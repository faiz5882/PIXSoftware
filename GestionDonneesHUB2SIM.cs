using System;
using System.Collections.Generic;
using System.Xml;
using System.Text;
using System.Drawing;
using System.Collections;
using System.Windows.Forms;
using Nevron.Chart.WinForm;
using Nevron.Chart;
using SIMCORE_TOOL.Prompt;
using Nevron.GraphicsCore;
using SIMCORE_TOOL.DataManagement;
using SIMCORE_TOOL.Classes;
using System.Data;
using SIMCORE_TOOL.com.crispico.gantt;
using System.IO;
using SIMCORE_TOOL.com.crispico.processFlow;
using SIMCORE_TOOL.com.crispico.dashboard;
using SIMCORE_TOOL.Prompt.Athens;
using SIMCORE_TOOL.Prompt.Dubai;
using SIMCORE_TOOL.Prompt.Liege;
using SIMCORE_TOOL.com.crispico.generalUse;
using SIMCORE_TOOL.Prompt.Dubai.P2S_Allocation;
using SIMCORE_TOOL.com.crispico.BHS_Analysis;
using SIMCORE_TOOL.com.crispico.documentTreeNode;
using SIMCORE_TOOL.com.crispico.EBS;
using SIMCORE_TOOL.com.crispico.FlightPlansUtils;

namespace SIMCORE_TOOL
{
    #region La classe GestionDonneesHUB2SIM
    /// <summary>
    /// Cette classe contient l'intégralité des informations concernant un projet ouvert dans PAX2SIM / SIMREPORTER.
    /// </summary>
    public class GestionDonneesHUB2SIM
    {

        #region La classe qui gère les dépendances des allocations.
        private class AllocationDependances
        {
            private Dictionary<String,Boolean> htTables;
            private bool _AirportStructure;
            #region Le constructeur + la classe d'initialisation
            public AllocationDependances()
            {
                htTables = new Dictionary<String, Boolean>();
                _AirportStructure = true;
            }
            public void addDependance(String NomTable)
            {
                htTables.Add(NomTable, true);
            }
            #endregion
            public void SetModification(bool bValue)
            {
                List<String> lsKey = new List<string>(htTables.Keys);
                foreach (String key in lsKey)
                {
                    htTables[key] = bValue;
                }
                _AirportStructure = bValue;
            }
            public void HadBeenModified(String NomTable)
            {
                if (!htTables.ContainsKey(NomTable))
                    return;
                htTables[NomTable] = true;
            }
            public void HadBeenRecalculated()
            {
                SetModification(false);
            }
            public bool HasToBeRecalculated()
            {
                foreach (String keys in htTables.Keys)
                {
                    if ((bool)htTables[keys])
                        return true;
                }
                return _AirportStructure;
            }
            public void SetAirportStructureHadBeenModified()
            {
                _AirportStructure = true;
            }
        }
        #endregion

        #region Les différentes variables statiques de la classe
        /// <summary>
        /// Liste d'erreurs apparues durant l'exécution des fonctions de calculs
        /// </summary>
        private static ArrayList ListeErreurs;
#if(NEWALLOCATIONSECU)
        // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
        /// <summary>
        /// The variable holds the current version for the Pax2Sim files. 
        /// It will be updated when one of the files changes its structure.
        /// </summary>
        internal static VersionManager sCurrentVersion = new VersionManager(GlobalNames.currentProjectVersion);
        // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
#else
        internal static VersionManager sCurrentVersion = new VersionManager("1.52");
#endif
        #endregion

        #region Les différentes variables de la classe.

        private string nomOldSavingPath;

        /// <summary>
        /// Nom absolu du chemin menant au dossier du projet.
        /// </summary>
        private string nomDuChemin;
        /// <summary>
        /// Nom du fichier Pax qu'il faut charger.
        /// </summary>
        private string nomFichierProjetPax;
        /// <summary>
        /// Nom du projet courant.
        /// </summary>
        private string nomProjetPax;

        public String getNomDuChemin()  // >> Task #12843 Pax2Sim - Dubai - allocate using Cplex : was private
        {
            if (nomOldSavingPath != nomDuChemin)
                return nomOldSavingPath;
            return nomDuChemin;
        }


        /// <summary>
        /// Directory that is usualy used for the saving
        /// </summary>
        private string BAKProject
        {
            get
            {
                return nomDuChemin + ".bak";
            }
        }

        /// <summary>
        /// Tempory saving directory
        /// </summary>
        private string BAK2Project
        {
            get
            {
                return nomDuChemin + ".bak2";
            }
        }

        #region Les variables pour les unités de mesures de l'application (temps et distance)
        private String DistanceUnit_;
        private String DistanceInitial_;
        private String TimeUnit_;
        private String TimeInitial_;
        private Double Speed_;
        private Double Tolerance_;
        private Double AllocationStep_;
        private Double[] Levels_;

        public String DistanceUnit
        {
            get
            {
                return DistanceUnit_;
            }
            set
            {
                if (value != DistanceUnit_)
                    hadBeenSaved = false;
                DistanceUnit_ = value;
            }
        }
        public String DistanceInitial
        {
            get
            {
                return DistanceInitial_;
            }
            set
            {
                if (value != DistanceInitial_)
                    hadBeenSaved = false;
                DistanceInitial_ = value;
            }
        }
        public String TimeUnit
        {
            get
            {
                return TimeUnit_;
            }
            set
            {
                if (value != TimeUnit_)
                    hadBeenSaved = false;
                TimeUnit_ = value;
            }
        }
        public String TimeInitial
        {
            get
            {
                return TimeInitial_;
            }
            set
            {
                if (value != TimeInitial_)
                    hadBeenSaved = false;
                TimeInitial_ = value;
            }
        }
        public Double Speed
        {
            get
            {
                return Speed_;
            }
            set
            {
                if (value != Speed_)
                    hadBeenSaved = false;
                Speed_ = value;
            }
        }
        public Double Tolerance
        {
            get
            {
                return Tolerance_;
            }
            set
            {
                if (value != Tolerance_)
                    hadBeenSaved = false;
                Tolerance_ = value;
            }
        }
        public Double AllocationStep
        {
            get
            {
                return AllocationStep_;
            }
            set
            {
                bool bIsModified = false;
                if (value != AllocationStep_)
                {
                    hadBeenSaved = false;
                    bIsModified = true;
                }
                AllocationStep_ = value;
                if (bIsModified)
                    AirportStructureChange();
            }
        }
        public Double[] Levels
        {
            get
            {
                return Levels_;
            }
            set
            {
                Levels_ = value;
            }
        }
        #endregion
        // >> Task #15088 Pax2Sim - BHS Analysis - Times and Indexes
        public List<AnalysisResultFilter> globalBasicAnalysisResultFilterList = new List<AnalysisResultFilter>();
        public List<AnalysisResultFilter> globalAdvancedAnalysisResultFilterList = new List<AnalysisResultFilter>();
        public List<AnalysisResultFilter> globalCustomAnalysisResultFilterList = new List<AnalysisResultFilter>();
        // << Task #15088 Pax2Sim - BHS Analysis - Times and Indexes
        /// <summary>
        /// Booléens servant à savoir si le projet a été enregistré ou non.
        /// </summary>
        private bool hadBeenSaved;
        private bool HadAlreadyBeenSavedOnDisk;

        public bool setAEteEnregistre
        {
            set
            {
                hadBeenSaved = value;
            }
        }

        /// <summary>
        /// Un booléen indiquant si la structure de l'aéroport a été modifié 
        /// depuis les dernier calculs d'allocation
        /// </summary>
        private bool bAirportStructureHadBeenModified;

        private DataManagement.DataManagerInput dmiInputData;
        private Dictionary<String,DataManagement.DataManagerScenario> dmsScenarios;


        /// <summary>
        /// \deprecated
        /// La variable contenant toutes les données d'entrées. (les différentes tables).
        /// </summary>
        private Dictionary<String,GestionDonnees> Data;

        /// <summary>
        /// \deprecated
        /// La variable qui contient toutes les informations relativers à un scénario, 
        /// les données utilisées pour chacun des calculs par exemple.
        /// </summary>
        private Dictionary<String, Classes.ParamScenario> htScenarios;

        /// <summary>
        /// Variable contenant tous les graphiques généraux.
        /// </summary>
        private Dictionary<String, GraphicFilter> htGraphiques;

        /// <summary>
        /// This dictionnary recolt all the filter that are made on graphics filters. These filters
        /// are only made on graphics that are already existing.
        /// </summary>
        private Dictionary<String, Filter> dsfGraphiquesFilters;

        /// <summary>
        /// Liste contenant toutes les notes générales de ce projet. (Notes sur les filres)
        /// </summary>
        private Dictionary<String, String> lsNotes;

        /// <summary>
        /// Liste contenant tous les paragrapges qui peuvent être ajoutés à des rapports.
        /// </summary>
        private Dictionary<String, Paragraph> lsParagraph;

        /// <summary>
        /// Structures de l'aéroport utilisé durant la sauvegarde et pour les calculs et la mise à jour de certaines tables.
        /// </summary>
        private XmlNode structureAeroport;

        private XmlDocument projet;

        private Dictionary<String,AllocationDependances> htAllocationDependances = null;

        private bool bUseAlphNumericForFlightInfo = false;

        internal bool UseAlphaNumericForFlightInfo
        {
            get
            {
                return bUseAlphNumericForFlightInfo;
            }
            set
            {
                if (value != bUseAlphNumericForFlightInfo)
                    ChangeAlphaNumericalChecks(value);
            }
        }
        internal bool getAlphaNumericValue()
        {
            return bUseAlphNumericForFlightInfo;
        }

        //private static Hashtable htChecks = null;

        internal Dictionary<string, ReportParameters> htReportParametres_ = null;
        public Dictionary<string, ReportParameters> htReportParametres
        {
            get { return htReportParametres_; }
            set { htReportParametres_ = value; }
        }

        internal List<string> documentTableNames = new List<string>();  // >> Task #16578 PAX2SIM - Documents - new node in main tree-view

        #region variables PDF
        private double bigTitleFontSize = 25.0;
        private String bigTitleFont = "Helvetica"; //"Times-Roman";//"Courier";
        private double titleFontSize = 13.0;
        private String titleFont = "Helvetica";
        private double textFontSize = 9.0;
        private String textFont = "Helvetica";
        #endregion


        #endregion

        #region les définitions des tables globales et statiques permettant de définir les tables toujours présentes.

        #region Variables statiques contenant tous les noms globaux.

        internal static String sTableBagPlan = "BagPlan";


        private static String sPaxCapacityAnalysis = "Pax Capacity Analysis";
        public static String sPeakFlows = "Peak Flows";
        public static String sBHSAnalysis = "Baggage Handling System";
        public static String sScenarioCustomGraphic = "User Graphics";

        public static String sHub2simModel = "hub2sim";
        // balise image pour la génération de l'arbre dépliable en HTML
        public static String imgJoin = "<img src=\"Images\\arbo_join.gif\" alt=\"\" />"; // jonction
        public static String imgJoinBottom = "<img src=\"Images\\arbo_joinbottom.gif\" alt=\"\" />"; // fin de liste
        public static String imgMinus = "<img src=\"Images\\arbo_minus.gif\" alt=\"[-]\" class=\"clic\" onclick=\"expand(this.parentNode)\" />"; // losqu'il contient une liste qui doit se deplier


        #endregion

        #region Les noms des tables et une breve description de chacune.

        public static Int32[] ListeSeparation = null;
        public static String[] ListeNomsSeparation = null;
        public static String[] ListeNomsCompletsSeparation = null;

        public String[] ListeNomTable = null;
        public String[] ListeNomsCompletsTables = null;
        /// <summary>
        /// Liste des index de 
        /// </summary>
        public int[] tiIndexTableDansListe = null;


        #region PAX


        //Définition de la liste des noms des tables contenues dans le dataSet. Il s'agit d'une norme, et elle
        //est également utilisée dans le système de sauvegarde d'un projet PAX2SIM.
        public static string[] ListeNomTablePAX = new String[]{
                                GlobalNames.FPATableName,               //1
                                GlobalNames.FPDTableName,               //2
                                GlobalNames.FPLinksTableName,           //3
                                GlobalNames.FP_AircraftTypesTableName,  //4
                                GlobalNames.FP_AirlineCodesTableName,   //5
                                GlobalNames.FP_AirportCodesTableName,   //6
                                GlobalNames.FP_FlightCategoriesTableName,//7	
                                GlobalNames.FPA_LoadFactorsTableName,   //8
                                GlobalNames.FPD_LoadFactorsTableName,   //9

                                GlobalNames.Transfer_ICTTableName,      //10
                                GlobalNames.Transfer_TerminalDitributionTableName,//11

                                GlobalNames.Transfer_FlightCategoryDitributionTableName,//12
                                GlobalNames.CI_ShowUpTableName,         //13
                                GlobalNames.NbBagsTableName	,           //14
                                GlobalNames.NbVisitorsTableName,	    //15
                                GlobalNames.NbTrolleyTableName,         //15

                                GlobalNames.OCT_BaggageClaimTableName,	//17	
                                GlobalNames.Alloc_BaggageClaimTableName,//18 	
                                GlobalNames.OCT_CITableName,            //19
                                GlobalNames.Alloc_CITableName,	        //20
                                GlobalNames.Opening_CITableName,        //21
	                            GlobalNames.OCT_BaggDropTableName,      //22 bagDrop
                                GlobalNames.OCT_BoardGateTableName,		//23
                                GlobalNames.Alloc_BoardGateTableName,   //24
	                            GlobalNames.OCT_ArrivalGateTableName,		//25 arrGate

                                GlobalNames.OCT_ParkingTableName,	    //26
                                GlobalNames.Alloc_ParkingTableName,     //27
	                            GlobalNames.OCT_RunwayTableName,    //28 runway
                                GlobalNames.Alloc_PassportCheckTableName,   //29		
                                GlobalNames.Alloc_SecurityCheckTableName,   //30
                                GlobalNames.Alloc_UserProcessCheckTableName,  //31  // << Task #7570 new Desk and extra information for Pax -Phase I B
                                GlobalNames.Alloc_TransferDeskTableName	,	    //32

                                GlobalNames.OCT_MakeUpTableName,            //33
                                GlobalNames.SegregationName,                //34
                                GlobalNames.OCT_ArrivalInfeedTableName,     //35 arrInf
                                GlobalNames.TransferInfeedAllocationRulesTableName, //36
                                GlobalNames.Baggage_Claim_ConstraintName,   //37

                                GlobalNames.Capa_QueuesTableName,       //38
                                GlobalNames.Group_QueuesName,           //39
                                GlobalNames.Animated_QueuesName,        //40
                                GlobalNames.Times_ProcessTableName,	    //41
                                GlobalNames.ItineraryTableName,         //42
                                GlobalNames.ProcessScheduleName,	    //43
                                GlobalNames.ParkingTableName,	        //44
                                GlobalNames.FromToShuttleTableName,		//45
                                GlobalNames.OneofSpecificationTableName	    //46
                            };

        /// <summary>
        /// Les index des tables marquant les séparations.
        /// </summary>

        public static String[] ListeNomsCompletsTablesPAX = { 
                                                           "Arrival Flight Plans", 
                                                           "Departure Flight Plans", 
            
                                                           "Aircraft Links",
                                                           "Aircraft Types",
                                                           "Airline Codes", 
                                                           "Airport Codes",
                                                           "Flight Categories", 
                                                           "Arrival Load Factors",
                                                           "Departure Load Factors", 

                                                           "Transfer InterConnecting Times", 
                                                           "Transfer Terminal Distribution",
                                                           "Transfer Flight Category Distribution",
                                                           "CI Show-Up Distribution", 
                                                           "Bags Distribution", 
                                                           "Visitors Distribution", 
                                                           "Trolley Distribution",


                                                           "Baggage Claim (Open/Close Times)", 
                                                           "Baggage Claim (Allocation)", 
                                                           "Check-In (Open/Close Times)",
                                                           "Check-In (Allocation)", 
                                                           "Check-In (Opening)",
                                                           "Baggage Drop (Open/Close Times)",   //22 //bagDrop
                                                           "Boarding Gates (Open/Close Times)", 
                                                           "Boarding Gates (Allocation)",
                                                           "Arrival Gates (Open/Close Times)",  //25 arrGate
                                                           "Parking (Open/Close Times)", 
                                                           "Parking (Allocation)",
                                                           "Runway (Open/Close Times)", //28 //runway
                                                           "Passport Check (Planning)",
                                                           "Security Check (Planning)",
                                                           "User Process (Planning)",// << Task #7570 new Desk and extra information for Pax -Phase I B
                                                           "Transfer desks (Planning)",
                                                           "Make-Up (Open/Close Times)",
                                                           "Segregation",
                                                           "Arrival Infeed (Open/Close Times)", //33 //arrInf
                                                           "Transfer Infeed (Open/Close Times)",
                                                           "Baggage Claim Constraint",
                                                           "Process Queues (Capacities)",
                                                           "Group Queues (Capacities)",
                                                           "Animated Queues",
        
                                                           "Pax Process Times", 
                                                           "Pax Itinerary",
                                                           GlobalNames.sTableProcessScheduleLong,
                                                           "Parking",
                                                           "From - To - Shuttle", 
            
                                                           "Probability Profiles"};
        public static Boolean[] ListeTablePAXSauvegardee = { true, 
                                                 true, 
            
                                                 true, 
                                                 true, 
                                                 true, 
                                                 true,   
                                                 true, 
                                                 true, 
                                                 true,  //9

                                                 true, 
                                                 true, 
                                                 true,  
                                                 true, 
                                                 true, 
                                                 true, 
                                                 true,  //16  


                                                 true, 
                                                 false,
                                                 true, 
                                                 false,
                                                 true,
                                                 true,  //22 //bagDrop
                                                 true, 
                                                 false,
                                                 true, //25 //arrGate
                                                 true, 
                                                 false,
                                                 true, //28 //runway
                                                 true, 
                                                 true, 
                                                 true, // << Task #7570 new Desk and extra information for Pax -Phase I B
                                                 true, 
                                                 true, 
                                                 true, //34 //arrInf
                                                 true, 
                                                 true, 
                                                 PAX2SIM.bDebug, 
                                                 true, 
                                                 true, 
                                                 true,  //40

                                                 true, 
                                                 true, 
                                                 true, 
                                                 true, 
                                                 true, 

                                                 true};
        public static Boolean[] ListeTablePAXVisible = { true, 
                                                 true, 
                                                 true, 
                                                 true, 
                                                 true, 
                                                 true,   
                                                 true, 
                                                 true, 
                                                 true,  //9

                                                 true, 
                                                 true, 
                                                 true,  
                                                 true, 
                                                 true, 
                                                 true, 
                                                 true,   //16


                                                 true, 
                                                 true,  
                                                 true,
                                                 true, 
                                                 true, 
                                                 true, //22 //bagDrop
                                                 true, 
                                                 true,  
                                                 true, //25 //arrGate
                                                 true, 
                                                 true,  
                                                 true, //28 //runway
                                                 true, 
                                                 true,   
                                                 true, // << Task #7570 new Desk and extra information for Pax -Phase I B
                                                 true, 
                                                 true,
                                                 true,  //34 //arrInf
                                                 true, 
                                                 true, 
                                                 PAX2SIM.bDebug,  
                                                 true, 
                                                 true, 
                                                 true,  //40

                                                 true, 
                                                 true, 
                                                 true, 
                                                 false, 
                                                 false, 

                                                 true};
        #endregion

        #region BHS

        public static string[] ListeNomTablesBHS_Racine = {
                                                GlobalNames.sBHS_Capa_Queues,
                                                GlobalNames.sBHS_Group_Queues,
                                                GlobalNames.sBHS_Itinerary
                                                };
        public static string[] ListeNomCompletsTablesBHS_Racine = {
                                                "BHS Process Queues (Capacities)",
                                                "BHS Group Queues (Capacities)",
                                                "BHS Itinerary table"
                                                };
        public static string[] ListeNomTableBHS = { GlobalNames.sBHS_General,
                                                    GlobalNames.sBHS_ArrivalInfeed_Groups,
                                                    GlobalNames.sBHS_CI_Groups,
                                                    GlobalNames.sBHS_TransferInfeed_Groups,
                                                    GlobalNames.sBHS_CI_Collectors,
                                                    GlobalNames.sBHS_CI_Routing,
                                                    GlobalNames.sBHS_HBS3_Routing,
                                                    GlobalNames.sBHS_Transfer_Routing,
                                                    GlobalNames.sBHS_Flow_Split,
                                                    GlobalNames.sBHS_Process,
                                                    /*"OCT_MakeUp",*/
                                                    GlobalNames.sBHS_Alloc_MakeUp,
                                                    GlobalNames.sBHS_Arrival_Containers,
                                                    GlobalNames.sBHS_Mean_Flows_Arrival_Infeed,
                                                    GlobalNames.sBHS_Mean_Flows_Check_In,
                                                    GlobalNames.sBHS_Mean_Flows_Transfer_Infeed
                                                };
        public static String[] ListeNomTableCompletsBHS = new String[]{
                                                  "General BHS Information",
                                                  "Arrival Infeed Groups",
                                                  "Check-In Groups",
                                                  "Transfer Infeed Groups",
                                                  "Check-In Collectors",
                                                  "Check-In Routing",
                                                  "HBS3 Routing",
                                                  "Transfer Routing",
                                                  "Flow Split",
                                                  "Process",
                                                  /*"Make-Up (Open/Close Times)",*/
                                                  "Make-Up (Allocation)",
                                                  "Arrival Containers",
                                                  "Mean Flows - Arrival Infeed",
                                                  "Mean Flows - Check In",
                                                  "Mean Flows - Transfer Infeed"
                                                };

        #endregion

        #endregion

        public List<int> liTerminalBHS = null;
        private static PAX2SIM.EnumPerimetre epPerimeter = PAX2SIM.EnumPerimetre.PAX;

        #region Définition des Conventions de nommage
        internal const int TerminalLevelEntry = 0;
        internal const int CheckInGroup = 1;
        internal const int PassportCheckGroup = 2;
        internal const int SecurityCheckGroup = 3;
        internal const int ArrivalGateGroup = 4;
        internal const int BaggageClaimGroup = 5;
        internal const int TransferGroup = 6;
        internal const int ShuttleGroup = 7;
        internal const int BoardingGateGroup = 8;
#if(PAXINOUTUTILISATION)
        internal const int ModelInGroup = 9;
        internal const int ModelOutGroup = 10;

        
#if(SHOPSUTILISATION)

        internal const int ShoppingAreaGroup = 11;
        internal const int CheckIn = 12;
        internal const int PassportCheck = 13;
        internal const int SecurityCheck = 14;
        internal const int ArrivalGate = 15;
        internal const int BaggageClaim = 16;
        internal const int Transfer = 17;
        internal const int Shuttle = 18;
        internal const int BoardingGate = 19;
        internal const int ModelIn = 20;
        internal const int ModelOut = 21;
        internal const int ShoppingArea = 22;

        internal const int LastGroupIndex = ShoppingAreaGroup;
#else
        internal const int CheckIn = 11;
        internal const int PassportCheck = 12;
        internal const int SecurityCheck = 13;
        internal const int ArrivalGate = 14;
        internal const int BaggageClaim = 15;
        internal const int Transfer = 16;
        internal const int Shuttle = 17;
        internal const int BoardingGate = 18;
        internal const int ModelIn = 19;
        internal const int ModelOut = 20;

        internal const int ShoppingArea = 22;
        internal const int ShoppingAreaGroup = 23;

        internal const int LastGroupIndex = ModelOutGroup;
#endif
#else
        internal const int ModelInGroup = 17;
        internal const int ModelOutGroup = 18;

        internal const int CheckIn = 9;
        internal const int PassportCheck = 10;
        internal const int SecurityCheck = 11;
        internal const int ArrivalGate = 12;
        internal const int BaggageClaim = 13;
        internal const int Transfer = 14;
        internal const int Shuttle = 15;
        internal const int BoardingGate = 16;
        internal const int ModelIn = 19;
        internal const int ModelOut = 20;

        internal const int ShoppingArea = 22;
        internal const int ShoppingAreaGroup = 23;

        internal const int LastGroupIndex =BoardingGateGroup;
#endif
        internal const int BHS_CONST_ArrivalInfeedGroup = 1;
        internal const int BHS_CONST_TransferInfeedGroup = 2;
        internal const int BHS_CONST_ArrHBSGroup = 3;
        internal const int BHS_CONST_BaggageClaimGroup = 4;
        internal const int BHS_CONST_CustomGroup = 5;
        internal const int BHS_CONST_CheckInGroup = 6;
        internal const int BHS_CONST_HBS1Group = 7;
        internal const int BHS_CONST_HBS2Group = 8;
        internal const int BHS_CONST_HBS3Group = 9;
        internal const int BHS_CONST_HBS4Group = 10;
        internal const int BHS_CONST_HBS5Group = 11;
        internal const int BHS_CONST_MESGroup = 12;
        internal const int BHS_CONST_EBSGroup = 13;
        internal const int BHS_CONST_MakeUpGroup = 14;
        internal const int BHS_CONST_CheckInCollectorGroup = 15;
        // << Task #7570 new Desk and extra information for Pax -Phase I B
        internal const int BHS_CONST_UserProcessGroup = 16;
        internal const int BHS_CONST_UserProcessObject = 17;
        // >> Task #7570 new Desk and extra information for Pax -Phase I B


        internal const String BHS_String_ArrivalInfeedGroup = "Arrival Infeed Group";
        internal const String BHS_String_TransferInfeedGroup = "Transfer Infeed Group";
        /*internal const String BHS_String_ArrHBSGroup = "";
        internal const String BHS_String_BaggageClaimGroup = "";
        internal const String BHS_String_CustomGroup = "";
        internal const String BHS_String_CheckInGroup = "";
        internal const String BHS_String_HBS1Group = "";
        internal const String BHS_String_HBS2Group = "";
        internal const String BHS_String_HBS3Group = "";
        internal const String BHS_String_HBS4Group = "";
        internal const String BHS_String_HBS5Group = "";
        internal const String BHS_String_MESGroup = "";
        internal const String BHS_String_EBSGroup = "";
        internal const String BHS_String_MakeUpGroup = "";
        internal const String BHS_String_CheckInCollectorGroup = "";*/

        public const int Constant = 1;
        public const int Uniform = 2;
        public const int Normal = 3;
        public const int Triangular = 4;
        public const int Exponential = 5;

        public const int Gamma = 6;
        public const int LogNormal = 7;
        public const int Weibull = 8;

        public const int StartingIndexOneof = 10;

        public static String[] DistributionsNames = { "Constant", "Uniform", "Normal", "Triangular", "Exponential", "Gamma", "LogNormal", "Weibull", "Probability profile" };
        #endregion

        #region Définition de la taille du modèle Automod.
        public static Dictionary<String, Int32> htSizeAutomodModel;

        public static Int32 NbTerminaux = 6;
        public static Int32 NbLevels = 5;
        public static Int32 NbTypes = LastGroupIndex;
        public static Int32 NbGroupes = 100;
        public static Int32 NbCheckInDesks = 300;
        public static Int32 NbDesks = 200;

        internal static Int32 NBScenarios = 3;
        internal static Int32 CI_ShowUpMax = 240;

        #endregion

        public static Hashtable htSizeTable;

        #region Liste des entêtes des tables

        #region Les tables Pour la partie passager.



        /*Liste des entêtes des tables utilisées comme table de chargement. Ceci est utile pour définir
          les tables lorsque le fichier associé est inexistant. Elles permettent
          également de vérifier que les tables sont bien chargées.*/

        #region FPDTable
        public static String[] ListeEntete_FPDTable = { GlobalNames.sFPD_A_Column_ID, 
                                                        GlobalNames.sFPD_A_Column_DATE, 
                                                        GlobalNames.sFPD_Column_STD, 
                                                        GlobalNames.sFPD_A_Column_AirlineCode, 
                                                        GlobalNames.sFPD_A_Column_FlightN, 
                                                        GlobalNames.sFPD_A_Column_AirportCode, 
                                                        GlobalNames.sFPD_A_Column_FlightCategory, 
                                                        GlobalNames.sFPD_A_Column_AircraftType, 
                                                        GlobalNames.sFPD_Column_TSA,
                                                        GlobalNames.sFPD_A_Column_NbSeats,
                                                        GlobalNames.sFPD_Column_TerminalCI, 
                                                        GlobalNames.sFPD_Column_Eco_CI_Start, 
                                                        GlobalNames.sFPD_Column_Eco_CI_End, 
                                                        GlobalNames.sFPD_Column_FB_CI_Start, 
                                                        GlobalNames.sFPD_Column_FB_CI_End, 
            
                                                        GlobalNames.sFPD_Column_Eco_Drop_Start,
                                                        GlobalNames.sFPD_Column_Eco_Drop_End,
                                                        GlobalNames.sFPD_Column_FB_Drop_Start,
                                                        GlobalNames.sFPD_Column_FB_Drop_End,
                                                        GlobalNames.sFPD_A_Column_TerminalGate, 
                                                        GlobalNames.sFPD_Column_BoardingGate ,

                                                        GlobalNames.sFPD_Column_TerminalMup, 
                                                        GlobalNames.sFPD_Column_Eco_Mup_Start,
                                                        GlobalNames.sFPD_Column_Eco_Mup_End ,
                                                        GlobalNames.sFPD_Column_First_Mup_Start,
                                                        GlobalNames.sFPD_Column_First_Mup_End ,
                                                        GlobalNames.sFPD_A_Column_TerminalParking,

                                                        GlobalNames.sFPD_A_Column_Parking,
                                                        GlobalNames.sFPD_A_Column_RunWay,
                                                        GlobalNames.sFPD_A_Column_User1,
                                                        GlobalNames.sFPD_A_Column_User2,
                                                        GlobalNames.sFPD_A_Column_User3,
                                                        GlobalNames.sFPD_A_Column_User4,
                                                        GlobalNames.sFPD_A_Column_User5};
        internal static Type[] ListeTypeEntete_FPDTable = { System.Type.GetType("System.Int32"), 
                                                            System.Type.GetType("System.DateTime"), 
                                                            System.Type.GetType("System.TimeSpan"), 
                                                            typeof(String), 
                                                            typeof(String) ,
                                                            typeof(String) ,
                                                            typeof(String) ,
                                                            typeof(String) ,
                                                            System.Type.GetType("System.Boolean"), 
                                                            System.Type.GetType("System.Int32"), 
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String)};
        /*public static Type[] ListeTypeEntete_FPDTable = { System.Type.GetType("System.Int32"), 
                                                          System.Type.GetType("System.DateTime"), 
                                                          System.Type.GetType("System.TimeSpan"), 
                                                          typeof(String), 
                                                          typeof(String) ,
                                                          typeof(String) ,
                                                          typeof(String) ,
                                                          typeof(String) ,
                                                          System.Type.GetType("System.Boolean"), 
                                                          System.Type.GetType("System.Int32"), 
                                                          System.Type.GetType("System.Int32"), 
                                                          System.Type.GetType("System.Int32"), 
                                                          System.Type.GetType("System.Int32"), 
                                                          System.Type.GetType("System.Int32"), 
                                                          System.Type.GetType("System.Int32"), 
                                                          System.Type.GetType("System.Int32"), 
                                                          System.Type.GetType("System.Int32"), 
                                                          System.Type.GetType("System.Int32"), 
                                                          System.Type.GetType("System.Int32"), 
                                                          System.Type.GetType("System.Int32"), 
                                                          System.Type.GetType("System.Int32"),
                                                          System.Type.GetType("System.Int32"), 
                                                          System.Type.GetType("System.Int32"), 
                                                          System.Type.GetType("System.Int32"),
                                                          System.Type.GetType("System.Int32"),
                                                          System.Type.GetType("System.Int32"),
                                                          System.Type.GetType("System.Int32"),
                                                          typeof(String),
                                                          typeof(String),
                                                          typeof(String),
                                                          typeof(String),
                                                          typeof(String)};*/
        public static int[] ListePrimaryKey_FPDTable = { 0 };
        public static Object[] ListeDefault_FPDTable = { null, null, null, "", "", "", "", "", false, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "", "", "", "", "" };

        #endregion

        #region FPATable

        public static String[] ListeEntete_FPATable = { GlobalNames.sFPD_A_Column_ID, 
                                                        GlobalNames.sFPD_A_Column_DATE, 
                                                        GlobalNames.sFPA_Column_STA, 
                                                        GlobalNames.sFPD_A_Column_AirlineCode, 
                                                        GlobalNames.sFPD_A_Column_FlightN, 
                                                        GlobalNames.sFPD_A_Column_AirportCode, 
                                                        GlobalNames.sFPD_A_Column_FlightCategory, 
                                                        GlobalNames.sFPD_A_Column_AircraftType,
                                                        GlobalNames.sFPA_Column_NoBSM, 
                                                        GlobalNames.sFPA_Column_CBP,
                                                        GlobalNames.sFPD_A_Column_NbSeats, 
                                                        GlobalNames.sFPD_A_Column_TerminalGate, 
                                                        GlobalNames.sFPA_Column_ArrivalGate, 
                                                        GlobalNames.sFPA_Column_TerminalReclaim, 
                                                        GlobalNames.sFPA_Column_ReclaimObject,
                                                        GlobalNames.sFPA_Column_TerminalInfeedObject,
                                                        GlobalNames.sFPA_Column_StartArrivalInfeedObject,
                                                        GlobalNames.sFPA_Column_EndArrivalInfeedObject,
                                                        GlobalNames.sFPA_Column_TransferInfeedObject, 
                                                        GlobalNames.sFPD_A_Column_TerminalParking, 
                                                        GlobalNames.sFPD_A_Column_Parking, 
                                                        GlobalNames.sFPD_A_Column_RunWay ,
                                                        GlobalNames.sFPD_A_Column_User1,
                                                        GlobalNames.sFPD_A_Column_User2,
                                                        GlobalNames.sFPD_A_Column_User3,
                                                        GlobalNames.sFPD_A_Column_User4,
                                                        GlobalNames.sFPD_A_Column_User5};
        internal static Type[] ListeTypeEntete_FPATable = { typeof(Int32), 
                                                            typeof(DateTime), 
                                                            typeof(TimeSpan), 
                                                            typeof(String), 
                                                            typeof(String) ,
                                                            typeof(String) ,
                                                            typeof(String) ,
                                                            typeof(String) ,
                                                            typeof(Boolean),
                                                            typeof(Boolean),
                                                            typeof(Int32), 
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String)};
        /*public static Type[] ListeTypeEntete_FPATable = { typeof(Int32), 
                                                            typeof(DateTime), 
                                                            typeof(TimeSpan), 
                                                            typeof(String), 
                                                            typeof(String) ,
                                                            typeof(String) ,
                                                            typeof(String) ,
                                                            typeof(String) ,
                                                            typeof(Boolean),
                                                            typeof(Boolean),
                                                            typeof(Int32), 
                                                            typeof(Int32), 
                                                            typeof(Int32),
                                                            typeof(Int32), 
                                                            typeof(Int32), 
                                                            typeof(Int32), 
                                                            typeof(Int32), 
                                                            typeof(Int32), 
                                                            typeof(Int32), 
                                                            typeof(Int32), 
                                                            typeof(Int32), 
                                                            typeof(Int32), 
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String),
                                                            typeof(String)};*/
        public static int[] ListePrimaryKey_FPATable = { 0 };
        public static Object[] ListeDefault_FPATable =  { null, null, null, "", "", "", "", "", false, false, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "", "", "", "", "" };
        #endregion

        public static String[] ListeEntete_FP_LinksTable = {GlobalNames.sFPLinks_Column_FPAID,
                                                        GlobalNames.sFPLinks_Column_STA ,
                                                        GlobalNames.sFPLinks_Column_FPAName ,
                                                        GlobalNames.sFPLinks_Column_FPDID,
                                                        GlobalNames.sFPLinks_Column_STD ,
                                                        GlobalNames.sFPLinks_Column_FPDName,
                                                        GlobalNames.sFPLinks_Column_RotationDuration};
        public static Type[] ListeTypeEntete_FP_LinksTable = {
                                                        typeof(int) ,
                                                        typeof(DateTime),
                                                        typeof(String),
                                                        typeof(String) ,
                                                        typeof(String),
                                                        typeof(String),
                                                        typeof(String)
        };
        public static int[] ListePrimaryKey_FP_LinksTable = { 0 };

        public static String[] ListeEntete_FP_AircraftTypesTable = {GlobalNames.sFPAircraft_AircraftTypes, 
                                                        GlobalNames.sFPAircraft_Description,
                                                        GlobalNames.sFPAircraft_Wake,
                                                        GlobalNames.sFPAircraft_Body,
                                                        GlobalNames.sFPAircraft_NumberSeats, 
                                                        GlobalNames.sTableColumn_ULDLoose };

        public static Type[] ListeTypeEntete_FP_AircraftTypesTable = { typeof(String), typeof(String), typeof(String), typeof(String), System.Type.GetType("System.Int32"), typeof(String) };

     /*   public static Object[] ListeDefault_FP_AircraftTypesTable_1_28 = { "","","","", 0, sTableContent_ULD };*/
  /*      public static String[] ListeEntete_FP_AircraftTypesTable ={ GlobalNames.sFPAircraft_AircraftTypes, GlobalNames.sFPAircraft_NumberSeats, GlobalNames.sTableColumn_ULDLoose };
        public static Type[] ListeTypeEntete_FP_AircraftTypesTable = { typeof(String), System.Type.GetType("System.Int32"), typeof(String) };
*/        public static int[] ListePrimaryKey_FP_AircraftTypesTable = { 0 };

        public static String[] ListeEntete_FP_AirlineCodesTable ={ GlobalNames.sFPAirline_AirlineCode, GlobalNames.sFPAirline_Description, GlobalNames.sFPAirline_GroundHandlers };
        public static Type[] ListeTypeEntete_FP_AirlineCodesTable = { typeof(String), typeof(String), typeof(String) };
        public static int[] ListePrimaryKey_FP_AirlineCodesTable = { 0 };

        public static String[] ListeEntete_FP_AirportCodesTable ={ GlobalNames.sFPAirport_AirportCode, GlobalNames.sFPAirport_Description };
        public static Type[] ListeTypeEntete_FP_AirportCodesTable = { typeof(String), typeof(String) };
        public static int[] ListePrimaryKey_FP_AirportCodesTable = { 0 };

        public static String[] ListeEntete_FP_FlightCategoriesTable ={ GlobalNames.sFPFlightCategory_FC, GlobalNames.sFPFlightCategory_Description };
        public static Type[] ListeTypeEntete_FP_FlightCategoriesTable = { typeof(String), typeof(String) };
        public static int[] ListePrimaryKey_FP_FlightCategoriesTable = { 0 };

        public static String[] ListeEntete_FPD_LoadFactorsTable ={ "Select a category" };
        public static Type[] ListeTypeEntete_FPD_LoadFactorsTable = { typeof(String) };
        public static int[] ListePrimaryKey_FPD_LoadFactorsTable = { 0 };

        public static String[] ListeEntete_FPA_LoadFactorsTable ={ "Select a category" };
        public static Type[] ListeTypeEntete_FPA_LoadFactorsTable = { typeof(String) };
        public static int[] ListePrimaryKey_FPA_LoadFactorsTable = { 0 };

        public static String[] ListeEntete_Transfer_ICTTable ={ "Begin", "End" };
        public static Type[] ListeTypeEntete_Transfer_ICTTable = { System.Type.GetType("System.Int32"), System.Type.GetType("System.Int32") };
        public static int[] ListePrimaryKey_Transfer_ICTTable = { 0, 1 };

        public static String[] ListeEntete_Transfer_TerminalDistributionTable ={ "To" };
        public static Type[] ListeTypeEntete_TerminalDistributionTable = { typeof(String) };
        public static int[] ListePrimaryKey_TerminalDistributionTable = { 0 };

        public static String[] ListeEntete_Transfer_FlightCategoryDistributionTable ={ "To" };
        public static Type[] ListeTypeEntete_FlightCategoryDistributionTable = { typeof(String) };
        public static int[] ListePrimaryKey_FlightCategoryDistributionTable = { 0 };

        public static String[] ListeEntete_CI_ShowUpTable ={ "Begin", "End" };
        public static Type[] ListeTypeEntete_CI_ShowUpTable = { System.Type.GetType("System.Int32"), System.Type.GetType("System.Int32") };
        public static int[] ListePrimaryKey_CI_ShowUpTable = { 0, 1 };

        public static String[] ListeEntete_NbBagsTable ={ "NbBags" };
        public static Type[] ListeTypeEntete_NbBagsTable = { System.Type.GetType("System.Int32") };
        public static int[] ListePrimaryKey_NbBagsTable = { 0 };

        public static String[] ListeEntete_NbVisitorsTable ={ "NbVisitors" };
        public static Type[] ListeTypeEntete_NbVisitorsTable = { System.Type.GetType("System.Int32") };
        public static int[] ListePrimaryKey_NbVisitorsTable = { 0 };

        public static String[] ListeEntete_NbTrolleyTable ={ "NbBags", "NbTrolley" };
        public static Type[] ListeTypeEntete_NbTrolleyTable = { System.Type.GetType("System.Int32"), System.Type.GetType("System.Int32") };
        public static int[] ListePrimaryKey_NbTrolleyTable = { 0, 1 };

        public static String[] ListeEntete_Times_ProcessTable = { "Items", "Distrib_1", "Param1_1", "Param2_1", "Param3_1", "Distrib_2", "Param1_2", "Param2_2", "Param3_2" };
        public static Type[] ListeTypeEntete_Times_ProcessTable = { typeof(String), typeof(String), System.Type.GetType("System.Double"),
                                                                   System.Type.GetType("System.Double"), System.Type.GetType("System.Double"), typeof(String),
                                                                   System.Type.GetType("System.Double"), System.Type.GetType("System.Double"), System.Type.GetType("System.Double")};
        public static int[] ListePrimaryKey_Times_ProcessTable = { 0 };

        public static String[] ListeEntete_ItineraryTable = { "Group", "NextGroup", "Weight", "Distribution", "Param1", "Param2", "Param3" };
        public static Type[] ListeTypeEntete_ItineraryTable = { typeof(String),typeof(String), 
                                                                System.Type.GetType("System.Double"), typeof(String), 
                                                                System.Type.GetType("System.Double"),System.Type.GetType("System.Double"),
                                                                System.Type.GetType("System.Double")};

        public static int[] ListePrimaryKey_ItineraryTable = { 0, 1 };

        public static String[] ListeEntete_AircraftLinksTable ={ "FPA_ID", "FPD_ID" };
        public static Type[] ListeTypeEntete_AircraftLinksTable = { System.Type.GetType("System.Int32"), System.Type.GetType("System.Int32") };
        public static int[] ListePrimaryKey_AircraftLinksTable = { 0, 1 };

        public static String[] ListeEntete_ParkingTable ={ "Parking", "Shuttle" };
        public static Type[] ListeTypeEntete_ParkingTable = { typeof(String), System.Type.GetType("System.Boolean") };
        public static int[] ListePrimaryKey_ParkingTable = { 0 };

        public static String[] ListeEntete_FromToShuttleTable ={ "From/To" };
        public static Type[] ListeTypeEntete_FromToShuttleTable = { typeof(String) };
        public static int[] ListePrimaryKey_FromToShuttleTable = { 0 };

        public static String[] ListeEntete_OneofSpecificationTable ={ };
        public static Type[] ListeTypeEntete_OneofSpecificationTable = { };
        public static int[] ListePrimaryKey_OneofSpecificationTable = null;

        public static String[] ListeEntete_OCT_CITable ={ "Select a category" };
        public static Type[] ListeTypeEntete_OCT_CITable = { typeof(String) };
        public static int[] ListePrimaryKey_OCT_CITable = { 0 };

        public static String[] ListeEntete_Alloc_CITable ={ "Time" };
        public static Type[] ListeTypeEntete_Alloc_CITable = { System.Type.GetType("System.DateTime") };
        public static int[] ListePrimaryKey_Alloc_CITable = { 0 };

        public static String[] ListeEntete_Opening_CITable ={ "Time" };
        public static Type[] ListeTypeEntete_Opening_CITable = { System.Type.GetType("System.DateTime") };
        public static int[] ListePrimaryKey_Opening_CITable = { 0 };

        public static String[] ListeEntete_OCT_BoardGateTable ={ "Select a category" };
        public static Type[] ListeTypeEntete_OCT_BoardGateTable = { typeof(String) };
        public static int[] ListePrimaryKey_OCT_BoardGateTable = { 0 };

        public static String[] ListeEntete_Alloc_BoardGateTable ={ "Time" };
        public static Type[] ListeTypeEntete_Alloc_BoardGateTable = { System.Type.GetType("System.DateTime") };
        public static int[] ListePrimaryKey_Alloc_BoardGateTable = { 0 };

        public static String[] ListeEntete_OCT_BaggageClaimTable ={ "Select a category" };
        public static Type[] ListeTypeEntete_OCT_BaggageClaimTable = { typeof(String) };
        public static int[] ListePrimaryKey_OCT_BaggageClaimTable = { 0 };

        public static String[] ListeEntete_Alloc_BaggageClaimTable ={ "Time" };
        public static Type[] ListeTypeEntete_Alloc_BaggageClaimTable = { System.Type.GetType("System.DateTime") };
        public static int[] ListePrimaryKey_Alloc_BaggageClaimTable = { 0 };

        public static String[] ListeEntete_OCT_ParkingClaimTable ={ "Select a category" };
        public static Type[] ListeTypeEntete_OCT_ParkingClaimTable = { typeof(String) };
        public static int[] ListePrimaryKey_OCT_ParkingClaimTable = { 0 };

        public static String[] ListeEntete_Alloc_ParkingClaimTable ={ "Time" };
        public static Type[] ListeTypeEntete_Alloc_ParkingClaimTable = { System.Type.GetType("System.DateTime") };
        public static int[] ListePrimaryKey_Alloc_ParkingClaimTable = { 0 };

        public static String[] ListeEntete_Alloc_PassportCheckTable ={ "Time" };
        public static Type[] ListeTypeEntete_Alloc_PassportCheckTable = { System.Type.GetType("System.DateTime") };
        public static int[] ListePrimaryKey_Alloc_PassportCheckTable = { 0 };

        public static String[] ListeEntete_Alloc_SecurityCheckTable ={ "Time" };
        public static Type[] ListeTypeEntete_Alloc_SecurityCheckTable = { System.Type.GetType("System.DateTime") };
        public static int[] ListePrimaryKey_Alloc_SecurityCheckTable = { 0 };

        public static String[] ListeEntete_Alloc_TransferDeskTable = { "Time" };
        public static Type[] ListeTypeEntete_Alloc_TransferDeskTable = { System.Type.GetType("System.DateTime") };
        public static int[] ListePrimaryKey_Alloc_TransferDeskTable = { 0 };

        public static String[] ListeEntete_OCT_OCT_MakeUp ={ "Select a category" };
        public static Type[] ListeTypeEntete_OCT_OCT_MakeUp = { typeof(String) };
        public static int[] ListePrimaryKey_OCT_OCT_MakeUp = { 0 };

        public static String[] ListeEntete_SegregationTable ={ "Segregation" };
        public static Type[] ListeTypeEntete_SegregationTable = { System.Type.GetType("System.Int32") };
        public static int[] ListePrimaryKey_SegregationTable = { 0 };

        public static String[] ListeEntete_OCT_TransferInfeedAllocationRulesTable ={ "Select a category" };
        public static Type[] ListeTypeEntete_OCT_TransferInfeedAllocationRulesTable = { typeof(String) };
        public static int[] ListePrimaryKey_OCT_TransferInfeedAllocationRulesTable = { 0 };

        public static String[] ListeEntete_BaggageClaimConstraintTable ={ "Select a category" };
        public static Type[] ListeTypeEntete_BaggageClaimConstraintTable = { typeof(String) };
        public static int[] ListePrimaryKey_BaggageClaimConstraintTable = { 0 };

        public static String[] ListeEntete_Capa_QueuesTable = { "Element", "Queue Capacity" };
        public static Type[] ListeTypeEntete_Capa_QueuesTable = { typeof(String), System.Type.GetType("System.Int32") };
        public static int[] ListePrimaryKey_Capa_QueuesTable = { 0 };

        public static String[] ListeEntete_Animated_QueuesTable = { "Name", "Value" };
        public static Type[] ListeTypeEntete_Animated_QueuesTable = { typeof(String), typeof(Int32) };
        public static int[] ListePrimaryKey_Animated_QueuesTable = { 0 };

        public static String[] ListeEntete_GroupsQueuesTable = { "Element", "Queue Capacity" };
        public static Type[] ListeTypeEntete_GroupsQueuesTable = { typeof(String), System.Type.GetType("System.Int32") };
        public static int[] ListePrimaryKey_GroupsQueuesTable = { 0 };
        
        // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
        //added the CapaProcessTable for the ProcessSchedule links
        public static String[] ListeEntete_ProcessScheduleTable = { "Begin", "End", GlobalNames.sTableProcessScheduleItinerary,
                                                                      GlobalNames.sTableProcessScheduleProcess,
                                                                      GlobalNames.sTableProcessScheduleGroupQueues,
                                                                      GlobalNames.sTableProcessScheduleProcessQueues,
                                                                      GlobalNames.sTableProcessScheduleProcessCapacity};
        public static Type[] ListeTypeEntete_ProcessScheduleTable = { typeof(DateTime), typeof(DateTime), typeof(String),
                                                                        typeof(String),
                                                                        typeof(String),
                                                                        typeof(String),
                                                                        typeof(String)};
        public static int[] ListePrimaryKey_ProcessScheduleTable = { 0 };        
        public static String[] ListeTableLinks_ProcessScheduleTable = { "", "", GlobalNames.ItineraryTableName,
                  GlobalNames.Times_ProcessTableName, GlobalNames.Group_QueuesName, GlobalNames.Capa_QueuesTableName,
                  GlobalNames.capaProcessTableName};
        // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)       
        
        // << Task #7570 new Desk and extra information for Pax -Phase I B
        public static String[] ListeEntete_Alloc_UserProcessCheckTable = { "Time" };
        public static Type[] ListeTypeEntete_Alloc_UserProcessCheckTable = { System.Type.GetType("System.DateTime") };
        public static int[] ListePrimaryKey_Alloc_UserProcessCheckTable = { 0 };
        // >> Task #7570 new Desk and extra information for Pax -Phase I B

        // >> Bug #13146 Pax2Sim - load old projects v1.29
        public static String[] ListeEntete_OCT_BagDropTable = { "Select a category" };
        public static Type[] ListeTypeEntete_OCT_BagDropTable = { typeof(String) };
        public static int[] ListePrimaryKey_OCT_BagDropTable = { 0 };

        public static String[] ListeEntete_OCT_ArrGateTable = { "Select a category" };
        public static Type[] ListeTypeEntete_OCT_ArrGateTable = { typeof(String) };
        public static int[] ListePrimaryKey_OCT_ArrGateTable = { 0 };

        public static String[] ListeEntete_OCT_RunwayTable = { "Select a category" };
        public static Type[] ListeTypeEntete_OCT_RunwayTable = { typeof(String) };
        public static int[] ListePrimaryKey_OCT_RunwayTable = { 0 };

        public static String[] ListeEntete_OCT_ArrInfTable = { "Select a category" };
        public static Type[] ListeTypeEntete_OCT_ArrInfTable = { typeof(String) };
        public static int[] ListePrimaryKey_OCT_ArrInfTable = { 0 };
        // << Bug #13146 Pax2Sim - load old projects v1.29
        #endregion

        #region Partie spécifique pour la table Oneof aucune colonne par défaut.
        public static String[] List_SuffixeColumnsOneOf ={ "Frequency", "Value" };
        public static Type[] List_TypeSuffixeColumnsOneOf = { System.Type.GetType("System.Double"), System.Type.GetType("System.Double") };


        public static String[][] ListeSuffixesTable = { List_SuffixeColumnsOneOf };
        public static String[] ListeTableAvecSuffixe = { "OneofSpecificationTable" };
        #endregion

        #region Les tables pour les résultats de la simulation statique des passagers.
        public static String[] ListeEntete_PaxPlan = { "PAX_ID", 
                                                       "CreationTime", 
                                                       "FPA_ID", 
                                                       "FPA_Class", 
                                                       "FPD_ID", 
                                                       "FPD_Class", 
                                                       "FPD_STD", 
                                                       "Self CheckIn",
                                                       "NbVisitors", 
                                                       "NbBags IG", 
                                                       "NbBags OOG", 
                                                       "NBTrolleys",
                                                       "Segregation", 
                                                       "PassportLocal", 
                                                       "Transfer" 
#if(PAXINOUTUTILISATION)
                                                       ,"TerminalInOut",
                                                       "InOut",
#endif
                                                       GlobalNames.sPaxPlan_Car
                                                     };


        public static Type[] ListeTypeEntete_PaxPlan = { typeof(Int32),             //Pax id
                                                                  typeof(Double),   //Creation time
                                                                  typeof(Int32),    //fpa_ID
                                                                  typeof(Int32),    //FPA_Class
                                                                  typeof(Int32),    //FPD_ID
                                                                  typeof(Int32),    //FPD_Class
                                                                  typeof(Int32),    //FPD_STD
                                                                  typeof(Int32),    //Self CheckIn
                                                                  typeof(Int32),    //NbVisitors
                                                                  typeof(Double),   //NbBags IG     // >> Task #17690 PAX2SIM - Flight Plan Parameters table (Double instead of Int32)
                                                                  typeof(Int32),    //NbBags OOG
                                                                  typeof(Int32),    //NBTrolleys
                                                                  typeof(Int32),    //Segregation
                                                                  typeof(Int32),    //PassportLocal
                                                                  typeof(Int32)     //Transfer
#if(PAXINOUTUTILISATION)
                                                                  ,typeof(Int32),   //TerminalInOut
                                                                  typeof(Int32),    //InOut
#endif
                                                                  typeof(Int32)     //sPaxPlan_Car
                                                       };

        public static String[] ListeEntete_BagPlan = { "Time(mn)", 
                                                       "ID_PAX", 
                                                       "FirstBag",
                                                       "FPA_ID", 
                                                       "FPA_Class", 
                                                       "PaxAtReclaim",
                                                       "FPD_ID", 
                                                       "FPD_Class", 
                                                       "STD", 
                                                       "NbBags",
                                                       "OOG_Bag",
                                                       "Segregation", 
                                                       "PassportLocal", 
                                                       "Transfer",
                                                       "Term.Arr", 
                                                       "#Arr.Gate", 
                                                       "Term.CI" , 
                                                       "#CI"  };

        public static Type[] ListeTypeEntete_BagPlan = { typeof(Double), 
                                                        typeof(Int32),  
                                                        typeof(Int32), 
                                                        typeof(Int32), 
                                                        typeof(Int32), 
                                                        typeof(Double), 
                                                        typeof(Int32), 
                                                        typeof(Int32), 
                                                        typeof(Double), 
                                                        typeof(Int32), 
                                                        typeof(Int32), 
                                                        typeof(Int32), 
                                                        typeof(Int32), 
                                                        typeof(Int32), 
                                                        typeof(Int32), 
                                                        typeof(Int32), 
                                                        typeof(Int32), 
                                                        typeof(Int32)};
        // New Bag Plan
        // << Sodexi Task#7129 Bagplan Update
        public static String[] bagPlan2HeaderList = {   GlobalNames.sBagPlan2_Column_Time, GlobalNames.sBagPlan2_Column_FirstBag,
                                                        GlobalNames.sBagPlan2_Column_BagId, GlobalNames.sBagPlan2_Column_PaxId,
                                                        GlobalNames.sBagPlan2_Column_FPAId, GlobalNames.sBagPlan2_Column_FPAClass,
                                                        GlobalNames.sBagPlan2_Column_PaxAtReclaim, GlobalNames.sBagPlan2_Column_FPDId,
                                                        GlobalNames.sBagPlan2_Column_FPDClass, GlobalNames.sBagPlan2_Column_STD,
                                                        GlobalNames.sBagPlan2_Column_NbBags, GlobalNames.sBagPlan2_Column_OOGBag,
                                                        GlobalNames.sBagPlan2_Column_Segregation, GlobalNames.sBagPlan2_Column_PassportLocal,
                                                        GlobalNames.sBagPlan2_Column_Transfer, GlobalNames.sBagPlan2_Column_ArrivalTerminal,
                                                        GlobalNames.sBagPlan2_Column_ArrivalGateNb, GlobalNames.sBagPlan2_Column_CheckInTerminal,
                                                        GlobalNames.sBagPlan2_Column_CheckInNb, GlobalNames.sBagPlan2_Column_Weight,
                                                        GlobalNames.sBagPlan2_Column_Length, GlobalNames.sBagPlan2_Column_Width,
                                                        GlobalNames.sBagPlan2_Column_Height, GlobalNames.sBagPlan2_Column_Volume,
                                                        GlobalNames.sBagPlan2_Column_LocalOrigin, GlobalNames.sBagPlan2_Column_LocalDestination,
                                                        GlobalNames.sBagPlan2_Column_User1, GlobalNames.sBagPlan2_Column_User2,
                                                        GlobalNames.sBagPlan2_Column_User3,GlobalNames.sBagPlan2_Column_User4, 
                                                        GlobalNames.sBagPlan2_Column_User5};
        /*public static Type[] bagPlan2HeaderTypeList = { typeof(Double), typeof(Int32),
                                                        typeof(Int32), typeof(Int32),
                                                        typeof(Int32), typeof(Int32),
                                                        typeof(Double), typeof(Int32),
                                                        typeof(Int32), typeof(Int32),
                                                        typeof(Int32), typeof(Int32),
                                                        typeof(Int32), typeof(Int32),
                                                        typeof(Int32), typeof(Int32),
                                                        typeof(Int32), typeof(Int32),
                                                        typeof(Int32), typeof(Double),
                                                        typeof(Double), typeof(Double),
                                                        typeof(Double), typeof(Double),
                                                        typeof(Int32), typeof(Int32),
                                                        typeof(String), typeof(String),
                                                        typeof(String), typeof(String),
                                                        typeof(String)};*/
        public static Type[] bagPlan2HeaderTypeList = { typeof(Double), typeof(Double),  // >> Pax trace analysis - Sum and BagPlan_2.txt
                                                        typeof(Double), typeof(Double),
                                                        typeof(Double), typeof(Double),
                                                        typeof(Double), typeof(Double),
                                                        typeof(Double), typeof(Double),
                                                        typeof(Double), typeof(Double),
                                                        typeof(Double), typeof(Double),
                                                        typeof(Double), typeof(Double),
                                                        typeof(Double), typeof(Double),
                                                        typeof(Double), typeof(Double),
                                                        typeof(Double), typeof(Double),
                                                        typeof(Double), typeof(Double),
                                                        typeof(Double), typeof(Double),
                                                        typeof(String), typeof(String),
                                                        typeof(String), typeof(String),
                                                        typeof(String)};

        // >> Sodexi Task#7129 Bagplan Update
        public static String[] ListeEntete_PaxGenTransferLog = { "PAX_ID", "FPA_ID", "FPA_Time", "PAX_Class", "Information" };
        public static Type[] ListeTypeEntete_PaxGenTransferLog = { System.Type.GetType("System.Int32"), System.Type.GetType("System.Int32"),
                                                                System.Type.GetType("System.Int32"),System.Type.GetType("System.Int32"),
                                                                typeof(String)};
        internal static List<string> lsOutputTables;
        internal static List<string> lsOutputTablesPath;
        internal static List<String[]> ltsOutputColumns;
        internal static List<Type[]> ltsOutputTypeColumns;
        internal static List<Int32[]> ltiOutputPrimaryKey;

        internal static List<List<ConvertTables.ConvertColumnOutputTables>> lccot_OutputConversion;
        #endregion

        #region Les tables pour la partie BHS

        #region BHS_General
        public static String[] ListeEntete_BHS_General = { "Data", "Value" };
        public static Type[] ListeTypeEntete_BHS_General = { typeof(String), typeof(Double) };
        public static int[] ListePrimaryKey_BHS_General = { 0 };
        #endregion

        #region BHS_Arrival_Infeed_Group
        public static String[] ListeEntete_BHS_ArrivalInfeed_Group = { "Arrival Infeed Group", "Arrival Infeed Start", "Arrival Infeed End" };
        public static Type[] ListeTypeEntete_BHS_ArrivalInfeed_Group = { typeof(Int32), typeof(Int32), typeof(Int32) };
        public static int[] ListePrimaryKey_BHS_ArrivalInfeed_Group = { 0 };
        #endregion

        #region BHS_CI_Group
        public static String[] ListeEntete_BHS_CI_Group = { "CI Group", "CI Start", "CI End" };
        public static Type[] ListeTypeEntete_BHS_CI_Group = { typeof(Int32), typeof(Int32), typeof(Int32) };
        public static int[] ListePrimaryKey_BHS_CI_Group = { 0 };
        #endregion

        #region BHS_Transfer_Infeed_Group
        public static String[] ListeEntete_BHS_TransferInfeed_Group = { "Transfer Infeed Group", "Transfer Infeed Start", "Transfer Infeed End" };
        public static Type[] ListeTypeEntete_BHS_TransferInfeed_Group = { typeof(Int32), typeof(Int32), typeof(Int32) };
        public static int[] ListePrimaryKey_BHS_TransferInfeed_Group = { 0 };
        #endregion

        #region CI_Collectors
        public static String[] ListeEntete_CI_Collectors = { "Collector", "CI_Desk_Start", "CI_Desk_End" };
        public static Type[] ListeTypeEntete_CI_Collectors = { typeof(Int32), typeof(Int32), typeof(Int32) };
        public static int[] ListePrimaryKey_CI_Collectors = { 0 };
        public static Object[] ListeDefault_CI_Collectors = { 1, 0, 0 };
        #endregion

        #region Routing_CI
        public static String[] ListeEntete_Routing_CI = { "CI_Group", "HBS1_Start", "HBS1_End", "HBS3_Start", "HBS3_End", "MES_Start", "MES_End", "MakeUp_Start", "MakeUp_End" };
        public static Type[] ListeTypeEntete_Routing_CI = { typeof(Int32), typeof(Int32), typeof(Int32), typeof(Int32), typeof(Int32), typeof(Int32), typeof(Int32), typeof(Int32), typeof(Int32) };
        public static int[] ListePrimaryKey_Routing_CI = { 0 };
        public static Object[] ListeDefault_Routing_CI = { 1, 0, 0, 0, 0, 0, 0, 0, 0 };
        #endregion

        #region Routing_HBS3
        //public static String[] ListeEntete_Routing_HBS3 = { "HBS3", "MES_Start", "MES_End", "HBS1_line_Start", "HBS1_line_End"};
        public static String[] ListeEntete_Routing_HBS3 = { "HBS3", "MES_Start", "MES_End", "MakeUp_Start", "MakeUp_End" };
        public static Type[] ListeTypeEntete_Routing_HBS3 = { typeof(Int32), typeof(Int32), typeof(Int32), typeof(Int32), typeof(Int32)};
        public static int[] ListePrimaryKey_Routing_HBS3 = { 0 };
        public static Object[] ListeDefault_Routing_HBS3 = { 1, 0, 0, 0, 0, };
        #endregion

        #region Routing_InFeed ==> Transfer
        public static String[] ListeEntete_Routing_InFeed = { "Trans_Infeed", "HBS1_Start", "HBS1_End", "HBS3_Start", "HBS3_End", "MES_Start", "MES_End", "MakeUp_Start", "MakeUp_End" };
        public static Type[] ListeTypeEntete_Routing_InFeed = { typeof(Int32), typeof(Int32), typeof(Int32), typeof(Int32), typeof(Int32), typeof(Int32), typeof(Int32), typeof(Int32), typeof(Int32) };
        public static int[] ListePrimaryKey_Routing_InFeed = { 0 };
        public static Object[] ListeDefault_Routing_InFeed = { 1, 0, 0, 0, 0, 0, 0, 0 };
        #endregion

        #region OCT_MakeUp
        public static String[] ListeEntete_OCT_MakeUp = { "Select a category" };
        public static Type[] ListeTypeEntete_OCT_MakeUp = { typeof(String) };
        public static int[] ListePrimaryKey_OCT_MakeUp = { 0 };
        #endregion

        #region Alloc_MakeUp
        public static String[] ListeEntete_Alloc_MakeUp = { "Time" };
        public static Type[] ListeTypeEntete_Alloc_MakeUp = { typeof(DateTime) };
        public static int[] ListePrimaryKey_Alloc_MakeUp = { 0 };
        #endregion

        #region BHS_Flow_Split
        public static String[] ListeEntete_BHS_Flow_Split = { "Flows" };
        public static Type[] ListeTypeEntete_BHS_Flow_Split = { typeof(String) };
        public static int[] ListePrimaryKey_BHS_Flow_Split = { 0 };
        #endregion

        #region BHS_Process
        public static String[] ListeEntete_BHS_Process = { "BHS Process data", "Value" };
        public static Type[] ListeTypeEntete_BHS_Process = { typeof(String), typeof(Double) };
        public static int[] ListePrimaryKey_BHS_Process = { 0 };
        #endregion

        #region BHS_Mean_Flows

        public static String[] ListeEntete_BHS_Arrival_Mean_Flows = { "Time" };
        public static Type[] ListeTypeEntete_BHS_Arrival_Mean_Flows = { typeof(DateTime) };
        public static int[] ListePrimaryKey_BHS_Arrival_Mean_Flows = { 0 };
        #endregion

        #region BHS_Mean_Flows

        public static String[] ListeEntete_BHS_CheckIn_Mean_Flows = { "Time" };
        public static Type[] ListeTypeEntete_BHS_CheckIn_Mean_Flows = { typeof(DateTime) };
        public static int[] ListePrimaryKey_BHS_CheckIn_Mean_Flows = { 0 };
        #endregion

        #region BHS_Mean_Flows

        public static String[] ListeEntete_BHS_Transfer_Mean_Flows = { "Time" };
        public static Type[] ListeTypeEntete_BHS_Transfer_Mean_Flows = { typeof(DateTime) };
        public static int[] ListePrimaryKey_BHS_Transfer_Mean_Flows = { 0 };
        #endregion

        #region BHS_Arrival_containers
        public static String[] ListeEntete_BHS_Arrival_Containers = { "Select a category" };
        public static Type[] ListeTypeEntete_BHS_Arrival_Containers = { typeof(String) };
        public static int[] ListePrimaryKey_BHS_Arrival_Containers = { 0 };
        #endregion

        #region BHS_Capa_Queues
        public static String[] ListeEntete_BHS_Capa_Queues = { "Element", "Queue Capacity" };
        public static Type[] ListeTypeEntete_BHS_Capa_Queues = { typeof(String), typeof(Int32) };
        public static int[] ListePrimaryKey_BHS_Capa_Queues = { 0 };
        #endregion

        #region BHS_Group_Queues
        public static String[] ListeEntete_BHS_Group_Queues = { "Element", "Queue Capacity" };
        public static Type[] ListeTypeEntete_BHS_Group_Queues = { typeof(String), typeof(Int32) };
        public static int[] ListePrimaryKey_BHS_Group_Queues = { 0 };
        #endregion

        #region BHS_Itinerary
        public static String[] ListeEntete_BHS_Itinerary = { "Group", "NextGroup", "Succeed", "Distribution", "Param1", "Param2", "Param3" };
        public static Type[] ListeTypeEntete_BHS_Itinerary = { typeof(String),typeof(String), 
                                                                typeof(Boolean), typeof(String), 
                                                                typeof(Double),typeof(Double),
                                                                typeof(Double)};
        public static Int32[] ListePrimaryKey_BHS_Itinerary = { 0, 1 };
        #endregion
        #endregion

        #region la table globale contenant les liens vers les tables de définition des tables.

        #region Partie Pax
        /// <summary>
        /// Voici la liste des entêtes des colonnes qui sont statiques, c'est à dire 
        /// qui sont toujours les mêmes peu importe les données chargées.
        /// </summary>
        public static String[][] listeEntetes ={
            ListeEntete_FPATable, //1
            ListeEntete_FPDTable, //2
            
            ListeEntete_FP_LinksTable,   //3 
            ListeEntete_FP_AircraftTypesTable,  //4
            ListeEntete_FP_AirlineCodesTable, //5
            ListeEntete_FP_AirportCodesTable, //6
            ListeEntete_FP_FlightCategoriesTable,//7
            ListeEntete_FPA_LoadFactorsTable,//8
            ListeEntete_FPD_LoadFactorsTable,//9
            ListeEntete_Transfer_ICTTable,//10
            ListeEntete_Transfer_TerminalDistributionTable,//11
            ListeEntete_Transfer_FlightCategoryDistributionTable ,//12
            ListeEntete_CI_ShowUpTable,//13
            ListeEntete_NbBagsTable,//14
            ListeEntete_NbVisitorsTable,//15
            ListeEntete_NbTrolleyTable,//16

            ListeEntete_OCT_BaggageClaimTable,//17
            ListeEntete_Alloc_BaggageClaimTable,//18
            ListeEntete_OCT_CITable,//19
            ListeEntete_Alloc_CITable,//20
            ListeEntete_Opening_CITable,//21
            ListeEntete_OCT_BagDropTable,//22   // >> Bug #13146 Pax2Sim - load old projects v1.29
            ListeEntete_OCT_BoardGateTable,//23
            ListeEntete_Alloc_BoardGateTable,//24
            ListeEntete_OCT_ArrGateTable,//25   // >> Bug #13146 Pax2Sim - load old projects v1.29
            ListeEntete_OCT_ParkingClaimTable,//26
            ListeEntete_Alloc_ParkingClaimTable,//27
            ListeEntete_OCT_RunwayTable,//28    // >> Bug #13146 Pax2Sim - load old projects v1.29
            ListeEntete_Alloc_PassportCheckTable,//29
            ListeEntete_Alloc_SecurityCheckTable,//30
            ListeEntete_Alloc_UserProcessCheckTable,    //31 << Task #7570 new Desk and extra information for Pax -Phase I B
            ListeEntete_Alloc_TransferDeskTable,//32
            ListeEntete_OCT_OCT_MakeUp,//33
            ListeEntete_SegregationTable,//34
            ListeEntete_OCT_ArrInfTable,//35    // >> Bug #13146 Pax2Sim - load old projects v1.29
            ListeEntete_OCT_TransferInfeedAllocationRulesTable,//36
            ListeEntete_BaggageClaimConstraintTable,//37
            ListeEntete_Capa_QueuesTable,//38
            ListeEntete_GroupsQueuesTable,//39
            ListeEntete_Animated_QueuesTable,//40

            ListeEntete_Times_ProcessTable,//41
            ListeEntete_ItineraryTable,//42
            ListeEntete_ProcessScheduleTable, //43
            ListeEntete_ParkingTable,//44
            ListeEntete_FromToShuttleTable,//45
            ListeEntete_OneofSpecificationTable //46
            };
        public static Type[][] listeTypeEntetes ={
            ListeTypeEntete_FPATable, 
            ListeTypeEntete_FPDTable, 
            
            ListeTypeEntete_FP_LinksTable,
            ListeTypeEntete_FP_AircraftTypesTable,                           
            ListeTypeEntete_FP_AirlineCodesTable, 
            ListeTypeEntete_FP_AirportCodesTable, 
            ListeTypeEntete_FP_FlightCategoriesTable,
            ListeTypeEntete_FPA_LoadFactorsTable,
            ListeTypeEntete_FPD_LoadFactorsTable,
            ListeTypeEntete_Transfer_ICTTable,
            ListeTypeEntete_TerminalDistributionTable,
            ListeTypeEntete_FlightCategoryDistributionTable ,
            ListeTypeEntete_CI_ShowUpTable,
            ListeTypeEntete_NbBagsTable,
            ListeTypeEntete_NbVisitorsTable, 
            ListeTypeEntete_NbTrolleyTable,

            ListeTypeEntete_OCT_BaggageClaimTable,
            ListeTypeEntete_Alloc_BaggageClaimTable,
            ListeTypeEntete_OCT_CITable,
            ListeTypeEntete_OCT_BagDropTable, // >> Bug #13146 Pax2Sim - load old projects v1.29
            ListeTypeEntete_Alloc_CITable,
            ListeTypeEntete_Opening_CITable,
            ListeTypeEntete_OCT_BoardGateTable,
            ListeTypeEntete_Alloc_BoardGateTable,
            ListeTypeEntete_OCT_ArrGateTable,// >> Bug #13146 Pax2Sim - load old projects v1.29
            ListeTypeEntete_OCT_ParkingClaimTable, 
            ListeTypeEntete_Alloc_ParkingClaimTable,
            ListeTypeEntete_OCT_RunwayTable,// >> Bug #13146 Pax2Sim - load old projects v1.29
            ListeTypeEntete_Alloc_PassportCheckTable,
            ListeTypeEntete_Alloc_SecurityCheckTable,
            ListeTypeEntete_Alloc_UserProcessCheckTable,    // << Task #7570 new Desk and extra information for Pax -Phase I B 
            ListeTypeEntete_Alloc_TransferDeskTable,
            ListeTypeEntete_OCT_OCT_MakeUp,
            ListeTypeEntete_SegregationTable,
            ListeTypeEntete_OCT_ArrInfTable,// >> Bug #13146 Pax2Sim - load old projects v1.29
            ListeTypeEntete_OCT_TransferInfeedAllocationRulesTable,
            ListeTypeEntete_BaggageClaimConstraintTable,
            ListeTypeEntete_Capa_QueuesTable,
            ListeTypeEntete_GroupsQueuesTable,
            ListeTypeEntete_Animated_QueuesTable,

            ListeTypeEntete_Times_ProcessTable,
            ListeTypeEntete_ItineraryTable,
            ListeTypeEntete_ProcessScheduleTable,
            ListeTypeEntete_ParkingTable,
            ListeTypeEntete_FromToShuttleTable, 
            ListeTypeEntete_OneofSpecificationTable};

        public static int[][] listePrimaryKey = {
            ListePrimaryKey_FPATable, 
            ListePrimaryKey_FPDTable, 

            ListePrimaryKey_FP_LinksTable,
            ListePrimaryKey_FP_AircraftTypesTable,                           
            ListePrimaryKey_FP_AirlineCodesTable, 
            ListePrimaryKey_FP_AirportCodesTable, 
            ListePrimaryKey_FP_FlightCategoriesTable,
            ListePrimaryKey_FPA_LoadFactorsTable,
            ListePrimaryKey_FPD_LoadFactorsTable,
            ListePrimaryKey_Transfer_ICTTable,
            ListePrimaryKey_TerminalDistributionTable,
            ListePrimaryKey_FlightCategoryDistributionTable ,
            ListePrimaryKey_CI_ShowUpTable,
            ListePrimaryKey_NbBagsTable,
            ListePrimaryKey_NbVisitorsTable,
            ListePrimaryKey_NbTrolleyTable,

            ListePrimaryKey_OCT_BaggageClaimTable,
            ListePrimaryKey_Alloc_BaggageClaimTable,
            ListePrimaryKey_OCT_CITable,
            ListePrimaryKey_OCT_BagDropTable,// >> Bug #13146 Pax2Sim - load old projects v1.29
            ListePrimaryKey_Alloc_CITable,
            ListePrimaryKey_Opening_CITable,
            ListePrimaryKey_OCT_BoardGateTable,
            ListePrimaryKey_Alloc_BoardGateTable,
            ListePrimaryKey_OCT_ArrGateTable,// >> Bug #13146 Pax2Sim - load old projects v1.29
            ListePrimaryKey_OCT_ParkingClaimTable, 
            ListePrimaryKey_Alloc_ParkingClaimTable,
            ListePrimaryKey_OCT_RunwayTable,// >> Bug #13146 Pax2Sim - load old projects v1.29
            ListePrimaryKey_Alloc_PassportCheckTable,
            ListePrimaryKey_Alloc_SecurityCheckTable,
            ListePrimaryKey_Alloc_UserProcessCheckTable,   // << Task #7570 new Desk and extra information for Pax -Phase I B
            ListePrimaryKey_Alloc_TransferDeskTable,
            ListePrimaryKey_OCT_OCT_MakeUp,
            ListePrimaryKey_SegregationTable,
            ListePrimaryKey_OCT_ArrInfTable,// >> Bug #13146 Pax2Sim - load old projects v1.29
            ListePrimaryKey_OCT_TransferInfeedAllocationRulesTable,
            ListePrimaryKey_BaggageClaimConstraintTable,
            ListePrimaryKey_Capa_QueuesTable,
            ListePrimaryKey_GroupsQueuesTable,
            ListePrimaryKey_Animated_QueuesTable,

            ListePrimaryKey_Times_ProcessTable,
            ListePrimaryKey_ItineraryTable,
            ListePrimaryKey_ProcessScheduleTable,
            ListePrimaryKey_ParkingTable,
            ListePrimaryKey_FromToShuttleTable,
            ListePrimaryKey_OneofSpecificationTable
        };
        #endregion

        #region BHS

        public static String[][] ListeEntetes_BHS_Racine ={
                    ListeEntete_BHS_Capa_Queues,
                    ListeEntete_BHS_Group_Queues,
                    ListeEntete_BHS_Itinerary
                };
        public static Type[][] ListeTypeEntetes_BHS_Racine ={
                    ListeTypeEntete_BHS_Capa_Queues,
                    ListeTypeEntete_BHS_Group_Queues,
                    ListeTypeEntete_BHS_Itinerary
                };
        public static Int32[][] ListePrimaryKey_BHS_Racine ={
                    ListePrimaryKey_BHS_Capa_Queues,
                    ListePrimaryKey_BHS_Group_Queues,
                    ListePrimaryKey_BHS_Itinerary
                };
        public static String[][] ListeEntetes_BHS = {
                    ListeEntete_BHS_General,
                    ListeEntete_BHS_ArrivalInfeed_Group,
                    ListeEntete_BHS_CI_Group,
                    ListeEntete_BHS_TransferInfeed_Group,
                    ListeEntete_CI_Collectors,
                    ListeEntete_Routing_CI,
                    ListeEntete_Routing_HBS3 ,
                    ListeEntete_Routing_InFeed,
                    ListeEntete_BHS_Flow_Split,
                    ListeEntete_BHS_Process,
                    /*ListeEntete_OCT_MakeUp,*/
                    ListeEntete_Alloc_MakeUp, 
                    ListeEntete_BHS_Arrival_Containers,
                    ListeEntete_BHS_Arrival_Mean_Flows,
                    ListeEntete_BHS_CheckIn_Mean_Flows,
                    ListeEntete_BHS_Transfer_Mean_Flows};

        public static Type[][] ListeTypeEntetes_BHS = {
                    ListeTypeEntete_BHS_General,
                    ListeTypeEntete_BHS_ArrivalInfeed_Group,
                    ListeTypeEntete_BHS_CI_Group,
                    ListeTypeEntete_BHS_TransferInfeed_Group,
                    ListeTypeEntete_CI_Collectors,
                    ListeTypeEntete_Routing_CI,
                    ListeTypeEntete_Routing_HBS3,
                    ListeTypeEntete_Routing_InFeed,
                    ListeTypeEntete_BHS_Flow_Split,
                    ListeTypeEntete_BHS_Process,
                    /*ListeTypeEntete_OCT_MakeUp,*/
                    ListeTypeEntete_Alloc_MakeUp,
                    ListeTypeEntete_BHS_Arrival_Containers ,
                    ListeTypeEntete_BHS_Arrival_Mean_Flows ,
                    ListeTypeEntete_BHS_CheckIn_Mean_Flows ,
                    ListeTypeEntete_BHS_Transfer_Mean_Flows};
        public static int[][] ListePrimaryKey_BHS = {
                        ListePrimaryKey_BHS_General,
                        ListePrimaryKey_BHS_ArrivalInfeed_Group,
                        ListePrimaryKey_BHS_CI_Group,
                        ListePrimaryKey_BHS_TransferInfeed_Group,
                        ListePrimaryKey_CI_Collectors,
                        ListePrimaryKey_Routing_CI,
                        ListePrimaryKey_Routing_HBS3,
                        ListePrimaryKey_Routing_InFeed,
                        ListePrimaryKey_BHS_Flow_Split,
                        ListePrimaryKey_BHS_Process,
                        /*ListePrimaryKey_OCT_MakeUp,*/
                        ListePrimaryKey_Alloc_MakeUp,
                        ListePrimaryKey_BHS_Arrival_Containers,
                        ListePrimaryKey_BHS_Arrival_Mean_Flows,
                        ListePrimaryKey_BHS_CheckIn_Mean_Flows,
                        ListePrimaryKey_BHS_Transfer_Mean_Flows };
        #endregion

        #endregion

        #endregion

        #region Les distinctions entre les différentes tables

        #region Pour la partie Passager

        //Les tables qui doivent avoir un ajout de colonnes avec des Doubles
        public static String[] listeTable_AjoutDouble = null;
        public static String[] listeTable_AjoutString = null;
        public static String[] listeTable_AjoutBoolean = null;
        public static String[] listeTable_FC = null;

        public static String[] listeTable_SchemaAeroport = null;
        public static string[] ListeEnteteDiv = null;
        public static String[] ListeTablesAvecLignesFixes = null;
        public static String[][] ListeLignesFixes = null;
        public static String[] ListeTablesAvecAllocation = null;
        public static String[] ListeTablesPourCalculAllocation = null;

        public static String[] ListeTablesDefault = null;
        public static Double[][] ListeTableDefaultValues = null;

        public static String[] Default_listeTable_AjoutDouble = { GlobalNames.FPD_LoadFactorsTableName, 
                                                          GlobalNames.FPA_LoadFactorsTableName ,
                                                          GlobalNames.Transfer_ICTTableName, 
                                                          GlobalNames.CI_ShowUpTableName, 
                                                          GlobalNames.NbBagsTableName, 
                                                          GlobalNames.NbVisitorsTableName,
                                                          GlobalNames.NbTrolleyTableName,
                                                          "OCT_CITable",
                                                          "OCT_BoardGateTable",
                                                          "OCT_BaggageClaimTable",
                                                          "OCT_ParkingTable", 
                                                          "Alloc_TransferDeskTable",
                                                          "FromToShuttleTable", 
                                                          "OneofSpecificationTable",
                                                          GlobalNames.Transfer_TerminalDitributionTableName,
                                                          GlobalNames.Transfer_FlightCategoryDitributionTableName,
                                                          "OCT_MakeUp",
                                                          "TransferInfeedAllocationRulesTable",
                                                          "Segregation"};


        public static String[] Default_listeTable_AjoutString = { "Alloc_CITable", 
                                                          "Alloc_BoardGateTable", 
                                                          "Alloc_BaggageClaimTable", 
                                                          "Alloc_ParkingTable",
                                                          "Alloc_PassportCheckTable",
                                                          "Alloc_SecurityCheckTable",
                                                          GlobalNames.Alloc_UserProcessCheckTableName,    // << Task #7570 new Desk and extra information for Pax -Phase I B
                                                          "Baggage_Claim_Constraint"};

        public static String[] Default_listeTable_AjoutBoolean = { "Opening_CITable" };

        //Les tables ayant leurs colonnes qui se basent sur les flight categories
        public static String[] Default_listeTable_FC ={GlobalNames.FPD_LoadFactorsTableName, 
                                               GlobalNames.FPA_LoadFactorsTableName, 
                                               GlobalNames.Transfer_ICTTableName, 
                                               GlobalNames.CI_ShowUpTableName, 
                                               GlobalNames.NbBagsTableName, 
                                               GlobalNames.NbVisitorsTableName,
                                               GlobalNames.NbTrolleyTableName,
                                               "OCT_CITable",
                                               "OCT_BoardGateTable",
                                               "OCT_BaggageClaimTable",
                                               "OCT_ParkingTable",
                                               "OCT_MakeUp",
                                               "TransferInfeedAllocationRulesTable",
                                               "Segregation",
                                               GlobalNames.Transfer_FlightCategoryDitributionTableName};


        //Les tables qui ont leurs noms de colonnes qui se basent sur la structure de l'aéroport.
        public static string[] Default_listeTable_SchemaAeroport = {  GlobalNames.Times_ProcessTableName,  
                                                              "Alloc_CITable", 
                                                              "Alloc_BoardGateTable", 
                                                              "Alloc_BaggageClaimTable", 
                                                              "Alloc_PassportCheckTable", 
                                                              "Alloc_SecurityCheckTable", 
                                                              GlobalNames.Alloc_UserProcessCheckTableName, // << Task #7570 new Desk and extra information for Pax -Phase I B
                                                              "Alloc_TransferDeskTable", 
                                                              GlobalNames.Capa_QueuesTableName ,
                                                              GlobalNames.capaProcessTableName,  // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                                                              "FromToShuttleTable",
                                                              "Opening_CITable",
                                                              "Alloc_ParkingTable",
                                                              GlobalNames.Transfer_TerminalDitributionTableName,
                                                              GlobalNames.Group_QueuesName,
                                                              "Baggage_Claim_Constraint"
                                                        };

        //Voici la liste des entetes qui peuvent être présent dans les tables se basant sur la structure d'un aéroport.
        //Cette liste permet d'éviter de supprimer les colonnes associées lors de la génération de la table.
        public static string[] Default_ListeEnteteDiv ={ "Select a category",
                                                 "NbBags", 
                                                 "NbVisitors", 
                                                 "NbTrolley", 
                                                 "Travel Times From>To", 
                                                 "Time", 
                                                 "From/To", 
                                                 "Begin", 
                                                 "End", 
                                                 "NbBaggage",
                                                 "To",
                                                 "Segregation",
                                                 "Data"
                                 //<< Task #7405 - new Desk and extra information for Pax
                                                 ,"Value"
                                //>> Task #7405 - new Desk and extra information for Pax
                                // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                                 , GlobalNames.sUserAttributesBaggLoadingDelayValueColumnName
                                                 , GlobalNames.sUserAttributesBaggLoadingRateValueColumnName
                                // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                                 , GlobalNames.userAttributesReclaimLogValueColumnName
                                // << Task #9172 Pax2Sim - Static Analysis - EBS algorithm - Input/Output Rates
                                                 , GlobalNames.userAttributesEBSInputRateValueColumnName
                                                 , GlobalNames.userAttributesEBSOutputRateValueColumnName
                                // >> Task #9172 Pax2Sim - Static Analysis - EBS algorithm - Input/Output Rate
                                                 };

        //Listes représentant les lignes devant être présentes pour certaines tables.

        public static string[] ListeLignesFPD_LF ={GlobalNames.sLFD_A_Line_Full, 
            GlobalNames.sLFD_A_Line_C, 
            GlobalNames.sLFD_A_Line_Y, 
            GlobalNames.sLFD_A_Line_Local,
            GlobalNames.sLFD_A_Line_NotLocal,
            GlobalNames.sLFD_Line_SelfCI, 
            GlobalNames.sLFD_Line_Originating, 
            GlobalNames.sLFD_A_Line_Transferring,
            GlobalNames.sLFD_A_Line_ReCheck, 
            GlobalNames.sLFD_A_Line_TransferDesk,
            GlobalNames.sLFD_A_Line_OOGTransf,
            GlobalNames.sLFD_Line_OOGOrig,
            GlobalNames.sLFD_A_Line_NbPaxPerCar
            
            /* OOG => Remove this coment to make appears the OOG information * /,

            "% Bags Out Of Gauge (OOG)"/*/};
        public static string[] ListeLignesFPA_LF ={GlobalNames.sLFD_A_Line_Full, 
            GlobalNames.sLFD_A_Line_C, 
            GlobalNames.sLFD_A_Line_Y, 
            GlobalNames.sLFD_A_Line_Local, 
            GlobalNames.sLFD_A_Line_NotLocal, 
            GlobalNames.sLFA_Line_Terminating, 
            GlobalNames.sLFD_A_Line_Transferring, 
            GlobalNames.sLFD_A_Line_ReCheck, 
            GlobalNames.sLFD_A_Line_TransferDesk,
            GlobalNames.sLFD_A_Line_OOGTransf,
            GlobalNames.sLFA_Line_OOGTerm,
            GlobalNames.sLFD_A_Line_NbPaxPerCar
            /* OOG => Remove this coment to make appears the OOG information * /,,
            "% Bags Out Of Gauge (OOG)"/*/};

        public static string[] ListeLignesOCT_CI = { GlobalNames.sOCT_CI_Line_Opening, GlobalNames.sOCT_CI_Line_Closing, GlobalNames.sOCT_CI_Line_Allocated,
                                                        GlobalNames.sOCT_CI_Line_PartialOpeningTime, GlobalNames.sOCT_CI_Line_NbStationsOpenedAtPartial, GlobalNames.sOCT_CI_Line_NbAdditionalStationsForOverlappingFlights};
        public static string[] ListeLignesOCT_BoardGate = { GlobalNames.sOCT_Board_Line_Opening, GlobalNames.sOCT_Board_Line_Closing };
        //public static string[] ListeLignesOCT_BaggageClaim = { "Baggage Claim Opening Time (Min after STA)", "Baggage Claim Closing Time (Min after STA)" };
        public static string[] ListeLignesOCT_BaggageClaim = { "Baggage Claim Opening Time (Min after STA)", "Baggage Claim Closing Time (Min after STA)", "Container size (baggage)", "Number of processed container per cycle", "Dead time between two cycles (minutes)" };
        public static string[] ListeLignesBaggage_Claim_Constraint = { "Infeed number", 
                                            "Infeed speed (sec/bags)", 
                                            "Limit Bag Acceptance (Number of bags)", 
                                            "Number of Bag Min", 
                                            "Number of Bag Max", 
                                            "Excluded categories", 
                                            "Excluded Ground Handler", 
                                            "Excluded Airline Code", 
                                            "Excluded Flight", 
                                            "Excluded Container type" };

        public static string[] ListeLignesOCT_MakeUp = {"Make-Up Opening Time (Min before STD)",
                                                       "Make-Up Closing Time (Min before STD)", 
                                                       "EBS delivery time (Min before STD)",
                                                       "Number of allocated Make-Up per flight",
                                                       "Make-Up Partial Opening/Closing Time (Min before STD)",
                                                       "Number of Opened Make-Up at Partial Opening/Closing",
                                                       "Segregation number",
                                                       "Container size",
                                                       "DeadTime (Time to change the container) (s)",
                                                       "Number of container per Lateral" };
        public static string[] ListeLignesTransferInfeedAllocationRulesTable = { "Tranfer Opening Time (Min after STA)", "Transfer Closing Time (Min after STA)", "Number of allocated Transfer Infeed per flight" };


        public static string[] ListeLignesOCT_Parking = { "Parking Opening Time (Min after STA or before STD)", "Parking Closing Time (Min after STA or before STD)" };

        public static String[] Default_ListeTablesAvecLignesFixes = { GlobalNames.FPD_LoadFactorsTableName, 
            GlobalNames.FPA_LoadFactorsTableName, 
            "OCT_CITable", 
            "OCT_BoardGateTable", 
            "OCT_BaggageClaimTable" ,
            "OCT_ParkingTable",
            "OCT_MakeUp",
            "TransferInfeedAllocationRulesTable",
            "Baggage_Claim_Constraint"};

        public static String[][] Default_ListeLignesFixes = { ListeLignesFPD_LF, 
            ListeLignesFPA_LF, 
            ListeLignesOCT_CI, 
            ListeLignesOCT_BoardGate, 
            ListeLignesOCT_BaggageClaim, 
            ListeLignesOCT_Parking,
            ListeLignesOCT_MakeUp,
            ListeLignesTransferInfeedAllocationRulesTable,
            ListeLignesBaggage_Claim_Constraint};

        public static String[] Default_ListeTablesAvecAllocation ={ "Alloc_CITable", 
            "Alloc_BoardGateTable", 
            "Alloc_BaggageClaimTable", 
            "Alloc_ParkingTable", 
            "Alloc_PassportCheckTable", 
            "Alloc_SecurityCheckTable", 
            GlobalNames.Alloc_UserProcessCheckTableName, // << Task #7570 new Desk and extra information for Pax -Phase I B
            "Alloc_TransferDeskTable" };

        public static String[] Default_ListeTablesPourCalculAllocation = { GlobalNames.FPDTableName, GlobalNames.FPATableName, GlobalNames.FP_AircraftTypesTableName, 
            GlobalNames.FP_AirlineCodesTableName, GlobalNames.FP_AirportCodesTableName, GlobalNames.FP_FlightCategoriesTableName, GlobalNames.FPD_LoadFactorsTableName, 
            GlobalNames.FPA_LoadFactorsTableName, "OCT_CITable", "OCT_BoardGateTable", "OCT_BaggageClaimTable", "OCT_ParkingTable" };

        public static String[] ListeTablesAvecDefault ={ GlobalNames.FP_AirlineCodesTableName, GlobalNames.FP_AirportCodesTableName, GlobalNames.FP_AircraftTypesTableName };


        #endregion

        #region Pour la partie BHS

        public static string[] ListeLignesGeneral_BHS = { "Number of Arrival Infeeds",
                                                          "Last index of Arrival Infeeds",
                                                          "Number of CI desks",
                                                          "Last index of CI desks",
                                                          "Number of Transfer Infeeds",
                                                          "Last index of Transfer Infeeds",
                                                          "Number of HBS Lev.1 machines",
                                                          "Last index of HBS Lev.1 machines",
                                                          "Number of HBS Lev.3 machines",
                                                          "Last index of HBS Lev.3 machines",
                                                          "Number of ME Station",
                                                          "Last index of ME Station",
                                                          "Number of Make-Up positions",
                                                          "Last index of Make-Up positions",
                                                          "Number of CI Collectors",
                                                          "Last index of CI Collectors",
                                                          "Window reservation Collectors ? (0/1)",
                                                          "Window size (m)"};

        public static string[] ListeLignesArrival_Containers = { "First Container delay (minutes)", 
                                                                 "Container size",
                                                                 "Number of laterals"};
        public static string[] ListeLignesFlowSplit_BHS ={ "% to HBS Level 2", 
                                                           "% to HBS Level 3", 
                                                           "% to HBS Level 4", 
                                                           "% to HBS Level 5", 
                                                           "% MES (Originating Bags)",
                                                           "% MES (Transfer Bags)",
                                                           "% Interlink (Transfer Bags)-optional",
                                                           "% Interlink (Originating Bags)-optional"};

        private static string[] ListeLignesProcess_BHS ={"Check-In Bag process time (Mean Flows mode) (sec)",
                                    "MES Short Process rate (%)",
                                    "MES Short process time (sec)",
                                    "MES Long process time (sec)",
                                    "HBS Lev.1 spacing (m)",
                                    "HBS Lev.1 Velocity (m/s)",
                                    "HBS Lev.2 process time Min (sec)",
                                    "HBS Lev.2 process time Mode (sec)",
                                    "HBS Lev.2 process time Max (sec)",
                                    "HBS Lev.2 TimeOut (sec)",
                                    "HBS Lev.2 Operators",
                                    "HBS Lev.3 process time Min (sec)",
                                    "HBS Lev.3 process time Mode (sec)",
                                    "HBS Lev.3 process time Max (sec)",
                                    "HBS Lev.3 spacing (m)",
                                    "HBS Lev.3 Velocity (m/s)",
                                    "HBS Lev.4 process time Min (sec)",
                                    "HBS Lev.4 process time Mode (sec)",
                                    "HBS Lev.4 process time Max (sec)",
                                    "HBS Lev.4 TimeOut (sec)",
                                    "HBS Lev.4 Operators",
                                    "HBS Lev.4 Hold inside ? (0/1)",
                                    "HBS Lev.5 process time Min (sec)",
                                    "HBS Lev.5 process time Mode (sec)",
                                    "HBS Lev.5 process time Max (sec)",
                                    "Make-Up PickUp throughput (bag/h)",
                                    "Transfer Unload throughput (bag/h)",
                                    "Arrival Unload throughput (bag/h)",
                                    "Number of Tray Sorters",
                                    "Sorter velocity (m/s)",
                                    "Sorter tray length (m)",
                                    "Sorter filling limit (%)",
                                    "Sorter recirculation limit (nb laps)",
                                    "Sorter Tilt interval (trays)",
                                    "Sorter Induction interval (trays)",
                                    "EBS operating ? (0/1)"
        };




        public static String[] listeTable_AjoutDouble_BHS ={ "OCT_MakeUp", "Flow_Split", "Arrival_Containers", "Mean_Flows_Arrival_Infeed", "Mean_Flows_Check_In", "Mean_Flows_Transfer_Infeed" };
        public static String[] listeTable_AjoutString_BHS = { "Alloc_MakeUp" };

        public static String[] listeTable_FC_BHS = { "OCT_MakeUp", "Flow_Split", "Arrival_Containers" };


        public static String[] listeTable_SchemaAeroport_BHS = { GlobalNames.sBHS_CI_Routing, GlobalNames.sBHS_Transfer_Routing, GlobalNames.sBHS_CI_Collectors, GlobalNames.sBHS_Alloc_MakeUp, GlobalNames.sBHS_CI_Groups, GlobalNames.sBHS_General, GlobalNames.sBHS_Mean_Flows_Arrival_Infeed, GlobalNames.sBHS_Mean_Flows_Check_In, GlobalNames.sBHS_Mean_Flows_Transfer_Infeed, GlobalNames.sBHS_ArrivalInfeed_Groups, GlobalNames.sBHS_TransferInfeed_Groups, GlobalNames.sBHS_HBS3_Routing };

        public static String[] ListeEnteteDiv_BHS ={ "Flows" };

        public static String[] ListeTablesAvecLignesFixes_BHS =  { "General", /*"OCT_MakeUp",*/ "Flow_Split", "Process", "Arrival_Containers" };


        public static String[][] ListeLignesFixes_BHS ={ ListeLignesGeneral_BHS, /*ListeLignesOCT_MakeUp,*/ ListeLignesFlowSplit_BHS, ListeLignesProcess_BHS, ListeLignesArrival_Containers };

        public static String[] ListeTablesAvecAllocation_BHS =  { "Alloc_MakeUp" };

        public static String[] ListeTablesPourCalculAllocation_BHS ={ "OCT_MakeUp" };

        public static ArrayList HiddenTables = null;
        #endregion

        #endregion

        #region Les lignes ou colonnes par défaut à ajouter aux tables lors de la création d'une structure vide.
        public static Double[] Default_FPDLoadFactors = { 90, 10, 90, 50, 50, 50, 80, 20, 10, 0, 0 };
        public static Double[] Default_FPALoadFactors = { 90, 10, 90, 50, 50, 90, 10, 50, 0, 0 };
        public static Double[] Default_TransferICT = { 0, 120, 100 };
        public static Double[] Default_ShowUp = { 0, 120, 100 };
        public static Double[] Default_NbBags = { 0, 100 };
        public static Double[] Default_NbVisitors = { 0, 100 };
        public static Double[] Default_Segregation = { 1, 100 };
        private static Double[] ListeValuesBaggage_Claim_Constraint = new Double[]{0.0,
                                    0.0,
                                    0.0,
                                    0.0,
                                    0.0,
                                    0.0,
                                    0.0,
                                    0.0,
                                    0.0,
                                    0.0};

        public static Double[] Default_OCT_CI = { 120, 30 };
        public static Double[] Default_OCT_BG = { 30, 0 };
        public static Double[] Default_OCT_BC = { 0, 60, 40, 1, 0 };
        public static Double[] Default_OCT_P = { 0, 25 };
        public static Double[] Default_OCT_MakeUp = { 120, 30, 90, 3, 120, 3, 3, 40, 60, 3 };
        public static Double[] Default_TransferInfeedAllocationRulesTable = { 10, 30, 2 };

        #region BHS

        //public static Double[] Default_OCT_MakeUp = { 120, 30, 90, 3, 40, 60, 3 };
        public static Double[] Default_Flow_Split = { 40, 12.5, 40, 0, 5, 50, 10 };
        public static Double[] Default_Arrival_Containers = { 15, 40, 2 };

        public static String[] ListeTablesDefault_BHS = { /*"OCT_MakeUp",*/ "Flow_Split", "Arrival_Containers" };
        public static Double[][] ListeTableDefaultValues_BHS = { /*Default_OCT_MakeUp,*/ Default_Flow_Split, Default_Arrival_Containers };
        public static VisualisationMode UtilizationBHSGroupTableVisualisationMode = null;
        #endregion

        public static String[] Default_ListeTablesDefault = { GlobalNames.FPD_LoadFactorsTableName, GlobalNames.FPA_LoadFactorsTableName, GlobalNames.Transfer_ICTTableName, GlobalNames.CI_ShowUpTableName, GlobalNames.NbBagsTableName, GlobalNames.NbVisitorsTableName, "OCT_CITable", "OCT_BoardGateTable", "OCT_BaggageClaimTable", "OCT_ParkingTable", "OCT_MakeUp", "TransferInfeedAllocationRulesTable", "Segregation", "Baggage_Claim_Constraint" };
        public static Double[][] Default_ListeTableDefaultValues = { Default_FPDLoadFactors, Default_FPALoadFactors, Default_TransferICT, Default_ShowUp, Default_NbBags, Default_NbVisitors, Default_OCT_CI, Default_OCT_BG, Default_OCT_BC, Default_OCT_P, Default_OCT_MakeUp, Default_TransferInfeedAllocationRulesTable, Default_Segregation, ListeValuesBaggage_Claim_Constraint };


        #endregion

        #region Chargement des visualisations par défault.
        public static Hashtable modeVisualisation = null;
        public static VisualisationMode UtilizationTableVisualisationMode = null;
        public static VisualisationMode UtilizationGroupTableVisualisationMode = null;
        /// <summary>
        /// Cette variable contient les mode de visualisation pour les tables de rapport.
        /// 0 ==> Airport
        /// 1 ==> Terminal
        /// 2 ==> Level
        /// 3 ==> Group
        /// 4 ==> Desk
        /// </summary>
        public static VisualisationMode[] RapportTableVisualisationMode = null;
        public static VisualisationMode StaticRapportVisualisationMode = null;

        private static void InitializeVisualisationMode()
        {
            if (modeVisualisation != null)
                return;
            VisualisationMode mode;
            modeVisualisation = new Hashtable();

            #region Partie PAX

            mode = new VisualisationMode(false, false, true, null, new int[] {0});
            modeVisualisation.Add(GlobalNames.FPLinksTableName, mode);


            /*Mode de visualisation normal, avec des tailles de colonnes définies et la première colonne fixée.*/
            mode = new VisualisationMode(true, true, true, new int[] {0}, new int[] {0}, false, false,
                                         Color.White, Color.Blue, Color.Black, Color.White,
                                         VisualisationMode.SelectionModeEnum.Row,
                                         VisualisationMode.EditModeEnum.Row, new int[] {0},
                                         new int[] {32, 70, 60, 56, 60, 56, 70, 64, 35}, null, null, null);
            mode.AllowEditRow = true;
            modeVisualisation.Add(GlobalNames.FPDTableName, mode);
            modeVisualisation.Add(GlobalNames.FPATableName, mode.Clone());

            /*Visualisation simple avec aucune colonne fixe et les tailles par défaut.*/
            mode = mode.Clone();
            mode.ColumnWidth = null;
            //mode.ColumnBlocked = null;
            mode.ColumnFrozen = null;
            modeVisualisation.Add(GlobalNames.FP_AircraftTypesTableName, mode);
            modeVisualisation.Add(GlobalNames.FP_AirlineCodesTableName, mode.Clone());
            modeVisualisation.Add(GlobalNames.FP_AirportCodesTableName, mode.Clone());
            modeVisualisation.Add(GlobalNames.FP_FlightCategoriesTableName, mode.Clone());
            //Seb -> 14/12/2009 ->AircraftLinks
            //modeVisualisation.Add("AircraftLinksTable", mode.Clone());

            /*Mode de visualisation avec la première colonne servant d'entete, aucun ajout de ligne possible.*/
            mode = mode.Clone();
            mode.AllowEditRow = false;
            mode.AllowEditColumn = true;
            mode.ColumnBlocked = new int[] {0};
            mode.FirstColumnInHeader = true;
            mode.ShowRowHeader = true;
            mode.Sortable = false;
            mode.SelectionMode = VisualisationMode.SelectionModeEnum.Column;
            mode.EditMode = VisualisationMode.EditModeEnum.Column;
            mode.AllowAddLine = false;

            modeVisualisation.Add(GlobalNames.FPD_LoadFactorsTableName, mode);
            modeVisualisation.Add(GlobalNames.FPA_LoadFactorsTableName, mode.Clone());
            modeVisualisation.Add("OCT_CITable", mode.Clone());
            modeVisualisation.Add("OCT_BoardGateTable", mode.Clone());
            modeVisualisation.Add("OCT_BaggageClaimTable", mode.Clone());
            modeVisualisation.Add("OCT_ParkingTable", mode.Clone());
            modeVisualisation.Add("OCT_MakeUp", mode.Clone());
            modeVisualisation.Add("TransferInfeedAllocationRulesTable", mode.Clone());
            modeVisualisation.Add("Baggage_Claim_Constraint", mode.Clone());

            /*Mode de visualisation avec sélection de colonnes complètes.*/
            mode = mode.Clone();
            mode.ShowRowHeader = false;
            mode.FirstColumnInHeader = false;
            mode.ColumnBlocked = new int[] {0, 1};
            mode.PrimaryKey = new int[] {0, 1};
            //mode.AllowAddLine = true;
            mode.Sortable = false;
            mode.allowSortColumn = null;
            mode.ColumnFrozen = new int[] {0, 1};

            modeVisualisation.Add(GlobalNames.Transfer_ICTTableName, mode);
            modeVisualisation.Add(GlobalNames.CI_ShowUpTableName, mode.Clone());

            /*Mode de visualisation pour les nombre de baggages.*/
            mode = mode.Clone();
            mode.ColumnFrozen = new int[] {0, 1};
            mode.ColumnBlocked = new int[] {0, 1};
            mode.PrimaryKey = new int[] {0, 1};
            modeVisualisation.Add(GlobalNames.NbTrolleyTableName, mode.Clone());
            mode.ColumnBlocked = new int[] {0};
            mode.ColumnFrozen = new int[] {0};
            mode.PrimaryKey = new int[] {0};
            modeVisualisation.Add(GlobalNames.NbBagsTableName, mode.Clone());
            modeVisualisation.Add(GlobalNames.NbVisitorsTableName, mode.Clone());
            modeVisualisation.Add("Segregation", mode.Clone());

            mode.AllowAddLine = false;
            mode.allowSortColumn = null;
            mode.AllowEditColumn = false;
            mode.AllowEditRow = true;
            mode.ColumnBlocked = new int[] {0};
            mode.EditMode = VisualisationMode.EditModeEnum.Row;
            mode.FirstColumnInHeader = true;
            mode.SelectionMode = VisualisationMode.SelectionModeEnum.Row;
            mode.ShowRowHeader = true;
            modeVisualisation.Add(GlobalNames.Times_ProcessTableName, mode);
            mode = mode.Clone();
            mode.AllowEditRow = false;
            modeVisualisation.Add("ParkingTable", mode.Clone());

            mode = mode.Clone();
            mode.ColumnBlocked = new int[] {0, 1};
            mode.ShowRowHeader = false;
            mode.FirstColumnInHeader = false;
            mode.PrimaryKey = new int[] {0, 1};
            modeVisualisation.Add(GlobalNames.ItineraryTableName, mode);
            modeVisualisation.Add(GlobalNames.sBHS_Itinerary, mode);

            mode = mode.Clone();
            mode.AllowEditRow = false;
            mode.ColumnBlocked = null;
            mode.ShowRowHeader = true;
            mode.FirstColumnInHeader = true;
            mode.Sortable = false;
            mode.Modifiable = false;
            mode.PrimaryKey = new int[] {0};
            mode.SelectionMode = VisualisationMode.SelectionModeEnum.Cell;
            mode.EditMode = VisualisationMode.EditModeEnum.None;

            ConditionnalFormatCharacter cfcAllocation = new ConditionnalFormatCharacter(',', true);
            cfcAllocation.setCondition(1, Color.FromArgb(0, 255, 0));

            cfcAllocation.setCondition(2, Color.FromArgb(192, 255, 0));
            cfcAllocation.setCondition(3, Color.FromArgb(255, 255, 0));
            cfcAllocation.setCondition(4, Color.FromArgb(255, 192, 0));
            cfcAllocation.setCondition(5, Color.FromArgb(255, 128, 0));
            cfcAllocation.setCondition(6, Color.FromArgb(255, 64, 0));
            cfcAllocation.setCondition(7, Color.FromArgb(255, 0, 0));

            mode.ConditionnalFormatClass = new VisualisationMode.ConditionnalFormat[] {cfcAllocation};
            modeVisualisation.Add("Alloc_CITable", mode);

            mode = mode.Clone();
            cfcAllocation = new ConditionnalFormatCharacter(',', true);
            cfcAllocation.setCondition(1, Color.FromArgb(0, 255, 0));
            cfcAllocation.setCondition(2, Color.FromArgb(192, 255, 0));
            cfcAllocation.setCondition(3, Color.FromArgb(255, 255, 0));
            cfcAllocation.setCondition(4, Color.FromArgb(255, 128, 0));
            cfcAllocation.setCondition(5, Color.FromArgb(255, 0, 0));

            mode.ConditionnalFormatClass = new VisualisationMode.ConditionnalFormat[] {cfcAllocation};
            modeVisualisation.Add("Alloc_BoardGateTable", mode);
            modeVisualisation.Add("Alloc_BaggageClaimTable", mode.Clone());
            modeVisualisation.Add("Alloc_ParkingTable", mode.Clone());
            modeVisualisation.Add("Alloc_DepartureParkingTable", mode.Clone());
            modeVisualisation.Add("Alloc_ArrivalParkingTable", mode.Clone());
            modeVisualisation.Add(PEAK_FLOWS_ALLOCATION_BHS_ALLOC_MUP_TABLE_NAME, mode.Clone());    // >> Task #10272 Pax2Sim - MUP Allocation C#9            
            modeVisualisation.Add("FPD_AircraftMovements", mode.Clone());
            modeVisualisation.Add("FPA_AircraftMovements", mode.Clone());
            modeVisualisation.Add(AllocationOutput.ALLOCATION_TEXT_GANTT_TABLE_NAME, mode.Clone());   // >> Task #12808 Pax2Sim - allocation Liege
            

            mode = mode.Clone();
            mode.AllowEditColumn = true;
            mode.Modifiable = true;
            mode.allowSortColumn = null;
            mode.ColumnBlocked = new int[] {0};
            mode.ConditionnalFormatClass = null;
            mode.EditMode = VisualisationMode.EditModeEnum.Cell;
            modeVisualisation.Add(GlobalNames.Alloc_PassportCheckTableName, mode);
            modeVisualisation.Add("Alloc_SecurityCheckTable", mode.Clone());
            modeVisualisation.Add(GlobalNames.Alloc_UserProcessCheckTableName, mode.Clone());    // << Task #7570 new Desk and extra information for Pax -Phase I B
            modeVisualisation.Add(GlobalNames.ProcessScheduleName, mode.Clone());
            modeVisualisation.Add("Alloc_TransferDeskTable", mode.Clone());
            modeVisualisation.Add(GlobalNames.Capa_QueuesTableName, mode.Clone());
            modeVisualisation.Add(GlobalNames.Group_QueuesName, mode.Clone());
            modeVisualisation.Add(GlobalNames.sBHS_Capa_Queues, mode.Clone());
            modeVisualisation.Add(GlobalNames.sBHS_Group_Queues, mode.Clone());
            modeVisualisation.Add("Animated_Queues", mode.Clone());

            mode = mode.Clone();
            mode.AllowAddLine = false;
            mode.AllowEditColumn = false;
            mode.EditMode = VisualisationMode.EditModeEnum.Cell;
            mode.SelectionMode = VisualisationMode.SelectionModeEnum.Cell;
            mode.AllowEditRow = false;
            modeVisualisation.Add("Opening_CITable", mode.Clone());



            mode = new VisualisationMode(true, false, false, new int[] {0}, new int[] {0}, true, true,
                                         Color.White, Color.Blue, Color.Black, Color.White,
                                         VisualisationMode.SelectionModeEnum.Cell,
                                         VisualisationMode.EditModeEnum.Cell, new int[] {0}, null, null, null, null);
            modeVisualisation.Add("FromToShuttleTable", mode.Clone());

            mode = new VisualisationMode(true, false, false, new int[] {0}, new int[] {0}, true, true,
                                         Color.White, Color.Blue, Color.Black, Color.White,
                                         VisualisationMode.SelectionModeEnum.Cell,
                                         VisualisationMode.EditModeEnum.Cell, new int[] {0}, null, null, null, null);
            modeVisualisation.Add(GlobalNames.Transfer_TerminalDitributionTableName, mode.Clone());
            modeVisualisation.Add(GlobalNames.Transfer_FlightCategoryDitributionTableName, mode.Clone());
            mode = new VisualisationMode(true, false, false, null, null, false, false, Color.White, Color.Blue,
                                         Color.Black,
                                         Color.White, VisualisationMode.SelectionModeEnum.Column,
                                         VisualisationMode.EditModeEnum.Column,
                                         null, null, null, null, null);
            mode.AllowEditColumn = true;
            modeVisualisation.Add("OneofSpecificationTable", mode);

            #endregion

            #region Partie BHS

            mode = new VisualisationMode(true, false, false, new int[] {0}, new int[] {0}, true, true, Color.White,
                                         Color.Blue, Color.Black, Color.White, VisualisationMode.SelectionModeEnum.Cell,
                                         VisualisationMode.EditModeEnum.Cell,
                                         null, new int[] {150, 40}, null, null, null);
            modeVisualisation.Add("General", mode.Clone());
            modeVisualisation.Add("Process", mode.Clone());
            mode = new VisualisationMode(false, false, true, null, new int[] {0}, false, false, Color.White,
                                         Color.Blue, Color.Black, Color.White, VisualisationMode.SelectionModeEnum.Cell,
                                         VisualisationMode.EditModeEnum.None,
                                         new int[] {0}, new int[] {70, 70, 70}, null, null, null);
            modeVisualisation.Add("CI_Groups", mode);
            modeVisualisation.Add("ArrivalInfeed_Groups", mode.Clone());
            modeVisualisation.Add("TransferInfeed_Groups", mode.Clone());
            mode = new VisualisationMode(true, false, true, new int[] {0}, new int[] {0}, true, true, Color.White,
                                         Color.Blue, Color.Black, Color.White, VisualisationMode.SelectionModeEnum.Row,
                                         VisualisationMode.EditModeEnum.Row,
                                         new int[] {0}, new int[] {70, 70, 70}, null, null, null);
            modeVisualisation.Add("CI_Collectors", mode);

            mode = new VisualisationMode(true, false, true, new int[] {0}, new int[] {0}, true, true, Color.White,
                                         Color.Blue, Color.Black, Color.White, VisualisationMode.SelectionModeEnum.Row,
                                         VisualisationMode.EditModeEnum.Row,
                                         new int[] {0}, null, null, null, null);
            modeVisualisation.Add(GlobalNames.sBHS_CI_Routing, mode);
            modeVisualisation.Add(GlobalNames.sBHS_Transfer_Routing, mode.Clone());
            modeVisualisation.Add(GlobalNames.sBHS_HBS3_Routing, mode.Clone());

            mode = new VisualisationMode(true, false, false, new int[] {0}, new int[] {0}, true, true, Color.White,
                                         Color.Blue, Color.Black, Color.White,
                                         VisualisationMode.SelectionModeEnum.Column,
                                         VisualisationMode.EditModeEnum.Column,
                                         new int[] {0}, new int[] {150, 30}, null, null, null);
            //modeVisualisation.Add("OCT_MakeUp", mode);
            modeVisualisation.Add("Flow_Split", mode.Clone());

            cfcAllocation = new ConditionnalFormatCharacter(',', true);
            cfcAllocation.setCondition(1, Color.FromArgb(0, 255, 0));
            cfcAllocation.setCondition(2, Color.FromArgb(192, 255, 0));
            cfcAllocation.setCondition(3, Color.FromArgb(255, 128, 0));
            cfcAllocation.setCondition(4, Color.FromArgb(255, 0, 0));
            mode = new VisualisationMode(false, false, false, new int[] {0}, new int[] {0}, true, true, Color.White,
                                         Color.Blue, Color.Black, Color.White, VisualisationMode.SelectionModeEnum.Cell,
                                         VisualisationMode.EditModeEnum.None,
                                         new int[] {0}, null, null, null,
                                         new VisualisationMode.ConditionnalFormat[] {cfcAllocation});
            modeVisualisation.Add("Alloc_MakeUp", mode);

            mode = new VisualisationMode(true, false, false, new int[] {0}, new int[] {0}, true, true, Color.White,
                                         Color.Blue, Color.Black, Color.White, VisualisationMode.SelectionModeEnum.Cell,
                                         VisualisationMode.EditModeEnum.Cell, null, null, null, null, null);
            modeVisualisation.Add("Mean_Flows_Arrival_Infeed", mode);
            modeVisualisation.Add("Mean_Flows_Check_In", mode.Clone());
            modeVisualisation.Add("Mean_Flows_Transfer_Infeed", mode.Clone());
            mode = new VisualisationMode(true, false, false, new int[] {0}, new int[] {0}, true, true, Color.White,
                                         Color.Blue,
                                         Color.Black, Color.White, VisualisationMode.SelectionModeEnum.Column,
                                         VisualisationMode.EditModeEnum.Column, new int[] {0}, null, null,
                                         null, null);
            modeVisualisation.Add("Arrival_Containers", mode);


            #endregion

            #region Mode de visualisation pour les tables d'utilisation des ressources :

            ConditionnalFormatValue cfcAllocationVal = new ConditionnalFormatValue();
            cfcAllocationVal.setCondition(0, Color.FromArgb(255, 255, 255));
            cfcAllocationVal.setCondition(1, Color.FromArgb(0, 255, 0));
            cfcAllocationVal.setCondition(25, Color.FromArgb(192, 255, 0));
            cfcAllocationVal.setCondition(50, Color.FromArgb(255, 192, 0));
            cfcAllocationVal.setCondition(75, Color.FromArgb(255, 128, 0));
            cfcAllocationVal.setCondition(100, Color.FromArgb(255, 0, 0));

            UtilizationTableVisualisationMode = new VisualisationMode(false, false, false, new int[] {0, 1},
                                                                      new int[] {0}, false, false,
                                                                      Color.White, Color.Blue, Color.Black, Color.White,
                                                                      VisualisationMode.SelectionModeEnum.Row,
                                                                      VisualisationMode.EditModeEnum.None,
                                                                      new int[] {0, 1}, null, null, null,
                                                                      new VisualisationMode.ConditionnalFormat[]
                                                                          {cfcAllocationVal});

            ConditionnalFormatValue cfcBlue = new ConditionnalFormatValue();
            cfcBlue.setCondition(0, Color.FromArgb(157, 184, 255));

            UtilizationGroupTableVisualisationMode = new VisualisationMode(false, false, false, new int[] {0, 1},
                                                                           new int[] {0}, false, false,
                                                                           Color.White, Color.Blue, Color.Black,
                                                                           Color.White,
                                                                           VisualisationMode.SelectionModeEnum.Row,
                                                                           VisualisationMode.EditModeEnum.None,
                                                                           new int[] {0, 1}, null, null,
                                                                           new int[2][]
                                                                               {
                                                                                   new int[1] {-1}, new int[2] {2, 3}
                                                                                   /*, new int[1] { 3 }*/
                                                                               },
                                                                           new VisualisationMode.ConditionnalFormat[]
                                                                               {
                                                                                   cfcAllocationVal, cfcBlue
                                                                                   /*, cfcDesks */
                                                                               });
            // Probleme avec stat occupation en mode BHS 18.07.2012
            UtilizationBHSGroupTableVisualisationMode = new VisualisationMode(false, false, false, new int[] { 0, 1 },
                                                                           new int[] { 0 }, false, false,
                                                                           Color.White, Color.Blue, Color.Black,
                                                                           Color.White,
                                                                           VisualisationMode.SelectionModeEnum.Row,
                                                                           VisualisationMode.EditModeEnum.None,
                                                                           new int[] { 0, 1 }, null, null,
                                                                           new int[1][]
                                                                               {
                                                                                   new int[1] {-1}
                                                                                   /*, new int[1] { 3 }*/
                                                                               },
                                                                           new VisualisationMode.ConditionnalFormat[]
                                                                               {
                                                                                   cfcAllocationVal
                                                                                   /*, cfcDesks */
                                                                               });



            ConditionnalFormatLine Format = new ConditionnalFormatLine();
            for (int j = 0; j < 20; j++)
            {
                Format.setCondition(j*2, Color.FromArgb(200, 255, 255));
                Format.setCondition(j*2 + 1, Color.FromArgb(255, 255, 180));
            }

            RapportTableVisualisationMode = new VisualisationMode[5];
            //Airport
            RapportTableVisualisationMode[0] = new VisualisationMode(true, false, false, new int[2] {0, 1},
                                                                     new int[1] {0});
            RapportTableVisualisationMode[0].ConditionnalFormatClass = new VisualisationMode.ConditionnalFormat[1];
            RapportTableVisualisationMode[0].ConditionnalFormatClass[0] =
                (VisualisationMode.ConditionnalFormat) Format.Clone();
            //Terminal
            RapportTableVisualisationMode[1] = RapportTableVisualisationMode[0].Clone();
            //Level
            RapportTableVisualisationMode[2] = RapportTableVisualisationMode[0].Clone();
            //Group
            RapportTableVisualisationMode[3] = RapportTableVisualisationMode[0].Clone();
            //Station
            RapportTableVisualisationMode[4] = RapportTableVisualisationMode[0].Clone();
            //Group

            StaticRapportVisualisationMode = new VisualisationMode(true, false, false, new int[2] {0, 1}, new int[1] {0});
            StaticRapportVisualisationMode.ConditionnalFormatClass = new VisualisationMode.ConditionnalFormat[1];
            Format = new ConditionnalFormatLine();
            // i < 30 -> i < 100 << Task #7530 Analyze Bag Trace module - Recirculation statistics
            // this increases the number of rows affected from 61 to 201
            for (int i = 0; i < 200; i++)   // was 100 // >> Task #11030 Pax2Sim - BHS analysis - HBS extended statistics 
            {

                Format.setCondition(i*2, Color.FromArgb(200, 255, 255));
                Format.setCondition(i * 2 + 1, Color.FromArgb(255, 255, 180));
            }

            /*Format.setCondition(1, Color.FromArgb(200, 255, 255));
            Format.setCondition(2, Color.FromArgb(200, 255, 255));

            Format.setCondition(3, Color.FromArgb(255, 255, 180));
            Format.setCondition(4, Color.FromArgb(255, 255, 180));
            Format.setCondition(5, Color.FromArgb(255, 255, 180));

            Format.setCondition(6, Color.FromArgb(200, 255, 255));
            Format.setCondition(7, Color.FromArgb(200, 255, 255));
            Format.setCondition(8, Color.FromArgb(200, 255, 255));

            Format.setCondition(9, Color.FromArgb(255, 255, 180));
            Format.setCondition(10, Color.FromArgb(255, 255, 180));
            Format.setCondition(11, Color.FromArgb(255, 255, 180));

            Format.setCondition(12, Color.FromArgb(200, 255, 255));
            Format.setCondition(13, Color.FromArgb(200, 255, 255));
            Format.setCondition(14, Color.FromArgb(200, 255, 255));

            Format.setCondition(15, Color.FromArgb(255, 255, 180));
            Format.setCondition(16, Color.FromArgb(255, 255, 180));
            Format.setCondition(17, Color.FromArgb(255, 255, 180));

            Format.setCondition(18, Color.FromArgb(200, 255, 255));
            Format.setCondition(19, Color.FromArgb(200, 255, 255));
            Format.setCondition(20, Color.FromArgb(200, 255, 255));

            Format.setCondition(21, Color.FromArgb(255, 255, 180));
            Format.setCondition(22, Color.FromArgb(255, 255, 180));
            Format.setCondition(23, Color.FromArgb(255, 255, 180));

            Format.setCondition(24, Color.FromArgb(200, 255, 255));
            Format.setCondition(25, Color.FromArgb(200, 255, 255));
            Format.setCondition(26, Color.FromArgb(200, 255, 255));

            Format.setCondition(27, Color.FromArgb(255, 255, 180));
            Format.setCondition(28, Color.FromArgb(255, 255, 180));
            Format.setCondition(29, Color.FromArgb(255, 255, 180));

            Format.setCondition(30, Color.FromArgb(200, 255, 255));
            Format.setCondition(31, Color.FromArgb(200, 255, 255));
            Format.setCondition(32, Color.FromArgb(200, 255, 255));

            Format.setCondition(33, Color.FromArgb(255, 255, 180));
            Format.setCondition(34, Color.FromArgb(255, 255, 180));
            Format.setCondition(35, Color.FromArgb(255, 255, 180));

            Format.setCondition(36, Color.FromArgb(200, 255, 255));
            Format.setCondition(37, Color.FromArgb(200, 255, 255));
            Format.setCondition(38, Color.FromArgb(200, 255, 255));

            Format.setCondition(39, Color.FromArgb(255, 255, 180));
            Format.setCondition(40, Color.FromArgb(255, 255, 180));
            Format.setCondition(41, Color.FromArgb(255, 255, 180));

            Format.setCondition(42, Color.FromArgb(200, 255, 255));
            Format.setCondition(43, Color.FromArgb(200, 255, 255));
            Format.setCondition(44, Color.FromArgb(200, 255, 255));*/

            StaticRapportVisualisationMode.ConditionnalFormatClass[0] = (VisualisationMode.ConditionnalFormat)Format;
            #endregion

            #region Mode de visualisation pour les tables résultats de BHS
            #endregion
        }
        #endregion

        #region Chargement des classes de vérification des tables.
        private static void InitialiazePaxCheck()
        {
            /*htChecks = new Hashtable();
            OverallTools.TableCheck tcTmp = new OverallTools.TableCheck(GlobalNames.FPDTableName,
                new String[] { GlobalNames.sFPD_A_Column_DATE },
                new String[] { GlobalNames.sFPD_A_Column_FlightCategory, GlobalNames.sFPD_A_Column_AircraftType },
                new String[] { GlobalNames.FP_FlightCategoriesTableName, GlobalNames.FP_AircraftTypesTableName },
                new string[] { GlobalNames.sFPD_A_Column_ID, GlobalNames.sFPD_A_Column_NbSeats, });
            tcTmp.ObjectType = new String[][] { new String[]{"Check In"},
                                                new String[]{"Check In"},
                                                new String[]{GlobalNames.sFPD_Column_BoardingGate}
                                              };
            tcTmp.CanBeNull = new Boolean[] { false, false, false };
            tcTmp.ObjectColumns = new String[][] { new String[]{GlobalNames.sFPD_Column_TerminalCI,"", GlobalNames.sFPD_Column_Eco_CI_Start, GlobalNames.sFPD_Column_Eco_CI_End},
                                                new String[]{GlobalNames.sFPD_Column_TerminalCI,"", GlobalNames.sFPD_Column_FB_CI_Start, GlobalNames.sFPD_Column_FB_CI_End},
                                                new String[]{GlobalNames.sFPD_A_Column_TerminalGate, "", GlobalNames.sFPD_Column_BoardingGate}
                                              };

            htChecks.Add(GlobalNames.FPDTableName, tcTmp);
            tcTmp = new OverallTools.TableCheck(GlobalNames.FPATableName,
                new String[] { GlobalNames.sFPD_A_Column_DATE },
                new String[] { GlobalNames.sFPD_A_Column_FlightCategory, GlobalNames.sFPD_A_Column_AircraftType },
                new String[] { GlobalNames.FP_FlightCategoriesTableName, GlobalNames.FP_AircraftTypesTableName },
                new string[] { GlobalNames.sFPD_A_Column_ID, GlobalNames.sFPD_A_Column_NbSeats, });
            tcTmp.ObjectType = new String[][] { new String[]{"Arrival Gate"},
                                                new String[]{"Baggage Claim"}
                                              };
            tcTmp.CanBeNull = new Boolean[] { false, false };
            tcTmp.ObjectColumns = new String[][] { new String[]{GlobalNames.sFPD_A_Column_TerminalGate, "", GlobalNames.sFPA_Column_ArrivalGate},
                                                new String[]{GlobalNames.sFPA_Column_TerminalReclaim, "", GlobalNames.sFPA_Column_ReclaimObject}
                                              };
            htChecks.Add(GlobalNames.FPATableName, tcTmp);
            tcTmp = new OverallTools.TableCheck(GlobalNames.FPLinksTableName, OverallTools.TableCheck.eTypeAnalyze.FPLinksTable);
            htChecks.Add(GlobalNames.FPLinksTableName, tcTmp);

            tcTmp = new OverallTools.TableCheck(GlobalNames.FP_AircraftTypesTableName, null, null, null, new string[] { GlobalNames.sFPAircraft_NumberSeats });
            htChecks.Add(GlobalNames.FP_AircraftTypesTableName, tcTmp);

            //Les load factors sont à vérifier.
            tcTmp = new OverallTools.TableCheck(GlobalNames.FPD_LoadFactorsTableName, OverallTools.TableCheck.eTypeAnalyze.LoadFactorDeparture);
            htChecks.Add(GlobalNames.FPD_LoadFactorsTableName, tcTmp);
            tcTmp = new OverallTools.TableCheck(GlobalNames.FPA_LoadFactorsTableName, OverallTools.TableCheck.eTypeAnalyze.LoadFactorArrival);
            htChecks.Add(GlobalNames.FPA_LoadFactorsTableName, tcTmp);


            tcTmp = new OverallTools.TableCheck(GlobalNames.Transfer_ICTTableName, null, null, null, null, null, null, 2, null, OverallTools.TableCheck.eTypeAnalyze.None);
            htChecks.Add(GlobalNames.Transfer_ICTTableName, tcTmp);
            tcTmp = new OverallTools.TableCheck(GlobalNames.CI_ShowUpTableName, null, null, null, null, null, null, 2, null, OverallTools.TableCheck.eTypeAnalyze.None);
            htChecks.Add(GlobalNames.CI_ShowUpTableName, tcTmp);
            tcTmp = new OverallTools.TableCheck(GlobalNames.NbBagsTableName, null, null, null, null, null, null, 1, null, OverallTools.TableCheck.eTypeAnalyze.None);
            htChecks.Add(GlobalNames.NbBagsTableName, tcTmp);
            tcTmp = new OverallTools.TableCheck(GlobalNames.NbVisitorsTableName, null, null, null, null, null, null, 1, null, OverallTools.TableCheck.eTypeAnalyze.None);
            htChecks.Add(GlobalNames.NbVisitorsTableName, tcTmp);
            tcTmp = new OverallTools.TableCheck(GlobalNames.NbTrolleyTableName, null, null, null, null, null, null, 2, "Nb Baggage", OverallTools.TableCheck.eTypeAnalyze.None);
            htChecks.Add(GlobalNames.NbTrolleyTableName, tcTmp);

            tcTmp = new OverallTools.TableCheck("Alloc_PassportCheckTable", OverallTools.TableCheck.eTypeAnalyze.PassportAllocation);
            htChecks.Add("Alloc_PassportCheckTable", tcTmp);
            tcTmp = new OverallTools.TableCheck("Alloc_SecurityCheckTable", OverallTools.TableCheck.eTypeAnalyze.SecurityAllocation);
            htChecks.Add("Alloc_SecurityCheckTable", tcTmp);
            tcTmp = new OverallTools.TableCheck("Alloc_TransferDeskTable", OverallTools.TableCheck.eTypeAnalyze.TransferAllocation);
            htChecks.Add("Alloc_TransferDeskTable", tcTmp);

            tcTmp = new OverallTools.TableCheck("Animated_Queues", OverallTools.TableCheck.eTypeAnalyze.AnimatedQueues);
            htChecks.Add("Animated_Queues", tcTmp);

            tcTmp = new OverallTools.TableCheck(GlobalNames.Times_ProcessTableName, null, null, null, null, new String[] { "Distrib_1", "Distrib_2" }, "OneofSpecificationTable", 2, "NbBaggage", OverallTools.TableCheck.eTypeAnalyze.ProcessTable);
            htChecks.Add(GlobalNames.Times_ProcessTableName, tcTmp);
            tcTmp = new OverallTools.TableCheck(GlobalNames.ItineraryTableName, null, null, null, null, new String[] { "Distribution" }, "OneofSpecificationTable", 2, "NbBaggage", OverallTools.TableCheck.eTypeAnalyze.None);
            htChecks.Add(GlobalNames.ItineraryTableName, tcTmp);

           
            //Pour les OCT.
            tcTmp = new OverallTools.TableCheck("OCT_CITable", true, false);
            htChecks.Add("OCT_CITable", tcTmp);
            tcTmp = new OverallTools.TableCheck("OCT_BoardGateTable", true, false);
            htChecks.Add("OCT_BoardGateTable", tcTmp);
            tcTmp = new OverallTools.TableCheck("OCT_BaggageClaimTable", false, true);
            htChecks.Add("OCT_BaggageClaimTable", tcTmp);
            tcTmp = new OverallTools.TableCheck("OCT_ParkingTable", true, true);
            htChecks.Add("OCT_ParkingTable", tcTmp);
            */
        }
        private void ChangeAlphaNumericalChecks(bool bNewValue)
        {
            bUseAlphNumericForFlightInfo = bNewValue;
            /*On convertit l'ensemble des plans de vol pour afficher les descriptions de groupes à la place des index.*/
            /*ConvertFPDInformations(*/
            DataManagement.DataManagerInput gsInput = InputData;
            if (gsInput == null)
                return;
            List<String> lsTables = gsInput.getTableFilters(GlobalNames.FPDTableName);
            foreach (String sTableName in lsTables)
            {
                DataTable dtTable = gsInput.GetTable(sTableName).Table;
                ConvertFPDInformations(dtTable, structureAeroport, bUseAlphNumericForFlightInfo);
            }
            lsTables = gsInput.getTableFilters(GlobalNames.FPATableName);
            foreach (String sTableName in lsTables)
            {
                DataTable dtTable = gsInput.GetTable(sTableName).Table;
                ConvertFPAInformations(dtTable, structureAeroport, bUseAlphNumericForFlightInfo);
            }
        }
        private void InitializeAllocationDependances()
        {
            htAllocationDependances = new Dictionary<String, AllocationDependances>();
            AllocationDependances adTmp = new AllocationDependances();
            adTmp.addDependance(GlobalNames.FPDTableName);
            adTmp.addDependance("OCT_CITable");
            adTmp.addDependance("FlightCategoriesTable");
            htAllocationDependances.Add("Alloc_CITable", adTmp);

            adTmp = new AllocationDependances();
            adTmp.addDependance(GlobalNames.FPATableName);
            adTmp.addDependance("OCT_BaggageClaimTable");
            adTmp.addDependance("FlightCategoriesTable");
            htAllocationDependances.Add("Alloc_BaggageClaimTable", adTmp);

            adTmp = new AllocationDependances();
            adTmp.addDependance(GlobalNames.FPDTableName);
            adTmp.addDependance("OCT_BoardGateTable");
            adTmp.addDependance("FlightCategoriesTable");
            htAllocationDependances.Add("Alloc_BoardGateTable", adTmp);

            adTmp = new AllocationDependances();
            adTmp.addDependance(GlobalNames.FPDTableName);
            adTmp.addDependance(GlobalNames.FPATableName);
            adTmp.addDependance(GlobalNames.FPLinksTableName);
            adTmp.addDependance("OCT_ParkingTable");
            adTmp.addDependance("FlightCategoriesTable");
            htAllocationDependances.Add("Alloc_ParkingTable", adTmp);
        }
        #endregion

        #region Définition de la structure des résultats statiques
        public const string PEAK_FLOWS_ALLOCATION_BHS_ALLOC_MUP_TABLE_NAME = "BHS_Alloc_MakeUp";    // >> Task #10272 Pax2Sim - MUP Allocation C#9        
        private static String[] StaticResultsAllocation = new String[] { "Alloc_CITable", 
                "Alloc_BoardGateTable", "Alloc_BaggageClaimTable", "Alloc_ParkingTable", 
                "Alloc_DepartureParkingTable", "Alloc_ArrivalParkingTable", 
                PEAK_FLOWS_ALLOCATION_BHS_ALLOC_MUP_TABLE_NAME
        };
        public static String[] StaticResultsFPD = new String[] { "FPD_Peak_Stats",
             "FPD_AircraftMovements", "FPD_AircraftMovementsRolling", "FPD_AircraftMovementsInstantaneous", 
            "FPD_OutBoundRolling", "FPD_OutBoundInstantaneous", 
            "FPD_CheckInShowUpRolling", "FPD_CheckInShowUpInstantaneous", 
            GlobalNames.FPD_TRANSFER_ICT_ROLLING, GlobalNames.FPD_TRANSFER_ICT_INSTANTANEOUS,   // >> Bug #11860 Pax2Sim - Static analysis - EBS calculation FB exception 2
            "FPD_PAXFlightDistribution", "FPD_FlightCategoriesDistribution",             
                #region //SGE-03/04/2012-Begin
             GlobalNames.FPD_EBS_ROLLING_TABLE_NAME,
             EbsStatisticsGenerator.GLOBAL_EBS_SUMMARY_TABLE_NAME, EbsLogger.GLOBAL_EBS_ISSUES_TABLE_NAME,    // >> Task #9171 Pax2Sim - Static Analysis - EBS algorithm - Throughputs C#5
                #endregion //SGE-03/04/2012-ENd
            "FPD_ParkingForTerminal_2", "FPD_Airport Statistics", "FPD_Airline Statistics", "FPD_Ground Handlers Statistics",  
            "FPD_Airline_Stats","FPD_AircraftMovements_Airline",
            "FPD_CheckInShowUpRolling_Airline", "FPD_CheckInShowUpInstantaneous_Airline",
            "FPD_CheckInShowUpRolling_Bag_Airline", "FPD_CheckInShowUpInstantaneous_Bag_Airline",
            "FPD_OutBoundRolling_Airline", "FPD_OutBoundInstantaneous_Airline",
            // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
            GlobalNames.fpdOutboundSmoothedPAXOriginating_Airline, GlobalNames.fpdOutboundInstantaneousPAXOriginating_Airline,
            GlobalNames.fpdOutboundSmoothedPAXTransferring_Airline, GlobalNames.fpdOutboundInstantaneousPAXTransferring_Airline,
            // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation
            "FPD_OutBoundRolling_Bag_Airline", "FPD_OutBoundInstantaneous_Bag_Airline",
            // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
            GlobalNames.fpdOutboundSmoothedBagOriginating_Airline, GlobalNames.fpdOutboundInstantaneousBagOriginating_Airline,
            GlobalNames.fpdOutboundSmoothedBagTransferring_Airline, GlobalNames.fpdOutboundInstantaneousBagTransferring_Airline,
            // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation
            GlobalNames.FPD_TRANSFER_ICT_ROLLING + "_Airline", 
            GlobalNames.FPD_TRANSFER_ICT_INSTANTANEOUS + "_Airline",
            GlobalNames.FPD_TRANSFER_ICT_ROLLING + "_Bag_Airline",            
            GlobalNames.FPD_TRANSFER_ICT_INSTANTANEOUS + "_Bag_Airline"
            ,
            "FPD_Terminal_Stats", "FPD_AircraftMovements_Terminal",
            "FPD_CheckInShowUpRolling_Terminal", "FPD_CheckInShowUpInstantaneous_Terminal",
            "FPD_CheckInShowUpRolling_Bag_Terminal", "FPD_CheckInShowUpInstantaneous_Bag_Terminal",
            "FPD_OutBoundRolling_Terminal", "FPD_OutBoundInstantaneous_Terminal", 
            // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
            GlobalNames.fpdOutboundSmoothedPAXOriginating_Terminal, GlobalNames.fpdOutboundInstantaneousPAXOriginating_Terminal,
            GlobalNames.fpdOutboundSmoothedPAXTransferring_Terminal, GlobalNames.fpdOutboundInstantaneousPAXTransferring_Terminal,
            // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation
            "FPD_OutBoundRolling_Bag_Terminal", "FPD_OutBoundInstantaneous_Bag_Terminal",
            // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
            GlobalNames.fpdOutboundSmoothedBagOriginating_Terminal, GlobalNames.fpdOutboundInstantaneousBagOriginating_Terminal,
            GlobalNames.fpdOutboundSmoothedBagTransferring_Terminal, GlobalNames.fpdOutboundInstantaneousBagTransferring_Terminal,
            // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation
            GlobalNames.FPD_TRANSFER_ICT_ROLLING + "_Terminal", 
            GlobalNames.FPD_TRANSFER_ICT_INSTANTANEOUS + "_Terminal",
            GlobalNames.FPD_TRANSFER_ICT_ROLLING + "_Bag_Terminal",            
            GlobalNames.FPD_TRANSFER_ICT_INSTANTANEOUS + "_Bag_Terminal"
            ,
            "FPD_FC_Stats", "FPD_AircraftMovements_FC",
            "FPD_CheckInShowUpRolling_FC", "FPD_CheckInShowUpInstantaneous_FC",
            "FPD_CheckInShowUpRolling_Bag_FC", "FPD_CheckInShowUpInstantaneous_Bag_FC",
            "FPD_OutBoundRolling_FC", "FPD_OutBoundInstantaneous_FC",
            // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
            GlobalNames.fpdOutBoundSmoothedPAXOriginating_FC, GlobalNames.fpdOutBoundInstantaneousPAXOriginating_FC,
            GlobalNames.fpdOutBoundSmoothedPAXTransfering_FC, GlobalNames.fpdOutBoundInstantaneousPAXTransfering_FC,
            // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation
            "FPD_OutBoundRolling_Bag_FC", "FPD_OutBoundInstantaneous_Bag_FC",
            // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
            GlobalNames.fpdOutBoundSmoothedBagOriginating_FC, GlobalNames.fpdOutBoundInstantaneousBagOriginating_FC,
            GlobalNames.fpdOutBoundSmoothedBagTransfering_FC, GlobalNames.fpdOutBoundInstantaneousBagTransfering_FC,
            GlobalNames.FPD_TRANSFER_ICT_ROLLING + "_FC", 
            GlobalNames.FPD_TRANSFER_ICT_INSTANTANEOUS + "_FC",
            GlobalNames.FPD_TRANSFER_ICT_ROLLING + "_Bag_FC",            
            GlobalNames.FPD_TRANSFER_ICT_INSTANTANEOUS + "_Bag_FC",
            GlobalNames.FPD_flightInformationTableName
            ,
            "FPD_FSC_Stats", "FPD_AircraftMovements_FSC",
            "FPD_CheckInShowUpRolling_FSC", "FPD_CheckInShowUpInstantaneous_FSC",
            "FPD_CheckInShowUpRolling_Bag_FSC", "FPD_CheckInShowUpInstantaneous_Bag_FSC",
            "FPD_OutBoundRolling_FSC", "FPD_OutBoundInstantaneous_FSC",
            GlobalNames.fpdOutBoundSmoothedPAXOriginating_FSC, GlobalNames.fpdOutBoundInstantaneousPAXOriginating_FSC,
            GlobalNames.fpdOutBoundSmoothedPAXTransfering_FSC, GlobalNames.fpdOutBoundInstantaneousPAXTransfering_FSC,
            "FPD_OutBoundRolling_Bag_FSC", "FPD_OutBoundInstantaneous_Bag_FSC",
            GlobalNames.fpdOutBoundSmoothedBagOriginating_FSC, GlobalNames.fpdOutBoundInstantaneousBagOriginating_FSC,
            GlobalNames.fpdOutBoundSmoothedBagTransfering_FSC, GlobalNames.fpdOutBoundInstantaneousBagTransfering_FSC,
            // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation
            GlobalNames.FPD_TRANSFER_ICT_ROLLING + "_FSC", 
            GlobalNames.FPD_TRANSFER_ICT_INSTANTANEOUS + "_FSC",
            GlobalNames.FPD_TRANSFER_ICT_ROLLING + "_Bag_FSC",            
            GlobalNames.FPD_TRANSFER_ICT_INSTANTANEOUS + "_Bag_FSC"
        };
        private static String[] StaticResultsFPA = new String[] { "FPA_Peak_Stats",
            GlobalNames.fpaPeakStatsBHSTableName,   // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
            "FPA_AircraftMovements" ,"FPA_AircraftMovementsRolling", "FPA_AircraftMovementsInstantaneous", 
            "FPA_InBoundRolling", "FPA_InBoundInstantaneous", 
            GlobalNames.paxGateSmoothedBHSTableName, GlobalNames.paxGateInstantaneousBHSTableName,  // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
            
            "FPA_TransferICTRolling", "FPA_TransferICTInstantaneous", 
            "FPA_PAXFlightDistribution", "FPA_FlightCategoriesDistribution", "FPA_ParkingForTerminal_2",
            "FPA_Airport Statistics", "FPA_Airline Statistics", "FPA_Ground Handlers Statistics",
            "FPA_Airline_Stats",
            "FPA_AircraftMovements_Airline",    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
            "FPA_InBoundRolling_Airline", "FPA_InBoundInstantaneous_Airline",
            // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
            GlobalNames.fpaInboundSmoothedPAXTerminating_Airline, GlobalNames.fpaInboundInstantaneousPAXTerminating_Airline,
            GlobalNames.fpaInboundSmoothedPAXTransferring_Airline, GlobalNames.fpaInboundInstantaneousPAXTransferring_Airline,
            // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation
            "FPA_InBoundRolling_Bag_Airline", "FPA_InBoundInstantaneous_Bag_Airline",
            // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
            GlobalNames.fpaInboundSmoothedBagTerminating_Airline, GlobalNames.fpaInboundInstantaneousBagTerminating_Airline,
            GlobalNames.fpaInboundSmoothedBagTransferring_Airline, GlobalNames.fpaInboundInstantaneousBagTransferring_Airline,
            // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation
            GlobalNames.paxGateSmoothedBHSTableName + "_Total_Airline", GlobalNames.paxGateInstantaneousBHSTableName + "_Total_Airline",            // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
            GlobalNames.paxGateSmoothedBHSTableName + "_Terminating_Airline", GlobalNames.paxGateInstantaneousBHSTableName + "_Terminating_Airline",    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
            GlobalNames.paxGateSmoothedBHSTableName + "_Transfering_Airline", GlobalNames.paxGateInstantaneousBHSTableName + "_Transfering_Airline",    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant           
             // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation            
            GlobalNames.FPA_TransferICTSmoothedTableName + "_Airline", 
            GlobalNames.FPA_TransferICTInstantaneousTableName + "_Airline",
            GlobalNames.FPA_TransferICTSmoothedTableName + "_Bag_Airline",            
            GlobalNames.FPA_TransferICTInstantaneousTableName + "_Bag_Airline",
            // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

            "FPA_Terminal_Stats",   // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
            "FPA_AircraftMovements_Terminal",
            "FPA_InBoundRolling_Terminal", "FPA_InBoundInstantaneous_Terminal",
            "FPA_InBoundRolling_Bag_Terminal", "FPA_InBoundInstantaneous_Bag_Terminal",
            GlobalNames.paxGateSmoothedBHSTableName + "_Total_Terminal", GlobalNames.paxGateInstantaneousBHSTableName + "_Total_Terminal",            // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
            GlobalNames.paxGateSmoothedBHSTableName + "_Terminating_Terminal", GlobalNames.paxGateInstantaneousBHSTableName + "_Terminating_Terminal",    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
            GlobalNames.paxGateSmoothedBHSTableName + "_Transfering_Terminal", GlobalNames.paxGateInstantaneousBHSTableName + "_Transfering_Terminal",    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant           
            // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
            GlobalNames.fpaInboundSmoothedPAXTerminating_Terminal, GlobalNames.fpaInboundInstantaneousPAXTerminating_Terminal,
            GlobalNames.fpaInboundSmoothedPAXTransferring_Terminal, GlobalNames.fpaInboundInstantaneousPAXTransferring_Terminal,
            GlobalNames.fpaInboundSmoothedBagTerminating_Terminal, GlobalNames.fpaInboundInstantaneousBagTerminating_Terminal,
            GlobalNames.fpaInboundSmoothedBagTransferring_Terminal, GlobalNames.fpaInboundInstantaneousBagTransferring_Terminal,
            GlobalNames.FPA_TransferICTSmoothedTableName + "_Terminal", 
            GlobalNames.FPA_TransferICTInstantaneousTableName + "_Terminal",
            GlobalNames.FPA_TransferICTSmoothedTableName + "_Bag_Terminal",            
            GlobalNames.FPA_TransferICTInstantaneousTableName + "_Bag_Terminal",
            // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

            "FPA_FC_Stats", // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
            "FPA_AircraftMovements_FC",
            "FPA_InBoundRolling_FC", "FPA_InBoundInstantaneous_FC",
            // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
            GlobalNames.fpaInboundSmoothedPAXTerminating_FC, GlobalNames.fpaInboundInstantaneousPAXTerminating_FC,
            GlobalNames.fpaInboundSmoothedPAXTransfering_FC, GlobalNames.fpaInboundInstantaneousPAXTransfering_FC,
            // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation
            "FPA_InBoundRolling_Bag_FC", "FPA_InBoundInstantaneous_Bag_FC",
            // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
            GlobalNames.fpaInboundSmoothedBagTerminating_FC, GlobalNames.fpaInboundInstantaneousBagTerminating_FC,
            GlobalNames.fpaInboundSmoothedBagTransfering_FC, GlobalNames.fpaInboundInstantaneousBagTransfering_FC,
            // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation
            GlobalNames.paxGateSmoothedBHSTableName + "_Total_FC", GlobalNames.paxGateInstantaneousBHSTableName + "_Total_FC",            // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
            GlobalNames.paxGateSmoothedBHSTableName + "_Terminating_FC", GlobalNames.paxGateInstantaneousBHSTableName + "_Terminating_FC",    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
            GlobalNames.paxGateSmoothedBHSTableName + "_Transfering_FC", GlobalNames.paxGateInstantaneousBHSTableName + "_Transfering_FC",    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

            // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
            GlobalNames.FPA_TransferICTSmoothedTableName + "_FC", 
            GlobalNames.FPA_TransferICTInstantaneousTableName + "_FC",
            GlobalNames.FPA_TransferICTSmoothedTableName + "_Bag_FC",            
            GlobalNames.FPA_TransferICTInstantaneousTableName + "_Bag_FC",
            // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

            // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
            GlobalNames.FPA_flightInformationTableName, "FPA_FSC_Stats",
            "FPA_AircraftMovements_FSC",
            "FPA_InBoundRolling_FSC", "FPA_InBoundInstantaneous_FSC",
            GlobalNames.fpaInboundSmoothedPAXTerminating_FSC, GlobalNames.fpaInboundInstantaneousPAXTerminating_FSC,
            GlobalNames.fpaInboundSmoothedPAXTransfering_FSC, GlobalNames.fpaInboundInstantaneousPAXTransfering_FSC,
            "FPA_InBoundRolling_Bag_FSC", "FPA_InBoundInstantaneous_Bag_FSC",
            GlobalNames.fpaInboundSmoothedBagTerminating_FSC, GlobalNames.fpaInboundInstantaneousBagTerminating_FSC,
            GlobalNames.fpaInboundSmoothedBagTransfering_FSC, GlobalNames.fpaInboundInstantaneousBagTransfering_FSC,
            GlobalNames.paxGateSmoothedBHSTableName + "_Total_FSC", GlobalNames.paxGateInstantaneousBHSTableName + "_Total_FSC",
            GlobalNames.paxGateSmoothedBHSTableName + "_Terminating_FSC", GlobalNames.paxGateInstantaneousBHSTableName + "_Terminating_FSC",
            GlobalNames.paxGateSmoothedBHSTableName + "_Transfering_FSC", GlobalNames.paxGateInstantaneousBHSTableName + "_Transfering_FSC",
            GlobalNames.FPA_TransferICTSmoothedTableName + "_FSC", 
            GlobalNames.FPA_TransferICTInstantaneousTableName + "_FSC",
            GlobalNames.FPA_TransferICTSmoothedTableName + "_Bag_FSC",            
            GlobalNames.FPA_TransferICTInstantaneousTableName + "_Bag_FSC"
            // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

        };
        private static String[] StaticResultsFPDFPA = new String[] {  "FPDFPA_PeakStats", 
            "FPDFPA_AircraftMovementsRolling", "FPDFPA_AircraftMovementsInstantaneous", 
            "FPDFPA_InOutBoundRolling", "FPDFPA_InOutBoundInstantaneous", 
           
            // >> Task #9108 Pax2Sim - Static Analysis - FPD+FPA split table
            GlobalNames.paxBoardingRoomSmoothedFlowsTableName, GlobalNames.paxBoardingRoomInstantaneousFlowsTableName,
            GlobalNames.makeUpSmoothedFlowsBHSTableName, GlobalNames.makeUpInstantaneousFlowsBHSTableName,            
            // << Task #9108 Pax2Sim - Static Analysis - FPD+FPA split table
            // << Task #9115 Pax2Sim - Static Analysis - FPD+FPA Departure Entrance
            GlobalNames.fpaFpdDepartureEntranceSmoothedTableName, GlobalNames.fpaFpdDepartureEntranceInstantaneousTableName,
            GlobalNames.fpaFpdDepartureEntranceBHSSmoothedTableName, GlobalNames.fpaFpdDepartureEntranceBHSInstantaneousTableName,
            // >> Task #9115 Pax2Sim - Static Analysis - FPD+FPA Departure Entrance
            "Airport Statistics", "Airline Statistics", "Ground Handlers Statistics",
            // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
            "FPDFPA_AircraftMovements_FSC", "FPDFPA_InOutBoundRolling_FSC", "FPDFPA_InOutBoundInstantaneous_FSC",
            "PAX Boarding Room Rolling_FSC", "PAX Boarding Room Instantaneous_FSC",
            "MakeUp Flows Rolling_FSC", "MakeUp Flows Instantaneous_FSC",
            GlobalNames.fpaFpdDepartureEntranceSmoothedTableName + "_FSC", GlobalNames.fpaFpdDepartureEntranceInstantaneousTableName + "_FSC",
            GlobalNames.fpaFpdDepartureEntranceSmoothedTableName + "_Bag_FSC", GlobalNames.fpaFpdDepartureEntranceInstantaneousTableName + "_Bag_FSC",
            // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation
            "Container results"
        };

        // >> Task #9915 Pax2Sim - BNP development - Peak Flows - USA Standard directory
        private static String[] usaStandardStatisticTablesResults = new String[] { GlobalNames.EDS_STATS_TABLE_NAME, 
            GlobalNames.USA_STANDARD_PARAMETERS_TABLE_GENERIC_NAME_FOR_SCENARIOS, GlobalNames.FLIGHT_PLAN_TABLE_GENERIC_NAME_FOR_SCENARIO,   // >> Task #10035 Pax2Sim - BNP development - Data Input tables
            GlobalNames.DEPARTURE_LOAD_FACTORS_GENERIC_NAME_FOR_SCENARIOS, GlobalNames.NB_BAGS_GENERIC_NAME_FOR_SCENARIOS,          // >> Task #10346 Pax2Sim - EBS review
            GlobalNames.CI_SHOWUP_PROFILE_GENERIC_NAME_FOR_SCENARIOS, GlobalNames.OCT_CI_GENERIC_NAME_FOR_SCENARIOS, GlobalNames.OCT_MUP_GENERIC_NAME_FOR_SCENARIOS,
            GlobalNames.EBS_INPUT_RATE_GENERIC_NAME_FOR_SCENARIOS, GlobalNames.EBS_OUTPUT_RATE_GENERIC_NAME_FOR_SCENARIOS,          // << Task #10346 Pax2Sim - EBS review
            GlobalNames.usaStandard_NumberOfETD_tableName,
            GlobalNames.usaStandard_NumberOfETD_short_tableName,    // >> Task #10346 Pax2Sim - EBS review
            GlobalNames.usaStandard_SortationRate_tableName,
            GlobalNames.EBS_STATS_TABLE_NAME, GlobalNames.usaStandard_EBSRequirements_tableName };

        private static List<String> usaStandard_InputData_TablesNames =
            new List<String> { GlobalNames.USA_STANDARD_PARAMETERS_TABLE_GENERIC_NAME_FOR_SCENARIOS, GlobalNames.FLIGHT_PLAN_TABLE_GENERIC_NAME_FOR_SCENARIO,   // >> Task #10035 Pax2Sim - BNP development - Data Input tables
                                GlobalNames.DEPARTURE_LOAD_FACTORS_GENERIC_NAME_FOR_SCENARIOS, GlobalNames.NB_BAGS_GENERIC_NAME_FOR_SCENARIOS,  // >> Task #10346 Pax2Sim - EBS review
                                GlobalNames.CI_SHOWUP_PROFILE_GENERIC_NAME_FOR_SCENARIOS, GlobalNames.OCT_CI_GENERIC_NAME_FOR_SCENARIOS, GlobalNames.OCT_MUP_GENERIC_NAME_FOR_SCENARIOS,
                                GlobalNames.EBS_INPUT_RATE_GENERIC_NAME_FOR_SCENARIOS, GlobalNames.EBS_OUTPUT_RATE_GENERIC_NAME_FOR_SCENARIOS}; // << Task #10346 Pax2Sim - EBS review
        private static List<String> usaStandard_EDSRequirements_StatisticTablesNames = new List<String> { GlobalNames.EDS_STATS_TABLE_NAME,
            GlobalNames.usaStandard_NumberOfETD_tableName,
            GlobalNames.usaStandard_NumberOfETD_short_tableName,    // >> Task #10346 Pax2Sim - EBS review
            GlobalNames.usaStandard_SortationRate_tableName };

        private static List<String> usaStandard_EBSRequirements_StatisticTablesNames = new List<String> { GlobalNames.EBS_STATS_TABLE_NAME, 
            GlobalNames.usaStandard_EBSRequirements_tableName };
        // << Task #9915 Pax2Sim - BNP development - Peak Flows - USA Standard directory

        // Sodexi Task#7129 Bagplan Update
        private static String[] StaticResultsPaxplan = new String[] { "PaxPlanTable", "Pax_GenTransferLog", "FPA_Pax", "FPD_Pax", "FPA_Bags", "FPD_Bags", sTableBagPlan, GlobalNames.BagPlan2Name, GlobalNames.PrkPlanName };

        private static String[] StaticResultsDirectory = new String[] { "Allocation", "FPA", "FPD", "FPD+FPA" };    //,     // >> Task #10069 Pax2Sim - no BNP development  //, "Pax plan" };// >> Task #15556 Pax2Sim - Scenario Properties Assistant issues - C#8
                                                                        //, GlobalNames.usaStandard_directoryName};    // >> Task #9915 Pax2Sim - BNP development - Peak Flows - USA Standard directory


        private static String[] StaticSodexianalysisDirectory = new String[] { "BagPlan Information", "Ignored Lines", "BagPlan Errors", "StatistiquesIn", "StatistiquesOut", "Depature Statistics", GlobalNames.FPDStatisticsExtendedName };
        private static String[][] StaticResultsTables = new String[][] { StaticResultsAllocation,  StaticResultsFPA,StaticResultsFPD, StaticResultsFPDFPA, StaticResultsPaxplan };

        // >> Task #12393 Pax2Sim - File conversion for Athens
        private static String[] staticAthensAnalysisDirectory 
            = new String[] { AthensTools.FlightPlanUpdate.IMPORTED_FPA_TABLE_NAME, 
                             AthensTools.FlightPlanUpdate.IMPORTED_FPD_TABLE_NAME,
                             AthensTools.INFORMATION_TABLE_NAME };
        // << Task #12393 Pax2Sim - File conversion for Athens

        // >> Task #12843 Pax2Sim - Dubai - allocate using Cplex
        private static String[] staticDubaiCplexAnalysisDirectory
            = new String[] { PAX2SIM.FILTERED_FPD_TABLE_NAME, PAX2SIM.PARKING_STAND_TABLE_NAME, 
                //PAX2SIM.FLIGHT_STAND_COST_TABLE_NAME, PAX2SIM.FLIGHT_PARKING_STAND_ALTERNATIVES_TABLE_NAME,
                PAX2SIM.CPLEX_TABLE_NAME, PAX2SIM.CPLEX_PARTIAL_SOLUTION_TABLE_NAME, GlobalNames.FPI_TableName, 
                DubaiTools.FlightPlanTextAllocation.FLIGHTPLAN_TEXT_ALLOCATION_TABLENAME};
        // << Task #12843 Pax2Sim - Dubai - allocate using Cplex

        // >> Task #12808 Pax2Sim - allocation Liege
        private static String[] staticLiegeAnalysisDirectory
            = new String[] { LiegeTools.INFORMATION_TABLE_NAME,
                                SIMCORE_TOOL.Prompt.Liege.FlightPlanUpdate.IMPORTED_FPA_TABLE_NAME,
                                SIMCORE_TOOL.Prompt.Liege.FlightPlanUpdate.IMPORTED_FPD_TABLE_NAME, 
                                PAX2SIM.ALLOCATION_PARAMETERS_TABLE_NAME,
                                PAX2SIM.FILTERED_FPD_TABLE_NAME,
                                PAX2SIM.PARKING_OCT_TABLE_NAME,
                                PAX2SIM.CHECK_IN_OCT_TABLE_NAME,
                                LiegeTools.OCT_CITABLE_EXCEPTION_AIRLINE_AIRPORT_TEXT_FILE_NAME,
                                PAX2SIM.CHECK_IN_SHOWUP_TABLE_NAME,
                                PAX2SIM.BOARDING_GATES_OCT_TABLE_NAME,
                                PAX2SIM.AIRCRAFT_TYPES_TABLE_NAME,
                                PAX2SIM.AIRCRAFT_LINKS_TABLE_NAME,
                                PAX2SIM.PARKING_PRIORITIES_TABLE_NAME,
                                PAX2SIM.BOARDING_GATES_PRIORITIES_TABLE_NAME,
                                AllocationOutput.AVAILABLE_RESOURCES_TABLE_NAME,
                                AllocationOutput.ALLOCATION_RESULT_TABLE_NAME,
                                AllocationOutput.ALLOCATION_TEXT_GANTT_TABLE_NAME, GlobalNames.FPI_TableName,
                                AllocationOutput.ALLOCATION_ISSUES_TABLE_NAME,
                                LiegeTools.LIEGE_ALLOCATION_TABLE_NAME };

        private static String[] staticLiegeAnalysisOccupationDirectory
            = new String[] { PAX2SIM.OCCUPATION_BG_1_TABLE_NAME, PAX2SIM.OCCUPATION_BG_2_TABLE_NAME, 
                             PAX2SIM.OCCUPATION_BG_3_TABLE_NAME, PAX2SIM.OCCUPATION_BG_4_TABLE_NAME,                             
                             AllocationOutput.OCCUPATION_ISSUES_TABLE_NAME };

        private static String[] staticLiegeAnalysisOccupationSubDirectory
            = new String[] { PAX2SIM.OCCUPATION_ISSUES_BG_1_TABLE_NAME, PAX2SIM.OCCUPATION_ISSUES_BG_2_TABLE_NAME, 
                             PAX2SIM.OCCUPATION_ISSUES_BG_3_TABLE_NAME, PAX2SIM.OCCUPATION_ISSUES_BG_4_TABLE_NAME,
                             PAX2SIM.OCCUPATION_ISSUES_LOG_BG_1_TABLE_NAME, PAX2SIM.OCCUPATION_ISSUES_LOG_BG_2_TABLE_NAME, 
                             PAX2SIM.OCCUPATION_ISSUES_LOG_BG_3_TABLE_NAME, PAX2SIM.OCCUPATION_ISSUES_LOG_BG_4_TABLE_NAME,
                             };
        // << Task #12808 Pax2Sim - allocation Liege
        #endregion

        #endregion

        // >> Task #14727 Dubai allocation
        private static String[] staticDubaiAnalysisDirectory
            = new String[] { PAX2SIM.ALLOCATION_PARAMETERS_TABLE_NAME, DubaiOutput.FLIGHT_PLAN_TABLE_NAME, DubaiOutput.PARKING_STAND_TABLE_NAME,
                DubaiOutput.ALLOCATION_RESULT_TABLE_NAME, DubaiOutput.UNALLOCATED_FLIGHTS_TABLE_NAME, GlobalNames.FPI_TableName };
        // << Task #14727 Dubai allocation

        // >> Task #14982 CDG - TBS4
        private static String[] staticCDGAnalysisDirectory
            = new String[] { PAX2SIM.MUP_OCT_EXC_TABLE_NAME };
        // << Task #14982 CDG - TBS4

        #region Les constructeurs et les fonctions d'initialisation de la classe.
        /// <summary>
        /// Procedure qui se charge d'initialiser les différentes variables de la classe.
        /// Elle vide également la liste des erreurs.
        /// </summary>

        public static void Initialize()
        {
            htSizeAutomodModel = new Dictionary<string, int>(); ;
            htSizeAutomodModel.Add(PAX2SIM.sTerminalName, NbTerminaux);
            htSizeAutomodModel.Add(PAX2SIM.sLevelName, NbLevels);
            htSizeAutomodModel.Add(PAX2SIM.sBHSName, 1);

            htSizeAutomodModel.Add("Check In", NbCheckInDesks);
            htSizeAutomodModel.Add(PAX2SIM.sCheckInGroup, NbGroupes);
            htSizeAutomodModel.Add("Passport Check", NbDesks);
            htSizeAutomodModel.Add("Passport Check Group", NbGroupes);
            htSizeAutomodModel.Add("Security Check", NbDesks);
            htSizeAutomodModel.Add("Security Check Group", NbGroupes);
            htSizeAutomodModel.Add("Arrival Gate", NbDesks);
            htSizeAutomodModel.Add("Arrival Gate Group", NbGroupes);
            htSizeAutomodModel.Add("Baggage Claim", NbDesks);
            htSizeAutomodModel.Add("Baggage Claim Group", NbGroupes);
            htSizeAutomodModel.Add("Transfer", NbDesks);
            htSizeAutomodModel.Add("Transfer Group", NbGroupes);
            // << Task #7570 new Desk and extra information for Pax -Phase I B
            //htSizeAutomodModel.Add("ShuttleS", NbDesks);
            //htSizeAutomodModel.Add("ShuttleS Group", NbGroupes);
            htSizeAutomodModel.Add(PAX2SIM.sUserProcessObject, NbDesks);
            htSizeAutomodModel.Add(PAX2SIM.sUserProcessGroup, NbGroupes);
            // >> Task #7570 new Desk and extra information for Pax -Phase I B            
            htSizeAutomodModel.Add("Boarding Gate", NbDesks);
            htSizeAutomodModel.Add("Boarding Gate Group", NbGroupes);

            htSizeTable = new Hashtable();
            InitialiazePaxCheck();
        }
        private void initialiseComponent()
        {
            setPerimeter(epPerimeter);
            ListeErreurs = new ArrayList();
            Data = new Dictionary<String,GestionDonnees>();
            htScenarios = new Dictionary<String, Classes.ParamScenario>();
            htGraphiques = new Dictionary<string, GraphicFilter>();
            dsfGraphiquesFilters = new Dictionary<string, Filter>();
            lsNotes = new Dictionary<String, string>();
            lsParagraph = new Dictionary<string, Paragraph>();
            dmiInputData = new DataManagement.DataManagerInput("Input");
            dmiInputData.GetPath = new DataManager.GetPathDelegate(getNomDuChemin);

            dmiInputData.setGetStructureAirportFunction = new DataManagerInput.GetStructureAirportDelegate(getRacine);
            dmiInputData.setGetUseAlphaNumericalFlightPlanFunction = new DataManagerInput.GetUseAlphaNumericalFlightPlanDelegate(getAlphaNumericValue);
            dmiInputData.setGetPerimeterFunction = new DataManagerInput.GetPerimeterDelegate(getPerimeter);
            dmiInputData.setUpdateTableFromAirportStructure = new DataManagerInput.UpdateTableFromAirportStructureDelegate(UpdateTableWithAirportStructure);
            

            dmsScenarios = new Dictionary<string, DataManagement.DataManagerScenario>();
            structureAeroport = new XmlDocument();
            projet = new XmlDocument();
            bAirportStructureHadBeenModified = false;
            InitializeVisualisationMode();

            ListeNomTable = new string[ListeNomTablePAX.Length];
            ListeNomsCompletsTables = new string[ListeNomsCompletsTablesPAX.Length];

            ListeNomTablePAX.CopyTo(ListeNomTable, 0);
            ListeNomsCompletsTablesPAX.CopyTo(ListeNomsCompletsTables, 0);

            bUseAlphNumericForFlightInfo = false;

            TimeUnit_ = "Seconds";  // Default time unit in Seconds
            TimeInitial_ = "mn";
            DistanceInitial_ = "m";
            DistanceUnit_ = "Meters";
            Speed_ = 1;
            Tolerance_ = 0;
            
            // >> Task #13368 Project/Properties update            
            AllocationStep_ = GlobalNames.PROJECT_DEFAULT_ALLOCATION_STEP;  //15.0;
            Levels_ = new Double[] { GlobalNames.PROJECT_DEFAULT_DISTRIBUTION_LEVEL_1,
                                     GlobalNames.PROJECT_DEFAULT_DISTRIBUTION_LEVEL_2,
                                     GlobalNames.PROJECT_DEFAULT_DISTRIBUTION_LEVEL_3 };//{ 50, 75, 95 };
            // << Task #13368 Project/Properties update

            InitializeAllocationDependances();
            initializeGlobalBasicAnalysisResultFilterList();
            initializeGlobalAdvancedAnalysisResultFilterList();
        }

        // >> Task #15088 Pax2Sim - BHS Analysis - Times and Indexes        
        private void initializeGlobalBasicAnalysisResultFilterList()
        {
            globalBasicAnalysisResultFilterList = new List<AnalysisResultFilter>();
            AnalysisResultFilter resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_ENTRY_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
                OverallTools.BagTraceAnalysis.FROMTO_EXIT_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true, false);
            globalBasicAnalysisResultFilterList.Add(resultFilter);

            resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_QUEUE_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
                            OverallTools.BagTraceAnalysis.FROMTO_EXIT_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true, false);
            globalBasicAnalysisResultFilterList.Add(resultFilter);

            resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_COLLECTOR_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
                            OverallTools.BagTraceAnalysis.FROMTO_EXIT_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true, false);
            globalBasicAnalysisResultFilterList.Add(resultFilter);

            resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_CHECKIN_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
                OverallTools.BagTraceAnalysis.FROMTO_EXIT_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true, false);
            globalBasicAnalysisResultFilterList.Add(resultFilter);

            resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_TRANSF_INFEED_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
                OverallTools.BagTraceAnalysis.FROMTO_EXIT_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true, false);
            globalBasicAnalysisResultFilterList.Add(resultFilter);
                        
            resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_DEP_READER_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
                OverallTools.BagTraceAnalysis.FROMTO_EXIT_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true, false);
            globalBasicAnalysisResultFilterList.Add(resultFilter);

            resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_EBS_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
                OverallTools.BagTraceAnalysis.FROMTO_EXIT_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true, false);
            globalBasicAnalysisResultFilterList.Add(resultFilter);

            resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_LAST_CHUTE_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
                OverallTools.BagTraceAnalysis.FROMTO_EXIT_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true, false);
            globalBasicAnalysisResultFilterList.Add(resultFilter);

            //resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_CI_COLLECTOR_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
            //    OverallTools.BagTraceAnalysis.FROMTO_EXIT_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true);
            //globalBasicAnalysisResultFilterList.Add(resultFilter);
            //resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_TRANSF_COLLECTOR_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
            //    OverallTools.BagTraceAnalysis.FROMTO_EXIT_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true);
            //globalBasicAnalysisResultFilterList.Add(resultFilter);
        }
        private void initializeGlobalAdvancedAnalysisResultFilterList()
        {
            globalAdvancedAnalysisResultFilterList = new List<AnalysisResultFilter>();            
            AnalysisResultFilter resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_CI_QUEUE_STATION_CODE, 
                AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING, OverallTools.BagTraceAnalysis.FROMTO_LAST_CHUTE_STATION_CODE,
                AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true, false);
            globalAdvancedAnalysisResultFilterList.Add(resultFilter);
            resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_TRANSF_QUEUE_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
                OverallTools.BagTraceAnalysis.FROMTO_LAST_CHUTE_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true, false);
            globalAdvancedAnalysisResultFilterList.Add(resultFilter);            
            resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_CI_COLLECTOR_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
                OverallTools.BagTraceAnalysis.FROMTO_LAST_CHUTE_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true, false);
            globalAdvancedAnalysisResultFilterList.Add(resultFilter);
            resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_TRANSF_COLLECTOR_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
                OverallTools.BagTraceAnalysis.FROMTO_LAST_CHUTE_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true, false);
            globalAdvancedAnalysisResultFilterList.Add(resultFilter);
                        
            resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_CI_QUEUE_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
            OverallTools.BagTraceAnalysis.FROMTO_EBS_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true, false);
            globalAdvancedAnalysisResultFilterList.Add(resultFilter);
            resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_TRANSF_QUEUE_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
            OverallTools.BagTraceAnalysis.FROMTO_EBS_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true, false);
            globalAdvancedAnalysisResultFilterList.Add(resultFilter);
            resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_CI_COLLECTOR_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
                OverallTools.BagTraceAnalysis.FROMTO_EBS_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true, false);
            globalAdvancedAnalysisResultFilterList.Add(resultFilter);
            resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_TRANSF_COLLECTOR_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
                OverallTools.BagTraceAnalysis.FROMTO_EBS_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true, false);
            globalAdvancedAnalysisResultFilterList.Add(resultFilter);
                        
            resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_CI_QUEUE_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
                OverallTools.BagTraceAnalysis.FROMTO_DEP_READER_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true, false);
            globalAdvancedAnalysisResultFilterList.Add(resultFilter);
            resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_TRANSF_QUEUE_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
                OverallTools.BagTraceAnalysis.FROMTO_DEP_READER_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true, false);
            globalAdvancedAnalysisResultFilterList.Add(resultFilter);
            resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_CI_COLLECTOR_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
                OverallTools.BagTraceAnalysis.FROMTO_DEP_READER_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true, false);
            globalAdvancedAnalysisResultFilterList.Add(resultFilter);
            resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_TRANSF_COLLECTOR_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
                OverallTools.BagTraceAnalysis.FROMTO_DEP_READER_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true, false);
            globalAdvancedAnalysisResultFilterList.Add(resultFilter);

            resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_CI_QUEUE_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
            OverallTools.BagTraceAnalysis.FROMTO_PRESORTATION_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true, false);
            globalAdvancedAnalysisResultFilterList.Add(resultFilter);
            resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_TRANSF_QUEUE_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
            OverallTools.BagTraceAnalysis.FROMTO_PRESORTATION_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true, false);
            globalAdvancedAnalysisResultFilterList.Add(resultFilter);
            resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_CI_COLLECTOR_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
                OverallTools.BagTraceAnalysis.FROMTO_PRESORTATION_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true, false);
            globalAdvancedAnalysisResultFilterList.Add(resultFilter);
            resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_TRANSF_COLLECTOR_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
                OverallTools.BagTraceAnalysis.FROMTO_PRESORTATION_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true, false);
            globalAdvancedAnalysisResultFilterList.Add(resultFilter);

            resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_CHECKIN_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
                OverallTools.BagTraceAnalysis.FROMTO_DEP_READER_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true, false);
            globalAdvancedAnalysisResultFilterList.Add(resultFilter);
            resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_CHECKIN_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
                OverallTools.BagTraceAnalysis.FROMTO_LAST_CHUTE_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true, false);
            globalAdvancedAnalysisResultFilterList.Add(resultFilter);
            resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_CHECKIN_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
                OverallTools.BagTraceAnalysis.FROMTO_PRESORTATION_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true, false);
            globalAdvancedAnalysisResultFilterList.Add(resultFilter);

            resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_DEP_READER_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
                OverallTools.BagTraceAnalysis.FROMTO_LAST_CHUTE_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true, false);
            globalAdvancedAnalysisResultFilterList.Add(resultFilter);

            resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_EBS_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
                OverallTools.BagTraceAnalysis.FROMTO_LAST_CHUTE_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true, false);
            globalAdvancedAnalysisResultFilterList.Add(resultFilter);
            resultFilter = new AnalysisResultFilter("", OverallTools.BagTraceAnalysis.FROMTO_EBS_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
                OverallTools.BagTraceAnalysis.FROMTO_MAKEUP_STATION_CODE, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, false, false, false, true, false);
            globalAdvancedAnalysisResultFilterList.Add(resultFilter);
                        
        }

        // << Task #15088 Pax2Sim - BHS Analysis - Times and Indexes

        #region Les constructeurs de la classe.
        /// <summary>
        /// Constructeur d'un nouveau projet Vide. Un nom de projet doit être défini par la suite.
        /// </summary>
        internal GestionDonneesHUB2SIM(AnalyseTracesDelegate atFunction)
        {
            initialiseComponent();
            AnalyseTracesFunction = atFunction;
            OverallTools.FonctionUtiles.setCoefficient(Speed_, TimeUnit_, Tolerance_, DistanceInitial_);
            chargementTables();
            LoadDefaultTable(GlobalNames.FP_AirlineCodesTableName);
            LoadDefaultTable(GlobalNames.FP_AirportCodesTableName);
            LoadDefaultTable(GlobalNames.FP_AircraftTypesTableName);
            // << Task User Attributes initialization when creating new project
            LoadDefaultTable(GlobalNames.sUserAttributesTableName);
            // >> Task User Attributes initialization when creating new project            
            hadBeenSaved = false;
            HadAlreadyBeenSavedOnDisk = false;
            initializeGlobalBasicAnalysisResultFilterList();
            initializeGlobalAdvancedAnalysisResultFilterList();
        }
        internal GestionDonneesHUB2SIM(String NomCompletFichierPax, AnalyseTracesDelegate atFunction)
        {
            //On initialise les différents composants de la classe.
            initialiseComponent();

            AnalyseTracesFunction = atFunction;
            /// Récupération du chemin
            this.nomDuChemin = System.IO.Path.GetDirectoryName(NomCompletFichierPax);
            /// Récupération du nom du fichier seul
            this.nomFichierProjetPax = System.IO.Path.GetFileName(NomCompletFichierPax);
            //Le fichier vient d'etre chargé, il n'y a donc eu aucune modification depuis la dernière ouverture.


            nomOldSavingPath = nomDuChemin;
            hadBeenSaved = true;
            HadAlreadyBeenSavedOnDisk = true;
        }
        #endregion

        internal static GestionDonneesHUB2SIM CreateProject(String NomCompletFichierPax,
                                                          AnalyseTracesDelegate atAnalyseTrace_,
                                                          Prompt.SIM_LoadingForm chForm,
                                                          TreeNodeCollection Racines,
                                                          ContextMenuStrip cmsScenarioMenu,
                                                          ContextMenuStrip cmsContextMenuInput,
                                                          ContextMenuStrip cmsMenuFilter,
                                                          ContextMenuStrip cmsAirport,
                                                          ContextMenuStrip cmsGraphicFilter,
                                                          ContextMenuStrip cmsAutomodMenu,
                                                          ContextMenuStrip cmsUserGraphics, 
                                                          ContextMenuStrip cmsMenuException,
                                                          ContextMenuStrip cmsExportScenarioTables)
        {
            GestionDonneesHUB2SIM gdh = new GestionDonneesHUB2SIM(NomCompletFichierPax, atAnalyseTrace_);
            if (!gdh.OuvrirFichierProjet(Racines, chForm, cmsScenarioMenu, cmsContextMenuInput, cmsMenuFilter, cmsAirport, cmsGraphicFilter, cmsAutomodMenu, cmsUserGraphics, cmsMenuException, cmsExportScenarioTables))
            {
                gdh.Dispose();
                gdh = null;
                return null;
            }
            //  On s'occupe de charger les tables, de mettre à jour les tables suivant les flight categories
            //et de mettre à jour la structure XML de l'aéroport. On indique également que le projet n'a encore
            //subi aucune modification.
            gdh.hadBeenSaved = true;
            gdh.chargementTables();
            gdh.Update_FlightCategorie();
            gdh.AirportStructureChange();
            return gdh;
        }

        public void Dispose()
        {
            if (Data != null)
            {
                foreach (String key in Data.Keys)
                {
                    ((GestionDonnees)Data[key]).Dispose();
                }
                Data.Clear();
            }
            Data = null;
            if(htScenarios != null)
                htScenarios.Clear();
            if (dmsScenarios != null)
            {
                foreach (String key in dmsScenarios.Keys)
                {
                    dmsScenarios[key].Dispose();
                }
            }
            if (dmiInputData != null)
                dmiInputData.Dispose();
            htScenarios = null;
            if (htGraphiques != null)
            htGraphiques.Clear();
            htGraphiques = null;
            if (dsfGraphiquesFilters != null)
                dsfGraphiquesFilters.Clear();
            projet = null;
            structureAeroport = null;
            for (int i = 1; i <= 6; i++)
                DataManagerInput.RemoveTerminalInputTable(i);
        }

        #endregion

        #region ### Initialisation des BHS.  ###

        internal PAX2SIM.EnumPerimetre getPerimeter() 
        {
            return epPerimeter;
        }
        internal static void setPerimeter(PAX2SIM.EnumPerimetre Perimeter)
        {
            epPerimeter = Perimeter;
            switch (epPerimeter)
            {
                case PAX2SIM.EnumPerimetre.BHS:
                case PAX2SIM.EnumPerimetre.TMS:
                    InitializeBHS();
                    break;
                case PAX2SIM.EnumPerimetre.PAX:
                    InitializePAX();
                    break;
                case PAX2SIM.EnumPerimetre.PKG:
                    InitializePAX();
                    InitializePKG();
                    break;
                default:
                    InitializePAX();
                    break;
            }
        }

        #region Initialisation des passagers.
        public static void InitializePAX()
        {
            if ((!PAX2SIM.bReporter) || (ListeNomsSeparation == null))
                if (PAX2SIM.bTrialVersion)
                {
                    ListeSeparation = new int[] { 8, 15, 31, 34, 40 };

                    ListeNomsSeparation = new String[] { "FP", "Passenger", "Allocations_Plannings", "Airport_Area_Capacity", "Airport_Process" };
                    ListeNomsCompletsSeparation = new String[] { "Flight Plans", "Passenger", "Allocation & Planning", "Airport Area Capacity", "Airport Process" };
                }
                else
                {
                    ListeSeparation = new int[] { 8, 15, 31, 34, 40, 40 };
                    ListeNomsSeparation = new String[] { "FP", "Passenger", "Allocations_Plannings", "Airport_Area_Capacity", "Airport_Process", "User Data" };
                    ListeNomsCompletsSeparation = new String[] { "Flight Plans", "Passenger", "Allocation & Planning", "Airport Area Capacity", "Airport Process", "User Data" };
                }

            int iIndex = OverallTools.FonctionUtiles.indexDansListe("Animated_Queues", ListeNomTablePAX);
            ListeTablePAXVisible[iIndex] = ListeTablePAXVisible[iIndex] && PAX2SIM.bAnimatedQueues;
            ListeTablePAXSauvegardee[iIndex] = ListeTablePAXSauvegardee[iIndex] && PAX2SIM.bAnimatedQueues;

            iIndex = OverallTools.FonctionUtiles.indexDansListe("Baggage_Claim_Constraint", ListeNomTablePAX);
            ListeTablePAXVisible[iIndex] = ListeTablePAXVisible[iIndex] && PAX2SIM.bShowAllocationTools;
            ListeTablePAXSauvegardee[iIndex] = ListeTablePAXSauvegardee[iIndex] && PAX2SIM.bShowAllocationTools;

            iIndex = OverallTools.FonctionUtiles.indexDansListe(GlobalNames.ProcessScheduleName, ListeNomTablePAX);
            /*ListeTablePAXVisible[iIndex] = ListeTablePAXVisible[iIndex] && PAX2SIM.bJNK;
            ListeTablePAXSauvegardee[iIndex] = ListeTablePAXSauvegardee[iIndex] && PAX2SIM.bJNK;*/


            listeTable_AjoutDouble = new string[Default_listeTable_AjoutDouble.Length];
            Default_listeTable_AjoutDouble.CopyTo(listeTable_AjoutDouble, 0);

            listeTable_AjoutString = new string[Default_listeTable_AjoutString.Length];
            Default_listeTable_AjoutString.CopyTo(listeTable_AjoutString, 0);

            listeTable_AjoutBoolean = new string[Default_listeTable_AjoutBoolean.Length];
            Default_listeTable_AjoutBoolean.CopyTo(listeTable_AjoutBoolean, 0);

            listeTable_FC = new string[Default_listeTable_FC.Length];
            Default_listeTable_FC.CopyTo(listeTable_FC, 0);

            listeTable_SchemaAeroport = new string[Default_listeTable_SchemaAeroport.Length];
            Default_listeTable_SchemaAeroport.CopyTo(listeTable_SchemaAeroport, 0);

            ListeEnteteDiv = new string[Default_ListeEnteteDiv.Length];
            Default_ListeEnteteDiv.CopyTo(ListeEnteteDiv, 0);

            ListeTablesAvecLignesFixes = new string[Default_ListeTablesAvecLignesFixes.Length];
            Default_ListeTablesAvecLignesFixes.CopyTo(ListeTablesAvecLignesFixes, 0);

            ListeLignesFixes = new string[Default_ListeLignesFixes.Length][];
            Default_ListeLignesFixes.CopyTo(ListeLignesFixes, 0);

            ListeTablesAvecAllocation = new string[Default_ListeTablesAvecAllocation.Length];
            Default_ListeTablesAvecAllocation.CopyTo(ListeTablesAvecAllocation, 0);

            ListeTablesPourCalculAllocation = new string[Default_ListeTablesPourCalculAllocation.Length];
            Default_ListeTablesPourCalculAllocation.CopyTo(ListeTablesPourCalculAllocation, 0);

            ListeTablesDefault = new string[Default_ListeTablesDefault.Length];
            Default_ListeTablesDefault.CopyTo(ListeTablesDefault, 0);

            ListeTableDefaultValues = new Double[Default_ListeTableDefaultValues.Length][];
            Default_ListeTableDefaultValues.CopyTo(ListeTableDefaultValues, 0);
            DataManagerInput.SwitchTo(PAX2SIM.EnumPerimetre.PAX);
        }
        #endregion

        #region Initialisation du mode Parking
        public static void InitializePKG()
        {
            DataManagerInput.SwitchTo(PAX2SIM.EnumPerimetre.PKG);
        }
        #endregion

        #region Initialisation du BHS
        public static void InitializeBHS()
        {
            InitializePAX();
            if (PAX2SIM.bDelhi)
            {
                ListeSeparation = new int[] { -1, -1 };
                ListeNomsSeparation = new String[] { "BHS", "User Data" };
                ListeNomsCompletsSeparation = new String[] { "Baggage Handling System", "User Data" };
            }
            else
            {
                if ((PAX2SIM.bRuntime) && (!PAX2SIM.bPAX))
                {
                    ListeSeparation = new int[] { -1, -1 };
                    ListeNomsSeparation = new String[] { "BHS", "User Data" };
                    ListeNomsCompletsSeparation = new String[] { "Baggage Handling System", "User Data" };
                }
                else
                {
                    ListeSeparation = new int[] { 8, 15, 31, 34, 40, 40, 40 };

                    ListeNomsSeparation = new String[] { "FP", "Passenger", "Allocations_Plannings", "Airport_Area_Capacity", "Airport_Process", "BHS", "User Data" };
                    ListeNomsCompletsSeparation = new String[] { "Flight Plans", "Passenger", "Allocation & Planning", "Airport Area Capacity", "Airport Process", "Baggage Handling System", "User Data" };
                }
            }


            ListeEnteteDiv = new string[Default_ListeEnteteDiv.Length + ListeEnteteDiv_BHS.Length];
            Default_ListeEnteteDiv.CopyTo(ListeEnteteDiv, 0);
            ListeEnteteDiv_BHS.CopyTo(ListeEnteteDiv, Default_ListeEnteteDiv.Length);

            DataManagerInput.SwitchTo(PAX2SIM.EnumPerimetre.BHS);
        }
        #endregion

        public void UpdateTreeView(TreeNode node, ContextMenuStrip cmsAiport)
        {
            OverallTools.TreeViewFunctions.construireArbre(structureAeroport, node, cmsAiport);
        }
        #endregion

        #region Fonctions pour le chargement des tables et pour l'élaboration de l'arbre.
        /// <summary>
        /// Fonction qui s'occupe de vérifier qu'il ne manque aucune table en mémoire.
        /// </summary>
        private void chargementTables()
        {
            InputData.InitializeTables();
        }

        /// <summary>
        /// Fonction qui s'occupe de charger depuis un emplacement spécifié la table en mémoire.
        /// Si cette table fait partie des tables qui ont un format prédéfini, alors elle vérifie
        /// l'exactitude des noms des colonnes.
        /// </summary>
        /// <param name="nomTable">Le nom de la table que l'on souhaite charger.</param>
        /// <param name="nomChemin">Le chemin du fichier contenant les données.</param>
        /// <param name="dataSet">Le nom du dataset dans lequel sauvegarder la table chargée</param>
        /// <param name="sVersion">La version courante du fichier qui va être chargé.</param>
        private bool chargerTable_old(String dataSet,
                                   String nomTable,
                                   String nomChemin,
                                   DataTable dtOldTable,
                                   VersionManager sVersion,
                                   bool bRessources)
        {
            //Chargement des données dans la nouvelle table.
            String fichier = nomChemin;
            if (nomChemin[0] == '\\')
            {
                fichier = nomDuChemin + nomChemin;
            }
            // ICI : Toujours mettre la dernière version modifiée pour définir le nom de la table.
            String sNomTable = nomTable;
            DataTable NewTable = null;
            if (dtOldTable != null)
            {
                NewTable = dtOldTable.Clone();
                NewTable.TableName = sNomTable;
            }
            else
                NewTable = new DataTable(sNomTable);


            bool bBHSTable = false;
            bool bBHSRacine = false;
            int iIndexDansTable = OverallTools.FonctionUtiles.indexDansListe(sNomTable, ListeNomTablePAX);
            if (iIndexDansTable == -1)
            {
                bBHSRacine = true;
                iIndexDansTable = OverallTools.FonctionUtiles.indexDansListe(sNomTable, ListeNomTablesBHS_Racine);
            }
            if (iIndexDansTable == -1)
            {
                bBHSRacine = false;
                iIndexDansTable = 0;
                //We check if the table is a BHS table.
                foreach (String sSuffixes in ListeNomTableBHS)
                {
                    if (sNomTable.EndsWith(sSuffixes) && sNomTable.StartsWith(GlobalNames.sBHS_PrefixeLong))
                    {
                        int iCaractere = GlobalNames.sBHS_PrefixeLong.Length;
                        String sIndexTerminal = OverallTools.FonctionUtiles.nextDoubleDate(sNomTable, ref iCaractere);
                        if (sIndexTerminal.Length != 0)
                        {
                            if (sSuffixes.Length + GlobalNames.sBHS_PrefixeLong.Length + sIndexTerminal.Length + 1 == sNomTable.Length)
                            {
                                bBHSTable = true;
                            }
                        }
                        break;
                    }
                    iIndexDansTable++;
                }
                if (!bBHSTable)
                    iIndexDansTable = -1;
            }
            if (iIndexDansTable == -1)
            {
                //Une table qui n'a pas de format prédéfini.
                //On peut donc la charger de manière transparente.
                if (!OverallTools.FonctionUtiles.LectureFichier(NewTable, fichier, "\t", ListeErreurs))
                {
                    return false;
                }
            }
            else
            {
                if (bBHSRacine)
                {
                    NewTable = ConvertTables.getConvertTable.LectureFichier(sNomTable,
                        null,
                        ListeEntetes_BHS_Racine[iIndexDansTable],
                                                ListeTypeEntetes_BHS_Racine[iIndexDansTable],
                                                ListePrimaryKey_BHS_Racine[iIndexDansTable],
                                                fichier,
                                                "\t",
                                                OverallTools.FonctionUtiles.estPresentDansListe(ListeNomTablesBHS_Racine[iIndexDansTable], listeTable_AjoutDouble_BHS),
                                                OverallTools.FonctionUtiles.estPresentDansListe(ListeNomTablesBHS_Racine[iIndexDansTable], listeTable_AjoutString_BHS),
                                                false,
                                                false,
                                                false,
                                                ListeErreurs,
                                                sVersion);
                }
                else if (bBHSTable)
                {
                    NewTable = ConvertTables.getConvertTable.LectureFichier(sNomTable,
                        null,
                        ListeEntetes_BHS[iIndexDansTable],
                                                ListeTypeEntetes_BHS[iIndexDansTable],
                                                ListePrimaryKey_BHS[iIndexDansTable],
                                                fichier,
                                                "\t",
                                                OverallTools.FonctionUtiles.estPresentDansListe(ListeNomTableBHS[iIndexDansTable], listeTable_AjoutDouble_BHS),
                                                OverallTools.FonctionUtiles.estPresentDansListe(ListeNomTableBHS[iIndexDansTable], listeTable_AjoutString_BHS),
                                                false,
                                                false,
                                                false,
                                                ListeErreurs,
                                                sVersion);
                }
                else
                {

                    NewTable = ConvertTables.getConvertTable.LectureFichier(sNomTable, null, listeEntetes[iIndexDansTable],
                        
                                                listeTypeEntetes[iIndexDansTable],
                                                listePrimaryKey[iIndexDansTable],
                                                fichier,
                                                "\t",
                                                OverallTools.FonctionUtiles.estPresentDansListe(sNomTable, listeTable_AjoutDouble),
                                                OverallTools.FonctionUtiles.estPresentDansListe(sNomTable, listeTable_AjoutString),
                                                OverallTools.FonctionUtiles.estPresentDansListe(sNomTable, listeTable_AjoutBoolean),
                                                bRessources,
                                                false,
                                                ListeErreurs,
                                                sVersion);
                }
                if (NewTable == null)
                {
                    return false;
                }
            }

            //Si la table fait partie des tables avec des entetes fixe.
            if ((OverallTools.FonctionUtiles.estPresentDansListe(sNomTable, ListeNomTablePAX))
                && (!VerifierTable_old(NewTable)))
            {
                //La table ne correspond pas à son modèle, on la supprime.
                getGestionDonnees(dataSet).removeTable(sNomTable);
                return false;
            }
            if (getGestionDonnees(dataSet).estPresent(sNomTable))
            {
                return getGestionDonnees(dataSet).ReplaceTable(NewTable);
            }
            else
            {
                VisualisationMode mode = new VisualisationMode(true, true, true, null, null);
                if (bBHSTable)
                    mode = (VisualisationMode)modeVisualisation[ListeNomTableBHS[iIndexDansTable]];
                else if (bBHSRacine && modeVisualisation.ContainsKey(ListeNomTablesBHS_Racine[iIndexDansTable]))
                    mode = (VisualisationMode)modeVisualisation[ListeNomTablesBHS_Racine[iIndexDansTable]];
                else if (OverallTools.FonctionUtiles.estPresentDansListe(sNomTable, ListeNomTablePAX))
                    mode = (VisualisationMode)modeVisualisation[sNomTable];
                return getGestionDonnees(dataSet).AddTable(NewTable, mode);
            }
        }

        /// <summary>
        /// Fonction qui vérifie que la table chargée a des noms de colonnes valide. (Uniquement
        /// pour les tables qui sont chargées par défaut)
        /// </summary>
        /// <param name="nomTable">Le nom de la table à vérifier.</param>
        /// <returns>Une valeur booléenne indiquant si la table est valide ou non.</returns>
        private bool VerifierTable_old(DataTable table)
        {
            int iIndexTable = OverallTools.FonctionUtiles.indexDansListe(table.TableName, ListeNomTablePAX);
            if (iIndexTable == -1)
            {
                ListeErreurs.Add("Err00058 : The Table \"" + table.TableName + "\" is not a default table.");
                //La table n'a pas une entete présente dans la liste.
                return false;
            }
            if (OverallTools.FonctionUtiles.estPresentDansListe(table.TableName, ListeTablesAvecLignesFixes))
            {
                int iIndextable = OverallTools.FonctionUtiles.indexDansListe(table.TableName, ListeTablesAvecLignesFixes);
                foreach (DataRow ligne in table.Rows)
                {
                    if (!OverallTools.FonctionUtiles.estPresentDansListe(ligne.ItemArray[0].ToString(), ListeLignesFixes[iIndextable]))
                    {
                        ListeErreurs.Add("Err00059 : The Table \"" + table.TableName + "\" has a line name which does not match with its default settings");
                        return false;
                    }
                }
            }
            for (int i = 0; i < listeEntetes[iIndexTable].Length; i++)
            {
                if (table.Columns[i].ColumnName.ToString() != listeEntetes[iIndexTable][i].ToString())
                {
                    //Une entête de colonne ne correspond pas.
                    ListeErreurs.Add("Err00057 : The Table \"" + table.TableName + "\" has a column name which does not match with its default settings.");
                    return false;
                }
            }

            //Variable pour vérifier que le nombre de lignes n'est pas trop important dans les tables limitées.
            if (htSizeTable.ContainsKey(table.TableName))
            {
                if (((int)htSizeTable[table.TableName]) < table.Rows.Count)
                {
                    ListeErreurs.Add("Err00023 : The Table \"" + table.TableName + "\" has too much line for your version of " + OverallTools.AssemblyActions.AssemblyTitle + " : Limited number of lines : \"" + ((int)htSizeTable[table.TableName]).ToString() + "\".");
                    return false;
                }
            }
            return true; // la vérification à réussie.
        }

        /// <summary>
        /// Fonction qui se charge de reconstruire l'arbre en XML à partir de celui présent
        /// dans le Treeview.
        /// </summary>
        /// <param name="NoeudRacineTrv">Noeud provenant du treeview.</param>
        /// <param name="Noeudxml">Noeud provenant de l'architecture XML</param>
        private void construireArbreAeroport(System.Windows.Forms.TreeNode NoeudRacineTrv, System.Xml.XmlNode Noeudxml)
        {
            foreach (System.Windows.Forms.TreeNode Noeud in NoeudRacineTrv.Nodes)
            {
                //(Noeud.Name)
                XmlElement newNoeud = projet.CreateElement(Noeud.Name.Replace(' ', '_'));
                Noeudxml.AppendChild(newNoeud);
                newNoeud.SetAttribute("Type", Noeud.Name);
                TreeViewTag tag = (TreeViewTag)Noeud.Tag;
                newNoeud.SetAttribute("Index", tag.Index.ToString());
                newNoeud.SetAttribute("Name", tag.Name);
                if (tag.Visible)
                {
                    newNoeud.SetAttribute("X", tag.Location.X.ToString());
                    newNoeud.SetAttribute("Y", tag.Location.Y.ToString());
                }
                if (tag.BHSVisible)
                {
                    newNoeud.SetAttribute("BHS_X", tag.BHSLocation.X.ToString());
                    newNoeud.SetAttribute("BHS_Y", tag.BHSLocation.Y.ToString());
                }
                construireArbreAeroport(Noeud, newNoeud);
            }
        }

        #endregion

        #region Les fonctions pour ouvrir et fermer le projet

        private Int32 getFilesNumber_old(XmlDocument projet)
        {
            //On lit dans la variable projet la structure du projet avec tous les fichiers présents.
            if (projet == null)
                return 0;
            if (projet.ChildNodes.Count == 0)
                return 0;
            int Resultat = 1;//Le 1 correspondant au chargement de la structure de l'aéroport.
            Resultat += projet["HUB2SIM"]["InputDatas"]["DataSource"].ChildNodes.Count;

            if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"]["InputDatas"], "Filters"))
            {
                Resultat += projet["HUB2SIM"]["InputDatas"]["Filters"].ChildNodes.Count;
            }

            if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"]["InputDatas"], "GraphicFilters"))
            {
                Resultat += projet["HUB2SIM"]["InputDatas"]["GraphicFilters"].ChildNodes.Count;
            }
            if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"]["InputDatas"], "GeneralGraphicFilters"))
            {
                Resultat += projet["HUB2SIM"]["InputDatas"]["GeneralGraphicFilters"].ChildNodes.Count;
            }
            if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"], "Scenarios"))
            {
                foreach (XmlElement xmlScenario in projet["HUB2SIM"]["Scenarios"].ChildNodes)
                {
                    if (OverallTools.FonctionUtiles.hasNamedChild(xmlScenario, "DataSource"))
                    {
                        Resultat += getFilesNumber(xmlScenario["DataSource"]);
                    }
                }
            }
            return Resultat;
        }
        private Int32 getFilesNumber(XmlDocument projet)
        {
            //On lit dans la variable projet la structure du projet avec tous les fichiers présents.
            if (projet == null)
                return 0;
            if (projet.ChildNodes.Count == 0)
                return 0;
            int Resultat = 1;//Le 1 correspondant au chargement de la structure de l'aéroport.

            if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"], "DataManagerInput"))
                if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"]["DataManagerInput"], "DataManager"))
                    Resultat += projet["HUB2SIM"]["DataManagerInput"]["DataManager"].ChildNodes.Count;


            
            /*if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"]["DataManagerInput"], "Filters"))
            {
                Resultat += projet["HUB2SIM"]["DataManagerInput"]["Filters"].ChildNodes.Count;
            }*/

            /*if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"]["DataManagerInput"], "GraphicFilters"))
            {
                Resultat += projet["HUB2SIM"]["DataManagerInput"]["GraphicFilters"].ChildNodes.Count;
            }*/
            if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"]["DataManagerInput"], "GeneralGraphicFilters"))
            {
                Resultat += projet["HUB2SIM"]["DataManagerInput"]["GeneralGraphicFilters"].ChildNodes.Count;
            }
            if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"], "Scenarios"))
            {
                foreach (XmlNode xnNode in projet["HUB2SIM"]["Scenarios"])
                {

                    if (OverallTools.FonctionUtiles.hasNamedChild(xnNode, "DataManagerScenario"))
                    if (OverallTools.FonctionUtiles.hasNamedChild(xnNode["DataManagerScenario"], "DataManager"))
                        Resultat += xnNode["DataManagerScenario"]["DataManager"].ChildNodes.Count;
                }
                //Resultat += projet["HUB2SIM"]["Scenarios"].ChildNodes.Count;
                /*
                foreach (XmlElement xmlScenario in projet["HUB2SIM"]["Scenarios"].ChildNodes)
                {
                    if (OverallTools.FonctionUtiles.hasNamedChild(xmlScenario, "DataSource"))
                    {
                        Resultat += 100;
                    }
                }*/
            }
            return Resultat;
        }
        public static Int32 getFilesNumber(XmlElement xmlBranch)
        {
            int Result = 0;
            if ((xmlBranch.Name == "Table") || (xmlBranch.Name == "FilterTable")
                || (xmlBranch.Name == "AirportObject") || (xmlBranch.Name == "Filter")
                || (xmlBranch.Name == "GraphicFilter"))
                Result++;
            for (int i = 0; i < xmlBranch.ChildNodes.Count; i++)
            {
                if (xmlBranch.ChildNodes[i].GetType() == typeof(XmlElement))
                    Result += getFilesNumber((XmlElement)xmlBranch.ChildNodes[i]);
            }
            return Result;
        }

        public Int32 getNumberOfFiles()
        {
            Int32 iResult = 0;
            foreach (String sKey in dmsScenarios.Keys)
            {
                iResult += dmsScenarios[sKey].TableNumber;
            }
            return iResult;
        }

        private bool OuvrirParametres(XmlElement xeNode, VersionManager sVersion)
        {
            if (OverallTools.FonctionUtiles.hasNamedAttribute(xeNode, "UseAlphaNumericForFlightPlans"))
                bUseAlphNumericForFlightInfo = true;

            InitializePAX();
            //Récupération du nom du projet.
            nomProjetPax = xeNode.GetAttribute("Name");
            if (OverallTools.FonctionUtiles.hasNamedChild(xeNode, "UnitsSettings"))
            {
                if (OverallTools.FonctionUtiles.hasNamedChild(xeNode["UnitsSettings"], "DistanceUnit"))
                    DistanceUnit_ = xeNode["UnitsSettings"]["DistanceUnit"].FirstChild.Value;
                if (OverallTools.FonctionUtiles.hasNamedChild(xeNode["UnitsSettings"], "DistanceInitial"))
                    DistanceInitial_ = xeNode["UnitsSettings"]["DistanceInitial"].FirstChild.Value;
                if (OverallTools.FonctionUtiles.hasNamedChild(xeNode["UnitsSettings"], "TimeUnit"))
                    TimeUnit_ = xeNode["UnitsSettings"]["TimeUnit"].FirstChild.Value;
                if (OverallTools.FonctionUtiles.hasNamedChild(xeNode["UnitsSettings"], "TimeInitial"))
                    TimeInitial_ = xeNode["UnitsSettings"]["TimeInitial"].FirstChild.Value;
                if (OverallTools.FonctionUtiles.hasNamedChild(xeNode["UnitsSettings"], "Speed"))
                {
                    if (!Double.TryParse(xeNode["UnitsSettings"]["Speed"].FirstChild.Value, out Speed_))
                    {
                        ListeErreurs.Add("Err00063 : Speed information does not have a good format");
                        return false;
                    }
                }
                if (OverallTools.FonctionUtiles.hasNamedChild(xeNode["UnitsSettings"], "Tolerance"))
                {
                    if (!Double.TryParse(xeNode["UnitsSettings"]["Tolerance"].FirstChild.Value, out Tolerance_))
                    {
                        ListeErreurs.Add("Err00064 : Tolerance information does not have a good format");
                        return false;
                    }
                }
                // >> Task #13368 Project/Properties update
                Levels_ = new Double[] { GlobalNames.PROJECT_DEFAULT_DISTRIBUTION_LEVEL_1, GlobalNames.PROJECT_DEFAULT_DISTRIBUTION_LEVEL_2, 
                                        GlobalNames.PROJECT_DEFAULT_DISTRIBUTION_LEVEL_3 };//{ 50, 75, 95 };                
                if (OverallTools.FonctionUtiles.hasNamedChild(xeNode["UnitsSettings"], "Levels"))
                {
                    if (OverallTools.FonctionUtiles.hasNamedAttribute(xeNode["UnitsSettings"]["Levels"], "First"))
                    {
                        if (!Double.TryParse(xeNode["UnitsSettings"]["Levels"].Attributes["First"].Value, out Levels_[0]))
                        {
                            ListeErreurs.Add("Warn00016 : The first level information does not have a good format");
                            Levels_[0] = 50;
                        }
                    }
                    if (OverallTools.FonctionUtiles.hasNamedAttribute(xeNode["UnitsSettings"]["Levels"], "Second"))
                    {
                        if (!Double.TryParse(xeNode["UnitsSettings"]["Levels"].Attributes["Second"].Value, out Levels_[1]))
                        {
                            ListeErreurs.Add("Warn00017 : The second level information does not have a good format");
                            Levels_[1] = 75;
                        }
                    }
                    if (OverallTools.FonctionUtiles.hasNamedAttribute(xeNode["UnitsSettings"]["Levels"], "Third"))
                    {
                        if (!Double.TryParse(xeNode["UnitsSettings"]["Levels"].Attributes["Third"].Value, out Levels_[2]))
                        {
                            ListeErreurs.Add("Warn00018 : The third level information does not have a good format");
                            Levels_[2] = 95;
                        }
                    }
                }
                // << Task #13368 Project/Properties update
            }
            
            // >> Task #15088 Pax2Sim - BHS Analysis - Times and Indexes
            if (OverallTools.FonctionUtiles.hasNamedChild(xeNode, XML_ELEMENT_NAME_ANALYSIS_RESULTS_FILTERS_MAIN))
            {
                XmlElement analysisResultsFiltersMainElement = xeNode[XML_ELEMENT_NAME_ANALYSIS_RESULTS_FILTERS_MAIN];                
                if (OverallTools.FonctionUtiles.hasNamedChild(analysisResultsFiltersMainElement, XML_ELEMENT_NAME_ANALYSIS_RESULTS_FILTERS_CUSTOM))
                {
                    globalCustomAnalysisResultFilterList
                        = loadAnalysisResultsFilters(analysisResultsFiltersMainElement[XML_ELEMENT_NAME_ANALYSIS_RESULTS_FILTERS_CUSTOM]);
                }
            }
            // << Task #15088 Pax2Sim - BHS Analysis - Times and Indexes

            AllocationStep_ = GlobalNames.PROJECT_DEFAULT_ALLOCATION_STEP;//15.0;   // >> Task #13368 Project/Properties update
            if (OverallTools.FonctionUtiles.hasNamedChild(xeNode, "AllocationStep"))
            {
                if (!Double.TryParse(xeNode["AllocationStep"].FirstChild.Value, out AllocationStep_))
                {
                    ListeErreurs.Add("Err00065 : AllocationStep information does not have a good format");
                    return false;
                }
            }
            OverallTools.FonctionUtiles.setCoefficient(Speed_, TimeUnit_, Tolerance_, DistanceInitial_);
            return true;
        }
        
        // >> Task #15088 Pax2Sim - BHS Analysis - Times and Indexes        
        private List<AnalysisResultFilter> loadAnalysisResultsFilters(XmlElement resultsFiltersRootElement)
        {
            List<AnalysisResultFilter> analysisResultsFilters = new List<AnalysisResultFilter>();
            if (resultsFiltersRootElement == null)
                return analysisResultsFilters;
            foreach (XmlElement resultFilterElement in resultsFiltersRootElement.ChildNodes)
            {
                bool dataRetrieved = true;
                string name = "";
                string fromStationCode = "";
                string fromTimeType = "";
                string toStationCode = "";
                string toTimeType = "";
                bool withRecirc = true;
                bool withFromSegr = true;
                bool withToSegr = true;
                bool excludeEBS = true;
                bool generateIST = true;
                if (OverallTools.FonctionUtiles
                    .hasNamedAttribute(resultFilterElement, ParamScenario.XML_ATTRIBUTE_NAME_FILTER_NAME))
                {
                    name = resultFilterElement.Attributes[ParamScenario.XML_ATTRIBUTE_NAME_FILTER_NAME].Value;
                }
                else
                    dataRetrieved = false;
                if (OverallTools.FonctionUtiles
                    .hasNamedAttribute(resultFilterElement, ParamScenario.XML_ATTRIBUTE_NAME_FROM_STATION))
                {
                    fromStationCode = resultFilterElement.Attributes[ParamScenario.XML_ATTRIBUTE_NAME_FROM_STATION].Value;
                }
                else
                    dataRetrieved = false;
                if (OverallTools.FonctionUtiles
                    .hasNamedAttribute(resultFilterElement, ParamScenario.XML_ATTRIBUTE_NAME_FROM_STATION_TIME_TYPE))
                {
                    fromTimeType = resultFilterElement.Attributes[ParamScenario.XML_ATTRIBUTE_NAME_FROM_STATION_TIME_TYPE].Value;
                }
                else
                    dataRetrieved = false;
                if (OverallTools.FonctionUtiles
                    .hasNamedAttribute(resultFilterElement, ParamScenario.XML_ATTRIBUTE_NAME_TO_STATION))
                {
                    toStationCode = resultFilterElement.Attributes[ParamScenario.XML_ATTRIBUTE_NAME_TO_STATION].Value;
                }
                else
                    dataRetrieved = false;
                if (OverallTools.FonctionUtiles
                    .hasNamedAttribute(resultFilterElement, ParamScenario.XML_ATTRIBUTE_NAME_TO_STATION_TIME_TYPE))
                {
                    toTimeType = resultFilterElement.Attributes[ParamScenario.XML_ATTRIBUTE_NAME_TO_STATION_TIME_TYPE].Value;
                }
                else
                    dataRetrieved = false;
                if (!OverallTools.FonctionUtiles.hasNamedAttribute(resultFilterElement, ParamScenario.XML_ATTRIBUTE_NAME_WITH_RECIRC)
                    || !Boolean.TryParse(resultFilterElement.Attributes[ParamScenario.XML_ATTRIBUTE_NAME_WITH_RECIRC].Value, out withRecirc))
                    dataRetrieved = false;
                if (!OverallTools.FonctionUtiles.hasNamedAttribute(resultFilterElement, ParamScenario.XML_ATTRIBUTE_NAME_WITH_FROM_SEGR)
                    || !Boolean.TryParse(resultFilterElement.Attributes[ParamScenario.XML_ATTRIBUTE_NAME_WITH_FROM_SEGR].Value, out withFromSegr))
                    dataRetrieved = false;
                if (!OverallTools.FonctionUtiles.hasNamedAttribute(resultFilterElement, ParamScenario.XML_ATTRIBUTE_NAME_WITH_TO_SEGR)
                    || !Boolean.TryParse(resultFilterElement.Attributes[ParamScenario.XML_ATTRIBUTE_NAME_WITH_TO_SEGR].Value, out withToSegr))
                    dataRetrieved = false;
                if (!OverallTools.FonctionUtiles.hasNamedAttribute(resultFilterElement, ParamScenario.XML_ATTRIBUTE_NAME_EXCLUDE_EBS)
                    || !Boolean.TryParse(resultFilterElement.Attributes[ParamScenario.XML_ATTRIBUTE_NAME_EXCLUDE_EBS].Value, out excludeEBS))
                    dataRetrieved = false;
                if (!OverallTools.FonctionUtiles.hasNamedAttribute(resultFilterElement, ParamScenario.XML_ATTRIBUTE_NAME_GENERATE_IST)
                    || !Boolean.TryParse(resultFilterElement.Attributes[ParamScenario.XML_ATTRIBUTE_NAME_GENERATE_IST].Value, out generateIST))
                {
                    generateIST = false;
                    //dataRetrieved = false; compatibility with previous versions that didn't have the attribute
                }
                if (dataRetrieved)
                {
                    AnalysisResultFilter resultFilter = new AnalysisResultFilter(name, fromStationCode, fromTimeType, toStationCode, toTimeType, 
                        withRecirc, withFromSegr, withToSegr, excludeEBS, generateIST);
                    analysisResultsFilters.Add(resultFilter);
                }
            }
            return analysisResultsFilters;
        }
        // << Task #15088 Pax2Sim - BHS Analysis - Times and Indexes

        /// <summary>
        /// Fonction qui se charge d'ouvrir le fichier PAX et de mettre en mémoire toutes les données.
        /// </summary>
        /// <returns>Retourne une valeur indiquant si le chargement s'est bien déroulé ou non.</returns>
        private bool OuvrirFichierProjet(TreeNodeCollection Racine,
                                         Prompt.SIM_LoadingForm chForm,
                                         ContextMenuStrip cmsScenarioMenu,
                                         ContextMenuStrip cmsContextMenuInput,
                                         ContextMenuStrip cmsMenuFilter,
                                         ContextMenuStrip cmsAirport,
                                         ContextMenuStrip cmsGraphicFilter,
                                         ContextMenuStrip cmsAutomodMenu,
                                         ContextMenuStrip cmsUserGraphics,
                                         ContextMenuStrip cmsMenuException, 
                                         ContextMenuStrip cmsExportScenarioTables)
        {
            try
            {
                XmlDocument projet = new XmlDocument();
                if (!System.IO.File.Exists(nomDuChemin + "\\" + nomFichierProjetPax))
                {
                    ListeErreurs.Add("Err00051 : The file does not exist, please check the path.");
                    return false;
                }
                projet.Load(nomDuChemin + "\\" + nomFichierProjetPax);
                if ((!projet.HasChildNodes) || 
                    (!OverallTools.FonctionUtiles.hasNamedChild(projet, "HUB2SIM")))
                {
                    ///Le fichier XML doit avoir au moin une node principale nommée HUB2SIM.
                    ///Si on ne trouve pas cette node, alors on retourne FAUX.
                    ListeErreurs.Add("Err00055 : The " + PAX2SIM.sExtension.ToUpper() + " file does not have a good format.");
                    return false;
                }

                #region Gestion de la version d'enregistrement
                ///On vérifie la version de sauvegarde du document. Si le document est plus ancien que la version 1.50
                ///alors on utilise l'ancienne fonction d'ouverture des projets.
                VersionManager sVersion = new VersionManager("1.0");
                if (OverallTools.FonctionUtiles.hasNamedAttribute(projet["HUB2SIM"], "Version"))
                {
                    sVersion = new VersionManager(projet["HUB2SIM"].Attributes["Version"].Value.ToString());
                }
                if (sVersion > sCurrentVersion)
                {
                    ListeErreurs.Add("Err00053 : The PAX file format version is not support by this application. Please check for updates for " + OverallTools.AssemblyActions.AssemblyTitle + ".");
                    return false;
                }
                if (sVersion < new VersionManager(1, 15))
                {
                    ListeErreurs.Add("Err00054 : This version is not supported by the application. For more information please contact support@pax2sim.com.");
                    return false;
                }
                if (sVersion < new VersionManager(1,50))
                {

                    Data.Add("Input", new GestionDonnees("InputDatas", new GestionDonnees.AnalyseTraces(AnalyseTraces), ListeErreurs));
                    bool bOpen = ouvrirFichierProjet_old(Racine,
                                         chForm,
                                          cmsScenarioMenu,
                                          cmsContextMenuInput,
                                          cmsMenuFilter,
                                          cmsAirport,
                                          cmsGraphicFilter,
                                          cmsAutomodMenu,
                                          cmsUserGraphics, cmsExportScenarioTables);
                    if(!bOpen)
                        return false;
                    InputData.ConvertGestionDonnees(getGestionDonnees("Input"));
                    InputData.UpdateFilters(Racine[1], cmsMenuFilter, cmsMenuException);
                    InputData.LoadUserData(nomDuChemin+"\\Data\\UserData\\");
                    UpdateBHSDirectory(Racine[0],null,cmsContextMenuInput);


                    foreach (String sKey in Data.Keys)
                    {
                        if (sKey == "Input")
                            continue;
                        DataManagerPaxBHS dmsScenario = new DataManagerPaxBHS(sKey);
                        dmsScenario.GetPath = new DataManager.GetPathDelegate(getNomDuChemin);
                        dmsScenario.ConvertGestionDonnees(Data[sKey]);
                        dmsScenario.Scenario = htScenarios[sKey];
                        dmsScenario.AnalyseTracesFonctions = new DataManagerPaxBHS.AnalyseTracesDelegate(AnalyseTraces);
                        AddScenario(dmsScenario);
                    }
                    foreach (String sKey in Data.Keys)
                    {
                        Data[sKey].Dispose();
                    }
                    Data.Clear();
                    htScenarios.Clear();
                    Data = null;
                    htScenarios = null;
                    
                    return bOpen;
                }
                #endregion

                #region Chargement des paramétrages globals du projet.
                if ((!OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"], "DataManagerInput")) ||
                    (!OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"], "Scenarios")))
                {
                    ListeErreurs.Add("Err00052 : The " + PAX2SIM.sExtension.ToUpper() + " file does not have a good format.");
                    return false;
                }
                OuvrirParametres(projet["HUB2SIM"], sVersion);
               

                int iNombreFichier = getFilesNumber(projet);

                if (chForm != null)
                    chForm.setFileNumber(iNombreFichier);

                ///Chargement 
                if (!dmiInputData.LoadInputData(projet["HUB2SIM"]["DataManagerInput"], sVersion, nomDuChemin,chForm))
                {
                    ListeErreurs.Add("Err00056 : The " + PAX2SIM.sExtension.ToUpper() + " file does not have a good format.");
                    return false;
                }
               
                #endregion

                if (chForm != null)
                    chForm.ChargementFichier("Load Airport definition");
                //Sauvegarde de la structure de l'aéroport.
                structureAeroport = projet["HUB2SIM"][PAX2SIM.sMainNodeName].Clone();

                if (!CheckAirportStructure(structureAeroport))
                    return false;

                //On charge la structure de l'aéroport.

                OverallTools.TreeViewFunctions.construireArbre(structureAeroport, Racine[0], cmsAirport);
                bAirportStructureHadBeenModified = true;
                DataManagement.DataManagerInput dmiTmp = InputData;
                

                ///Chargement des générales notes à l'aide de \ref openGeneralNotes
                if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"], "GeneralNotes"))
                {
                    openGeneralNotes(projet["HUB2SIM"]["GeneralNotes"]);
                }
                if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"], "Paragraphs"))
                {
                    openParagraph(projet["HUB2SIM"]["Paragraphs"]);
                }


                dmiTmp.UpdateFilters(Racine[1], cmsMenuFilter, cmsMenuException);

                #region Gestion des filtres généraux et des graphiques généraux
                if (chForm != null)
                    chForm.ChargementFichier("Load general filters and general graphics.");
                if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"], "GeneralFilters"))
                {
                    Filter fFilter;
                    foreach (XmlElement xmlfiltre in projet["HUB2SIM"]["GeneralFilters"].ChildNodes)
                    {
                        fFilter = new Filter(xmlfiltre);
                        dsfGraphiquesFilters.Add(fFilter.Name, fFilter);
                    }
                }
                if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"], "GeneralGraphicFilters"))
                {
                    GraphicFilter filtre;
                    foreach (XmlElement xmlfiltre in projet["HUB2SIM"]["GeneralGraphicFilters"].ChildNodes)
                    {
                        if (chForm != null)
                            chForm.ChargementFichier("Load Graphics : " + xmlfiltre.Name);
                        filtre = new GraphicFilter(xmlfiltre);
                        if (FilterExist(filtre.Name))
                        {
                            AddGraphicFilter("", filtre);
                        }
                        else
                        {
                            AddGeneralGraphicFilter(filtre);
                            TreeViewTag Tag = TreeViewTag.getChartNode(filtre.Name);
                            OverallTools.TreeViewFunctions.AddSortedNode(Racine[3], OverallTools.TreeViewFunctions.createBranch(filtre.Name, filtre.Name, Tag, cmsGraphicFilter));
                        }
                    }
                    if (dsfGraphiquesFilters.Count>0)
                    {
                        UpdateGeneralFilters(Racine[3], cmsMenuFilter);
                    }
                }
                #endregion


                foreach (XmlElement xmlScenario in projet["HUB2SIM"]["Scenarios"].ChildNodes)
                {
                    if (!CanAddScenario())
                    {
                        ListeErreurs.Add("Err00024 : The project contains too many scenarios for the trial version of " + OverallTools.AssemblyActions.AssemblyTitle + ". The limit is " + NBScenarios.ToString() + ".");
                        return false;
                    }
                    //OverallTools.ExternFunctions.PrintLogFile("Scenario start.");
                    TreeNode newScenario = null;
                    if (((xmlScenario.Name == typeof(DataManagerPaxBHS).Name) && (sVersion >= new VersionManager(1,52))) ||
                        sVersion < new VersionManager(1,52))
                    {
                        newScenario = LoadScenarioNew(xmlScenario, null, chForm, cmsScenarioMenu, cmsContextMenuInput, cmsMenuFilter, cmsAutomodMenu, cmsUserGraphics, sVersion);
                    }
                    else if (xmlScenario.Name == typeof(DataManagerParking).Name)
                    {
                        newScenario = LoadScenarioParking(xmlScenario, null, chForm, cmsScenarioMenu, cmsContextMenuInput, cmsMenuFilter, sVersion);
                    }
                    else if (xmlScenario.Name == typeof(DataManagerAllocation).Name)
                    {
                        newScenario = LoadScenarioAllocation(xmlScenario, null, chForm, cmsScenarioMenu, cmsContextMenuInput, cmsMenuFilter, sVersion);
                    }
                    if (newScenario != null)
                        OverallTools.TreeViewFunctions.AddSortedNode(Racine[2], newScenario);
                    
                    //OverallTools.ExternFunctions.PrintLogFile("Scenario " + newScenario.Name + " loaded.");
                }



                if (System.IO.Directory.Exists(nomDuChemin + "\\Data\\UserData"))
                {
                    dmiTmp.LoadUserData(nomDuChemin + "\\Data\\UserData");
                }/*
                if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"], "AllocateTables"))
                {
                    gs.LoadAllocateTables(projet["HUB2SIM"]);
                }*/
                if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"], "ReportList"))
                {
                    // Load the reports
                    htReportParametres = ReportParameters.ImportParameters(projet["HUB2SIM"]["ReportList"], sVersion, Racine);
                }
                if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"], GlobalNames.DOCUMENTS_XML_NODE_NAME)) // >> Task #16578 PAX2SIM - Documents - new node in main tree-view
                {
                    documentTableNames = new List<string>();
                    foreach (XmlNode documentXmlNode in projet["HUB2SIM"][GlobalNames.DOCUMENTS_XML_NODE_NAME].ChildNodes)
                    {
                        if (documentXmlNode.Attributes[GlobalNames.DOCUMENT_XML_NODE_NAME_ATTRIBUTE] == null)
                            continue;
                        string documentName = documentXmlNode.Attributes[GlobalNames.DOCUMENT_XML_NODE_NAME_ATTRIBUTE].Value;
                        if (!documentTableNames.Contains(documentName))
                        {
                            documentTableNames.Add(documentName);
                        }
                        else
                        {
                            OverallTools.ExternFunctions.PrintLogFile("Found duplicate document(" + documentName
                                + ") while loading the project " + nomFichierProjetPax + ".");
                        }                        
                    }
                }
                //<< Task #7405 - new Desk and extra information for Pax
                NormalTable userAttributes = dmiInputData.GetTable(GlobalNames.sUserAttributesTableName);
                if (userAttributes != null)
                {
                    // << Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay
                    removeOldLoadingRateAndDelayParametersTablesFromUserAttributes(userAttributes);
                    // >> Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay

                    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    NormalTable baggageLoadingTable = dmiInputData.GetTable(GlobalNames.sUserAttributesBaggLoadingRateTableName);
                    if (baggageLoadingTable == null
                        && !userAttributeTableContainsAttributeName(userAttributes.Table, GlobalNames.sUserAttributesBaggLoadingRateTableName))  // << Task User Attributes initialization when creating new project
                    {
                        addAttributeToUserAttributesTable(userAttributes, GlobalNames.sUserAttributesBaggLoadingRateTableName);
                    }

                    baggageLoadingTable = dmiInputData.GetTable(GlobalNames.sUserAttributesBaggLoadingDelayTableName);
                    if (baggageLoadingTable == null
                        && !userAttributeTableContainsAttributeName(userAttributes.Table, GlobalNames.sUserAttributesBaggLoadingDelayTableName)) // << Task User Attributes initialization when creating new project
                    {
                        addAttributeToUserAttributesTable(userAttributes, GlobalNames.sUserAttributesBaggLoadingDelayTableName);
                    }
                    // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                    // >> Task #8958 Reclaim Synchronisation mode Gantt
                    NormalTable reclaimLogTable = dmiInputData.GetTable(GlobalNames.userAttributesReclaimLogTableName);
                    if (reclaimLogTable == null
                        && !userAttributeTableContainsAttributeName(userAttributes.Table, GlobalNames.userAttributesReclaimLogTableName))  // << Task User Attributes initialization when creating new project
                    {
                        addAttributeToUserAttributesTable(userAttributes, GlobalNames.userAttributesReclaimLogTableName);
                    }
                    // << Task #8958 Reclaim Synchronisation mode Gantt

                    // << Task #9172 Pax2Sim - Static Analysis - EBS algorithm - Input/Output Rates
                    NormalTable ebsInputRateTable = dmiInputData.GetTable(GlobalNames.userAttributesEBSInputRateTableName);
                    if (ebsInputRateTable == null
                        && !userAttributeTableContainsAttributeName(userAttributes.Table, GlobalNames.userAttributesEBSInputRateTableName)) // << Task User Attributes initialization when creating new project
                    {
                        addAttributeToUserAttributesTable(userAttributes, GlobalNames.userAttributesEBSInputRateTableName);
                    }

                    NormalTable ebsOutputRateTable = dmiInputData.GetTable(GlobalNames.userAttributesEBSOutputRateTableName);
                    if (ebsOutputRateTable == null
                        && !userAttributeTableContainsAttributeName(userAttributes.Table, GlobalNames.userAttributesEBSOutputRateTableName)) // << Task User Attributes initialization when creating new project
                    {
                        addAttributeToUserAttributesTable(userAttributes, GlobalNames.userAttributesEBSOutputRateTableName);
                    }
                    // >> Task #9172 Pax2Sim - Static Analysis - EBS algorithm - Input/Output Rates

                    // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                    NormalTable flightSubcategoryTable = dmiInputData.GetTable(GlobalNames.flightSubcategoriesTableName);
                    if (flightSubcategoryTable == null
                        && !userAttributeTableContainsAttributeName(userAttributes.Table, GlobalNames.flightSubcategoriesTableName))
                    {
                        addAttributeToUserAttributesTable(userAttributes, GlobalNames.flightSubcategoriesTableName);
                    }
                    // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

                    // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                    NormalTable numberOfPassengersTable = dmiInputData.GetTable(GlobalNames.numberOfPassengersTableName);
                    if (numberOfPassengersTable == null
                        && !userAttributeTableContainsAttributeName(userAttributes.Table, GlobalNames.numberOfPassengersTableName))
                    {
                        addAttributeToUserAttributesTable(userAttributes, GlobalNames.numberOfPassengersTableName);
                    }
                    //NormalTable numberOfBaggagesTable = dmiInputData.GetTable(GlobalNames.numberOfBaggagesTableName);
                    //if (numberOfBaggagesTable == null
                    //    && !userAttributeTableContainsAttributeName(userAttributes.Table, GlobalNames.numberOfBaggagesTableName))
                    //{
                    //    addAttributeToUserAttributesTable(userAttributes, GlobalNames.numberOfBaggagesTableName);
                    //}
                    // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)

                    // >> Task #9967 Pax2Sim - BNP development - Peak Flows - USA Standard parameters table
                    NormalTable usaStandardParametersTable = dmiInputData.GetTable(GlobalNames.USA_STANDARD_PARAMETERS_TABLE_NAME);
                    if (usaStandardParametersTable == null
                        && !userAttributeTableContainsAttributeName(userAttributes.Table, GlobalNames.USA_STANDARD_PARAMETERS_TABLE_NAME))
                    {
                        addAttributeToUserAttributesTable(userAttributes, GlobalNames.USA_STANDARD_PARAMETERS_TABLE_NAME);
                    }
                    // << Task #9967 Pax2Sim - BNP development - Peak Flows - USA Standard parameters table

                    DataManagerInput.createUserAttributesTablesFromUserAttributesColumnNames(userAttributes.Table);

                    // >> Task #10764 Pax2Sim - new User attributes for Groups
                    if (!userAttributeTableContainsAttributeName(userAttributes.Table, GlobalNames.PAX_CI_GROUP_USER_ATTRIBUTE))
                    {
                        addAttributeToUserAttributesTable(userAttributes, GlobalNames.PAX_CI_GROUP_USER_ATTRIBUTE);
                    }
                    if (!userAttributeTableContainsAttributeName(userAttributes.Table, GlobalNames.PAX_RECLAIM_GROUP_USER_ATTRIBUTE))
                    {
                        addAttributeToUserAttributesTable(userAttributes, GlobalNames.PAX_RECLAIM_GROUP_USER_ATTRIBUTE);
                    }
                    if (!userAttributeTableContainsAttributeName(userAttributes.Table, GlobalNames.PAX_TRANSFER_GROUP_USER_ATTRIBUTE))
                    {
                        addAttributeToUserAttributesTable(userAttributes, GlobalNames.PAX_TRANSFER_GROUP_USER_ATTRIBUTE);
                    }                    
                    if (!userAttributeTableContainsAttributeName(userAttributes.Table, GlobalNames.PAX_BOARDING_GATE_GROUP_USER_ATTRIBUTE))
                    {
                        addAttributeToUserAttributesTable(userAttributes, GlobalNames.PAX_BOARDING_GATE_GROUP_USER_ATTRIBUTE);
                    }
                    // << Task #10764 Pax2Sim - new User attributes for Groups                                        
                }
                //>> Task #7405 - new Desk and extra information for Pax
                dmiInputData.InitializeTables();
                UpdateBHSDirectory(Racine[0], null, cmsContextMenuInput);

                initializeEBSRatesTables(ListeErreurs); // << Task #9260 Pax2Sim - Static Analysis - EBS algorithm - EBS per Terminal

                initializeNumberOfPaxAndBagsTables(ListeErreurs);   // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)

                initializeUSAStandardParametersTable(ListeErreurs); // >> Task #9967 Pax2Sim - BNP development - Peak Flows - USA Standard parameters table

                // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                initializeFlightSubcategoriesTables(ListeErreurs);
                initializeReclaimLogTable(ListeErreurs);    // >> Task #8958 Reclaim Synchronisation mode Gantt
                if (userAttributes != null && userAttributes.Table != null)
                    updateAllocationTablesWithDefaultValues(userAttributes.Table, userAttributes.Table);
                // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation
            }
            catch (XmlException e)
            {
                ListeErreurs.Add("Err00060 : L'ouverture du fichier " + nomDuChemin + "\\" + nomFichierProjetPax + " a généré l'erreur suivante " + e.Message);
                OverallTools.ExternFunctions.PrintLogFile("Err00060: " + this.GetType().ToString() + " throw an exception: " + e.Message);
                return false;
            }
            return true;
        }

        // << Task User Attributes initialization when creating new project
        private bool userAttributeTableContainsAttributeName(DataTable userAttributesTable, String attributeName)
        {
            bool contains = false;
            if (userAttributesTable != null && userAttributesTable.Columns != null
                && userAttributesTable.Columns.IndexOf(GlobalNames.sUserAttributes_ColumnName) != -1)
            {
                if (userAttributesTable.Rows != null && userAttributesTable.Rows.Count > 0)
                {
                    foreach (DataRow dr in userAttributesTable.Rows)
                    {
                        if (dr[GlobalNames.sUserAttributes_ColumnName].ToString().Equals(attributeName))
                            contains = true;
                    }
                }
            }
            return contains;
        }
        // >> Task User Attributes initialization when creating new project

        // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
        private void addAttributeToUserAttributesTable(NormalTable userAttributes, String baggageLoadingColumnName)
        {
            DataRow dr = userAttributes.Table.NewRow();
            dr[GlobalNames.sUserAttributes_ColumnName] = baggageLoadingColumnName;
            userAttributes.Table.Rows.Add(dr);
        }
        // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

        // << Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay
        private void removeOldLoadingRateAndDelayParametersTablesFromUserAttributes(NormalTable userAttributesTable)
        {
            List<DataRow> userAttributesRowsToDelete = new List<DataRow>();
            if (userAttributesTable != null && userAttributesTable.Table != null
                && userAttributesTable.Table.Rows.Count > 0)
            {
                int indexUserAttributesColumn = userAttributesTable.Table.Columns.IndexOf(GlobalNames.sUserAttributes_ColumnName);

                if (indexUserAttributesColumn != -1)
                {
                    foreach (DataRow row in userAttributesTable.Table.Rows)
                    {
                        if (GlobalNames.oldUserAttributeTableNames.Contains((row[indexUserAttributesColumn].ToString()))
                            || GlobalNames.oldEbsRateTableNamesList.Contains((row[indexUserAttributesColumn].ToString())) )
                            userAttributesRowsToDelete.Add(row);
                    }
                }
                if (userAttributesRowsToDelete.Count > 0)
                {
                    foreach (DataRow row in userAttributesRowsToDelete)
                    {
                        userAttributesTable.Table.Rows.Remove(row);
                    }
                }
            }
        }
        // >> Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay

        // << Task #9260 Pax2Sim - Static Analysis - EBS algorithm - EBS per Terminal
        private void initializeEBSRatesTables(ArrayList ListeErreurs)
        {
            NormalTable ebsInputRateTable = dmiInputData.GetTable(GlobalNames.userAttributesEBSInputRateTableName);
            NormalTable ebsOutputRateTable = dmiInputData.GetTable(GlobalNames.userAttributesEBSOutputRateTableName);

            if (ebsInputRateTable != null && ebsOutputRateTable != null
                && ebsInputRateTable.Table != null && ebsOutputRateTable.Table != null)
            {
                if (ebsInputRateTable.Table.Rows.Count == 0)
                {
                    DataRow dr = ebsInputRateTable.Table.NewRow();
                    dr[GlobalNames.ebsRatesTableTerminalUnknownColumnName] = 12;
                    ebsInputRateTable.Table.Rows.Add(dr);
                    ebsInputRateTable.Table.AcceptChanges();
                }
                if (ebsOutputRateTable.Table.Rows.Count == 0)
                {
                    DataRow dr = ebsOutputRateTable.Table.NewRow();
                    dr[GlobalNames.ebsRatesTableTerminalUnknownColumnName] = 12;
                    ebsOutputRateTable.Table.Rows.Add(dr);
                    ebsOutputRateTable.Table.AcceptChanges();
                }
            }
            else
            {
                ListeErreurs.Add("Error while initializint the EBS Input and Output Rates tables.");
                OverallTools.ExternFunctions.PrintLogFile("The EBS Input or Output Rates tables could not be loaded.");
            }

        }
        // >> Task #9260 Pax2Sim - Static Analysis - EBS algorithm - EBS per Terminal

        // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
        private void initializeFlightSubcategoriesTables(ArrayList errorList)
        {
            NormalTable flightSubcategoriesTable = dmiInputData.GetTable(GlobalNames.flightSubcategoriesTableName);

            if (flightSubcategoriesTable != null && flightSubcategoriesTable.Table != null)
            {                
                if (flightSubcategoriesTable.Table.Rows.Count == 0)
                {                    
                    foreach (String defaultFlightSubcategory in GlobalNames.defaultFlightSubcategoriesList)
                    {
                        DataRow row = flightSubcategoriesTable.Table.NewRow();
                        row[0] = defaultFlightSubcategory;                        
                        flightSubcategoriesTable.Table.Rows.Add(row);
                        flightSubcategoriesTable.Table.AcceptChanges();    
                    }                    
                }
            }
            else
            {
                ListeErreurs.Add("Error while initializing the Flight Subcategory table.");
                OverallTools.ExternFunctions.PrintLogFile("The Flight Subcategory table could not be loaded.");
            }
        }
        // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation
        
        // >> Task #8958 Reclaim Synchronisation mode Gantt
        private void initializeReclaimLogTable(ArrayList errorList)
        {
            NormalTable reclaimLogTable = dmiInputData.GetTable(GlobalNames.userAttributesReclaimLogTableName);            
            if (reclaimLogTable != null && reclaimLogTable.Table != null)
            {
                if (reclaimLogTable.Table.Rows.Count == 0)
                {
                    foreach (String value in GlobalNames.defaultReclaimLogValuesList)
                    {
                        DataRow row = reclaimLogTable.Table.NewRow();
                        row[0] = value;
                        reclaimLogTable.Table.Rows.Add(row);
                        reclaimLogTable.Table.AcceptChanges();
                    }
                }
            }
            else
            {
                //ListeErreurs.Add("Error while initializing the Reclaim Log table.");
                OverallTools.ExternFunctions.PrintLogFile("The Reclaim Log table could not be loaded.");
            }
        }
        // << Task #8958 Reclaim Synchronisation mode Gantt

        // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
        private void initializeNumberOfPaxAndBagsTables(ArrayList errorList)
        {
            NormalTable numberOfPaxTable = dmiInputData.GetTable(GlobalNames.numberOfPassengersTableName);
           
            if (numberOfPaxTable != null && numberOfPaxTable.Table != null)
            {
                if (numberOfPaxTable.Table.Rows.Count == 0)
                {
                    DataRow dr = numberOfPaxTable.Table.NewRow();
                    dr[GlobalNames.originatingPaxDepartureColumnName] = 0;
                    dr[GlobalNames.transferringPaxDepartureColumnName] = 0;
                    dr[GlobalNames.terminatingPaxArrivalColumnName] = 0;
                    dr[GlobalNames.transferringPaxArrivalColumnName] = 0;
                    numberOfPaxTable.Table.Rows.Add(dr);
                    numberOfPaxTable.Table.AcceptChanges();
                }
            }
            else
            {
                ListeErreurs.Add("Error while initializint the NumberOfPassengers tables.");
                OverallTools.ExternFunctions.PrintLogFile("The NumberOfPassengers tables could not be loaded.");
            }
        }
        // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)

        // >> Task #9967 Pax2Sim - BNP development - Peak Flows - USA Standard parameters table
        private void initializeUSAStandardParametersTable(ArrayList errorList)
        {
            NormalTable usaStandardParametersTable = dmiInputData.GetTable(GlobalNames.USA_STANDARD_PARAMETERS_TABLE_NAME);

            if (usaStandardParametersTable != null && usaStandardParametersTable.Table != null
                && usaStandardParametersTable.Table.Rows.Count == 0)
            {
                #region column indexes
                int oogPercentColumnIndex = usaStandardParametersTable.Table.Columns.IndexOf(GlobalNames.USA_STANDARD_OOG_PERCENT_PARAM_NAME);
                int osPercentColumnIndex = usaStandardParametersTable.Table.Columns.IndexOf(GlobalNames.USA_STANDARD_OS_PERCENT_PARAM_NAME);
                int edsScreenRatePerMinColumnIndex = usaStandardParametersTable.Table.Columns.IndexOf(GlobalNames.USA_STANDARD_EDS_SCREENING_RATE_PER_MINUTE_PARAM_NAME);
                int edsScreenRatePerHourColumnIndex = usaStandardParametersTable.Table.Columns.IndexOf(GlobalNames.USA_STANDARD_EDS_SCREENING_RATE_PER_HOUR_PARAM_NAME);
                int falseAlarmEdsDomColumnIndex = usaStandardParametersTable.Table.Columns.IndexOf(GlobalNames.USA_STANDARD_FALSE_ALARM_EDS_DOM_PARAM_NAME);
                int falseAlarmEdsIntColumnIndex = usaStandardParametersTable.Table.Columns.IndexOf(GlobalNames.USA_STANDARD_FALSE_ALARM_EDS_INT_PARAM_NAME);
                int osrProcessingRatePerHourColumnIndex = usaStandardParametersTable.Table.Columns.IndexOf(GlobalNames.USA_STANDARD_OSR_PROCESSING_RATE_BPH_PARAM_NAME);
                int clearRateColumnIndex = usaStandardParametersTable.Table.Columns.IndexOf(GlobalNames.USA_STANDARD_CLEAR_RATE_PARAM_NAME);
                int etdScreenRateDomWithImageColumnIndex = usaStandardParametersTable.Table.Columns.IndexOf(GlobalNames.USA_STANDARD_ETD_SCREENING_RATE_DOM_WITH_IMAGE_PARAM_NAME);
                int etdScreenRateDomNoImageColumnIndex = usaStandardParametersTable.Table.Columns.IndexOf(GlobalNames.USA_STANDARD_ETD_SCREENING_RATE_DOM_NO_IMAGE_PARAM_NAME);
                int etdScreenRateIntWithImageColumnIndex = usaStandardParametersTable.Table.Columns.IndexOf(GlobalNames.USA_STANDARD_ETD_SCREENING_RATE_INT_WITH_IMAGE_PARAM_NAME);
                int etdScreenRateIntNoImageColumnIndex = usaStandardParametersTable.Table.Columns.IndexOf(GlobalNames.USA_STANDARD_ETD_SCREENING_RATE_INT_NO_IMAGE_PARAM_NAME);
                int rateLostTrackOSColumnIndex = usaStandardParametersTable.Table.Columns.IndexOf(GlobalNames.USA_STANDARD_RATE_LOST_TRACK_OS_PARAM_NAME);
                //int rateLostTrackOOGColumnIndex = usaStandardParametersTable.Table.Columns.IndexOf(GlobalNames.USA_STANDARD_RATE_LOST_TRACK_OOG_PARAM_NAME);
                int etdScreenRateOSBagsPerHourColumnIndex = usaStandardParametersTable.Table.Columns.IndexOf(GlobalNames.USA_STANDARD_ETD_SCREENING_RATE_OS_BAGS_BPH_PARAM_NAME);
                #endregion

                DataRow dr = usaStandardParametersTable.Table.NewRow();

                if (oogPercentColumnIndex != -1)
                    dr[oogPercentColumnIndex] = 0.04;
                if (osPercentColumnIndex != -1)
                    dr[osPercentColumnIndex] = 0.02;
                if (edsScreenRatePerMinColumnIndex != -1)
                    dr[edsScreenRatePerMinColumnIndex] = 8.42;
                if (edsScreenRatePerHourColumnIndex != -1)
                    dr[edsScreenRatePerHourColumnIndex] = 505;
                if (falseAlarmEdsDomColumnIndex != -1)
                    dr[falseAlarmEdsDomColumnIndex] = 0.2;
                if (falseAlarmEdsIntColumnIndex != -1)
                    dr[falseAlarmEdsIntColumnIndex] = 0.2;
                if (osrProcessingRatePerHourColumnIndex != -1)
                    dr[osrProcessingRatePerHourColumnIndex] = 180;
                if (clearRateColumnIndex != -1)
                    dr[clearRateColumnIndex] = 0.5;
                if (etdScreenRateDomWithImageColumnIndex != -1)
                    dr[etdScreenRateDomWithImageColumnIndex] = 18.85;
                if (etdScreenRateDomNoImageColumnIndex != -1)
                    dr[etdScreenRateDomNoImageColumnIndex] = 26.67;
                if (etdScreenRateIntWithImageColumnIndex != -1)
                    dr[etdScreenRateIntWithImageColumnIndex] = 13.9;
                if (etdScreenRateIntNoImageColumnIndex != -1)
                    dr[etdScreenRateIntNoImageColumnIndex] = 19.78;
                if (rateLostTrackOSColumnIndex != -1)
                    dr[rateLostTrackOSColumnIndex] = 0.01;
/*
                if (rateLostTrackOOGColumnIndex != -1)
                    dr[rateLostTrackOOGColumnIndex] = 0.04;
*/
                if (etdScreenRateOSBagsPerHourColumnIndex != -1)
                    dr[etdScreenRateOSBagsPerHourColumnIndex] = 15.19;
                
                usaStandardParametersTable.Table.Rows.Add(dr);
                usaStandardParametersTable.Table.AcceptChanges();
            }
            else
            {
                if (usaStandardParametersTable == null)
                {
                    ListeErreurs.Add("Error while initializing the USA Standard Parameters table.");
                    OverallTools.ExternFunctions.PrintLogFile("The USA Standard Parameters table could not be loaded.");
                }
            }
        }
        // << Task #9967 Pax2Sim - BNP development - Peak Flows - USA Standard parameters table

        private bool ouvrirFichierProjet_old(TreeNodeCollection Racine,
                                         Prompt.SIM_LoadingForm chForm,
                                         ContextMenuStrip cmsScenarioMenu,
                                         ContextMenuStrip cmsContextMenuInput,
                                         ContextMenuStrip cmsMenuFilter,
                                         ContextMenuStrip cmsAirport,
                                         ContextMenuStrip cmsGraphicFilter,
                                         ContextMenuStrip cmsAutomodMenu,
                                         ContextMenuStrip cmsUserGraphics,
                                         ContextMenuStrip cmsExportScenarioTables)
        {
            try
            {
                XmlDocument projet = new XmlDocument();
                if (!System.IO.File.Exists(nomDuChemin + "\\" + nomFichierProjetPax))
                {
                    ListeErreurs.Add("Err00051 : The file does not exist, please check the path.");
                    return false;
                }
                projet.Load(nomDuChemin + "\\" + nomFichierProjetPax);

                //Le fichier chargé ne possède pas de noeud enfant. Il ne s'agit donc pas 
                //d'un fichier de projet valide.
                if ((!projet.HasChildNodes) || //On vérifie que le fichier XML a des enfants.
                    (!OverallTools.FonctionUtiles.hasNamedChild(projet, "HUB2SIM")) || //On vérifie que l'un des noeuds principaux se nomme bien HUB2SIM
                    (!OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"], "InputDatas")) || // On vérifie que le noeud InputData est présent, il s'agit du noeud stockant les données d'entrées.
                    (!OverallTools.FonctionUtiles.hasNamedAttribute(projet["HUB2SIM"], "Name")) || //On vérifie que le nom du projet est bien renseigné.
                    (!OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"]["InputDatas"], "DataSource")) ||//On vérifie qu'il y a bien un enfant DataSource
                    (!OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"]["InputDatas"], PAX2SIM.sMainNodeName)))//On vérifie qu'il y a bien un enfant Airport
                {
                    ListeErreurs.Add("Err00052 : The " + PAX2SIM.sExtension.ToUpper() + " file does not have a good format.");
                    return false;
                }
                VersionManager sVersion = new VersionManager("1.0");
                //Gestion de la version:
                if (OverallTools.FonctionUtiles.hasNamedAttribute(projet["HUB2SIM"], "Version"))
                {
                    sVersion = new VersionManager(projet["HUB2SIM"].Attributes["Version"].Value.ToString());
                }
                if (sVersion > sCurrentVersion)
                {
                    ListeErreurs.Add("Err00053 : The PAX file format version is not support by this application. Please check for updates for " + OverallTools.AssemblyActions.AssemblyTitle + ".");
                    return false;
                }
                if (sVersion < new VersionManager(1, 15))
                {
                    ListeErreurs.Add("Err00054 : This version is not supported by the application. For more information please contact support@pax2sim.com.");
                    return false;
                }
                if (OverallTools.FonctionUtiles.hasNamedAttribute(projet["HUB2SIM"], "UseAlphaNumericForFlightPlans"))
                    bUseAlphNumericForFlightInfo = true;

                InitializePAX();
                int iNombreFichier = getFilesNumber_old(projet);

                if (chForm != null)
                    chForm.setFileNumber(iNombreFichier);
                //Récupération du nom du projet.
                nomProjetPax = projet["HUB2SIM"].GetAttribute("Name");
                if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"], "UnitsSettings"))
                {
                    if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"]["UnitsSettings"], "DistanceUnit"))
                        DistanceUnit_ = projet["HUB2SIM"]["UnitsSettings"]["DistanceUnit"].FirstChild.Value;
                    if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"]["UnitsSettings"], "DistanceInitial"))
                        DistanceInitial_ = projet["HUB2SIM"]["UnitsSettings"]["DistanceInitial"].FirstChild.Value;
                    if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"]["UnitsSettings"], "TimeUnit"))
                        TimeUnit_ = projet["HUB2SIM"]["UnitsSettings"]["TimeUnit"].FirstChild.Value;
                    if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"]["UnitsSettings"], "TimeInitial"))
                        TimeInitial_ = projet["HUB2SIM"]["UnitsSettings"]["TimeInitial"].FirstChild.Value;
                    if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"]["UnitsSettings"], "Speed"))
                    {
                        if (!Double.TryParse(projet["HUB2SIM"]["UnitsSettings"]["Speed"].FirstChild.Value, out Speed_))
                        {
                            ListeErreurs.Add("Err00063 : Speed information does not have a good format");
                            return false;
                        }
                    }
                    if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"]["UnitsSettings"], "Tolerance"))
                    {
                        if (!Double.TryParse(projet["HUB2SIM"]["UnitsSettings"]["Tolerance"].FirstChild.Value, out Tolerance_))
                        {
                            ListeErreurs.Add("Err00064 : Tolerance information does not have a good format");
                            return false;
                        }
                    }
                    // >> Task #13368 Project/Properties update
                    Levels_ = new Double[] { GlobalNames.PROJECT_DEFAULT_DISTRIBUTION_LEVEL_1, GlobalNames.PROJECT_DEFAULT_DISTRIBUTION_LEVEL_2, 
                                        GlobalNames.PROJECT_DEFAULT_DISTRIBUTION_LEVEL_3 };//{ 50, 75, 95 };                
                    if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"]["UnitsSettings"], "Levels"))
                    {
                        if (OverallTools.FonctionUtiles.hasNamedAttribute(projet["HUB2SIM"]["UnitsSettings"]["Levels"], "First"))
                        {
                            if (!Double.TryParse(projet["HUB2SIM"]["UnitsSettings"]["Levels"].Attributes["First"].Value, out Levels_[0]))
                            {
                                ListeErreurs.Add("Warn00016 : The first level information does not have a good format");
                                Levels_[0] = 50;
                            }
                        }
                        if (OverallTools.FonctionUtiles.hasNamedAttribute(projet["HUB2SIM"]["UnitsSettings"]["Levels"], "Second"))
                        {
                            if (!Double.TryParse(projet["HUB2SIM"]["UnitsSettings"]["Levels"].Attributes["Second"].Value, out Levels_[1]))
                            {
                                ListeErreurs.Add("Warn00017 : The second level information does not have a good format");
                                Levels_[1] = 75;
                            }
                        }
                        if (OverallTools.FonctionUtiles.hasNamedAttribute(projet["HUB2SIM"]["UnitsSettings"]["Levels"], "Third"))
                        {
                            if (!Double.TryParse(projet["HUB2SIM"]["UnitsSettings"]["Levels"].Attributes["Third"].Value, out Levels_[2]))
                            {
                                ListeErreurs.Add("Warn00018 : The third level information does not have a good format");
                                Levels_[2] = 95;
                            }
                        }
                    }
                    // << Task #13368 Project/Properties update
                }
                AllocationStep_ = GlobalNames.PROJECT_DEFAULT_ALLOCATION_STEP;  //15.0; // >> Task #13368 Project/Properties update
                if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"], "AllocationStep"))
                {
                    if (!Double.TryParse(projet["HUB2SIM"]["AllocationStep"].FirstChild.Value, out AllocationStep_))
                    {
                        ListeErreurs.Add("Err00065 : AllocationStep information does not have a good format");
                        return false;
                    }
                }
                OverallTools.FonctionUtiles.setCoefficient(Speed_, TimeUnit_, Tolerance_, DistanceInitial_);

                //Sauvegarde de la structure de l'aéroport.
                structureAeroport = projet["HUB2SIM"]["InputDatas"][PAX2SIM.sMainNodeName].Clone();

                if (!CheckAirportStructure(structureAeroport))
                    return false;

                //On charge la structure de l'aéroport.

                if (chForm != null)
                    chForm.ChargementFichier("Load Airport definition");
                OverallTools.TreeViewFunctions.construireArbre(structureAeroport, Racine[0], cmsAirport);
                bAirportStructureHadBeenModified = true;

                GestionDonnees gsInput = getGestionDonnees("Input");
                //On charge les filtres dans un premier temps afin de pouvoir mettre à jour au fur et à mesure
                //la structure de l'arbre
                if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"]["InputDatas"], "Filters"))
                {
                    //Récupération de tous les filtres.
                    Filter filtre;
                    foreach (XmlElement xmlfiltre in projet["HUB2SIM"]["InputDatas"]["Filters"].ChildNodes)
                    {
                        if (chForm != null)
                            chForm.ChargementFichier("Load Filter : " + xmlfiltre.Name);
                        filtre = new Filter(xmlfiltre);
                        if (!IsValidFilter(filtre))
                        {
                            ListeErreurs.Add("Err00187 : The filters can't be \"CopyFilters\", one or more filter in the project are not allowed in the " + OverallTools.AssemblyActions.AssemblyTitle + " trial version.");
                            return false;
                        }
                        gsInput.ListFilters.Add(filtre.Name, filtre);
                    }
                }
                //ConvertTables.ConvertFilters(gsInput.ListFilters, sVersion, sCurrentVersion);
                ConvertTables.getConvertTable.ConvertFilters(gsInput.ListFilters, sVersion);

                //Chargement des données, en se basant sur les noms contenus dans le fichier de projet.
                foreach (XmlElement node in projet["HUB2SIM"]["InputDatas"]["DataSource"].ChildNodes)
                {
                    if (!node.HasAttribute("Name"))
                        continue;
                    String sTableName = node.Attributes["Name"].Value;
                    //sTableName = ConvertTables.ConvertName(sTableName, sVersion, sCurrentVersion);
                    sTableName = ConvertTables.getConvertTable.ConvertName(sTableName, sVersion);
                    if (chForm != null)
                        chForm.ChargementFichier("Load table : " + sTableName);
                    if (!chargerTable_old("Input", sTableName, nomDuChemin + node.FirstChild.Value, null, sVersion, false))
                        return false;
                    //ConvertTables.ConvertTable(getTable("Input", sTableName),sVersion,sCurrentVersion);
                    String sMother = motherTable(sTableName, gsInput.ListFilters);
                    ConvertTables.getConvertTable.ConvertFilter(gsInput.GetTable(sTableName), gsInput.getFilter(sTableName), sMother, sVersion);
                    //ConvertTables.ConvertTableFilter(gsInput.GetTable(sTableName), sMother, sVersion, sCurrentVersion);
                    gsInput.aEteModifiee(sTableName, true);
                }
                if (sVersion.isVersion(1, 15))
                {
                    ConvertTables.Version_1_15.ConvertMeanFlows_To_1_16(gsInput);
                }
                //Chargement des notes.
                if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"]["InputDatas"], "Notes"))
                {
                    gsInput.openNotes(projet["HUB2SIM"]["InputDatas"]["Notes"]);
                }

                ///Chargement des générales notes à l'aide de \ref openGeneralNotes
                if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"]["InputDatas"], "GeneralNotes"))
                {
                    openGeneralNotes(projet["HUB2SIM"]["InputDatas"]["GeneralNotes"]);
                }
                if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"]["InputDatas"], "Paragraphs"))
                {
                    openParagraph(projet["HUB2SIM"]["InputDatas"]["Paragraphs"]);
                }


                gsInput.UpdateFilters(Racine[1], cmsMenuFilter);
                if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"]["InputDatas"], "GraphicFilters"))
                {
                    //XmlNode arbreFiltres = projet["HUB2SIM"]["InputDatas"]["GraphicFilters"].Clone();
                    GraphicFilter filtre;
                    foreach (XmlElement xmlfiltre in projet["HUB2SIM"]["InputDatas"]["GraphicFilters"].ChildNodes)
                    {
                        if (chForm != null)
                            chForm.ChargementFichier("Load Graphics : " + xmlfiltre.Name);
                        filtre = new GraphicFilter(xmlfiltre);
                        gsInput.AddGraphicFilter(filtre);
                        //AddGraphicFilter("Input", filtre);
                    }
                }

                if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"]["InputDatas"], "GeneralFilters"))
                {
                    Filter fFilter;
                    foreach (XmlElement xmlfiltre in projet["HUB2SIM"]["InputDatas"]["GeneralFilters"].ChildNodes)
                    {
                        fFilter = new Filter(xmlfiltre);

                        if (chForm != null)
                            chForm.ChargementFichier("Load Graphics : " + xmlfiltre.Name);
                        dsfGraphiquesFilters.Add(fFilter.Name, fFilter);
                    }
                }
                Dictionary<String, GraphicFilter> dsGeneralGraphicFilterForFilter = new Dictionary<String, GraphicFilter>();
                if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"]["InputDatas"], "GeneralGraphicFilters"))
                {
                    GraphicFilter filtre;
                    foreach (XmlElement xmlfiltre in projet["HUB2SIM"]["InputDatas"]["GeneralGraphicFilters"].ChildNodes)
                    {
                        if (chForm != null)
                            chForm.ChargementFichier("Load Graphics : " + xmlfiltre.Name);
                        filtre = new GraphicFilter(xmlfiltre);
                        if (FilterExist(filtre.Name))
                        {
                            AddGraphicFilter("", filtre);
                            dsGeneralGraphicFilterForFilter.Add(filtre.Name, filtre);
                        }
                        else
                        {
                            AddGeneralGraphicFilter(filtre);
                            TreeViewTag Tag = TreeViewTag.getChartNode(filtre.Name);
                            OverallTools.TreeViewFunctions.AddSortedNode(Racine[3], OverallTools.TreeViewFunctions.createBranch(filtre.Name, filtre.Name, Tag, cmsGraphicFilter));
                        }
                    }
                }
                if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"]["InputDatas"], "GeneralFilters"))
                {
                    UpdateGeneralFilters(Racine[3], cmsMenuFilter);
                }
                if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"], "Scenarios"))
                {
                    foreach (XmlElement xmlScenario in projet["HUB2SIM"]["Scenarios"].ChildNodes)
                    {
                        if (!CanAddScenario())
                        {
                            ListeErreurs.Add("Err00024 : The project contains too many scenarios for the trial version of " + OverallTools.AssemblyActions.AssemblyTitle + ". The limit is " + NBScenarios.ToString() + ".");
                            return false;
                        }
                        TreeNode newScenario = LoadScenario_old(xmlScenario, null, chForm, cmsScenarioMenu, cmsContextMenuInput, cmsMenuFilter, cmsAutomodMenu, cmsUserGraphics, sVersion, cmsExportScenarioTables);
                        if (newScenario != null)
                            OverallTools.TreeViewFunctions.AddSortedNode(Racine[2], newScenario);
                    }
                }



                if (System.IO.Directory.Exists(nomDuChemin + "\\Data\\UserData"))
                {
                    gsInput.LoadUserData(nomDuChemin + "\\Data\\UserData", null);
                }
                if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"], "AllocateTables"))
                {
                    gsInput.LoadAllocateTables(projet["HUB2SIM"]);
                }
                if (OverallTools.FonctionUtiles.hasNamedChild(projet["HUB2SIM"], "ReportList"))
                {
                    // Load the reports
                    htReportParametres = ReportParameters.ImportParameters(projet["HUB2SIM"]["ReportList"], sVersion, Racine);
                }
            }
            catch (XmlException e)
            {
                ListeErreurs.Add("Err00060 : L'ouverture du fichier " + nomDuChemin + "\\" + nomFichierProjetPax + " a généré l'erreur suivante " + e.Message);
                OverallTools.ExternFunctions.PrintLogFile("Err00060: " + this.GetType().ToString() + " throw an exception: " + e.Message);
                return false;
            }
            return true;
        }
        /// <summary>
        /// This function is called to check that the current project can be saved. It would try to rename the project directory. And
        /// will check that there is no problems in moving the current directory into the .bak directory.
        /// </summary>
        /// <returns></returns>
        internal bool ManageBAKProjects(Prompt.SIM_LoadingForm chForm)
        {
            if (!System.IO.Directory.Exists(nomDuChemin))
                return true;
            if (System.IO.Directory.Exists(BAK2Project))
            {
                //If the Tempory saving directory already exists, that means that Pax2sim had had a really violent problem.
                ListeErreurs
                    .Add("Err00330 : There was a problem while saving the current project. Please select a different name or a different directory to save your current project.");   // >> Task #13366 Error message correction
                return false;
            }
            if (chForm != null)
                chForm.ChargementFichier("Makes the project backup : \"" + BAKProject + "\"");
            //We are moving the current pointing directory for the application.
            OverallTools.ExternFunctions.MoveCurrentDirectory();

            try
            {
                System.IO.Directory.Move(nomDuChemin, BAK2Project);
            }
            catch (Exception e)
            {
                ListeErreurs.Add("Err00332 : a problem appears during the saving of the project :  Unable to rename the directory \t\r" + e.Message);
                OverallTools.ExternFunctions.PrintLogFile("Err00332: " + this.GetType().ToString() + " throw an exception: " + e.Message);
                return false;
            }
            //We succeded in moving the old version. So we 
            return true;
        }

        /// <summary>
        /// If during the saving of the project some problems appeared, we have to delete the directory that had been generated. And 
        /// we try to restore the tempory directory.
        /// </summary>
        /// <param name="chForm"></param>
        /// <returns></returns>
        internal bool RestoreCurrentDirectory(Prompt.SIM_LoadingForm chForm)
        {
            //We are moving the current pointing directory for the application.
            OverallTools.ExternFunctions.MoveCurrentDirectory();
            if (System.IO.Directory.Exists(nomDuChemin))
            {
                //We first delete the directory that had been partially generated.
                try
                {
                    if (chForm != null)
                        chForm.ChargementFichier("Delete partial saved project : \"" + nomDuChemin + "\"");

                    System.IO.Directory.Delete(nomDuChemin, true);
                    if (System.IO.Directory.Exists(nomDuChemin))
                        return false;
                }
                catch (Exception e)
                {
                    ListeErreurs.Add("Err00333 : a problem appears while trying to remove the partial saved project : \t\r" + e.Message);
                    OverallTools.ExternFunctions.PrintLogFile("Err00333: " + this.GetType().ToString() + " throw an exception: " + e.Message);
                    return false;
                }
            }
            if (System.IO.Directory.Exists(BAK2Project))
            {
                //We try to move back the bak2project directory.
                try
                {
                    System.IO.Directory.Move(BAK2Project, nomDuChemin);
                }
                catch (Exception e)
                {
                    ListeErreurs.Add("Err00334 : a problem appears while trying to reinitialize the saving project \t\r" + e.Message);
                    OverallTools.ExternFunctions.PrintLogFile("Err00334: " + this.GetType().ToString() + " throw an exception: " + e.Message);
                    return false;
                }
            }
            return true;
        }

        /// <summary>
        /// Move finally the BAK2 project into the BAK directory.
        /// </summary>
        /// <returns></returns>
        internal bool FinalyseSAving()
        {
            if (!System.IO.Directory.Exists(BAK2Project))
                return false;

            //We are moving the current pointing directory for the application.
            OverallTools.ExternFunctions.MoveCurrentDirectory();
            if (!System.IO.File.Exists(BAK2Project + "\\" + nomFichierProjetPax))
            {

                if (!OverallTools.ExternFunctions.DeleteDirectory(BAK2Project))
                {
                    ListeErreurs.Add("Err00338 : a problem appears when trying to remove .bak directory \t\r");
                    return false;
                }
            }
            else
            {


                if (System.IO.Directory.Exists(BAKProject))
                {
                    if (!OverallTools.ExternFunctions.DeleteDirectory(BAKProject))
                    {
                        ListeErreurs.Add("Err00335 : a problem appears when trying to remove .bak directory \t\r");
                        return false;
                    }
                }

                try
                {
                    System.IO.Directory.Move(BAK2Project, BAKProject);
                }
                catch (Exception e)
                {
                    ListeErreurs.Add("Err00337 : a problem appears during the saving of the project :  Unable to rename the directory \t\r" + e.Message);
                    OverallTools.ExternFunctions.PrintLogFile("Err00337: " + this.GetType().ToString() + " throw an exception: " + e.Message);
                    return false;
                }
            }
            //We succeded in moving the old version.
            return true;
        }

        

        /// <summary>
        /// Fonction qui se charge d'enregistrer le projet dans le fichier du projet.
        /// </summary>
        /// <param name="Arbre">la structure de l'arbre. Cela permet d'exporter la structure de l'aéroport en XML.</param>
        /// <returns>Renvoie un booléen indiquant si l'enregistrement s'est bien déroulé.</returns>
        public bool saveProjet(System.Windows.Forms.TreeNodeCollection Arbre, Prompt.SIM_LoadingForm chForm)
        {
            if (chForm != null)
                chForm.setFileNumber(getNumberOfFiles() + 8);
            if (nomDuChemin == nomOldSavingPath)
            {
                nomOldSavingPath = BAK2Project;
                if (System.IO.Directory.Exists(nomDuChemin))
                    if (!ManageBAKProjects(chForm))
                    {
                        nomOldSavingPath = nomDuChemin;
                        return false;
                    }
            }
            if (chForm != null)
                chForm.ChargementFichier("Saving project : Create Directories.");
            OverallTools.ExternFunctions.CheckCreateDirectory(nomDuChemin);
            //On vérifie que le chemin spécifié existe.
            if (!System.IO.Directory.Exists(nomDuChemin))
            {
                ListeErreurs.Add("Err00061 : The directory does not exist.");
                return false;
            }
            try
            {
                if (System.IO.Directory.Exists(nomDuChemin + "\\Data"))
                {
                    System.IO.Directory.Delete(nomDuChemin + "\\Data", true);
                }
                OverallTools.ExternFunctions.CheckCreateDirectory(nomDuChemin + "\\Data");
            }
            catch (Exception e)
            {
                ListeErreurs.Add("Err00200 : a problem appears during the saving of the project : Unable to create the \"Data\" directory :\t\r" + e.Message);
                OverallTools.ExternFunctions.PrintLogFile("Err00200: " + this.GetType().ToString() + " throw an exception: " + e.Message);
                return false;
            }

            try
            {
                if (System.IO.Directory.Exists(nomDuChemin + "\\Data\\UserData"))
                {
                    //Normalement impossible, car on aurait supprimer le dossier Data en premier lieu.
                    System.IO.Directory.Delete(nomDuChemin + "\\Data\\UserData", true);
                }
                if (System.IO.Directory.Exists(nomDuChemin + "\\Output"))
                {
                    System.IO.Directory.Delete(nomDuChemin + "\\Output", true);
                }
            }
            catch (Exception e)
            {
                ListeErreurs.Add("Err00201 : a problem appears during the saving of the project : Unable to access the saving directory :\t\r" + e.Message);
                OverallTools.ExternFunctions.PrintLogFile("Err00201: " + this.GetType().ToString() + " throw an exception: " + e.Message);
                return false;
            }
            DataManagerInput dmiInput = InputData;
            if (dmiInput == null)
                return false;
            hadBeenSaved = true;
            HadAlreadyBeenSavedOnDisk = true;
            if (chForm != null)
                chForm.ChargementFichier("Saving project : Exporting airport structure.");
            //projet = new XmlDocument();
            structureAeroport.RemoveAll();
            projet.RemoveAll();
            projet = null;
            projet = new XmlDocument();
            structureAeroport = projet.CreateElement(PAX2SIM.sMainNodeName);
            //On créée l'arbre XML pour l'aéroport.
            construireArbreAeroport(Arbre[0], structureAeroport);

            projet.AppendChild(projet.CreateElement("HUB2SIM"));
            projet["HUB2SIM"].SetAttribute("Name", nomProjetPax);
            projet["HUB2SIM"].SetAttribute("Version", sCurrentVersion.ToString());
            projet["HUB2SIM"].SetAttribute("ApplicationVersion", OverallTools.AssemblyActions.AssemblyVersion);    //new attribute "ApplicationVersion"
            projet["HUB2SIM"].SetAttribute("UniqueHardwareId", AskMode.unikeyHardwareId.ToString());    // >> Task #13763 Pax2Sim - .pax project file
            projet["HUB2SIM"].SetAttribute("Last4DigitsFromUnikeyMemory", AskMode.lastFourUnikeyMemoryDigits);    // >> Task #13763 Pax2Sim - .pax project file

            if (bUseAlphNumericForFlightInfo)
                projet["HUB2SIM"].SetAttribute("UseAlphaNumericForFlightPlans", "");

            XmlElement UnitsSettings = projet.CreateElement("UnitsSettings");
            XmlElement xmlTmp = projet.CreateElement("DistanceUnit");
            xmlTmp.AppendChild(projet.CreateTextNode(DistanceUnit_));
            UnitsSettings.AppendChild(xmlTmp);

            xmlTmp = projet.CreateElement("DistanceInitial");
            xmlTmp.AppendChild(projet.CreateTextNode(DistanceInitial_));
            UnitsSettings.AppendChild(xmlTmp);

            xmlTmp = projet.CreateElement("TimeUnit");
            xmlTmp.AppendChild(projet.CreateTextNode(TimeUnit_));
            UnitsSettings.AppendChild(xmlTmp);

            xmlTmp = projet.CreateElement("TimeInitial");
            xmlTmp.AppendChild(projet.CreateTextNode(TimeInitial_));
            UnitsSettings.AppendChild(xmlTmp);

            xmlTmp = projet.CreateElement("Speed");
            xmlTmp.AppendChild(projet.CreateTextNode(Speed_.ToString()));
            UnitsSettings.AppendChild(xmlTmp);

            xmlTmp = projet.CreateElement("Tolerance");
            xmlTmp.AppendChild(projet.CreateTextNode(Tolerance_.ToString()));
            UnitsSettings.AppendChild(xmlTmp);

            xmlTmp = projet.CreateElement("Levels");
            xmlTmp.SetAttribute("First", Levels_[0].ToString());
            xmlTmp.SetAttribute("Second", Levels_[1].ToString());
            xmlTmp.SetAttribute("Third", Levels_[2].ToString());
            UnitsSettings.AppendChild(xmlTmp);
            
            projet["HUB2SIM"].AppendChild(UnitsSettings);

            // >> Task #15088 Pax2Sim - BHS Analysis - Times and Indexes
            XmlElement analysisResultsFiltersMainElement = projet.CreateElement(XML_ELEMENT_NAME_ANALYSIS_RESULTS_FILTERS_MAIN);
            XmlElement basicAnalysisResultsFiltersElement = projet.CreateElement(XML_ELEMENT_NAME_ANALYSIS_RESULTS_FILTERS_BASIC);
            saveAnalysisResultsFilters(globalBasicAnalysisResultFilterList, projet, basicAnalysisResultsFiltersElement);
            analysisResultsFiltersMainElement.AppendChild(basicAnalysisResultsFiltersElement);

            XmlElement advancedAnalysisResultsFiltersElement = projet.CreateElement(XML_ELEMENT_NAME_ANALYSIS_RESULTS_FILTERS_ADVANCED);
            saveAnalysisResultsFilters(globalAdvancedAnalysisResultFilterList, projet, advancedAnalysisResultsFiltersElement);
            analysisResultsFiltersMainElement.AppendChild(advancedAnalysisResultsFiltersElement);

            XmlElement customAnalysisResultsFiltersElement = projet.CreateElement(XML_ELEMENT_NAME_ANALYSIS_RESULTS_FILTERS_CUSTOM);
            saveAnalysisResultsFilters(globalCustomAnalysisResultFilterList, projet, customAnalysisResultsFiltersElement);
            analysisResultsFiltersMainElement.AppendChild(customAnalysisResultsFiltersElement);

            projet["HUB2SIM"].AppendChild(analysisResultsFiltersMainElement);
            // << Task #15088 Pax2Sim - BHS Analysis - Times and Indexes
            
            xmlTmp = projet.CreateElement("AllocationStep");
            xmlTmp.AppendChild(projet.CreateTextNode(AllocationStep_.ToString()));
            projet["HUB2SIM"].AppendChild(xmlTmp);

            if (chForm != null)
                chForm.ChargementFichier("Saving project : Exporting input data.");

            UserDocumentUtils.updateDocumentTablesFilePaths(documentTableNames, nomDuChemin, this); // >> Task #16578 PAX2SIM - Documents - new node in main tree-view
                        
            XmlElement xeInput = dmiInput.Save(projet, nomDuChemin, nomOldSavingPath, "\\Data\\",chForm);
            projet["HUB2SIM"].AppendChild(xeInput);

            // << Task #6386 Itinerary process
            NormalTable itineraryTableNt = GetTable("Input", GlobalNames.ItineraryTableName);
            if (itineraryTableNt != null)   // PAX key flag disabled
            {
                List<string> filtersForItineraryTable = itineraryTableNt.GetFilters();

                List<string> itineraryGroupsTablePartialPathForFilters = new List<string>();
                for (int i = 0; i < filtersForItineraryTable.Count; i++)
                {
                    String filterName = filtersForItineraryTable[i];
                    String partialFilePath = "\\Data\\" + Model.itineraryGroupsTextFilePrefix
                        + filterName + Model.itineraryGroupsTextFileExtention;
                    itineraryGroupsTablePartialPathForFilters.Add(partialFilePath);
                }
                String itineraryTablePartialPath = "\\Data\\" + Model.itineraryGroupsTextFilePrefix
                        + GlobalNames.ItineraryTableName + Model.itineraryGroupsTextFileExtention;
                itineraryGroupsTablePartialPathForFilters.Add(itineraryTablePartialPath);

                if (nomOldSavingPath != null && nomDuChemin != null)          // << Bug #8210 Pax2Sim - ProcessFlow - save issue
                {
                    for (int j = 0; j < itineraryGroupsTablePartialPathForFilters.Count; j++)
                    {
                        String partialFilePath = itineraryGroupsTablePartialPathForFilters[j];
                        String groupsFileOldPath = nomOldSavingPath + partialFilePath;
                        String groupsFileNewPath = nomDuChemin + partialFilePath;

                        try
                        {
                            if (File.Exists(groupsFileOldPath))
                                File.Copy(groupsFileOldPath, groupsFileNewPath, true);
                        }
                        catch (Exception e)
                        {
                            OverallTools.ExternFunctions.PrintLogFile("Exception caught while copying " +
                                "ItineraryGroups_*.txt files. " + e.Message);
                        }
                    }
                }
                else
                {
                    // << Bug #8210 Pax2Sim - ProcessFlow - save issue
                    foreach (KeyValuePair<String, List<ItineraryData>> pair in PAX2SIM.globalItineraryDataListDictionary)
                    {
                        String processFlowName = pair.Key;
                        List<ItineraryData> itineraryGroupList = pair.Value;
                        if (itineraryGroupList != null)
                        {
                            String groupsFilePath = nomDuChemin + "\\Data\\"
                                                  + Model.itineraryGroupsTextFilePrefix + processFlowName + Model.itineraryGroupsTextFileExtention;

                            try
                            {
                                System.IO.StreamWriter writer = new StreamWriter(groupsFilePath);
                                foreach (ItineraryData group in itineraryGroupList)
                                {
                                    writer.WriteLine(group.name + ";" + group.description + ";" + group.itineraryDataType
                                        + ";" + group.x + ";" + group.y + ";" + group.width + ";" + group.height + ";" + group.paxProcessTimes
                                        + ";" + group.bagProcessTimes + ";" + group.capacity + ";" + group.firstGradientColor + ";" + group.firstGradientAlpha
                                         + ";" + group.secondGradientColor + ";" + group.secondGradientAlpha + ";" + group.borderColor
                                         + ";" + group.gradientAngle);
                                }
                                writer.Close();
                                writer.Dispose();
                            }
                            catch (Exception e)
                            {
                                OverallTools.ExternFunctions.PrintLogFile("Exception while saving process flows " + e.Message);
                            }

                        }
                    }
                    // >> Bug #8210 Pax2Sim - ProcessFlow - save issue

                }
                if (!ProcessFlowServices.saveBackgroundImageFilesForProcessFlows(nomDuChemin, nomOldSavingPath, ListeErreurs))
                    return false;

                //save bendpoints files
                ProcessFlowServices.saveConnectionBendpointsFiles(nomDuChemin, nomOldSavingPath, ListeErreurs, this);
                // >> Task #6386 Itinerary process

                // << Task #8819 Pax2Sim - ProcessFlow - save Details parameters
                ProcessFlowServices.saveProcessFlowShowDetailsParametersFiles(nomDuChemin, nomOldSavingPath,
                    ListeErreurs, this);
                // >> Task #8819 Pax2Sim - ProcessFlow - save Details parameters
            }
            XmlNode xnNotes = saveGeneralNotes(projet);
            if (xnNotes != null)
                projet["HUB2SIM"].AppendChild(xnNotes);

            xnNotes = saveParagraph(projet);
            if (xnNotes != null)
                projet["HUB2SIM"].AppendChild(xnNotes);

            //On ajoute au fichier XML l'arbre XML de l'aéroport.
            projet["HUB2SIM"].AppendChild(projet.ImportNode(structureAeroport.Clone(), true));
       
            if (htGraphiques.Count != 0)
            {
                XmlElement arbreFiltres = projet.CreateElement("GeneralGraphicFilters");
                foreach (GraphicFilter filtre in htGraphiques.Values)
                {
                    arbreFiltres.AppendChild(filtre.creerArbreXml(projet));
                }
                projet["HUB2SIM"].AppendChild(arbreFiltres);
                if (dsfGraphiquesFilters.Count > 0)
                {
                    arbreFiltres = projet.CreateElement("GeneralFilters");
                    foreach (String Name in dsfGraphiquesFilters.Keys)
                    {
                        arbreFiltres.AppendChild(dsfGraphiquesFilters[Name].creerArbreXml(projet));
                        //arbreFiltres.AppendChild(filtre.creerArbreXml(projet));
                    }
                    projet["HUB2SIM"].AppendChild(arbreFiltres);
                }
            }

            if (chForm != null)
                chForm.ChargementFichier("Saving project : Scenarios.");
            try
            {
                OverallTools.ExternFunctions.CheckCreateDirectory(nomDuChemin + "\\Output");                
            }
            catch (Exception e)
            {
                ListeErreurs.Add("Err00205 : a problem appears during the saving of the project : Unable to create the \"output\" directory \t\r" + e.Message);
                OverallTools.ExternFunctions.PrintLogFile("Err00205: " + this.GetType().ToString() + " throw an exception: " + e.Message);
                return false;
            }
            XmlElement XMLScenarios = projet.CreateElement("Scenarios");
            projet["HUB2SIM"].AppendChild(XMLScenarios);
            try
            {
                foreach (String sKey in dmsScenarios.Keys)
                {
                    OverallTools.ExternFunctions.CheckCreateDirectory(nomDuChemin + "\\Output\\" + sKey);
                    TreeNode racineScenario = OverallTools.TreeViewFunctions.RechercherNom(sKey, Arbre[2]);
                    dmsScenarios[sKey].UpdateAbro(racineScenario);                    
                    XmlElement xeScenario = dmsScenarios[sKey].Save(projet, nomDuChemin, nomOldSavingPath, "\\Output\\" + sKey + "\\",chForm);
                    if (xeScenario != null)
                        XMLScenarios.AppendChild(xeScenario);
                }
            }
            catch (Exception e)
            {
                OverallTools.ExternFunctions.PrintLogFile("Err00206 : Unable to save a scenario, Exception : " + e.Message);
                OverallTools.ExternFunctions.PrintLogFile("Err00206: " + this.GetType().ToString() + " throw an exception: " + e.Message);
                return false;
            }

            // >> Task #17969 PAX2SIM - Reports improvements
            OverallTools.FonctionUtiles.CopyFolderContents(nomOldSavingPath + "\\Output\\" + ReportGenerator.REPORTS_ROOT_DIRECTORY_NAME, 
                nomDuChemin + "\\Output\\" + ReportGenerator.REPORTS_ROOT_DIRECTORY_NAME);
            // << Task #17969 PAX2SIM - Reports improvements

            if (chForm != null)
                chForm.ChargementFichier("Saving Reports.");
            // save the reports parameters
            XmlNode ReportListElement = ReportParameters.ExportParameters(htReportParametres, projet, nomDuChemin+"\\", chForm);
            if (ReportListElement != null)
                projet["HUB2SIM"].AppendChild(ReportListElement);

            // >> Task #16578 PAX2SIM - Documents - new node in main tree-view
            if (chForm != null)
                chForm.ChargementFichier("Saving Documents.");
            XmlNode documentsXmlNode = projet.CreateElement(GlobalNames.DOCUMENTS_XML_NODE_NAME);
            foreach (string documentTableName in documentTableNames)
            {
                XmlElement documentTableXmlNode = projet.CreateElement(GlobalNames.DOCUMENT_XML_NODE_NAME);
                documentTableXmlNode.SetAttribute(GlobalNames.DOCUMENT_XML_NODE_NAME_ATTRIBUTE, documentTableName);
                documentsXmlNode.AppendChild(documentTableXmlNode);
            }
            projet["HUB2SIM"].AppendChild(documentsXmlNode);

            //>>GanttNote for Report    // >> Task #10645 Pax2Sim - Pax analysis - Summary: dashboard image for Reports            
            // the hidden directory ..\Output\GanttFiles holds the Gantt .png images
            // when saving this directory will be copied and made hidden
            // the Dashboard note images are also held in this directory
            String sourcePath = "";
            String targetPath = "";

            if (nomDuChemin.Equals(nomOldSavingPath))
            {
                sourcePath = BAK2Project + "\\Output\\GanttFiles";
                targetPath = nomDuChemin + "\\Output\\GanttFiles";
            }
            else
            {
                sourcePath = nomOldSavingPath + "\\Output\\GanttFiles";
                targetPath = nomDuChemin + "\\Output\\GanttFiles";
            }

            String fileName = "";
            String destFile = "";
            if (System.IO.Directory.Exists(sourcePath))
            {
                //OverallTools.ExternFunctions.CheckCreateDirectory(targetPath);
                DirectoryInfo di = null;
                if (!Directory.Exists(targetPath))
                {
                    try
                    {
                        di = Directory.CreateDirectory(targetPath);
                    }
                    catch (Exception ex)
                    {
                        if (ex is System.IO.IOException || ex is System.UnauthorizedAccessException
                            || ex is System.ArgumentException || ex is System.ArgumentNullException
                            || ex is System.IO.PathTooLongException || ex is System.IO.DirectoryNotFoundException
                            || ex is System.NotSupportedException)
                        {
                            ListeErreurs.Add("ErrG001 : a problem appears during the saving of the project : Unable to create the directory GanttFiles \t\r" + ex.Message);
                            return false;
                        }
                    }
                    di.Attributes = FileAttributes.Directory | FileAttributes.Hidden;
                }
                string[] files = null;
                try
                {
                    files = System.IO.Directory.GetFiles(sourcePath);
                }
                catch (Exception ex)
                {
                    if (ex is System.IO.IOException || ex is System.UnauthorizedAccessException
                        || ex is System.ArgumentException || ex is System.ArgumentNullException
                        || ex is System.IO.PathTooLongException || ex is System.IO.DirectoryNotFoundException)
                    {
                        ListeErreurs.Add("ErrG002 : a problem appears during the saving of the project : Unable to retrieve the files from the old Gantt and Dashboard files directory \t\r" + ex.Message);
                        return false;
                    }
                }
                // Copy the files and overwrite destination files if they already exist.
                foreach (string s in files)
                {
                    // Use static Path methods to extract only the file name from the path.
                    try
                    {
                        fileName = System.IO.Path.GetFileName(s);
                    }
                    catch (System.ArgumentException ex)
                    {
                        ListeErreurs.Add("ErrG003 : a problem appears during the saving of the project : Unable to retrieve the file name from the old Gantt and Dashboard files directory \t\r" + ex.Message);
                        return false;
                    }
                    try
                    {
                        destFile = System.IO.Path.Combine(targetPath, fileName);
                    }
                    catch (Exception ex)
                    {
                        if (ex is System.ArgumentException || ex is System.ArgumentNullException)
                        {
                            ListeErreurs.Add("ErrG004 : a problem appears during the saving of the project : Unable to create the destination path for the Gantt and Dashboard files \t\r" + ex.Message);
                            return false;
                        }
                    }
                    try
                    {
                        System.IO.File.Copy(s, destFile, true);
                    }
                    catch (Exception ex)
                    {
                        if (ex is System.IO.IOException || ex is System.UnauthorizedAccessException
                            || ex is System.ArgumentException || ex is System.ArgumentNullException
                            || ex is System.IO.PathTooLongException || ex is System.IO.DirectoryNotFoundException
                            || ex is System.NotSupportedException || ex is System.IO.FileNotFoundException)
                        {
                            ListeErreurs.Add("ErrG005 : a problem appears during the saving of the project : Unable to copy the Gantt and Dashboard files into the new directory \t\r" + ex.Message);
                            return false;
                        }
                    }
                }
            }

            // >> Task #10701 Pax2Sim - Pax analysis - saving the Dashboard configuration
            String projectDirectoryPath = getDossierEnregistrement();
            if (projectDirectoryPath != null)
            {
                DashboardTools.saveDashboardConfigDataIntoTextFile(PAX2SIM.scenariosStationsDashboardDictionary, projectDirectoryPath);
            }
            // << Task #10701 Pax2Sim - Pax analysis - saving the Dashboard configuration

            // >> Task #16578 PAX2SIM - Documents - new node in main tree-view
            string oldProjectDocumentsDirectoryPath = "";
            string newProjectDocumentsDirectoryPath = nomDuChemin + "\\Data\\" + GlobalNames.DOCUMENTS_DIRECTORY_NAME;
            if (nomDuChemin.Equals(nomOldSavingPath))
            {
                oldProjectDocumentsDirectoryPath = BAK2Project + "\\Data\\" + GlobalNames.DOCUMENTS_DIRECTORY_NAME;                
            }
            else
            {
                oldProjectDocumentsDirectoryPath = nomOldSavingPath + "\\Data\\" + GlobalNames.DOCUMENTS_DIRECTORY_NAME;                
            }
            //copy first from the old Project dir so that for an updated doc the file from the Temp directory will overwrite the one from the old Project dir.
            //Then delete the temp Documents directory so that it will not impact if we change to a project that has among the docs one with the same name.
            UserDocumentUtils.copyDocumentsFromOldProjectDirectoryIntoNewProject(oldProjectDocumentsDirectoryPath, newProjectDocumentsDirectoryPath, documentTableNames);
            string tempDocumentsDirectoryPath = OverallTools.ExternFunctions.getTempDirectoryForPax2sim() + GlobalNames.DOCUMENTS_DIRECTORY_NAME;
            if (Directory.Exists(tempDocumentsDirectoryPath))
            {
                OverallTools.ExternFunctions.CheckCreateDirectory(newProjectDocumentsDirectoryPath);
                UserDocumentUtils.copyDocumentsFromTemporaryDirectoryIntoNewProject(tempDocumentsDirectoryPath, newProjectDocumentsDirectoryPath, documentTableNames);
                string errorMessage = "";
                UserDocumentUtils.deleteDirectory(tempDocumentsDirectoryPath, out errorMessage);               
            }
            // << Task #16578 PAX2SIM - Documents - new node in main tree-view

            //On enregistre le fichier du projet.
            try
            {
                if (chForm != null)
                    chForm.ChargementFichier("Finalizing the saving.");
                projet.Save(nomDuChemin + "\\" + nomFichierProjetPax);
            }
            catch (Exception e)
            {
                ListeErreurs.Add("Err00207 : a problem appears during the saving of the project : Unable to save the allocated table \t\r" + e.Message);
                OverallTools.ExternFunctions.PrintLogFile("Err00207: " + this.GetType().ToString() + " throw an exception: " + e.Message);
                return false;
            }
            nomOldSavingPath = nomDuChemin;
            return true;
        }

        /// <summary>
        /// Fonction pour enregistrer le fichier du projet à l'emplacement spécifié.
        /// </summary>
        /// <param name="fichierSauvegarde">Emplacement de sauvegarde du projet.</param>
        /// <param name="Arbre">Arbre du treeview permettant de récupérer la structure de l'aéroport.</param>
        /// <returns>Renvoie un booléen indiquant si la sauvegarde s'est bien déroulée ou non.</returns>
        public bool saveProjet(String CheminSauvegarde, System.Windows.Forms.TreeNodeCollection Arbre, Prompt.SIM_LoadingForm chForm)
        {
            nomOldSavingPath = nomDuChemin;
            /// Récupération du chemin
            this.nomDuChemin = CheminSauvegarde + "\\" + nomProjetPax;//System.IO.Path.GetDirectoryName(fichierSauvegarde);
            /// Récupération du nom du fichier seul
            this.nomFichierProjetPax = nomProjetPax + "." + PAX2SIM.sExtension;//System.IO.Path.GetFileName(fichierSauvegarde);
            if (!saveProjet(Arbre, chForm))
            {
                nomDuChemin = nomOldSavingPath;
                return false;
            }
            else
            {
                nomOldSavingPath = nomDuChemin;
                return true;
            }
        }

        // >> Task #15088 Pax2Sim - BHS Analysis - Times and Indexes
        private const string XML_ELEMENT_NAME_ANALYSIS_RESULTS_FILTERS_MAIN = "AnalysisResultsFilters";
        private const string XML_ELEMENT_NAME_ANALYSIS_RESULTS_FILTERS_BASIC = "BasicAnalysisResultsFilters";
        private const string XML_ELEMENT_NAME_ANALYSIS_RESULTS_FILTERS_ADVANCED = "AdvancedAnalysisResultsFilters";
        private const string XML_ELEMENT_NAME_ANALYSIS_RESULTS_FILTERS_CUSTOM = "CustomAnalysisResultsFilters";
        private void saveAnalysisResultsFilters(List<AnalysisResultFilter> analysisResultsFilters,
            XmlDocument project, XmlElement paramScenarioElement)
        {
            if (analysisResultsFilters != null)
            {                
                for (int i = 0; i < analysisResultsFilters.Count; i++)
                {
                    AnalysisResultFilter resultFilter = analysisResultsFilters[i];
                    XmlElement resultFilterElement = project.CreateElement(resultFilter.filterName + "RF" + i);
                    resultFilterElement.SetAttribute(ParamScenario.XML_ATTRIBUTE_NAME_FILTER_NAME, resultFilter.filterName);
                    resultFilterElement.SetAttribute(ParamScenario.XML_ATTRIBUTE_NAME_FROM_STATION, resultFilter.fromStationCode);
                    resultFilterElement.SetAttribute(ParamScenario.XML_ATTRIBUTE_NAME_FROM_STATION_TIME_TYPE, resultFilter.fromStationTimeType);
                    resultFilterElement.SetAttribute(ParamScenario.XML_ATTRIBUTE_NAME_TO_STATION, resultFilter.toStationCode);
                    resultFilterElement.SetAttribute(ParamScenario.XML_ATTRIBUTE_NAME_TO_STATION_TIME_TYPE, resultFilter.toStationTimeType);
                    resultFilterElement.SetAttribute(ParamScenario.XML_ATTRIBUTE_NAME_WITH_RECIRC, resultFilter.withRecirculation.ToString());
                    resultFilterElement.SetAttribute(ParamScenario.XML_ATTRIBUTE_NAME_WITH_FROM_SEGR, resultFilter.withFromSegregation.ToString());
                    resultFilterElement.SetAttribute(ParamScenario.XML_ATTRIBUTE_NAME_WITH_TO_SEGR, resultFilter.withToSegregation.ToString());
                    resultFilterElement.SetAttribute(ParamScenario.XML_ATTRIBUTE_NAME_EXCLUDE_EBS, resultFilter.excludeEBSStorageTime.ToString());
                    resultFilterElement.SetAttribute(ParamScenario.XML_ATTRIBUTE_NAME_GENERATE_IST, resultFilter.generateIST.ToString());
                    paramScenarioElement.AppendChild(resultFilterElement);
                }                
            }
        }
        // << Task #15088 Pax2Sim - BHS Analysis - Times and Indexe
        #endregion

        #region Partie pour la gestion des UserData
        public Dictionary<String, List<String>> getUserData()
        {
            DataManagement.DataManagerInput gs = InputData;
            if (gs == null)
                return null;
            return gs.GetUserData();
        }

        public void SaveUserDataForScenario(String Directory, Dictionary<String,String> htDefaults)
        {
            DataManagement.DataManagerInput gs = InputData;
            if (gs != null)
            {
                gs.SaveUserDataForSimulation(Directory, htDefaults);
            }
        }
        public void MajUserData(TreeNode InputNode, ContextMenuStrip cmsUserDataMenu)
        {
            DataManagement.DataManagerInput gs = InputData;
            if (gs == null)
                return;
            TreeNode UserData = OverallTools.TreeViewFunctions.RechercherNom("User Data", InputNode);
            if (UserData == null)
                return;
            UserData.ContextMenuStrip = cmsUserDataMenu;
            gs.UpdateUserDataTree(UserData, cmsUserDataMenu);

        }



        public bool AddUserData(String UserDataName, String sFile)
        {
            DataManagement.DataManagerInput gs = InputData;
            if (gs == null)
                return false;
            if (!gs.AddUserData(sFile, UserDataName))
                return false;
            hadBeenSaved = false;
            return true;
        }
        public bool AddUserData(TreeNode InputNode, ContextMenuStrip cmsUserDataMenu, String sFile, String sNomTable)
        {
            DataManagement.DataManagerInput gs = InputData;
            if (gs == null)
                return false;

            if ((sNomTable == "") || (sNomTable == null))
            {
                sNomTable = sFile;
                if (sNomTable.Contains("\\"))
                    sNomTable = sNomTable.Substring(sFile.LastIndexOf("\\") + 1);
            }
            bool bAlreadyExist = gs.UserDataExists(sNomTable);
            string Location = InputNode.Name;
            if (InputNode.Name == "User Data")
                Location = sNomTable;
            if (!gs.AddUserData(sFile, Location))
                return false;
            hadBeenSaved = false;
            if (!bAlreadyExist)
            {
                if (InputNode.Name == "User Data")
                {
                    TreeNode tnTmp = OverallTools.TreeViewFunctions.CreateDirectory(sNomTable, cmsUserDataMenu);
                    OverallTools.TreeViewFunctions.AddSortedNode(InputNode, tnTmp);
                    InputNode = tnTmp;
                }
                String nomTable = sFile.Substring(sFile.LastIndexOf("\\") + 1);
                TreeNode tmp = OverallTools.TreeViewFunctions.createBranch(nomTable, nomTable, TreeViewTag.getTableNode("Input", nomTable), cmsUserDataMenu);
                OverallTools.TreeViewFunctions.AddSortedNode(InputNode, tmp);
            }
            return true;
        }
        /// <summary>
        /// Fonction qui supprime une table ou un dossier du UserData.
        /// </summary>
        /// <param name="ObjectNode"></param>
        /// <param name="bDirectoryNode">Si il s'agit d'un dossier</param>
        /// <returns></returns>
        public bool DeleteUserData(TreeNode ObjectNode, bool bDirectoryNode)
        {
            if (ObjectNode == null)
                return false;
            String sName = ObjectNode.Text;
            DataManagement.DataManagerInput gs = InputData;
            if (gs == null)
                return false;
            hadBeenSaved = false;
            if (bDirectoryNode)
            {
                gs.DeleteUserData(ObjectNode.Text);
            }
            else
                gs.DeleteUserData(ObjectNode.Parent.Name, sName);
            ObjectNode.Parent.Nodes.Remove(ObjectNode);
            return true;
        }
        public bool IsUserData(String sNomFichier)
        {
            if (sNomFichier == null)
                return false;
            DataManagement.DataManagerInput gs = InputData;
            if (gs == null)
                return false;
            return gs.UserDataExists(sNomFichier);
        }
        
        #endregion

        #region Fonctions qui mettent à jour les tables en fonction des categories de vol.

        /// <summary>
        /// Fonction qui met à jour les colonnes des tables qui se basent sur les catégories de vol.
        /// </summary>
        public void Update_FlightCategorie()
        {
            DataTable dtFlightCategory = getTable("Input", GlobalNames.FP_FlightCategoriesTableName);
            if (dtFlightCategory == null)   // PAX key flag disabled
            {
                return;
            }
            String[] Columns = new String[dtFlightCategory.Rows.Count];
            for (int i = 0; i < dtFlightCategory.Rows.Count; i++)
            {
                Columns[i] = dtFlightCategory.Rows[i][0].ToString();
            }
            List<String> Tables = dmiInputData.getTablesForFlightCategoriesUpdate();
            foreach (String nomTable in Tables)
            {
                ApplyFlightCategoriesChange(nomTable, null, Columns);
            }
            Check_FC_Values();
        }
        private bool ApplyFlightCategoriesChange(String sTableName, String sMotherTable, String[] tsFlightCategories)
        {
            DataManagement.DataManagerInput gs = InputData;
            if (gs == null)
                return false;
            DataManagement.NormalTable ntTable = gs.GetTable(sTableName);
            if (ntTable == null)
                return false;
            DataTable dtTable = ntTable.Table;
            if ((dtTable == null) || (dtTable.Columns.Count == 0))
                return false;
            bool bHadBeenChanged = false;
            int i;
            ArrayList FirstColumns = new ArrayList();
            String[] tsLastColumns = new string[dtTable.Columns.Count];
            int j = 0;
            DataManagerInput.LoadParameters lpTmp = DataManagerInput.getParameters(sTableName);
            
            //Suppression des colonnes qui ne sont pas présente dans la table des flight categories
            for (i = 0; i < dtTable.Columns.Count; i++)
            {
                String sColumnName = dtTable.Columns[i].ColumnName;
                tsLastColumns[j] = sColumnName;
                j++;
                if ((lpTmp != null) && (lpTmp.dstEntetes.Count!=0))
                //if (sColumnName, ListeEnteteDiv))
                {
                    String sTmp = "";
                    foreach (DataManagerInput.LoadParameters.Entete e in lpTmp.dstEntetes)
                    {
                        if (sColumnName == e.sName)
                        {
                            sTmp = sColumnName;
                            break;
                        }
                    }
                    if (sTmp != "")
                    {
                        FirstColumns.Add(sColumnName);
                        continue;
                    }

                }
                if (!OverallTools.FonctionUtiles.estPresentDansListe(sColumnName, tsFlightCategories))
                {
                    // << Task #7570 new Desk and extra information for Pax -Phase I B User Process tables
                    //Avoid trying to delete the primary key for the dinamicaly added tables(UserProcess table)
                    //When loading a project the application only recreates loadParameters for static tables =>
                    //the DataManagerInput.LoadParameters.Entete e in lpTmp.dstEntetes is by-passed because the loadParam is null.
                    bool isPrimaryKey = false;
                    DataColumn[] columns = dtTable.PrimaryKey;
                    for (int k = 0; k < columns.Length; k++)
                    {
                        if (dtTable.Columns[i].ColumnName == columns[k].ColumnName)
                            isPrimaryKey = true;
                    }
                    if (!isPrimaryKey)
                    {
                        dtTable.Columns.RemoveAt(i);
                        bHadBeenChanged = true;
                        i--;
                    }
                    // >> Task #7570 new Desk and extra information for Pax -Phase I B User Process tables
                }
            }
            NormalTable ntMother = GetTable("Input", sMotherTable);
            //int iIndexMotherTable = OverallTools.FonctionUtiles.indexDansListe(sTableName, ListeTablesDefault);
            //if (sMotherTable != null)
            //    iIndexMotherTable = OverallTools.FonctionUtiles.indexDansListe(sMotherTable, ListeTablesDefault);
            VisualisationMode vmVisuualisation =ntTable.Mode;
            if (sMotherTable != null)
                vmVisuualisation = ntMother.Mode;

            //Ajout des colonnes liés à la flight catégorie.
            foreach (String sColumnName in tsFlightCategories)
            {
                if (dtTable.Columns.Contains(sColumnName))
                    continue;
                bHadBeenChanged = true;
                dtTable.Columns.Add(sColumnName, typeof(Double));
                if (((ntMother == null) || (ntMother.TableParameters == null) || (ntMother.TableParameters.oDefaultColumn == null)) &&
                    ((ntTable == null) || (ntTable.TableParameters == null) || (ntTable.TableParameters.oDefaultColumn == null)))
                {
                    for (int k = 0; k < dtTable.Rows.Count; k++)
                        dtTable.Rows[k][sColumnName] = 0;
                    continue;
                }
                if(ntMother == null)
                    OverallTools.FonctionUtiles.initialiserColumnAdded(dtTable, ntTable.TableParameters.oDefaultColumn, vmVisuualisation, dtTable.Columns.Count - 1);
                else
                    OverallTools.FonctionUtiles.initialiserColumnAdded(dtTable, ntMother.TableParameters.oDefaultColumn, vmVisuualisation, dtTable.Columns.Count - 1);
            }
            if (bHadBeenChanged)
            {
                String[] tsColumnsSorted = new String[FirstColumns.Count + tsFlightCategories.Length];
                for (i = 0; i < FirstColumns.Count; i++)
                    tsColumnsSorted[i] = (String)FirstColumns[i];
                tsFlightCategories.CopyTo(tsColumnsSorted, FirstColumns.Count);
                //dtTable.PrimaryKey = null;
                OverallTools.DataFunctions.SortColumns(dtTable, tsColumnsSorted);

                if(sMotherTable == null)
                //if (OverallTools.FonctionUtiles.estPresentDansListe(sTableName, listeTable_FC))
                {
                    ArrayList alTableChanged = new ArrayList();
                    ConvertFiltersForFC(ntTable, sTableName, tsLastColumns, tsColumnsSorted);
                }
            }
            if (sTableName == GlobalNames.Transfer_FlightCategoryDitributionTableName)
            {
                ArrayList alFC = new ArrayList();
                alFC.InsertRange(0, tsFlightCategories);
                for (i = 0; i < dtTable.Rows.Count; i++)
                {
                    if (alFC.Contains(dtTable.Rows[i][0].ToString()))
                    {
                        alFC.Remove(dtTable.Rows[i][0].ToString());
                        continue;
                    }
                    dtTable.Rows.RemoveAt(i);
                    i--;
                }
                foreach (String sFC in alFC)
                {
                    DataRow drNewRow = dtTable.NewRow();
                    drNewRow[0] = sFC;
                    for (i = 1; i < dtTable.Columns.Count; i++)
                        drNewRow[i] = 0;
                    dtTable.Rows.Add(drNewRow);
                }
            }
            if (GlobalNames.NbTrolleyTableName == sTableName)
            {
                OverallTools.DataFunctions.UpdateTrolleyTable(gs.GetTable(GlobalNames.NbBagsTableName).Table, dtTable);
            }
            if (GlobalNames.Transfer_FlightCategoryDitributionTableName == sTableName)
            {
                OverallTools.DataFunctions.InitTranfertDistri(dtTable);
            }

            return true;
        }
        private void ConvertFiltersForFC(DataManagement.NormalTable ntParent, String sMotherTable, String[] tsLastColumns, String[] tsNewColumns)
        {
            ///On vérifie que le filtre que l'on souhaite ajouter implémente bien l'interface \ref IFilterTable
            if (ntParent == null)
                return;
            Type tType = ntParent.GetType();
            if (tType.GetInterface("IFilterTable") != null)
            {
                DataManagement.IFilterTable iftTable = (DataManagement.IFilterTable)ntParent;
                bool bConvertFilter = ConvertTables.ConvertFilter(iftTable.Definition, tsLastColumns, tsNewColumns);
                if ((iftTable.Definition.copyTable) && (bConvertFilter))
                {
                    //Il faut répercuter les changements sur la table copy.
                    ApplyFlightCategoriesChange(ntParent.Name, sMotherTable, tsNewColumns);
                }
            }
            if (ntParent.Filters == 0)
                return;
            foreach (String sFilters in ntParent.GetAllFilters())
            {
                DataManagement.NormalTable ntFilter = ntParent.GetFilter(sFilters);
                ConvertFiltersForFC(ntFilter, sMotherTable, tsLastColumns, tsNewColumns);
            }
        }

        


        private void Check_FC_Values()
        {
            DataTable tmp = getTable("Input", GlobalNames.FP_FlightCategoriesTableName);
            if (tmp == null)
            {
                return;
            }
            List<String> Tables = dmiInputData.getTablesForFlightCategoriesUpdate();
            foreach (String nomTable in Tables)
            {
                foreach (DataRow ligne in tmp.Rows)
                {
                    String CategorieDeVol = ligne.ItemArray[0].ToString();
                    DataTable dtTable = getTable("Input", nomTable);
                    if (dtTable == null)
                        continue;
                    foreach (DataRow ligneAModifiee in dtTable.Rows)
                    {
                        if (ligneAModifiee[CategorieDeVol].ToString() == "")
                        {
                            ligneAModifiee.BeginEdit();
                            ligneAModifiee[CategorieDeVol] = 0;
                        }
                    }
                    dtTable.AcceptChanges();
                }
            }
        }


        #endregion

        #region Fonctions qui se chargent de mettre à jour les tables à partir de la structure de l'aéroport

        /// <summary>
        /// Fonction qui met à jour les noms des colonnes des tables qui dépendent de la structure de 
        /// l'aéroport, à partir de l'arbre d'un treeview.
        /// </summary>
        /// <param name="Racine">Structure de l'aéroport dans le treeview</param>
        public void MAJ_TablesSuivantStructureAeroport(System.Windows.Forms.TreeNode Racine)
        {
            projet = new XmlDocument();
            structureAeroport.RemoveAll();
            structureAeroport = projet.CreateElement(PAX2SIM.sMainNodeName);
            construireArbreAeroport(Racine, structureAeroport);
            MAJ_TablesSuivantStructureAeroport(structureAeroport);
        }


        internal void UpdateTableWithAirportStructure(String sNomTable, DataManagerInput.LoadParameters lpParameters)
        {
            if (!lpParameters.bBHS)
            {
                MAJStructureTable(structureAeroport, sNomTable, lpParameters.iSAirport_TypeRecherche, lpParameters.bSAirport_AnalyseLigne, 0, lpParameters.bSAirport_AnalyseColonne, lpParameters);
            }
            else
            {
                int iTerminal = AnalyseTerminalName(sNomTable);
                if (iTerminal == 0)
                    return;
                if((lpParameters.iSAirport_TypeRecherche == -1) && (!lpParameters.bSAirport_AnalyseColonne) && (!lpParameters.bSAirport_AnalyseLigne))
                {
                    AnalyseAirportStructureForGeneralInformation(structureAeroport, iTerminal, sNomTable);
                }
                else
                {
                    MAJStructureTable(structureAeroport, iTerminal, sNomTable, lpParameters.iSAirport_TypeRecherche, lpParameters.bSAirport_AnalyseLigne, lpParameters.bSAirport_AnalyseColonne);
                }
            }
        }

        /// <summary>
        /// Fonction qui met à jour les noms des colonnes des tables qui dépendent de la structure de 
        /// l'aéroport à partir de l'arbre en XML.
        /// </summary>
        /// <param name="structure">Structure de l'aéroport en XML.</param>
        public void MAJ_TablesSuivantStructureAeroport(XmlNode structure)
        {
            if (!bAirportStructureHadBeenModified)
                return;
            dmiInputData.UpdateTablesFromAirportStructure();

            bAirportStructureHadBeenModified = false;

        }

        #region ============= Pour la partie PAX =============
        /// <summary>
        /// Fonction qui se charge de mettre à jour la structure des tables en fonction de la
        /// structure de l'aéroport et des paramètre de mise à jour.
        /// </summary>
        /// <param name="Aeroport">Structure de l'aéroport</param>
        /// <param name="nomTable">Nom de la table à mettre à jour.</param>
        /// <param name="TypeRecherche">Type de recherche à effectuer dans la structure (cf. MajTableFromTRV).</param>
        /// <param name="analyseLigne">Indique si l'on doit mettre à jour le contenu des lignes (cf. MajDesTables).</param>
        /// <param name="numColonne">Indique, dnas le cas de mise à jour des lignes, quelle colonne analyser (cf. MajDesTables).</param>
        /// <param name="analyseColonne">Indique si l'on doit mettre à jour le contenu des colonnes (cf. MajDesTables).</param>
        private void MAJStructureTable(XmlNode Aeroport, String nomTable, int TypeRecherche, bool analyseLigne, int numColonne, bool analyseColonne, DataManagement.DataManagerInput.LoadParameters lpParameters)
        {
            ArrayList ListeObj,ListObjectColumn=null;
            ListObjectColumn = MajTableFromTRV(Aeroport, "", "", TypeRecherche);
            if ((TypeRecherche == 37) || (TypeRecherche == 38))
            {
                ListeObj = MajTableFromTRV(Aeroport, "", "", 1);
            }
            else
            {
                ListeObj = ListObjectColumn;
            }
            MajDesTables(nomTable, ListeObj,ListObjectColumn, analyseLigne, numColonne, analyseColonne, TypeRecherche, lpParameters);
            /*SGE : 12/06/2012*/
            if ((lpParameters.oDefaultValue == null) && (TypeRecherche == 41) && (lpParameters.vmDefaultVisualisationMode!= null))
            {
                //We have to initialize the table with distribution.
                DataTable dtTable = getTable("Input", nomTable);
                if(OverallTools.DataFunctions.SumColumn(dtTable,dtTable.Columns[dtTable.Columns.Count-1].ColumnName) != 100)
                    OverallTools.FonctionUtiles.initialiserColumnAdded(dtTable, lpParameters.oDefaultColumn, lpParameters.vmDefaultVisualisationMode, dtTable.Columns.Count - 1);
                
            }
            /*End SGE : 12/06/2012*/
            OverallTools.DataFunctions.InitializeValues(getTable("Input", nomTable), lpParameters.oDefaultValue);
        }

        //Fonction pour mettre à jour les colonnes et les lignes des tables à 
        //partir d'une liste d'éléments devant être présent.
        /// <summary>
        /// Fonction pour mettre à jour les colonnes et les lignes des tables à
        /// partir d'une liste d'éléments devant être présent.
        /// </summary>
        /// <param name="NomTable">Le nom de la table à mettre à jour.</param>
        /// <param name="ListeObj">La liste des objets à ajouter.</param>
        /// <param name="AnalyseLigne">Indique si l'on doit ajouter les objets sur les lignes.</param>
        /// <param name="NumColonne">La colonne dans laquelle ajouter les objets pour les lignes.</param>
        /// <param name="AnalyseColonne">Indique si l'on doit ajouter les objets sur les colonnes.</param>
        private void MajDesTables(string NomTable, ArrayList ListeObj, ArrayList ListeObjColumns, bool AnalyseLigne, int NumColonne, bool AnalyseColonne, int iTypeRecherche, DataManagement.DataManagerInput.LoadParameters lpParameters)//bool CapaQueuesTable)
        {
            bool CapaQueuesTable = (iTypeRecherche == 9) || (iTypeRecherche == 30) || (iTypeRecherche == 31) || (iTypeRecherche == 32)
                || (iTypeRecherche == 99);   // << Task #7570 new Desk and extra information for Pax -Phase I B
            string NomColonne;
            string NomLigne;
            bool NomLgnTrv;
            bool NomColTrv;
            if ((iTypeRecherche == 35) || (iTypeRecherche == 36) || (iTypeRecherche == 39))
            {
                ListeObj.Insert(0, GlobalNames.sParkingColumnTotal);
            }
            ArrayList ListeASuppr = new ArrayList();
            DataTable tableAModifiee = getTable("Input", NomTable);
            if (tableAModifiee == null)
                return;

            ///*** RECHERCHE DES AJOUTS
            if (ListeObjColumns.Count > 0)
            {
                /// Si l'analyse des colonnes est demandée
                if (AnalyseColonne == true)
                {
                    /// Pour tous les objet de la liste
                    foreach (string NomObj in ListeObjColumns)
                    {
                        NomColTrv = false;
                        if (!tableAModifiee.Columns.Contains(NomObj))
                        {
                            if ((lpParameters != null) && (lpParameters.bAllowAddColumns))
                                tableAModifiee.Columns.Add(NomObj, lpParameters.tTypeNewColumns);
                            else if (OverallTools.FonctionUtiles.estPresentDansListe(NomTable, listeTable_AjoutDouble))
                            {
                                tableAModifiee.Columns.Add(NomObj, typeof(Double));
                            }
                            else if (OverallTools.FonctionUtiles.estPresentDansListe(NomTable, listeTable_AjoutBoolean))
                            {
                                tableAModifiee.Columns.Add(NomObj, typeof(Boolean));
                            }
                            else
                            {
                                tableAModifiee.Columns.Add(NomObj, typeof(String));
                            }
                        }
                    }
                }
            }
            if(ListeObj.Count>0){
                /// Si l'analyse des lignes est demandée
                if (AnalyseLigne == true)
                {
                    /// Pour tous les objets de la liste
                    foreach (string NomObj in ListeObj)
                    {
                        if (NomObj == GlobalNames.sParkingColumnTotal)
                            continue;
                        NomLgnTrv = false;
                        foreach (DataRow TheRow in tableAModifiee.Rows)
                        {
                            NomLigne = TheRow.ItemArray[NumColonne].ToString();
                            if ((NomLigne.ToUpper() == NomObj.ToUpper()) || 
                                    ((iTypeRecherche == 36) 
                                        && 
                                    ((NomLigne.ToUpper() == (GlobalNames.sParkingDistribRushTimeLine1Begin + NomObj + GlobalNames.sParkingDistribRushTimeLine1End).ToUpper())
                                        ||
                                    (NomLigne.ToUpper() == (GlobalNames.sParkingDistribRushTimeLine2Begin + NomObj + GlobalNames.sParkingDistribRushTimeLine2End).ToUpper())
                                    )))

                            {
                                NomLgnTrv = true;
                                break;
                            }
                        }
                        /// Si pas trouve alors ajout de la ligne
                        if (NomLgnTrv == false)
                        {
                            object[] ligne = new object[tableAModifiee.Columns.Count];
                            ligne[NumColonne] = NomObj;
                            if (iTypeRecherche == 36)
                            {
                                ligne[NumColonne] = GlobalNames.sParkingDistribRushTimeLine1Begin + NomObj + GlobalNames.sParkingDistribRushTimeLine1End;
                                tableAModifiee.Rows.Add(ligne);
                                ligne = new object[tableAModifiee.Columns.Count];
                                ligne[NumColonne] = GlobalNames.sParkingDistribRushTimeLine2Begin + NomObj + GlobalNames.sParkingDistribRushTimeLine2End;
                                
                            }
                            if (CapaQueuesTable)
                            {
                                //Here we set the capacity of the station to 1 and for the groups to -1
                                if ((iTypeRecherche == 9) || (iTypeRecherche == 31))
                                    ligne[1] = 1;
                                else
                                    ligne[1] = -1;
                            }
                            if (iTypeRecherche == 3)
                            {
                                //Cas ou l'on édite la table des process
                                ligne[1] = "Constant";
                                ligne[2] = 0;
                                ligne[3] = 0;
                                ligne[4] = 0;
                                int[] SelectedGroup = OverallTools.DataFunctions.AnalyzeGroupName(NomObj);
                                if ((SelectedGroup[2] == GestionDonneesHUB2SIM.BaggageClaimGroup) ||
                                    (SelectedGroup[2] == GestionDonneesHUB2SIM.CheckInGroup) ||
                                    (SelectedGroup[2] == GestionDonneesHUB2SIM.PassportCheckGroup))
                                {
                                    ligne[5] = "Constant";
                                    ligne[6] = 0;
                                    ligne[7] = 0;
                                    ligne[8] = 0;
                                }
                                // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                                int indexColumnReferenceTime = tableAModifiee.Columns.IndexOf(GlobalNames.sProcessTable_WaitingTimeReference);
                                int indexColumnWaitingTimeDistribution = tableAModifiee.Columns.IndexOf(GlobalNames.sProcessTable_Distrib_3);
                                int indexColumnParam1_3 = tableAModifiee.Columns.IndexOf(GlobalNames.sProcessTable_Param1_3);
                                int indexColumnParam2_3 = tableAModifiee.Columns.IndexOf(GlobalNames.sProcessTable_Param2_3);
                                int indexColumnParam3_3 = tableAModifiee.Columns.IndexOf(GlobalNames.sProcessTable_Param3_3);

                                if (indexColumnWaitingTimeDistribution != -1)
                                    ligne[indexColumnWaitingTimeDistribution] = "Constant";
                                if (indexColumnReferenceTime != -1)
                                    ligne[indexColumnReferenceTime] = "";
                                if (indexColumnParam1_3 != -1)
                                    ligne[indexColumnParam1_3] = 0;
                                if (indexColumnParam2_3 != -1)
                                    ligne[indexColumnParam2_3] = 0;
                                if (indexColumnParam3_3 != -1)
                                    ligne[indexColumnParam3_3] = 0;
                                // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)                            
                            }
                            // << Task #9484 Pax2Sim - Saturation parameters - initialization
                            if (iTypeRecherche == 40)
                            {
                                //Saturation Parameters table
                                int indexColumnApplySaturationRules = tableAModifiee.Columns.IndexOf(GlobalNames.sSaturation_ApplyRules);
                                int indexColumnFillingQueue = tableAModifiee.Columns.IndexOf(GlobalNames.sSaturation_Filling);
                                int indexColumnOpened = tableAModifiee.Columns.IndexOf(GlobalNames.sSaturation_Opened);
                                int indexColumnAccumulation = tableAModifiee.Columns.IndexOf(GlobalNames.sSaturation_Accumulation);
                                int indexColumnReactionTime = tableAModifiee.Columns.IndexOf(GlobalNames.sSaturation_ReactionTime);

                                if (indexColumnApplySaturationRules != -1
                                    && tableAModifiee.Columns[GlobalNames.sSaturation_ApplyRules].DataType == typeof(Boolean))
                                {
                                    ligne[indexColumnApplySaturationRules] = false;
                                }                                
                                if (indexColumnFillingQueue != -1
                                    && tableAModifiee.Columns[GlobalNames.sSaturation_Filling].DataType == typeof(String))
                                {
                                    ligne[indexColumnFillingQueue] = GlobalNames.FIRST_STATION_FILLING_TYPE;
                                }
                                if (indexColumnOpened != -1
                                    && tableAModifiee.Columns[GlobalNames.sSaturation_Opened].DataType == typeof(Int32))
                                {
                                    ligne[indexColumnOpened] = 0;
                                }
                                if (indexColumnAccumulation != -1
                                    && tableAModifiee.Columns[GlobalNames.sSaturation_Accumulation].DataType == typeof(Int32))
                                {
                                    ligne[indexColumnAccumulation] = 0;
                                }
                                if (indexColumnReactionTime != -1
                                    && tableAModifiee.Columns[GlobalNames.sSaturation_ReactionTime].DataType == typeof(Int32))
                                {
                                    ligne[indexColumnReactionTime] = 0;
                                }
                            }
                            // >> Task #9484 Pax2Sim - Saturation parameters - initialization
                            tableAModifiee.Rows.Add(ligne);
                        }
                    }
                }
            }
            ///*** RECHERCHE DES SUPPRESSIONS
            /// Si l'analyse des lignes est demandée
            if (AnalyseLigne == true)
            {
                ListeASuppr.Clear();
                foreach (DataRow TheRow in tableAModifiee.Rows)
                {
                    NomLgnTrv = false;
                    NomLigne = TheRow.ItemArray[NumColonne].ToString();
                    foreach (string NomObj in ListeObj)
                    {
                        if ((NomLigne.ToUpper() == NomObj.ToUpper()) ||
                            ((iTypeRecherche == 36) && (
                                (NomLigne.ToUpper() == (GlobalNames.sParkingDistribRushTimeLine1Begin + NomObj + GlobalNames.sParkingDistribRushTimeLine1End).ToUpper())
                                    ||
                                (NomLigne.ToUpper() == (GlobalNames.sParkingDistribRushTimeLine2Begin + NomObj + GlobalNames.sParkingDistribRushTimeLine2End).ToUpper())
                                )))
                        {
                            NomLgnTrv = true;
                            break;
                        }
                    }
                    /// SI NomLgnTrv non trouvé alors marquage pour suppression
                    if (NomLgnTrv == false)
                    {
                        ListeASuppr.Add(TheRow);
                    }

                }
                /// Si des lignes sont a supprimer
                if (ListeASuppr.Count > 0)
                {
                    foreach (DataRow OldRow in ListeASuppr)
                    {
                        tableAModifiee.Rows.Remove(OldRow);
                    }
                }
            }
            /// Si l'analyse des colonnes est demandée
            if (AnalyseColonne == true)
            {
                ListeASuppr.Clear();
                foreach (DataColumn TheCol in tableAModifiee.Columns)
                {
                    NomColTrv = false;
                    NomColonne = TheCol.ColumnName.ToString();
                    /// Exclusion des colonnes qui portent un nom normal ("FromTo" ...)
                    if ((NomColonne != ListeEnteteDiv[4])
                        && (NomColonne != ListeEnteteDiv[5])
                        && (NomColonne != ListeEnteteDiv[6])
                        && (NomColonne != ListeEnteteDiv[7])
                        && (NomColonne != ListeEnteteDiv[8])
                        && (NomColonne != ListeEnteteDiv[10])
                        && (NomColonne != ListeEnteteDiv[12])
                        && (NomColonne != ListeEnteteDiv[0])
                        && (NomColonne != GlobalNames.sColumnFrom)) // >> Task #15867 Transfer Distribution Tables/Charts improvement
                    {
                        foreach (string NomObj in ListeObjColumns)
                        {
                            if (NomColonne.ToUpper() == NomObj.ToUpper())
                            {
                                NomColTrv = true;
                                break;
                            }
                        }
                        /// SI NomColonne non trouvé alors marquage pour suppression
                        if (NomColTrv == false)
                        {
                            ListeASuppr.Add(NomColonne);
                        }
                    }
                }
                /// Si des lignes sont a supprimer
                if (ListeASuppr.Count > 0)
                {
                    foreach (string VS_Temp in ListeASuppr)
                    {
                        tableAModifiee.Columns.Remove(VS_Temp);
                    }
                }
            }
            if((iTypeRecherche == 39) &&(AnalyseColonne))
                OverallTools.DataFunctions.SortColumns(tableAModifiee, 3);
            else if(((iTypeRecherche == 35) ||(iTypeRecherche == 36) )&&(AnalyseColonne))
                OverallTools.DataFunctions.SortColumns(tableAModifiee, 2);
            else if (AnalyseColonne)
                OverallTools.DataFunctions.SortColumns(tableAModifiee, 1);
        }

        private static ArrayList MajTableFromTRV(XmlNode RacineAAnaliser, string NomTerminal, string NomLevel, int TypeRecherche)
        {
            return MajTableFromTRV(RacineAAnaliser, NomTerminal, NomLevel, TypeRecherche, false);
        }

        /// <summary>
        /// Met à jour les tables ListeNomTableTRV en fonction du treeview
        /// TypeRecherche = 1 : T                   ==> Shuttle
        /// TypeRecherche = 2 : TL, TL_group        ==> FromToTable
        /// TypeRecherche = 3 : TL_group            ==> ProcessTable
        /// TypeRecherche = 4 : TL_groupCI_CI   
        /// TypeRecherche = 5 : TL_groupBG_BG 
        /// TypeRecherche = 6 : TL_groupRC_RC 
        /// TypeRecherche = 7 : TL_groupPC_PC ListeNomObjet[3] /!\Group
        /// TypeRecherche = 8 : TL_groupTD_TD ListeNomObjet[7] /!\ Group
        /// TypeRecherche = 9 : capaqueues ==> Ne pas mettre les groupes ni les bureaux Gate, Shuttle, Baggage Claim
        /// TypeRecherche = 10: TL_groupSC_SC ListeNomObjet[4]/!\Group
        /// TypeRecherche = 30 : GroupQueues ==> Ne pas mettre les groupes ni les bureaux Gate, Shuttle, Baggage Claim
        /// TypeRecherche = 35 : Noms des terminaux au format "Tx(Description)"
        /// TypeRecherche = 36 : Noms des lignes pour la répartition des pointes entre les terminaux. (Même comportement que 35)
        /// TypeRecherche = 37 : Noms des points d'entrées Pax In. 
        /// TypeRecherche = 38 : Noms des points de sortie Pax Out.
        /// TypeRecherche = 39 : Noms des terminaux pour la table Parking Occupation (Même fonctionnement que 35/36).
        /// TypeRecherche = 40 : Noms des groupes de Passport / Security et Transfert pour la table Saturation Opening. (7,8 et 10)
        /// TypeRechecher = 41 : Noms des objets Pax In contenant le mot clef Parking.
        /// </summary>
        /// <param name="RacineAAnaliser">Racine de la structure de l'aéroport</param>
        /// <param name="NomTerminal">Nom du terminal (Pour le fonctionnement récursif)</param>
        /// <param name="NomLevel">Nom du Level(Niveau) (Pour le fonctionnement récursif)</param>
        /// <param name="TypeRecherche">Type de recherche que l'on souhaite effectuer.</param>
        /// <returns>Renvoie une liste des éléments qui correspondent au type de recherche
        /// dans la structure de l'aéroport.</returns>
        private static ArrayList MajTableFromTRV(XmlNode RacineAAnaliser, string NomTerminal, string NomLevel, int TypeRecherche, bool bDescription)
        {
            ArrayList listeColonnes = new ArrayList();

            //On parcours les noeuds enfants de la racine.
            foreach (XmlNode enfant in RacineAAnaliser.ChildNodes)
            {
                //S'il s'agit d'un noeud de type    --  Terminal  --
                if (enfant.Attributes["Type"].Value == PAX2SIM.ListeNomObjet[0])
                {
                    //On initialise la variable NomTerminal à Tindex où index est le numéro du terminal analysé.
                    NomTerminal = "T" + enfant.Attributes["Index"].Value;
                    //Si la recherche que nous effectuons veut les terminaux, on ajoute le nom à la liste.
                    if (TypeRecherche == 1)
                    {
                        if (!bDescription)
                        {
                            listeColonnes.Add(NomTerminal);
                        }
                        else
                        {
                            if (OverallTools.FonctionUtiles.hasNamedAttribute(enfant, "Name"))
                                listeColonnes.Add(enfant.Attributes["Name"].Value);
                        }
                    }
                    if ((TypeRecherche == 35) || (TypeRecherche == 36) || (TypeRecherche == 39))
                    {
                        if (OverallTools.FonctionUtiles.hasNamedAttribute(enfant, "Name"))
                            listeColonnes.Add(NomTerminal + " (" +enfant.Attributes["Name"].Value+")");
                    }
                }
                //S'il s'agit d'un noeud de type    --  Level  --
                else if (enfant.Attributes["Type"].Value == PAX2SIM.ListeNomObjet[1])
                {
                    //On initialise la variable NomLevel à Lindex où index est le numéro du Level analysé.
                    NomLevel = "L" + enfant.Attributes["Index"].Value;
                    //Si la recherche que nous effectuons veut les levels, on ajoute le nom à la liste.
                    if (TypeRecherche == 2)
                    {
                        if (!bDescription)
                        {
                            listeColonnes.Add(NomTerminal + NomLevel);
                        }
                        else
                        {
                            if (OverallTools.FonctionUtiles.hasNamedAttribute(enfant, "Name"))
                                listeColonnes.Add(enfant.Attributes["Name"].Value);
                        }
                    }
                }
                //S'il s'agit d'un noeud de type    --  Group  --
                else if (OverallTools.FonctionUtiles.estPresentDansListe(enfant.Attributes["Type"].Value, PAX2SIM.ListeNomObjetGroup))
                {
                    //Suivant le type de recherche, on ajoute dans la liste des objets les noms des groupes.
                    if (((TypeRecherche == 2) || (TypeRecherche == 3)) ||
                        (((TypeRecherche == 7) || (TypeRecherche == 40)) && (enfant.Attributes["Type"].Value == PAX2SIM.ListeNomObjetGroup[3])) ||
                        (((TypeRecherche == 10) || (TypeRecherche == 40)) && (enfant.Attributes["Type"].Value == PAX2SIM.ListeNomObjetGroup[4])) ||
                        (((TypeRecherche == 8) || (TypeRecherche == 40)) && (enfant.Attributes["Type"].Value == PAX2SIM.ListeNomObjetGroup[7]))||
                        ((TypeRecherche == 37) && (enfant.Attributes["Type"].Value == PAX2SIM.sModelInGroup)) ||
                        ((TypeRecherche == 38) && (enfant.Attributes["Type"].Value == PAX2SIM.sModelOutGroup))||
                        ((TypeRecherche == 41) && (/*(enfant.Attributes["Type"].Value == PAX2SIM.sModelOutGroup) ||*/ (enfant.Attributes["Type"].Value == PAX2SIM.sModelInGroup)) && (enfant.Attributes["Name"].Value.ToLower().Contains("parking")))
                         || ((TypeRecherche == 99 || TypeRecherche == 40) && (enfant.Attributes["Type"].Value == PAX2SIM.ListeNomObjetGroup[8])) // << Task #7570 new Desk and extra information for Pax -Phase I B
                        )
                    {
                        if (!bDescription)
                        {
                            String sTmp = NomTerminal + NomLevel + "_" + enfant.Attributes["Type"].Value + " " + enfant.Attributes["Index"].Value;

                            if ((TypeRecherche == 37) || (TypeRecherche == 38) || (TypeRecherche == 41))
                            {
                                if (OverallTools.FonctionUtiles.hasNamedAttribute(enfant, "Name"))
                                    sTmp += " ("+enfant.Attributes["Name"].Value+")";
                            }
                            listeColonnes.Add(sTmp);
                        }
                        else
                        {
                            if (OverallTools.FonctionUtiles.hasNamedAttribute(enfant, "Name"))
                                listeColonnes.Add(enfant.Attributes["Name"].Value);
                        }
                    }
                    if ((TypeRecherche == 30) && ((enfant.Attributes["Type"].Value == PAX2SIM.ListeNomObjetGroup[2]) ||
                                                  (enfant.Attributes["Type"].Value == PAX2SIM.ListeNomObjetGroup[3]) ||
                                                  (enfant.Attributes["Type"].Value == PAX2SIM.ListeNomObjetGroup[4]) ||
                                                  (enfant.Attributes["Type"].Value == PAX2SIM.ListeNomObjetGroup[7]) ||
                                                  (enfant.Attributes["Type"].Value == PAX2SIM.ListeNomObjetGroup[9])
                                               || (enfant.Attributes["Type"].Value == PAX2SIM.ListeNomObjetGroup[8]) ) )   // << Task #7570 new Desk and extra information for Pax -Phase I B
                    {
                        listeColonnes.Add(NomTerminal + NomLevel + "_" + enfant.Attributes["Type"].Value + " " + enfant.Attributes["Index"].Value);

                    }
                }
                //S'il s'agit d'un noeud de type    --  Objet  --
                else
                {
                    //Suivant le type de recherche, on ajoute dans la liste des objets les noms des objets.
                    if (((TypeRecherche == 4) && (enfant.Attributes["Type"].Value == PAX2SIM.ListeNomObjet[2])) ||
                        ((TypeRecherche == 5) && (enfant.Attributes["Type"].Value == PAX2SIM.ListeNomObjet[9])) ||
                        ((TypeRecherche == 6) && (enfant.Attributes["Type"].Value == PAX2SIM.ListeNomObjet[6])) ||
                        ((TypeRecherche == 9) 
                                && (   (enfant.Attributes["Type"].Value == PAX2SIM.ListeNomObjet[2]) 
                                    || (enfant.Attributes["Type"].Value == PAX2SIM.ListeNomObjet[3]) 
                                    || (enfant.Attributes["Type"].Value == PAX2SIM.ListeNomObjet[4]) 
                                    || (enfant.Attributes["Type"].Value == PAX2SIM.ListeNomObjet[7]) 
                                    || (enfant.Attributes["Type"].Value == PAX2SIM.ListeNomObjet[9]) 
                                    || (enfant.Attributes["Type"].Value == PAX2SIM.ListeNomObjet[8]))) // << Task #7570 new Desk and extra information for Pax -Phase I B
                        || ((TypeRecherche == 12) 
                                && (   (enfant.Attributes["Type"].Value == PAX2SIM.ListeNomObjet[5]) 
                                    || (enfant.Attributes["Type"].Value == PAX2SIM.ListeNomObjet[9])))                        
                        )
                    {
                        if (!bDescription)
                        {
                            listeColonnes.Add(NomTerminal + NomLevel + "_" + enfant.Attributes["Type"].Value + " " + enfant.Attributes["Index"].Value);
                        }
                        else
                        {
                            if (OverallTools.FonctionUtiles.hasNamedAttribute(enfant, "Name"))
                                listeColonnes.Add(enfant.Attributes["Name"].Value);
                        }
                    }
                    if ((TypeRecherche == 16) && (enfant.Attributes["Type"].Value == GlobalNames.sBHS_MakeUpObject))
                        listeColonnes.Add(enfant.Attributes["Type"].Value + " " + enfant.Attributes["Index"].Value);

                    if ((TypeRecherche == 18) && (enfant.Attributes["Type"].Value == "Aircraft Parking Stand"))
                    {
                        if (!bDescription)
                        {
                            listeColonnes.Add(NomTerminal + "_Parking_" + enfant.Attributes["Index"].Value);

                        }
                        else
                        {
                            if (OverallTools.FonctionUtiles.hasNamedAttribute(enfant, "Name"))
                                listeColonnes.Add(enfant.Attributes["Name"].Value);
                        }
                    }
                }
                if ((TypeRecherche != 35) && (TypeRecherche != 36) && (TypeRecherche != 39))
                {
                    //Si le noeud analysé possède des enfants, alors on lance la recherche dessus.
                    //On ajoute alors la liste obtenue à la liste courante des objets.
                    if (enfant.ChildNodes.Count != 0)
                        listeColonnes.AddRange(MajTableFromTRV(enfant, NomTerminal, NomLevel, TypeRecherche, bDescription));
                }
            }
            return listeColonnes;
        }


        #endregion

        #region ============= Pour la partie BHS =============

        public static int AnalyseTerminalName(String TableName)
        {
            if (!TableName.StartsWith(GlobalNames.sBHS_PrefixeLong))
                return 0;
            int iIndex = GlobalNames.sBHS_PrefixeLong.Length;
            String sIndex = OverallTools.FonctionUtiles.nextInt(TableName, ref iIndex);
            if (!Int32.TryParse(sIndex, out iIndex))
            {
                return 0;
            }
            return iIndex;
        }

        private void MajDesTablesStr(string NomTable, ArrayList ListeObj)
        {
            DataTable tableAModifiee = getTable("Input", NomTable);
            if (tableAModifiee == null)
                return;
            if ((ListeObj == null) || (ListeObj.Count == 0) || (ListeObj[0].GetType() != typeof(Int32[])))
            {
                tableAModifiee.Rows.Clear();
                return;
            }
            int iNbInformation = ((Int32[])ListeObj[0]).Length;
            if (tableAModifiee.Columns[0].DataType != typeof(String))
                return;
            int i;
            String[] keys = new String[ListeObj.Count];
            int j;
            for (i = 0; i < ListeObj.Count; i++)
            {
                keys[i] = "L" + ((int[])ListeObj[i])[0].ToString();
                for (j = 1; j < iNbInformation; j++)
                    keys[i] += "_" + ((int[])ListeObj[i])[j].ToString();
            }

            bool[] bRowPresent = new bool[tableAModifiee.Rows.Count];
            for (i = 0; i < tableAModifiee.Rows.Count; i++)
            {
                bRowPresent[i] = false;
            }
            int[] RowPresent = new int[iNbInformation];
            for (i = 0; i < tableAModifiee.Rows.Count; i++)
            {
                for (j = 0; j < keys.Length; j++)
                {
                    if (keys[j] == tableAModifiee.Rows[i][0].ToString())
                    {
                        bRowPresent[i] = true;
                        keys[j] = "";
                        break;
                    }
                }
            }
            int iNbSupprimes = 0;
            for (i = 0; i < tableAModifiee.Rows.Count; i++)
            {
                if (!bRowPresent[i])
                {
                    tableAModifiee.Rows.RemoveAt(i - iNbSupprimes);
                    iNbSupprimes++;
                }
            }
            foreach (String Value in keys)
            {
                if (Value != "")
                {
                    DataRow newRow = tableAModifiee.NewRow();
                    newRow[0] = Value;
                    for (j = 1; j < tableAModifiee.Columns.Count; j++)
                        newRow[j] = 0;
                    tableAModifiee.Rows.Add(newRow);
                }
            }
        }
        private void MajDesTables(string NomTable, ArrayList ListeObj)
        {
            DataTable tableAModifiee = getTable("Input", NomTable);
            if (tableAModifiee == null)
                return;
            if ((ListeObj == null) || (ListeObj.Count == 0) || (ListeObj[0].GetType() != typeof(Int32[])))
            {
                tableAModifiee.Rows.Clear();
                return;
            }
            int iNbInformation = ((Int32[])ListeObj[0]).Length;
            if (iNbInformation > tableAModifiee.Columns.Count)
                return;
            int i;
            for (i = 0; i < iNbInformation; i++)
            {
                if ((tableAModifiee.Columns[i].DataType != typeof(int)) &&
                    (tableAModifiee.Columns[i].DataType != typeof(Int32)) &&
                    (tableAModifiee.Columns[i].DataType != typeof(Int16)) &&
                    (tableAModifiee.Columns[i].DataType != typeof(Int64)))
                {
                    return;
                }
            }
            bool[] bRowPresent = new bool[tableAModifiee.Rows.Count];
            for (i = 0; i < tableAModifiee.Rows.Count; i++)
            {
                bRowPresent[i] = false;
            }
            int[] RowPresent = new int[iNbInformation];
            int j;
            for (i = 0; i < tableAModifiee.Rows.Count; i++)
            {
                for (j = 0; j < iNbInformation; j++)
                {
                    RowPresent[j] = (int)tableAModifiee.Rows[i][j];
                }
                for (int k = 0; k < ListeObj.Count; k++)
                {
                    for (j = 0; j < iNbInformation; j++)
                    {
                        if (RowPresent[j] != ((int[])ListeObj[k])[j])
                            break;
                    }
                    if (j == iNbInformation)
                    {
                        ListeObj.RemoveAt(k);
                        bRowPresent[i] = true;
                        break;
                    }
                }
            }
            int iNbSupprimes = 0;
            for (i = 0; i < tableAModifiee.Rows.Count; i++)
            {
                if (!bRowPresent[i])
                {
                    tableAModifiee.Rows.RemoveAt(i - iNbSupprimes);
                    iNbSupprimes++;
                }
            }
            foreach (int[] Value in ListeObj)
            {
                DataRow newRow = tableAModifiee.NewRow();
                for (j = 0; j < iNbInformation; j++)
                    newRow[j] = Value[j];
                for (; j < tableAModifiee.Columns.Count; j++)
                    newRow[j] = 0;
                tableAModifiee.Rows.Add(newRow);
            }
        }


        private ArrayList MajTableFromTRV(XmlNode RacineAAnaliser, int iTerminalAnalyzed, int iLevel, int TypeRecherche, int iDeep)
        {

            ArrayList alResult = new ArrayList();
            int iTerminal;
            //On parcours les noeuds enfants de la racine.
            foreach (XmlNode enfant in RacineAAnaliser.ChildNodes)
            {
                //S'il s'agit d'un noeud de type    --  Terminal  --
                if (enfant.Attributes["Type"].Value == PAX2SIM.sTerminalName)
                {
                    if (!Int32.TryParse(enfant.Attributes["Index"].Value, out iTerminal))
                        return null;
                    if ((TypeRecherche != 27) && (TypeRecherche != 28) && (TypeRecherche != 31) && (TypeRecherche != 32))
                    {
                        if (iTerminalAnalyzed != iTerminal)
                            continue;
                    }
                    else
                    {
                        iTerminalAnalyzed = iTerminal;
                    }
                }
                //S'il s'agit d'un noeud de type    --  Level  --
                else if ((iDeep == 1) && ((TypeRecherche == 27) || (TypeRecherche == 28)))
                {

                    if (enfant.Attributes["Type"].Value == PAX2SIM.sLevelName)
                    {
                        if (!Int32.TryParse(enfant.Attributes["Index"].Value, out iLevel))
                            return null;
                    }
                }
                else if (iDeep == 2) // Niveau des groupes
                {
                    bool bQueues = (TypeRecherche == 31) || (TypeRecherche == 32);
                    if (((enfant.Attributes["Type"].Value == PAX2SIM.sCheckInGroup) && (!bQueues)) ||
                        ((enfant.Attributes["Type"].Value == BHS_String_TransferInfeedGroup) && (!bQueues)) ||
                        ((enfant.Attributes["Type"].Value == BHS_String_ArrivalInfeedGroup) && (!bQueues)) ||
                        ((enfant.Attributes["Type"].Value == "Baggage Claim Group") && (!bQueues)) ||
                        (enfant.Attributes["Type"].Value == "HBS Lev1 Group") ||
                        (enfant.Attributes["Type"].Value == "HBS Lev3 Group") ||
                        (enfant.Attributes["Type"].Value == "HBS Lev5 Group") ||
                        (enfant.Attributes["Type"].Value == "MES Group") ||
                        (enfant.Attributes["Type"].Value == "EBS Group") ||
                        (enfant.Attributes["Type"].Value == "Make-Up Group"))
                    {
                        if (TypeRecherche == 25)
                            alResult.Add(enfant.Attributes["Type"].Value + " " + enfant.Attributes["Index"].Value);
                        else if (TypeRecherche == 26)
                            alResult.Add(enfant.Attributes["Name"].Value);
                        else if ((TypeRecherche == 27) || (TypeRecherche == 31) || (TypeRecherche == 32))
                        {
                            String sData = "";
                            if (iTerminalAnalyzed > 0)
                                sData += "T" + iTerminalAnalyzed.ToString();
                            if (iLevel > 0)
                                sData += "L" + iLevel.ToString();
                            if (sData.Length > 0)
                                sData += "_";
                            sData += enfant.Attributes["Type"].Value + " " + enfant.Attributes["Index"].Value;
                            alResult.Add(sData);
                        }
                        else if (TypeRecherche == 28)
                            alResult.Add(enfant.Attributes["Name"].Value);
                    }
                }
                if ((iDeep == 0) || (iDeep == 1))
                {
                    //Si le noeud analysé possède des enfants, alors on lance la recherche dessus.
                    //On ajoute alors la liste obtenue à la liste courante des objets.
                    if (enfant.ChildNodes.Count != 0)
                        alResult.AddRange(MajTableFromTRV(enfant, iTerminalAnalyzed, iLevel, TypeRecherche, iDeep + 1));
                }
            }
            return alResult;
        }
        /// <summary>
        /// Fonction qui se charge de parcourir la structure de l'aéroport et qui renvoie les informations 
        /// demandées par l'utilisateur
        /// </summary>
        /// <param name="RacineAAnaliser">La racine de l'arbre de l'aéroport.</param>
        /// <param name="iTerminalAnalyzed">Le terminal analysé.</param>
        /// <param name="TypeRecherche">Le type de recherche fait.
        /// 13 : Check In Group
        /// 14 : Transfer Infeed
        /// 15 : Check In Collector
        /// 16 : Make-Up
        /// 17 : Check In Group + index First et index Last Check In
        /// 19 : Check In Group + Transfer Infeed Group + Arrival Infeed Group
        /// 20 : Arrival Infeed Group
        /// 21 : Check In Group
        /// 22 : Transfer Infeed Group
        /// 23 :  Arrival Infeed Group + index First et index Last 
        /// 24 :  transfer Infeed Group + index First et index Last 
        /// 25 : Tous les groupes utiles de l'aéroport pour l'itinerary.
        /// 26 : Listing des descriptions des postes utiles pour l'itinerary BHS
        /// 27 : Toues les groupes utiles de l'aroport pour l'itinerary BHS
        /// 28 : Listing des descriptions des postes utiles pour l'itinerary BHS
        /// 31 : BHS_CapaQueues
        /// 32 : BHS_Group_Queues
        /// 34 : HBS3_Routing
        /// </param>
        /// <returns>Retourne une liste contenant des tableaux d'entiers avec les objets recherchés.</returns>
        private ArrayList MajTableFromTRV(XmlNode RacineAAnaliser, int iTerminalAnalyzed, int TypeRecherche)
        {
            ArrayList alResult = new ArrayList();
            int iTerminal;
            //On parcours les noeuds enfants de la racine.
            foreach (XmlNode enfant in RacineAAnaliser.ChildNodes)
            {
                //S'il s'agit d'un noeud de type    --  Terminal  --
                if (enfant.Attributes["Type"].Value == PAX2SIM.sTerminalName)
                {
                    if (!Int32.TryParse(enfant.Attributes["Index"].Value, out iTerminal))
                        return null;
                    if (iTerminalAnalyzed != iTerminal)
                        continue;
                }
                //S'il s'agit d'un noeud de type    --  Level  --
                else if (enfant.Attributes["Type"].Value == PAX2SIM.sLevelName)
                {
                    if ((TypeRecherche != 13) && (TypeRecherche != 17)
                        && (TypeRecherche != 19) && (TypeRecherche != 21)
                        && (TypeRecherche != 25))
                        continue;
                }
                else if ((enfant.Attributes["Type"].Value != PAX2SIM.sBHSName) &&
                       ((TypeRecherche == 19) || (TypeRecherche == 20)
                            || (TypeRecherche == 21) || (TypeRecherche == 22)
                            || (TypeRecherche == 23) || (TypeRecherche == 24) || (TypeRecherche == 25)
                        )
                        )
                {
                    if ((enfant.Attributes["Type"].Value != PAX2SIM.sCheckInGroup) &&
                        (enfant.Attributes["Type"].Value != BHS_String_TransferInfeedGroup) &&
                        (enfant.Attributes["Type"].Value != BHS_String_ArrivalInfeedGroup))
                        continue;
                    if ((enfant.Attributes["Type"].Value == PAX2SIM.sCheckInGroup) && (TypeRecherche != 19) &&
                        (TypeRecherche != 21))
                        continue;
                    if ((enfant.Attributes["Type"].Value == BHS_String_TransferInfeedGroup) && (TypeRecherche != 19) &&
                        (TypeRecherche != 22) && (TypeRecherche != 24))
                        continue;
                    if ((enfant.Attributes["Type"].Value == BHS_String_ArrivalInfeedGroup) && (TypeRecherche != 19) &&
                        (TypeRecherche != 20) && (TypeRecherche != 23))
                        continue;
                    int iIndex;
                    if ((TypeRecherche == 24) || (TypeRecherche == 23))
                    {
                        if (!Int32.TryParse(enfant.Attributes["Index"].Value, out iIndex))
                            return null;
                        int iFirst = 0;
                        int iLast = 0;
                        int itmp;
                        foreach (XmlNode xnChild in enfant.ChildNodes)
                        {
                            if (!Int32.TryParse(xnChild.Attributes["Index"].Value, out itmp))
                                return null;
                            if ((itmp < iFirst) || iFirst == 0)
                            {
                                iFirst = itmp;
                                if (iLast == 0)
                                    iLast = iFirst;
                            }
                            if (itmp > iFirst)
                                iLast = itmp;
                        }
                        alResult.Add(new int[] { iIndex, iFirst, iLast });
                        continue;
                    }
                    if (!Int32.TryParse(enfant.Attributes["Index"].Value, out iIndex))
                        return null;
                    alResult.Add(enfant.Attributes["Type"].Value + " " + iIndex.ToString());
                    continue;
                }
                else if ((TypeRecherche == 13) || (TypeRecherche == 17))
                {
                    if ((enfant.Attributes["Type"].Value != PAX2SIM.sCheckInGroup))
                        continue;
                    int iIndex;
                    if (!Int32.TryParse(enfant.Attributes["Index"].Value, out iIndex))
                        return null;
                    if (TypeRecherche == 13)
                    {
                        alResult.Add(new int[] { iIndex });
                        continue;
                    }

                    if (enfant.ChildNodes.Count == 0)
                        continue;
                    int iFirst = getIndexFirstDesk(iTerminalAnalyzed, /*iLevel,*/ CheckInGroup, iIndex);
                    int iLast = getIndexLastDesk(iTerminalAnalyzed, /*iLevel,*/ CheckInGroup, iIndex);
                    alResult.Add(new int[] { iIndex, iFirst, iLast });
                }
                else
                {
                    if (((TypeRecherche == 14) && (enfant.Attributes["Type"].Value == "Transfer Infeed")) ||
                        ((TypeRecherche == 15) && (enfant.Attributes["Type"].Value == "Check In Collector")) ||
                        ((TypeRecherche == 34) && (enfant.Attributes["Type"].Value == "HBS Lev3")))// Group"))) // >> Bug #13558 Lyon BHS project
                    {
                        int iIndex;
                        if (!Int32.TryParse(enfant.Attributes["Index"].Value, out iIndex))
                            return null;
                        alResult.Add(new int[] { iIndex });
                        continue;
                    }
                    else if ((TypeRecherche == 16) && (enfant.Attributes["Type"].Value == GlobalNames.sBHS_MakeUpObject))
                    {
                        alResult.Add(enfant.Attributes["Type"].Value + " " + enfant.Attributes["Index"].Value);
                    }
                }

                //Si le noeud analysé possède des enfants, alors on lance la recherche dessus.
                //On ajoute alors la liste obtenue à la liste courante des objets.
                if (enfant.ChildNodes.Count != 0)
                    alResult.AddRange(MajTableFromTRV(enfant, iTerminalAnalyzed, TypeRecherche));
            }
            return alResult;
        }
        private void MAJStructureTable(XmlNode Aeroport, int iTerminal, String nomTable, int TypeRecherche, bool analyseLigne, bool analyseColonne)
        {
            ArrayList ListeObj;
            if (iTerminal > 0)
            {
                ListeObj = MajTableFromTRV(Aeroport, iTerminal, TypeRecherche);
            }
            else
            {
                ListeObj = MajTableFromTRV(Aeroport, -1, 0, TypeRecherche, 0);
            }
            if ((TypeRecherche == 31) || (TypeRecherche == 32))
            {
                MajDesTables(nomTable, ListeObj, ListeObj, analyseLigne, 0, analyseColonne, TypeRecherche, null);
            }
            else if (analyseColonne)
            {
                MajDesTables(nomTable, ListeObj, ListeObj, analyseLigne, 0, analyseColonne, 0, null);
            }
            else if ((TypeRecherche == 15) || (TypeRecherche == 14) || (TypeRecherche == 13) || (TypeRecherche == 34))
            {
                MajDesTables(nomTable, ListeObj);
            }
            else if ((TypeRecherche == 17) || (TypeRecherche == 23) || (TypeRecherche == 24))
            {
                MajDesTablesStructureGroup(nomTable, ListeObj);
            }
            else
            {
                MajDesTablesStr(nomTable, ListeObj);
            }
            OverallTools.DataFunctions.InitializeValues(getTable("Input", nomTable));
        }

        private void MajDesTablesStructureGroup(string NomTable, ArrayList ListeObj)
        {
            DataTable tableAModifiee = getTable("Input", NomTable);
            if (tableAModifiee == null)
                return;
            tableAModifiee.Rows.Clear();
            if ((ListeObj == null) || (ListeObj.Count == 0) || (ListeObj[0].GetType() != typeof(Int32[])))
                return;
            int iNbInformation = ((Int32[])ListeObj[0]).Length;
            if (tableAModifiee.Columns[0].DataType != typeof(Int32))
                return;
            if (iNbInformation != 3)
                return;
            int i;
            for (i = 0; i < ListeObj.Count; i++)
            {
                DataRow newLine = tableAModifiee.NewRow();
                newLine[0] = ((int[])ListeObj[i])[0];
                newLine[1] = ((int[])ListeObj[i])[1];
                newLine[2] = ((int[])ListeObj[i])[2];
                tableAModifiee.Rows.Add(newLine);
            }
            tableAModifiee.AcceptChanges();
        }

        private void AnalyseAirportStructureForGeneralInformation(XmlNode RacineAAnaliser, int iTerminalAnalyzed, String TableName)
        {
            /*Ici, il faut ajouter le comptage des MES et modifier l'ordre des différentes colonnes.*/
            DataTable latable = getTable("Input", TableName);
            if (latable == null)
                return;
            int iNbArrivalInfeed = 0;
            int iNbCI = 0;
            int iNbTransferInfeed = 0;
            int iNbLev1 = 0;
            int iNbLev3 = 0;
            int iNbMEStation = 0;
            int iNbMakeUpPosition = 0;
            int iNbCollectors = 0;

            int iLastArrivalInfeed = 0;
            int iLastCI = 0;
            int iLastTransferInfeed = 0;
            int iLastLev1 = 0;
            int iLastLev3 = 0;
            int iLastMEStation = 0;
            int iLastMakeUpPosition = 0;
            int iLastCollectors = 0;
            XmlNode xnTerminal = null;
            int iTerminal;
            //On parcours les noeuds enfants de la racine.
            foreach (XmlNode enfant in RacineAAnaliser.ChildNodes)
            {
                //S'il s'agit d'un noeud de type    --  Terminal  --
                if (enfant.Attributes["Type"].Value == PAX2SIM.sTerminalName)
                {
                    if (!Int32.TryParse(enfant.Attributes["Index"].Value, out iTerminal))
                        return;
                    if (iTerminalAnalyzed != iTerminal)
                        continue;
                    xnTerminal = enfant;
                    break;
                }
            }
            if (xnTerminal == null)
                return;
            foreach (XmlNode enfant in xnTerminal.ChildNodes)
            {
                //S'il s'agit d'un noeud de type    --  Level  --
                if (enfant.Attributes["Type"].Value == PAX2SIM.sLevelName)
                {
                    foreach (XmlNode Group in enfant.ChildNodes)
                    {
                        if (Group.Attributes["Type"].Value == PAX2SIM.sCheckInGroup)
                        {
                            iNbCI += Group.ChildNodes.Count;
                            FindMaxIndex(Group, ref iLastCI);
                        }
                    }
                }
                else if (enfant.Attributes["Type"].Value == PAX2SIM.sBHSName)
                {
                    foreach (XmlNode Group in enfant.ChildNodes)
                    {
                        if (Group.Attributes["Type"].Value == BHS_String_TransferInfeedGroup)
                        {
                            iNbTransferInfeed += Group.ChildNodes.Count;
                            FindMaxIndex(Group, ref iLastTransferInfeed);
                        }
                        else if (Group.Attributes["Type"].Value == "Check In Collector Group")
                        {
                            iNbCollectors += Group.ChildNodes.Count;
                            FindMaxIndex(Group, ref iLastCollectors);
                        }
                        else if (Group.Attributes["Type"].Value == "Make-Up Group")
                        {
                            iNbMakeUpPosition += Group.ChildNodes.Count;
                            FindMaxIndex(Group, ref iLastMakeUpPosition);
                        }
                        else if (Group.Attributes["Type"].Value == "MES Group")
                        {
                            iNbMEStation += Group.ChildNodes.Count;
                            FindMaxIndex(Group, ref iLastMEStation);
                        }
                        else if (Group.Attributes["Type"].Value == "HBS Lev1 Group")
                        {
                            iNbLev1 += Group.ChildNodes.Count;
                            FindMaxIndex(Group, ref iLastLev1);
                        }
                        else if (Group.Attributes["Type"].Value == "HBS Lev3 Group")
                        {
                            iNbLev3 += Group.ChildNodes.Count;
                            FindMaxIndex(Group, ref iLastLev3);
                        }
                        else if (Group.Attributes["Type"].Value == BHS_String_ArrivalInfeedGroup)
                        {
                            iNbArrivalInfeed += Group.ChildNodes.Count;
                            FindMaxIndex(Group, ref iLastArrivalInfeed);
                        }
                    }
                }
            }
            if (latable.Rows.Count < ListeLignesGeneral_BHS.Length)
            {
                latable.Rows.Clear();
                latable.Columns.Clear();
                OverallTools.FonctionUtiles.initialiserTable(latable, ListeEntete_BHS_General, ListeTypeEntete_BHS_General, ListePrimaryKey_BHS_General);
                OverallTools.FonctionUtiles.initialiserLignesTable(latable, ListeLignesGeneral_BHS);

                latable.Rows[16][1] = 0;
                latable.Rows[17][1] = 0;
            }

            latable.Rows[0][1] = iNbArrivalInfeed;
            latable.Rows[1][1] = iLastArrivalInfeed;
            latable.Rows[2][1] = iNbCI;
            latable.Rows[3][1] = iLastCI;
            latable.Rows[4][1] = iNbTransferInfeed;
            latable.Rows[5][1] = iLastTransferInfeed;
            latable.Rows[6][1] = iNbLev1;
            latable.Rows[7][1] = iLastLev1;
            latable.Rows[8][1] = iNbLev3;
            latable.Rows[9][1] = iLastLev3;
            latable.Rows[10][1] = iNbMEStation;
            latable.Rows[11][1] = iLastMEStation;
            latable.Rows[12][1] = iNbMakeUpPosition;
            latable.Rows[13][1] = iLastMakeUpPosition;
            latable.Rows[14][1] = iNbCollectors;
            latable.Rows[15][1] = iLastCollectors;

            latable.AcceptChanges();
        }
        private void FindMaxIndex(XmlNode xnGroup, ref int iMax)
        {
            int iTmp;
            foreach (XmlNode xnFils in xnGroup.ChildNodes)
            {
                if (!Int32.TryParse(xnFils.Attributes["Index"].Value, out iTmp))
                    return;
                if (iTmp > iMax)
                    iMax = iTmp;
            }
        }
        #endregion

        #endregion

        #region Fonction pour la vérification des données chargées.
        #region OLD

        /*public ArrayList CheckTable(String sTable, String sortedColumn, SortOrder Order)
        {

            if (!htChecks.ContainsKey(sTable))
                return null;
            Dictionary<String, DataTable> htTables = new Dictionary<String, DataTable>();
            OverallTools.TableCheck tcCheck = (OverallTools.TableCheck)htChecks[sTable];
            DataTable Tmp = getTable("Input", sTable);
            if (Tmp == null)
                return null;
            htTables.Add(sTable, Tmp);
            if (tcCheck.TableLinkedTable != null)
            {
                foreach (String TableName in tcCheck.TableLinkedTable)
                {
                    Tmp = getTable("Input", TableName);
                    if (Tmp == null)
                        return null;
                    htTables.Add(TableName, Tmp);
                }
            }
            if (tcCheck.OneOfTable != null)
            {
                Tmp = getTable("Input", tcCheck.OneOfTable);
                if (Tmp == null)
                    return null;
                htTables.Add("OneofSpecificationTable", Tmp);
            }

            return CheckTable(sTable, htTables, sortedColumn, Order, (epPerimeter == PAX2SIM.EnumPerimetre.PAX), (epPerimeter == PAX2SIM.EnumPerimetre.BHS));
        }
        private ArrayList CheckTable(String sTable,
            Dictionary<String, DataTable> htTables,
            String sortedColumn,
            SortOrder Order,
            bool bCheckPaxSimulation,
            bool bCheckBagSimulation)
        {
            ArrayList errorList = new ArrayList();
            ArrayList warningList = new ArrayList();
            String SsortedColumn = sortedColumn;
            if (Order == SortOrder.Descending)
                SsortedColumn = sortedColumn + " DESC";
            if (Order == SortOrder.None)
                SsortedColumn = null;
            ConditionnalFormatErrors cfeErrors = new ConditionnalFormatErrors();

            //Vérifier que si on est en mode version évaluation, il n'y ait pas de problèmes.
            if (!htTables.ContainsKey(sTable))
                return null;
            DataTable dtTable_ = (DataTable)htTables[sTable];
            if (!IsValidShowUp(dtTable_))
            {
                errorList.Add("The table " + dtTable_.TableName + " is not valid. The maximum time can't be greater than " + CI_ShowUpMax.ToString());
                if ((dtTable_.Columns.Count > 1) && (dtTable_.Rows.Count > 0))
                    cfeErrors.setCondition(1, dtTable_.Rows.Count - 1, errorList[errorList.Count - 1].ToString());

                //Fin de la vérification de la version d'évaluation.
            }
            else
            {
                if (!htChecks.Contains(sTable))
                    return null;
                OverallTools.TableCheck tcCheck = (OverallTools.TableCheck)htChecks[sTable];
                if (tcCheck.CheckTable(htTables, SsortedColumn, structureAeroport, errorList, warningList, cfeErrors, bUseAlphNumericForFlightInfo, bCheckPaxSimulation, bCheckBagSimulation))
                    errorList = null;
            }
            VisualisationMode mode = this.getModeVisualisation("Input", sTable);
            if (mode != null)
            {
                if ((cfeErrors.Errors != 0) || (cfeErrors.Warnings != 0))
                    mode.ConditionnalFormatClass = new VisualisationMode.ConditionnalFormat[] { cfeErrors };
                else
                    mode.ConditionnalFormatClass = null;
            }
            return errorList;
        }*/
        /*public ArrayList CheckFlightPlans(String sortedColumn, SortOrder Order)
       {
           ArrayList errorList = new ArrayList();
           foreach (String name in ListeNomTablePAX)
           {
               NormalTable ntTmp = InputData.GetTable(name);
               if (ntTmp == null)
                   continue;

               ArrayList tmp = ntTmp.getErrors(sortedColumn,Order);//CheckTable(name, sortedColumn, Order);
               if (tmp != null)
                   errorList.AddRange(tmp);
           }
           if (errorList.Count > 0)
               return errorList;
           return null;
       }*/
        /*public ArrayList CheckTable(Dictionary<String, DataTable> htTables, bool bCheckPaxSimulation, bool bCheckBagSimulation)
       {
           ArrayList errorList = new ArrayList();
           foreach (String name in htTables.Keys)
           {
               GC.Collect();
               ArrayList tmp = CheckTable(name, htTables, null, SortOrder.None, bCheckPaxSimulation, bCheckBagSimulation);
               if (tmp != null)
                   errorList.AddRange(tmp);
           }
           if (errorList.Count > 0)
               return errorList;
           return null;
       }*/
        #endregion
        public ArrayList CheckTable(String sTable, String sortedColumn, SortOrder Order)
        {
            NormalTable ntTable = InputData.GetTable(sTable);
            if (ntTable == null)
                return null;
            return ntTable.getErrors(sortedColumn, Order);
        }
        public ArrayList CheckFlightPlans(String sortedColumn, SortOrder Order)
        {
            return InputData.CheckTables(sortedColumn, Order);
        }
       
        public ArrayList CheckTable(List<String> lsTables, bool bCheckPaxSimulation, bool bCheckBagSimulation)
        {
            return InputData.CheckTables(lsTables, null, SortOrder.None, bCheckPaxSimulation, bCheckBagSimulation);
        }
       

        private bool CheckAirportStructure(XmlNode xnStructure)
        {
            foreach (System.Xml.XmlNode Noeud in xnStructure.ChildNodes)
            {
                if (!OverallTools.FonctionUtiles.hasNamedAttribute(Noeud, "Name"))
                {
                    ListeErreurs.Add("Err00019 : Wrong format for an Airport object.");
                    return false;
                }
                String Name = Noeud.Attributes["Name"].Value;
                if (!OverallTools.FonctionUtiles.hasNamedAttribute(Noeud, "Type"))
                {
                    ListeErreurs.Add("Err00008 : Wrong format for the Airport object : \"" + Name + "\". Unable to load project.");
                    return false;
                }
                String Type = Noeud.Attributes["Type"].Value;
                if (!OverallTools.FonctionUtiles.hasNamedAttribute(Noeud, "Index"))
                {
                    ListeErreurs.Add("Err00020 : Wrong format for the Airport object : \"" + Name + "\". Unable to load project.");
                    return false;
                }
                String Index = Noeud.Attributes["Index"].Value;
                int iIndex;
                if (!Int32.TryParse(Index, out iIndex))
                {
                    ListeErreurs.Add("Err00021 : Wrong format for the Airport object : \"" + Name + "\". There is a mistake in the index content.");
                    return false;
                }
                if (htSizeAutomodModel.ContainsKey(Type))
                {
                    int iNbMax = (int)htSizeAutomodModel[Type];
                    if (iNbMax < iIndex)
                    {
                        ListeErreurs.Add("Err00022 : The limited number of \"" + Type + "\" in the airport structure is exceeded. It can't be greather than " + iNbMax + " object(s).");
                        return false;
                    }
                }
                if (!CheckAirportStructure(Noeud))
                    return false;
            }
            return true;
        }
        #endregion

        #region Fonctions pour répercuté sur toutes les tables le changement de nom d'une catégorie de vol.
        public void ChangeFlightCategorie(String oldFC, String newFC)
        {
            /*For the flight plans*/
            DataTable FPTable = getTable("Input", GlobalNames.FPDTableName);
            if (FPTable == null)
                return;
            OverallTools.DataFunctions.ReplaceValue(FPTable, GlobalNames.sFPD_A_Column_FlightCategory, oldFC, newFC);
            FPTable = getTable("Input", GlobalNames.FPATableName);
            if (FPTable == null)
                return;
            OverallTools.DataFunctions.ReplaceValue(FPTable, GlobalNames.sFPD_A_Column_FlightCategory, oldFC, newFC);

            /*For the tables with a column named with the given Flight categorie.*/
            foreach (String name in listeTable_FC)
            {

                FPTable = getTable("Input", name);
                if (FPTable == null)
                    return;
                OverallTools.DataFunctions.renameColumn(FPTable, oldFC, newFC);
            }
        }
        #endregion

        #region Fonctions pour la génération du PaxPlan et du pax_GenTransferLog

        #region Fonction pour la réalisation des différentes tables utilisées par l'outil de simulation
        internal static DataTable calcOCT_FPD(DataTable FPDTable,
                                     NormalTable OCTCITable,
                                     NormalTable OCTBGTable,                                     
                                     List<String> lsOrderAirline,
                                     List<String> lsOrderFlightCategory,
                                     DateTime debutSimulation,
                                     XmlNode xnStructure,
                                     Boolean bUseAlpha)
        {
            if ((FPDTable == null) || (OCTCITable == null) || (OCTBGTable == null))                
                return null;

            if (!(OCTCITable is ExceptionTable))
                return null;
            if (!(OCTBGTable is ExceptionTable))
                return null;
            
            ExceptionTable etOCTCITable = (ExceptionTable)OCTCITable;
            ExceptionTable etOCTBGTable = (ExceptionTable)OCTBGTable;
            
            DataTable simpleFPD = new DataTable("simpleFPD");
            DataTable dtTmp = FPDTable;
            if (bUseAlpha)
                dtTmp = ConvertFPDInformations(FPDTable, xnStructure, false, false);
            if (dtTmp == null)
                return null;
            simpleFPD.Columns.Add("Id", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("OpeningCI", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("ClosingCI", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("OpeningBoardGate", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("ClosingBoardGate", System.Type.GetType("System.Int32"));

            simpleFPD.Columns.Add("CheckInTerminal", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("IndexFBCheckInstart", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("IndexFBCheckInEnd", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("IndexEcoCheckInStart", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("IndexEcoCheckInEnd", System.Type.GetType("System.Int32"));

            simpleFPD.Columns.Add("BoardingGateTerminal", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("IndexBoardingGate", System.Type.GetType("System.Int32"));

            simpleFPD.Columns.Add("FlightCategory", System.Type.GetType("System.Int32"));

            simpleFPD.Columns.Add("MakeUpTerminal", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("FBMakeUpStart", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("FBMakeUpEnd", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("EcoMakeUpStart", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("EcoMakeUpEnd", System.Type.GetType("System.Int32"));

            simpleFPD.Columns.Add("ParkingTerminal", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("Parking", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("RunWay", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("TSA", System.Type.GetType("System.Int32"));

            simpleFPD.Columns.Add("IndexFBBagDropStart", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("IndexFBBagDropEnd", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("IndexEcoBagDropStart", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("IndexEcoBagDropEnd", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("Airline", System.Type.GetType("System.Int32"));

            int iIndexFC = dtTmp.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightCategory);
            int iIndexAirline = dtTmp.Columns.IndexOf(GlobalNames.sFPD_A_Column_AirlineCode);
            if ((iIndexFC == -1) ||(iIndexAirline==-1))
                return null;


            //int iIndexOpeningCI = OverallTools.DataFunctions.indexLigne(OCTCITable, 0, GlobalNames.sOCT_CI_Line_Opening);
            //int iIndexClosingCI = OverallTools.DataFunctions.indexLigne(OCTCITable, 0, GlobalNames.sOCT_CI_Line_Closing);

            //int iIndexOpeningBG = OverallTools.DataFunctions.indexLigne(OCTBGTable, 0, GlobalNames.sOCT_Board_Line_Opening);
            //int iIndexClosingBG = OverallTools.DataFunctions.indexLigne(OCTBGTable, 0, GlobalNames.sOCT_Board_Line_Closing);

            /*if ((iIndexOpeningCI == -1) ||
                (iIndexClosingCI == -1) ||
                (iIndexOpeningBG == -1) ||
                (iIndexClosingBG == -1))
            {
                return null;
            }*/

            foreach (DataRow Row in dtTmp.Rows)
            {
                DataRow newLine = simpleFPD.NewRow();

                newLine["Id"] = FonctionsType.getInt(Row[GlobalNames.sFPD_A_Column_ID], Row[GlobalNames.sFPD_A_Column_ID].GetType());

                String flightId = "D_" + newLine["Id"].ToString();      // << Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop
                String sCategorieVol = Row.ItemArray[iIndexFC].ToString();
                String sAirline = Row.ItemArray[iIndexAirline].ToString();

                // On détermine l'heure d'ouverture et de fermeture de la ressource pour le vol.
                Dictionary<String, String> dssCiValues = etOCTCITable.GetInformationsColumns(0, flightId, sAirline, sCategorieVol); // << Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop
                Dictionary<String, String> dssBGValues = etOCTBGTable.GetInformationsColumns(0, flightId, sAirline, sCategorieVol); // << Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop
       
                if (dssCiValues == null)
                    continue;
                if (dssBGValues == null)
                    continue;

                //dssCiValues[GlobalNames.sOCT_CI_Line_Opening]
                int iIndexCI = lsOrderFlightCategory.IndexOf(sCategorieVol);
                if (iIndexCI >= 0)
                    iIndexCI++;
                int iAirline = lsOrderAirline.IndexOf(sAirline);
                if (iAirline >=0 )
                    iAirline++;

                /*int iIndexBG = OCTBGTable.Columns.IndexOf(sCategorieVol);
                if (iIndexBG == -1)
                    continue;*/

                //On détermine l'heure d'arrivée du vol.
                DateTime dtJourHeureArrivee = OverallTools.DataFunctions.toDateTime(Row[GlobalNames.sFPD_A_Column_DATE], Row[GlobalNames.sFPD_Column_STD]);
                if (dtJourHeureArrivee < debutSimulation)
                    continue;

                newLine["FlightCategory"] = iIndexCI;

                newLine["CheckInTerminal"] = FonctionsType.getInt(Row[GlobalNames.sFPD_Column_TerminalCI]);
                newLine["IndexFBCheckInstart"] = FonctionsType.getInt(Row[GlobalNames.sFPD_Column_FB_CI_Start]);
                newLine["IndexFBCheckInEnd"] =FonctionsType.getInt( Row[GlobalNames.sFPD_Column_FB_CI_End]);
                newLine["IndexEcoCheckInStart"] = FonctionsType.getInt(Row["Eco. Class CI Start"]);
                newLine["IndexEcoCheckInEnd"] = FonctionsType.getInt(Row["Eco. Class CI End"]);

                newLine["BoardingGateTerminal"] = FonctionsType.getInt(Row[GlobalNames.sFPD_A_Column_TerminalGate]);
                newLine["IndexBoardingGate"] = FonctionsType.getInt(Row[GlobalNames.sFPD_Column_BoardingGate]);
                
                newLine["MakeUpTerminal"] = FonctionsType.getInt(Row[GlobalNames.sFPD_Column_TerminalMup]);
                newLine["EcoMakeUpStart"] = FonctionsType.getInt(Row[GlobalNames.sFPD_Column_Eco_Mup_Start]);

                newLine["EcoMakeUpEnd"] = FonctionsType.getInt(Row[GlobalNames.sFPD_Column_Eco_Mup_End]);
                newLine["FBMakeUpStart"] = FonctionsType.getInt(Row[GlobalNames.sFPD_Column_First_Mup_Start]);
                newLine["FBMakeUpEnd"] = FonctionsType.getInt(Row[GlobalNames.sFPD_Column_First_Mup_End]);

                newLine["ParkingTerminal"] = FonctionsType.getInt(Row[GlobalNames.sFPD_A_Column_TerminalParking]);
                newLine["Parking"] = FonctionsType.getInt(Row[GlobalNames.sFPD_A_Column_Parking]);
                newLine["RunWay"] = FonctionsType.getInt(Row[GlobalNames.sFPD_A_Column_RunWay]);
                if ((bool)Row[GlobalNames.sFPD_Column_TSA])
                    newLine["TSA"] = 1;
                else
                    newLine["TSA"] = 0;

                newLine["IndexFBBagDropStart"] =FonctionsType.getInt( Row[GlobalNames.sFPD_Column_FB_Drop_Start]);
                newLine["IndexFBBagDropEnd"] = FonctionsType.getInt(Row[GlobalNames.sFPD_Column_FB_Drop_End]);
                newLine["IndexEcoBagDropStart"] = FonctionsType.getInt(Row[GlobalNames.sFPD_Column_Eco_Drop_Start]);
                newLine["IndexEcoBagDropEnd"] =FonctionsType.getInt( Row[GlobalNames.sFPD_Column_Eco_Drop_End]);

                DateTime heureOuvertureCI = dtJourHeureArrivee.AddMinutes(-FonctionsType.getInt(dssCiValues[GlobalNames.sOCT_CI_Line_Opening], dssCiValues[GlobalNames.sOCT_CI_Line_Opening].GetType()));
                DateTime heureFermetureCI = dtJourHeureArrivee.AddMinutes(-FonctionsType.getInt(dssCiValues[GlobalNames.sOCT_CI_Line_Closing], dssCiValues[GlobalNames.sOCT_CI_Line_Closing].GetType()));

                DateTime heureOuvertureBG = dtJourHeureArrivee.AddMinutes(-FonctionsType.getInt(dssBGValues[GlobalNames.sOCT_Board_Line_Opening], dssBGValues[GlobalNames.sOCT_Board_Line_Opening].GetType()));
                DateTime heureFermetureBG = dtJourHeureArrivee.AddMinutes(-FonctionsType.getInt(dssBGValues[GlobalNames.sOCT_Board_Line_Closing], dssBGValues[GlobalNames.sOCT_Board_Line_Closing].GetType()));
                                
                if (heureOuvertureCI < debutSimulation)
                {
                    newLine["OpeningCI"] = 0;
                }
                else
                {
                    newLine["OpeningCI"] = (int)((TimeSpan)heureOuvertureCI.Subtract(debutSimulation)).TotalMinutes;
                }

                if (heureFermetureCI < debutSimulation)
                {
                    newLine["ClosingCI"] = 0;
                }
                else
                {
                    newLine["ClosingCI"] = (int)((TimeSpan)heureFermetureCI.Subtract(debutSimulation)).TotalMinutes;
                }
                if (heureOuvertureBG < debutSimulation)
                {
                    newLine["OpeningBoardGate"] = 0;
                }
                else
                {
                    newLine["OpeningBoardGate"] = (int)((TimeSpan)heureOuvertureBG.Subtract(debutSimulation)).TotalMinutes;
                }
                if (heureFermetureBG < debutSimulation)
                {
                    newLine["ClosingBoardGate"] = 0;
                }
                else
                {
                    newLine["ClosingBoardGate"] = (int)((TimeSpan)heureFermetureBG.Subtract(debutSimulation)).TotalMinutes;
                }
                newLine["Airline"] = iAirline;
                simpleFPD.Rows.Add(newLine);
            }
            if (bUseAlpha)
                dtTmp.Dispose();
            return simpleFPD;
        }

        // << Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop
        internal static DataTable calcOCT_FPD_2(DataTable FPDTable,
                                     NormalTable OCTCITable,
                                     NormalTable OCTBGTable,
                                     NormalTable OCTBagDropTable,   // << Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop
                                     List<String> lsOrderAirline,
                                     List<String> lsOrderFlightCategory,
                                     DateTime debutSimulation,
                                     XmlNode xnStructure,
                                     Boolean bUseAlpha)
        {
            if ((FPDTable == null) || (OCTCITable == null) || (OCTBGTable == null)
                || OCTBagDropTable == null)   // << Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop
                return null;

            if (!(OCTCITable is ExceptionTable))
                return null;
            if (!(OCTBGTable is ExceptionTable))
                return null;
            // << Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop
            if (!(OCTBagDropTable is ExceptionTable))
                return null;
            // >> Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop

            ExceptionTable etOCTCITable = (ExceptionTable)OCTCITable;
            ExceptionTable etOCTBGTable = (ExceptionTable)OCTBGTable;
            ExceptionTable etOCTBDTable = (ExceptionTable)OCTBagDropTable;   // << Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop



            DataTable simpleFPD = new DataTable("simpleFPD");
            DataTable dtTmp = FPDTable;
            if (bUseAlpha)
                dtTmp = ConvertFPDInformations(FPDTable, xnStructure, false, false);
            if (dtTmp == null)
                return null;
            simpleFPD.Columns.Add("Id", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("OpeningCI", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("ClosingCI", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("OpeningBoardGate", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("ClosingBoardGate", System.Type.GetType("System.Int32"));

            simpleFPD.Columns.Add("CheckInTerminal", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("IndexFBCheckInstart", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("IndexFBCheckInEnd", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("IndexEcoCheckInStart", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("IndexEcoCheckInEnd", System.Type.GetType("System.Int32"));

            simpleFPD.Columns.Add("BoardingGateTerminal", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("IndexBoardingGate", System.Type.GetType("System.Int32"));

            simpleFPD.Columns.Add("FlightCategory", System.Type.GetType("System.Int32"));

            simpleFPD.Columns.Add("MakeUpTerminal", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("FBMakeUpStart", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("FBMakeUpEnd", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("EcoMakeUpStart", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("EcoMakeUpEnd", System.Type.GetType("System.Int32"));

            simpleFPD.Columns.Add("ParkingTerminal", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("Parking", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("RunWay", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("TSA", System.Type.GetType("System.Int32"));

            simpleFPD.Columns.Add("IndexFBBagDropStart", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("IndexFBBagDropEnd", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("IndexEcoBagDropStart", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("IndexEcoBagDropEnd", System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add("Airline", System.Type.GetType("System.Int32"));
            // << Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop
            simpleFPD.Columns.Add(GlobalNames.FPD_TABLE_2_OPENING_CI_FIRST_COLUMN_NAME, System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add(GlobalNames.FPD_TABLE_2_CLOSING_CI_FIRST_COLUMN_NAME, System.Type.GetType("System.Int32"));

            simpleFPD.Columns.Add(GlobalNames.FPD_TABLE_2_OPENING_BAGDROP_ECO_COLUMN_NAME, System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add(GlobalNames.FPD_TABLE_2_CLOSING_BAGDROP_ECO_COLUMN_NAME, System.Type.GetType("System.Int32"));

            simpleFPD.Columns.Add(GlobalNames.FPD_TABLE_2_OPENING_BAGDROP_FIRST_COLUMN_NAME, System.Type.GetType("System.Int32"));
            simpleFPD.Columns.Add(GlobalNames.FPD_TABLE_2_CLOSING_BAGDROP_FIRST_COLUMN_NAME, System.Type.GetType("System.Int32"));
            // >> Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop

            int iIndexFC = dtTmp.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightCategory);
            int iIndexAirline = dtTmp.Columns.IndexOf(GlobalNames.sFPD_A_Column_AirlineCode);
            if ((iIndexFC == -1) || (iIndexAirline == -1))
                return null;


            //int iIndexOpeningCI = OverallTools.DataFunctions.indexLigne(OCTCITable, 0, GlobalNames.sOCT_CI_Line_Opening);
            //int iIndexClosingCI = OverallTools.DataFunctions.indexLigne(OCTCITable, 0, GlobalNames.sOCT_CI_Line_Closing);

            //int iIndexOpeningBG = OverallTools.DataFunctions.indexLigne(OCTBGTable, 0, GlobalNames.sOCT_Board_Line_Opening);
            //int iIndexClosingBG = OverallTools.DataFunctions.indexLigne(OCTBGTable, 0, GlobalNames.sOCT_Board_Line_Closing);

            /*if ((iIndexOpeningCI == -1) ||
                (iIndexClosingCI == -1) ||
                (iIndexOpeningBG == -1) ||
                (iIndexClosingBG == -1))
            {
                return null;
            }*/

            foreach (DataRow Row in dtTmp.Rows)
            {
                DataRow newLine = simpleFPD.NewRow();

                newLine["Id"] = FonctionsType.getInt(Row[GlobalNames.sFPD_A_Column_ID], Row[GlobalNames.sFPD_A_Column_ID].GetType());

                String flightId = "D_" + newLine["Id"].ToString();      // << Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop
                String sCategorieVol = Row.ItemArray[iIndexFC].ToString();
                String sAirline = Row.ItemArray[iIndexAirline].ToString();

                // On détermine l'heure d'ouverture et de fermeture de la ressource pour le vol.
                Dictionary<String, String> dssCiValues = etOCTCITable.GetInformationsColumns(0, flightId, sAirline, sCategorieVol); // << Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop                
                Dictionary<String, String> dssCiValues_FB = etOCTCITable.GetInformationsColumns(1, flightId, sAirline, sCategorieVol);  // << Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop

                Dictionary<String, String> dssBGValues = etOCTBGTable.GetInformationsColumns(0, flightId, sAirline, sCategorieVol); // << Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop                

                Dictionary<String, String> dssBDValues = etOCTBDTable.GetInformationsColumns(0, flightId, sAirline, sCategorieVol); // << Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop                                
                Dictionary<String, String> dssBDValues_FB = etOCTBDTable.GetInformationsColumns(1, flightId, sAirline, sCategorieVol); // << Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop

                if (dssCiValues == null)
                    continue;
                if (dssBGValues == null)
                    continue;
                // << Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop
                if (dssCiValues_FB == null)
                    continue;
                if (dssBDValues == null)
                    continue;
                if (dssBDValues_FB == null)
                    continue;
                // >> Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop

                //dssCiValues[GlobalNames.sOCT_CI_Line_Opening]
                int iIndexCI = lsOrderFlightCategory.IndexOf(sCategorieVol);
                if (iIndexCI >= 0)
                    iIndexCI++;
                int iAirline = lsOrderAirline.IndexOf(sAirline);
                if (iAirline >= 0)
                    iAirline++;

                /*int iIndexBG = OCTBGTable.Columns.IndexOf(sCategorieVol);
                if (iIndexBG == -1)
                    continue;*/

                //On détermine l'heure d'arrivée du vol.
                DateTime dtJourHeureArrivee = OverallTools.DataFunctions.toDateTime(Row[GlobalNames.sFPD_A_Column_DATE], Row[GlobalNames.sFPD_Column_STD]);
                if (dtJourHeureArrivee < debutSimulation)
                    continue;

                newLine["FlightCategory"] = iIndexCI;

                newLine["CheckInTerminal"] = FonctionsType.getInt(Row[GlobalNames.sFPD_Column_TerminalCI]);
                newLine["IndexFBCheckInstart"] = FonctionsType.getInt(Row[GlobalNames.sFPD_Column_FB_CI_Start]);
                newLine["IndexFBCheckInEnd"] = FonctionsType.getInt(Row[GlobalNames.sFPD_Column_FB_CI_End]);
                newLine["IndexEcoCheckInStart"] = FonctionsType.getInt(Row["Eco. Class CI Start"]);
                newLine["IndexEcoCheckInEnd"] = FonctionsType.getInt(Row["Eco. Class CI End"]);

                newLine["BoardingGateTerminal"] = FonctionsType.getInt(Row[GlobalNames.sFPD_A_Column_TerminalGate]);
                newLine["IndexBoardingGate"] = FonctionsType.getInt(Row[GlobalNames.sFPD_Column_BoardingGate]);

                newLine["MakeUpTerminal"] = FonctionsType.getInt(Row[GlobalNames.sFPD_Column_TerminalMup]);
                newLine["EcoMakeUpStart"] = FonctionsType.getInt(Row[GlobalNames.sFPD_Column_Eco_Mup_Start]);

                newLine["EcoMakeUpEnd"] = FonctionsType.getInt(Row[GlobalNames.sFPD_Column_Eco_Mup_End]);
                newLine["FBMakeUpStart"] = FonctionsType.getInt(Row[GlobalNames.sFPD_Column_First_Mup_Start]);
                newLine["FBMakeUpEnd"] = FonctionsType.getInt(Row[GlobalNames.sFPD_Column_First_Mup_End]);

                newLine["ParkingTerminal"] = FonctionsType.getInt(Row[GlobalNames.sFPD_A_Column_TerminalParking]);
                newLine["Parking"] = FonctionsType.getInt(Row[GlobalNames.sFPD_A_Column_Parking]);
                newLine["RunWay"] = FonctionsType.getInt(Row[GlobalNames.sFPD_A_Column_RunWay]);
                if ((bool)Row[GlobalNames.sFPD_Column_TSA])
                    newLine["TSA"] = 1;
                else
                    newLine["TSA"] = 0;

                newLine["IndexFBBagDropStart"] = FonctionsType.getInt(Row[GlobalNames.sFPD_Column_FB_Drop_Start]);
                newLine["IndexFBBagDropEnd"] = FonctionsType.getInt(Row[GlobalNames.sFPD_Column_FB_Drop_End]);
                newLine["IndexEcoBagDropStart"] = FonctionsType.getInt(Row[GlobalNames.sFPD_Column_Eco_Drop_Start]);
                newLine["IndexEcoBagDropEnd"] = FonctionsType.getInt(Row[GlobalNames.sFPD_Column_Eco_Drop_End]);

                DateTime heureOuvertureCI = dtJourHeureArrivee.AddMinutes(-FonctionsType.getInt(dssCiValues[GlobalNames.sOCT_CI_Line_Opening], dssCiValues[GlobalNames.sOCT_CI_Line_Opening].GetType()));
                DateTime heureFermetureCI = dtJourHeureArrivee.AddMinutes(-FonctionsType.getInt(dssCiValues[GlobalNames.sOCT_CI_Line_Closing], dssCiValues[GlobalNames.sOCT_CI_Line_Closing].GetType()));

                DateTime heureOuvertureBG = dtJourHeureArrivee.AddMinutes(-FonctionsType.getInt(dssBGValues[GlobalNames.sOCT_Board_Line_Opening], dssBGValues[GlobalNames.sOCT_Board_Line_Opening].GetType()));
                DateTime heureFermetureBG = dtJourHeureArrivee.AddMinutes(-FonctionsType.getInt(dssBGValues[GlobalNames.sOCT_Board_Line_Closing], dssBGValues[GlobalNames.sOCT_Board_Line_Closing].GetType()));

                // << Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop
                // Check In Opening/Closing DateTime for First&Business
                DateTime openingTimeCI_FB = dtJourHeureArrivee.AddMinutes(-FonctionsType
                                                                .getInt(dssCiValues_FB[GlobalNames.sOCT_CI_Line_Opening],
                                                                        dssCiValues_FB[GlobalNames.sOCT_CI_Line_Opening].GetType()));
                DateTime closingTimeCI_FB = dtJourHeureArrivee.AddMinutes(-FonctionsType
                                                                .getInt(dssCiValues_FB[GlobalNames.sOCT_CI_Line_Closing],
                                                                        dssCiValues_FB[GlobalNames.sOCT_CI_Line_Closing].GetType()));

                // Baggage Drop Opening/Closing DateTime for Economy
                DateTime openingTimeBagDrop = dtJourHeureArrivee.AddMinutes(-FonctionsType
                                                                .getInt(dssBDValues[GlobalNames.sOCT_BagDropOpening],
                                                                        dssBDValues[GlobalNames.sOCT_BagDropOpening].GetType()));
                DateTime closingTimeBagDrop = dtJourHeureArrivee.AddMinutes(-FonctionsType
                                                                .getInt(dssBDValues[GlobalNames.sOCT_BagDropClosing],
                                                                        dssBDValues[GlobalNames.sOCT_BagDropClosing].GetType()));
                // Baggage Drop Opening/Closing DateTime for First&Business
                DateTime openingTimeBagDrop_FB = dtJourHeureArrivee.AddMinutes(-FonctionsType
                                                                .getInt(dssBDValues_FB[GlobalNames.sOCT_BagDropOpening],
                                                                        dssBDValues_FB[GlobalNames.sOCT_BagDropOpening].GetType()));
                DateTime closingTimeBagDrop_FB = dtJourHeureArrivee.AddMinutes(-FonctionsType
                                                                .getInt(dssBDValues_FB[GlobalNames.sOCT_BagDropClosing],
                                                                        dssBDValues_FB[GlobalNames.sOCT_BagDropClosing].GetType()));
                // >> Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop

                if (heureOuvertureCI < debutSimulation)
                {
                    newLine["OpeningCI"] = 0;
                }
                else
                {
                    newLine["OpeningCI"] = (int)((TimeSpan)heureOuvertureCI.Subtract(debutSimulation)).TotalMinutes;
                }

                if (heureFermetureCI < debutSimulation)
                {
                    newLine["ClosingCI"] = 0;
                }
                else
                {
                    newLine["ClosingCI"] = (int)((TimeSpan)heureFermetureCI.Subtract(debutSimulation)).TotalMinutes;
                }
                if (heureOuvertureBG < debutSimulation)
                {
                    newLine["OpeningBoardGate"] = 0;
                }
                else
                {
                    newLine["OpeningBoardGate"] = (int)((TimeSpan)heureOuvertureBG.Subtract(debutSimulation)).TotalMinutes;
                }
                if (heureFermetureBG < debutSimulation)
                {
                    newLine["ClosingBoardGate"] = 0;
                }
                else
                {
                    newLine["ClosingBoardGate"] = (int)((TimeSpan)heureFermetureBG.Subtract(debutSimulation)).TotalMinutes;
                }
                newLine["Airline"] = iAirline;

                // << Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop
                if (openingTimeCI_FB < debutSimulation)
                {
                    newLine[GlobalNames.FPD_TABLE_2_OPENING_CI_FIRST_COLUMN_NAME] = 0;
                }
                else
                {
                    newLine[GlobalNames.FPD_TABLE_2_OPENING_CI_FIRST_COLUMN_NAME]
                        = (int)((TimeSpan)openingTimeCI_FB.Subtract(debutSimulation)).TotalMinutes; ;
                }
                if (closingTimeCI_FB < debutSimulation)
                {
                    newLine[GlobalNames.FPD_TABLE_2_CLOSING_CI_FIRST_COLUMN_NAME] = 0;
                }
                else
                {
                    newLine[GlobalNames.FPD_TABLE_2_CLOSING_CI_FIRST_COLUMN_NAME]
                        = (int)((TimeSpan)closingTimeCI_FB.Subtract(debutSimulation)).TotalMinutes; ;
                }

                if (openingTimeBagDrop < debutSimulation)
                {
                    newLine[GlobalNames.FPD_TABLE_2_OPENING_BAGDROP_ECO_COLUMN_NAME] = 0;
                }
                else
                {
                    newLine[GlobalNames.FPD_TABLE_2_OPENING_BAGDROP_ECO_COLUMN_NAME]
                        = (int)((TimeSpan)openingTimeBagDrop.Subtract(debutSimulation)).TotalMinutes; ;
                }
                if (closingTimeBagDrop < debutSimulation)
                {
                    newLine[GlobalNames.FPD_TABLE_2_CLOSING_BAGDROP_ECO_COLUMN_NAME] = 0;
                }
                else
                {
                    newLine[GlobalNames.FPD_TABLE_2_CLOSING_BAGDROP_ECO_COLUMN_NAME]
                        = (int)((TimeSpan)closingTimeBagDrop.Subtract(debutSimulation)).TotalMinutes; ;
                }

                if (openingTimeBagDrop_FB < debutSimulation)
                {
                    newLine[GlobalNames.FPD_TABLE_2_OPENING_BAGDROP_FIRST_COLUMN_NAME] = 0;
                }
                else
                {
                    newLine[GlobalNames.FPD_TABLE_2_OPENING_BAGDROP_FIRST_COLUMN_NAME]
                        = (int)((TimeSpan)openingTimeBagDrop_FB.Subtract(debutSimulation)).TotalMinutes; ;
                }
                if (closingTimeBagDrop_FB < debutSimulation)
                {
                    newLine[GlobalNames.FPD_TABLE_2_CLOSING_BAGDROP_FIRST_COLUMN_NAME] = 0;
                }
                else
                {
                    newLine[GlobalNames.FPD_TABLE_2_CLOSING_BAGDROP_FIRST_COLUMN_NAME]
                        = (int)((TimeSpan)closingTimeBagDrop_FB.Subtract(debutSimulation)).TotalMinutes; ;
                }
                // >> Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop

                simpleFPD.Rows.Add(newLine);
            }
            if (bUseAlpha)
                dtTmp.Dispose();
            return simpleFPD;
        }
        // >> Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop

        // >> Task #13361 FP AutoMod Data tables V3
        internal const String FPD_TABLE_3_FOR_AUTOMOD_TABLE_NAME = "FPD_Table_3";
        internal const String FPD_TABLE_3_FOR_AUTOMOD_PAX2SIM_TABLE_NAME = "FPD_Table";
        internal static DataTable getFPDTable3ForAutomod(DataTable FPDTable, NormalTable OCTCITable,         
            NormalTable OCTBGTable, NormalTable OCTBagDropTable, NormalTable octMakeUpTable, List<String> airlinesList,
            List<String> flightCategoriesList, List<String> aircraftTypesList,
            DateTime simulationStartDate, XmlNode xnStructure, Boolean bUseAlpha)
        {
            if (FPDTable == null || OCTCITable == null
                || OCTBGTable == null || OCTBagDropTable == null
                || octMakeUpTable == null)
            {
                return null;
            }

            if (!(OCTCITable is ExceptionTable))
                return null;
            if (!(OCTBGTable is ExceptionTable))
                return null;            
            if (!(OCTBagDropTable is ExceptionTable))
                return null;
            if (!(octMakeUpTable is ExceptionTable))
                return null;

            ExceptionTable etOCTCITable = (ExceptionTable)OCTCITable;
            ExceptionTable etOCTBGTable = (ExceptionTable)OCTBGTable;
            ExceptionTable etOCTBDTable = (ExceptionTable)OCTBagDropTable;
            ExceptionTable etOCTMakeUpTable = (ExceptionTable)octMakeUpTable;

            DataTable fpd3ForAutomod = new DataTable(FPD_TABLE_3_FOR_AUTOMOD_PAX2SIM_TABLE_NAME);
            DataTable dtTmp = FPDTable;

            if (bUseAlpha)
                dtTmp = ConvertFPDInformations(FPDTable, xnStructure, false, false);
            if (dtTmp == null)
                return null;

            #region columns and column indexes
            int fpd3IdColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("Id", typeof(Int32));

            int fpd3FlightNColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("FlightN", typeof(String));

            int fpd3AirlineIdColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("Airline_Id", typeof(Int32));
            int fpd3AirlineColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("Airline", typeof(String));

            int fpd3FlightCategoryIdColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("FlightCategory_Id", typeof(Int32));
            int fpd3FlightCategoryColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("FlightCategory", typeof(String));

            int fpd3AircraftTypeIdColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("AircraftType_Id", typeof(Int32));
            int fpd3AircraftTypeColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("AircraftType", typeof(String));

            int fpd3ParkingTerminalColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("Parking_Terminal", typeof(Int32));
            int fpd3ParkingStartColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("Parking_IndexStart", typeof(Int32));
            int fpd3ParkingEndColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("Parking_IndexEnd", typeof(Int32));

            int fpd3RunwayColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("RunWay", typeof(Int32));

            int fpd3User1ColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("User01", typeof(String));
            int fpd3User2ColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("User02", typeof(String));
            int fpd3User3ColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("User03", typeof(String));
            int fpd3User4ColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("User04", typeof(String));
            int fpd3User5ColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("User05", typeof(String));
            int fpd3User6ColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("User06", typeof(String));
            int fpd3User7ColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("User07", typeof(String));
            int fpd3User8ColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("User08", typeof(String));
            int fpd3User9ColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("User09", typeof(String));
            int fpd3User10ColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("User10", typeof(String));

            int fpd3STDColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("STD", typeof(Int32));

            int fpd3TSAColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("TSA", typeof(Int32));

            int fpd3CheckInTerminalColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("CheckIn_Terminal", typeof(Int32));
            int fpd3CheckInEcoStartColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("CheckIn_IndexStart_Eco", typeof(Int32));
            int fpd3CheckInEcoEndColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("CheckIn_IndexEnd_Eco", typeof(Int32));
            int fpd3CheckInFBStartColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("CheckIn_IndexStart_FB", typeof(Int32));
            int fpd3CheckInFBEndColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("CheckIn_IndexEnd_FB", typeof(Int32));

            int fpd3CheckInEcoOpeningColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("CheckIn_Opening_Eco", typeof(Int32));
            int fpd3CheckInEcoClosingColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("CheckIn_Closing_Eco", typeof(Int32));
            int fpd3CheckInFBOpeningColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("CheckIn_Opening_FB", typeof(Int32));
            int fpd3CheckInFBClosingColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("CheckIn_Closing_FB", typeof(Int32));

            int fpd3BagDropEcoStartColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("BagDrop_IndexStart_Eco", typeof(Int32));
            int fpd3BagDropEcoEndColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("BagDrop_IndexEnd_Eco", typeof(Int32));
            int fpd3BagDropFBStartColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("BagDrop_IndexStart_FB", typeof(Int32));
            int fpd3BagDropFBEndColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("BagDrop_IndexEnd_FB", typeof(Int32));

            int fpd3BagDropEcoOpeningColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("BagDrop_Opening_Eco", typeof(Int32));
            int fpd3BagDropEcoClosingColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("BagDrop_Closing_Eco", typeof(Int32));
            int fpd3BagDropFBOpeningColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("BagDrop_Opening_FB", typeof(Int32));
            int fpd3BagDropFBClosingColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("BagDrop_Closing_FB", typeof(Int32));

            int fpd3BoardingGateTerminalColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("BoardingGate_Terminal", typeof(Int32));
            int fpd3BoardingGateEcoStartColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("BoardingGate_IndexStart_Eco", typeof(Int32));
            int fpd3BoardingGateEcoEndColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("BoardingGate_IndexEnd_Eco", typeof(Int32));
            int fpd3BoardingGateFBStartColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("BoardingGate_IndexStart_FB", typeof(Int32));
            int fpd3BoardingGateFBEndColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("BoardingGate_IndexEnd_FB", typeof(Int32));

            int fpd3BoardingGateEcoOpeningColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("BoardingGate_Opening_Eco", typeof(Int32));
            int fpd3BoardingGateEcoClosingColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("BoardingGate_Closing_Eco", typeof(Int32));
            int fpd3BoardingGateFBOpeningColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("BoardingGate_Opening_FB", typeof(Int32));
            int fpd3BoardingGateFBClosingColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("BoardingGate_Closing_FB", typeof(Int32));

            int fpd3MakeUpTerminalColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("MakeUp_Terminal", typeof(Int32));
            int fpd3MakeUpEcoStartColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("MakeUp_IndexStart_Eco", typeof(Int32));
            int fpd3MakeUpEcoEndColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("MakeUp_IndexEnd_Eco", typeof(Int32));
            int fpd3MakeUpFBStartColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("MakeUp_IndexStart_FB", typeof(Int32));
            int fpd3MakeUpFBEndColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("MakeUp_IndexEnd_FB", typeof(Int32));

            int fpd3MakeUpOpeningColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("MakeUp_Opening", typeof(Int32));
            int fpd3MakeUpClosingColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("MakeUp_Closing", typeof(Int32));

            int fpd3MakeUpEBSDeliveryTimeColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("MakeUp_EBSDeliveryTime", typeof(Int32));
            int fpd3MakeUpSegregationNbColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("MakeUp_SegregationNb", typeof(Int32));
            int fpd3MakeUpContainerSizeColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("MakeUp_ContainerSize", typeof(Int32));
            int fpd3MakeUpDeadTimeColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("MakeUp_DeadTime", typeof(Int32));
            int fpd3MakeUpNbContPerLateralColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("MakeUp_NbContPerLateral", typeof(Int32));
            int fpd3MakeUpLateTimeColumnIndex = fpd3ForAutomod.Columns.Count;
            fpd3ForAutomod.Columns.Add("MakeUp_LateTime", typeof(Int32));
            #endregion

            int fpdFlightCategoryColumnIndex = dtTmp.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightCategory);
            int fpdAirlineColumnindex = dtTmp.Columns.IndexOf(GlobalNames.sFPD_A_Column_AirlineCode);
            int fpdFlightNColumnIndex = dtTmp.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightN);
            int fpdAircraftTypeColumnIndex = dtTmp.Columns.IndexOf(GlobalNames.sFPD_A_Column_AircraftType);
            int fpdFlightDateColumnIndex = dtTmp.Columns.IndexOf(GlobalNames.sFPD_A_Column_DATE);
            int fpdFlightTimeColumnIndex = dtTmp.Columns.IndexOf(GlobalNames.sFPD_Column_STD);

            if (fpdFlightCategoryColumnIndex == -1 || fpdAirlineColumnindex == -1
                || fpdFlightCategoryColumnIndex == -1 || fpdAircraftTypeColumnIndex == -1
                || fpdFlightDateColumnIndex == -1 || fpdFlightTimeColumnIndex == -1)
            {
                return null;
            }

            foreach (DataRow fpdRow in dtTmp.Rows)
            {
                DataRow newFPD3Row = fpd3ForAutomod.NewRow();

                int flightId = FonctionsType.getInt(fpdRow[GlobalNames.sFPD_A_Column_ID], fpdRow[GlobalNames.sFPD_A_Column_ID].GetType());
                if (flightId <= 0)
                    continue;

                String flightIdWithPrefix = "D_" + flightId.ToString();
                String flightCategory = fpdRow.ItemArray[fpdFlightCategoryColumnIndex].ToString();
                String airlineCode = fpdRow.ItemArray[fpdAirlineColumnindex].ToString();
                String aircraftType = fpdRow.ItemArray[fpdAircraftTypeColumnIndex].ToString();
                String flightNb = fpdRow.ItemArray[fpdFlightNColumnIndex].ToString();

                // On détermine l'heure d'ouverture et de fermeture de la ressource pour le vol.
                Dictionary<String, String> dssCiValues = etOCTCITable.GetInformationsColumns(0, flightIdWithPrefix, airlineCode, flightCategory);
                Dictionary<String, String> dssCiValues_FB = etOCTCITable.GetInformationsColumnsOnlyForFBExceptions(1, flightIdWithPrefix, airlineCode, flightCategory);

                Dictionary<String, String> dssBGValues = etOCTBGTable.GetInformationsColumns(0, flightIdWithPrefix, airlineCode, flightCategory);
                Dictionary<String, String> dssBGValues_FB = etOCTBGTable.GetInformationsColumnsOnlyForFBExceptions(1, flightIdWithPrefix, airlineCode, flightCategory);

                Dictionary<String, String> dssBDValues = etOCTBDTable.GetInformationsColumns(0, flightIdWithPrefix, airlineCode, flightCategory);
                Dictionary<String, String> dssBDValues_FB = etOCTBDTable.GetInformationsColumnsOnlyForFBExceptions(1, flightIdWithPrefix, airlineCode, flightCategory);

                Dictionary<String, String> dssMakeUpValues = etOCTMakeUpTable.GetInformationsColumns(0, flightIdWithPrefix, airlineCode, flightCategory);   // New Mup OCT parameter
                
                if (dssCiValues == null)
                    continue;
                if (dssBGValues == null || dssBGValues_FB == null)
                    continue;
                // << Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop
                if (dssCiValues_FB == null)
                    continue;
                if (dssBDValues == null)
                    continue;
                if (dssBDValues_FB == null)
                    continue;
                // >> Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop

                //dssCiValues[GlobalNames.sOCT_CI_Line_Opening]
                int flightCategoryIndex = flightCategoriesList.IndexOf(flightCategory);
                if (flightCategoryIndex >= 0)
                    flightCategoryIndex++;
                int airlineIndex = airlinesList.IndexOf(airlineCode);
                if (airlineIndex >= 0)
                    airlineIndex++;
                int aircraftTypeIndex = aircraftTypesList.IndexOf(aircraftType);
                if (aircraftTypeIndex >= 0)
                    aircraftTypeIndex++;
              
                //On détermine l'heure d'arrivée du vol.
                DateTime flightDepartureDateAndTime = OverallTools.DataFunctions.toDateTime(fpdRow[GlobalNames.sFPD_A_Column_DATE], fpdRow[GlobalNames.sFPD_Column_STD]);
                if (flightDepartureDateAndTime < simulationStartDate)
                    continue;

                newFPD3Row[fpd3IdColumnIndex] = flightId;
                newFPD3Row[fpd3FlightNColumnIndex] = flightNb;

                newFPD3Row[fpd3AirlineIdColumnIndex] = airlineIndex;
                newFPD3Row[fpd3AirlineColumnIndex] = airlineCode;

                newFPD3Row[fpd3FlightCategoryIdColumnIndex] = flightCategoryIndex;
                newFPD3Row[fpd3FlightCategoryColumnIndex] = flightCategory;

                newFPD3Row[fpd3AircraftTypeIdColumnIndex] = aircraftTypeIndex;
                newFPD3Row[fpd3AircraftTypeColumnIndex] = aircraftType;

                newFPD3Row[fpd3ParkingTerminalColumnIndex] = FonctionsType.getInt(fpdRow[GlobalNames.sFPD_A_Column_TerminalParking]);
                newFPD3Row[fpd3ParkingStartColumnIndex] = FonctionsType.getInt(fpdRow[GlobalNames.sFPD_A_Column_Parking]);
                newFPD3Row[fpd3ParkingEndColumnIndex] = FonctionsType.getInt(fpdRow[GlobalNames.sFPD_A_Column_Parking]);

                newFPD3Row[fpd3RunwayColumnIndex] = FonctionsType.getInt(fpdRow[GlobalNames.sFPD_A_Column_RunWay]);

                newFPD3Row[fpd3User1ColumnIndex] = FonctionsType.getString(fpdRow[GlobalNames.sFPD_A_Column_User1]);
                newFPD3Row[fpd3User2ColumnIndex] = FonctionsType.getString(fpdRow[GlobalNames.sFPD_A_Column_User2]);
                newFPD3Row[fpd3User3ColumnIndex] = FonctionsType.getString(fpdRow[GlobalNames.sFPD_A_Column_User3]);
                newFPD3Row[fpd3User4ColumnIndex] = FonctionsType.getString(fpdRow[GlobalNames.sFPD_A_Column_User4]);
                newFPD3Row[fpd3User5ColumnIndex] = FonctionsType.getString(fpdRow[GlobalNames.sFPD_A_Column_User5]);
                newFPD3Row[fpd3User6ColumnIndex] = "";
                newFPD3Row[fpd3User7ColumnIndex] = "";
                newFPD3Row[fpd3User8ColumnIndex] = "";
                newFPD3Row[fpd3User9ColumnIndex] = "";
                newFPD3Row[fpd3User10ColumnIndex] = "";

                newFPD3Row[fpd3STDColumnIndex] = Math.Round(OverallTools.DataFunctions.MinuteDifference(simulationStartDate, flightDepartureDateAndTime), 2);

                if ((bool)fpdRow[GlobalNames.sFPD_Column_TSA])
                    newFPD3Row[fpd3TSAColumnIndex] = 1;
                else
                    newFPD3Row[fpd3TSAColumnIndex] = 0;

                #region check in
                newFPD3Row[fpd3CheckInTerminalColumnIndex] = FonctionsType.getInt(fpdRow[GlobalNames.sFPD_Column_TerminalCI]);
                newFPD3Row[fpd3CheckInEcoStartColumnIndex] = FonctionsType.getInt(fpdRow[GlobalNames.sFPD_Column_Eco_CI_Start]);
                newFPD3Row[fpd3CheckInEcoEndColumnIndex] = FonctionsType.getInt(fpdRow[GlobalNames.sFPD_Column_Eco_CI_End]);
                newFPD3Row[fpd3CheckInFBStartColumnIndex] = FonctionsType.getInt(fpdRow[GlobalNames.sFPD_Column_FB_CI_Start]);
                newFPD3Row[fpd3CheckInFBEndColumnIndex] = FonctionsType.getInt(fpdRow[GlobalNames.sFPD_Column_FB_CI_End]);

                DateTime ecoCheckInOpeningTime 
                    = flightDepartureDateAndTime.AddMinutes(-FonctionsType.getInt(dssCiValues[GlobalNames.sOCT_CI_Line_Opening], dssCiValues[GlobalNames.sOCT_CI_Line_Opening].GetType()));
                DateTime ecoCheckInClosingTime 
                    = flightDepartureDateAndTime.AddMinutes(-FonctionsType.getInt(dssCiValues[GlobalNames.sOCT_CI_Line_Closing], dssCiValues[GlobalNames.sOCT_CI_Line_Closing].GetType()));

                DateTime fbCheckInOpeningTime = flightDepartureDateAndTime.AddMinutes(-FonctionsType
                                                                .getInt(dssCiValues_FB[GlobalNames.sOCT_CI_Line_Opening],
                                                                        dssCiValues_FB[GlobalNames.sOCT_CI_Line_Opening].GetType()));
                DateTime fbCheckInClosingTime = flightDepartureDateAndTime.AddMinutes(-FonctionsType
                                                                .getInt(dssCiValues_FB[GlobalNames.sOCT_CI_Line_Closing],
                                                                        dssCiValues_FB[GlobalNames.sOCT_CI_Line_Closing].GetType()));

                if (ecoCheckInOpeningTime < simulationStartDate)
                {
                    newFPD3Row[fpd3CheckInEcoOpeningColumnIndex] = 0;
                }
                else
                {
                    newFPD3Row[fpd3CheckInEcoOpeningColumnIndex] = (int)((TimeSpan)ecoCheckInOpeningTime.Subtract(simulationStartDate)).TotalMinutes;
                }

                if (ecoCheckInClosingTime < simulationStartDate)
                {
                    newFPD3Row[fpd3CheckInEcoClosingColumnIndex] = 0;
                }
                else
                {
                    newFPD3Row[fpd3CheckInEcoClosingColumnIndex] = (int)((TimeSpan)ecoCheckInClosingTime.Subtract(simulationStartDate)).TotalMinutes;
                }
                if (fbCheckInOpeningTime < simulationStartDate)
                {
                    newFPD3Row[fpd3CheckInFBOpeningColumnIndex] = 0;
                }
                else
                {
                    newFPD3Row[fpd3CheckInFBOpeningColumnIndex]
                        = (int)((TimeSpan)fbCheckInOpeningTime.Subtract(simulationStartDate)).TotalMinutes; ;
                }
                if (fbCheckInClosingTime < simulationStartDate)
                {
                    newFPD3Row[fpd3CheckInFBClosingColumnIndex] = 0;
                }
                else
                {
                    newFPD3Row[fpd3CheckInFBClosingColumnIndex]
                        = (int)((TimeSpan)fbCheckInClosingTime.Subtract(simulationStartDate)).TotalMinutes; ;
                }
                #endregion

                #region bag drop
                newFPD3Row[fpd3BagDropEcoStartColumnIndex] = FonctionsType.getInt(fpdRow[GlobalNames.sFPD_Column_Eco_Drop_Start]);
                newFPD3Row[fpd3BagDropEcoEndColumnIndex] = FonctionsType.getInt(fpdRow[GlobalNames.sFPD_Column_Eco_Drop_End]);
                newFPD3Row[fpd3BagDropFBStartColumnIndex] = FonctionsType.getInt(fpdRow[GlobalNames.sFPD_Column_FB_Drop_Start]);
                newFPD3Row[fpd3BagDropFBEndColumnIndex] = FonctionsType.getInt(fpdRow[GlobalNames.sFPD_Column_FB_Drop_End]);
                              
                DateTime ecoBagDropOpeningTime
                    = flightDepartureDateAndTime.AddMinutes(-FonctionsType
                                                                .getInt(dssBDValues[GlobalNames.sOCT_BagDropOpening],
                                                                        dssBDValues[GlobalNames.sOCT_BagDropOpening].GetType()));
                DateTime ecoBagDropClosingTime
                    = flightDepartureDateAndTime.AddMinutes(-FonctionsType
                                                                .getInt(dssBDValues[GlobalNames.sOCT_BagDropClosing],
                                                                        dssBDValues[GlobalNames.sOCT_BagDropClosing].GetType()));

                DateTime fbBagDropOpeningTime = flightDepartureDateAndTime.AddMinutes(-FonctionsType
                                                                .getInt(dssBDValues_FB[GlobalNames.sOCT_BagDropOpening],
                                                                        dssBDValues_FB[GlobalNames.sOCT_BagDropOpening].GetType()));
                DateTime fbBagDropClosingTime = flightDepartureDateAndTime.AddMinutes(-FonctionsType
                                                                .getInt(dssBDValues_FB[GlobalNames.sOCT_BagDropClosing],
                                                                        dssBDValues_FB[GlobalNames.sOCT_BagDropClosing].GetType()));

                if (ecoBagDropOpeningTime < simulationStartDate)
                {
                    newFPD3Row[fpd3BagDropEcoOpeningColumnIndex] = 0;
                }
                else
                {
                    newFPD3Row[fpd3BagDropEcoOpeningColumnIndex] = (int)((TimeSpan)ecoBagDropOpeningTime.Subtract(simulationStartDate)).TotalMinutes;
                }

                if (ecoBagDropClosingTime < simulationStartDate)
                {
                    newFPD3Row[fpd3BagDropEcoClosingColumnIndex] = 0;
                }
                else
                {
                    newFPD3Row[fpd3BagDropEcoClosingColumnIndex] = (int)((TimeSpan)ecoBagDropClosingTime.Subtract(simulationStartDate)).TotalMinutes;
                }
                if (fbBagDropOpeningTime < simulationStartDate)
                {
                    newFPD3Row[fpd3BagDropFBOpeningColumnIndex] = 0;
                }
                else
                {
                    newFPD3Row[fpd3BagDropFBOpeningColumnIndex]
                        = (int)((TimeSpan)fbBagDropOpeningTime.Subtract(simulationStartDate)).TotalMinutes;
                }
                if (fbBagDropClosingTime < simulationStartDate)
                {
                    newFPD3Row[fpd3BagDropFBClosingColumnIndex] = 0;
                }
                else
                {
                    newFPD3Row[fpd3BagDropFBClosingColumnIndex]
                        = (int)((TimeSpan)fbBagDropClosingTime.Subtract(simulationStartDate)).TotalMinutes;
                }
                #endregion

                #region boarding gate
                newFPD3Row[fpd3BoardingGateTerminalColumnIndex] = FonctionsType.getInt(fpdRow[GlobalNames.sFPD_A_Column_TerminalGate]);
                newFPD3Row[fpd3BoardingGateEcoStartColumnIndex] = FonctionsType.getInt(fpdRow[GlobalNames.sFPD_Column_BoardingGate]);
                newFPD3Row[fpd3BoardingGateEcoEndColumnIndex] = FonctionsType.getInt(fpdRow[GlobalNames.sFPD_Column_BoardingGate]);
                newFPD3Row[fpd3BoardingGateFBStartColumnIndex] = FonctionsType.getInt(fpdRow[GlobalNames.sFPD_Column_BoardingGate]);
                newFPD3Row[fpd3BoardingGateFBEndColumnIndex] = FonctionsType.getInt(fpdRow[GlobalNames.sFPD_Column_BoardingGate]);

                DateTime ecoBoardingGateOpeningTime
                    = flightDepartureDateAndTime.AddMinutes(-FonctionsType.getInt(dssBGValues[GlobalNames.sOCT_Board_Line_Opening], dssBGValues[GlobalNames.sOCT_Board_Line_Opening].GetType()));
                DateTime ecoBoardingGateClosingTime
                    = flightDepartureDateAndTime.AddMinutes(-FonctionsType.getInt(dssBGValues[GlobalNames.sOCT_Board_Line_Closing], dssBGValues[GlobalNames.sOCT_Board_Line_Closing].GetType()));

                DateTime fbBoardingGateOpeningTime = flightDepartureDateAndTime.AddMinutes(-FonctionsType
                                                                .getInt(dssBGValues_FB[GlobalNames.sOCT_Board_Line_Opening],
                                                                        dssBGValues_FB[GlobalNames.sOCT_Board_Line_Opening].GetType()));
                DateTime fbBoardingGateClosingTime = flightDepartureDateAndTime.AddMinutes(-FonctionsType
                                                                .getInt(dssBGValues_FB[GlobalNames.sOCT_Board_Line_Closing],
                                                                        dssBGValues_FB[GlobalNames.sOCT_Board_Line_Closing].GetType()));

                if (ecoBoardingGateOpeningTime < simulationStartDate)
                {
                    newFPD3Row[fpd3BoardingGateEcoOpeningColumnIndex] = 0;
                }
                else
                {
                    newFPD3Row[fpd3BoardingGateEcoOpeningColumnIndex] = (int)((TimeSpan)ecoBoardingGateOpeningTime.Subtract(simulationStartDate)).TotalMinutes;
                }

                if (ecoBoardingGateClosingTime < simulationStartDate)
                {
                    newFPD3Row[fpd3BoardingGateEcoClosingColumnIndex] = 0;
                }
                else
                {
                    newFPD3Row[fpd3BoardingGateEcoClosingColumnIndex] = (int)((TimeSpan)ecoBoardingGateClosingTime.Subtract(simulationStartDate)).TotalMinutes;
                }
                if (fbBoardingGateOpeningTime < simulationStartDate)
                {
                    newFPD3Row[fpd3BoardingGateFBOpeningColumnIndex] = 0;
                }
                else
                {
                    newFPD3Row[fpd3BoardingGateFBOpeningColumnIndex]
                        = (int)((TimeSpan)fbBoardingGateOpeningTime.Subtract(simulationStartDate)).TotalMinutes;
                }
                if (fbBoardingGateClosingTime < simulationStartDate)
                {
                    newFPD3Row[fpd3BoardingGateFBClosingColumnIndex] = 0;
                }
                else
                {
                    newFPD3Row[fpd3BoardingGateFBClosingColumnIndex]
                        = (int)((TimeSpan)fbBoardingGateClosingTime.Subtract(simulationStartDate)).TotalMinutes;
                }
                #endregion

                #region make up
                newFPD3Row[fpd3MakeUpTerminalColumnIndex] = FonctionsType.getInt(fpdRow[GlobalNames.sFPD_Column_TerminalMup]);
                newFPD3Row[fpd3MakeUpEcoStartColumnIndex] = FonctionsType.getInt(fpdRow[GlobalNames.sFPD_Column_Eco_Mup_Start]);
                newFPD3Row[fpd3MakeUpEcoEndColumnIndex] = FonctionsType.getInt(fpdRow[GlobalNames.sFPD_Column_Eco_Mup_End]);
                newFPD3Row[fpd3MakeUpFBStartColumnIndex] = FonctionsType.getInt(fpdRow[GlobalNames.sFPD_Column_First_Mup_Start]);
                newFPD3Row[fpd3MakeUpFBEndColumnIndex] = FonctionsType.getInt(fpdRow[GlobalNames.sFPD_Column_First_Mup_End]);
                
                DateTime makeUpOpeningTime = flightDepartureDateAndTime
                    .AddMinutes(-FonctionsType.getInt(dssMakeUpValues[GlobalNames.sOCT_MakeUpOpening], dssMakeUpValues[GlobalNames.sOCT_MakeUpOpening].GetType()));
                DateTime makeUpClosingTime = flightDepartureDateAndTime
                    .AddMinutes(-FonctionsType.getInt(dssMakeUpValues[GlobalNames.sOCT_MakeUpClosing], dssMakeUpValues[GlobalNames.sOCT_MakeUpClosing].GetType()));
                                
                if (makeUpOpeningTime < simulationStartDate)
                {
                    newFPD3Row[fpd3MakeUpOpeningColumnIndex] = 0;
                }
                else
                {
                    newFPD3Row[fpd3MakeUpOpeningColumnIndex] = (int)((TimeSpan)makeUpOpeningTime.Subtract(simulationStartDate)).TotalMinutes;
                }

                if (makeUpClosingTime < simulationStartDate)
                {
                    newFPD3Row[fpd3MakeUpClosingColumnIndex] = 0;
                }
                else
                {
                    newFPD3Row[fpd3MakeUpClosingColumnIndex] = (int)((TimeSpan)makeUpClosingTime.Subtract(simulationStartDate)).TotalMinutes;
                }

                DateTime makeUpEBSDeliveryTime = flightDepartureDateAndTime
                    .AddMinutes(-FonctionsType.getInt(dssMakeUpValues[GlobalNames.sOCT_MakeUpEBS_Delivery], dssMakeUpValues[GlobalNames.sOCT_MakeUpEBS_Delivery].GetType()));
                if (makeUpEBSDeliveryTime < simulationStartDate)
                {
                    newFPD3Row[fpd3MakeUpEBSDeliveryTimeColumnIndex] = 0;
                }
                else
                {
                    newFPD3Row[fpd3MakeUpEBSDeliveryTimeColumnIndex] = (int)((TimeSpan)makeUpEBSDeliveryTime.Subtract(simulationStartDate)).TotalMinutes;
                }
                
                int makeUpSegregationNb
                    = FonctionsType.getInt(dssMakeUpValues[GlobalNames.sOCT_MakeUpSegregationNumber], dssMakeUpValues[GlobalNames.sOCT_MakeUpSegregationNumber].GetType());
                newFPD3Row[fpd3MakeUpSegregationNbColumnIndex] = makeUpSegregationNb;

                int makeUpContainerSize
                    = FonctionsType.getInt(dssMakeUpValues[GlobalNames.sOCT_MakeUpContainerSize], dssMakeUpValues[GlobalNames.sOCT_MakeUpContainerSize].GetType());
                newFPD3Row[fpd3MakeUpContainerSizeColumnIndex] = makeUpContainerSize;

                int makeUpDeadTime
                    = FonctionsType.getInt(dssMakeUpValues[GlobalNames.sOCT_MakeUpDeadTime], dssMakeUpValues[GlobalNames.sOCT_MakeUpDeadTime].GetType());
                newFPD3Row[fpd3MakeUpDeadTimeColumnIndex] = makeUpDeadTime;

                int makeUpNbContPerLateral
                    = FonctionsType.getInt(dssMakeUpValues[GlobalNames.sOCT_MakeUpNumberContainerLateral], dssMakeUpValues[GlobalNames.sOCT_MakeUpNumberContainerLateral].GetType());
                newFPD3Row[fpd3MakeUpNbContPerLateralColumnIndex] = makeUpNbContPerLateral;
                int mupLateTime
                    = FonctionsType.getInt(dssMakeUpValues[GlobalNames.OCT_MAKE_UP_LATE_TIME_COLUMN_NAME], dssMakeUpValues[GlobalNames.OCT_MAKE_UP_LATE_TIME_COLUMN_NAME].GetType());
                newFPD3Row[fpd3MakeUpLateTimeColumnIndex] = mupLateTime;
                #endregion

                fpd3ForAutomod.Rows.Add(newFPD3Row);
            }
            if (bUseAlpha)
                dtTmp.Dispose();
            return fpd3ForAutomod;
        }
        // << Task #13361 FP AutoMod Data tables V3

        internal static DataTable calcOCT_FPA(DataTable FPATable,
                                     NormalTable OCTBaggageClaimTable,
                                     List<String> lsOrderAirline,
                                     List<String> lsOrderFlightCategory,
                                     DateTime debutSimulation,
                                     XmlNode xnStructure,
                                     bool bUseAlpha)
        {
            if ((FPATable == null) || OCTBaggageClaimTable == null)
                return null;

            if (!(OCTBaggageClaimTable is ExceptionTable))
                return null;
            ExceptionTable etOCTBGTable = (ExceptionTable)OCTBaggageClaimTable;
            DataTable dtTmp = FPATable;
            if (bUseAlpha)
                dtTmp = ConvertFPAInformations(FPATable, xnStructure, false, false);
            if (dtTmp == null)
                return null;
            DataTable simpleFPA = new DataTable("simpleFPA");
            simpleFPA.Columns.Add("Id", System.Type.GetType("System.Int32"));
            simpleFPA.Columns.Add("OpeningBaggageClaim", System.Type.GetType("System.Int32"));
            simpleFPA.Columns.Add("ClosingBaggageClaim", System.Type.GetType("System.Int32"));

            simpleFPA.Columns.Add("ArrivalGateTerminal", System.Type.GetType("System.Int32"));
            simpleFPA.Columns.Add("IndexArrivalGate", System.Type.GetType("System.Int32"));

            simpleFPA.Columns.Add("BaggageClaimTerminal", System.Type.GetType("System.Int32"));
            simpleFPA.Columns.Add("IndexBaggageClaim", System.Type.GetType("System.Int32"));

            simpleFPA.Columns.Add("FlightCategory", System.Type.GetType("System.Int32"));

            simpleFPA.Columns.Add("InfeedsTerminal", System.Type.GetType("System.Int32"));
            simpleFPA.Columns.Add("ArrivalInfeedStart", System.Type.GetType("System.Int32"));
            simpleFPA.Columns.Add("ArrivalInfeedEnd", System.Type.GetType("System.Int32"));
            simpleFPA.Columns.Add("TransferInfeed", System.Type.GetType("System.Int32"));
            simpleFPA.Columns.Add("ParkingTerminal", System.Type.GetType("System.Int32"));
            simpleFPA.Columns.Add("Parking", System.Type.GetType("System.Int32"));
            simpleFPA.Columns.Add("RunWay", System.Type.GetType("System.Int32"));
            simpleFPA.Columns.Add("No BSM", System.Type.GetType("System.Int32"));
            simpleFPA.Columns.Add("CBP", System.Type.GetType("System.Int32"));
            simpleFPA.Columns.Add("Airline", System.Type.GetType("System.Int32"));

            //int iIndexOpeningBaggage = OverallTools.DataFunctions.indexLigne(OCTBaggageClaimTable, 0, GlobalNames.sOCT_Baggage_Line_Opening);
            //int iIndexClosingBaggage = OverallTools.DataFunctions.indexLigne(OCTBaggageClaimTable, 0, GlobalNames.sOCT_Baggage_Line_Closing);

            /*if ((iIndexOpeningBaggage == -1) ||
                (iIndexClosingBaggage == -1))
            {
                return null;
            }*/

            int iIndexFC = dtTmp.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightCategory);
            int iIndexAirline = dtTmp.Columns.IndexOf(GlobalNames.sFPD_A_Column_AirlineCode);
            if ((iIndexFC == -1) || (iIndexAirline == -1))
                return null;

            foreach (DataRow Row in dtTmp.Rows)
            {
                DataRow newLine = simpleFPA.NewRow();

                newLine[0] = FonctionsType.getInt(Row[GlobalNames.sFPD_A_Column_ID], Row[GlobalNames.sFPD_A_Column_ID].GetType());

                String flightId = "A_" + newLine[0].ToString();         // << Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop
                String sCategorieVol = Row.ItemArray[iIndexFC].ToString();
                String sAirline = Row.ItemArray[iIndexAirline].ToString();

                Dictionary<String, String> dssBGTable = etOCTBGTable.GetInformationsColumns(0, flightId, sAirline, sCategorieVol); // << Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop
                if (dssBGTable == null)
                    continue;
                // On détermine l'heure d'ouverture et de fermeture de la ressource pour le vol.
                int iIndexBaggageClaim = lsOrderFlightCategory.IndexOf(sCategorieVol);
                //The indexes in Automod starts at 1 (not 0).
                if (iIndexBaggageClaim>= 0)
                    iIndexBaggageClaim++;
                int iAirline = lsOrderAirline.IndexOf(sAirline);
                //The indexes in Automod starts at 1 (not 0).
                if (iAirline >= 0)
                    iAirline++;

                //On détermine l'heure d'arrivée du vol.
                DateTime dtJourHeureArrivee = OverallTools.DataFunctions.toDateTime(Row[GlobalNames.sFPD_A_Column_DATE], Row[GlobalNames.sFPA_Column_STA]);
                if (dtJourHeureArrivee < debutSimulation)
                    continue;

                newLine["FlightCategory"] = iIndexBaggageClaim;

                newLine["ArrivalGateTerminal"] = FonctionsType.getInt(Row[GlobalNames.sFPD_A_Column_TerminalGate]);
                newLine["IndexArrivalGate"] = FonctionsType.getInt(Row[GlobalNames.sFPA_Column_ArrivalGate]);
                newLine["BaggageClaimTerminal"] =FonctionsType.getInt( Row[GlobalNames.sFPA_Column_TerminalReclaim]);
                newLine["IndexBaggageClaim"] = FonctionsType.getInt(Row[GlobalNames.sFPA_Column_ReclaimObject]);

                newLine["InfeedsTerminal"] = FonctionsType.getInt(Row[GlobalNames.sFPA_Column_TerminalInfeedObject]);
                newLine["ArrivalInfeedStart"] = FonctionsType.getInt(Row[GlobalNames.sFPA_Column_StartArrivalInfeedObject]);
                newLine["ArrivalInfeedEnd"] = FonctionsType.getInt(Row[GlobalNames.sFPA_Column_EndArrivalInfeedObject]);
                newLine["TransferInfeed"] =FonctionsType.getInt(Row[GlobalNames.sFPA_Column_TransferInfeedObject]);
                newLine["ParkingTerminal"] = FonctionsType.getInt(Row[GlobalNames.sFPD_A_Column_TerminalParking]);
                newLine["Parking"] =FonctionsType.getInt( Row[GlobalNames.sFPD_A_Column_Parking]);
                newLine["RunWay"] = FonctionsType.getInt(Row[GlobalNames.sFPD_A_Column_RunWay]);

                if ((bool)Row[GlobalNames.sFPA_Column_NoBSM])
                    newLine["No BSM"] = 1;
                else
                    newLine["No BSM"] = 0;
                if ((bool)Row[GlobalNames.sFPA_Column_CBP])
                    newLine["CBP"] = 1;
                else
                    newLine["CBP"] = 0;
                newLine["Airline"] = iAirline;
                DateTime heureOuvertureBaggageClaim = dtJourHeureArrivee.AddMinutes(FonctionsType.getInt(dssBGTable[GlobalNames.sOCT_Baggage_Line_Opening], dssBGTable[GlobalNames.sOCT_Baggage_Line_Opening].GetType()));
                DateTime heureFermetureBaggageClaim = dtJourHeureArrivee.AddMinutes(FonctionsType.getInt(dssBGTable[GlobalNames.sOCT_Baggage_Line_Closing], dssBGTable[GlobalNames.sOCT_Baggage_Line_Closing].GetType()));

                if (heureOuvertureBaggageClaim < debutSimulation)
                {
                    newLine[1] = 0;
                }
                else
                {
                    newLine[1] = (int)((TimeSpan)heureOuvertureBaggageClaim.Subtract(debutSimulation)).TotalMinutes;
                }

                if (heureFermetureBaggageClaim < debutSimulation)
                {
                    newLine[2] = 0;
                }
                else
                {
                    newLine[2] = (int)((TimeSpan)heureFermetureBaggageClaim.Subtract(debutSimulation)).TotalMinutes;
                }

                simpleFPA.Rows.Add(newLine);
            }
            if (bUseAlpha)
                dtTmp.Dispose();
            return simpleFPA;
        }

        // >> Task #13361 FP AutoMod Data tables V3
        internal const String FPA_TABLE_3_FOR_AUTOMOD_TABLE_NAME = "FPA_Table_3";
        internal const String FPA_TABLE_3_FOR_AUTOMOD_PAX2SIM_TABLE_NAME = "FPA_Table";
        internal static DataTable getFPATable3ForAutomod(DataTable arrivalFlightPlanTable, NormalTable octBaggageClaimTable,
             List<String> airlinesList, List<String> flightCategoriesList, List<String> aircraftTypesList,
             DateTime simulationStartDate, XmlNode xnStructure, bool bUseAlpha)
        {
            if ((arrivalFlightPlanTable == null) || octBaggageClaimTable == null)
                return null;

            if (!(octBaggageClaimTable is ExceptionTable))
                return null;

            ExceptionTable etOCTBGTable = (ExceptionTable)octBaggageClaimTable;
            DataTable dtTmp = arrivalFlightPlanTable;

            if (bUseAlpha)
                dtTmp = ConvertFPAInformations(arrivalFlightPlanTable, xnStructure, false, false);
            if (dtTmp == null)
                return null;

            DataTable fpa3ForAutomod = new DataTable(FPA_TABLE_3_FOR_AUTOMOD_PAX2SIM_TABLE_NAME);

            int fpa3IdColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("Id", typeof(Int32));

            int fpa3FlightNColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("FlightN", typeof(String));

            int fpa3AirlineIdColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("Airline_Id", typeof(Int32));
            int fpa3AirlineColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("Airline", typeof(String));

            int fpa3FlightCategoryIdColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("FlightCategory_Id", typeof(Int32));
            int fpa3FlightCategoryColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("FlightCategory", typeof(String));

            int fpa3AircraftTypeIdColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("AircraftType_Id", typeof(Int32));
            int fpa3AircraftTypeColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("AircraftType", typeof(String));

            int fpa3ParkingTerminalColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("Parking_Terminal", typeof(Int32));
            int fpa3ParkingStartColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("Parking_IndexStart", typeof(Int32));
            int fpa3ParkingEndColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("Parking_IndexEnd", typeof(Int32));

            int fpa3RunwayColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("RunWay", typeof(Int32));

            int fpa3User1ColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("User01", typeof(String));
            int fpa3User2ColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("User02", typeof(String));
            int fpa3User3ColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("User03", typeof(String));
            int fpa3User4ColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("User04", typeof(String));
            int fpa3User5ColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("User05", typeof(String));
            int fpa3User6ColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("User06", typeof(String));
            int fpa3User7ColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("User07", typeof(String));
            int fpa3User8ColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("User08", typeof(String));
            int fpa3User9ColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("User09", typeof(String));
            int fpa3User10ColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("User10", typeof(String));

            int fpa3STAColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("STA", typeof(Int32));

            int fpa3NoBSMColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("NoBSM", typeof(Int32));
            int fpa3CBPColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("CBP", typeof(Int32));

            int fpa3ArrivalGateTerminalColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("ArrivalGate_Terminal", typeof(Int32));
            int fpa3ArrivalGateStartColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("ArrivalGate_IndexStart", typeof(Int32));
            int fpa3ArrivalGateEndColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("ArrivalGate_IndexEnd", typeof(Int32));

            int fpa3BagClaimTerminalColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("BaggageClaim_Terminal", typeof(Int32));
            int fpa3BagClaimStartColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("BaggageClaim_IndexStart", typeof(Int32));
            int fpa3BagClaimEndColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("BaggageClaim_IndexEnd", typeof(Int32));

            int fpa3BagClaimOpeningColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("BaggageClaim_Opening", typeof(Int32));
            int fpa3BagClaimClosingColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("BaggageClaim_Closing", typeof(Int32));

            int fpa3InfeedsTerminalColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("Infeeds_Terminal", typeof(Int32));
            
            int fpa3ArrInfeedStartColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("InfeedArr_IndexStart", typeof(Int32));
            int fpa3ArrInfeedEndColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("InfeedArr_IndexEnd", typeof(Int32));

            int fpa3TransfInfeedStartColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("InfeedTr_IndexStart", typeof(Int32));
            int fpa3TransfInfeedEndColumnIndex = fpa3ForAutomod.Columns.Count;
            fpa3ForAutomod.Columns.Add("InfeedTr_IndexEnd", typeof(Int32));


            int flightPlanFlightCategoryColumnIndex = dtTmp.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightCategory);
            int flightPlanAirlineColumnIndex = dtTmp.Columns.IndexOf(GlobalNames.sFPD_A_Column_AirlineCode);
            int flightPlanFlightNColumnIndex = dtTmp.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightN);
            int flightPlanAircraftTypeColumnIndex = dtTmp.Columns.IndexOf(GlobalNames.sFPD_A_Column_AircraftType);

            int flightPlanFlightDateColumnIndex = dtTmp.Columns.IndexOf(GlobalNames.sFPD_A_Column_DATE);
            int flightPlanFlightTimeColumnIndex = dtTmp.Columns.IndexOf(GlobalNames.sFPA_Column_STA);

            if (flightPlanFlightCategoryColumnIndex == -1 || flightPlanAirlineColumnIndex == -1
                || flightPlanAircraftTypeColumnIndex == -1 || flightPlanFlightNColumnIndex == -1
                || flightPlanFlightDateColumnIndex == -1 || flightPlanFlightTimeColumnIndex == -1)
            {
                return null;
            }

            foreach (DataRow flightPlanRow in dtTmp.Rows)
            {
                DataRow newFP3Row = fpa3ForAutomod.NewRow();

                int flightId = FonctionsType.getInt(flightPlanRow[GlobalNames.sFPD_A_Column_ID], flightPlanRow[GlobalNames.sFPD_A_Column_ID].GetType());
                if (flightId <= 0)
                    continue;
                                
                String flightIdWithPrefix = "A_" + flightId.ToString();
                String flightCategory = flightPlanRow.ItemArray[flightPlanFlightCategoryColumnIndex].ToString();
                String airlineCode = flightPlanRow.ItemArray[flightPlanAirlineColumnIndex].ToString();
                String aircraftType = flightPlanRow.ItemArray[flightPlanAircraftTypeColumnIndex].ToString();
                String flightNb = flightPlanRow.ItemArray[flightPlanFlightNColumnIndex].ToString();

                Dictionary<String, String> dssBGTable = etOCTBGTable.GetInformationsColumns(0, flightIdWithPrefix, airlineCode, flightCategory); // << Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop
                if (dssBGTable == null)
                    continue;
                // On détermine l'heure d'ouverture et de fermeture de la ressource pour le vol.
                int flightCategoryIndex = flightCategoriesList.IndexOf(flightCategory);
                //The indexes in Automod starts at 1 (not 0).
                if (flightCategoryIndex >= 0)
                    flightCategoryIndex++;
                int airlineIndex = airlinesList.IndexOf(airlineCode);
                //The indexes in Automod starts at 1 (not 0).
                if (airlineIndex >= 0)
                    airlineIndex++;
                int aircraftTypeIndex = aircraftTypesList.IndexOf(aircraftType);
                if (aircraftTypeIndex >= 0)
                    aircraftTypeIndex++;

                //On détermine l'heure d'arrivée du vol.
                DateTime flightArrivalDateAndTime = OverallTools.DataFunctions.toDateTime(flightPlanRow[GlobalNames.sFPD_A_Column_DATE], flightPlanRow[GlobalNames.sFPA_Column_STA]);
                if (flightArrivalDateAndTime < simulationStartDate)
                    continue;

                newFP3Row[fpa3IdColumnIndex] = flightId;
                newFP3Row[fpa3FlightNColumnIndex] = flightNb;

                newFP3Row[fpa3AirlineIdColumnIndex] = airlineIndex;
                newFP3Row[fpa3AirlineColumnIndex] = airlineCode;

                newFP3Row[fpa3FlightCategoryIdColumnIndex] = flightCategoryIndex;
                newFP3Row[fpa3FlightCategoryColumnIndex] = flightCategory;

                newFP3Row[fpa3AircraftTypeIdColumnIndex] = aircraftTypeIndex;
                newFP3Row[fpa3AircraftTypeColumnIndex] = aircraftType;

                newFP3Row[fpa3ParkingTerminalColumnIndex] = FonctionsType.getInt(flightPlanRow[GlobalNames.sFPD_A_Column_TerminalParking]);
                newFP3Row[fpa3ParkingStartColumnIndex] = FonctionsType.getInt(flightPlanRow[GlobalNames.sFPD_A_Column_Parking]);
                newFP3Row[fpa3ParkingEndColumnIndex] = FonctionsType.getInt(flightPlanRow[GlobalNames.sFPD_A_Column_Parking]);

                newFP3Row[fpa3RunwayColumnIndex] = FonctionsType.getInt(flightPlanRow[GlobalNames.sFPD_A_Column_RunWay]);

                newFP3Row[fpa3User1ColumnIndex] = FonctionsType.getString(flightPlanRow[GlobalNames.sFPD_A_Column_User1]);
                newFP3Row[fpa3User2ColumnIndex] = FonctionsType.getString(flightPlanRow[GlobalNames.sFPD_A_Column_User2]);
                newFP3Row[fpa3User3ColumnIndex] = FonctionsType.getString(flightPlanRow[GlobalNames.sFPD_A_Column_User3]);
                newFP3Row[fpa3User4ColumnIndex] = FonctionsType.getString(flightPlanRow[GlobalNames.sFPD_A_Column_User4]);
                newFP3Row[fpa3User5ColumnIndex] = FonctionsType.getString(flightPlanRow[GlobalNames.sFPD_A_Column_User5]);
                newFP3Row[fpa3User6ColumnIndex] = "";
                newFP3Row[fpa3User7ColumnIndex] = "";
                newFP3Row[fpa3User8ColumnIndex] = "";
                newFP3Row[fpa3User9ColumnIndex] = "";
                newFP3Row[fpa3User10ColumnIndex] = "";

                newFP3Row[fpa3STAColumnIndex] = Math.Round(OverallTools.DataFunctions.MinuteDifference(simulationStartDate, flightArrivalDateAndTime), 2);               

                if ((bool)flightPlanRow[GlobalNames.sFPA_Column_NoBSM])
                    newFP3Row[fpa3NoBSMColumnIndex] = 1;
                else
                    newFP3Row[fpa3NoBSMColumnIndex] = 0;

                if ((bool)flightPlanRow[GlobalNames.sFPA_Column_CBP])
                    newFP3Row[fpa3CBPColumnIndex] = 1;
                else
                    newFP3Row[fpa3CBPColumnIndex] = 0;

                newFP3Row[fpa3ArrivalGateTerminalColumnIndex] = FonctionsType.getInt(flightPlanRow[GlobalNames.sFPD_A_Column_TerminalGate]);
                newFP3Row[fpa3ArrivalGateStartColumnIndex] = FonctionsType.getInt(flightPlanRow[GlobalNames.sFPA_Column_ArrivalGate]);
                newFP3Row[fpa3ArrivalGateEndColumnIndex] = FonctionsType.getInt(flightPlanRow[GlobalNames.sFPA_Column_ArrivalGate]);

                newFP3Row[fpa3BagClaimTerminalColumnIndex] = FonctionsType.getInt(flightPlanRow[GlobalNames.sFPA_Column_TerminalReclaim]);
                newFP3Row[fpa3BagClaimStartColumnIndex] = FonctionsType.getInt(flightPlanRow[GlobalNames.sFPA_Column_ReclaimObject]);
                newFP3Row[fpa3BagClaimEndColumnIndex] = FonctionsType.getInt(flightPlanRow[GlobalNames.sFPA_Column_ReclaimObject]);

                DateTime bagClaimOpeningTime = flightArrivalDateAndTime.AddMinutes(FonctionsType.getInt(dssBGTable[GlobalNames.sOCT_Baggage_Line_Opening], dssBGTable[GlobalNames.sOCT_Baggage_Line_Opening].GetType()));
                DateTime bagClaimClosingTime = flightArrivalDateAndTime.AddMinutes(FonctionsType.getInt(dssBGTable[GlobalNames.sOCT_Baggage_Line_Closing], dssBGTable[GlobalNames.sOCT_Baggage_Line_Closing].GetType()));

                if (bagClaimOpeningTime < simulationStartDate)
                {
                    newFP3Row[fpa3BagClaimOpeningColumnIndex] = 0;
                }
                else
                {
                    newFP3Row[fpa3BagClaimOpeningColumnIndex] = (int)((TimeSpan)bagClaimOpeningTime.Subtract(simulationStartDate)).TotalMinutes;
                }

                if (bagClaimClosingTime < simulationStartDate)
                {
                    newFP3Row[fpa3BagClaimClosingColumnIndex] = 0;
                }
                else
                {
                    newFP3Row[fpa3BagClaimClosingColumnIndex] = (int)((TimeSpan)bagClaimClosingTime.Subtract(simulationStartDate)).TotalMinutes;
                }

                newFP3Row[fpa3InfeedsTerminalColumnIndex] = FonctionsType.getInt(flightPlanRow[GlobalNames.sFPA_Column_TerminalInfeedObject]);
                newFP3Row[fpa3ArrInfeedStartColumnIndex] = FonctionsType.getInt(flightPlanRow[GlobalNames.sFPA_Column_StartArrivalInfeedObject]);
                newFP3Row[fpa3ArrInfeedEndColumnIndex] = FonctionsType.getInt(flightPlanRow[GlobalNames.sFPA_Column_EndArrivalInfeedObject]);
                newFP3Row[fpa3TransfInfeedStartColumnIndex] = FonctionsType.getInt(flightPlanRow[GlobalNames.sFPA_Column_TransferInfeedObject]);
                newFP3Row[fpa3TransfInfeedEndColumnIndex] = FonctionsType.getInt(flightPlanRow[GlobalNames.sFPA_Column_TransferInfeedObject]);
                                
                fpa3ForAutomod.Rows.Add(newFP3Row);
            }
            if (bUseAlpha)
                dtTmp.Dispose();
            return fpa3ForAutomod;
        }
        // << Task #13361 FP AutoMod Data tables V3
        #endregion

        #region Fonction pour le calcul du flux de passagers
        /// <summary>
        /// Fonction qui se charge de générer le flot de passagers et le fichier de transfert.
        /// </summary>
        /// <param name="tableName">Nom de la table que l'on souhaite générer</param>
        /// <param name="Pax_GenTransferLog">La table pour les log des transferts</param>
        /// <param name="debutSimulation">La date et l'heure de la simulation</param>
        /// <param name="finSimulation">L'heure de fin de la simulation</param>
        /// <param name="bGenerateAllPax">La façon de se comporter face aux passagers qui sont en dehors de la plage</param>
        /// <param name="FPA">La table des plans de vols arrivées</param>
        /// <param name="FPD">La table des plans de vols départs</param>
        /// <param name="FPAircraftType">La table des caractéristiques des avions</param>
        /// <param name="FPFlightCategories">La table des catégories de vol</param>
        /// <param name="FPALoadFactors">La table des facteurs de chargement des vols arrivée</param>
        /// <param name="FPDLoadFactors">La table des facteurs de chargement des vols départs</param>
        /// <param name="InterConnectingTimes">La table des temps de transferts</param>
        /// <param name="NbBags">La table du nombre de bagages par passager</param>
        /// <param name="NbVisitors">La table du nombre d'accompagnateurs par passagers</param>
        /// <param name="CI_ShowUp">La table des présentations des passagers</param>
        /// <param name="Seed">Les données dinitialisation des variables aléatoires</param>
        /// <returns>La table des flots de passagers</returns>
        internal static DataTable effectuerCalculPaxPlan(String tableName,
            out DataTable Pax_GenTransferLog,
            out DataTable dtFPDBags,
            out DataTable dtFPABags,
            out DataTable dtFPDPassengers,
            out DataTable dtFPAPassengers,
            #region //SGE-26/03/2012-Begin
            ref DataTable dtPRKPlan,
            out Hashtable htPRKTrace,
            out List<String> lsNamesForPRKTrace,
            #endregion //SGE-26/03/2012-Begin
            DateTime debutSimulation,
            DateTime finSimulation,
            bool bTransferArrivalGeneration,
            bool bFillTransfer,
            bool bGenerateAllPax,
            DataTable FPA,
            DataTable FPD,
            DataTable TransferTerminalDistribution,
            DataTable TransferFlightCategoryDistribution,
            DataManagement.NormalTable FPAircraftType,
            DataTable FPFlightCategories,
            DataManagement.NormalTable FPALoadFactors,
            DataManagement.NormalTable FPDLoadFactors,
            DataManagement.NormalTable InterConnectingTimes,
            DataManagement.NormalTable NbBags,
            DataManagement.NormalTable NbVisitors,
            DataManagement.NormalTable NbTrolley,
            DataManagement.NormalTable CI_ShowUp,
#if(PAXINOUTUTILISATION)
            DataManagement.NormalTable ntPaxInDistrib,
            DataManagement.NormalTable ntPaxOutDistrib,
#endif
            #region //SGE-26/03/2012-Begin
            ParamScenario psTmp,
            GestionDonneesHUB2SIM Donnees,
            DataTable etInitialState,
            DataManagement.ExceptionTable etShortStay,
            DataManagement.ExceptionTable etLongStay,
            #endregion //SGE-26/03/2012-Begin
            DataManagement.NormalTable dtSegregation,
            int Seed,
            List<FlightConfiguration> userDefinedFlightConfigurations,
            Prompt.SIM_LoadingForm cht)
        {
            Pax_GenTransferLog = null;
            dtFPDBags = null;
            dtFPABags = null;
            dtFPAPassengers = null;
            dtFPDPassengers = null;
            htPRKTrace = null;
            lsNamesForPRKTrace = null;
            OverallTools.StaticAnalysis.PaxPlanClass ppcPaxPlanGenerator =
                new OverallTools.StaticAnalysis.PaxPlanClass(debutSimulation,
                finSimulation, 
                bTransferArrivalGeneration, 
                bFillTransfer, 
                bGenerateAllPax, 
                FPA, 
                FPD, 
                TransferTerminalDistribution, 
                TransferFlightCategoryDistribution,
                FPAircraftType, 
                FPFlightCategories, 
                FPALoadFactors, 
                FPDLoadFactors,
                CI_ShowUp, 
                InterConnectingTimes, 
                NbBags, 
                NbVisitors, 
                NbTrolley,
#if(PAXINOUTUTILISATION)
                ntPaxInDistrib,
                ntPaxOutDistrib,
#endif
                Seed,
                ListeErreurs, cht,
                // << Task #8667 Pax2Sim - PaxPlan not showing departure pax with flights that have STD after the end of simulation                
                psTmp.GenerateFlightsAtEnd
                // >> Task #8667 Pax2Sim - PaxPlan not showing departure pax with flights that have STD after the end of simulation
                , Donnees,   // >> Task #10764 Pax2Sim - new User attributes for Groups
                userDefinedFlightConfigurations,
                psTmp
                );
            //<< Task #7405 - new Desk and extra information for Pax            
            //call the distrib tables function
            setsUserAttributesTables(ppcPaxPlanGenerator, Donnees,
                psTmp.userAttributesTablesDictionary);  // << Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab
            //>> Task #7405 - new Desk and extra information for Pax
            if (!ppcPaxPlanGenerator.effectuerCalculPaxPlan())
                return null;
            ppcPaxPlanGenerator.AllocateSegregation(dtSegregation, Seed * 12);
            Pax_GenTransferLog = ppcPaxPlanGenerator.Pax_GenTransferLog;
            dtFPDBags = ppcPaxPlanGenerator.FPDBags;
            dtFPABags = ppcPaxPlanGenerator.FPABags;
            dtFPAPassengers = ppcPaxPlanGenerator.FPAPassengers;
            dtFPDPassengers = ppcPaxPlanGenerator.FPDPassengers;
            if ((!psTmp.UseExistingPRKPlan)&&(etInitialState != null))
            {
                dtPRKPlan = ppcPaxPlanGenerator.PrkPlanTable;
            }
            if ((dtPRKPlan != null) && (etInitialState != null))
            {
                htPRKTrace = OverallTools.StaticAnalysis.PRKTrace.GenerateAndAnalysePRKTrace(debutSimulation,
                    finSimulation,psTmp.SamplingStep,1,31,Donnees, dtPRKPlan, FPD, FPA, etShortStay, etLongStay, etInitialState, Seed, cht,
                    out lsNamesForPRKTrace, psTmp.AnalysisRange, psTmp.percentilesLevels);   // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
            }
                                               
            return ppcPaxPlanGenerator.PaxPlanTable;
        }

        //<< Task #7405 - new Desk and extra information for Pax
        private static void setsUserAttributesTables(OverallTools.StaticAnalysis.PaxPlanClass ppcPaxPlanGenerator,
            GestionDonneesHUB2SIM donnees, Dictionary<String, String> userAttributesDictionaryParam) // << Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab
        {
            Dictionary<string, NormalTable> distributionTables = new Dictionary<string, NormalTable>();
            DataTable userAttributesTable = donnees.getTable("Input", GlobalNames.sUserAttributesTableName);
            if (userAttributesTable.Rows.Count > 0)
            {
                // << Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab
                if (userAttributesDictionaryParam != null)
                {
                    foreach (KeyValuePair<String, String> pair in userAttributesDictionaryParam)
                    {
                        String userAttributeName = pair.Key;
                        String distributionTableName = pair.Value;
                        if (GlobalNames.nonUserAttributesExceptionsList.Contains(distributionTableName))    //just precaution
                            continue;
                        NormalTable distributionTable = donnees.GetTable("Input", distributionTableName);

                        if (distributionTable != null)
                            distributionTables.Add(userAttributeName, distributionTable);
                    }
                }
/*
                foreach (DataRow row in userAttributesTable.Rows)
                {
                    String distribTableName = row[GlobalNames.sUserAttributes_ColumnName].ToString();
                    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    if (GlobalNames.nonUserAttributesExceptionsList.Contains(distribTableName))
                        continue;
                    // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    NormalTable distributionTable = donnees.GetTable("Input", distribTableName);
                    if (distributionTable != null)
                        distributionTables.Add(distributionTable.Table.TableName, distributionTable);
                }
*/ 
                // >> Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab

            }
            ppcPaxPlanGenerator.setUserAttributesTables(userAttributesTable, distributionTables);
        }
        //>> Task #7405 - new Desk and extra information for Pax        
        #endregion

        #endregion

        #region Des fonctions publiques permettant la mise à jour des données.
        /// <summary>
        /// Fonction qui calcul la table des check in opening par rapport à celle des allocations.
        /// </summary>
        public void UpdateCheckInAllocation()
        {
            AllocationDependances adTmp = (AllocationDependances)htAllocationDependances["Alloc_CITable"];
            if (adTmp.HasToBeRecalculated())
                UpdateAllocation("Input", "Alloc_CITable");
            DataTable AllocCI = this.getTable("Input", "Alloc_CITable");
            DataTable OpeningCI = this.getTable("Input", "Opening_CITable");
            if ((AllocCI != null) && (OpeningCI != null))
                OverallTools.DataFunctions.OpeningCIAllocation(AllocCI, OpeningCI);
            aEteModifiee("Input", "Opening_CITable");
        }

        public void UpdateAllocation(String DataSet, String sTableName)
        {
            if (DataSet != "Input")
                return;
            DataTable dtFPA = this.getTable("Input", GlobalNames.FPATableName);
            DataTable dtFPD = this.getTable("Input", GlobalNames.FPDTableName);
            if (bUseAlphNumericForFlightInfo)
            {
                dtFPA = ConvertFPAInformations(dtFPA, structureAeroport, false, false) ;
                dtFPD = ConvertFPDInformations(dtFPD, structureAeroport, false, false);
            }
            if (sTableName.EndsWith("_Alloc_MakeUp"))   // >> Task #10272 Pax2Sim - MUP Allocation
            {
                String sOCTTable = sTableName.Remove(sTableName.IndexOf("_Alloc_MakeUp"));
                String CurrentTerminal = sOCTTable.Remove(0, GlobalNames.sBHS_PrefixeLong.Length);
                if (CurrentTerminal.Length == 0)
                    return;
                int iTerminal;
                if (!Int32.TryParse(CurrentTerminal, out iTerminal))
                    return;
                VisualisationMode obj = null;
                OverallTools.UpdateAllocation.effectuerCalculAllocation(dtFPD,
                                        this.getTable("Input", sTableName),
                                          this.getTable("Input", "OCT_MakeUp"),
                                          null,
                                          iTerminal, true, (int)(AllocationStep), GlobalNames.sFPD_A_Column_DATE, GlobalNames.sFPD_Column_STD, GlobalNames.sFPD_A_Column_FlightCategory,
                                          GlobalNames.sFPD_Column_TerminalMup, GlobalNames.sFPD_Column_Eco_Mup_End,
                                          GlobalNames.sFPD_Column_Eco_Mup_Start, GlobalNames.sFPD_Column_First_Mup_Start, GlobalNames.sFPD_Column_First_Mup_End,
                                          GlobalNames.sBHS_MakeUpObject, false, out obj, ListeErreurs);
            }
            else
            {
                if (!htAllocationDependances.ContainsKey(sTableName))
                {
                    /*2011.12.23 : Ajout de cette partie de code pour permettre la mise à jour de la table parente d'allocation
                     lorsqu'un filtre est demandé.*/
                    NormalTable ntTable = GetTable(DataSet, sTableName);
                    if (ntTable.isFilter)
                    {
                        if (htAllocationDependances.ContainsKey(((IFilterTable)ntTable).Root.Name))
                            UpdateAllocation(DataSet, ((IFilterTable)ntTable).Root.Name);
                    }
                    /*2011.12.23 : fin */
                    return;
                }
                else
                {
                    AllocationDependances adTmp = (AllocationDependances)htAllocationDependances[sTableName];
                    if (!adTmp.HasToBeRecalculated())
                        return;

                    adTmp.HadBeenRecalculated();
                    switch (sTableName)
                    {
                        case "Alloc_CITable":

                            OverallTools.UpdateAllocation.effectuerCalculAllocation(dtFPD,
                                                          this.getTable("Input", "Alloc_CITable"),
                                                          this.GetTable("Input", "OCT_CITable"),
                                                          true,
                                                          (int)(AllocationStep),
                                                          GlobalNames.sFPD_A_Column_DATE,
                                                          GlobalNames.sFPD_Column_STD,
                                                          GlobalNames.sFPD_A_Column_FlightCategory,
                                                          GlobalNames.sFPD_A_Column_ID,
                                                          GlobalNames.sFPD_A_Column_AirlineCode,
                                                          GlobalNames.sOCT_CI_Line_Opening,
                                                          GlobalNames.sOCT_CI_Line_Closing,
                                                          GlobalNames.sFPD_Column_TerminalCI,
                                                          true,
                                                          GlobalNames.sFPD_Column_FB_CI_Start,
                                                          GlobalNames.sFPD_Column_FB_CI_End,
                                                          "Check In",
                                                          GlobalNames.sFPD_Column_Eco_CI_Start,
                                                          GlobalNames.sFPD_Column_Eco_CI_End,
                                                          ListeErreurs);




                            return;
                        case "Alloc_BaggageClaimTable":
                            OverallTools.UpdateAllocation.effectuerCalculAllocation(dtFPA,
                                                            this.getTable("Input", "Alloc_BaggageClaimTable"),
                                                            this.GetTable("Input", "OCT_BaggageClaimTable"),
                                                            false,
                                                            (int)(AllocationStep),
                                                            GlobalNames.sFPD_A_Column_DATE,
                                                            GlobalNames.sFPA_Column_STA,
                                                            GlobalNames.sFPD_A_Column_FlightCategory,
                                                            GlobalNames.sFPD_A_Column_ID,
                                                            GlobalNames.sFPD_A_Column_AirlineCode,
                                                            GlobalNames.sOCT_Baggage_Line_Opening,
                                                            GlobalNames.sOCT_Baggage_Line_Closing,
                                                            GlobalNames.sFPA_Column_TerminalReclaim,
                                                            false,
                                                            GlobalNames.sFPA_Column_ReclaimObject,
                                                            null,
                                                            "Baggage Claim",
                                                            null,
                                                            null,
                                                            ListeErreurs);
                            return;
                        case "Alloc_BoardGateTable":
                            OverallTools.UpdateAllocation.effectuerCalculAllocation(dtFPD,
                                                            this.getTable("Input", "Alloc_BoardGateTable"),
                                                            this.GetTable("Input", "OCT_BoardGateTable"),
                                                            true,
                                                            (int)(AllocationStep),
                                                            GlobalNames.sFPD_A_Column_DATE,
                                                            GlobalNames.sFPD_Column_STD,
                                                            GlobalNames.sFPD_A_Column_FlightCategory,
                                                            GlobalNames.sFPD_A_Column_ID,
                                                            GlobalNames.sFPD_A_Column_AirlineCode,
                                                            GlobalNames.sOCT_Board_Line_Opening,
                                                            GlobalNames.sOCT_Board_Line_Closing,
                                                            GlobalNames.sFPD_A_Column_TerminalGate,
                                                            false,
                                                            GlobalNames.sFPD_Column_BoardingGate,
                                                            null,
                                                            GlobalNames.sFPD_Column_BoardingGate,
                                                            null,
                                                            null,
                                                            ListeErreurs);
                            return;
                        case "Alloc_ParkingTable":
                            DataTable dtAircraftLinkTable = this.getTable("Input", GlobalNames.FPLinksTableName);
                            OverallTools.UpdateAllocation.effectuerCalculParkingAllocation(dtFPD,
                                                            dtFPA,
                                                            dtAircraftLinkTable,
                                                            this.getTable("Input", "Alloc_ParkingTable"),
                                                            this.getTable("Input", "OCT_ParkingTable"),
                                                            true, true, (int)(AllocationStep), ListeErreurs);
                            return;
                        default:
                            break;
                    }
                }
            }
            if (bUseAlphNumericForFlightInfo)
            {
                dtFPD.Dispose();
                dtFPA.Dispose();
            }
        }

        /// <summary>
        /// Fonction qui doit être appelée lorsque la structure de l'aéroport
        /// change afin de recalculé les tables qui peuvent être influencées.
        /// </summary>
        public void AirportStructureChange()
        {
            foreach (String key in htAllocationDependances.Keys)
            {
                ((AllocationDependances)htAllocationDependances[key]).SetAirportStructureHadBeenModified();
            }
        }
        internal void aEteModifiee(String dataset, String nomtable, String sExceptionName)
        {
            DataManager dmTmp = GetDataManager(dataset);
            if (dmTmp == null)
            {
                ListeErreurs.Add("Err00250 : The dataset does not exist.");
                return;
            }
            if (dmTmp.GetType() != typeof(DataManagerInput))
                return;
            ((DataManagerInput)dmTmp).CheckExDiff(nomtable, sExceptionName);
        }
        public void aEteModifiee(String dataset, String nomtable)
        {
            if (GetDataManager(dataset) == null)
            {
                ListeErreurs.Add("Err00090 : The dataset does not exist.");
                return;
            }
            if ((dataset == "Input") && (nomtable == GlobalNames.NbBagsTableName))
            {
                //Version 3.0.0.1 (la table Trolley est intimement liée à celle des baggages)
                OverallTools.DataFunctions.UpdateTrolleyTable(getTable(dataset, GlobalNames.NbBagsTableName), getTable(dataset, GlobalNames.NbTrolleyTableName));
            }
            GetDataManager(dataset).UpdateTable(nomtable);

            if (dataset == "Input")
            {
                foreach (String key in htAllocationDependances.Keys)
                {
                    ((AllocationDependances)htAllocationDependances[key]).HadBeenModified(nomtable);
                }
                if ((nomtable == GlobalNames.NbBagsTableName))
                //Version 3.0.0.1 (la table Trolley est intimement liée à celle des baggages
                {
                    GetDataManager(dataset).UpdateTable(GlobalNames.NbTrolleyTableName);
                }
                //Plusieurs vérifications à faire s'il s'agit d'une table contenue dans le Input
                if (nomtable == GlobalNames.FP_FlightCategoriesTableName)
                {
                    Update_FlightCategorie();
                }
                if (OverallTools.FonctionUtiles.estPresentDansListe(nomtable, ListeTablesPourCalculAllocation))
                {
                    AirportStructureChange();
                }
            }
            hadBeenSaved = false;
        }
        /// <summary>
        /// Function that permits to update the filters , but only the children.
        /// </summary>
        /// <param name="dataset"></param>
        /// <param name="nomtable"></param>
        internal void HasBeenUpdated(String dataset, String nomtable)
        {
            if (GetDataManager(dataset) == null)
                return;
            if ((dataset == "Input") && (nomtable == GlobalNames.NbBagsTableName))
            {
                //Version 3.0.0.1 (la table Trolley est intimement liée à celle des baggages)
                OverallTools.DataFunctions.UpdateTrolleyTable(getTable(dataset, GlobalNames.NbBagsTableName), getTable(dataset, GlobalNames.NbTrolleyTableName));
            }
            if (dataset == "Input")
            {
                foreach (String key in htAllocationDependances.Keys)
                {
                    ((AllocationDependances)htAllocationDependances[key]).HadBeenModified(nomtable);
                }
                //Plusieurs vérifications à faire s'il s'agit d'une table contenue dans le Input
                if (nomtable == GlobalNames.FP_FlightCategoriesTableName)
                {
                    Update_FlightCategorie();
                }
                if (OverallTools.FonctionUtiles.estPresentDansListe(nomtable, ListeTablesPourCalculAllocation))
                {
                    AirportStructureChange();
                }
            }
            hadBeenSaved = false;
        }

       


        /// <summary>
        /// Cette fonction se charge de mettre à jour tous les filtres contenus dans un scénario donné, et
        /// de les placés au bon endroit dans le treeview.
        /// </summary>
        /// <param name="sScenario"> Nom du scénario</param>
        /// <param name="node"> Racine de l'arbre où doivent être insérer les nouveaux filtes</param>
        /// <param name="cmsMenuFilter">Menu contextuel associé aux scénarios.</param>
        public void UpdateFilters(String sScenario, TreeNode node, ContextMenuStrip cmsMenuFilter, ContextMenuStrip cmsMenuException)
        {
            DataManager gs = GetDataManager(sScenario);
            if (gs == null)
                return;
            gs.UpdateFilters(node, cmsMenuFilter, cmsMenuException);
        }

        /// <summary>
        /// Fonction pour specifier aux tables quelles doivent prendre en compte ou non leurs tables
        /// d'exception.
        /// </summary>
        /// <param name="Parametres">Parametres du scenarion pour lequel l'information sur l'utilisation
        /// des tables d'exceptions est spécifié.</param>
        internal void SetUseException(Classes.ParamScenario Parametres)
        {
            if (dmiInputData == null) 
                return;

            Dictionary<String, NormalTable> tables = new Dictionary<string, NormalTable>();
            //List<NormalTable> tables = new List<NormalTable>();

            tables.Add(GlobalNames.FP_AircraftTypesTableName, dmiInputData.GetTable(Parametres.AircraftType));
            tables.Add(GlobalNames.Transfer_ICTTableName, dmiInputData.GetTable(Parametres.ICT_Table));
            tables.Add(GlobalNames.NbBagsTableName, dmiInputData.GetTable(Parametres.NbBags));
            tables.Add(GlobalNames.NbTrolleyTableName, dmiInputData.GetTable(Parametres.NbTrolley));
            tables.Add(GlobalNames.NbVisitorsTableName, dmiInputData.GetTable(Parametres.NbVisitors));
            tables.Add(GlobalNames.OCT_BaggageClaimTableName, dmiInputData.GetTable(Parametres.OCT_BC));
            tables.Add(GlobalNames.OCT_BoardGateTableName ,dmiInputData.GetTable(Parametres.OCT_BG));
            tables.Add(GlobalNames.OCT_ArrivalGateTableName, dmiInputData.GetTable(Parametres.OCT_BG));  //arrGate
            tables.Add(GlobalNames.OCT_MakeUpTableName ,dmiInputData.GetTable(Parametres.OCT_MakeUp));
            tables.Add(GlobalNames.Times_ProcessTableName ,dmiInputData.GetTable(Parametres.ProcessTimes));
            tables.Add(GlobalNames.FPD_LoadFactorsTableName ,dmiInputData.GetTable(Parametres.DepartureLoadFactors));
            tables.Add(GlobalNames .FPA_LoadFactorsTableName,dmiInputData.GetTable(Parametres.ArrivalLoadFactors));
            tables.Add(GlobalNames.CI_ShowUpTableName ,dmiInputData.GetTable(Parametres.CI_ShowUpTable));
            
#if(PAXINOUTUTILISATION)
            tables.Add(GlobalNames.ProcessDistributionPaxInName ,dmiInputData.GetTable(Parametres.PaxIn));
            tables.Add(GlobalNames.ProcessDistributionPaxOutName ,dmiInputData.GetTable(Parametres.PaxOut));
#endif
            // << Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab
            if (Parametres.userAttributesTablesDictionary != null)
            {
                foreach (KeyValuePair<String, String> pair in Parametres.userAttributesTablesDictionary)
                {
                    String userAttributeTableName = pair.Value;
                    NormalTable userAttributeTable = dmiInputData.GetTable(userAttributeTableName);

                    if (userAttributeTable != null)
                        tables.Add(userAttributeTableName, userAttributeTable);
                }
            }
            // >> Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab

            // << Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop
            tables.Add(GlobalNames.OCT_CITableName, dmiInputData.GetTable(Parametres.OCT_CI_Table));

            NormalTable oct_bagDrop = dmiInputData.GetTable(Parametres.OCT_BagDropTableName);
            if (oct_bagDrop != null && !tables.ContainsKey(GlobalNames.OCT_BaggDropTableName))
                tables.Add(GlobalNames.OCT_BaggDropTableName, oct_bagDrop);

            NormalTable ebsInputRate = dmiInputData.GetTable(Parametres.ebsInputRateTableName);
            if (ebsInputRate != null && !tables.ContainsKey(GlobalNames.userAttributesEBSInputRateTableName))
                tables.Add(GlobalNames.userAttributesEBSInputRateTableName, ebsInputRate);
            
            NormalTable ebsOutputRate = dmiInputData.GetTable(Parametres.ebsOutputRateTableName);
            if (ebsOutputRate != null && !tables.ContainsKey(GlobalNames.userAttributesEBSOutputRateTableName))
                tables.Add(GlobalNames.userAttributesEBSOutputRateTableName, ebsOutputRate);

            NormalTable arrivalBagLoadingRate = dmiInputData.GetTable(Parametres.arrivalBaggageLoadingRateTableName);
            if (arrivalBagLoadingRate != null && !tables.ContainsKey(GlobalNames.sUserAttributesBaggLoadingRateTableName))
                tables.Add(GlobalNames.sUserAttributesBaggLoadingRateTableName, arrivalBagLoadingRate);

            NormalTable arrivalBagLoadingDelay = dmiInputData.GetTable(Parametres.arrivalBaggageLoadingDelayTableName);
            if (arrivalBagLoadingDelay != null && !tables.ContainsKey(GlobalNames.sUserAttributesBaggLoadingDelayTableName))
                tables.Add(GlobalNames.sUserAttributesBaggLoadingDelayTableName, arrivalBagLoadingDelay);
            // >> Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop          

            foreach (String Name in tables.Keys)
            {
                if (Name == null)
                    continue;
                if (tables[Name] == null)
                    continue;
                NormalTable table = dmiInputData.GetTable(Name);
                ExceptionTable exTable = table as ExceptionTable;
                if (exTable == null)
                    continue;
                exTable.UseException = Parametres.UseException(tables[Name].Name);
            }

            // Segretation se traite autrement
            if (Parametres.UseMakeUpSegregation)
            {
                NormalTable ntTable = GetTable("Input", GlobalNames.SegregationName);
                if (ntTable != null)
                {
                    ExceptionTable exTable = ntTable as ExceptionTable;
                    if (exTable != null)
                        exTable.UseException = Parametres.UseExSegregation;
                }
            }

        }
        /// <summary>
        /// Remet à vraie la variable indiquant si les exceptions doivent être utilisé ou non.
        /// </summary>
        internal void ResetUseException()
        {
            if (dmiInputData == null)
                return;
            dmiInputData.ResetUseException();
        }

        #endregion

        #region Fonctions pour la création des filtres.
        
        internal bool createReplaceFilter(String dataset, Filter filtre)
        {
            if ((dataset == null) || (dataset == ""))
            {
                if (FilterExist(filtre.Name))
                {
                    return UpdateFilter(filtre);
                    //return getTable(filtre.Name);
                }
                return AddFilter(filtre);
                //return getTable(filtre.Name);
            }
            DataManager gs = GetDataManager(dataset);
            if (gs == null)
                return false;
            hadBeenSaved = false;
            if (gs.GetFilter(filtre.Name) != null)
                return gs.UpdateFilter(filtre);
            else
                return gs.AddFilter(filtre);
            //return gs.GetTable(filtre.Name).Table;
        }

        private bool AddFilter(String dataset, Filter filtre)
        {
            if ((dataset == "") || (dataset == null))
                return AddFilter(filtre);
            DataManager gs = GetDataManager(dataset);
            if (gs == null)
                return false;
            if (gs.GetFilter(filtre.Name) != null)
            {
                return false;
            }
            hadBeenSaved = false;
            gs.AddFilter( filtre);
            return true;
        }
        internal Filter getFilter(String dataset, String nomFiltre)
        {
            if ((dataset == "") || (dataset == null))
                return GetFilter(nomFiltre);
            DataManager gs = GetDataManager(dataset);
            if (gs == null)
                return null;
            NormalTable ntTmp = gs.GetFilter(nomFiltre);
            if (ntTmp == null)
                return null;
            Type tType = ntTmp.GetType();
            if (tType.GetInterface("IFilterTable") == null)
                return null;
            return ((IFilterTable)ntTmp).Definition;
        }
        public String getFilterRootName(String dataset, String nomFiltre)
        {
            DataManagement.DataManager dmData = GetDataManager(dataset);
            if (dmData == null)
                return null;
            return dmData.getFilterRootName(nomFiltre);
        }

        /// <summary>
        /// Function which returns the mother table for the filter. It returns the originating table,
        /// if their is some filter on the way, it goes through till the mother table.
        /// </summary>
        /// <param name="FilterName">The name of the filter.</param>
        /// <param name="ListFilter">The filter list.</param>
        /// <returns></returns>
        public static String motherTable(String FilterName, Hashtable ListFilter)
        {
            String tmp = FilterName;
            while (ListFilter.ContainsKey(tmp))
            {
                String tmp2 = ((Filter)ListFilter[tmp]).MotherTableName;
                if (tmp2 == "")
                    break;
                tmp = tmp2;
            }
            return tmp;
        }
        
        internal GraphicFilter getGraphicFilter(String dataset, String FilterName)
        {
            if ((dataset == "") || (dataset == null))
                return GetGraphicFilter(FilterName);
            DataManager gs = GetDataManager(dataset);
            if (gs == null)
                return null;
            if (gs.GetTable(FilterName) == null)
                return null;
            // >> Task #15867 Transfer Distribution Tables/Charts improvement            
            GraphicFilter graphicFilter = gs.GetTable(FilterName).GraphicDefinition;
            if (dataset == "Input" && graphicFilter == null)
                graphicFilter = GraphicFilter.getDefaultGraphicFilterForInputTables(gs.GetTable(FilterName).Table);
            // << Task #15867 Transfer Distribution Tables/Charts improvement
            return graphicFilter;
        }
        internal void AddReplaceGraphicFilter(String dataset, GraphicFilter filter)
        {
            if (filter == null)
                return;
            if ((dataset == "") || (dataset == null))
            {
                if (GetGraphicFilter(filter.Name) != null)
                {
                    UpdateGraphicFilter(filter);
                }
                else
                {
                    AddGraphicFilter(filter);
                }
            }
            DataManager gs = GetDataManager(dataset);
            if (gs == null)
                return;
            // << Task #8319 Pax2Sim - Pax2Sim - Charts - Title format: ScenarioName - ChartName
            if (filter.useScenarioNameInTitle)  // << Task #9624 Pax2Sim - Charts - checkBox for scenario name
            {
                if (dataset != null && dataset.Length > 0 && dataset != "Input"
                    && filter.Title != null && !filter.Title.Contains(dataset))
                    filter.Title = " " + dataset + " - " + filter.Title;
            }
            // >> Task #8319 Pax2Sim - Pax2Sim - Charts - Title format: ScenarioName - ChartName
            gs.UpdateGraphique(filter.Name, filter);
            hadBeenSaved = false;
        }
        // << Task #8319 Pax2Sim - Pax2Sim - Charts - Title format: ScenarioName - ChartName
        internal void AddReplaceGraphicFilterHavingScenarioNameInTitle(String dataset, GraphicFilter filter)
        {
            if (filter == null)
                return;
            if ((dataset == "") || (dataset == null))
            {
                if (GetGraphicFilter(filter.Name) != null)
                {
                    UpdateGraphicFilter(filter);
                }
                else
                {
                    AddGraphicFilter(filter);
                }
            }
            DataManager gs = GetDataManager(dataset);
            if (gs == null)
                return;
            if (dataset != null && dataset.Length > 0 && dataset != "Input"
                && filter.Title != null && !filter.Title.Contains(dataset))
                filter.Title = " " + dataset + " - " + filter.Title;
            gs.UpdateGraphique(filter.Name, filter);
            hadBeenSaved = false;
        }
        // >> Task #8319 Pax2Sim - Pax2Sim - Charts - Title format: ScenarioName - ChartName
        #endregion

        #region ACCESSEURS aux informations de la classe

        #region Fonctions pour les allocations
        
        public Boolean isAllocatedTable(String sTable)
        {
            DataManagement.DataManagerInput gs = InputData;
            if (gs == null)
                return false;
            ///Todo : Gestion des tables allouées.
            return gs.IsAllocated(sTable);
        }
        public void deleteAllocatedTable(String sTable)
        {
            DataManagement.DataManagerInput gs = InputData;
            if (gs == null)
                return;
            hadBeenSaved = false;
            ///Todo : Gestion des tables allouées.
            gs.RemoveAllocation(sTable);
        }
        #endregion

        #region Fonctions pour atteindre directement les structures de données utilisées pour stockées les données.


        private DataManagement.DataManagerInput InputData
        {
            get
            {
                return dmiInputData;
            }
        }
        /// <summary>
        /// Fonction qui permet de récupérer le dataManager contenant toutes les données.
        /// </summary>
        /// <param name="NomDataset">Nom du dataManager recherché</param>
        /// <returns>NULL ou alors le dataManager recherché.</returns>
        public DataManagement.DataManager GetDataManager(String NomDataset)
        {
            if (NomDataset == null)
                return null;
            if (NomDataset == "Input")
                return dmiInputData;
            if(!dmsScenarios.ContainsKey(NomDataset))
                return null;
            return dmsScenarios[NomDataset];
        }

        /// <summary>
        /// \deprecated
        /// </summary>
        /// <param name="NomDataset"></param>
        /// <returns></returns>
        public GestionDonnees getGestionDonnees(String NomDataset)
        {
            if (NomDataset == null)
            {
                //ListeErreurs.Add("Err00321 : The dataset does not exist.");
                return null;
            }
            if (Data == null)
                return null;
            if (!Data.ContainsKey(NomDataset))
            {
                ListeErreurs.Add("Err00143 : The dataset does not exist.");
                return null;
            }

            return (GestionDonnees)Data[NomDataset];
        }
        #endregion

        #region Pour les filtres graphiques.
        
        internal bool AddGraphicFilter(String dataset, GraphicFilter filtre)
        {
            if ((dataset == "") || (dataset == null))
            {
                return AddGraphicFilter(filtre);
            }
            if (filtre == null)
                return false;
            DataManagement.DataManager gs = GetDataManager(dataset);
            if (gs == null)
                return false;
            hadBeenSaved = false;
            return gs.UpdateGraphique(filtre.Name, filtre);
        }
        internal void RemoveGraphicFilter(String dataset, String filtreName)
        {
            if ((dataset == "") || (dataset == null))
            {
                DeleteGraphicFilter(filtreName);
                return;
            }
            DataManagement.DataManager gs = GetDataManager(dataset);
            if (gs == null)
                return;
            hadBeenSaved = false;
            gs.UpdateGraphique(filtreName,null);
        }
        #endregion

        #region Fonctions pour les Allocations
        internal Classes.GenerateAllocationTool GetAllocation(String sName)
        {
            if (sName == null)
                return null;
            List<String> lsName = getScenarioAllocation();
            if ((lsName == null) || (!lsName.Contains(sName)))
                return null;
            DataManagerScenario dms = dmsScenarios[sName];
            return ((DataManagerAllocation)dms).AllocationDefinition;
        }
        #endregion

        #region Pour les tables.

        /// <summary>
        /// Fonction qui permet de récupérer la table parente de la table (ou filtre) passée en paramètre. Si
        /// la table n'a pas de table parente, alors le nom de la table courante est renvoyé.
        /// </summary>
        /// <param name="dataSet">Système de données dans lequel se trouve la table dont le nom parent est recherché.</param>
        /// <param name="sNomTable">Nom de la table</param>
        /// <returns>Nom de la table parente (ou nom de la table passée en parametre, si celle ci n'est pas un filtre)</returns>
        internal String getMotherTable(String dataSet, String sNomTable)
        {
            DataManager dm = GetDataManager(dataSet);
            if (dm == null)
                return null;

            NormalTable ntTable = dm.GetFilter(sNomTable);
            if (ntTable == null)
                return sNomTable;
            Type tType = ntTable.GetType();
            if (tType.GetInterface("IFilterTable") == null)
                return sNomTable;
            NormalTable ntParent = ((IFilterTable)ntTable).Root;
            if (ntParent == null)
                return null;
            return ntParent.Name;
        }

        internal DataManagement.ExceptionTable.ExceptionTableParameters GetExceptionParameters(String dataset, String nomTable)
        {
            if((InputData == null) || (dataset != InputData.Name))
                return ExceptionTable.ExceptionTableParameters.None;
            return InputData.GetExceptionParameter(nomTable);
        }
        internal DataManagement.ExceptionTable.ExceptionTableFormat GetExceptionFormat(String dataset, String nomTable)
        {
            if ((InputData == null) || (dataset != InputData.Name))
                return ExceptionTable.ExceptionTableFormat.Column;
            return InputData.GetExceptionFormat(nomTable);
        }
        /// <summary>
        /// Retourne un booléen indiquand si la table est présente dans le dataSet
        /// </summary>
        /// <param name="dataSet">Le nom du dataset</param>
        /// <param name="nomTable">Le nom de la table.</param>
        /// <returns>Booléen qui indique si la table est présente dans le DataSet.</returns>
        public bool tableEstPresente(String dataSet, String nomTable)
        {
            if ((dataSet == "") || (dataSet == null))
                return getTable(nomTable) != null;
            if (dataSet == "Input")
                return dmiInputData.Exist(nomTable);

            if (!dmsScenarios.ContainsKey(dataSet))
                return false;
            return dmsScenarios[dataSet].Exist(nomTable);
        }

        /// <summary>
        /// Fonction qui retourne la table spécifiée.
        /// </summary>
        /// <param name="dataSet">Nom du dataSet où aller chercher la table</param>
        /// <param name="nomTable">Nom de la table</param>
        /// <returns>Retourne la table ou null si cette table n'existe pas.</returns>
        public DataTable getTable(String dataSet, String nomTable)
        {
            if ((dataSet == "") || (dataSet == null))
                return getTable(nomTable);
            if (dataSet == "Input")
            {
                NormalTable ntTable = InputData.GetTable(nomTable);
                if (ntTable == null)
                    return null;
                return ntTable.Table;
            }
            if (!dmsScenarios.ContainsKey(dataSet))
                return null;

            NormalTable ntTable2 = dmsScenarios[dataSet].GetTable(nomTable);
            if (ntTable2 == null)
                return null;

            // >> Task #13955 Pax2Sim -BHS trace loading issue
            if (typeof(DataManagerPaxBHS).IsInstanceOfType(dmsScenarios[dataSet]))
            {
                DataManagerPaxBHS paxBHSScenario = (DataManagerPaxBHS)dmsScenarios[dataSet];
                if (paxBHSScenario != null && !PAX2SIM.loadingScenarioToShowObject) //&& paxBHSScenario.useTraceSaving 
                {
                    bool filterNeedsReloading = false;
                    NormalTable filterParent = null;
                    if (ntTable2.isFilter && ntTable2.GetType() == typeof(FilterTable)) // >> Task #1954_exportOutputTables
                    {
                        filterParent = getParentResultsTableFromFilter((FilterTable)ntTable2);
                        if (filterParent != null && !filterParent.tableIsLoaded && filterParent is ResultsTable)
                            filterNeedsReloading = true;
                    }
                    if ((ntTable2 != null && !ntTable2.tableIsLoaded && ntTable2 is ResultsTable) || filterNeedsReloading)
                    {
                        if (PAX2SIM.stoppedLoadingScenario)
                        {
                            PAX2SIM.loadingScenarioToShowObject = false;
                            return null;
                        }
                        ResultsTable resultsTable = null;
                        if (filterNeedsReloading)
                            resultsTable = (ResultsTable)filterParent;
                        else
                            resultsTable = (ResultsTable)ntTable2;
                        if (resultsTable != null && resultsTable.CalculatedFromTrace)
                        {
                            PAX2SIM.loadingScenarioToShowObject = true;
                            string warningMessage = "This is a table based on a scenario (\"" + dataSet + "\"). " // >> Task #16728 PAX2SIM Improvements (Recurring) C#13
                                + Environment.NewLine
                                + "The loading procedure may take a few minutes. Do you want to continue?";

                            ParamScenario scenarioParams = GetScenario(dataSet);
                            List<AnalysisResultFilter> resultFilters = null;
                            List<string> flowTypes = null;
                            bool isBHSSimulation = false;
                            if (scenarioParams != null)
                            {
                                resultFilters = scenarioParams.analysisResultsFilters;
                                flowTypes = scenarioParams.flowTypes;
                                isBHSSimulation = scenarioParams.BHSSimulation;

                                if (scenarioParams.analysisResultsFilters != null && scenarioParams.analysisResultsFilters.Count > 0)
                                {
                                    if (scenarioParams.flowTypes == null || scenarioParams.flowTypes.Count == 0)
                                    {
                                        scenarioParams.flowTypes.Clear();
                                        scenarioParams.flowTypes.Add(AnalysisResultFilter.DEPARTING_FLOW_TYPE_VISUAL_NAME);
                                        //scenarioParams.flowTypes.Add(AnalysisResultFilter.ARRIVING_FLOW_TYPE_VISUAL_NAME);
                                        scenarioParams.flowTypes.Add(AnalysisResultFilter.ORIGINATING_FLOW_TYPE_VISUAL_NAME);
                                        //scenarioParams.flowTypes.Add(AnalysisResultFilter.TERMINATING_FLOW_TYPE_VISUAL_NAME);
                                        scenarioParams.flowTypes.Add(AnalysisResultFilter.TRANSFERRING_FLOW_TYPE_VISUAL_NAME);
                                    }
                                }
                            }

                            BHSCustomMessageBox customMessageBox = new BHSCustomMessageBox(warningMessage, isBHSSimulation, resultFilters, flowTypes, this, 
                                BHSCustomMessageBox.generateParametersForPopup(scenarioParams));
                            DialogResult dr = customMessageBox.ShowDialog();
                            if (dr == DialogResult.No || dr == DialogResult.Cancel)
                            {
                                PAX2SIM.stoppedLoadingScenario = true;
                                PAX2SIM.loadingScenarioToShowObject = false;    // >> Reload scenario Question bug
                                return null;
                            }
                            PAX2SIM.stoppedLoadingScenario = false;
                            PAX2SIM.loadingScenarioToShowObject = true; // >> Reload scenario Question bug

                            PAX2SIM.generateLocalISTForBHS = customMessageBox.generateLocalIST;
                            PAX2SIM.generateGroupISTForBHS = customMessageBox.generateGroupIST; // >> Task #14280 Bag Trace Loading time too long
                            PAX2SIM.generateMUPSegregationForBHS = customMessageBox.generateMUPSegregation; // >> Task #14280 Bag Trace Loading time too long
                            PAX2SIM.copyOutputTables = customMessageBox.copyOutputTables;
                            
                            if (scenarioParams != null && customMessageBox.resultFilters != null)
                            {
                                scenarioParams.analysisResultsFilters.Clear();
                                scenarioParams.analysisResultsFilters.AddRange(customMessageBox.resultFilters);
                            }
                            if (scenarioParams != null && customMessageBox.flowTypes != null)
                            {
                                scenarioParams.flowTypes.Clear();
                                scenarioParams.flowTypes.AddRange(customMessageBox.flowTypes);
                            }
                        }
                    }
                }
            }
            // << Task #13955 Pax2Sim -BHS trace loading issue

            return ntTable2.Table;
        }

        // << Task #8862 Pax2sim - Chart - confirm loading Scenario for Chart       
        public bool tabelIsLoaded(String dataSet, String tableName)
        {
            if (dataSet == "" || dataSet == null || tableName == null)
                return false;
            if (!dmsScenarios.ContainsKey(dataSet))
                return false;

            NormalTable normalTable = dmsScenarios[dataSet].GetTable(tableName);
            if (normalTable == null)
                return false;
            if (normalTable is ResultsTable)
                return ((ResultsTable)normalTable).Loaded;
            return false;
        }

        public bool tabelIsCalculatedFromTrace(String dataSet, String tableName)
        {
            if (dataSet == "" || dataSet == null || tableName == null)
                return false;
            if (!dmsScenarios.ContainsKey(dataSet))
                return false;

            NormalTable normalTable = dmsScenarios[dataSet].GetTable(tableName);
            if (normalTable == null)
                return false;
            if (normalTable is ResultsTable)
                return ((ResultsTable)normalTable).CalculatedFromTrace;
            return false;
        }

        public bool isFilterTable(String dataSet, String tableName)
        {
            if (dataSet == "" || dataSet == null || tableName == null)
                return false;
            if (!dmsScenarios.ContainsKey(dataSet))
                return false;
            NormalTable normalTable = dmsScenarios[dataSet].GetTable(tableName);
            if (normalTable == null)
                return false;            
            return normalTable.isFilter;
        }
        // >> Task #8862 Pax2sim - Chart - confirm loading Scenario for Chart

        private ResultsTable getParentResultsTableFromFilter(FilterTable filter)
        {
            if (filter == null || filter.Parent == null)
                return null;
            if (filter.Parent.GetType() == typeof(FilterTable))
                return getParentResultsTableFromFilter((FilterTable)filter.Parent);
            else if (filter.Parent.GetType() == typeof(ResultsTable))
                return (ResultsTable)filter.Parent;
            return null;
        }

        /// <summary>
        /// Fonction qui retourne la table spécifiée.
        /// </summary>
        /// <param name="dataSet">Nom du dataSet où aller chercher la table</param>
        /// <param name="nomTable">Nom de la table</param>
        /// <returns>Retourne la table ou null si cette table n'existe pas.</returns>
        internal NormalTable GetTable(String dataSet, String nomTable)
        {
            if ((dataSet == "") || (dataSet == null))
                return null;
            if (dataSet == "Input")
                return InputData.GetTable(nomTable);
            if (!dmsScenarios.ContainsKey(dataSet))
                return null;            
            return dmsScenarios[dataSet].GetTable(nomTable);
        }

        // >> Task #13955 Pax2Sim -BHS trace loading issue
        internal NormalTable GetScenarioNormalTable(String dataSet, String nomTable)
        {
            if (dataSet == "" || dataSet == null)
                return null;
            if (dataSet == "Input")
                return null;
            if (!dmsScenarios.ContainsKey(dataSet))
                return null;
            return dmsScenarios[dataSet].GetTable(nomTable);
        }
        // << Task #13955 Pax2Sim -BHS trace loading issue

        public bool AddTable(String dataSet, DataTable nouvelleTable)
        {
            DataManagement.DataManager gs = GetDataManager(dataSet);
            if (gs == null)
                return false;
            if (nouvelleTable == null)
                return false;
            if (gs.Exist(nouvelleTable.TableName))
            {
                return false;
            }
            hadBeenSaved = false;
            AddNewTable(dataSet, nouvelleTable);
            return true;
        }
        private void AddNewTable(String dataSet, DataTable nouvelleTable)
        {
            DataManagement.DataManager gs = GetDataManager(dataSet);
            if (gs == null)
                return;
            hadBeenSaved = false;
            /*if (OverallTools.FonctionUtiles.estPresentDansListe(nouvelleTable.TableName, ListeNomTablePAX))
            {

                gs.AddTable(nouvelleTable, (VisualisationMode)modeVisualisation[nouvelleTable.TableName]);
                return;
            }
            else if (dataSet == "Input")
            {
                foreach (String Nom in ListeNomTableBHS)
                {
                    if (nouvelleTable.TableName.StartsWith(sBHS_PrefixeLong) &&
                        nouvelleTable.TableName.EndsWith(Nom))
                    {
                        gs.AddTable(nouvelleTable, (VisualisationMode)modeVisualisation[Nom]);
                        return;
                    }
                }
            }*/
            if (gs.Exist(nouvelleTable.TableName))
                gs.UpdateTable(nouvelleTable);
            else
                //Toutes les modifications sont permises sur cette nouvelle table.
                gs.AddTable(nouvelleTable/*, new VisualisationMode(true, true, true, null, null)*/);
        }
        public void RemoveTable(String dataSet, String nomTable)
        {
            if ((dataSet == "") || (dataSet == null))
            {
                DeleteFilter(nomTable);
                return;
            }
            DataManagement.DataManager gs = GetDataManager(dataSet);
            if (gs == null)
                return;
            hadBeenSaved = false;
            gs.RemoveTable(nomTable);
        }
        public bool ReplaceTable(String dataSet, DataTable laTable)
        {
            return ReplaceTable(dataSet, laTable, false);
        }
        public bool ReplaceTable(String dataSet, DataTable laTable, Boolean CalculatedFromTrace)
        {
            DataManagement.DataManager gs = GetDataManager(dataSet);
            if (gs == null)
                return false;
            hadBeenSaved = false;
            if (typeof(DataManagement.DataManagerPaxBHS).IsInstanceOfType(gs))
            {
                return ((DataManagement.DataManagerPaxBHS)gs).UpdateTable(laTable, CalculatedFromTrace);
            }else
                return gs.UpdateTable(laTable);
        }
        public void AddReplaceTable(String dataSet, DataTable laTable)
        {
            AddReplaceTable(dataSet, laTable, false);
        }
        public void AddReplaceTable(String dataSet, DataTable laTable, Boolean CalculatedFromTrace)
        {
            DataManagement.DataManager gs = GetDataManager(dataSet);
            if (gs == null)
                return;
            if (laTable == null)
                return;
            hadBeenSaved = false;
            if(!gs.Exist(laTable.TableName))
                AddTable(dataSet,laTable);
            ReplaceTable(dataSet, laTable, CalculatedFromTrace);
        }
        public bool UpdateTable(String dataSet, String TableName, DataTable laTable)
        {
            DataManagement.DataManager gs = GetDataManager(dataSet);
            if (gs == null)
                return false;
            if ((TableName == null) || (TableName == ""))
                return false;
            if (laTable == null)
                return false;
            hadBeenSaved = false;
            if (!gs.Exist(TableName))
                return false;
            return gs.UpdateTable(TableName,laTable);
        }

        public bool SetAllocatedTable(String dataSet, String TableName)
        {
            DataManagement.DataManager gs = GetDataManager(dataSet);
            if (gs == null)
                return false;
            if ((TableName == null) || (TableName == ""))
                return false;
            if (!typeof(DataManagerAllocation).IsInstanceOfType(gs))
                return false;
            return ((DataManagerAllocation)gs).UpdateTable(TableName, true);
        }

        public bool LoadDefaultTable(String nomTable)
        {
            return ChargerFichierTable("Input", nomTable, "SIMCORE_TOOL.Resources." + nomTable + ".txt", true);
        }

        /// <summary>
        /// Fonction qui permet de récupèrer une table UserData avec le format habituel des tables (s'il est possible
        /// de convertir la table).
        /// </summary>
        /// <param name="sTableName">Nom de la table à récupérer</param>
        /// <returns>La table formatée en mode habituel ou null ou le cas échéant, la table habituelle d'un UserData (colonne A/B/C...)</returns>
        internal NormalTable GetFormatedUserDataTable(String sTableName)
        {
            if (InputData == null)
                return null;
            try
            {
                return InputData.GetFormatedUserDataTable(sTableName);
            }
            catch
            {
            }
            return null;
        }
        // >> Task #12393 Pax2Sim - File conversion for Athens
        internal NormalTable GetFormatedUserDataTableForFlightPlan(String sTableName)
        {
            if (InputData == null)
                return null;
            try
            {
                return InputData.GetFormatedUserDataTableForFlightPlan(sTableName);
            }
            catch
            {
            }
            return null;
        }
        // << Task #12393 Pax2Sim - File conversion for Athens
        /// <summary>
        /// Fonction qui se charge de charger un nouveau fichier dans une table existante.
        /// </summary>
        /// <param name="dataset">Nom du dataset où cette table doit être chargée</param>
        /// <param name="nomTable">Nom de la table qui doit être modifiée</param>
        /// <param name="nomFichier">Nom du fichier qui doit être chargé dans la table</param>
        /// <returns>Booléen indiquant si le chargement s'est bien déroulé ou non.</returns>
        public bool ChargerFichierTable(String dataset, String nomTable, String nomFichier, Boolean bLoadedFromResources)
        {
            ///Récupération du dataset contenant la table qui doit être mise à jour.
            DataManagement.DataManager gs = GetDataManager(dataset);
            ///Si le Dataset n'existe pas, ou que la table n'est pas présente, alors la fonction renvoie FAUX.
            if ((gs == null) ||(!gs.Exist(nomTable)))
                return false;
            ///Récupération du \ref NormalTable représentant la table.
            NormalTable ntTable = gs.GetTable(nomTable);
            ///Sauvegarde de l'ancienne table (pour pouvoir la réinjecter si le fichier n'est pas valide.
            DataTable dtOldTable = ntTable.Table;
            ///Mise à jour des composantes \ref NormalTable.Path et \ref NormalTable.Loaded de la table aux informations utiles
            ///pour forcer le rechargement.
            ntTable.Path = nomFichier;
            ntTable.Loaded = false;
            ///Si la table doit être chargée depuis les ressources, alors on fixe le booléen \ref NormalTable.PresentInResources à VRAI.
            if (bLoadedFromResources)
                ntTable.PresentInResources = bLoadedFromResources;
            ///Interrogation de la composante \ref NormalTable.Table pour forcer le chargement de la table. Si celle ci est null,
            ///on réinject l'ancienne table.
            if (ntTable.Table == null)
            {
                ntTable.UpdateTable(dtOldTable);
                return false;
            }
            hadBeenSaved = false;
            return true;/*
            aEteEnregistre = false;
            DataTable dtOldTable = gs.GetTable(nomTable).Table;
            if (!chargerTable(dataset, nomTable, nomFichier, dtOldTable, new VersionManager(0, 0), false))
            {
                gs.UpdateTable(nomTable, dtOldTable);
                return false;
            }
            return true;*/
        }
        public bool ChargerFichierTable(String dataset, String nomTable, String srcdataset, String srcnomTable)
        {
            DataManagement.DataManager gs = GetDataManager(dataset);
            if ((gs == null) || (!gs.Exist(nomTable)))
                return false;
            DataTable destTable = gs.GetTable(nomTable).Table;
            gs = GetDataManager(srcdataset);
            if ((gs == null) || (!gs.Exist(srcnomTable)))
                return false;
           
            DataTable srcTable = gs.GetTable(srcnomTable).Table;
            if (destTable.Columns.Count != srcTable.Columns.Count)
                return false;
            bool bConvertType = false;
            for (int i = 0; i < srcTable.Columns.Count; i++)
            {
                if (srcTable.Columns[i].ColumnName != destTable.Columns[i].ColumnName)
                {
                    return false;
                }
                if (srcTable.Columns[i].DataType != destTable.Columns[i].DataType)
                {
                    bConvertType = true;
                    if (FonctionsType.isBoolean(destTable.Columns[i].DataType))
                    {
                        if (!FonctionsType.isBoolean(srcTable.Columns[i].DataType))
                            return false;
                    }
                    else if (FonctionsType.isInt(destTable.Columns[i].DataType))
                    {
                        if (!(FonctionsType.isDouble(srcTable.Columns[i].DataType) ||
                            (FonctionsType.isString(srcTable.Columns[i].DataType))))
                            return false;
                    }
                    else if (FonctionsType.isDouble(destTable.Columns[i].DataType))
                    {
                        if (!(FonctionsType.isInt(srcTable.Columns[i].DataType) ||
                            (FonctionsType.isString(srcTable.Columns[i].DataType))))
                            return false;
                    }
                    else if (FonctionsType.isString(destTable.Columns[i].DataType))
                    {
                    }
                    else if (FonctionsType.isDate(destTable.Columns[i].DataType))
                    {
                        if (!FonctionsType.isDate(srcTable.Columns[i].DataType))
                            return false;
                    }
                    else if (FonctionsType.isTime(destTable.Columns[i].DataType))
                    {
                        if (!FonctionsType.isTime(srcTable.Columns[i].DataType))
                            return false;
                    }
                    else
                    {
                        /*FonctionsTypes*/
                        return false;
                    }
                }
            }
            if (bConvertType)
            {
                //The types are not completely incompatibles.
                DataTable dtConvertedTable = destTable.Clone();
                foreach (DataRow drRow in srcTable.Rows)
                {
                    DataRow drNew = dtConvertedTable.NewRow();
                    for (int i = 0; i < srcTable.Columns.Count; i++)
                    {
                        if (dtConvertedTable.Columns[i].DataType != srcTable.Columns[i].DataType)
                            drNew[i] = drRow[i];
                        else
                        {
                            if (FonctionsType.isBoolean(dtConvertedTable.Columns[i].DataType))
                            {
                                drNew[i] = FonctionsType.getBoolean(drRow[i], srcTable.Columns[i].DataType);
                            }
                            else if (FonctionsType.isInt(destTable.Columns[i].DataType))
                            {
                                drNew[i] = FonctionsType.getInt(drRow[i], srcTable.Columns[i].DataType);
                            }
                            else if (FonctionsType.isDouble(destTable.Columns[i].DataType))
                            {
                                drNew[i] = FonctionsType.getDouble(drRow[i], srcTable.Columns[i].DataType);
                            }
                            else if (FonctionsType.isString(destTable.Columns[i].DataType))
                            {
                                drNew[i] = FonctionsType.getString(drRow[i], srcTable.Columns[i].DataType);
                            }
                            else if (FonctionsType.isDate(destTable.Columns[i].DataType))
                            {
                                drNew[i] = FonctionsType.getDate(drRow[i], srcTable.Columns[i].DataType);
                            }
                            else if (FonctionsType.isTime(destTable.Columns[i].DataType))
                            {
                                drNew[i] = FonctionsType.getTime(drRow[i], srcTable.Columns[i].DataType);
                            }
                        }
                    }
                    dtConvertedTable.Rows.Add(drNew);
                }
                srcTable = dtConvertedTable;
            }
            DataTable NewTable;
                    NewTable = srcTable.Copy();
                    NewTable.TableName = destTable.TableName;
            /*
            if (dataset == "Input")
            {
                if (OverallTools.FonctionUtiles.estPresentDansListe(nomTable, ListeNomTablePAX))
                {
                    if (!VerifierTable(NewTable))
                    {
                        return false;
                    }
                }
            }*/
            bool bSaved = GetDataManager(dataset).UpdateTable(NewTable);
            hadBeenSaved = hadBeenSaved && (!bSaved);
            return bSaved;
        }

        internal bool AddReplaceExceptionTable(String sdataset, String sNomMotherTable, DataTable dtNewExceptionTable, String sExceptionType)
        {
            NormalTable ntTmp = GetTable(sdataset, sNomMotherTable);
            if (!(ntTmp is ExceptionTable))
                return false;
            if (dtNewExceptionTable == null)
                return false;
            ExceptionTable etTmp = (ExceptionTable)ntTmp;
            VisualisationMode vmMode = etTmp.Mode.Clone();
            if((vmMode.ConditionnalFormatClass !=null) && (vmMode.ConditionnalFormatClass.Length>0))
            {
                if(vmMode.ConditionnalFormatClass[0] is ConditionnalFormatErrors)
                    vmMode.ConditionnalFormatClass = null;
            }
            NormalTable ntExceptionTable = new NormalTable(dtNewExceptionTable, vmMode);
            if (sExceptionType.StartsWith(GlobalNames.FirstAndBusiness))
            {
                if (sExceptionType.EndsWith(GlobalNames.Flight))
                {
                    etTmp.ExceptionFlightFB = ntExceptionTable;
                }
                else if (sExceptionType.EndsWith(GlobalNames.Airline))
                {
                    etTmp.ExceptionAirlineFB = ntExceptionTable;
                }
                else if (sExceptionType.EndsWith(GlobalNames.FlightCategory))
                {
                    etTmp.ExceptionFCFB = ntExceptionTable;
                }
                else
                {
                    etTmp.ExceptionFB = ntExceptionTable;
                }
                    return true;
            }
            else
            {
                if (sExceptionType.EndsWith(GlobalNames.Flight))
                {
                    etTmp.ExceptionFlight = ntExceptionTable;
                    return true;
                }
                else if (sExceptionType.EndsWith(GlobalNames.Airline))
                {
                    etTmp.ExceptionAirline = ntExceptionTable;
                    return true;
                }
                else if (sExceptionType.EndsWith(GlobalNames.FlightCategory))
                {
                    etTmp.ExceptionFC = ntExceptionTable;
                    return true;
                }
            }
            return false;
        }

        internal NormalTable GetExceptionTable(String sDataset, String sNomMotherTable, String sExceptionType)
        {
            NormalTable ntTmp = GetTable(sDataset, sNomMotherTable);
            if (!(ntTmp is ExceptionTable))
                return null;
            if (sExceptionType == null)
                return null;
            ExceptionTable etTmp = (ExceptionTable)ntTmp;
            NormalTable ntReturn = null;
            if (sExceptionType.StartsWith(GlobalNames.FirstAndBusiness))
            {
                if (sExceptionType.EndsWith(GlobalNames.Flight))
                {
                    ntReturn = etTmp.ExceptionFlightFB;
                }
                else if (sExceptionType.EndsWith(GlobalNames.Airline))
                {
                    ntReturn = etTmp.ExceptionAirlineFB;
                }
                else if (sExceptionType.EndsWith(GlobalNames.FlightCategory))
                {
                    ntReturn = etTmp.ExceptionFCFB;
                }
                else
                {
                    ntReturn = etTmp.ExceptionFB;
                }
            }
            else
            {
                if (sExceptionType.EndsWith(GlobalNames.Flight))
                {
                    ntReturn = etTmp.ExceptionFlight;
                }
                else if (sExceptionType.EndsWith(GlobalNames.Airline))
                {
                    ntReturn = etTmp.ExceptionAirline;
                }
                else if (sExceptionType.EndsWith(GlobalNames.FlightCategory))
                {
                    ntReturn = etTmp.ExceptionFC;
                }
            }
            return ntReturn;
        }

        internal DataTable getExceptionTable(String sDataset, String sNomMotherTable, String sExceptionType)
        {
            NormalTable ntTmp = GetExceptionTable(sDataset, sNomMotherTable, sExceptionType);
            if (ntTmp == null)
                return null;
            return ntTmp.Table;
        }

        internal GraphicFilter getExceptionTableGraphicFilter(String sDataset, String sNomMotherTable, String sExceptionType)
        {
            NormalTable ntTmp = GetExceptionTable(sDataset, sNomMotherTable, sExceptionType);
            if (ntTmp == null)
                return null;
            return ntTmp.GraphicDefinition;
        }

        internal void AddReplaceExceptionTableGraphicFilter(String sDataset, String sNomMotherTable, String sExceptionType, GraphicFilter gfDefinition)
        {
            NormalTable ntTmp = GetExceptionTable(sDataset, sNomMotherTable, sExceptionType);
            if (ntTmp == null)
                return;
            ntTmp.GraphicDefinition = gfDefinition;
        }


        public double getMaxValue(String dataset, String nomTable, int iColonne)
        {
            if (!tableEstPresente(dataset, nomTable))
                return 0;

            return OverallTools.DataFunctions.getMaxValue(getTable(dataset, nomTable), iColonne);
        }
        public DataRow getLine(String dataset, String nomTable, int iIndexColonne, String value)
        {
            return getLine(getTable(dataset, nomTable), iIndexColonne, value);
        }
        public DataRow getLine(String dataset, String nomTable, int iIndexColonne, int value)
        {
            return getLine(getTable(dataset, nomTable), iIndexColonne, value);
        }
        public static DataRow getLine(DataTable table, int iIndexColonne, int Value)
        {
            if (table == null)
                return null;
            if (table.Columns.Count <= iIndexColonne)
                return null;
            int valeurLigne;
            foreach (DataRow ligne in table.Rows)
            {
                if (Int32.TryParse(ligne.ItemArray[iIndexColonne].ToString(), out valeurLigne))
                {
                    if (Value == valeurLigne)
                        return ligne;
                }
            }
            return null;
        }
        public static DataRow getLine(DataTable table, int iIndexColonne, String Value)
        {
            if (table == null)
                return null;
            if (table.Columns.Count <= iIndexColonne)
                return null;
            foreach (DataRow ligne in table.Rows)
            {
                if (ligne.ItemArray[iIndexColonne].ToString() == Value)
                {
                    return ligne;
                }
            }
            return null;
        }

        #endregion

        #region Pour les paramètres du projet.
        public String getNomProjet()
        {
            return nomProjetPax;
        }
        public void setNomProjet(String nouveauNomProjet)
        {
            HadAlreadyBeenSavedOnDisk = false;
            hadBeenSaved = false;
            nomProjetPax = nouveauNomProjet;
        }

        public bool getAEteEnregistreUneFois() { return HadAlreadyBeenSavedOnDisk; }
        public bool getAEteEnregistre() { return hadBeenSaved; }
        public XmlNode getRacine()
        {
            return structureAeroport;
        }
        public String getDossierEnregistrement()
        {
            return nomDuChemin + "\\";
        }

        public bool getStructureAEteModifie()
        {
            return bAirportStructureHadBeenModified;
        }
        public void setStructureAEteModifie()
        {
            hadBeenSaved = false;
            bAirportStructureHadBeenModified = true;
        }
        #endregion

        #region Pour les warnings et les erreurs générées lors de l'utilisation de cette classe
        public static void EraseWarningsErrorsProject()
        {
            ListeErreurs.Clear();
        }

        public static ArrayList getWarningsErreursProject()
        {
            return ListeErreurs;
        }
        public static ArrayList getWarningsProject()
        {
            ArrayList listWarning = new ArrayList();
            foreach (String elem in ListeErreurs)
            {
                if (elem.Substring(0, 4) == "Warn")
                {
                    listWarning.Add(elem);
                }
            }
            return listWarning;
        }
        public static ArrayList getErreursProject()
        {
            ArrayList listErreurs = new ArrayList();
            foreach (String elem in ListeErreurs)
            {
                if (elem.Substring(0, 3) == "Err")
                {
                    listErreurs.Add(elem);
                }
            }
            return listErreurs;
        }

        public static String getLastError()
        {
            for (int i = ListeErreurs.Count - 1; i >= 0; i--)
            {
                if (ListeErreurs[i].ToString().Substring(0, 3) == "Err")
                {
                    return ListeErreurs[i].ToString();
                }
            }
            return null;
        }
        #endregion

        #region Pour les modes de visualisation des tables.
        

        public VisualisationMode getModeVisualisation(String dataset, String nomTable)
        {
            DataManagement.DataManager gs = GetDataManager(dataset);
            if (gs == null)
                return null;
            if (!gs.Exist(nomTable))
                return null;
            NormalTable ntTable = gs.GetTable(nomTable);
            if(ntTable==null)
                return null;
            return ntTable.Mode;
        }

        public VisualisationMode getModeVisualisation(String dataset, String nomTable, String sExceptionName)
        {
            DataManagement.DataManagerInput gs = GetDataManager(dataset) as DataManagement.DataManagerInput;
            if (gs == null)
                return null;
            NormalTable ntTable = gs.GetTableException(nomTable);
            if (ntTable == null || ntTable.GetType().IsInstanceOfType(typeof(ExceptionTable)))
                return null;
            ntTable = (ntTable as ExceptionTable).GetExceptionTable(sExceptionName);
            if (ntTable == null)
                return null;
            return ntTable.Mode;
        }

        public void AddReplaceModeVisualisation(String dataset, String nomTable, VisualisationMode mode)
        {
            DataManagement.DataManager gs = GetDataManager(dataset);
            if (gs == null)
                return;
            hadBeenSaved = false;
            gs.UpdateModeVisualisation(nomTable, mode);
        }

        #endregion

        #region Pour la structure de l'aéroport.

        #region public ArrayList getAllGroups()
        /// <summary>
        /// Fonction qui renvoie tous les groupes constituant l'aéroport pour la partie passager, ainsi que tous les Levels
        /// </summary>
        /// <returns></returns>
        public ArrayList getAllGroups()
        {
            return MajTableFromTRV(structureAeroport, "", "", 2);
        }
        /// <summary>
        /// Fonction qui renvoie tous les groupes constituant l'aéroport pour la partie passager, ainsi que tous les Levels
        /// </summary>
        /// <returns></returns>
        public List<String> getAllGroups2()
        {
            ArrayList alList = MajTableFromTRV(structureAeroport, "", "", 2);
            List<String> alResult = new List<string>();
            foreach (String sTmp in alList)
            {
                alResult.Add(sTmp);
            }
            alList.Clear();
            alList = null;
            return alResult;
        }
        /// <summary>
        /// Fonction qui renvoie tous les groupes constituant l'aéroport pour la partie BHS.
        /// </summary>
        /// <returns></returns>
        public ArrayList getAllBHSGroups(int iTerminal)
        {
            return MajTableFromTRV(structureAeroport, iTerminal, 0, 25, 0);
        }
        /// <summary>
        /// Fonction qui renvoie tous les groupes constituant l'aéroport pour la partie BHS.
        /// </summary>
        /// <returns></returns>
        public ArrayList getAllBHSGroups()
        {
            return MajTableFromTRV(structureAeroport, -1, 0, 27, 0);
        }
        public ArrayList getAllGroupsDescriptions()
        {
            return MajTableFromTRV(structureAeroport, "", "", 2, true);
        }

        public ArrayList getAllBHSGroupsDescriptions(int iTerminal)
        {
            return MajTableFromTRV(structureAeroport, iTerminal, 0, 26, 0);
        }
        public ArrayList getAllBHSGroupsDescriptions()
        {
            return MajTableFromTRV(structureAeroport, -1, 0, 28, 0);
        }
        #endregion

        /*
        internal class AlphoToNum
        {
            internal static Boolean bIndexFirst= true;
            private String sName;
            private int iIndex;
            private String sType;
            private List<AlphoToNum> atnChilds;
            internal AlphoToNum(String Name, int Index, String Type)
            {
                sName = Name;
                iIndex = Index;
                sType = Type;
                atnChilds = null;
            }
            internal void AddChild(AlphoToNum atnNewChild)
            {
                if (atnChilds == null)
                    atnChilds = new List<AlphoToNum>();
                atnChilds.Add(atnNewChild);
            }
            internal AlphoToNum getChild(String Type, int Index)
            {
                if ((this.sType == Type) && (this.iIndex == Index))
                    return this;
                foreach (AlphoToNum atnTmp in atnChilds)
                {
                    AlphoToNum atnResult = atnTmp.getChild(Type, Index);
                    if (atnResult != null)
                        return atnResult;
                }
                return null;
            }
            internal AlphoToNum getChild(String Type, String Name)
            {
                if ((this.sType == Type) && (this.sName== Name))
                    return this;
                foreach (AlphoToNum atnTmp in atnChilds)
                {
                    AlphoToNum atnResult = atnTmp.getChild(Type, Name);
                    if (atnResult != null)
                        return atnResult;
                }
                return null;
            }
            public override string ToString()
            {
                if (bIndexFirst)
                    return iIndex.ToString() + " ( " + sName + " )";
                return sName + " ( " + iIndex.ToString() + " )";
            }
            internal List<AlphoToNum> getListObject(String Type)
            {
                List<AlphoToNum> latnResults = null;
                if (sType == Type)
                {
                    latnResults = new List<AlphoToNum>();
                    latnResults.Add(this);
                    return latnResults;
                }
                else if ((atnChilds == null) || (atnChilds.Count == 0))
                    return null;
                latnResults = new List<AlphoToNum>();
                foreach (AlphoToNum atnTmp in atnChilds)
                {
                    latnResults.AddRange( atnTmp.getListObject(Type));
                }
                if (latnResults.Count == 0)
                    return null;
                return latnResults;
            }
        }



        private void createAirportLinksTable(System.Xml.XmlNode Noeudxml)
        {
            
            foreach (System.Xml.XmlNode Noeud in Noeudxml.ChildNodes)
            {

                
                //(Noeud.Name)
                XmlElement newNoeud = projet.CreateElement(Noeud.Name.Replace(' ', '_'));
                Noeudxml.AppendChild(newNoeud);
                newNoeud.SetAttribute("Type", Noeud.Name);
                TreeViewTag tag = (TreeViewTag)Noeud.Tag;
                newNoeud.SetAttribute("Index", tag.Index.ToString());
                newNoeud.SetAttribute("Name", tag.Name);
                if (tag.Visible)
                {
                    newNoeud.SetAttribute("X", tag.Location.X.ToString());
                    newNoeud.SetAttribute("Y", tag.Location.Y.ToString());
                }
                if (tag.BHSVisible)
                {
                    newNoeud.SetAttribute("BHS_X", tag.BHSLocation.X.ToString());
                    newNoeud.SetAttribute("BHS_Y", tag.BHSLocation.Y.ToString());
                }
                construireArbreAeroport(Noeud, newNoeud);
            }
        }*/

        #region Pour les terminaux
        /// <summary>
        /// Fonction qui retourne les noms des différents terminaux contenus dans la structure d'aéroport
        /// </summary>
        /// <returns>La table avec tous les noms des terminaux</returns>
        public String[] getTerminal()
        {
            return getTerminal(structureAeroport, bUseAlphNumericForFlightInfo);
        }
        /// <summary>
        /// Fonction qui retourne les noms des différents terminaux contenus dans la structure d'aéroport
        /// </summary>
        /// <param name="racine">La racine de l'aéroport à analyser.</param>
        /// <returns></returns>
        public static String[] getTerminal(XmlNode racine, bool bUseAlpha)
        {
            if (racine == null)
                return null;
            if (racine.ChildNodes.Count == 0)
                return null;
            if (racine.Name != PAX2SIM.sMainNodeName)
                return null;

            int iNbTerminal = 0;
            foreach (XmlNode node in racine.ChildNodes)
            {
                if (node.Attributes["Type"].Value == PAX2SIM.sTerminalName)
                    iNbTerminal++;
            }
            if (iNbTerminal == 0)
                return null;
            String[] resultat = new String[iNbTerminal];
            int iIndexresult = 0;
            for (int i = 0; i < racine.ChildNodes.Count; i++)
            {
                if (racine.ChildNodes[i].Attributes["Type"].Value == PAX2SIM.sTerminalName)
                {
                    resultat[iIndexresult] = ConvertName(racine.ChildNodes[i].Attributes["Index"].Value, racine.ChildNodes[i].Attributes["Name"].Value, bUseAlpha);
                    iIndexresult++;
                }
            }
            return resultat;
        }
        /// <summary>
        /// Fonction qui renvoie le noeud Xml du terminal désigné.
        /// </summary>
        /// <param name="racine">La racine Xml de l'aéroport</param>
        /// <param name="iIndexTerminalRecherche">l'index du terminal recherché</param>
        /// <returns></returns>
        public static XmlNode getTerminal(XmlNode racine, int iIndexTerminalRecherche)
        {
            if (racine == null)
                return null;
            if (racine.ChildNodes.Count == 0)
                return null;
            if (iIndexTerminalRecherche == -1)
                return null;
            //On recherche dans la structure de l'aéroport le terminal sélectionné
            int iIndexTerminal = -1;
            for (int i = 0; i < racine.ChildNodes.Count; i++)
            {
                if (racine.ChildNodes[i].Attributes["Type"].Value != PAX2SIM.sTerminalName)
                    continue;
                if (iIndexTerminalRecherche == FonctionsType.getInt(racine.ChildNodes[i].Attributes["Index"].Value))// + " ( " + racine.ChildNodes[i].Attributes["Name"].Value + " )")
                {
                    iIndexTerminal = i;
                    break;
                }
            }
            if (iIndexTerminal == -1)
                return null;
            return racine.ChildNodes[iIndexTerminal];
        }

        /// <summary>
        /// Fonction qui renvoie le noeud Xml du terminal désigné.
        /// </summary>
        /// <param name="racine">La racine Xml de l'aéroport</param>
        /// <param name="sDescriptionRecherche">Description du terminal recherché</param>
        /// <returns></returns>
        public static XmlNode getTerminalByDescription(XmlNode racine, String sDescriptionRecherche)
        {
            if (racine == null)
                return null;
            if (racine.ChildNodes.Count == 0)
                return null;
            if ((sDescriptionRecherche == "") || (sDescriptionRecherche == null))
                return null;
            int iIndex = sDescriptionRecherche.LastIndexOf("(");
            if (iIndex > 0)
            {
                sDescriptionRecherche = sDescriptionRecherche.Substring(0, iIndex);
            }
            for (int i = 0; i < racine.ChildNodes.Count; i++)
            {
                if (racine.ChildNodes[i].Attributes["Type"].Value != PAX2SIM.sTerminalName)
                    continue;
                String sDescription = racine.ChildNodes[i].Attributes["Name"].Value.ToString();
                if (sDescription.IndexOf(":") != -1)
                    sDescription = sDescription.Substring(0, sDescription.IndexOf(":"));
                if (sDescription.ToLower().Trim() == sDescriptionRecherche.ToLower().Trim())
                {
                    return racine.ChildNodes[i];
                }
            }
            return null;
        }
        /// <summary>
        /// Fonction qui renvoie le noeud Xml du terminal désigné.
        /// </summary>
        /// <param name="racine">La racine Xml de l'aéroport</param>
        /// <param name="Terminal">Le nom du terminal "x ( Name )" ou x est l'index du terminal et Name son nom</param>
        /// <returns></returns>
        public static XmlNode getTerminal(XmlNode racine, String Terminal)
        {/*
            if (bUseAlphNumericForFlightInfo)
                return getTerminalByDescription(racine, Terminal);*/
            if (racine == null)
                return null;
            if (racine.ChildNodes.Count == 0)
                return null;
            if (racine.Name != PAX2SIM.sMainNodeName)
                return null;
            int iTerminal;
            String sTerminal = OverallTools.FonctionUtiles.Substring(Terminal);
            if (!Int32.TryParse(sTerminal, out iTerminal))
                return null;
            return getTerminal(racine, iTerminal);
        }
        #endregion

        #region Pour les levels
        /// <summary>
        /// Fonction qui renvoie le noeud XML du level désiré.
        /// </summary>
        /// <param name="racine">La racine Xml de l'aéroport</param>
        /// <param name="iTerminal">Le terminal dans lequel le level se situe</param>
        /// <param name="iLevel">Le nom du level désiré</param>
        /// <returns></returns>
        public static XmlNode getLevel(XmlNode racine, int iTerminal, int iLevel)
        {
            if (racine == null)
                return null;
            if (racine.ChildNodes.Count == 0)
                return null;
            if (iLevel <= 0)
                return null;
            XmlNode xmlTerminal = getTerminal(racine, iTerminal);
            if (xmlTerminal == null)
                return null;
            int iIndexLevel = -1;
            for (int i = 0; i < xmlTerminal.ChildNodes.Count; i++)
            {
                if (xmlTerminal.ChildNodes[i].Attributes["Type"].Value != PAX2SIM.sLevelName)
                    continue;
                if (iLevel == FonctionsType.getInt(xmlTerminal.ChildNodes[i].Attributes["Index"].Value))
                {
                    iIndexLevel = i;
                    break;
                }
            }
            if (iIndexLevel == -1)
                return null;
            return xmlTerminal.ChildNodes[iIndexLevel];
        }

        public static XmlNode getLevelByDescription(XmlNode racine, String sDescriptionTerminal, String sDescriptionLevel)
        {
            if (racine == null)
                return null;
            if (racine.ChildNodes.Count == 0)
                return null;
            if ((sDescriptionLevel == "") || (sDescriptionLevel == null))
                return null;
            XmlNode xmlTerminal = getTerminalByDescription(racine, sDescriptionTerminal);
            if (xmlTerminal == null)
                return null;
            for (int i = 0; i < xmlTerminal.ChildNodes.Count; i++)
            {
                if (xmlTerminal.ChildNodes[i].Attributes["Type"].Value != PAX2SIM.sLevelName)
                    continue;

                String sDescription = xmlTerminal.ChildNodes[i].Attributes["Name"].Value.ToString();
                if (sDescription.IndexOf(":") != -1)
                    sDescription = sDescription.Substring(0, sDescription.IndexOf(":"));
                if (sDescription.ToLower().Trim() == sDescriptionLevel.ToLower().Trim())
                {
                    return xmlTerminal.ChildNodes[i];
                }
            }
            return null;
        }
        public static String getLevelByDescription(XmlNode racine, String sTerminal, String sGroupType, String sIndex)
        {
            if (racine == null)
                return null;
            if (racine.ChildNodes.Count == 0)
                return null;
            XmlNode[] xnGroup = getGroupByDescription(racine, sTerminal, sGroupType);
            if ((xnGroup == null) || (xnGroup.Length == 0))
                return "";
            foreach (XmlNode node in xnGroup)
            {
                if (node.ChildNodes.Count == 0)
                    continue;
                foreach (XmlNode ChildNode in node.ChildNodes)
                {
                    String sDescription = ChildNode.Attributes["Name"].Value;
                    if (sDescription.IndexOf(":") != -1)
                        sDescription = sDescription.Substring(0, sDescription.IndexOf(":"));
                    if (sDescription.Trim().ToLower() == sIndex.Trim().ToLower())
                    {
                        return ConvertName(node.ParentNode.Attributes["Index"].Value.ToString(), node.ParentNode.Attributes["Name"].Value.ToString(), true);
                        //return node.ParentNode.Attributes["Index"].Value + " ( Level )";
                    }
                }
            }
            return "";
        }

        public static String getLevel(XmlNode racine, String sTerminal, String sGroupType, String sIndex, bool bUseAlpha)
        {
            if (racine == null)
                return null;
            if (racine.ChildNodes.Count == 0)
                return null;
            int iTerminal, iIndex;
            if (bUseAlpha)
            {
                return getLevelByDescription(racine, sTerminal, sGroupType, sIndex);
            }
            //String Terminal = OverallTools.FonctionUtiles.Substring(sTerminal);
            //String Index = OverallTools.FonctionUtiles.Substring(sIndex);
            if ((!Int32.TryParse(sTerminal, out iTerminal)) || (!Int32.TryParse(sIndex, out iIndex)))
                return "";
            return getLevel(racine, iTerminal, sGroupType, iIndex, bUseAlpha);
        }
        public static String getLevel(XmlNode racine, int iTerminal, String sGroupType, int iIndex, bool bUseAlpha)
        {
            XmlNode[] xnGroup = getGroup(racine, iTerminal, sGroupType);
            if ((xnGroup == null) || (xnGroup.Length == 0))
                return "";
            foreach (XmlNode node in xnGroup)
            {
                if (node.ChildNodes.Count == 0)
                    continue;
                foreach (XmlNode ChildNode in node.ChildNodes)
                {
                    if (ChildNode.Attributes["Index"].Value == iIndex.ToString())
                    {
                        return ConvertName(node.ParentNode.Attributes["Index"].Value.ToString(), node.ParentNode.Attributes["Name"].Value.ToString(), bUseAlpha);
                        //return node.ParentNode.Attributes["Index"].Value + " ( Level )";
                    }
                }
            }
            return "";
        }

        public String getCheckInLevel(String sTerminal, String sDesk)
        {
            return getLevel(structureAeroport, ConvertName(sTerminal, bUseAlphNumericForFlightInfo), PAX2SIM.sCheckInGroup, ConvertName(sDesk, bUseAlphNumericForFlightInfo), bUseAlphNumericForFlightInfo);
        }
        public String getBoardingGateLevel(String sTerminal, String sDesk)
        {
            return getLevel(structureAeroport, ConvertName(sTerminal, bUseAlphNumericForFlightInfo), "Boarding Gate Group", ConvertName(sDesk, bUseAlphNumericForFlightInfo), bUseAlphNumericForFlightInfo);
        }
        public String getArrivalGateLevel(String sTerminal, String sDesk)
        {
            return getLevel(structureAeroport, ConvertName(sTerminal, bUseAlphNumericForFlightInfo), "Arrival Gate Group", ConvertName(sDesk, bUseAlphNumericForFlightInfo), bUseAlphNumericForFlightInfo);
        }
        public String getBaggageClaimLevel(String sTerminal, String sDesk)
        {
            return getLevel(structureAeroport, ConvertName(sTerminal, bUseAlphNumericForFlightInfo), "Baggage Claim Group", ConvertName(sDesk, bUseAlphNumericForFlightInfo), bUseAlphNumericForFlightInfo);
        }
        #endregion

        #region Partie BHS ou autre qui n'a aucun lien avec les levels.
        #region Pour les parkings
        /// <summary>
        /// Fonction qui renvoie les noms des Levels contenus dans le terminal sélectionné.
        /// </summary>
        /// <param name="Terminal">Le terminal à analyser</param>
        /// <returns></returns>
        public String[] getParking(String Terminal)
        {
            return getParking(structureAeroport, Terminal, bUseAlphNumericForFlightInfo);
        }
        /// <summary>
        /// Fonction qui renvoie les noms des Levels contenus dans le terminal sélectionné.
        /// </summary>
        /// <param name="racine">La racine Xml de l'aéroport</param>
        /// <param name="Terminal">Le terminal à analyser</param>
        /// <returns></returns>
        public static String[] getParking(XmlNode racine, String Terminal, bool bUseAlpha)
        {
            if (racine == null)
                return null;
            if (racine.ChildNodes.Count == 0)
                return null;
            XmlNode noeud;
            if (bUseAlpha)
            {
                noeud = getTerminalByDescription(racine, Terminal);
            }
            else
            {
                noeud = getTerminal(racine, Terminal);
            }
            if (noeud == null)
                return null;
            String[] resultat = null;
            for (int i = 0; i < noeud.ChildNodes.Count; i++)
            {
                if (noeud.ChildNodes[i].Attributes["Type"].Value == "Aircraft Parking Stands")
                {
                    resultat = new String[noeud.ChildNodes[i].ChildNodes.Count];
                    for (int j = 0; j < noeud.ChildNodes[i].ChildNodes.Count; j++)
                    {
                        XmlNode node = noeud.ChildNodes[i].ChildNodes[j];
                        resultat[j] = ConvertName(node.Attributes["Index"].Value, node.Attributes["Name"].Value, bUseAlpha);
                        /*if (bUseAlpha)
                        {
                            resultat[j] = node.Attributes["Name"].Value + " ( " + node.Attributes["Index"].Value + " )";
                        }
                        else
                        {
                            resultat[j] = node.Attributes["Index"].Value + " ( " + node.Attributes["Name"].Value + " )";
                        }*/
                    }
                }
            }
            return resultat;
        }
        #endregion

        #region Pour les MakeUp
        /// <summary>
        /// Fonction qui renvoie les noms des Levels contenus dans le terminal sélectionné.
        /// </summary>
        /// <param name="Terminal">Le terminal à analyser</param>
        /// <returns></returns>
        public String[] getMakeUp(String Terminal)
        {
            return getMakeUp(structureAeroport, Terminal, bUseAlphNumericForFlightInfo);
        }
        /// <summary>
        /// Fonction qui renvoie les noms des Levels contenus dans le terminal sélectionné.
        /// </summary>
        /// <param name="racine">La racine Xml de l'aéroport</param>
        /// <param name="Terminal">Le terminal à analyser</param>
        /// <returns></returns>
        public static String[] getMakeUp(XmlNode racine, String Terminal, bool bUseAlpha)
        {
            if (racine == null)
                return null;
            if (racine.ChildNodes.Count == 0)
                return null;
            XmlNode noeud;
            if (bUseAlpha)
            {
                noeud = getTerminalByDescription(racine, Terminal);
            }
            else
            {
                noeud = getTerminal(racine, Terminal);
            }
            if (noeud == null)
                return null;

            //il faut ensuite trouver la partie BHS réservée pour le terminal en question
            XmlNode NoeudBHS = null;
            for (int i = 0; i < noeud.ChildNodes.Count; i++)
            {
                if (noeud.ChildNodes[i].Attributes["Type"].Value == PAX2SIM.sBHSName)
                {
                    NoeudBHS = noeud.ChildNodes[i];
                    break;
                }
            }
            if (NoeudBHS == null)
                return null;
            ArrayList alPostes = new ArrayList();
            //Ensuite il faut rechercher les groupes Make-Up présent dans le BHS.
            for (int i = 0; i < NoeudBHS.ChildNodes.Count; i++)
            {
                if (NoeudBHS.ChildNodes[i].Attributes["Type"].Value == "Make-Up Group")
                {
                    foreach (XmlNode MakeUpNode in NoeudBHS.ChildNodes[i].ChildNodes)
                    {
                        alPostes.Add(ConvertName(MakeUpNode.Attributes["Index"].Value, MakeUpNode.Attributes["Name"].Value, bUseAlpha));
                        /*if (bUseAlpha)
                        {
                            alPostes.Add(MakeUpNode.Attributes["Name"].Value + " ( " + MakeUpNode.Attributes["Index"].Value + " )");
                        }
                        else
                        {
                            alPostes.Add(MakeUpNode.Attributes["Index"].Value + " ( " + MakeUpNode.Attributes["Name"].Value + " )");
                        }*/
                    }
                }
            }
            if (alPostes.Count == 0)
                return null;
            String[] resultat = new string[alPostes.Count];
            for (int i = 0; i < alPostes.Count; i++)
            {
                resultat[i] = alPostes[i].ToString();
            }
            return resultat;
        }
        #endregion

        #region Pour les RunWays
        /// <summary>
        /// Fonction qui renvoie les noms des Levels contenus dans le terminal sélectionné.
        /// </summary>
        /// <returns></returns>
        public String[] getRunWay()
        {
            return getRunWay(structureAeroport, bUseAlphNumericForFlightInfo);
        }
        /// <summary>
        /// Fonction qui renvoie les noms des Levels contenus dans le terminal sélectionné.
        /// </summary>
        /// <param name="racine">La racine Xml de l'aéroport</param>
        /// <returns></returns>
        public static String[] getRunWay(XmlNode racine, bool bUseAlpha)
        {
            if (racine == null)
                return null;
            if (racine.ChildNodes.Count == 0)
                return null;

            //il faut ensuite trouver la partie BHS réservée pour le terminal en question
            XmlNode NoeudRunWays = null;
            for (int i = 0; i < racine.ChildNodes.Count; i++)
            {
                if (racine.ChildNodes[i].Attributes["Type"].Value == "Runways")
                {
                    NoeudRunWays = racine.ChildNodes[i];
                    break;
                }
            }
            if ((NoeudRunWays == null) || (NoeudRunWays.ChildNodes.Count == 0))
                return null;
            String[] resultat = new string[NoeudRunWays.ChildNodes.Count];
            for (int i = 0; i < NoeudRunWays.ChildNodes.Count; i++)
            {
                resultat[i] = ConvertName(NoeudRunWays.ChildNodes[i].Attributes["Index"].Value, NoeudRunWays.ChildNodes[i].Attributes["Name"].Value, bUseAlpha);
            }
            return resultat;
        }
        public static XmlNode getRunways(XmlNode xmlRacine)
        {
            for (int j = 0; j < xmlRacine.ChildNodes.Count; j++)
            {
                if (xmlRacine.ChildNodes[j].Attributes["Type"].Value == "Runways")
                {
                    return xmlRacine.ChildNodes[j];
                }
            }
            return null;
        }
        #endregion

        #region Pour les Transfer Infeed
        /// <summary>
        /// Fonction qui renvoie les noms des Levels contenus dans le terminal sélectionné.
        /// </summary>
        /// <param name="Terminal">Le terminal à analyser</param>
        /// <returns></returns>
        public String[] getTransferInfeed(String Terminal)
        {
            return getTransferInfeed(structureAeroport, Terminal, bUseAlphNumericForFlightInfo);
        }
        /// <summary>
        /// Fonction qui renvoie les noms des Levels contenus dans le terminal sélectionné.
        /// </summary>
        /// <param name="racine">La racine Xml de l'aéroport</param>
        /// <param name="Terminal">Le terminal à analyser</param>
        /// <returns></returns>
        public static String[] getTransferInfeed(XmlNode racine, String Terminal, bool bUseAlpha)
        {
            if (racine == null)
                return null;
            if (racine.ChildNodes.Count == 0)
                return null;
            XmlNode noeud;
            if (bUseAlpha)
            {
                noeud = getTerminalByDescription(racine, Terminal);
            }
            else
            {
                noeud = getTerminal(racine, Terminal);
            }
            if (noeud == null)
                return null;

            //il faut ensuite trouver la partie BHS réservée pour le terminal en question
            XmlNode NoeudBHS = null;
            for (int i = 0; i < noeud.ChildNodes.Count; i++)
            {
                if (noeud.ChildNodes[i].Attributes["Type"].Value == PAX2SIM.sBHSName)
                {
                    NoeudBHS = noeud.ChildNodes[i];
                    break;
                }
            }
            if (NoeudBHS == null)
                return null;
            ArrayList alPostes = new ArrayList();
            //Ensuite il faut rechercher les groupes Make-Up présent dans le BHS.
            for (int i = 0; i < NoeudBHS.ChildNodes.Count; i++)
            {
                if (NoeudBHS.ChildNodes[i].Attributes["Type"].Value == BHS_String_TransferInfeedGroup)
                {
                    foreach (XmlNode TransferNode in NoeudBHS.ChildNodes[i].ChildNodes)
                    {
                        alPostes.Add(ConvertName(TransferNode.Attributes["Index"].Value, TransferNode.Attributes["Name"].Value, bUseAlpha));
                        /*
                                if (bUseAlpha)
                                {
                                    alPostes.Add(TransferNode.Attributes["Name"].Value + " ( " + TransferNode.Attributes["Index"].Value + " )");
                                }
                                else
                                {
                                    alPostes.Add(TransferNode.Attributes["Index"].Value + " ( " + TransferNode.Attributes["Name"].Value + " )");
                                }*/
                    }
                }
            }
            if (alPostes.Count == 0)
                return null;
            String[] resultat = new string[alPostes.Count];
            for (int i = 0; i < alPostes.Count; i++)
            {
                resultat[i] = alPostes[i].ToString();
            }
            return resultat;
        }
        #endregion

        #region Pour les Arrival Infeed
        /// <summary>
        /// Fonction qui renvoie les noms des Levels contenus dans le terminal sélectionné.
        /// </summary>
        /// <param name="Terminal">Le terminal à analyser</param>
        /// <returns></returns>
        public String[] getArrivalInfeed(String Terminal)
        {
            return getArrivalInfeed(structureAeroport, Terminal, bUseAlphNumericForFlightInfo);
        }
        /// <summary>
        /// Fonction qui renvoie les noms des Levels contenus dans le terminal sélectionné.
        /// </summary>
        /// <param name="racine">La racine Xml de l'aéroport</param>
        /// <param name="Terminal">Le terminal à analyser</param>
        /// <returns></returns>
        public static String[] getArrivalInfeed(XmlNode racine, String Terminal, bool bUseAlpha)
        {
            if (racine == null)
                return null;
            if (racine.ChildNodes.Count == 0)
                return null;
            XmlNode noeud;
            if (bUseAlpha)
            {
                noeud = getTerminalByDescription(racine, Terminal);
            }
            else
            {
                noeud = getTerminal(racine, Terminal);
            }
            if (noeud == null)
                return null;

            //il faut ensuite trouver la partie BHS réservée pour le terminal en question
            XmlNode NoeudBHS = null;
            for (int i = 0; i < noeud.ChildNodes.Count; i++)
            {
                if (noeud.ChildNodes[i].Attributes["Type"].Value == PAX2SIM.sBHSName)
                {
                    NoeudBHS = noeud.ChildNodes[i];
                    break;
                }
            }
            if (NoeudBHS == null)
                return null;
            ArrayList alPostes = new ArrayList();
            //Ensuite il faut rechercher les groupes Make-Up présent dans le BHS.
            for (int i = 0; i < NoeudBHS.ChildNodes.Count; i++)
            {
                if (NoeudBHS.ChildNodes[i].Attributes["Type"].Value == BHS_String_ArrivalInfeedGroup)
                {
                    foreach (XmlNode TransferNode in NoeudBHS.ChildNodes[i].ChildNodes)
                    {
                        alPostes.Add(ConvertName(TransferNode.Attributes["Index"].Value, TransferNode.Attributes["Name"].Value, bUseAlpha));

                        /* if (bUseAlpha)
                         {
                             alPostes.Add(TransferNode.Attributes["Name"].Value + " ( " + TransferNode.Attributes["Index"].Value + " )");
                         }
                         else
                         {
                             alPostes.Add(TransferNode.Attributes["Index"].Value + " ( " + TransferNode.Attributes["Name"].Value + " )");
                         }*/
                    }
                }
            }
            if (alPostes.Count == 0)
                return null;
            String[] resultat = new string[alPostes.Count];
            for (int i = 0; i < alPostes.Count; i++)
            {
                resultat[i] = alPostes[i].ToString();
            }
            return resultat;
        }
        #endregion
        /*
        /// <summary>
        /// Fonction qui renvoie le groupe auquel appartient le bureau sélectionné dans le level et le terminal désigné
        /// </summary>
        /// <param name="racine">La structure XML de l'aéroport</param>
        /// <param name="Terminal">Le Terminal analysé</param>
        /// <param name="Level">Le level analysé</param>
        /// <param name="nomGroup">Le type de groupe auquel appartient le bureau</param>
        /// <param name="DeskStart">Le bureau recherché.</param>
        /// <returns></returns>
        public static XmlNode getGroup(XmlNode racine, String Terminal, String nomGroup, String DeskStart)
        {
            int iTerminal, iDeskStart;
            String sTerminal = OverallTools.FonctionUtiles.Substring(Terminal);
            if ((!Int32.TryParse(sTerminal, out iTerminal)) ||
                (!Int32.TryParse(DeskStart, out iDeskStart)))
                return null;
            return getGroup(racine, iTerminal, nomGroup, iDeskStart);
        }
        /// <summary>
        /// Fonction qui renvoie le groupe auquel appartient le bureau sélectionné dans le level et le terminal désigné
        /// </summary>
        /// <param name="iTerminal">Le Terminal analysé</param>
        /// <param name="iLevel">Le level analysé</param>
        /// <param name="nomGroup">Le type de groupe auquel appartient le bureau</param>
        /// <param name="iDeskStart">Le bureau recherché.</param>
        /// <returns></returns>
        public static XmlNode getGroup(XmlNode racine, int iTerminal,  String nomGroup, int iDeskStart)
        {
            XmlNode[] xmlGroupes = getGroup(racine, iTerminal, nomGroup);
            if (xmlGroupes == null)
                return null;
            for (int i = 0; i < xmlGroupes.Length; i++)
            {
                for (int j = 0; j < xmlGroupes[i].ChildNodes.Count; j++)
                {
                    if (Convert.ToInt32(xmlGroupes[i].ChildNodes[j].Attributes["Index"].Value) == iDeskStart)
                    {
                        return xmlGroupes[i];
                    }
                }
            }
            return null;
        }

        */
        #endregion

        #region Pour les groupes
        // >> Task #13659 IST MakeUp segregation        
        public static string AIRPORT_XML_NODE_INDEX_ATTRIBUTE_NAME = "Index";
        public static string AIRPORT_XML_NODE_DESCRIPTION_ATTRIBUTE_NAME = "Name";
        // << Task #13659 IST MakeUp segregation

        private static XmlNode[] getGroup(XmlNode xmlTerminal, String nomGroup)
        {
            List<XmlNode> lsGroup = new List<XmlNode>();
            for (int j = 0; j < xmlTerminal.ChildNodes.Count; j++)
            {/*
                if (xmlTerminal.ChildNodes[j].Attributes["Type"].Value == PAX2SIM.sLevelName)
                {*/
                for (int i = 0; i < xmlTerminal.ChildNodes[j].ChildNodes.Count; i++)
                {
                    if (xmlTerminal.ChildNodes[j].ChildNodes[i].Attributes["Type"].Value == nomGroup)
                    {
                        lsGroup.Add(xmlTerminal.ChildNodes[j].ChildNodes[i]);
                    }
                }
                /*}*/
            }
            if (lsGroup.Count == 0)
                return null;
            XmlNode[] resultats = new XmlNode[lsGroup.Count];
            for (int i = 0; i < resultats.Length; i++)
                resultats[i] = lsGroup[i];

            return resultats;
        }

        /// <summary>
        /// Fonction qui renvoi tous les groupes du type spécifié contenus dans le label spécifié.
        /// </summary>
        /// <param name="racine">La structure xml de l'aéroport</param>
        /// <param name="iTerminal">Le nom du terminal désiré</param>
        /// <param name="iLevel">Le nom du level voulu</param>
        /// <param name="nomGroup">le type de groupe recherché.</param>
        /// <returns></returns>
        public static XmlNode[] getGroup(XmlNode racine, int iTerminal, String nomGroup)
        {
            if (racine == null)
                return null;
            if (racine.ChildNodes.Count == 0)
                return null;
            XmlNode xmlTerminal = getTerminal(racine, iTerminal);
            if (xmlTerminal == null)
                return null;
            return getGroup(xmlTerminal, nomGroup);
        }
        /// <summary>
        /// Fonction qui renvoi tous les groupes du type spécifié contenus dans le label spécifié.
        /// </summary>
        /// <param name="racine">La structure xml de l'aéroport</param>
        /// <param name="Terminal">Le nom du terminal désiré</param>
        /// <param name="Level">Le nom du level voulu</param>
        /// <param name="nomGroup">le type de groupe recherché.</param>
        /// <returns></returns>
        public static XmlNode[] getGroup(XmlNode racine, String Terminal, /*String Level,*/ String nomGroup)
        {
            if (racine == null)
                return null;
            if (racine.ChildNodes.Count == 0)
                return null;
            int iTerminal;
            String sTerminal = OverallTools.FonctionUtiles.Substring(Terminal);
            if ((!Int32.TryParse(sTerminal, out iTerminal)))
                return null;
            return getGroup(racine, iTerminal/*, iLevel*/, nomGroup);
        }
        /// <summary>
        /// Fonction qui renvoi tous les groupes du type spécifié contenus dans le label spécifié.
        /// </summary>
        /// <param name="racine">La structure xml de l'aéroport</param>
        /// <param name="Terminal">Le nom du terminal désiré</param>
        /// <param name="Level">Le nom du level voulu</param>
        /// <param name="nomGroup">le type de groupe recherché.</param>
        /// <returns></returns>
        public static XmlNode[] getGroupByDescription(XmlNode racine, String TerminalDescription, String nomGroup)
        {
            if (racine == null)
                return null;
            if (racine.ChildNodes.Count == 0)
                return null;
            XmlNode xmlTerminal = getTerminalByDescription(racine, TerminalDescription);
            if (xmlTerminal == null)
                return null;
            return getGroup(xmlTerminal, nomGroup);
        }
        public static XmlNode getGroupByDescription(XmlNode racine, String TerminalDescription, String nomGroup, String DeskStart)
        {
            XmlNode[] xmlGroupes = getGroupByDescription(racine, TerminalDescription, nomGroup);
            if (xmlGroupes == null)
                return null;
            for (int i = 0; i < xmlGroupes.Length; i++)
            {
                for (int j = 0; j < xmlGroupes[i].ChildNodes.Count; j++)
                {
                    String sDescription = extractDescription(xmlGroupes[i].ChildNodes[j].Attributes["Name"].Value.ToString());
                    if (sDescription.ToLower().Trim() == DeskStart.ToLower().Trim())
                    {
                        return xmlGroupes[i];
                    }
                }
            }
            return null;
        }

        /// <summary>
        /// Fonction qui renvoie le groupe auquel appartient le bureau sélectionné dans le level et le terminal désigné
        /// </summary>
        /// <param name="racine">La structure XML de l'aéroport</param>
        /// <param name="Terminal">Le Terminal analysé</param>
        /// <param name="Level">Le level analysé</param>
        /// <param name="nomGroup">Le type de groupe auquel appartient le bureau</param>
        /// <param name="DeskStart">Le bureau recherché.</param>
        /// <returns></returns>
        public static XmlNode getGroup(XmlNode racine, String Terminal, /*String Level,*/ String nomGroup, String DeskStart)
        {
            int iTerminal, iDeskStart;
            String sTerminal = OverallTools.FonctionUtiles.Substring(Terminal);
            if ((!Int32.TryParse(sTerminal, out iTerminal)) ||
                (!Int32.TryParse(DeskStart, out iDeskStart)))
                return null;
            return getGroup(racine, iTerminal, nomGroup, iDeskStart);
        }
        /// <summary>
        /// Fonction qui renvoie le groupe auquel appartient le bureau sélectionné dans le level et le terminal désigné
        /// </summary>
        /// <param name="iTerminal">Le Terminal analysé</param>
        /// <param name="iLevel">Le level analysé</param>
        /// <param name="nomGroup">Le type de groupe auquel appartient le bureau</param>
        /// <param name="iDeskStart">Le bureau recherché.</param>
        /// <returns></returns>
        public static XmlNode getGroup(XmlNode racine, int iTerminal, /*int iLevel,*/ String nomGroup, int iDeskStart)
        {
            XmlNode[] xmlGroupes = getGroup(racine, iTerminal, /*iLevel,*/ nomGroup);
            if (xmlGroupes == null)
                return null;
            for (int i = 0; i < xmlGroupes.Length; i++)
            {
                for (int j = 0; j < xmlGroupes[i].ChildNodes.Count; j++)
                {
                    if (FonctionsType.getInt(xmlGroupes[i].ChildNodes[j].Attributes["Index"].Value) == iDeskStart)
                    {
                        return xmlGroupes[i];
                    }
                }
            }
            return null;
        }

        public static String getStationGroup(XmlNode racine, String sStationName)
        {
            if (sStationName == null)
                return null;
            if (racine == null)
                return null;
            int[] iTmp = OverallTools.DataFunctions.AnalyzeGroupName(sStationName);
            if ((iTmp == null) || (iTmp.Length != 4))
                return null;
            XmlNode xnTmp = getGroup(racine, iTmp[0], OverallTools.DataFunctions.AnalyzeName(iTmp[2] - LastGroupIndex), iTmp[3]);
            if (xnTmp == null)
                return null;
            String sResult = sStationName.Substring(0, sStationName.IndexOf('_') + 1);
            sResult += OverallTools.DataFunctions.AnalyzeName(OverallTools.DataFunctions.GetGroupId(iTmp[2])/*- GestionDonneesHUB2SIM.BoardingGateGroup*/);
            sResult += " " + xnTmp.Attributes["Index"].Value.ToString();
            return sResult;
        }

        internal String getGroup(String sStationName)
        {
            return getStationGroup(structureAeroport, sStationName);
        }
        #endregion

        #region Pour avoir l'index du premier bureau d'un group
        public static int getIndexFirstDesk(XmlNode racine, int Terminal, /*int Level,*/ int Group, int indexGroup)
        {
            return getIndexFirstDesk(racine, Terminal.ToString() + " ( Terminal )", /*Level.ToString() + " ( Level )",*/ PAX2SIM.ListeNomObjet[1 + Group] + " Group", indexGroup.ToString());
        }
        public int getIndexFirstDesk(int Terminal, /*int Level,*/ int Group, int indexGroup)
        {
            return getIndexFirstDesk(structureAeroport, Terminal, /*Level,*/ Group, indexGroup);
        }
        public static int getIndexFirstDesk(XmlNode racine, String Terminal, /*String Level,*/ String Group, String indexGroup)
        {
            if (racine == null)
                return -1;
            if (racine.ChildNodes.Count == 0)
                return -1;
            XmlNode[] xmlGroupes = getGroup(racine, Terminal, /*Level,*/ Group);
            if (xmlGroupes == null)
                return -1;
            foreach (XmlNode xmlGroup in xmlGroupes)
            {
                if (xmlGroup.Attributes["Index"].Value.ToString() == indexGroup)
                {
                    if (xmlGroup.FirstChild != null)
                    {
                        return FonctionsType.getInt(xmlGroup.FirstChild.Attributes["Index"].Value.ToString());
                    }
                    break;
                }
            }
            return -1;

        }
        public int getIndexFirstDesk(String Terminal, /*String Level,*/ String Group, String indexGroup)
        {
            return getIndexFirstDesk(structureAeroport, Terminal, /*Level,*/ Group, indexGroup);
        }

        #endregion

        #region Pour avoir l'index du dernier bureau d'un group
        public static int getIndexLastDesk(XmlNode racine, int Terminal, /*int Level,*/ int Group, int indexGroup)
        {
            return getIndexLastDesk(racine, Terminal.ToString() + " ( Terminal )", PAX2SIM.ListeNomObjet[1 + Group] + " Group", indexGroup.ToString());
        }
        public int getIndexLastDesk(int Terminal, /*int Level,*/ int Group, int indexGroup)
        {
            return getIndexLastDesk(structureAeroport, Terminal, /*Level,*/ Group, indexGroup);
        }
        public static int getIndexLastDesk(XmlNode racine, String Terminal, /*String Level,*/ String Group, String indexGroup)
        {
            if (racine == null)
                return -1;
            if (racine.ChildNodes.Count == 0)
                return -1;
            XmlNode[] xmlGroupes = getGroup(racine, Terminal, /*Level,*/ Group);
            if (xmlGroupes == null)
                return -1;
            foreach (XmlNode xmlGroup in xmlGroupes)
            {
                if (xmlGroup.Attributes["Index"].Value.ToString() == indexGroup)
                {
                    if (xmlGroup.FirstChild != null)
                    {
                        return FonctionsType.getInt(xmlGroup.LastChild.Attributes["Index"].Value.ToString());
                    }
                    break;
                }
            }
            return -1;

        }
        #endregion

        #region Pour les bureaux

        private String[] getDesks(String Terminal, /*String Level,*/ String group)
        {
            return getDesks(structureAeroport, Terminal, /*Level,*/ group);
        }
        private String[] getDesksByDescription(String Terminal, String groupType)
        {
            return getDesksByDescription(structureAeroport, Terminal, groupType);
        }
        private static String[] getDesks(XmlNode racine, String Terminal, /*String Level,*/ String group)
        {
            if (racine == null)
                return null;
            if (racine.ChildNodes.Count == 0)
                return null;
            XmlNode[] xmlGroupes = getGroup(racine, Terminal, /*Level,*/ group);
            if (xmlGroupes == null)
                return null;
            int iNombreCheckIn = 0;
            for (int i = 0; i < xmlGroupes.Length; i++)
            {
                iNombreCheckIn += xmlGroupes[i].ChildNodes.Count;
            }
            if (iNombreCheckIn == 0)
                return null;
            String[] resultats = new String[iNombreCheckIn];
            iNombreCheckIn = 0;
            for (int i = 0; i < xmlGroupes.Length; i++)
            {
                for (int j = 0; j < xmlGroupes[i].ChildNodes.Count; j++)
                {
                    resultats[iNombreCheckIn] = ConvertName(xmlGroupes[i].ChildNodes[j].Attributes["Index"].Value, xmlGroupes[i].ChildNodes[j].Attributes["Name"].Value, false);
                    //resultats[iNombreCheckIn] = xmlGroupes[i].ChildNodes[j].Attributes["Index"].Value + " ( " + xmlGroupes[i].ChildNodes[j].Attributes["Name"].Value + " )";
                    iNombreCheckIn++;
                }
            }
            return resultats;
        }
        private static String[] getDesksByDescription(XmlNode racine, String TerminalDescription, String groupType)
        {
            if (racine == null)
                return null;
            if (racine.ChildNodes.Count == 0)
                return null;
            XmlNode[] xmlGroupes = getGroupByDescription(racine, TerminalDescription, groupType);
            if (xmlGroupes == null)
                return null;
            int iDeskNumber = 0;
            for (int i = 0; i < xmlGroupes.Length; i++)
            {
                iDeskNumber += xmlGroupes[i].ChildNodes.Count;
            }
            if (iDeskNumber == 0)
                return null;
            String[] resultats = new String[iDeskNumber];
            iDeskNumber = 0;
            for (int i = 0; i < xmlGroupes.Length; i++)
            {
                for (int j = 0; j < xmlGroupes[i].ChildNodes.Count; j++)
                {
                    resultats[iDeskNumber] = ConvertName(xmlGroupes[i].ChildNodes[j].Attributes["Index"].Value, xmlGroupes[i].ChildNodes[j].Attributes["Name"].Value, true);

                    //                    resultats[iDeskNumber] = xmlGroupes[i].ChildNodes[j].Attributes["Name"].Value + " ( " + xmlGroupes[i].ChildNodes[j].Attributes["Index"].Value + " )";
                    iDeskNumber++;
                }
            }
            return resultats;
        }
        private String[] getDesksByDescription(String TerminalDescription, String groupType, String DeskStart)
        {
            return getDesksByDescription(structureAeroport, TerminalDescription, groupType, DeskStart);
        }
        private static String[] getDesksByDescription(XmlNode racine, String TerminalDescription, String groupType, String DeskStart)
        {
            if (racine == null)
                return null;
            if (racine.ChildNodes.Count == 0)
                return null;
            XmlNode xmlGroupe = getGroupByDescription(racine, TerminalDescription, /*Level,*/ groupType, DeskStart);
            if (xmlGroupe == null)
                return null;
            int iDeskNumber = xmlGroupe.ChildNodes.Count;

            if (iDeskNumber == 0)
                return null;
            String[] resultats = new String[iDeskNumber];
            iDeskNumber = 0;
            for (int j = 0; j < xmlGroupe.ChildNodes.Count; j++)
            {
                resultats[iDeskNumber] = ConvertName(xmlGroupe.ChildNodes[j].Attributes["Index"].Value, xmlGroupe.ChildNodes[j].Attributes["Name"].Value, true);
                //resultats[iDeskNumber] = xmlGroupe.ChildNodes[j].Attributes["Name"].Value + " ( " + xmlGroupe.ChildNodes[j].Attributes["Index"].Value + " )";
                iDeskNumber++;
            }
            return resultats;
        }
        private String[] getDesks(String Terminal, /*String Level,*/ String group, String DeskStart)
        {
            return getDesks(structureAeroport, Terminal, /*Level,*/ group, DeskStart);
        }
        private static String[] getDesks(XmlNode racine, String Terminal, /*String Level,*/ String group, String DeskStart)
        {
            if (racine == null)
                return null;
            if (racine.ChildNodes.Count == 0)
                return null;
            XmlNode xmlGroupe = getGroup(racine, Terminal, /*Level,*/ group, DeskStart);
            if (xmlGroupe == null)
                return null;
            int iNombreCheckIn = xmlGroupe.ChildNodes.Count;

            if (iNombreCheckIn == 0)
                return null;
            String[] resultats = new String[iNombreCheckIn];
            iNombreCheckIn = 0;
            for (int j = 0; j < xmlGroupe.ChildNodes.Count; j++)
            {
                resultats[iNombreCheckIn] = ConvertName(xmlGroupe.ChildNodes[j].Attributes["Index"].Value, xmlGroupe.ChildNodes[j].Attributes["Name"].Value, false);
                //resultats[iNombreCheckIn] = xmlGroupe.ChildNodes[j].Attributes["Index"].Value + " ( " + xmlGroupe.ChildNodes[j].Attributes["Name"].Value + " )";
                iNombreCheckIn++;
            }
            return resultats;
        }

        internal String[] getCheckIn(String Terminal/*, String Level*/)
        {
            if (bUseAlphNumericForFlightInfo)
            {
                return getDesksByDescription(ConvertName(Terminal, bUseAlphNumericForFlightInfo), /*Level,*/ PAX2SIM.sCheckInGroup);
            }
            return getDesks(ConvertName(Terminal, bUseAlphNumericForFlightInfo), /*Level,*/ PAX2SIM.sCheckInGroup);
        }
        internal String[] getCheckIn(String Terminal/*, String Level*/, String CheckInStart)
        {

            if (bUseAlphNumericForFlightInfo)
            {
                return getDesksByDescription(ConvertName(Terminal, bUseAlphNumericForFlightInfo),
                    PAX2SIM.sCheckInGroup,
                    ConvertName(CheckInStart, bUseAlphNumericForFlightInfo));
            }
            return getDesks(ConvertName(Terminal, bUseAlphNumericForFlightInfo),
                PAX2SIM.sCheckInGroup,
                ConvertName(CheckInStart, bUseAlphNumericForFlightInfo));
        }
        internal String[] getArrivalGate(String Terminal)
        {
            if (bUseAlphNumericForFlightInfo)
            {
                return getDesksByDescription(ConvertName(Terminal, bUseAlphNumericForFlightInfo), "Arrival Gate Group");
            }
            return getDesks(ConvertName(Terminal, bUseAlphNumericForFlightInfo), "Arrival Gate Group");
        }
        internal String[] getBoardingGate(String Terminal)
        {
            if (bUseAlphNumericForFlightInfo)
            {
                return getDesksByDescription(ConvertName(Terminal, bUseAlphNumericForFlightInfo), "Boarding Gate Group");
            }
            return getDesks(ConvertName(Terminal, bUseAlphNumericForFlightInfo), "Boarding Gate Group");
        }
        internal String[] getBaggageClaimBelt(String Terminal)
        {
            if (bUseAlphNumericForFlightInfo)
            {
                return getDesksByDescription(ConvertName(Terminal, bUseAlphNumericForFlightInfo), "Baggage Claim Group");
            }
            return getDesks(ConvertName(Terminal, bUseAlphNumericForFlightInfo), "Baggage Claim Group");
        }

        // >> Task #15781 Various TreeView assistans improvements C#1_1
        internal String[] getPassportCheckDesks(String Terminal)
        {
            if (bUseAlphNumericForFlightInfo)
            {
                return getDesksByDescription(ConvertName(Terminal, bUseAlphNumericForFlightInfo), "Passport Check Group");
            }
            return getDesks(ConvertName(Terminal, bUseAlphNumericForFlightInfo), "Passport Check Group");
        }
        internal String[] getSecurityCheckDesks(String Terminal)
        {
            if (bUseAlphNumericForFlightInfo)
            {
                return getDesksByDescription(ConvertName(Terminal, bUseAlphNumericForFlightInfo), "Security Check Group");
            }
            return getDesks(ConvertName(Terminal, bUseAlphNumericForFlightInfo), "Security Check Group");
        }
        internal String[] getTransferDesks(String Terminal)
        {
            if (bUseAlphNumericForFlightInfo)
            {
                return getDesksByDescription(ConvertName(Terminal, bUseAlphNumericForFlightInfo), "Transfer Group");
            }
            return getDesks(ConvertName(Terminal, bUseAlphNumericForFlightInfo), "Transfer Group");
        }
        internal String[] getUserProcessDesks(String Terminal)
        {
            if (bUseAlphNumericForFlightInfo)
            {
                return getDesksByDescription(ConvertName(Terminal, bUseAlphNumericForFlightInfo), PAX2SIM.sUserProcessGroup);
            }
            return getDesks(ConvertName(Terminal, bUseAlphNumericForFlightInfo), PAX2SIM.sUserProcessGroup);
        }
        // << Task #15781 Various TreeView assistans improvements C#1_1

        // >> Task #13659 IST MakeUp segregation
        internal static bool tryGetResourceIndex(XmlNode station, out int index)
        {
            index = -1;
            if (station == null || station.Attributes == null)
                return false;
            if (station.Attributes[AIRPORT_XML_NODE_INDEX_ATTRIBUTE_NAME] == null)
                return false;
            return Int32.TryParse(station.Attributes[AIRPORT_XML_NODE_INDEX_ATTRIBUTE_NAME]
                                    .Value.ToString(), out index);
        }
        internal static bool tryGetResourceDescription(XmlNode station, out string description)
        {
            description = "";
            if (station == null || station.Attributes == null)
                return false;
            if (station.Attributes[AIRPORT_XML_NODE_DESCRIPTION_ATTRIBUTE_NAME] == null)
                return false;
            description = extractDescription(station.Attributes[AIRPORT_XML_NODE_DESCRIPTION_ATTRIBUTE_NAME].Value);
            return true;
        }
        // << Task #13659 IST MakeUp segregation
        #endregion

        private static String ConvertName(String sIndex, String sDescription, bool bUseAlpha)
        {
            if (!bUseAlpha)
                return sIndex + " ( " + sDescription + " )";
            String sShortDescription = sDescription;
            if (sDescription.IndexOf(":") != -1)
                sShortDescription = sDescription.Substring(0, sDescription.IndexOf(":"));
            return sShortDescription + " ( " + sIndex + " : " + sDescription + " )";
        }

        internal static String extractDescription(String sCompleteDescription)
        {
            String sDescription = sCompleteDescription;
            if (sCompleteDescription.IndexOf(":") != -1)
                sDescription = sCompleteDescription.Substring(0, sCompleteDescription.IndexOf(":"));
            return sDescription;
        }
        internal static String ConvertName(String sName, bool bUseAlpha)
        {
            int iIndex;
            int iIndexPoints = -1;
            if (bUseAlpha)
            {
                iIndexPoints = sName.IndexOf(":");
                if (iIndexPoints != -1)
                {
                    String sTmp = sName.Substring(0, iIndexPoints);
                    iIndex = sTmp.LastIndexOf("(");
                }
                else
                    iIndex = sName.LastIndexOf("(");
            }
            else
            {
                iIndex = sName.IndexOf("(");
            }
            if (iIndex > 0)
            {
                return sName.Substring(0, iIndex);
            }
            return sName;
        }
        //internal static Int32 ConvertName(XmlNode xnStructure, String sDescription
        
        internal static DataTable ConvertFPDInformations(DataTable dtFPD, XmlNode racine, bool bUseAlpha, bool bEraseOldTable)
        {
            if (dtFPD == null)
                return null;
            if (racine == null)
                return null;
            DataTable dtResult = null;
            if (!bEraseOldTable)
            {
                dtResult = dtFPD.Copy();
                ConvertFPDInformations(dtResult, racine, bUseAlpha);
            }
            else
            {
                ConvertFPDInformations(dtFPD, racine, bUseAlpha);
            }
            return dtResult;
        }
        internal static bool ConvertFPDInformations(DataTable dtFPD, XmlNode racine, bool bUseAlpha)
        {
            if (dtFPD == null)
                return false;
            if (racine == null)
                return false;
            int iIndexTerminalCheckIn = -1;
            int iIndexTerminalGate = -1;
            int iIndexTerminalMup = -1;
            int iIndexTerminalParking = -1;
            int iIndexTerminalRunway = -1;
            int iParking = -1;

            List<Int32> lsCheckIn = new List<Int32>();
            List<Int32> lsBoardingGate = new List<Int32>();
            List<Int32> lsMup = new List<Int32>();

            #region Initialisation des colonnes à recherché et à remplacé
            if (dtFPD.Columns.Contains(GlobalNames.sFPD_A_Column_TerminalGate))
            {
                iIndexTerminalGate = dtFPD.Columns.IndexOf(GlobalNames.sFPD_A_Column_TerminalGate);
                if (dtFPD.Columns.Contains(GlobalNames.sFPD_Column_BoardingGate))
                    lsBoardingGate.Add(dtFPD.Columns.IndexOf(GlobalNames.sFPD_Column_BoardingGate));
            }
            if (dtFPD.Columns.Contains(GlobalNames.sFPD_Column_TerminalCI))
            {
                iIndexTerminalCheckIn = dtFPD.Columns.IndexOf(GlobalNames.sFPD_Column_TerminalCI);
                if (dtFPD.Columns.Contains(GlobalNames.sFPD_Column_Eco_CI_End))
                    lsCheckIn.Add(dtFPD.Columns.IndexOf(GlobalNames.sFPD_Column_Eco_CI_End));
                if (dtFPD.Columns.Contains(GlobalNames.sFPD_Column_Eco_CI_Start))
                    lsCheckIn.Add(dtFPD.Columns.IndexOf(GlobalNames.sFPD_Column_Eco_CI_Start));
                if (dtFPD.Columns.Contains(GlobalNames.sFPD_Column_FB_CI_End))
                    lsCheckIn.Add(dtFPD.Columns.IndexOf(GlobalNames.sFPD_Column_FB_CI_End));
                if (dtFPD.Columns.Contains(GlobalNames.sFPD_Column_FB_CI_Start))
                    lsCheckIn.Add(dtFPD.Columns.IndexOf(GlobalNames.sFPD_Column_FB_CI_Start));

                if (dtFPD.Columns.Contains(GlobalNames.sFPD_Column_Eco_Drop_End))
                    lsCheckIn.Add(dtFPD.Columns.IndexOf(GlobalNames.sFPD_Column_Eco_Drop_End));
                if (dtFPD.Columns.Contains(GlobalNames.sFPD_Column_Eco_Drop_Start))
                    lsCheckIn.Add(dtFPD.Columns.IndexOf(GlobalNames.sFPD_Column_Eco_Drop_Start));
                if (dtFPD.Columns.Contains(GlobalNames.sFPD_Column_FB_Drop_End))
                    lsCheckIn.Add(dtFPD.Columns.IndexOf(GlobalNames.sFPD_Column_FB_Drop_End));
                if (dtFPD.Columns.Contains(GlobalNames.sFPD_Column_FB_Drop_Start))
                    lsCheckIn.Add(dtFPD.Columns.IndexOf(GlobalNames.sFPD_Column_FB_Drop_Start));
            }

            if (dtFPD.Columns.Contains(GlobalNames.sFPD_Column_TerminalMup))
            {
                iIndexTerminalMup = dtFPD.Columns.IndexOf(GlobalNames.sFPD_Column_TerminalMup);
                if (dtFPD.Columns.Contains(GlobalNames.sFPD_Column_Eco_Mup_End))
                    lsMup.Add(dtFPD.Columns.IndexOf(GlobalNames.sFPD_Column_Eco_Mup_End));
                if (dtFPD.Columns.Contains(GlobalNames.sFPD_Column_Eco_Mup_Start))
                    lsMup.Add(dtFPD.Columns.IndexOf(GlobalNames.sFPD_Column_Eco_Mup_Start));
                if (dtFPD.Columns.Contains(GlobalNames.sFPD_Column_First_Mup_Start))
                    lsMup.Add(dtFPD.Columns.IndexOf(GlobalNames.sFPD_Column_First_Mup_Start));
                if (dtFPD.Columns.Contains(GlobalNames.sFPD_Column_First_Mup_End))
                    lsMup.Add(dtFPD.Columns.IndexOf(GlobalNames.sFPD_Column_First_Mup_End));
            }

            if (dtFPD.Columns.Contains(GlobalNames.sFPD_A_Column_TerminalParking))
            {
                iIndexTerminalParking = dtFPD.Columns.IndexOf(GlobalNames.sFPD_A_Column_TerminalParking);
                if (dtFPD.Columns.Contains(GlobalNames.sFPD_A_Column_Parking))
                    iParking = dtFPD.Columns.IndexOf(GlobalNames.sFPD_A_Column_Parking);
            }
            if (dtFPD.Columns.Contains(GlobalNames.sFPD_A_Column_RunWay))
            {
                iIndexTerminalRunway = dtFPD.Columns.IndexOf(GlobalNames.sFPD_A_Column_RunWay);
            }
            #endregion

            foreach (DataRow drRow in dtFPD.Rows)
            {
                if (iIndexTerminalCheckIn != -1)
                    ConvertComponents(drRow, iIndexTerminalCheckIn, lsCheckIn, PAX2SIM.sCheckInGroup, racine, bUseAlpha);

                if (iIndexTerminalGate != -1)
                    ConvertComponents(drRow, iIndexTerminalGate, lsBoardingGate, "Boarding Gate Group", racine, bUseAlpha);
                if (iIndexTerminalMup != -1)
                    ConvertComponents(drRow, iIndexTerminalMup, lsMup, PAX2SIM.sMakeUpGroup, racine, bUseAlpha);
                if (iIndexTerminalParking != -1)
                    ConvertComponentsParking(drRow, iParking, iIndexTerminalParking, racine, bUseAlpha);
                if (iIndexTerminalRunway != -1)
                    ConvertComponentsRunways(drRow, iIndexTerminalRunway, racine, "Runways", bUseAlpha);
            }

            return true;
        }
        internal static DataTable ConvertFPAInformations(DataTable dtFPA, XmlNode racine, bool bUseAlpha, bool bEraseOldTable)
        {
            if (dtFPA == null)
                return null;
            if (racine == null)
                return null;
            DataTable dtResult = null;
            if (!bEraseOldTable)
            {
                dtResult = dtFPA.Copy();
                ConvertFPAInformations(dtResult, racine, bUseAlpha);
            }
            else
            {
                ConvertFPAInformations(dtFPA, racine, bUseAlpha);
            }
            return dtResult;
        }
        internal static bool ConvertFPAInformations(DataTable dtFPA, XmlNode racine, bool bUseAlpha)
        {
            if (dtFPA == null)
                return false;
            if (racine == null)
                return false;
            int iIndexTerminalReclaim = -1;
            int iIndexTerminalGate = -1;
            int iIndexTerminalInfeed = -1;
            int iIndexTerminalParking = -1;
            int iIndexTerminalRunway = -1;
            int iParking = -1;

            List<Int32> lsReclaim = new List<Int32>();
            List<Int32> lsArrivalGate = new List<Int32>();
            List<Int32> lsTransferInfeed = new List<Int32>();
            List<Int32> lsArrivalInfeed = new List<Int32>();

            #region Initialisation des colonnes à recherché et à remplacé
            if (dtFPA.Columns.Contains(GlobalNames.sFPD_A_Column_TerminalGate))
            {
                iIndexTerminalGate = dtFPA.Columns.IndexOf(GlobalNames.sFPD_A_Column_TerminalGate);
                if (dtFPA.Columns.Contains(GlobalNames.sFPA_Column_ArrivalGate))
                    lsArrivalGate.Add(dtFPA.Columns.IndexOf(GlobalNames.sFPA_Column_ArrivalGate));
            }
            if (dtFPA.Columns.Contains(GlobalNames.sFPA_Column_TerminalReclaim))
            {
                iIndexTerminalReclaim = dtFPA.Columns.IndexOf(GlobalNames.sFPA_Column_TerminalReclaim);
                if (dtFPA.Columns.Contains(GlobalNames.sFPA_Column_ReclaimObject))
                    lsReclaim.Add(dtFPA.Columns.IndexOf(GlobalNames.sFPA_Column_ReclaimObject));
            }

            if (dtFPA.Columns.Contains(GlobalNames.sFPA_Column_TerminalInfeedObject))
            {
                iIndexTerminalInfeed = dtFPA.Columns.IndexOf(GlobalNames.sFPA_Column_TerminalInfeedObject);
                if (dtFPA.Columns.Contains(GlobalNames.sFPA_Column_TransferInfeedObject))
                    lsTransferInfeed.Add(dtFPA.Columns.IndexOf(GlobalNames.sFPA_Column_TransferInfeedObject));
                if (dtFPA.Columns.Contains(GlobalNames.sFPA_Column_StartArrivalInfeedObject))
                    lsArrivalInfeed.Add(dtFPA.Columns.IndexOf(GlobalNames.sFPA_Column_StartArrivalInfeedObject));
                if (dtFPA.Columns.Contains(GlobalNames.sFPA_Column_EndArrivalInfeedObject))
                    lsArrivalInfeed.Add(dtFPA.Columns.IndexOf(GlobalNames.sFPA_Column_StartArrivalInfeedObject));
            }

            if (dtFPA.Columns.Contains(GlobalNames.sFPD_A_Column_TerminalParking))
            {
                iIndexTerminalParking = dtFPA.Columns.IndexOf(GlobalNames.sFPD_A_Column_TerminalParking);
                if (dtFPA.Columns.Contains(GlobalNames.sFPD_A_Column_Parking))
                    iParking = dtFPA.Columns.IndexOf(GlobalNames.sFPD_A_Column_Parking);
            }
            if (dtFPA.Columns.Contains(GlobalNames.sFPD_A_Column_RunWay))
            {
                iIndexTerminalRunway = dtFPA.Columns.IndexOf(GlobalNames.sFPD_A_Column_RunWay);
            }
            #endregion

            foreach (DataRow drRow in dtFPA.Rows)
            {
                if (iIndexTerminalGate != -1)
                    ConvertComponents(drRow, iIndexTerminalGate, lsArrivalGate, "Arrival Gate Group", racine, bUseAlpha);
                if (iIndexTerminalReclaim != -1)
                    ConvertComponents(drRow, iIndexTerminalReclaim, lsReclaim, "Baggage Claim Group", racine, bUseAlpha);

                if (iIndexTerminalInfeed != -1)
                    ConvertComponents(drRow, iIndexTerminalInfeed, lsTransferInfeed, BHS_String_TransferInfeedGroup, racine, bUseAlpha);
                if (iIndexTerminalInfeed != -1)
                    ConvertComponents(drRow, iIndexTerminalInfeed, lsArrivalInfeed, BHS_String_ArrivalInfeedGroup, racine, bUseAlpha);
                if (iIndexTerminalParking != -1)
                    ConvertComponentsParking(drRow, iParking, iIndexTerminalParking, racine, bUseAlpha);
                if (iIndexTerminalRunway != -1)
                    ConvertComponentsRunways(drRow, iIndexTerminalRunway, racine, "Runways", bUseAlpha);
            }
            return true;
        }

        private static void ConvertComponents(DataRow drRow, int iIndexTerminalColumn, List<Int32> liElements, String sTypeElement, XmlNode racine, bool bUseAlpha)
        {
            if (racine == null)
                return;
            String sTerminalContent = drRow[iIndexTerminalColumn].ToString();

            XmlNode xnTerminal = null;
            Int32 iIndexTerminal = -1;
            if (bUseAlpha)
            {
                //The content of the FPD should be numbers.
                if (!Int32.TryParse(sTerminalContent, out iIndexTerminal))
                    return;
                xnTerminal = getTerminal(racine, iIndexTerminal);
            }
            else
            {
                //The content of the FPD is AlphaNumerical caracters (Description of the Terminal objects)
                xnTerminal = getTerminalByDescription(racine, sTerminalContent);
            }
            if (xnTerminal == null)
                return;
            //drRow[iIndexTerminalColumn] = ConvertName(xnTerminal.Attributes["Index"].Value, xnTerminal.Attributes["Name"].Value, bUseAlpha);

            if (bUseAlpha)
            {
                drRow[iIndexTerminalColumn] = extractDescription(xnTerminal.Attributes["Name"].Value);
                foreach (Int32 iValue in liElements)
                {
                    ConvertComponents(drRow, iValue, racine, iIndexTerminal, sTypeElement);
                }
            }
            else
            {
                drRow[iIndexTerminalColumn] = xnTerminal.Attributes["Index"].Value;
                foreach (Int32 iValue in liElements)
                {
                    ConvertComponents(drRow, iValue, racine, sTerminalContent, sTypeElement);
                }
            }
        }
        private static void ConvertComponents(DataRow drRow, int iIndexElement, XmlNode racine, int iIndexTerminal, String sTypeElement)
        {
            String sObjectContent = drRow[iIndexElement].ToString();
            XmlNode xnGroup = null;
            //The content of the FPD should be numbers.
            Int32 iIndexObject;
            if (!Int32.TryParse(sObjectContent, out iIndexObject))
                return;
            xnGroup = getGroup(racine, iIndexTerminal, sTypeElement, iIndexObject);
            if (xnGroup == null)
                return;

            for (int j = 0; j < xnGroup.ChildNodes.Count; j++)
            {
                if (xnGroup.ChildNodes[j].Attributes["Index"].Value.ToString() == iIndexObject.ToString())
                {
                    drRow[iIndexElement] = extractDescription(xnGroup.ChildNodes[j].Attributes["Name"].Value);
                    //drRow[elementValue] = ConvertName(xnGroup.ChildNodes[j].Attributes["Index"].Value, xnGroup.ChildNodes[j].Attributes["Name"].Value, true);
                    return;
                }
            }
        }
        private static void ConvertComponents(DataRow drRow, int iIndexElement, XmlNode racine, String sTerminal, String sTypeElement)
        {
            String sObjectContent = drRow[iIndexElement].ToString();
            XmlNode xnGroup = null;
            //The content of the FPD should be numbers.

            //xnGroup = getMakeUp(racine, sTerminal, true);
            xnGroup = getGroupByDescription(racine, sTerminal, sTypeElement, sObjectContent);
            if (xnGroup == null)
                return;

            for (int j = 0; j < xnGroup.ChildNodes.Count; j++)
            {
                String sDescription = extractDescription(xnGroup.ChildNodes[j].Attributes["Name"].Value.ToString());
                /*if (sDescription.IndexOf(":") != -1)
                    sDescription = sDescription.Substring(0, sDescription.IndexOf(":"));*/
                if (sDescription.ToLower().Trim() == sObjectContent.ToLower().Trim())
                {
                    drRow[iIndexElement] = xnGroup.ChildNodes[j].Attributes["Index"].Value.ToString();
                    //drRow[elementValue] = ConvertName(xnGroup.ChildNodes[j].Attributes["Index"].Value, xnGroup.ChildNodes[j].Attributes["Name"].Value, false);
                    return;
                }
            }
        }
        private static void ConvertComponentsParking(DataRow drRow, int iIndexElement, int iIndexTerminal, XmlNode racine, bool bUseAlpha)
        {
            String sObjectContent = drRow[iIndexElement].ToString().Trim().ToLower();
            String sTerminalContent = drRow[iIndexTerminal].ToString().Trim().ToLower();
            if ((sObjectContent == "") || (sObjectContent == null) || (sTerminalContent == "") || (sTerminalContent == null))
                return;
            XmlNode xnTerminal = null;
            if (bUseAlpha)
            {
                int iTerminal;
                if (!Int32.TryParse(sTerminalContent, out iTerminal))
                    return;
                xnTerminal = getTerminal(racine, iTerminal);
            }
            else
            {
                xnTerminal = getTerminalByDescription(racine, sTerminalContent);
            }
            if (xnTerminal == null)
                return;
            XmlNode xnParkings = null;
            foreach (XmlNode xnNode in xnTerminal.ChildNodes)
            {
                if (xnNode.Attributes["Type"].Value == "Aircraft Parking Stands")
                {
                    xnParkings = xnNode;
                    break;
                }
            }
            if (bUseAlpha)
            {
                drRow[iIndexTerminal] = extractDescription(xnTerminal.Attributes["Name"].Value);
            }
            else
            {
                drRow[iIndexTerminal] = xnTerminal.Attributes["Index"].Value;
            }
            if (xnParkings == null)
                return;

            for (int j = 0; j < xnParkings.ChildNodes.Count; j++)
            {
                String sDescription = extractDescription(xnParkings.ChildNodes[j].Attributes["Name"].Value.ToString());
                if (!bUseAlpha && (sObjectContent == sDescription.ToLower().Trim()))
                {
                    drRow[iIndexElement] = xnParkings.ChildNodes[j].Attributes["Index"].Value.ToString();
                    //drRow[elementValue] = ConvertName(xnGroup.ChildNodes[j].Attributes["Index"].Value, xnGroup.ChildNodes[j].Attributes["Name"].Value, false);
                    return;
                }
                else if ((bUseAlpha) && (sObjectContent == xnParkings.ChildNodes[j].Attributes["Index"].Value))
                {
                    drRow[iIndexElement] = sDescription;
                    return;
                }
            }
        }
        private static void ConvertComponentsRunways(DataRow drRow, int iIndexElement, XmlNode racine, String sTypeElement, bool bUseAlpha)
        {
            String sObjectContent = drRow[iIndexElement].ToString().Trim().ToLower();

            //The content of the FPD should be numbers.

            //xnGroup = getMakeUp(racine, sTerminal, true);
            XmlNode xnGroup = getRunways(racine);
            if (xnGroup == null)
                return;

            for (int j = 0; j < xnGroup.ChildNodes.Count; j++)
            {
                String sDescription = extractDescription(xnGroup.ChildNodes[j].Attributes["Name"].Value.ToString());
                if (!bUseAlpha && (sObjectContent == sDescription.ToLower().Trim()))
                {
                    drRow[iIndexElement] = xnGroup.ChildNodes[j].Attributes["Index"].Value.ToString();
                    //drRow[elementValue] = ConvertName(xnGroup.ChildNodes[j].Attributes["Index"].Value, xnGroup.ChildNodes[j].Attributes["Name"].Value, false);
                    return;
                }
                else if ((bUseAlpha) && (sObjectContent == xnGroup.ChildNodes[j].Attributes["Index"].Value))
                {
                    drRow[iIndexElement] = sDescription;
                    return;
                }
            }
        }

        #endregion

        #region Pour les différents Scénarios   ==> Commentaires faits

        
        internal List<String> getScenarioPAXBHS()
        {
            return GetScenario( typeof(DataManagerPaxBHS));
        }

        internal List<String> getScenarioParking()
        {
            return GetScenario( typeof(DataManagerParking));
        }
        internal List<String> getScenarioAllocation()
        {
            return GetScenario( typeof(DataManagerAllocation));
        }

        private List<String> GetScenario(Type tType)
        {
            if (tType == null)
                return null;
            if (dmsScenarios == null)
                return null;
            List<String> lsReturn = new List<string>();
            foreach (DataManagerScenario dm in dmsScenarios.Values)
            {
                if (tType.IsInstanceOfType(dm))
                    lsReturn.Add(dm.Name);
            }
            if (lsReturn.Count == 0)
                return null;
            return lsReturn;
        }

        /// <summary>
        /// Fonction pour déterminer si un scénario donné est déjà présent dans le système de données.
        /// </summary>
        /// <param name="Name">Nom du scénario recherché</param>
        /// <returns>Booléen indiquant si le scénario est présent ou non dans le système de données.</returns>
        public bool ScenarioExist(String Name)
        {
            ///Si le nom est NULL alors on renvoie faux
            if (Name == null)
                return false;
            ///Si le scénario est présent on renvoie vrai, sinon on renvoie faux.
            return dmsScenarios.ContainsKey(Name);
        }
        /// <summary>
        /// Cett fonction sert à renvoyer le paramètrage pour le Scénario passé en paramètre. Si le scénario
        /// n'existe pas dans la collection, alors la fonction renvoie NULL.
        /// </summary>
        /// <param name="Name">Le scénario recherché.</param>
        /// <returns>NULL ou le paramétrage du scénario.</returns>
        public Classes.ParamScenario GetScenario(String Name)
        {
            ///Si le scénario n'existe pas, on renvoie NULL.
            if (!ScenarioExist(Name))
                return null;
            if (!typeof(DataManagerPaxBHS).IsInstanceOfType(dmsScenarios[Name]))
                return null;
            ///On renvoie le scénario demandé.
            return ((DataManagerPaxBHS)dmsScenarios[Name]).Scenario;
        }

        /// <summary>
        /// Fonction qui permet de remplacer la définition d'un scénario par une nouvelle définition de scénario.
        /// </summary>
        /// <param name="Name">Nom du scénario à remplacer.</param>
        /// <param name="parametres">Paramètres de la nouvelle définition du scénario.</param>
        /// <returns>Booléen indiquant si le remplacement s'est bien déroulé ou non.</returns>
        public bool ReplaceScenario(String Name, Classes.ParamScenario parametres)
        {
            ///Vérification des paramètres de la fonction. Si l'un des paramètres est NULL, alors on 
            ///renvoie FAUX.
            if ((Name == null) || (parametres == null))
                return false;
            ///Si le scénario est déjà présent, alors on supprime son paramétrage existant.
            ///Sinon on renvoie Faux, indiquant que le scénario n'a pu être mis à jour car inexistant.
            if ((ScenarioExist(Name))&&(typeof(DataManagerPaxBHS).IsInstanceOfType(dmsScenarios[Name])))
            {
                ((DataManagerPaxBHS)dmsScenarios[Name]).Scenario = parametres;
            }
            else
            {
                return false;
            }
            ///On signifie au projet qu'un élément a été modifié.
            hadBeenSaved = false;
            ///On renvoie Vrai, indiquant que la mise à jour s'est bien déroulée.
            return true;
        }

        /// <summary>
        /// Fonction qui permet d'ajouter un scénario au système de données.
        /// </summary>
        /// <param name="dmsScenario">Le scénario à ajouter.</param>
        /// <returns>Booléen indiquant si l'ajout s'est bien déroulé ou non.</returns>
        public bool AddScenario(DataManagement.DataManagerScenario dmsScenario)
        {
            ///Si le scénario est NULL alors Renvoyer Faux
            if (dmsScenario == null)
                return false;
            ///Si le scénario existe déjà en mémoire alors Renvoyer Faux.
            if (ScenarioExist(dmsScenario.Name))
                return false;

            ///On signifie au projet qu'un élément a été modifié.
            hadBeenSaved = false;

            ///Ajout dans la liste des scénarios de ce nouveau scénario \ref dmsScenarios
            dmsScenarios.Add(dmsScenario.Name, dmsScenario);
            if (typeof(DataManagerPaxBHS).IsInstanceOfType(dmsScenario))
                ((DataManagerPaxBHS)dmsScenario).AnalyseTracesFonctions = new DataManagerPaxBHS.AnalyseTracesDelegate(AnalyseTraces);
            return true;
        }

        /// <summary>
        /// Fonction qui permet d'ajouter dans le système de données un nouveau paramétrage pour un scénario.
        /// Cela va également initialiser le système de données qui servira à stocker l'ensemble des élements et tables
        /// de ce nouveau scénario.
        /// </summary>
        /// <param name="Name">Nom du nouveau scénario à ajouter.</param>
        /// <param name="parametres">Paramétrage du nouveau scénario à ajouter.</param>
        /// <returns></returns>
        public bool AddScenario(String Name, Classes.ParamScenario parametres)
        {
            ///Vérification des paramètres de la fonction. Si l'un des paramètres est NULL, alors on 
            ///renvoie FAUX (impossible d'ajouter un scénario avec des données manquantes).
            if ((Name == null) || (parametres == null))
                return false;

            ///Si un scénario est déjà présent avec le même nom, alors on renvoie Faux, indiquant que le scénario n'a pu être ajouter.
            if (ScenarioExist(Name))
                return false;
            ///On signifie au projet qu'un élément a été modifié.
            hadBeenSaved = false;
            ///On ajoute le paramétrage du nouveau scénario dans le système de données.
            DataManagerPaxBHS dmsScenario = new DataManagement.DataManagerPaxBHS(Name);
            dmsScenarios.Add(Name, dmsScenario);
            ReplaceScenario(Name, parametres);
            dmsScenario.AnalyseTracesFonctions = new DataManagerPaxBHS.AnalyseTracesDelegate(AnalyseTraces);
            dmsScenarios[Name].GetPath = new DataManager.GetPathDelegate(getNomDuChemin);

            return true;
        }

        /// <summary>
        /// Fonction qui permet de supprimer un scénario du système de données.
        /// </summary>
        /// <param name="Name">Nom du scénario que l'on souhaite supprimer.</param>
        /// <returns>Booléen indiquant si la suppression s'est bien déroulée.</returns>
        public bool RemoveScenario(String Name)
        {
            ///Si le scénario n'existe pas dans la liste, alors on renvoie Faux.
            if (!ScenarioExist(Name))
                return false;
            ///On rend la mémoire occupée par ce scénario
            DataManagement.DataManagerScenario Scenario= dmsScenarios[Name];
            dmsScenarios.Remove(Name);
            Scenario.Dispose();
            Scenario = null;
            ///On signifie au projet qu'un élément a été modifié.
            hadBeenSaved = false;
            ///On renvoie Vrai, indiquant que la suppression s'est bien déroulée.
            return true;
        }

        /// <summary>
        /// Fonction qui permet de récupérer les liste triée des noms des scénarios contenus dans le système de données de PAX2SIM.
        /// </summary>
        /// <returns>La liste triée des noms des scénarios qui sont présents dans le système de données.</returns>
        public List<String> getScenarioNames()
        {
            ///On alloue la mémoire pour la liste des noms
            List<String> lsResult = new List<string>();

            ///On parcours l'ensemble des scénarios, et on récupère les noms.
            foreach (String key in dmsScenarios.Keys)
            {
                lsResult.Add(key);
            }
            ///On trie la liste des noms ainsi récupérés.
            lsResult.Sort(new OverallTools.FonctionUtiles.ColumnsComparerList());
            ///On retourne la liste calculée.
            return lsResult;
        }

        /// <summary>
        /// Fonction qui renvoie tous les noms des scénarios qui peuvent être simulés en mode passager. Cela veut dire qui ont des 
        /// paramètres pour la simulations passager valides.
        /// </summary>
        /// <returns>Liste des noms des scénarios qui sont valides pour une simulation passager.</returns>
        public List<String> getScenariosReadyToSimulate()
        {
            ///On alloue la mémoire pour la liste des noms
            List<String> lsResult = new List<string>();
            ///On parcours les scénarios et on ne sélectionne que ceux qui ont une définition pour une simulation Passager valide.
            foreach (String key in dmsScenarios.Keys)
            {
                if (!typeof(DataManagerPaxBHS).IsInstanceOfType(dmsScenarios[key]))
                    continue;
                if (((DataManagerPaxBHS)dmsScenarios[key]).Scenario == null)
                    continue;
                if (((DataManagerPaxBHS)dmsScenarios[key]).Scenario.PaxSimulation)
                {
                    lsResult.Add(key);
                }
            }
            ///On trie la liste des noms ainsi récupérés.
            lsResult.Sort(new OverallTools.FonctionUtiles.ColumnsComparerList());
            ///On retourne la liste calculée.
            return lsResult;
        }

        /// <summary>
        /// Fonction qui renvoie tous les noms des scénarios qui ont un bagplan valide. C'est à dire que ces scénarios ont été simulés
        /// en mode passager et qu'un bagplan a été ensuite chargé.
        /// </summary>
        /// <returns>Liste des scénarios qui ont une définition valide pour le bagplan.</returns>
        public List<String> getScenariosReadyToSimulateWithBagPlan()
        {
            ///On alloue la mémoire pour la liste des noms
            List<String> lsResult = new List<string>();
            ///On parcours les scénarios et on ne sélectionne que ceux qui ont une définition pour une simulation Passager valide et un BagPlan valide.
            foreach (String key in dmsScenarios.Keys)
            {
                if (!typeof(DataManagerPaxBHS).IsInstanceOfType(dmsScenarios[key]))
                    continue;
                if ((((DataManagerPaxBHS)dmsScenarios[key]).Scenario.PaxSimulation) &&
                    (dmsScenarios[key].Exist(sTableBagPlan)))
                {
                    lsResult.Add(key);
                }
            }
            ///On trie la liste des noms ainsi récupérés.
            lsResult.Sort(new OverallTools.FonctionUtiles.ColumnsComparerList());
            ///On retourne la liste calculée.
            return lsResult;
        }
        
        /// <summary>
        /// Fonction qui se charge d'ajouter un nouveau scénario en se basant sur un scénario déjà existant. Cette fonction
        /// copie alors l'intégralité des données présentes dans le scénario source dans un nouveau scénario.
        /// </summary>
        /// <param name="Name">Nom du nouveau scénario</param>
        /// <param name="AncienName">Nom de l'ancien scénario</param>
        /// <param name="cht">Fenêtre de chargement (peut être NULL) permettant de gérer un état d'avancement pour l'utilisateur</param>
        /// <param name="cmsBranchTestMenu">Menu à mettre au noeud principal du scénario.</param>
        /// <param name="cmsContextMenuInput">Menu à mettre aux noeuds de chacune des tables contenus dans le scénario.</param>
        /// <param name="cmsFilterMenu">Menu à mettre aux noeuds ajoutés qui représenteront un Filtre.</param>
        /// <param name="cmsAutomodMenu">Menu à mettre au noeud du dossier qui contient tous les graphiques Automod.</param>
        /// <param name="cmsUserGraphics">Menu à mettre aux noeuds de chacun des graphiques importés depuis Automod (User Graphics).</param>
        /// <param name="processAndDescriptionDictionary">Result nodes from the scenario -> K: process name, V: process name and description</param>
        /// <returns>NULL ou le noeud du treeview qui doit être ajouté à l'interface et qui contient toute l'architecture du nouveau scénario.</returns>        
        public TreeNode CopyScenario(String Name,
                                     String AncienName,
                                     Prompt.SIM_LoadingForm cht,
                                     ContextMenuStrip cmsBranchTestMenu,
                                     ContextMenuStrip cmsContextMenuInput,
                                     ContextMenuStrip cmsFilterMenu,
                                     ContextMenuStrip cmsAutomodMenu,
                                     ContextMenuStrip cmsUserGraphics,
                                     Dictionary<String, String> processAndDescriptionDictionary)    // >> Task #10326 Pax2Sim - Copy Scenario - copy process description
        {
            ///Si un scénario avec le même nom est déjà présent dans le système de données, alors on renvoie NULL.
            if (ScenarioExist(Name))
                return null;
            DataManagement.DataManagerScenario dmsScenario = (DataManagement.DataManagerScenario)GetDataManager(AncienName);
            dmsScenario.tempName = Name;    // >> Task #1954_bagTrace
                        
            dmsScenario = (DataManagement.DataManagerScenario)dmsScenario.Copy();
            dmsScenario.Name = Name;

            ///On signifie au projet qu'un élément a été modifié.
            hadBeenSaved = false;
            AddScenario(dmsScenario);
            return dmsScenario.GenerateScenarioNode(cmsBranchTestMenu, cmsContextMenuInput, cmsFilterMenu, cmsAutomodMenu, cmsUserGraphics,
                                                    processAndDescriptionDictionary);   // >> Task #10326 Pax2Sim - Copy Scenario - copy process description
        }

        /// <summary>
        /// Cette fonction permet de récupérer la liste des noms de tables (ou de filtres) qui peuvent être utilisés pour une simulation.
        /// Ces tables sont sélectionnée suivant plusieurs critères. \n - Elles doivent être les filles de la table passée en paramêtre 
        /// (celle ci est également valide)\n - Elles doivent posséder les mêmes colonnes que la table mère.
        /// </summary>
        /// <param name="dataSet">Nom du système de données où sont stockées les tables.</param>
        /// <param name="NomTable">Nom de la table racine.</param>
        /// <returns>Tableau vide, ou la liste des noms des tables qui sont valides pour la simulation.</returns>
        public List<String> getValidTables(String dataSet, String NomTable)
        {
            ///On essaie de récupérer le système de données, si celui n'existe pas alors on Renvoie une liste vide.
            DataManagement.DataManager dmInput = InputData;
            if (dmInput == null)
                return new List<string>();
            //Booléen pour savoir s'il y a une vérification particulière à faire pour la table de ShowUp. (le mode version d'évaluation est
            //limité en nombre de lignes).
            bool bCheckShowUp = (NomTable == GlobalNames.CI_ShowUpTableName) && PAX2SIM.bTrialVersion;

            SIMCORE_TOOL.DataManagement.NormalTable ntTable = dmInput.GetTable(NomTable);
            if (ntTable == null)
                return new List<string>();
            return ntTable.getValidTables(bCheckShowUp);//getValidTables(ntTable, listeEntetes[iIndexReferenceTable], bCheckShowUp);

        }

        /*internal List<String> getValidTables(DataManagement.NormalTable ntTable, String[] Columns, bool bCheckShowUp)
        {
            List<String> lsReturn = new List<string>();
            bool bValid = true;
            DataTable dtTable = ntTable.Table;
            foreach (String columnName in Columns)
            {
                if (!dtTable.Columns.Contains(columnName))
                {
                    bValid = false;
                    break;
                }
            }
            if (bValid && ((!bCheckShowUp) || (IsValidShowUp(dtTable))))
                lsReturn.Add(ntTable.Name);
            List<String> Filters = ntTable.GetFilters();
            foreach (String sKey in Filters)
            {
                lsReturn.AddRange(getValidTables(ntTable.GetFilter(sKey), Columns, bCheckShowUp));
            }
            return lsReturn;
        }*/

        /// <summary>
        /// Fonction qui permet de récupérer la liste des noms de tables (ou de filters) qui peuvent être utilisés pour une simulation Bagage.
        /// Ces tables sont sélectionnée suivant plusieurs critères. \n - Elles doivent être les filles de la table passée en paramêtre 
        /// (celle ci est également valide)\n - Elles doivent posséder les mêmes colonnes que la table mère.
        /// </summary>
        /// <param name="dataSet">Nom du système de données où sont stockées les tables.</param>
        /// <param name="iTerminal">Terminal observé.</param>
        /// <param name="suffixe">Suffixe de la table que l'on recherhe.</param>
        /// <returns>Tableau vide, ou la liste des noms des tables qui sont valides pour la simulation.</returns>
        public List<String> getValidTables(String dataSet, int iTerminal, String suffixe)
        {
            ///TODO - Voir pour la détection 
            ///On vérifie que la table racine est bien une table détaillée dans l'interface de PAX2SIM (plans de vols, Show Up ...)
            int iIndexReferenceTable = OverallTools.FonctionUtiles.indexDansListe(suffixe, ListeNomTableBHS);
            if (iIndexReferenceTable == -1)
            {
                ///On retourne une liste vide si la table racine n'est pas une table valide comme modèle.
                return new List<String>();
            }
            String tableName = GlobalNames.sBHS_PrefixeLong + iTerminal.ToString() + "_" + suffixe;


            DataManagement.DataManager dmInput = GetDataManager(dataSet);
            if (dmInput == null)
                return new List<string>();
            DataManagement.NormalTable ntTmp = dmInput.GetTable(tableName);
            if (ntTmp == null)
                return new List<string>();
            return ntTmp.getValidTables(false);// getValidTables(ntTmp, ListeEntetes_BHS[iIndexReferenceTable], false);
        }


        #endregion

        #region Pour les notes   ==> Commentaires faits
        
        /// <summary>
        /// Fonction qui permet de récupérer le contenu de la note pour la table passée en paramètre.
        /// </summary>
        /// <param name="dataSet">Nom du système de données où est stockée la table (nom du scénario / "INPUT" / "")</param>
        /// <param name="nomTable">Nom de la table auquel la note est attachée</param>
        /// <returns>Renvoie une chaine de caractère représentant la note. Renvoie null si aucune note ou si un problème est apparu</returns>
        public String getNote(String dataSet, String nomTable)
        {
            if ((dataSet == null) || (dataSet == ""))
            {
                return getGeneralNote(nomTable);
            }
            /// Récupération du système de données auquel la note est attachée
            DataManagement.DataManager gs = GetDataManager(dataSet);
            ///Si le système de donnée n'existe pas, on renvoie null.
            if (gs == null)
                return null;
            ///Si la table n'existe pas dans le système de données alors la fonction ne fait rien
            if (!gs.Exist(nomTable))
                return null;
            ///On renvoie la note trouvée.
            return gs.GetTable(nomTable).Note;
        }
        /// <summary>
        /// Function that retrieves the content of a Gantt Note associated to the given Table from the given Dataset
        /// </summary>
        /// <param name="dataSet">The name of the Dataset where the Table is stored (name of scenario / "INPUT" / "")</param>
        /// <param name="nomTable">Name of the table that has the Gantt Note associated</param>
        /// <returns>Returns a String representing the content of the Gantt Note. Returns null if there is no Gantt Note,
        /// if the Data can't be retrieved based on the Dataset parameter or if the Table can't be found in the Data</returns>
        public String getGanttNote(String dataSet, String nomTable) //>>GanttNote for Report
        {
            DataManagement.DataManager gs = GetDataManager(dataSet);
            if (gs == null)
                return null;
            if (!gs.Exist(nomTable))
                return null;
            return gs.GetTable(nomTable).ganttNote;
        }
        // >> Task #10645 Pax2Sim - Pax analysis - Summary: dashboard image for Reports
        /// <summary>
        /// Function that retrieves the content of a Dashboard Note associated to the given Table from the given Dataset
        /// </summary>
        /// <param name="dataSet">The name of the Dataset where the Table is stored (name of scenario / "INPUT" / "")</param>
        /// <param name="nomTable">Name of the table that has the Dashboard Note associated</param>
        /// <returns>Returns a String representing the content of the Dashboard Note. Returns null if there is no Dashboard Note,
        /// if the Data can't be retrieved based on the Dataset parameter or if the Table can't be found in the Data</returns>
        public String getDashboardNote(String dataSet, String tableName)
        {
            DataManagement.DataManager dataManager = GetDataManager(dataSet);
            if (dataManager == null || !dataManager.Exist(tableName))
            {
                return null;
            }
            return dataManager.GetTable(tableName).dashboardNote;
        }
        // << Task #10645 Pax2Sim - Pax analysis - Summary: dashboard image for Reports
        /// <summary>
        /// Fonction qui permet de récupérer le contenu de la note pour la table d'exception passée en paramètre.
        /// </summary>
        /// <param name="dataSet">Nom du système de données où est stockée la table (nom du scénario / "INPUT" / "")</param>
        /// <param name="nomTable">Nom de la table auquel la note est attachée</param>
        /// <returns>Renvoie une chaine de caractère représentant la note. Renvoie null si aucune note ou si un problème est apparu</returns>
        public String getExNote(String dataSet, String nomTable, String exceptionType)
        {
            if ((dataSet == null) || (dataSet == ""))
            {
                return null;
            }
            NormalTable ntTable = GetExceptionTable(dataSet, nomTable, exceptionType);
            if (ntTable != null)
                return ntTable.Note;
            return null;
        }
        /// <summary>
        /// Fonction qui permet d'attribuer (ou de mettre à jour) une note à une table
        /// </summary>
        /// <param name="dataSet">Nom du système de données où est stockée la table (nom du scénario / "INPUT" / "")</param>
        /// <param name="nomTable">Nom de la table auquel la note est attachée</param>
        /// <param name="sNote">La note que l'on souhaite attribuée à une table.</param>
        public void setNote(String dataSet, String nomTable, String sNote)
        {
            if ((dataSet == null) || (dataSet == ""))
            {
                setGeneralNote(nomTable, sNote);
                return;
            }
            /// Récupération du système de données auquel la note est attachée
            DataManagement.DataManager gs = GetDataManager(dataSet);
            ///Si le système de donnée n'existe pas, on arrète la fonction
            if (gs == null)
                return;
            ///Si la table n'existe pas dans le système de données alors la fonction ne fait rien
            if (!gs.Exist(nomTable))
                return ;
            ///On met à jour la note dans le système de données.
            gs.GetTable(nomTable).Note = sNote;
        }
        /// <summary>
        /// Function that associates or updates a Gantt Note to the given Table
        /// </summary>
        /// <param name="dataSet">The name of the Dataset where the Table is stored (name of scenario / "INPUT" / "")</param>
        /// <param name="nomTable">Name of the Table to which the Gantt Note will be associated</param>
        /// <param name="sNote">The String representation of the Gantt Note</param>
        public void setGanttNote(String dataSet, String nomTable, String sNote) //>>GanttNote for Report
        {
            DataManagement.DataManager gs = GetDataManager(dataSet);
            if (gs == null)
                return;
            if (!gs.Exist(nomTable))
                return;
            gs.GetTable(nomTable).ganttNote = sNote;
        }
        // >> Task #10645 Pax2Sim - Pax analysis - Summary: dashboard image for Reports
        /// <summary>
        /// Function that associates or updates a Dashboard Note to the given Table
        /// </summary>
        /// <param name="dataSet">The name of the Dataset where the Table is stored (name of scenario / "INPUT" / "")</param>
        /// <param name="nomTable">Name of the Table to which the Dashboard Note will be associated</param>
        /// <param name="sNote">The String representation of the Dashboard Note</param>
        public void setDashboardNote(String dataSet, String tableName, String dashboardNote)
        {
            DataManagement.DataManager dataManager = GetDataManager(dataSet);
            if (dataManager == null || !dataManager.Exist(tableName))
            {
                return;
            }
            dataManager.GetTable(tableName).dashboardNote = dashboardNote;
        }
        // << Task #10645 Pax2Sim - Pax analysis - Summary: dashboard image for Reports
        /// <summary>
        /// Fonction qui permet d'attribuer (ou de mettre à jour) une note à une table
        /// </summary>
        /// <param name="dataSet">Nom du système de données où est stockée la table (nom du scénario / "INPUT" / "")</param>
        /// <param name="nomTable">Nom de la table auquel la note est attachée</param>
        /// <param name="sNote">La note que l'on souhaite attribuée à une table.</param>
        public void setExNote(String dataSet, String nomTable, String exceptionType, String sNote)
        {
            if ((dataSet == null) || (dataSet == ""))
            {
                return;
            }
            NormalTable ntTable = GetExceptionTable(dataSet, nomTable, exceptionType);
            if (ntTable != null)
                ntTable.Note = sNote;
        }


        /// <summary>
        /// Fonction qui permet de récupérer la note globale portant le nom passé en paramètre.
        /// </summary>
        /// <param name="nomNote">Nom de la note recherchée</param>
        /// <returns>Renvoie une chaine de caractère représentant la note. Renvoie null si aucune note ou si un problème est apparu</returns>
        public String getGeneralNote(String nomNote)
        {
            ///Si la note n'existe pas, alors on renvoie NULL.
            if (!lsNotes.ContainsKey(nomNote))
                return null;
            ///On renvoie la note recherchée.
            return lsNotes[nomNote];
        }

        /// <summary>
        /// Fonction qui permet d'attribuer (ou de mettre à jour) une note stockée dans le projet
        /// </summary>
        /// <param name="nomNote">Nom de la note</param>
        /// <param name="sNote">La note que l'on souhaite ajoutée ou mettre à jour.</param>
        public void setGeneralNote(String nomNote, String sNote)
        {
            ///Si la note existe déjà dans le système, alors on la met à jour. 
            ///Sinon on ajoute une nouvelle entrée avec la nouvelle note.
            if (lsNotes.ContainsKey(nomNote))
            {
                lsNotes[nomNote]= sNote;
            }
            else
            {
                lsNotes.Add(nomNote, sNote);
            }
        }

        /// <summary>
        /// Fonction qui permet de sauvegarder les notes générals dans le fichier xml.
        /// </summary>
        /// <param name="xdProjet">Document Xml qui nous permet de créer la totalité des noeuds XML.</param>
        /// <returns>NULL, ou le noeud XMl contenant toutes les notes à sauvegarder.</returns>
        internal XmlNode saveGeneralNotes(XmlDocument xdProjet)
        {
            ///Si le système qui stocke les notes est vide, alors on renvoie NULL
            if (lsNotes == null)
                return null;
            ///S'il n'y a aucune note à sauvegarder, alors on renvoie NULL
            if (lsNotes.Count == 0)
                return null;
            ///On créé un nouveau noeud XML nommé General Notes
            XmlNode xnNotes = xdProjet.CreateElement("GeneralNotes");
            ///Pour chaque note présent dans le système, on créé un noeud XML contenant les informations sur la note.
            foreach (String sKey in lsNotes.Keys)
            {
                XmlElement xnNote = xdProjet.CreateElement("Note");
                xnNote.SetAttribute("Name", sKey);
                xnNote.AppendChild(xdProjet.CreateCDataSection(lsNotes[sKey]));
                xnNotes.AppendChild(xnNote);
            }
            ///On renvoie le noeud XML racine de toutes les notes.
            return xnNotes;
        }

        /// <summary>
        /// Fonction qui permet d'ouvrir les notes générales stockées dans le XML.
        /// </summary>
        /// <param name="xnNodes">Noeud xml contenant toutes les notes générales que l'on souhaite ouvrir.</param>
        internal void openGeneralNotes(XmlNode xnNodes)
        {
            ///On intialize la structure de donnée qui va accueillir les notes.
            if (lsNotes != null)
                lsNotes.Clear();
            lsNotes = new Dictionary<string, string>();
            ///Pour chaque noeud xml contenu dans le noeud XML parent, si le noeux contient une note valide, alors on l'ajoute aux notes générales.
            foreach (XmlNode xnTmp in xnNodes.ChildNodes)
            {
                if (!OverallTools.FonctionUtiles.hasNamedAttribute(xnTmp, "Name"))
                    continue;
                String sKey = xnTmp.Attributes["Name"].Value;
                string sValue = xnTmp.FirstChild.Value;
                setGeneralNote(sKey, sValue);
            }
        }


        /// <summary>
        /// Class représentant un paragraphe. Un paragraphe étant un morceau de texte qui peut être ajouté dans un rapport pdf (ou html).
        /// </summary>
        internal class Paragraph
        {
            /// <summary>
            /// Le nom du paragraphe.
            /// </summary>
            public String Name;
            /// <summary>
            /// Titre du paragraphe.
            /// </summary>
            public String Title;
            /// <summary>
            /// Contenu de la note html.
            /// </summary>
            public String Content;

            /// <summary>
            /// Constructeur d'un paragraphe.
            /// </summary>
            /// <param name="sName">Le nom du paragraphe.</param>
            /// <param name="sTitle">Titre du paragraphe.</param>
            /// <param name="sContent">Contenu de la note html.</param>
            internal Paragraph(String sName, String sTitle, String sContent)
            {
                Name = sName;
                Title = sTitle;
                Content = sContent;
            }

            /// <summary>
            /// Constructeur de paragraphe qui se base sur un noeud XML passé en paramètre.
            /// </summary>
            /// <param name="xnNodes">Noeud XML représentant un Paragraph</param>
            internal Paragraph(XmlNode xnNodes)
            {
                ///Si le noeud XML n'a pas d'attribut Name ou d'attribut Title, alors on initialise toutes les variables
                ///à null.
                if (!OverallTools.FonctionUtiles.hasNamedAttribute(xnNodes, "Name"))
                    return;

                if (!OverallTools.FonctionUtiles.hasNamedAttribute(xnNodes, "Title"))
                    return;
                ///Sinon on initiale les variables avec les valeurs trouvées dans le noeud XML.
                Name = xnNodes.Attributes["Name"].Value;
                Title = xnNodes.Attributes["Title"].Value;
                Content = xnNodes.FirstChild.Value;
            }

            /// <summary>
            /// Fonction qui permet de construire un noeud XML représenant l'instance courante de paragraph.
            /// </summary>
            /// <param name="xdProject">Le projet auque le noeud XML doit être rattaché.</param>
            /// <returns>Un noeud Xml représentant l'instance de paragraph courant.</returns>
            internal XmlNode getXml(XmlDocument xdProject)
            {
                XmlElement xnParagraph = xdProject.CreateElement("Paragraph");
                xnParagraph.SetAttribute("Name", Name);
                xnParagraph.SetAttribute("Title", Title);
                xnParagraph.AppendChild(xdProject.CreateCDataSection(Content));
                return xnParagraph;
            }
        }

        /// <summary>
        /// Permet de mettre à jour ou d'ajouter un nouveau paragraphe dans le document.
        /// </summary>
        /// <param name="sName">Nom du paragraphe</param>
        /// <param name="pParagraph">Contenu du paragraphe.</param>
        internal void setParagraph(String sName, Paragraph pParagraph)
        {
            ///Si le paragraphe est déjà présent dans le projet, alors on met à jour son contenu.
            ///Sinon on ajoute un nouveau paragraphe.
            if (lsParagraph.ContainsKey(sName))
            {
                if (pParagraph == null)
                    lsParagraph.Remove(sName);
                else
                    lsParagraph[sName] = pParagraph;
            }
            else
            {
                lsParagraph.Add(sName, pParagraph);
            }
        }
        /// <summary>
        /// Permet de récupérer la définition d'un paragraphe.
        /// </summary>
        /// <param name="sName">Le nom du paragraphe recherché.</param>
        /// <returns>Le paragraphe recherché ou alors NULL.</returns>
        internal Paragraph getParagraph(String sName)
        {
            if (!lsParagraph.ContainsKey(sName))
                return null;
            return lsParagraph[sName];
        }

        /// <summary>
        /// Permet de recuperer la list des paragraphes.
        /// </summary>
        /// <returns>Dictionary of Paragraphs</returns>
        internal Dictionary<String, Paragraph> getParagraphList()
        {
            return lsParagraph;
        }
        /// <summary>
        /// Fonction qui permet de sauvegarder les paragraphes dans le fichier xml.
        /// </summary>
        /// <param name="xdProjet">Document Xml qui nous permet de créer la totalité des noeuds XML.</param>
        /// <returns>NULL, ou le noeud XMl contenant tous les paragraphes à sauvegarder.</returns>
        internal XmlNode saveParagraph(XmlDocument xdProjet)
        {
            ///Si le système qui stocke les paragraphes est vide, alors on renvoie NULL
            if (lsParagraph == null)
                return null;
            ///S'il n'y a aucun paragraphe à sauvegarder, alors on renvoie NULL
            if (lsParagraph.Count == 0)
                return null;
            ///On créé un nouveau noeud XML nommé Paragraphs
            XmlNode xnParagraphs = xdProjet.CreateElement("Paragraphs");
            ///Pour chaque paragraphe présent dans le système, on créé un noeud XML contenant les informations sur celui ci.
            foreach (String sKey in lsParagraph.Keys)
            {
                XmlNode xnParagraph = lsParagraph[sKey].getXml(xdProjet);
                xnParagraphs.AppendChild(xnParagraph);
            }
            ///On renvoie le noeud XML racine de tous les paragraphes.
            return xnParagraphs;
        }

        /// <summary>
        /// Fonction qui permet d'ouvrir les paragraphes stockées dans le XML.
        /// </summary>
        /// <param name="xnNodes">Noeud xml contenant tous les paragraphes que l'on souhaite ouvrir.</param>
        internal void openParagraph(XmlNode xnNodes)
        {
            ///On intialize la structure de donnée qui va accueillir les paragraphes.
            if (lsParagraph != null)
                lsParagraph.Clear();
            lsParagraph = new Dictionary<string, Paragraph>();
            ///Pour chaque noeud xml contenu dans le noeud XML parent, si le noeux contient un paragraphe valide, alors on l'ajoute aux Paragraphes.
            foreach (XmlNode xnTmp in xnNodes.ChildNodes)
            {
                Paragraph tmp = new Paragraph(xnTmp);
                if (tmp.Name == null)
                    continue;
                lsParagraph.Add(tmp.Name, tmp);
            }
        }

        /// <summary>
        /// Permet de recuperer la list des paragraphes.
        /// </summary>
        /// <returns>Dictionary of Paragraphs</returns>
        internal void deleteParagraph(String paragraphName)
        {
            if (!lsParagraph.ContainsKey(paragraphName))
                return;
            lsParagraph.Remove(paragraphName);
        }
        #endregion

        #region Gestion des filtres sur les graphiques généraux   ==> Commentaires faits
        /// <summary>
        /// Vérifie si le FiltreGraphique existe dans la liste des FiltresGraphique généraux.
        /// </summary>
        /// <param name="Name">Le nom recherché</param>
        /// <returns>Booléen indiquant si le nom a été trouvé ou non</returns>
        internal bool GraphicFilterExist(String Name)
        {
            return htGraphiques.ContainsKey(Name);
        }

        /// <summary>
        /// Vérifie si le Filtre existe dans la liste des Filtres généraux.
        /// </summary>
        /// <param name="Name">Le nom recherché</param>
        /// <returns>Booléen indiquant si le nom a été trouvé ou non</returns>
        internal bool FilterExist(String Name)
        {
            return dsfGraphiquesFilters.ContainsKey(Name);
        }

        /// <summary>
        /// Fonction qui permet d'ajouter un graphique général au projet courant. 
        /// </summary>
        /// <param name="graphicFilter">Le filtre graphique que l'on souhaite ajouter</param>
        /// <returns>Booléen indiquant si l'ajout s'est bien déroulé.</returns>
        internal bool AddGeneralGraphicFilter(GraphicFilter graphicFilter)
        {
            ///On teste d'abord que aucun Filtre ou FiltreGraphic ne porte déjà ce nom.
            if (GraphicFilterExist(graphicFilter.Name) || FilterExist(graphicFilter.Name))
                return false;
            ///On signifie au projet qu'un élément a été modifié.
            hadBeenSaved = false;
            ///On ajoute à la collection le nouveau FiltreGraphique.
            htGraphiques.Add(graphicFilter.Name, graphicFilter);
            return true;
        }

        /// <summary>
        /// Fonction qui permet d'ajouter un FiltreGraphique à la collection. Ce FiltreGraphique devra
        /// être lié à une table déjà existante dans la collection. Sinon il ne sera pas ajouter. Il faut 
        /// également que le FiltreGraphique ne soit pas déjà existant dans la collection.
        /// </summary>
        /// <param name="graphicFilter">Le nouveau FiltreGraphique que l'on veut ajouter.</param>
        /// <returns>Booléen indiquant si l'ajout s'est bien déroulé.</returns>
        internal bool AddGraphicFilter(GraphicFilter graphicFilter)
        {
            ///On vérifie que le nouveau FiltreGraphique peut être ajouté (Un Filtre existe avec ce nom).
            if((!FilterExist(graphicFilter.Name)) || (GraphicFilterExist(graphicFilter.Name)))
                return false;
            ///On signifie au projet qu'un élément a été modifié.
            hadBeenSaved = false;
            ///On ajoute à la collection le nouveau FiltreGraphique.
            htGraphiques.Add(graphicFilter.Name, graphicFilter);
            return true;
        }

        /// <summary>
        /// Fonction qui permet de mettre à jour un FiltreGraphique déjà existant dans la collection.
        /// La condition est que un Filtre portant se même nom doit déjà exister dans la collection.
        /// </summary>
        /// <param name="graphicFilter">Le nouveau FiltreGraphique que l'on veut mettre à jour.</param>
        /// <returns>Booléen indiquant si l'ajout s'est bien déroulé.</returns>
        internal bool UpdateGraphicFilter(GraphicFilter graphicFilter)
        {
            ///On vérifie que le nouveau FiltreGraphique peut être ajouté (Un Filtre existe avec ce nom).
            if (!FilterExist(graphicFilter.Name))
                return false;
            ///On supprime l'ancienne version du FiltreGraphique (si elle était présente).
            if (GraphicFilterExist(graphicFilter.Name))
                htGraphiques.Remove(graphicFilter.Name);
            ///On signifie au projet qu'un élément a été modifié.
            hadBeenSaved = false;
            ///On ajoute à la collection le nouveau FiltreGraphique.
            htGraphiques.Add(graphicFilter.Name, graphicFilter);
            return true;
        }

        /// <summary>
        /// Fonction qui permet d'ajouter ou de mettre à jour un graphique général au projet courant. 
        /// </summary>
        /// <param name="graphicFilter">Le nouveau FiltreGraphique que l'on veut mettre à jour.</param>
        /// <returns>Booléen indiquant si l'ajout s'est bien déroulé.</returns>
        internal bool UpdateGeneralGraphicFilter(GraphicFilter graphicFilter)
        {
            ///On teste qu'aucun filtre n'existe avec le nom du FiltreGraphique qui doit être ajouté.
            if (FilterExist(graphicFilter.Name))
                return false;
            ///On supprime l'ancienne version du FiltreGraphique général (si elle était présente).
            if (GraphicFilterExist(graphicFilter.Name) || FilterExist(graphicFilter.Name))
                htGraphiques.Remove(graphicFilter.Name);
            ///On signifie au projet qu'un élément a été modifié.
            hadBeenSaved = false;
            ///On ajoute à la collection le nouveau FiltreGraphique.
            htGraphiques.Add(graphicFilter.Name, graphicFilter);
            return true;
        }

        /// <summary>
        /// Cette fonction retourne tous les noms des filtresGraphiques généraux présents dans le projet.
        /// </summary>
        /// <returns>La liste des noms des filtresGraphiques généraux présents dans le projet. (Peut être une liste vide)</returns>
        internal List<String> GetGeneralGraphicFilter()
        {
            ///Si la liste des filtresGraphiques est vide, alors on retourne une liste vide.
            if (htGraphiques.Count == 0)
                return new List<string>();
            List<String> lsResult = new List<string>();
            ///On parcours l'ensemble des filtresGraphiques présents dans le projet. S'il n'y a pas de filtre associé, alors on ajoute
            ///le nom à la liste qui sera renvoyée.
            foreach (String sKey in htGraphiques.Keys)
            {
                if (FilterExist(sKey))
                    continue;
                lsResult.Add(sKey);
            }
            ///On trie la liste ainsi trouvée et on la renvoie.
            lsResult.Sort(new OverallTools.FonctionUtiles.ColumnsComparerList());
            return lsResult;
        }

        /// <summary>
        /// Fonction qui permet de supprimer la définition d'un FiltreGraphique.
        /// </summary>
        /// <param name="Name">Le nom du FiltreGraphique que l'on veut supprimer.</param>
        /// <returns>Booléen indiquant si l'ajout s'est bien déroulé.</returns>
        public bool DeleteGraphicFilter(String Name)
        {
            ///On vérifie que le FiltreGraphique existe.
            if (!GraphicFilterExist(Name))
                return false;
            ///On signifie au projet qu'un élément a été modifié.
            hadBeenSaved = false;
            ///On supprime la définition du graphique.
            htGraphiques.Remove(Name);
            return true;
        }

        /// <summary>
        /// Fonction qui permet de supprimer la définition d'un FiltreGraphique général, ainsi
        /// que tous les filtres qui étaient associés.
        /// </summary>
        /// <param name="Name">Le nom du FiltreGraphique général que l'on souhaite supprimer.</param>
        /// <returns>Booléen indiquant si l'ajout s'est bien déroulé.</returns>
        public bool DeleteGeneralGraphicFilter(String Name)
        {
            ///On vérifie que le FiltreGraphique existe.
            if ((!GraphicFilterExist(Name)) || (FilterExist(Name)))
                return false;
            ///On signifie au projet qu'un élément a été modifié.
            hadBeenSaved = false;

            ///On parcours l'ensemble des Filtres présents. Et on supprime tous les filtres qui ont pour parent
            ///le FiltreGraphique courant.
            foreach (String fFilterKey in dsfGraphiquesFilters.Keys)
            {
                if (dsfGraphiquesFilters[fFilterKey].MotherTableName == Name)
                {
                    DeleteFilter(fFilterKey);
                }
            }
            ///On supprime la définition du graphique.
            htGraphiques.Remove(Name);
            return true;
        }

        /// <summary>
        /// Return the definition of the FiltreGraphique general voulu.
        /// </summary>
        /// <param name="Name">Nom du FiltreGraphique que l'on souhaite récupérer.</param>
        /// <returns>Null ou alors la définition du FiltreGraphique voulue.</returns>
        internal GraphicFilter GetGeneralGraphicFilter(String Name)
        {
            ///On vérifie que le FiltreGraphique existe, si non alors on retourne NULL
            if (!FilterExist(Name) && !GraphicFilterExist(Name))
                return null;
            if ((FilterExist(Name)) || (!GraphicFilterExist(Name)))
                return null;
            ///On retourne la définition du FiltreGraphique voulu.
            return htGraphiques[Name];
        }

        /// <summary>
        /// Return the definition of the FiltreGraphique voulu.
        /// </summary>
        /// <param name="Name">Nom du FiltreGraphique que l'on souhaite récupérer.</param>
        /// <returns>Null ou alors la définition du FiltreGraphique voulue.</returns>
        internal GraphicFilter GetGraphicFilter(String Name)
        {
            ///On vérifie que le FiltreGraphique existe, si non alors on retourne NULL
            if ((!FilterExist(Name)) || (!GraphicFilterExist(Name)))
                return null;
            ///On retourne la définition du FiltreGraphique voulu.
            return htGraphiques[Name];
        }

        /// <summary>
        /// Fonction qui renvoie les noms de tous les FiltresGraphique généraux.
        /// </summary>
        /// <returns>Liste des noms de tous les FiltresGraphique généraux.</returns>
        internal List<String> GetGraphicFilter()
        {
            ///On parcourt chacune des définitons de FiltreGraphique. Si aucun Filtre n'est défini avec le même nom, alors on
            /// ajoute ce nom à la liste.
            List<String> lsNames = new List<string>();
            foreach (String key in htGraphiques.Keys)
            {
                if (FilterExist(key))
                    continue;
                lsNames.Add(key);
            }

            ///On retourne la liste ainsi trouvée.
            return lsNames;

        }

        /// <summary>
        /// Fonction qui permet de mettre à jour un Filtre. Ce Filtre est général, cela veut dire qu'il n'est pas lié
        /// à un DataSet. Ce filtre peut donc avoir comme parent un autre filtre ou alors un FiltreGraphique 
        /// général.
        /// </summary>
        /// <param name="fFilter">La mise à jour du filtre.</param>
        /// <returns>Booléen indiquant si l'ajout s'est déroulé sans problème ou non.</returns>
        internal bool UpdateFilter(Filter fFilter)
        {
            if (!dsfGraphiquesFilters.ContainsKey(fFilter.Name))
                return false;
            dsfGraphiquesFilters.Remove(fFilter.Name);
            dsfGraphiquesFilters.Add(fFilter.Name, fFilter);
            return true;
        }

        /// <summary>
        /// Fonction qui permet d'ajouter un Filtre. Ce Filtre est général, cela veut dire qu'il n'est pas lié
        /// à un DataSet. Ce filtre peut donc avoir comme parent un autre filtre ou alors un FiltreGraphique 
        /// général.
        /// </summary>
        /// <param name="fFilter">Le nouveau filtre à ajouter.</param>
        /// <param name="bLoading">Booléen indiquant si l'on est en train de charger les filtres ou non.</param>
        /// <returns>Booléen indiquant si l'ajout s'est déroulé sans problème ou non.</returns>
        internal bool AddFilter(Filter fFilter, bool bLoading)
        {
            ///On vérifie que le filtre peut être ajouté. Il ne doit pas exister dans les définitions de Filtres ou de
            ///FiltreGraphique généraux.
            if ((GraphicFilterExist(fFilter.Name)) ||
                (FilterExist(fFilter.Name)))
                return false;

            ///On vérifie que le parent du filtre existe. (que ce soit un Filtre ou un FiltreGraphique général.
            if ((!GraphicFilterExist(fFilter.MotherTableName)) && (!FilterExist(fFilter.MotherTableName)))
                return false;
            DataTable dtParent =null;
            ///Si on n'est pas en train de charger les filtres (bLoading à faux)
            if (!bLoading)
            {
                ///__ On récupère la table parente à partir de laquelle le filtre sera calculé, pour vérifier que le filtre sera viable.
                ///__ Si la table est nulle, alors on retourne FAUX.
                if (FilterExist(fFilter.MotherTableName))
                {
                    dtParent = getTable(fFilter.MotherTableName);
                }
                else
                {
                    GraphicFilter gf = GetGeneralGraphicFilter(fFilter.MotherTableName);
                    if (gf == null) return false;
                    dtParent = gf.GenerateTable(this);
                }
                if (dtParent == null)
                    return false;
            }
            ///On signifie au projet qu'un élément a été modifié.
            hadBeenSaved = false;
            ///On ajoute le filtre dans la collection.
            dsfGraphiquesFilters.Add(fFilter.Name, fFilter);
            return true;
        }

        /// <summary>
        /// Fonction qui permet d'ajouter un Filtre. Ce Filtre est général, cela veut dire qu'il n'est pas lié
        /// à un DataSet. Ce filtre peut donc avoir comme parent un autre filtre ou alors un FiltreGraphique 
        /// général.
        /// </summary>
        /// <param name="fFilter">Le nouveau filtre à ajouter.</param>
        /// <returns>Booléen indiquant si l'ajout s'est déroulé sans problème ou non.</returns>
        internal bool AddFilter(Filter fFilter)
        {
            ///Appel de \ref AddFilter(Filter fFilter, bool bLoading)
            return AddFilter(fFilter, false);
        }

        /// <summary>
        /// Fonction qui se charge de supprimer un Filtre.
        /// </summary>
        /// <param name="Name">Le nom du filtre que l'on veut supprimer.</param>
        /// <returns>Booléen indiquant si la suppression s'est déroulé sans problème ou non.</returns>
        internal bool DeleteFilter(String Name)
        {
            ///Si le filtre n'existe pas dans la collection, alors on retourne vrai.
            if(!FilterExist(Name))
                return true;
            ///Si le filtre possédait une définition pour son FiltreGraphique, alors on supprime celle ci.
            if(GraphicFilterExist(Name))
                DeleteGraphicFilter(Name);

            ///On parcours l'ensemble des Filtres présents. Et on supprime tous les filtres qui ont pour parent
            ///le Filtre courant.
            foreach (String fFilterKey in dsfGraphiquesFilters.Keys)
            {
                if (dsfGraphiquesFilters[fFilterKey].MotherTableName == Name)
                {
                    DeleteFilter(fFilterKey);
                }
            }
            ///On supprime le filtre passé en paramètre.
            dsfGraphiquesFilters.Remove(Name);
            return true;
        }

        /// <summary>
        /// Fonction pour récupérer la définition du filtre passé en paramètre.
        /// </summary>
        /// <param name="Name">Nom du filtre que l'on souhaite récupérer</param>
        /// <returns>Null ou alors le filtre s'il existe</returns>
        internal Filter GetFilter(String Name)
        {
            ///Si le Filtre n'existe pas, alors on renvoie NULL
            if(!FilterExist(Name))
                return null;
            ///On renvoie la définition du Filtre demandé.
            return dsfGraphiquesFilters[Name];
        }


        /// <summary>
        /// Fonction qui se charge d'actualisé tous les filtres enfant ayant pour parent l'objet sélectionné.
        /// </summary>
        /// <param name="sMotherTable">Le nom du noeud dont on veut mettre à jour les noeuds enfant.</param>
        /// <param name="tnGeneralGraphicsArea">Le noeud auquel tous les enfants devront être rattachés.</param>
        /// <param name="cmsMenuFilter">Le menu qui doit être attribué aux noeuds du treeview.</param>
        internal void UpdateGeneralFilters(String sMotherTable, TreeNode tnGeneralGraphicsArea, ContextMenuStrip cmsMenuFilter)
        {
            ///On parcours l'ensemble des filtres généraux présents dans le projet.
            foreach (String sKey in dsfGraphiquesFilters.Keys)
            {
                ///__ Si le filtre observé n'a pas pour parent \ref sMotherTable, alors on passe au filtre suivant.
                Filter fFilter = dsfGraphiquesFilters[sKey];
                if (fFilter.MotherTableName != sMotherTable)
                    continue;
                ///__ On essaye de récupèrer le noeud du treeview représentant le filtre.
                TreeNode noeudFiltre = OverallTools.TreeViewFunctions.RechercherNomEnfantStrict(fFilter.Name, tnGeneralGraphicsArea);
                if (noeudFiltre == null)
                {
                    ///____ Si le noeud n'existe pas, alors on en créé un avec les informations concernant le filtre.
                    TreeViewTag Tag = TreeViewTag.getFilterNode(null, fFilter.Name, fFilter.Blocked, fFilter.copyTable);

                    noeudFiltre = OverallTools.TreeViewFunctions.createBranch(fFilter.Name, fFilter.Name, Tag, cmsMenuFilter);
                    if (noeudFiltre == null)
                        continue;
                    ///____ On ajoute le noeud nouvellement créé au noeud passé en paramètre.
                    OverallTools.TreeViewFunctions.AddSortedNode(tnGeneralGraphicsArea, noeudFiltre, true);
                }
                ///__ On appelle \ref internal void UpdateGeneralFilters(String sMotherTable, TreeNode tnGeneralGraphicsArea, ContextMenuStrip cmsMenuFilter) pour le filtre courant.
                UpdateGeneralFilters(sKey, noeudFiltre, cmsMenuFilter);
            }
        }

        /// <summary>
        /// Fonction qui se charge de créer tous les noeuds dans le Treeview pour les filtres présents sur les graphiques généraux.
        /// </summary>
        /// <param name="tnGeneralGraphicsArea">Le noeud où sont contenus tous les graphiques généraux.</param>
        /// <param name="cmsMenuFilter">Le menu qui doit être attribué aux noeuds du treeview.</param>
        internal void UpdateGeneralFilters(TreeNode tnGeneralGraphicsArea, ContextMenuStrip cmsMenuFilter)
        {
            ///S'il n'y a aucun Filtre sur les FiltresGraphique généraux, alors on stoppe la fonction.
            if (dsfGraphiquesFilters.Count == 0)
                return;
            ///On récupère la liste des FiltresGraphiques genéraux. Si cette liste est vide, alors on stoppe la fonction.
            List<String> lsGeneralGraphicFilters = GetGeneralGraphicFilter();
            if (lsGeneralGraphicFilters.Count == 0)
                return;
            ///On parcours l'ensemble des FiltresGraphique généraux.
            foreach (String sGeneralFiltreName in lsGeneralGraphicFilters)
            {
                ///__ On recherche le noeud dans le Treeview pour le FiltreGraphique Genéral. S'il n'y en a pas, on ignore ce FiltreGraphique général.
                TreeNode noeudTmp = OverallTools.TreeViewFunctions.RechercherNom(sGeneralFiltreName, tnGeneralGraphicsArea);
                if (noeudTmp == null)
                    continue;
                ///On appelle \ref  internal void UpdateGeneralFilters(String sMotherTable, TreeNode tnGeneralGraphicsArea)
                ///pour mettre à jour tous les filtres pour ce FiltreGraphique général.
                UpdateGeneralFilters(sGeneralFiltreName, noeudTmp, cmsMenuFilter);
            }
        }


        /// <summary>
        /// Cette fonction renvoie la table associée au Filtre ou FiltreGraphique général demandé.
        /// </summary>
        /// <param name="sTableName">Le nom du Filtre ou du FiltreGraphique général demandé.</param>
        /// <returns>NULL ou la table demandée.</returns>
        internal DataTable getTable(String sTableName)
        {
            ///Si aucun Filtre et aucun FiltreGraphique général n'existent avec ce nom, alors on renvoie NULL
            if ((!FilterExist(sTableName)) && (!GraphicFilterExist(sTableName)))
                return null;

            ///On calcul la table du filtre à partir de la table parente.
            if (FilterExist(sTableName))
            {
                Filter filter = GetFilter(sTableName);
                
                DataTable dtParentTable = getTable(filter.MotherTableName);
                if (dtParentTable == null)
                    return null;
                return filter.applyFilter(dtParentTable, filter);
            }
            else
            {
                GraphicFilter gf = GetGeneralGraphicFilter(sTableName);
                if (gf == null)
                    return null;
                return gf.GenerateTable(this);
            }
        }
       
        #endregion

        #endregion

        #region Gestion de l'ajout d'un SCENARIO

        #region Fonction pour mettre à jour toutes les tables générées par le scénario.
        /// <summary>
        /// That function will calculate all the allocation tables linked to the 
        /// given Scenario. It will call all the different functions to allocate
        /// Check In, Boarding gate ...
        /// </summary>
        /// <param name="paParametres"></param>
        /// <param name="scWindow"></param>
        /// <param name="vmMode"></param>
        /// <param name="vmModeHandlers"></param>
        /// <returns></returns>
        private ArrayList MajAllocationScenario(Classes.ParamScenario paParametres,
                                                PAX2SIM.EnumPerimetre perimeter, // >> Task #10272 Pax2Sim - MUP Allocation C#9
                                                Prompt.SIM_LoadingForm scWindow,
                                                out VisualisationMode vmMode,
                                                out VisualisationMode vmModeHandlers)
        {
            ArrayList alResults = new ArrayList();
            ArrayList ListeObj;
            String sFPD = paParametres.FPD;
            String sFPA = paParametres.FPA;
            String sAircraftLinks = paParametres.AircraftLinksTable;
            String sOCT_CI = paParametres.OCT_CI_Table;
            String sOCT_BG = paParametres.OCT_BG;
            String sOCT_BC = paParametres.OCT_BC;
            String sOCT_Parking = "OCT_ParkingTable";
            String sOCT_MakeUp = paParametres.OCT_MakeUp;
            String sAirline = GlobalNames.FP_AirlineCodesTableName;
            int iStepAnalysis = (int)paParametres.SamplingStep;
            int iAnalysisRange = (int)paParametres.AnalysisRange;
            XmlNode Aeroport = structureAeroport;
            vmMode = null;
            vmModeHandlers = null;

            DataTable dtFPD = null;
            if (sFPD != "")
            {
                if (scWindow != null)
                    scWindow.ChargementFichier("Alloc_CITable");
                dtFPD = getTable("Input", sFPD);
                if (bUseAlphNumericForFlightInfo)
                    dtFPD = ConvertFPDInformations(dtFPD, structureAeroport, false, false);
                //Allocation des check in.
                ListeObj = MajTableFromTRV(Aeroport, "", "", 4);
                DataTable dtAllocCI = new DataTable("Alloc_CITable");
                dtAllocCI.Columns.Add("Time", typeof(DateTime));
                foreach (String sColumnName in ListeObj)
                    dtAllocCI.Columns.Add(sColumnName, typeof(String));

                OverallTools.UpdateAllocation.effectuerCalculAllocation(dtFPD,
                                              dtAllocCI,
                                              GetTable("Input", sOCT_CI),
                                              true,
                                              iStepAnalysis, GlobalNames.sFPD_A_Column_DATE,
                                              GlobalNames.sFPD_Column_STD,
                                              GlobalNames.sFPD_A_Column_FlightCategory,
                                              GlobalNames.sFPD_A_Column_ID,
                                              GlobalNames.sFPD_A_Column_AirlineCode,
                                              GlobalNames.sOCT_CI_Line_Opening,
                                              GlobalNames.sOCT_CI_Line_Closing,
                                              GlobalNames.sFPD_Column_TerminalCI, 
                                              true, 
                                              GlobalNames.sFPD_Column_FB_CI_Start,
                                              GlobalNames.sFPD_Column_FB_CI_End, 
                                              "Check In",
                                              GlobalNames.sFPD_Column_Eco_CI_Start,
                                              GlobalNames.sFPD_Column_Eco_CI_End,
                                              ListeErreurs);
                alResults.Add(dtAllocCI);


                if (scWindow != null)
                    scWindow.ChargementFichier("Boarding Gate Allocation");
                ListeObj = MajTableFromTRV(Aeroport, "", "", 5);
                DataTable dtAllocBoardingGate = new DataTable("Alloc_BoardGateTable");
                dtAllocBoardingGate.Columns.Add("Time", typeof(DateTime));
                foreach (String sColumnName in ListeObj)
                    dtAllocBoardingGate.Columns.Add(sColumnName, typeof(String));


                OverallTools.UpdateAllocation.effectuerCalculAllocation(dtFPD,
                                                dtAllocBoardingGate,
                                                GetTable("Input", sOCT_BG),
                                                true, iStepAnalysis, 
                                                GlobalNames.sFPD_A_Column_DATE, 
                                                GlobalNames.sFPD_Column_STD,
                                                GlobalNames.sFPD_A_Column_FlightCategory,
                                                GlobalNames.sFPD_A_Column_ID,
                                                GlobalNames.sFPD_A_Column_AirlineCode,
                                                GlobalNames.sOCT_Board_Line_Opening,
                                                GlobalNames.sOCT_Board_Line_Closing,
                                                GlobalNames.sFPD_A_Column_TerminalGate,
                                                false,
                                                GlobalNames.sFPD_Column_BoardingGate, 
                                                null, 
                                                GlobalNames.sFPD_Column_BoardingGate,
                                                null, 
                                                null, 
                                                ListeErreurs);
                alResults.Add(dtAllocBoardingGate);
                if (perimeter == PAX2SIM.EnumPerimetre.BHS)    // >> Task #10272 Pax2Sim - MUP Allocation C#9  //(paParametres.BHSSimulation)
                {
                    if (scWindow != null)
                        scWindow.ChargementFichier("Make-Up Allocation");
                    ListeObj = MajTableFromTRV(Aeroport, paParametres.iTerminal, 16);
                    DataTable dtAllocMakeUp = new DataTable(GestionDonneesHUB2SIM.PEAK_FLOWS_ALLOCATION_BHS_ALLOC_MUP_TABLE_NAME);//("Alloc_MakeUpTable_Airline");  // >> Task #10272 Pax2Sim - MUP Allocation C#9
                    dtAllocMakeUp.Columns.Add("Time", typeof(DateTime));
                    foreach (String sColumnName in ListeObj)
                        dtAllocMakeUp.Columns.Add(sColumnName, typeof(String));
                    OverallTools.UpdateAllocation.effectuerCalculAllocation(dtFPD,
                                                dtAllocMakeUp,
                                                this.getTable("Input", sOCT_MakeUp),
                                                null, paParametres.iTerminal, true, iStepAnalysis, GlobalNames.sFPD_A_Column_DATE, GlobalNames.sFPD_Column_STD, GlobalNames.sFPD_A_Column_FlightCategory,
                                                GlobalNames.sFPD_Column_TerminalMup, GlobalNames.sFPD_Column_Eco_Mup_End,
                                                GlobalNames.sFPD_Column_Eco_Mup_Start,
                                                GlobalNames.sFPD_Column_First_Mup_Start, GlobalNames.sFPD_Column_First_Mup_End,
                                                GlobalNames.sBHS_MakeUpObject, true, out vmMode, ListeErreurs);
                    alResults.Add(dtAllocMakeUp);
                    /*dtAllocMakeUp = new DataTable(GestionDonneesHUB2SIM.PEAK_FLOWS_ALLOCATION_HANDLERS_ALLOC_MUP_TABLE_NAME);//("Alloc_MakeUpTable_Handlers");  // >> Task #10272 Pax2Sim - MUP Allocation C#9
                    dtAllocMakeUp.Columns.Add("Time", typeof(DateTime));
                    foreach (String sColumnName in ListeObj)
                        dtAllocMakeUp.Columns.Add(sColumnName, typeof(String));
                    OverallTools.UpdateAllocation.effectuerCalculAllocation(dtFPD,
                                                dtAllocMakeUp,
                                                this.getTable("Input", sOCT_MakeUp),
                                                this.getTable("Input", sAirline),
                                                paParametres.iTerminal,
                                                true,
                                                iStepAnalysis, GlobalNames.sFPD_A_Column_DATE, GlobalNames.sFPD_Column_STD, GlobalNames.sFPD_A_Column_FlightCategory,
                                                GlobalNames.sFPD_Column_TerminalMup, GlobalNames.sFPD_Column_Eco_Mup_End,
                                                GlobalNames.sFPD_Column_Eco_Mup_Start,
                                                GlobalNames.sFPD_Column_First_Mup_Start, GlobalNames.sFPD_Column_First_Mup_End,
                                                GlobalNames.sBHS_MakeUpObject, false, out vmModeHandlers, ListeErreurs);
                    alResults.Add(dtAllocMakeUp);*/
                }
            }
            if (sFPA != "")
            {
                if (scWindow != null)
                    scWindow.ChargementFichier("Allocation Baggage Claim");
                DataTable dtFPA = this.getTable("Input", sFPA);
                if (bUseAlphNumericForFlightInfo)
                    dtFPA = ConvertFPAInformations(dtFPA, structureAeroport, false, false);
                ListeObj = MajTableFromTRV(Aeroport, "", "", 6);
                DataTable dtAllocBaggageClaim = new DataTable("Alloc_BaggageClaimTable");
                dtAllocBaggageClaim.Columns.Add("Time", typeof(DateTime));
                foreach (String sColumnName in ListeObj)
                    dtAllocBaggageClaim.Columns.Add(sColumnName, typeof(String));

                OverallTools.UpdateAllocation.effectuerCalculAllocation(dtFPA,
                                                dtAllocBaggageClaim,
                                                GetTable("Input", sOCT_BC),
                                                false, 
                                                iStepAnalysis,
                                                GlobalNames.sFPD_A_Column_DATE, 
                                                GlobalNames.sFPA_Column_STA,
                                                GlobalNames.sFPD_A_Column_FlightCategory,
                                                GlobalNames.sFPD_A_Column_ID,
                                                GlobalNames.sFPD_A_Column_AirlineCode,
                                                GlobalNames.sOCT_Baggage_Line_Opening,
                                                GlobalNames.sOCT_Baggage_Line_Closing,
                                                GlobalNames.sFPA_Column_TerminalReclaim, 
                                                false,
                                                GlobalNames.sFPA_Column_ReclaimObject,
                                                null, 
                                                "Baggage Claim",
                                                null, 
                                                null, 
                                                ListeErreurs);

                alResults.Add(dtAllocBaggageClaim);

                if (scWindow != null)
                    scWindow.ChargementFichier("Allocation Parking");
                ListeObj = MajTableFromTRV(Aeroport, "", "", 18);
                DataTable dtAllocParking = new DataTable("Alloc_ArrivalParkingTable");
                dtAllocParking.Columns.Add("Time", typeof(DateTime));
                DataTable dtAircraftLink = getTable("Input", sAircraftLinks);
                foreach (String sColumnName in ListeObj)
                    dtAllocParking.Columns.Add(sColumnName, typeof(String));
                OverallTools.UpdateAllocation.effectuerCalculParkingAllocation(dtFPD,
                                                dtFPA,
                                                dtAircraftLink,
                                                dtAllocParking,
                                                this.getTable("Input", sOCT_Parking),
                                                    true, false,
                                                iStepAnalysis, ListeErreurs);
                alResults.Add(dtAllocParking);
                if (dtFPD != null)
                {
                    dtAllocParking = new DataTable("Alloc_ParkingTable");
                    dtAllocParking.Columns.Add("Time", typeof(DateTime));
                    foreach (String sColumnName in ListeObj)
                        dtAllocParking.Columns.Add(sColumnName, typeof(String));
                    OverallTools.UpdateAllocation.effectuerCalculParkingAllocation(dtFPD,
                                                    dtFPA,
                                                    dtAircraftLink,
                                                    dtAllocParking,
                                                    this.getTable("Input", sOCT_Parking),
                                                    true, true,
                                                    iStepAnalysis, ListeErreurs);
                    alResults.Add(dtAllocParking);


                    dtAllocParking = new DataTable("Alloc_DepartureParkingTable");
                    dtAllocParking.Columns.Add("Time", typeof(DateTime));
                    foreach (String sColumnName in ListeObj)
                        dtAllocParking.Columns.Add(sColumnName, typeof(String));

                    OverallTools.UpdateAllocation.effectuerCalculParkingAllocation(dtFPD,
                                                    dtFPA,
                                                    dtAircraftLink,
                                                    dtAllocParking,
                                                    this.getTable("Input", sOCT_Parking),
                                                    false, true,
                                                    iStepAnalysis, ListeErreurs);
                    alResults.Add(dtAllocParking);
                }
                if ((bUseAlphNumericForFlightInfo) && (dtFPA != null))
                    dtFPA.Dispose();
            }
            if ((bUseAlphNumericForFlightInfo) && (dtFPD != null))
                dtFPD.Dispose();
            return alResults;
        }


        /// <summary>
        /// Function that will generate the statics results. The Departure / Arrival and Paxplan calculation.
        /// </summary>
        /// <param name="Scenario"></param>
        /// <param name="cht"></param>
        private Hashtable MAJ_tablesScenario(String Scenario,PAX2SIM.InsertPRKResultsDelegate InsertPRKResults, Prompt.SIM_LoadingForm cht,
            PAX2SIM.EnumPerimetre perimeter)    // >> Task #10272 Pax2Sim - MUP Allocation C#9
        {
            if(GetDataManager(Scenario) == null)
            {
                ListeErreurs.Add("Err00084 : This scenario does not exist.");
                return null;
            }
            Classes.ParamScenario parametres = GetScenario(Scenario);

            
            DataTable dtFPD = null;
            if ((parametres.FPD != null) && (parametres.FPD != ""))
            {
                dtFPD = getTable("Input", parametres.FPD);
                dtFPD = ConvertFPDInformations(dtFPD, structureAeroport, false, false);
            }
            DataTable dtFPA = null;
            if ((parametres.FPA != null) && (parametres.FPA != ""))
            {
                dtFPA = getTable("Input", parametres.FPA);
                dtFPA = ConvertFPAInformations(dtFPA, structureAeroport, false, false);
            }

            // >> Task #9936 Pax2Sim - project properties saved specifically for each scenario + Times stats Spec
            double[] percentileLevels = new double[3];
            if (parametres.percentilesLevels.Count == 3)
            {
                percentileLevels[0] = parametres.percentilesLevels[0];
                percentileLevels[1] = parametres.percentilesLevels[1];
                percentileLevels[2] = parametres.percentilesLevels[2];
            }
            else
            {
                percentileLevels[0] = Levels[0];
                percentileLevels[1] = Levels[1];
                percentileLevels[2] = Levels[2];
            }
            // << Task #9936 Pax2Sim - project properties saved specifically for each scenario + Times stats Spec
            
            // >> Task #17690 PAX2SIM - Flight Plan Parameters table
            List<FlightConfiguration> userDefinedFlightConfigurations = new List<FlightConfiguration>();
            if (parametres.FPParametersTableName != "")
            {
                userDefinedFlightConfigurations = Tools.FlightPlanParametersTools
                    .getFlightConfigurationsListFromFPParametersTable(getTable("Input", parametres.FPParametersTableName));
            }
            // << Task #17690 PAX2SIM - Flight Plan Parameters table
            //OverallTools.ExternFunctions.PrintLogFile("PeakFlowTest: Calculate Departure Peak start");
            bool bSupprTable = true;
            if (parametres.DeparturePeak)
            {
                if (cht != null)
                    cht.ChargementFichier("Calculate Departure Peak");

                ArrayList httmp = OverallTools.StaticAnalysis.CalcStaticAnalysisPerAirline(dtFPD,
                                                                             GetTable("Input", parametres.DepartureLoadFactors),
                                                                             GetTable("Input", parametres.AircraftType),
                                                                             GetTable("Input", parametres.CI_ShowUpTable),
                                                                             GetTable("Input", parametres.OCT_CI_Table),
                                                                             GetTable("Input", parametres.NbBags),
                                                                             GetTable("Input", parametres.NbVisitors),
                                                                             GetTable("Input", parametres.NbTrolley),                                                                             
                                                                             getTable("Input", parametres.FlightCategories),
                                                                             parametres.DateDebut,
                                                                             parametres.DateFin,
                                                                             parametres.SamplingStep,
                                                                             parametres.AnalysisRange,
                                                                             parametres.UseStatisticsStep,
                                                                             parametres.StatisticsStep,
                                                                             parametres.StatisticsStepMode,
                                                                             ListeErreurs,
                                                                             // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                                                                             parametres.UseDefinedNbPax,
                                                                             getTable("Input", parametres.NumberOfPassengers),
                                                                             parametres.UseDefinedNbBags,
                                                                             getTable("Input", parametres.NumberOfBaggages)
                                                                             // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                                                                             , percentileLevels,   // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                                                                             GetTable("Input", parametres.ICT_Table), userDefinedFlightConfigurations
                                                                             );
                ArrayList alTmp = OverallTools.StaticAnalysis.CalcStaticAnalysisPerTerminal(dtFPD,
                                                                             GetTable("Input", parametres.DepartureLoadFactors),
                                                                             GetTable("Input", parametres.AircraftType),
                                                                             GetTable("Input", parametres.CI_ShowUpTable),
                                                                             GetTable("Input", parametres.OCT_CI_Table),
                                                                             GetTable("Input", parametres.NbBags),
                                                                             GetTable("Input", parametres.NbVisitors),
                                                                             GetTable("Input", parametres.NbTrolley),                                                                             
                                                                             getTable("Input", parametres.FlightCategories),
                                                                             parametres.DateDebut,
                                                                             parametres.DateFin,
                                                                             parametres.SamplingStep,
                                                                             parametres.AnalysisRange,
                                                                             parametres.UseStatisticsStep,
                                                                             parametres.StatisticsStep,
                                                                             parametres.StatisticsStepMode,
                                                                             ListeErreurs,
                                                                             // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                                                                             parametres.UseDefinedNbPax,
                                                                             getTable("Input", parametres.NumberOfPassengers),
                                                                             parametres.UseDefinedNbBags,
                                                                             getTable("Input", parametres.NumberOfBaggages)
                                                                             // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                                                                             , percentileLevels,   // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                                                                             GetTable("Input", parametres.ICT_Table), userDefinedFlightConfigurations
                                                                             );
                if ((alTmp != null) && (httmp!=null))
                    httmp .AddRange(alTmp);
                alTmp = OverallTools.StaticAnalysis.CalcStaticAnalysisPerFlightCategory(dtFPD,
                                                                             GetTable("Input", parametres.DepartureLoadFactors),
                                                                             GetTable("Input", parametres.AircraftType),
                                                                             GetTable("Input", parametres.CI_ShowUpTable),
                                                                             GetTable("Input", parametres.OCT_CI_Table),
                                                                             GetTable("Input", parametres.NbBags),
                                                                             GetTable("Input", parametres.NbVisitors),
                                                                             GetTable("Input", parametres.NbTrolley),
                                                                             getTable("Input", parametres.FlightCategories),
                                                                             parametres.DateDebut,
                                                                             parametres.DateFin,
                                                                             parametres.SamplingStep,
                                                                             parametres.AnalysisRange,
                                                                             parametres.UseStatisticsStep,
                                                                             parametres.StatisticsStep,
                                                                             parametres.StatisticsStepMode,
                                                                             ListeErreurs,
                                                                             // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                                                                             parametres.UseDefinedNbPax,
                                                                             getTable("Input", parametres.NumberOfPassengers),
                                                                             parametres.UseDefinedNbBags,
                                                                             getTable("Input", parametres.NumberOfBaggages)
                                                                             // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                                                                             , percentileLevels,   // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                                                                             GetTable("Input", parametres.ICT_Table), userDefinedFlightConfigurations
                                                                             );
                if ((alTmp != null) && (httmp != null))
                    httmp.AddRange(alTmp);

                // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                alTmp = OverallTools.StaticAnalysis.CalcStaticAnalysisPerFlightSubcategory(dtFPD,
                                                                             GetTable("Input", parametres.DepartureLoadFactors),
                                                                             GetTable("Input", parametres.AircraftType),
                                                                             GetTable("Input", parametres.CI_ShowUpTable),
                                                                             GetTable("Input", parametres.OCT_CI_Table),
                                                                             GetTable("Input", parametres.NbBags),
                                                                             GetTable("Input", parametres.NbVisitors),
                                                                             GetTable("Input", parametres.NbTrolley),
                                                                             getTable("Input", parametres.FlightCategories),
                                                                            // getTable("Input", GlobalNames.flightSubcategoriesTableName),
                                                                             getTable("Input", parametres.FlightSubcategories),
                                                                             parametres.DateDebut,
                                                                             parametres.DateFin,
                                                                             parametres.SamplingStep,
                                                                             parametres.AnalysisRange,
                                                                             parametres.UseStatisticsStep,
                                                                             parametres.StatisticsStep,
                                                                             parametres.StatisticsStepMode,
                                                                             ListeErreurs,
                                                                             // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                                                                             parametres.UseDefinedNbPax,
                                                                             getTable("Input", parametres.NumberOfPassengers),
                                                                             parametres.UseDefinedNbBags,
                                                                             getTable("Input", parametres.NumberOfBaggages)
                                                                             // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                                                                             , percentileLevels,   // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                                                                             GetTable("Input", parametres.ICT_Table), userDefinedFlightConfigurations
                                                                             );
                if ((alTmp != null) && (httmp != null))
                    httmp.AddRange(alTmp);
                // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                //OverallTools.ExternFunctions.PrintLogFile("PeakFlowTest: Calculate EBS");
                #region //SGE-03/04/2012-Begin
                List<DataTable> ldtTmp = OverallTools.StaticAnalysis.CalcEBSNeeds(dtFPD,
                                                                             GetTable("Input", parametres.DepartureLoadFactors),
                                                                             GetTable("Input", parametres.AircraftType),
                                                                             GetTable("Input", parametres.CI_ShowUpTable),
                                                                             GetTable("Input", parametres.ICT_Table),   // << Task #9117 Pax2Sim - Static Analysis - FPD_EBS calculation - transfering pax missing
                                                                             GetTable("Input", parametres.OCT_CI_Table),
                                                                             GetTable("Input", parametres.NbBags),
                                                                             GetTable("Input", parametres.OCT_MakeUp),
                                                                             getTable("Input", parametres.ebsInputRateTableName),   // << Task #9260 Pax2Sim - Static Analysis - EBS algorithm - EBS per Terminal
                                                                             getTable("Input", parametres.ebsOutputRateTableName),  // << Task #9260 Pax2Sim - Static Analysis - EBS algorithm - EBS per Terminal
                                                                             getTable("Input", parametres.FlightCategories),
                                                                             parametres.DateDebut,
                                                                             parametres.DateFin,
                                                                             parametres.SamplingStep,
                                                                             parametres.AnalysisRange,
                                                                             parametres.UseStatisticsStep,
                                                                             parametres.StatisticsStep,
                                                                             parametres.StatisticsStepMode,
                                                                             ListeErreurs,
                                                                             parametres.Seed, // >> Bug #11859 PAx2Sim - Static analysis - EBS calculation FB exception
                                                                             userDefinedFlightConfigurations);
                 if ((ldtTmp != null) && (httmp != null))
                 {
                     httmp.AddRange(ldtTmp);
                     if (ldtTmp.Count > 0)
                     {
                         foreach (DataTable dtTable in httmp)
                         {
                             if (dtTable.TableName == "FPD_Peak_Stats")
                             {
                                 for (int i = 1; i < ldtTmp[0].Columns.Count; i++)
                                 {
                                     // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                                     OverallTools.DataFunctions.addNewStatisticsToStatisticTable(dtTable, ldtTmp[0], new int[1] { i }, percentileLevels);
                                     //OverallTools.DataFunctions.GetStatTable(dtTable, ldtTmp[0], new int[1] { i });
                                     // << Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                                 }
                                 //break;
                             }
                         }
                     }
                 }
                #endregion //SGE-03/04/2012-End
               

// >> Task #10069 Pax2Sim - no BNP development
                 if (PAX2SIM.usaMode)
                 {
                     // >> Task #9915 Pax2Sim - BNP development - Peak Flows - USA Standard directory
                     NormalTable departureLoadFactorsNT = GetTable("Input", parametres.DepartureLoadFactors);   // >> Task #10035 Pax2Sim - BNP development - Data Input tables
                     NormalTable aircraftTypeNT = GetTable("Input", parametres.AircraftType);                   // >> Task #10035 Pax2Sim - BNP development - Data Input tables
                     NormalTable nbBagsNT = GetTable("Input", parametres.NbBags);                               // >> Task #10035 Pax2Sim - BNP development - Data Input tables

                     alTmp = OverallTools.StaticAnalysis.calculateUSAStandardStaticAnalysisTables(httmp, parametres, dtFPD, departureLoadFactorsNT, aircraftTypeNT, nbBagsNT,
                         getTable("Input", parametres.FlightCategories), getTable("Input", parametres.FlightSubcategories),
                         getTable("Input", parametres.UsaStandardParamTableName), ListeErreurs,  // >> Task #9967 Pax2Sim - BNP development - Peak Flows - USA Standard parameters table
                         this); // >> Task #10346 Pax2Sim - EBS review
                     if (alTmp != null && httmp != null)
                         httmp.AddRange(alTmp);
                     // << Task #9915 Pax2Sim - BNP development - Peak Flows - USA Standard directory
                 }

                if (httmp != null)
                {

                    if (PAX2SIM.bShowAllocationTools)
                    {
                        //OverallTools.ExternFunctions.PrintLogFile("PeakFlowTest: CalcAllocationParkingDeparture FPD_AircraftMovements start");
                        DataTable dtResult = OverallTools.StaticAnalysis.CalcAllocationParkingDeparture("FPD_AircraftMovements",
                                                    dtFPD,
                                                                             GetTable("Input", parametres.DepartureLoadFactors),
                                                                             GetTable("Input", parametres.AircraftType),
                                                                             getTable("Input", parametres.FlightCategories),
                                                    parametres.DateDebut,
                                                    parametres.DateFin,
                                                    parametres.SamplingStep,
                                                    false,
                                                    userDefinedFlightConfigurations,
                                                    ListeErreurs);
                        httmp.Add(dtResult);
                        //OverallTools.ExternFunctions.PrintLogFile("PeakFlowTest: CalcAllocationParkingDeparture FPD_AircraftMovements end");
                    }
                    //<<Statistic tables
                    // added to calculate the statistics for FPD
                    int i;
                    DataTable Stat = OverallTools.StaticAnalysis.getDistribution(parametres.DateDebut,
                                                                      parametres.DateFin,
                                                                      dtFPD,
                                                                      null,
                                                                      getTable("Input", parametres.FlightCategories),
                                                                      GetTable("Input", parametres.AircraftType),
                                                                      GetTable("Input", parametres.DepartureLoadFactors),
                                                                      GetTable("Input", parametres.ArrivalLoadFactors),
                                                                      GetTable("Input", parametres.NbBags),
                                                                      GlobalNames.sFPD_A_Column_FlightCategory,
                                                                      userDefinedFlightConfigurations,
                                                                      out i,
                                                                      ListeErreurs);
                    if (Stat != null)
                    {
                        AddReplaceTable(Scenario, Stat);
                        VisualisationMode mode = StaticRapportVisualisationMode.Clone();
                        mode.ConditionnalFormatClass[0] = new ConditionnalFormatLine(getTable("Input", parametres.FlightCategories).Rows.Count + 1, Color.FromArgb(200, 255, 255), Color.FromArgb(255, 255, 180));
                        AddReplaceModeVisualisation(Scenario, Stat.TableName, mode);
                    }
                    int iNbAirline = 0;
                    Stat = OverallTools.StaticAnalysis.getDistribution(parametres.DateDebut,
                                                                      parametres.DateFin,
                                                                      dtFPD,
                                                                      null,
                                                                      getTable("Input", parametres.FlightCategories),
                                                                      GetTable("Input", parametres.AircraftType),
                                                                      GetTable("Input", parametres.DepartureLoadFactors),
                                                                      GetTable("Input", parametres.ArrivalLoadFactors),
                                                                      GetTable("Input", parametres.NbBags),
                                                                      GlobalNames.sFPD_A_Column_AirlineCode,
                                                                      userDefinedFlightConfigurations,
                                                                      out iNbAirline,
                                                                      ListeErreurs);
                    if (Stat != null)
                    {
                        AddReplaceTable(Scenario, Stat);
                        VisualisationMode mode = StaticRapportVisualisationMode.Clone();
                        mode.ConditionnalFormatClass[0] = new ConditionnalFormatLine(iNbAirline + 1, Color.FromArgb(200, 255, 255), Color.FromArgb(255, 255, 180));
                        AddReplaceModeVisualisation(Scenario, Stat.TableName, mode);

                        int iNbHandling;
                        Stat = OverallTools.StaticAnalysis.getHandlingAgentDistribution(Stat, getTable("Input", parametres.Airline), out iNbHandling, ListeErreurs);
                        if (Stat != null)
                        {
                            AddReplaceTable(Scenario, Stat);
                            mode = StaticRapportVisualisationMode.Clone();
                            mode.ConditionnalFormatClass[0] = new ConditionnalFormatLine(iNbHandling, Color.FromArgb(200, 255, 255), Color.FromArgb(255, 255, 180));
                            AddReplaceModeVisualisation(Scenario, Stat.TableName, mode);
                        }

                    }
                    //>>Statistic tables
                    foreach (DataTable dtResults in httmp)
                    {
                        AddReplaceTable(Scenario, dtResults);

                        if (modeVisualisation.ContainsKey(dtResults.TableName))
                            AddReplaceModeVisualisation(Scenario, dtResults.TableName, (VisualisationMode)modeVisualisation[dtResults.TableName]);
                        if (dtResults.TableName == "FPD_Peak_Stats")
                            AddReplaceModeVisualisation(Scenario, "FPD_Peak_Stats", StaticRapportVisualisationMode);
                        else if (dtResults.TableName.StartsWith(EbsStatisticsGenerator.GLOBAL_EBS_SUMMARY_TABLE_NAME))  // >> Task #9171 Pax2Sim - Static Analysis - EBS algorithm - Throughputs C#5
                        {
                            AddReplaceModeVisualisation(Scenario, dtResults.TableName, StaticRapportVisualisationMode);
                        }
                        else if (getGraphicFilter(Scenario, dtResults.TableName) == null)
                            AddGraphicFilter(Scenario, GraphicFilter.getStaticGraphicFilter(dtResults, dtResults.TableName.Contains("Rolling")));
                    }
                    bSupprTable = false;
                }
            }
            if (bSupprTable)
            {
                foreach (String sName in StaticResultsFPD)
                {
                    RemoveTable(Scenario, sName);
                }
            }
            bSupprTable = true;
            if (parametres.ArrivalPeak)
            {
                //OverallTools.ExternFunctions.PrintLogFile("PeakFlowTest: CalcACalculate Arrival Peak start");
                if (cht != null)
                    cht.ChargementFichier("Calculate Arrival Peak");
                //ArrayList alTmp = new ArrayList();
                //ArrayList alTmp2 = new ArrayList();
                
                ArrayList alTmp = OverallTools.StaticAnalysis.CalcStaticArrivalAnalysisPerAirline(
                                                   dtFPA,
                                                   GetTable("Input", parametres.ArrivalLoadFactors),
                                                   GetTable("Input", parametres.AircraftType),
                                                   GetTable("Input", parametres.NbBags),
                                                   GetTable("Input", parametres.NbVisitors),
                                                   GetTable("Input", parametres.NbTrolley),
                                                   GetTable("Input", parametres.ICT_Table),
                                                   // << Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay
                                                   GetTable("Input", parametres.arrivalBaggageLoadingRateTableName),
                                                   GetTable("Input", parametres.arrivalBaggageLoadingDelayTableName),
                                                   // >> Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay
                                                   getTable("Input", parametres.FlightCategories),
                                                   parametres.DateDebut,
                                                   parametres.DateFin,
                                                   parametres.SamplingStep,
                                                   parametres.AnalysisRange,
                                                   ListeErreurs,
                                                   this,   // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                                   // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                                                   parametres.UseDefinedNbPax,
                                                   getTable("Input", parametres.NumberOfPassengers),
                                                   parametres.UseDefinedNbBags,
                                                   getTable("Input", parametres.NumberOfBaggages)
                                                   // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                                                   , percentileLevels, userDefinedFlightConfigurations // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                                                   );
                ArrayList alTmp2 = OverallTools.StaticAnalysis.CalcStaticArrivalAnalysisPerTerminal(
                                                   dtFPA,
                                                   GetTable("Input", parametres.ArrivalLoadFactors),
                                                   GetTable("Input", parametres.AircraftType),
                                                   GetTable("Input", parametres.NbBags),
                                                   GetTable("Input", parametres.NbVisitors),
                                                   GetTable("Input", parametres.NbTrolley),
                                                   GetTable("Input", parametres.ICT_Table),
                    // << Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay
                                                   GetTable("Input", parametres.arrivalBaggageLoadingRateTableName),
                                                   GetTable("Input", parametres.arrivalBaggageLoadingDelayTableName),
                    // >> Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay
                                                   getTable("Input", parametres.FlightCategories),
                                                   parametres.DateDebut,
                                                   parametres.DateFin,
                                                   parametres.SamplingStep,
                                                   parametres.AnalysisRange,
                                                   ListeErreurs,
                                                   this,   // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                                   // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                                                   parametres.UseDefinedNbPax,
                                                   getTable("Input", parametres.NumberOfPassengers),
                                                   parametres.UseDefinedNbBags,
                                                   getTable("Input", parametres.NumberOfBaggages)
                                                   // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                                                   , percentileLevels, userDefinedFlightConfigurations // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                                                   );
                if ((alTmp2 != null) && (alTmp != null))
                    alTmp.AddRange(alTmp2);
                alTmp2 = OverallTools.StaticAnalysis.CalcStaticArrivalAnalysisPerFlightCategory(
                                                   dtFPA,
                                                   GetTable("Input", parametres.ArrivalLoadFactors),
                                                   GetTable("Input", parametres.AircraftType),
                                                   GetTable("Input", parametres.NbBags),
                                                   GetTable("Input", parametres.NbVisitors),
                                                   GetTable("Input", parametres.NbTrolley),
                                                   GetTable("Input", parametres.ICT_Table),
                                                   // << Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay
                                                   GetTable("Input", parametres.arrivalBaggageLoadingRateTableName),
                                                   GetTable("Input", parametres.arrivalBaggageLoadingDelayTableName),
                                                   // >> Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay
                                                   getTable("Input", parametres.FlightCategories),
                                                   parametres.DateDebut,
                                                   parametres.DateFin,
                                                   parametres.SamplingStep,
                                                   parametres.AnalysisRange,
                                                   ListeErreurs,
                                                   this,   // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                                   // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                                                   parametres.UseDefinedNbPax,
                                                   getTable("Input", parametres.NumberOfPassengers),
                                                   parametres.UseDefinedNbBags,
                                                   getTable("Input", parametres.NumberOfBaggages)
                                                   // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                                                   , percentileLevels, userDefinedFlightConfigurations // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                                                   );
                if ((alTmp2 != null) && (alTmp != null))
                    alTmp.AddRange(alTmp2);

                // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                alTmp2 = OverallTools.StaticAnalysis.CalcStaticArrivalAnalysisPerFlightSubcategory(
                                                   dtFPA,
                                                   GetTable("Input", parametres.ArrivalLoadFactors),
                                                   GetTable("Input", parametres.AircraftType),
                                                   GetTable("Input", parametres.NbBags),
                                                   GetTable("Input", parametres.NbVisitors),
                                                   GetTable("Input", parametres.NbTrolley),
                                                   GetTable("Input", parametres.ICT_Table),
                                                   // << Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay
                                                   GetTable("Input", parametres.arrivalBaggageLoadingRateTableName),
                                                   GetTable("Input", parametres.arrivalBaggageLoadingDelayTableName),
                                                   // >> Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay
                                                   getTable("Input", parametres.FlightCategories),
                                                   getTable("Input", parametres.FlightSubcategories),   //getTable("Input", GlobalNames.flightSubcategoriesTableName),
                                                   parametres.DateDebut,
                                                   parametres.DateFin,
                                                   parametres.SamplingStep,
                                                   parametres.AnalysisRange,
                                                   ListeErreurs,
                                                   this,   // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                                   // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                                                   parametres.UseDefinedNbPax,
                                                   getTable("Input", parametres.NumberOfPassengers),
                                                   parametres.UseDefinedNbBags,
                                                   getTable("Input", parametres.NumberOfBaggages)
                                                   // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                                                   , percentileLevels, userDefinedFlightConfigurations // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                                                   );
                if ((alTmp2 != null) && (alTmp != null))
                    alTmp.AddRange(alTmp2);
                // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                
                if (alTmp != null)
                {

                    if ((PAX2SIM.bShowAllocationTools) && (parametres.ArrivalPeak))
                    {
                        //OverallTools.ExternFunctions.PrintLogFile("PeakFlowTest: FPA_AircraftMovements start");
                        DataTable dtResult = OverallTools.StaticAnalysis.CalcAllocationParkingDeparture("FPA_AircraftMovements",
                                                    dtFPA,
                                                                             GetTable("Input", parametres.ArrivalLoadFactors),
                                                                             GetTable("Input", parametres.AircraftType),
                                                                             getTable("Input", parametres.FlightCategories),
                                                    parametres.DateDebut,
                                                    parametres.DateFin,
                                                    parametres.SamplingStep,
                                                    true,
                                                    userDefinedFlightConfigurations,
                                                    ListeErreurs);
                        alTmp.Add(dtResult);
                        //OverallTools.ExternFunctions.PrintLogFile("PeakFlowTest: FPA_AircraftMovements end");
                    }
                    //<<Statistic tables
                    // added to calculate the statistics for FPA
                    int i;
                    DataTable Stat = OverallTools.StaticAnalysis.getDistribution(parametres.DateDebut,
                                                                      parametres.DateFin,
                                                                      null,
                                                                      dtFPA,
                                                                      getTable("Input", parametres.FlightCategories),
                                                                      GetTable("Input", parametres.AircraftType),
                                                                      GetTable("Input", parametres.DepartureLoadFactors),
                                                                      GetTable("Input", parametres.ArrivalLoadFactors),
                                                                      GetTable("Input", parametres.NbBags),
                                                                      GlobalNames.sFPD_A_Column_FlightCategory,
                                                                      userDefinedFlightConfigurations,
                                                                      out i,
                                                                      ListeErreurs);
                    if (Stat != null)
                    {
                        AddReplaceTable(Scenario, Stat);
                        VisualisationMode mode = StaticRapportVisualisationMode.Clone();
                        mode.ConditionnalFormatClass[0] = new ConditionnalFormatLine(getTable("Input", parametres.FlightCategories).Rows.Count + 1, Color.FromArgb(200, 255, 255), Color.FromArgb(255, 255, 180));
                        AddReplaceModeVisualisation(Scenario, Stat.TableName, mode);
                    }
                    int iNbAirline = 0;
                    Stat = OverallTools.StaticAnalysis.getDistribution(parametres.DateDebut,
                                                                      parametres.DateFin,
                                                                      null,
                                                                      dtFPA,
                                                                      getTable("Input", parametres.FlightCategories),
                                                                      GetTable("Input", parametres.AircraftType),
                                                                      GetTable("Input", parametres.DepartureLoadFactors),
                                                                      GetTable("Input", parametres.ArrivalLoadFactors),
                                                                      GetTable("Input", parametres.NbBags),
                                                                      GlobalNames.sFPD_A_Column_AirlineCode,
                                                                      userDefinedFlightConfigurations,
                                                                      out iNbAirline,
                                                                      ListeErreurs);
                    if (Stat != null)
                    {
                        AddReplaceTable(Scenario, Stat);
                        VisualisationMode mode = StaticRapportVisualisationMode.Clone();
                        mode.ConditionnalFormatClass[0] = new ConditionnalFormatLine(iNbAirline + 1, Color.FromArgb(200, 255, 255), Color.FromArgb(255, 255, 180));
                        AddReplaceModeVisualisation(Scenario, Stat.TableName, mode);

                        int iNbHandling;
                        Stat = OverallTools.StaticAnalysis.getHandlingAgentDistribution(Stat, getTable("Input", parametres.Airline), out iNbHandling, ListeErreurs);
                        if (Stat != null)
                        {
                            AddReplaceTable(Scenario, Stat);
                            mode = StaticRapportVisualisationMode.Clone();
                            mode.ConditionnalFormatClass[0] = new ConditionnalFormatLine(iNbHandling, Color.FromArgb(200, 255, 255), Color.FromArgb(255, 255, 180));
                            AddReplaceModeVisualisation(Scenario, Stat.TableName, mode);
                        }

                    }
                    //>>Statistic tables
                    foreach (DataTable dtResults in alTmp)
                    {
                        if (dtResults == null)
                            continue;
                        AddReplaceTable(Scenario, dtResults);

                        if (modeVisualisation.ContainsKey(dtResults.TableName))
                            AddReplaceModeVisualisation(Scenario, dtResults.TableName, (VisualisationMode)modeVisualisation[dtResults.TableName]);
                        if (dtResults.TableName == "FPA_Peak_Stats")
                            AddReplaceModeVisualisation(Scenario, "FPA_Peak_Stats", StaticRapportVisualisationMode);
                        else if (dtResults.TableName == GlobalNames.fpaPeakStatsBHSTableName)   // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                            AddReplaceModeVisualisation(Scenario, GlobalNames.fpaPeakStatsBHSTableName, StaticRapportVisualisationMode);
                        else if (getGraphicFilter(Scenario, dtResults.TableName) == null)
                            AddGraphicFilter(Scenario, GraphicFilter.getStaticGraphicFilter(dtResults, dtResults.TableName.Contains("Rolling")));
                    }
                    bSupprTable = false;
                }
            }
            if (bSupprTable)
            {
                foreach (String sName in StaticResultsFPA)
                {
                    RemoveTable(Scenario, sName);
                }
            }
            bSupprTable = true;
            if ((parametres.DeparturePeak) && (parametres.ArrivalPeak))
            {
                //OverallTools.ExternFunctions.PrintLogFile("PeakFlowTest: Arr + Dep start");
                DataTable Stats = null;
                DataTable FPD_PaxGateFlow = getTable(Scenario, "FPD_OutBoundRolling");
                DataTable FPA_PaxGateFlow = getTable(Scenario, "FPA_InBoundRolling");
                DataTable FPD_AircraftMovement = getTable(Scenario, "FPD_AircraftMovementsRolling");
                DataTable FPA_AircraftMovement = getTable(Scenario, "FPA_AircraftMovementsRolling");

                if ((FPD_PaxGateFlow != null) && (FPA_PaxGateFlow != null) &&
                    ((FPD_PaxGateFlow.Rows.Count > 1) && (FPD_PaxGateFlow.Rows.Count > 1)))
                {

                    DataTable Sum_Arrival_Departure = FPD_PaxGateFlow.Copy();
                    Sum_Arrival_Departure.TableName = "FPDFPA_InOutBoundRolling";
                    Sum_Arrival_Departure.Columns.Remove("Originating Bags / h");   // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    Sum_Arrival_Departure.Columns.Remove("Originating Bags");   // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    Sum_Arrival_Departure.Columns.Remove("Transferring Bags / h");  // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    Sum_Arrival_Departure.Columns.Remove("Transferring Bags");  // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    Sum_Arrival_Departure.Columns.Remove("Transferring PAX / h");   // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    Sum_Arrival_Departure.Columns.Remove("Transferring PAX");   // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    Sum_Arrival_Departure.Columns["Total PAX / h"].ColumnName = "Nb PAX Total / h";             // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    Sum_Arrival_Departure.Columns["Total PAX"].ColumnName = "Nb PAX Total";             // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    Sum_Arrival_Departure.Columns["Originating PAX / h"].ColumnName = "Nb PAX Originating / h"; // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    Sum_Arrival_Departure.Columns["Originating PAX"].ColumnName = "Nb PAX Originating"; // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    Sum_Arrival_Departure.Columns["Total Bags / h"].ColumnName = "Nb Bags Total / h";           // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    Sum_Arrival_Departure.Columns["Total Bags"].ColumnName = "Nb Bags Total";           // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                    OverallTools.DataFunctions.ConcateneTable(Sum_Arrival_Departure, FPD_PaxGateFlow,
                        new String[] { "Total PAX", "Total Bags", "Total PAX / h", "Total Bags / h" }, "FPD_");     // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns                    

                    OverallTools.DataFunctions.ConcateneTable(Sum_Arrival_Departure, FPA_PaxGateFlow,
                        new String[] { "Total PAX", "Terminating PAX", "Total Bags", "Total PAX / h", "Terminating PAX / h", "Total Bags / h" }, "FPA_");  // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                    Sum_Arrival_Departure.Columns["FPA_Total PAX / h"].ColumnName = "Nb PAX Inbound / h";   // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    Sum_Arrival_Departure.Columns["FPA_Total PAX"].ColumnName = "Nb PAX Inbound";   // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    
                    Sum_Arrival_Departure.Columns["FPA_Terminating PAX / h"].ColumnName = "Nb PAX Terminating / h"; // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    Sum_Arrival_Departure.Columns["FPA_Terminating PAX"].ColumnName = "Nb PAX Terminating"; // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                    Sum_Arrival_Departure.Columns["FPD_Total PAX / h"].ColumnName = "Nb PAX Outbound / h";  // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    Sum_Arrival_Departure.Columns["FPD_Total PAX"].ColumnName = "Nb PAX Outbound";  // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                    OverallTools.DataFunctions.SumColumns(Sum_Arrival_Departure, new String[] { "Nb PAX Inbound", "Nb PAX Originating" }, "Nb PAX Total");  // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    OverallTools.DataFunctions.SumColumns(Sum_Arrival_Departure, new String[] { "Nb PAX Inbound / h", "Nb PAX Originating / h" }, "Nb PAX Total / h");  // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                    OverallTools.DataFunctions.SumColumns(Sum_Arrival_Departure, new String[] { "FPA_Total Bags", "FPD_Total Bags" }, "Nb Bags Total"); // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    OverallTools.DataFunctions.SumColumns(Sum_Arrival_Departure, new String[] { "FPA_Total Bags / h", "FPD_Total Bags / h" }, "Nb Bags Total / h"); // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                    Sum_Arrival_Departure.Columns.Remove("FPD_Total Bags / h"); // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    Sum_Arrival_Departure.Columns.Remove("FPD_Total Bags"); // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                    Sum_Arrival_Departure.Columns.Remove("FPA_Total Bags / h"); // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    Sum_Arrival_Departure.Columns.Remove("FPA_Total Bags"); // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                    OverallTools.DataFunctions.SortColumns(Sum_Arrival_Departure,
                        new String[] { "Time", "Nb PAX Total", "Nb PAX Total / h", "Nb Bags Total", "Nb Bags Total / h",
                            "Nb PAX Originating", "Nb PAX Originating / h", "Nb PAX Terminating", "Nb PAX Terminating / h",
                            "Nb PAX Outbound", "Nb PAX Outbound / h", "Nb PAX Inbound", "Nb PAX Inbound / h" });   // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    AddReplaceTable(Scenario, Sum_Arrival_Departure);
                    AddGraphicFilter(Scenario, GraphicFilter.getStaticGraphicFilter(Sum_Arrival_Departure, true));
                    
                    // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                    Stats = OverallTools.DataFunctions.getStatisticTable(Sum_Arrival_Departure,
                        new int[12] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 }, percentileLevels);
/*
                    Stats = OverallTools.DataFunctions.GetStatTable(Sum_Arrival_Departure,
                        new int[12] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 });    // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
*/
                    // << Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                    Stats.TableName = "FPDFPA_PeakStats";
                }
                if ((FPD_AircraftMovement != null) && (FPA_AircraftMovement != null) &&
                    ((FPD_PaxGateFlow.Rows.Count > 1) && (FPD_PaxGateFlow.Rows.Count > 1)))
                {
                    DataTable Sum_Arrival_Departure = FPD_AircraftMovement.Copy();
                    Sum_Arrival_Departure.TableName = "FPDFPA_AircraftMovementsRolling";
                    Sum_Arrival_Departure.Columns.RemoveAt(2);
                    Sum_Arrival_Departure.Columns[1].ColumnName = "Total Nb Flights";
                    OverallTools.DataFunctions.ConcateneTable(Sum_Arrival_Departure, FPD_AircraftMovement, new int[] { 1, 2 }, "FPD_");
                    OverallTools.DataFunctions.ConcateneTable(Sum_Arrival_Departure, FPA_AircraftMovement, new int[] { 1, 2 }, "FPA_");
                    Sum_Arrival_Departure.Columns[2].ColumnName = "Nb Flights FPD";
                    Sum_Arrival_Departure.Columns[4].ColumnName = "Nb Flights FPA";
                    Sum_Arrival_Departure.Columns[5].ColumnName = "Nb Flights / h";
                    OverallTools.DataFunctions.SumColumns(Sum_Arrival_Departure, new String[] { "Nb Flights FPD", "Nb Flights FPA" }, "Total Nb Flights");
                    OverallTools.DataFunctions.SumColumns(Sum_Arrival_Departure, new String[] { "FPD_Nb Flights / h", "Nb Flights / h" }, "Nb Flights / h");

                    Sum_Arrival_Departure.Columns.RemoveAt(3);
                    //Sum_Arrival_Departure.Columns.RemoveAt(4);
                    AddReplaceTable(Scenario, Sum_Arrival_Departure);
                    AddGraphicFilter(Scenario, GraphicFilter.getStaticGraphicFilter(Sum_Arrival_Departure, true));
                    
                    // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                    OverallTools.DataFunctions.addNewStatisticsToStatisticTable(Stats, Sum_Arrival_Departure, new int[] { 1, 2, 3 }, percentileLevels);
                    //OverallTools.DataFunctions.GetStatTable(Stats, Sum_Arrival_Departure, new int[] { 1, 2, 3 });
                    // << Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics                    
                }

                FPD_PaxGateFlow = getTable(Scenario, "FPD_OutBoundInstantaneous");
                FPA_PaxGateFlow = getTable(Scenario, "FPA_InBoundInstantaneous");
                FPD_AircraftMovement = getTable(Scenario, "FPD_AircraftMovementsInstantaneous");
                FPA_AircraftMovement = getTable(Scenario, "FPA_AircraftMovementsInstantaneous");

                if ((FPD_PaxGateFlow != null) && (FPA_PaxGateFlow != null) &&
                    ((FPD_PaxGateFlow.Rows.Count > 1) && (FPD_PaxGateFlow.Rows.Count > 1)))
                {

                    DataTable Sum_Arrival_Departure = FPD_PaxGateFlow.Copy();
                    Sum_Arrival_Departure.TableName = "FPDFPA_InOutBoundInstantaneous";
                    Sum_Arrival_Departure.Columns.Remove("Originating Bags / h");   // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    Sum_Arrival_Departure.Columns.Remove("Transferring Bags / h");  // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    Sum_Arrival_Departure.Columns.Remove("Transferring PAX / h");   // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                    Sum_Arrival_Departure.Columns.Remove("Originating Bags");   // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    Sum_Arrival_Departure.Columns.Remove("Transferring Bags");  // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    Sum_Arrival_Departure.Columns.Remove("Transferring PAX");   // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                    Sum_Arrival_Departure.Columns["Total PAX / h"].ColumnName = "Nb PAX Total / h"; // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    Sum_Arrival_Departure.Columns["Originating PAX / h"].ColumnName = "Nb PAX Originating / h"; // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    Sum_Arrival_Departure.Columns["Total Bags / h"].ColumnName = "Nb Bags Total / h";       // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                    Sum_Arrival_Departure.Columns["Total PAX"].ColumnName = "Nb PAX Total";             // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    Sum_Arrival_Departure.Columns["Originating PAX"].ColumnName = "Nb PAX Originating"; // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    Sum_Arrival_Departure.Columns["Total Bags"].ColumnName = "Nb Bags Total";           // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                    OverallTools.DataFunctions.ConcateneTable(Sum_Arrival_Departure, FPD_PaxGateFlow,
                        new String[] { "Total PAX / h", "Total Bags / h", "Total PAX", "Total Bags" }, "FPD_");  // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    OverallTools.DataFunctions.ConcateneTable(Sum_Arrival_Departure, FPA_PaxGateFlow,
                        new String[] { "Total PAX / h", "Terminating PAX / h", "Total Bags / h", "Total PAX", "Terminating PAX", "Total Bags" }, "FPA_");   // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    
                    Sum_Arrival_Departure.Columns["FPA_Total PAX / h"].ColumnName = "Nb PAX Inbound / h";   // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    Sum_Arrival_Departure.Columns["FPA_Terminating PAX / h"].ColumnName = "Nb PAX Terminating / h"; // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    Sum_Arrival_Departure.Columns["FPD_Total PAX / h"].ColumnName = "Nb PAX Outbound / h";      // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                    Sum_Arrival_Departure.Columns["FPA_Total PAX"].ColumnName = "Nb PAX Inbound";           // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    Sum_Arrival_Departure.Columns["FPA_Terminating PAX"].ColumnName = "Nb PAX Terminating"; // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    Sum_Arrival_Departure.Columns["FPD_Total PAX"].ColumnName = "Nb PAX Outbound";          // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                    OverallTools.DataFunctions.SumColumns(Sum_Arrival_Departure, new String[] { "Nb PAX Inbound / h", "Nb PAX Originating / h" }, "Nb PAX Total / h");  // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    OverallTools.DataFunctions.SumColumns(Sum_Arrival_Departure, new String[] { "FPA_Total Bags / h", "FPD_Total Bags / h" }, "Nb Bags Total / h"); // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                    OverallTools.DataFunctions.SumColumns(Sum_Arrival_Departure, new String[] { "Nb PAX Inbound", "Nb PAX Originating" }, "Nb PAX Total");  // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    OverallTools.DataFunctions.SumColumns(Sum_Arrival_Departure, new String[] { "FPA_Total Bags", "FPD_Total Bags" }, "Nb Bags Total");     // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                                        
                    Sum_Arrival_Departure.Columns.Remove("FPD_Total Bags / h"); // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    Sum_Arrival_Departure.Columns.Remove("FPA_Total Bags / h"); // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                    Sum_Arrival_Departure.Columns.Remove("FPD_Total Bags"); // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    Sum_Arrival_Departure.Columns.Remove("FPA_Total Bags"); // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                    OverallTools.DataFunctions.SortColumns(Sum_Arrival_Departure,
                        new String[] { "Time", "Nb PAX Total", "Nb PAX Total / h", "Nb Bags Total", "Nb Bags Total / h",
                            "Nb PAX Originating", "Nb PAX Originating / h", "Nb PAX Terminating", "Nb PAX Terminating / h",
                            "Nb PAX Outbound", "Nb PAX Outbound / h", "Nb PAX Inbound", "Nb PAX Inbound / h" });   // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    AddReplaceTable(Scenario, Sum_Arrival_Departure);
                    AddGraphicFilter(Scenario, GraphicFilter.getStaticGraphicFilter(Sum_Arrival_Departure, false));
                    
                    // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                    //OverallTools.DataFunctions.addNewStatisticsToStatisticTable(Stats, Sum_Arrival_Departure, new int[12] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 }, percentileLevels);
                    //OverallTools.DataFunctions.GetStatTable(Stats, Sum_Arrival_Departure, new int[12] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 });
                    // << Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                }

                if ((FPD_AircraftMovement != null) && (FPA_AircraftMovement != null) &&
                    ((FPD_PaxGateFlow.Rows.Count > 1) && (FPD_PaxGateFlow.Rows.Count > 1)))
                {
                    DataTable Sum_Arrival_Departure = FPD_AircraftMovement.Copy();
                    Sum_Arrival_Departure.TableName = "FPDFPA_AircraftMovementsInstantaneous";
                    Sum_Arrival_Departure.Columns.RemoveAt(2);
                    Sum_Arrival_Departure.Columns[1].ColumnName = "Total Nb Flights";
                    OverallTools.DataFunctions.ConcateneTable(Sum_Arrival_Departure, FPD_AircraftMovement, new int[] { 1, 2 }, "FPD_");
                    OverallTools.DataFunctions.ConcateneTable(Sum_Arrival_Departure, FPA_AircraftMovement, new int[] { 1, 2 }, "FPA_");
                    Sum_Arrival_Departure.Columns[2].ColumnName = "Nb Flights FPD";
                    Sum_Arrival_Departure.Columns[4].ColumnName = "Nb Flights FPA";
                    Sum_Arrival_Departure.Columns[5].ColumnName = "Nb Flights / h";
                    OverallTools.DataFunctions.SumColumns(Sum_Arrival_Departure, new String[] { "Nb Flights FPD", "Nb Flights FPA" }, "Total Nb Flights");
                    OverallTools.DataFunctions.SumColumns(Sum_Arrival_Departure, new String[] { "FPD_Nb Flights / h", "Nb Flights / h" }, "Nb Flights / h");
                    Sum_Arrival_Departure.Columns.RemoveAt(3);
                    AddReplaceTable(Scenario, Sum_Arrival_Departure);
                    AddGraphicFilter(Scenario, GraphicFilter.getStaticGraphicFilter(Sum_Arrival_Departure, true));
                    // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                    //OverallTools.DataFunctions.addNewStatisticsToStatisticTable(Stats, Sum_Arrival_Departure, new int[] { 1, 2, 3 }, percentileLevels);
                    //OverallTools.DataFunctions.GetStatTable(Stats, Sum_Arrival_Departure, new int[] { 1, 2, 3 });
                    // << Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics                    
                }

                DataTable FPD_CheckInShowUpFlow = getTable(Scenario, "FPD_CheckInShowUpRolling");
                DataTable FPA_TransferICTFlow = getTable(Scenario, "FPA_TransferICTRolling");
                if ((FPD_CheckInShowUpFlow != null) && (FPA_TransferICTFlow != null) &&
                    (FPD_CheckInShowUpFlow.Rows.Count > 0) && (FPA_TransferICTFlow.Rows.Count > 0))
                {
                    // >> Task #9108 Pax2Sim - Static Analysis - FPD+FPA split table
                    #region PAX Boarding room Smoothed flows
                    DataTable paxBoardingRoomSmoothedFlowsTable = FPA_TransferICTFlow.Copy();
                    paxBoardingRoomSmoothedFlowsTable.TableName = GlobalNames.paxBoardingRoomSmoothedFlowsTableName;

                    paxBoardingRoomSmoothedFlowsTable.Columns.Remove("Nb Bags");
                    paxBoardingRoomSmoothedFlowsTable.Columns.Remove("Nb Bags / h");

                    paxBoardingRoomSmoothedFlowsTable.Columns["Nb Pax"].ColumnName = "Departing Pax";
                    paxBoardingRoomSmoothedFlowsTable.Columns["Nb Pax / h"].ColumnName = "Departing Pax / h";

                    OverallTools.DataFunctions.ConcateneTable(paxBoardingRoomSmoothedFlowsTable, FPD_CheckInShowUpFlow,
                        new String[] { "Passengers", "Passengers / h" }, "FPD_");
                    OverallTools.DataFunctions.ConcateneTable(paxBoardingRoomSmoothedFlowsTable, FPA_TransferICTFlow,
                        new String[] { "Nb Pax", "Nb Pax / h" }, "FPA_");

                    paxBoardingRoomSmoothedFlowsTable.Columns["FPD_Passengers"].ColumnName = "Originating Pax";
                    paxBoardingRoomSmoothedFlowsTable.Columns["FPD_Passengers / h"].ColumnName = "Originating Pax / h";
                    paxBoardingRoomSmoothedFlowsTable.Columns["FPA_Nb Pax"].ColumnName = "Transfering ICT Pax";
                    paxBoardingRoomSmoothedFlowsTable.Columns["FPA_Nb Pax / h"].ColumnName = "Transfering ICT Pax / h";

                    OverallTools.DataFunctions.SumColumns(paxBoardingRoomSmoothedFlowsTable,
                        new String[] { "Originating Pax", "Transfering ICT Pax" }, "Departing Pax");
                    OverallTools.DataFunctions.SumColumns(paxBoardingRoomSmoothedFlowsTable,
                        new String[] { "Originating Pax / h", "Transfering ICT Pax / h" }, "Departing Pax / h");
                    
                    AddReplaceTable(Scenario, paxBoardingRoomSmoothedFlowsTable);
                    AddGraphicFilter(Scenario, GraphicFilter.getStaticGraphicFilter(paxBoardingRoomSmoothedFlowsTable, true));

                    // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics                    
                    OverallTools.DataFunctions.addNewStatisticsToStatisticTable(Stats, paxBoardingRoomSmoothedFlowsTable,
                        new int[] { 1, 2, 3, 4, 5, 6 }, percentileLevels);
                    /*OverallTools.DataFunctions.GetStatTable(Stats, paxBoardingRoomSmoothedFlowsTable,
                        new int[] { 1, 2, 3, 4, 5, 6 });*/
                    // << Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics

                    AddReplaceTable(Scenario, Stats);
                    AddReplaceModeVisualisation(Scenario, "FPDFPA_PeakStats", StaticRapportVisualisationMode);
                    #endregion

                    #region Make-Up Smoothed flows BHS
                    DataTable makeUpSmoothedFlowsBHSTable = FPA_TransferICTFlow.Copy();
                    makeUpSmoothedFlowsBHSTable.TableName = GlobalNames.makeUpSmoothedFlowsBHSTableName;

                    makeUpSmoothedFlowsBHSTable.Columns.Remove("Nb Pax");
                    makeUpSmoothedFlowsBHSTable.Columns.Remove("Nb Pax / h");

                    makeUpSmoothedFlowsBHSTable.Columns["Nb Bags"].ColumnName = "Departing Bags";
                    makeUpSmoothedFlowsBHSTable.Columns["Nb Bags / h"].ColumnName = "Departing Bags / h";

                    OverallTools.DataFunctions.ConcateneTable(makeUpSmoothedFlowsBHSTable, FPD_CheckInShowUpFlow,
                        new String[] { "Baggage", "Baggage / h" }, "FPD_");
                    OverallTools.DataFunctions.ConcateneTable(makeUpSmoothedFlowsBHSTable, FPA_TransferICTFlow,
                        new String[] { "Nb Bags", "Nb Bags / h" }, "FPA_");

                    makeUpSmoothedFlowsBHSTable.Columns["FPD_Baggage"].ColumnName = "Originating Bags";
                    makeUpSmoothedFlowsBHSTable.Columns["FPD_Baggage / h"].ColumnName = "Originating Bags / h";
                    makeUpSmoothedFlowsBHSTable.Columns["FPA_Nb Bags"].ColumnName = "Transfering ICT Bags";
                    makeUpSmoothedFlowsBHSTable.Columns["FPA_Nb Bags / h"].ColumnName = "Transfering ICT Bags / h";

                    OverallTools.DataFunctions.SumColumns(makeUpSmoothedFlowsBHSTable,
                        new String[] { "Originating Bags", "Transfering ICT Bags" }, "Departing Bags");
                    OverallTools.DataFunctions.SumColumns(makeUpSmoothedFlowsBHSTable,
                        new String[] { "Originating Bags / h", "Transfering ICT Bags / h" }, "Departing Bags / h");

                    AddReplaceTable(Scenario, makeUpSmoothedFlowsBHSTable);
                    AddGraphicFilter(Scenario, GraphicFilter.getStaticGraphicFilter(makeUpSmoothedFlowsBHSTable, true));
                    
                    // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                    OverallTools.DataFunctions.addNewStatisticsToStatisticTable(Stats, makeUpSmoothedFlowsBHSTable,
                        new int[] { 1, 2, 3, 4, 5, 6 }, percentileLevels);
                    /*OverallTools.DataFunctions.GetStatTable(Stats, makeUpSmoothedFlowsBHSTable,
                        new int[] { 1, 2, 3, 4, 5, 6 });*/
                    // << Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                    
                    AddReplaceTable(Scenario, Stats);
                    AddReplaceModeVisualisation(Scenario, "FPDFPA_PeakStats", StaticRapportVisualisationMode);
                    #endregion
                    // << Task #9108 Pax2Sim - Static Analysis - FPD+FPA split table
                    #region old code
                    /* 
                    DataTable Sum_Arrival_Departure = FPA_TransferICTFlow.Copy();
                    Sum_Arrival_Departure.TableName = "PAX Boarding room & BHS Make-Up Smoothed flows";
                    //Sum_Arrival_Departure.Columns.Remove("Nb Pax");   // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    //Sum_Arrival_Departure.Columns.Remove("Nb Bags");  // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                    Sum_Arrival_Departure.Columns["Nb Pax"].ColumnName = "Departing Pax";   // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    Sum_Arrival_Departure.Columns["Nb Bags"].ColumnName = "Departing Bags"; // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                    Sum_Arrival_Departure.Columns["Nb Pax / h"].ColumnName = "Departing Pax / h";   // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    Sum_Arrival_Departure.Columns["Nb Bags / h"].ColumnName = "Departing Bags / h"; // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                    OverallTools.DataFunctions.ConcateneTable(Sum_Arrival_Departure, FPD_CheckInShowUpFlow,
                        new String[] { "Passengers", "Passengers / h", "Baggage", "Baggage / h" }, "FPD_");  // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    OverallTools.DataFunctions.ConcateneTable(Sum_Arrival_Departure, FPA_TransferICTFlow,
                        new String[] { "Nb Pax", "Nb Pax / h", "Nb Bags", "Nb Bags / h" }, "FPA_");        // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                    Sum_Arrival_Departure.Columns["FPD_Passengers"].ColumnName = "Originating Pax"; // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    Sum_Arrival_Departure.Columns["FPD_Passengers / h"].ColumnName = "Originating Pax / h"; // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                    Sum_Arrival_Departure.Columns["FPD_Baggage"].ColumnName = "Originating Bags";   // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    Sum_Arrival_Departure.Columns["FPD_Baggage / h"].ColumnName = "Originating Bags / h";   // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant                    

                    Sum_Arrival_Departure.Columns["FPA_Nb Pax"].ColumnName = "Transfering ICT Pax";    // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    Sum_Arrival_Departure.Columns["FPA_Nb Pax / h"].ColumnName = "Transfering ICT Pax / h";    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                    Sum_Arrival_Departure.Columns["FPA_Nb Bags"].ColumnName = "Transfering ICT Bags";  // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    Sum_Arrival_Departure.Columns["FPA_Nb Bags / h"].ColumnName = "Transfering ICT Bags / h";  // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant                   

                    OverallTools.DataFunctions.SumColumns(Sum_Arrival_Departure, new String[] { "Originating Pax / h", "Transfering ICT Pax / h" }, "Departing Pax / h");      // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    OverallTools.DataFunctions.SumColumns(Sum_Arrival_Departure, new String[] { "Originating Bags / h", "Transfering ICT Bags / h" }, "Departing Bags / h");   // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                    OverallTools.DataFunctions.SumColumns(Sum_Arrival_Departure, 
                        new String[] { "Originating Pax", "Transfering ICT Pax" }, "Departing Pax");      // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    OverallTools.DataFunctions.SumColumns(Sum_Arrival_Departure,
                        new String[] { "Originating Bags", "Transfering ICT Bags" }, "Departing Bags");   // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                    AddReplaceTable(Scenario, Sum_Arrival_Departure);
                    AddGraphicFilter(Scenario, GraphicFilter.getStaticGraphicFilter(Sum_Arrival_Departure, true));
                    OverallTools.DataFunctions.GetStatTable(Stats, Sum_Arrival_Departure,
                        new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 ,10, 11, 12 });  // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                    AddReplaceTable(Scenario, Stats);
                    AddReplaceModeVisualisation(Scenario, "FPDFPA_PeakStats", StaticRapportVisualisationMode);
 */
                    #endregion
                }

                FPD_CheckInShowUpFlow = getTable(Scenario, "FPD_CheckInShowUpInstantaneous");
                FPA_TransferICTFlow = getTable(Scenario, "FPA_TransferICTInstantaneous");
                if ((FPD_CheckInShowUpFlow != null) && (FPA_TransferICTFlow != null) &&
                    (FPD_CheckInShowUpFlow.Rows.Count > 0) && (FPA_TransferICTFlow.Rows.Count > 0))
                {
                    // >> Task #9108 Pax2Sim - Static Analysis - FPD+FPA split table                    
                    #region PAX Boarding room Instantaneous flows
                    DataTable paxBoardingRoomInstantaneousFlowsTable = FPA_TransferICTFlow.Copy();
                    paxBoardingRoomInstantaneousFlowsTable.TableName = GlobalNames.paxBoardingRoomInstantaneousFlowsTableName;

                    paxBoardingRoomInstantaneousFlowsTable.Columns.Remove("Nb Bags");
                    paxBoardingRoomInstantaneousFlowsTable.Columns.Remove("Nb Bags / h");

                    paxBoardingRoomInstantaneousFlowsTable.Columns["Nb Pax"].ColumnName = "Departing Pax";
                    paxBoardingRoomInstantaneousFlowsTable.Columns["Nb Pax / h"].ColumnName = "Departing Pax / h";

                    OverallTools.DataFunctions.ConcateneTable(paxBoardingRoomInstantaneousFlowsTable, FPD_CheckInShowUpFlow,
                        new String[] { "Passengers", "Passengers / h" }, "FPD_");
                    OverallTools.DataFunctions.ConcateneTable(paxBoardingRoomInstantaneousFlowsTable, FPA_TransferICTFlow,
                        new String[] { "Nb Pax", "Nb Pax / h" }, "FPA_");

                    paxBoardingRoomInstantaneousFlowsTable.Columns["FPD_Passengers"].ColumnName = "Originating Pax";
                    paxBoardingRoomInstantaneousFlowsTable.Columns["FPD_Passengers / h"].ColumnName = "Originating Pax / h";
                    paxBoardingRoomInstantaneousFlowsTable.Columns["FPA_Nb Pax"].ColumnName = "Transfering ICT Pax";
                    paxBoardingRoomInstantaneousFlowsTable.Columns["FPA_Nb Pax / h"].ColumnName = "Transfering ICT Pax / h";

                    OverallTools.DataFunctions.SumColumns(paxBoardingRoomInstantaneousFlowsTable,
                        new String[] { "Originating Pax", "Transfering ICT Pax" }, "Departing Pax");
                    OverallTools.DataFunctions.SumColumns(paxBoardingRoomInstantaneousFlowsTable,
                        new String[] { "Originating Pax / h", "Transfering ICT Pax / h" }, "Departing Pax / h");

                    AddReplaceTable(Scenario, paxBoardingRoomInstantaneousFlowsTable);
                    AddGraphicFilter(Scenario, GraphicFilter.getStaticGraphicFilter(paxBoardingRoomInstantaneousFlowsTable, true));
                    
                    // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                    //OverallTools.DataFunctions.addNewStatisticsToStatisticTable(Stats, paxBoardingRoomInstantaneousFlowsTable,
                        //new int[] { 1, 2, 3, 4, 5, 6 }, percentileLevels);
                    /*OverallTools.DataFunctions.GetStatTable(Stats, paxBoardingRoomInstantaneousFlowsTable,
                        new int[] { 1, 2, 3, 4, 5, 6 });*/
                    // << Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics

                    AddReplaceTable(Scenario, Stats);
                    AddReplaceModeVisualisation(Scenario, "FPDFPA_PeakStats", StaticRapportVisualisationMode);
                    #endregion

                    #region Make-Up Instantaneous flows BHS
                    DataTable makeUpInstantaneousFlowsBHSTable = FPA_TransferICTFlow.Copy();
                    makeUpInstantaneousFlowsBHSTable.TableName = GlobalNames.makeUpInstantaneousFlowsBHSTableName;

                    makeUpInstantaneousFlowsBHSTable.Columns.Remove("Nb Pax");
                    makeUpInstantaneousFlowsBHSTable.Columns.Remove("Nb Pax / h");

                    makeUpInstantaneousFlowsBHSTable.Columns["Nb Bags"].ColumnName = "Departing Bags";
                    makeUpInstantaneousFlowsBHSTable.Columns["Nb Bags / h"].ColumnName = "Departing Bags / h";

                    OverallTools.DataFunctions.ConcateneTable(makeUpInstantaneousFlowsBHSTable, FPD_CheckInShowUpFlow,
                        new String[] { "Baggage", "Baggage / h" }, "FPD_");
                    OverallTools.DataFunctions.ConcateneTable(makeUpInstantaneousFlowsBHSTable, FPA_TransferICTFlow,
                        new String[] { "Nb Bags", "Nb Bags / h" }, "FPA_");

                    makeUpInstantaneousFlowsBHSTable.Columns["FPD_Baggage"].ColumnName = "Originating Bags";
                    makeUpInstantaneousFlowsBHSTable.Columns["FPD_Baggage / h"].ColumnName = "Originating Bags / h";
                    makeUpInstantaneousFlowsBHSTable.Columns["FPA_Nb Bags"].ColumnName = "Transfering ICT Bags";
                    makeUpInstantaneousFlowsBHSTable.Columns["FPA_Nb Bags / h"].ColumnName = "Transfering ICT Bags / h";

                    OverallTools.DataFunctions.SumColumns(makeUpInstantaneousFlowsBHSTable,
                        new String[] { "Originating Bags", "Transfering ICT Bags" }, "Departing Bags");
                    OverallTools.DataFunctions.SumColumns(makeUpInstantaneousFlowsBHSTable,
                        new String[] { "Originating Bags / h", "Transfering ICT Bags / h" }, "Departing Bags / h");

                    AddReplaceTable(Scenario, makeUpInstantaneousFlowsBHSTable);
                    AddGraphicFilter(Scenario, GraphicFilter.getStaticGraphicFilter(makeUpInstantaneousFlowsBHSTable, true));
                    
                    // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                    //OverallTools.DataFunctions.addNewStatisticsToStatisticTable(Stats, makeUpInstantaneousFlowsBHSTable,
                    //new int[] { 1, 2, 3, 4, 5, 6 }, percentileLevels);
                    /*OverallTools.DataFunctions.GetStatTable(Stats, makeUpInstantaneousFlowsBHSTable,
                        new int[] { 1, 2, 3, 4, 5, 6 });*/
                    // << Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics

                    AddReplaceTable(Scenario, Stats);
                    AddReplaceModeVisualisation(Scenario, "FPDFPA_PeakStats", StaticRapportVisualisationMode);
                    #endregion
                    // << Task #9108 Pax2Sim - Static Analysis - FPD+FPA split table

                    #region old code
/*
                    DataTable Sum_Arrival_Departure = FPA_TransferICTFlow.Copy();
                    Sum_Arrival_Departure.TableName = "PAX Boarding room & BHS Make-Up Instantaneous flows";
                    //Sum_Arrival_Departure.Columns.Remove("Nb Pax");   // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    //Sum_Arrival_Departure.Columns.Remove("Nb Bags");  // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    Sum_Arrival_Departure.Columns["Nb Pax / h"].ColumnName = "Departing Pax / h";   // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    Sum_Arrival_Departure.Columns["Nb Bags / h"].ColumnName = "Departing Bags / h"; // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                    Sum_Arrival_Departure.Columns["Nb Pax"].ColumnName = "Departing Pax";   // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    Sum_Arrival_Departure.Columns["Nb Bags"].ColumnName = "Departing Bags"; // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                    OverallTools.DataFunctions.ConcateneTable(Sum_Arrival_Departure, FPD_CheckInShowUpFlow,
                        new String[] { "Passengers", "Passengers / h", "Baggage", "Baggage / h" }, "FPD_");  // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    OverallTools.DataFunctions.ConcateneTable(Sum_Arrival_Departure, FPA_TransferICTFlow,
                        new String[] { "Nb Pax", "Nb Pax / h", "Nb Bags", "Nb Bags / h" }, "FPA_");    // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    
                    Sum_Arrival_Departure.Columns["FPD_Passengers / h"].ColumnName = "Originating Pax / h";     // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    Sum_Arrival_Departure.Columns["FPD_Baggage / h"].ColumnName = "Originating Bags / h";       // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                    Sum_Arrival_Departure.Columns["FPD_Passengers"].ColumnName = "Originating Pax";     // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    Sum_Arrival_Departure.Columns["FPD_Baggage"].ColumnName = "Originating Bags";       // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                    Sum_Arrival_Departure.Columns["FPA_Nb Pax / h"].ColumnName = "Transfering ICT Pax / h";    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    Sum_Arrival_Departure.Columns["FPA_Nb Bags / h"].ColumnName = "Transfering ICT Bags / h";  // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                    Sum_Arrival_Departure.Columns["FPA_Nb Pax"].ColumnName = "Transfering ICT Pax";    // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    Sum_Arrival_Departure.Columns["FPA_Nb Bags"].ColumnName = "Transfering ICT Bags";  // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                    OverallTools.DataFunctions.SumColumns(Sum_Arrival_Departure,
                        new String[] { "Originating Pax / h", "Transfering ICT Pax / h" }, "Departing Pax / h");      // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    OverallTools.DataFunctions.SumColumns(Sum_Arrival_Departure,
                        new String[] { "Originating Bags / h", "Transfering ICT Bags / h" }, "Departing Bags / h");   // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                    OverallTools.DataFunctions.SumColumns(Sum_Arrival_Departure,
                        new String[] { "Originating Pax", "Transfering ICT Pax" }, "Departing Pax");      // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                    OverallTools.DataFunctions.SumColumns(Sum_Arrival_Departure,
                        new String[] { "Originating Bags", "Transfering ICT Bags" }, "Departing Bags");   // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                    AddReplaceTable(Scenario, Sum_Arrival_Departure);
                    AddGraphicFilter(Scenario, GraphicFilter.getStaticGraphicFilter(Sum_Arrival_Departure, true));
                    OverallTools.DataFunctions.GetStatTable(Stats, Sum_Arrival_Departure,
                        new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 });  // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                    AddReplaceTable(Scenario, Stats);
                    AddReplaceModeVisualisation(Scenario, "FPDFPA_PeakStats", StaticRapportVisualisationMode);
 */ 
                    #endregion
                }
                // << Task #9115 Pax2Sim - Static Analysis - FPD+FPA Departure Entrance
                #region Departure Entrance Smoothed
                DataTable fpdOutBoundSmoothedTable = getTable(Scenario, "FPD_OutBoundRolling");
                DataTable fpaInBoundSmoothedTable = getTable(Scenario, "FPA_InBoundRolling");
                List<String> fpdOutBoundColumnsNeededList = new List<String>(new string[] { "Time", "Originating PAX", "Originating PAX / h" });
                string[] fpaInBoundColumnsNeededList = new string[] {"Transferring PAX", "Transferring PAX / h" };
                DataTable fpaFpdDepartureEntranceSmoothedTable = null;

                if (fpdOutBoundSmoothedTable != null && fpaInBoundSmoothedTable != null
                    && fpdOutBoundSmoothedTable.Rows.Count > 0 && fpaInBoundSmoothedTable.Rows.Count > 0)
                {
                    fpaFpdDepartureEntranceSmoothedTable = createDepartureEntranceTableForStaticAnalysis(fpdOutBoundSmoothedTable,
                        fpdOutBoundColumnsNeededList, fpaInBoundSmoothedTable, fpaInBoundColumnsNeededList);
                }
                if (fpaFpdDepartureEntranceSmoothedTable != null)
                {
                    AddReplaceTable(Scenario, fpaFpdDepartureEntranceSmoothedTable);
                    AddGraphicFilter(Scenario, GraphicFilter.getStaticGraphicFilter(fpaFpdDepartureEntranceSmoothedTable, true));
                    
                    // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                    OverallTools.DataFunctions.addNewStatisticsToStatisticTable(Stats, fpaFpdDepartureEntranceSmoothedTable,
                        new int[] { 1, 2, 3, 4 }, percentileLevels);
                    /*OverallTools.DataFunctions.GetStatTable(Stats, fpaFpdDepartureEntranceSmoothedTable,
                        new int[] { 1, 2, 3, 4 });*/
                    // << Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics

                    AddReplaceTable(Scenario, Stats);
                    AddReplaceModeVisualisation(Scenario, "FPDFPA_PeakStats", StaticRapportVisualisationMode);
                }
                #endregion

                #region Departure Entrance Instantaneous
                DataTable fpdOutBoundInstantaneousTable = getTable(Scenario, "FPD_OutBoundInstantaneous");
                DataTable fpaInBoundInstantaneousTable = getTable(Scenario, "FPA_InBoundInstantaneous");
                fpdOutBoundColumnsNeededList = new List<String>(new string[] { "Time", "Originating PAX", "Originating PAX / h" });
                fpaInBoundColumnsNeededList = new string[] { "Transferring PAX", "Transferring PAX / h" };
                DataTable fpaFpdDepartureEntranceInstantaneousTable = null;

                if (fpdOutBoundInstantaneousTable != null && fpaInBoundInstantaneousTable != null
                    && fpdOutBoundInstantaneousTable.Rows.Count > 0 && fpaInBoundInstantaneousTable.Rows.Count > 0)
                {
                    fpaFpdDepartureEntranceInstantaneousTable
                        = createDepartureEntranceTableForStaticAnalysis(fpdOutBoundInstantaneousTable, fpdOutBoundColumnsNeededList,
                                                                    fpaInBoundInstantaneousTable, fpaInBoundColumnsNeededList);
                }
                if (fpaFpdDepartureEntranceInstantaneousTable != null)
                {
                    AddReplaceTable(Scenario, fpaFpdDepartureEntranceInstantaneousTable);
                    AddGraphicFilter(Scenario, GraphicFilter.getStaticGraphicFilter(fpaFpdDepartureEntranceInstantaneousTable, true));

                    // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                    //OverallTools.DataFunctions.addNewStatisticsToStatisticTable(Stats, fpaFpdDepartureEntranceInstantaneousTable,
                    //new int[] { 1, 2, 3, 4 }, percentileLevels);
                    /*OverallTools.DataFunctions.GetStatTable(Stats, fpaFpdDepartureEntranceInstantaneousTable,
                        new int[] { 1, 2, 3, 4 });*/
                    // << Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics

                    AddReplaceTable(Scenario, Stats);
                    AddReplaceModeVisualisation(Scenario, "FPDFPA_PeakStats", StaticRapportVisualisationMode);
                }
                #endregion

                #region Departure Entrance BHS Smoothed
                fpdOutBoundColumnsNeededList = new List<string>(new string[] { "Time", "Originating Bags", "Originating Bags / h"});
                DataTable fpaInboundBHSSmoothedTable = getTable(Scenario, GlobalNames.paxGateSmoothedBHSTableName);
                string[] fpaInboundBHSColumnsNeededList = new string[] {"Transferring BHS Bags", "Transferring BHS Bags / h" };
                DataTable departureEntranceBHSSmoothedTable = null;

                if (fpdOutBoundSmoothedTable != null && fpaInboundBHSSmoothedTable != null
                    && fpdOutBoundSmoothedTable.Rows.Count > 0 && fpaInboundBHSSmoothedTable.Rows.Count > 0)
                {
                    departureEntranceBHSSmoothedTable = createDepartureEntranceTableForStaticAnalysis(fpdOutBoundSmoothedTable,
                        fpdOutBoundColumnsNeededList, fpaInboundBHSSmoothedTable, fpaInboundBHSColumnsNeededList);
                }
                if (departureEntranceBHSSmoothedTable != null)
                {
                    AddReplaceTable(Scenario, departureEntranceBHSSmoothedTable);
                    AddGraphicFilter(Scenario, GraphicFilter.getStaticGraphicFilter(departureEntranceBHSSmoothedTable, true));

                    // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                    OverallTools.DataFunctions.addNewStatisticsToStatisticTable(Stats, departureEntranceBHSSmoothedTable,
                        new int[] { 1, 2, 3, 4 }, percentileLevels);
                    /*OverallTools.DataFunctions.GetStatTable(Stats, departureEntranceBHSSmoothedTable,
                        new int[] { 1, 2, 3, 4 });*/
                    // << Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics

                    AddReplaceTable(Scenario, Stats);
                    AddReplaceModeVisualisation(Scenario, "FPDFPA_PeakStats", StaticRapportVisualisationMode);
                }                
                #endregion

                #region Departure Entrance BHS Instantaneous
                fpdOutBoundColumnsNeededList = new List<string>(new string[] { "Time", "Originating Bags", "Originating Bags / h" });
                DataTable fpaInboundBHSInstantaneousTable = getTable(Scenario, GlobalNames.paxGateInstantaneousBHSTableName);
                fpaInboundBHSColumnsNeededList = new string[] { "Transferring BHS Bags", "Transferring BHS Bags / h" };
                DataTable departureEntranceBHSInstantaneousTable = null;

                if (fpdOutBoundInstantaneousTable != null && fpaInboundBHSInstantaneousTable != null
                    && fpdOutBoundInstantaneousTable.Rows.Count > 0 && fpaInboundBHSInstantaneousTable.Rows.Count > 0)
                {
                    departureEntranceBHSInstantaneousTable = createDepartureEntranceTableForStaticAnalysis(fpdOutBoundInstantaneousTable,
                        fpdOutBoundColumnsNeededList, fpaInboundBHSInstantaneousTable, fpaInboundBHSColumnsNeededList);
                }
                if (departureEntranceBHSInstantaneousTable != null)
                {
                    AddReplaceTable(Scenario, departureEntranceBHSInstantaneousTable);
                    AddGraphicFilter(Scenario, GraphicFilter.getStaticGraphicFilter(departureEntranceBHSInstantaneousTable, true));

                    // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                    //OverallTools.DataFunctions.addNewStatisticsToStatisticTable(Stats, departureEntranceBHSInstantaneousTable,
                    //new int[] { 1, 2, 3, 4 }, percentileLevels);
                    /*OverallTools.DataFunctions.GetStatTable(Stats, departureEntranceBHSInstantaneousTable,
                        new int[] { 1, 2, 3, 4 });*/
                    // << Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics

                    AddReplaceTable(Scenario, Stats);
                    AddReplaceModeVisualisation(Scenario, "FPDFPA_PeakStats", StaticRapportVisualisationMode);
                }
                #endregion
                // >> Task #9115 Pax2Sim - Static Analysis - FPD+FPA Departure Entrance

                // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                #region Segregation by Flight Subcategory
                DataTable FPA_flightInformationTable = getTable(Scenario, GlobalNames.FPA_flightInformationTableName);
                DataTable FPD_flightInformationTable = getTable(Scenario, GlobalNames.FPD_flightInformationTableName);

                List<String> flightSubcategories = OverallTools.StaticAnalysis
                    .getFlightSubcategoriesFromFlightInformationTable(FPA_flightInformationTable, FPD_flightInformationTable);

                DataTable fpd_aircraftMovements_fsc = getTable(Scenario, "FPD_AircraftMovements_FSC");
                DataTable fpa_aircraftMovements_fsc = getTable(Scenario, "FPA_AircraftMovements_FSC");

                DataTable fpa_inBoundSmoothed_fsc = getTable(Scenario, "FPA_InBoundRolling_FSC");
                DataTable fpd_outBoundSmoothed_fsc = getTable(Scenario, "FPD_OutBoundRolling_FSC");

                DataTable fpa_inBoundInstant_fsc = getTable(Scenario, "FPA_InBoundInstantaneous_FSC");
                DataTable fpd_outBoundInstant_fsc = getTable(Scenario, "FPD_OutBoundInstantaneous_FSC");

                DataTable fpa_inBoundSmoothedPAXTransfering_fsc = getTable(Scenario, GlobalNames.fpaInboundSmoothedPAXTransfering_FSC);
                DataTable fpa_inBoundInstantaneousPAXTransfering_fsc = getTable(Scenario, GlobalNames.fpaInboundInstantaneousPAXTransfering_FSC);

                DataTable fpd_outBoundSmoothedPAXOriginating_fsc = getTable(Scenario, GlobalNames.fpdOutBoundSmoothedPAXOriginating_FSC);
                DataTable fpd_outBoundInstantaneousPAXOriginating_fsc = getTable(Scenario, GlobalNames.fpdOutBoundInstantaneousPAXOriginating_FSC);

                DataTable fpa_inBoundSmoothedBagTransfering_fsc = getTable(Scenario, GlobalNames.fpaInboundSmoothedBagTransfering_FSC);
                DataTable fpa_inBoundInstantaneousBagTransfering_fsc = getTable(Scenario, GlobalNames.fpaInboundInstantaneousBagTransfering_FSC);

                DataTable fpd_outBoundSmoothedBagOriginating_fsc = getTable(Scenario, GlobalNames.fpdOutBoundSmoothedBagOriginating_FSC);
                DataTable fpd_outBoundInstantaneousBagOriginating_fsc = getTable(Scenario, GlobalNames.fpdOutBoundInstantaneousBagOriginating_FSC);


                DataTable fpa_transferICTSmoothed_fsc = getTable(Scenario, GlobalNames.FPA_TransferICTSmoothedTableName + "_FSC");
                DataTable fpa_transferICTInstantaneous_fsc = getTable(Scenario, GlobalNames.FPA_TransferICTInstantaneousTableName + "_FSC");

                DataTable fpd_checkInShowUpSmoothed_fsc = getTable(Scenario, GlobalNames.FPDCheckInShowUpSmoothedTableName + "_FSC");
                DataTable fpd_checkInShowUpInstantaneous_fsc = getTable(Scenario, GlobalNames.FPDCheckInShowUpInstantaneousTableName + "_FSC");

                DataTable fpa_transferICTBagSmoothed_fsc = getTable(Scenario, GlobalNames.FPA_TransferICTSmoothedTableName + "_Bag_FSC");
                DataTable fpa_transferICTBagInstantaneous_fsc = getTable(Scenario, GlobalNames.FPA_TransferICTInstantaneousTableName + "_Bag_FSC");

                DataTable fpd_checkInShowUpBagSmoothed_fsc = getTable(Scenario, GlobalNames.FPDCheckInShowUpSmoothedTableName + "_Bag_FSC");
                DataTable fpd_checkInShowUpBagInstantaneous_fsc = getTable(Scenario, GlobalNames.FPDCheckInShowUpInstantaneousTableName + "_Bag_FSC");

                List<DataTable> segregationTablesList = OverallTools.StaticAnalysis
                    .getFPDFPAFlightSubcategorySegregationTables(fpd_aircraftMovements_fsc, fpa_aircraftMovements_fsc,
                        fpa_inBoundSmoothed_fsc, fpd_outBoundSmoothed_fsc, fpa_inBoundInstant_fsc, fpd_outBoundInstant_fsc,
                        fpa_inBoundSmoothedPAXTransfering_fsc, fpa_inBoundInstantaneousPAXTransfering_fsc,
                        fpd_outBoundSmoothedPAXOriginating_fsc,fpd_outBoundInstantaneousPAXOriginating_fsc,
                        fpa_inBoundSmoothedBagTransfering_fsc, fpa_inBoundInstantaneousBagTransfering_fsc,
                        fpd_outBoundSmoothedBagOriginating_fsc, fpd_outBoundInstantaneousBagOriginating_fsc,
                        fpa_transferICTSmoothed_fsc, fpd_checkInShowUpSmoothed_fsc, fpa_transferICTInstantaneous_fsc, fpd_checkInShowUpInstantaneous_fsc,
                        fpa_transferICTBagSmoothed_fsc, fpd_checkInShowUpBagSmoothed_fsc,
                        fpa_transferICTBagInstantaneous_fsc, fpd_checkInShowUpBagInstantaneous_fsc, flightSubcategories);

                foreach (DataTable table in segregationTablesList)
                {
                    AddReplaceTable(Scenario, table);
                    AddGraphicFilter(Scenario, GraphicFilter.getStaticGraphicFilter(table, true));
                }
                
                #endregion
                // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

                int i;
                DataTable Stat = OverallTools.StaticAnalysis.getDistribution(parametres.DateDebut,
                                                                  parametres.DateFin,
                                                                  dtFPD,
                                                                  dtFPA,
                                                                  getTable("Input", parametres.FlightCategories),
                                                                  GetTable("Input", parametres.AircraftType),
                                                                  GetTable("Input", parametres.DepartureLoadFactors),
                                                                  GetTable("Input", parametres.ArrivalLoadFactors),
                                                                  GetTable("Input", parametres.NbBags),
                                                                  GlobalNames.sFPD_A_Column_FlightCategory,
                                                                  userDefinedFlightConfigurations,
                                                                  out i,
                                                                  ListeErreurs);
                if (Stat != null)
                {
                    AddReplaceTable(Scenario, Stat);
                    VisualisationMode mode = StaticRapportVisualisationMode.Clone();
                    mode.ConditionnalFormatClass[0] = new ConditionnalFormatLine(getTable("Input", parametres.FlightCategories).Rows.Count + 1, Color.FromArgb(200, 255, 255), Color.FromArgb(255, 255, 180));
                    AddReplaceModeVisualisation(Scenario, Stat.TableName, mode);
                }
                int iNbAirline = 0;
                Stat = OverallTools.StaticAnalysis.getDistribution(parametres.DateDebut,
                                                                  parametres.DateFin,
                                                                  dtFPD,
                                                                  dtFPA,
                                                                  getTable("Input", parametres.FlightCategories),
                                                                  GetTable("Input", parametres.AircraftType),
                                                                  GetTable("Input", parametres.DepartureLoadFactors),
                                                                  GetTable("Input", parametres.ArrivalLoadFactors),
                                                                  GetTable("Input", parametres.NbBags),
                                                                  GlobalNames.sFPD_A_Column_AirlineCode,
                                                                  userDefinedFlightConfigurations,
                                                                  out iNbAirline,
                                                                  ListeErreurs);
                if (Stat != null)
                {
                    AddReplaceTable(Scenario, Stat);
                    VisualisationMode mode = StaticRapportVisualisationMode.Clone();
                    mode.ConditionnalFormatClass[0] = new ConditionnalFormatLine(iNbAirline + 1, Color.FromArgb(200, 255, 255), Color.FromArgb(255, 255, 180));
                    AddReplaceModeVisualisation(Scenario, Stat.TableName, mode);

                    int iNbHandling;
                    Stat = OverallTools.StaticAnalysis.getHandlingAgentDistribution(Stat, getTable("Input", parametres.Airline), out iNbHandling, ListeErreurs);
                    if (Stat != null)
                    {
                        AddReplaceTable(Scenario, Stat);
                        mode = StaticRapportVisualisationMode.Clone();
                        mode.ConditionnalFormatClass[0] = new ConditionnalFormatLine(iNbHandling, Color.FromArgb(200, 255, 255), Color.FromArgb(255, 255, 180));
                        AddReplaceModeVisualisation(Scenario, Stat.TableName, mode);
                    }
                }

                Stat = OverallTools.StaticAnalysis.CalcContainerStatistics(
                                                                  dtFPD,
                                                                  GetTable("Input", parametres.OCT_MakeUp),
                                                                  GetTable("Input", parametres.CI_ShowUpTable),
                                                                  GetTable("Input", "Segregation"),
                                                                  GetTable("Input", parametres.ICT_Table),
                                                                  GetTable("Input", parametres.OCT_CI_Table),
                                                                  GetTable("Input", parametres.DepartureLoadFactors),
                                                                  GetTable("Input", parametres.AircraftType),
                                                                  getTable("Input", parametres.FlightCategories),
                                                                  GetTable("Input", parametres.NbBags),
                                                                  parametres.DateDebut,
                                                                  parametres.DateFin,
                                                                  userDefinedFlightConfigurations,
                                                                  ListeErreurs);
                if (Stat != null)
                {
                    AddReplaceTable(Scenario, Stat);
                    //                    AddReplaceModeVisualisation(Scenario, Stat.TableName, mode);
                }
                bSupprTable = false;
                //OverallTools.ExternFunctions.PrintLogFile("PeakFlowTest: Arr + Dep end");
            }
            if (bSupprTable)
            {
                foreach (String sName in StaticResultsFPDFPA)
                {
                    RemoveTable(Scenario, sName);
                }
            }
            if (!parametres.BagPlan)
            {
                VisualisationMode vmMode = null;
                VisualisationMode vmMode2 = null;
                ArrayList alAllocationTables = MajAllocationScenario(parametres, perimeter, cht, out vmMode, out vmMode2);
                if (alAllocationTables != null)
                {
                    foreach (String sName in StaticResultsAllocation)
                    {
                        RemoveTable(Scenario, sName);
                    }
                    foreach (DataTable dtResults in alAllocationTables)
                    {
                        AddReplaceTable(Scenario, dtResults);
                        /*if (dtResults.TableName.StartsWith("Alloc_MakeUpTable"))  // >> Task #10272 Pax2Sim - MUP Allocation C#9
                        {
                            if (dtResults.TableName.EndsWith("Airline"))
                                AddReplaceModeVisualisation(Scenario, dtResults.TableName, vmMode);
                            else
                                AddReplaceModeVisualisation(Scenario, dtResults.TableName, vmMode2);
                        }
                        else*/ if (modeVisualisation.ContainsKey(dtResults.TableName))
                            AddReplaceModeVisualisation(Scenario, dtResults.TableName, (VisualisationMode)modeVisualisation[dtResults.TableName]);
                    }
                }
            }
            /*Pour savoir si l'on va regénérer le PaxPlan ou non, il faut que l'on vérifie qu'il est à générer.
             Et que le booléen reGenerate est à True (Protection avec bJNK pour être sur que tout le monde
             ne puisse pas utiliser cette option.*/
            Hashtable htResult_Pkg = null;
            if ((parametres.PaxPlan && parametres.RegeneratePaxplan) //if ((parametres.PaxPlan) && (parametres.RegeneratePaxplan))//((parametres.RegeneratePaxplan) || (!PAX2SIM.bJNK)))  // << Task #8569 Pax2Sim - Scenario Properties - Regenerate PaxPlan
                || parametres.generatePaxPlanForStaticAnalysis) // >> Task #15556 Pax2Sim - Scenario Properties Assistant issues - C#5
            {
                DataTable Pax_GenTransferLog;
                int seed = parametres.Seed;
                if (!parametres.UseSeed)
                {
                    seed = DateTime.Now.Millisecond;
                }

                if (cht != null)
                    cht.ChargementFichier("Calculate pax plan");
                DataTable dtFPDBags, dtFPABags, dtFPDPassengers, dtFPAPassengers;
                DataTable dtTransfTerminalDistribution = null, dtTransfFlightCategoryDistribution = null;
                if ((parametres.TransfTerminalDistribution != null) &&
                    (parametres.TransfTerminalDistribution != ""))
                    dtTransfTerminalDistribution = getTable("Input", parametres.TransfTerminalDistribution);

                if ((parametres.TransfFligthCategoryDistribution != null) &&
                    (parametres.TransfFligthCategoryDistribution != ""))
                    dtTransfFlightCategoryDistribution = getTable("Input", parametres.TransfFligthCategoryDistribution);

                //OverallTools.ExternFunctions.PrintLogFile("PeakFlowTest: PaxPlanTable start");
                
            #region //SGE-26/03/2012-Begin
                DataTable dtPKGPlan=getTable(Scenario,GlobalNames.PrkPlanName);
                List<String> lsNames;
                DataTable dtInitialCarStock = null;
                ExceptionTable etShortStay = null;
                ExceptionTable etLongStay = null;
                if(parametres.InitialCarStock != "")
                {
                    dtInitialCarStock = getTable("Input", parametres.InitialCarStock);
                    if(getTable("Input", parametres.ShortStayTable) != null)
                        etShortStay = (ExceptionTable)GetTable("Input", parametres.ShortStayTable);
                    if (getTable("Input", parametres.LongStayTable) != null)
                        etLongStay = (ExceptionTable)GetTable("Input", parametres.LongStayTable);
                    if ((dtInitialCarStock == null) ||
                        (etShortStay == null) ||
                        (etLongStay == null))
                    {
                        dtInitialCarStock = null;
                        etShortStay = null;
                        etLongStay = null;
                    }
                }
            #endregion //SGE-26/03/2012-End
                DataTable PaxPlanTable = GestionDonneesHUB2SIM.effectuerCalculPaxPlan("PaxPlanTable",
                    out Pax_GenTransferLog,
                    out dtFPDBags,
                    out dtFPABags,
                    out dtFPDPassengers,
                    out dtFPAPassengers,
                    ref dtPKGPlan,
                    out htResult_Pkg,
                    out lsNames,
                    parametres.DateDebut,
                    parametres.DateFin,
                    parametres.TransferArrivalGeneration,
                    parametres.FillTransfer,
                    parametres.GenerateAll,
                    dtFPA,
                    dtFPD,
                    dtTransfTerminalDistribution,
                    dtTransfFlightCategoryDistribution,
                    GetTable("Input", parametres.AircraftType),
                    getTable("Input", parametres.FlightCategories),
                    GetTable("Input", parametres.ArrivalLoadFactors),
                    GetTable("Input", parametres.DepartureLoadFactors),
                    GetTable("Input", parametres.ICT_Table),
                    GetTable("Input", parametres.NbBags),
                    GetTable("Input", parametres.NbVisitors),
                    GetTable("Input", parametres.NbTrolley),
                    GetTable("Input", parametres.CI_ShowUpTable),
#if(PAXINOUTUTILISATION)
                    GetTable("Input", parametres.PaxIn),
                    GetTable("Input", parametres.PaxOut),
#endif
                    parametres,
                    this,
                    dtInitialCarStock,
                    etShortStay,
                    etLongStay,

                    GetTable("Input", "Segregation"),
                    seed, userDefinedFlightConfigurations, cht);
                if ((PaxPlanTable != null) && (Pax_GenTransferLog != null))
                {
                    DataTable SortedPaxPlan = OverallTools.DataFunctions.sortTable(PaxPlanTable, "CreationTime");

                    AddReplaceTable(Scenario, SortedPaxPlan);
                    VisualisationMode mode = new VisualisationMode(false, false, true, null, new int[] { 0 });
                    AddReplaceModeVisualisation(Scenario, SortedPaxPlan.TableName, mode);
                    AddReplaceTable(Scenario, Pax_GenTransferLog);
                    AddReplaceModeVisualisation(Scenario, SortedPaxPlan.TableName, mode.Clone());
                    AddReplaceTable(Scenario, dtFPDBags);
                    AddReplaceTable(Scenario, dtFPABags);
                    AddReplaceTable(Scenario, dtFPDPassengers);
                    AddReplaceTable(Scenario, dtFPAPassengers);
                    if(!parametres.UseExistingPRKPlan)
                        AddReplaceTable(Scenario, dtPKGPlan);
                    if (/*(htResult_Pkg != null) &&*/ (InsertPRKResults != null))
                    {
                        //We need here to integrate the new results for parking occupation into a specific directory.
                        InsertPRKResults(parametres.Name, htResult_Pkg);
                    }
                }
                else
                {
                    foreach (String sName in StaticResultsPaxplan)
                    {
                        RemoveTable(Scenario, sName);
                    }
                }
                //OverallTools.ExternFunctions.PrintLogFile("PeakFlowTest: PaxPlanTable end");
            }
            if (bUseAlphNumericForFlightInfo)
            {
                if (dtFPD != null)
                    dtFPD.Dispose();
                if (dtFPA != null)
                    dtFPA.Dispose();
            }
            return htResult_Pkg;
        }

        // << Task #9115 Pax2Sim - Static Analysis - FPD+FPA Departure Entrance
        private DataTable createDepartureEntranceTableForStaticAnalysis(DataTable fpdOutBoundTable,
            List<String> fpdOutBoundColumnsNeededList, DataTable fpaInBoundTable, string[] fpaInBoundColumnsNeededList)
        {
            String departureEntranceTableName = "";
            if (fpaInBoundTable.TableName.Contains("Rolling") && fpdOutBoundTable.TableName.Contains("Rolling"))
            {
                if (fpaInBoundTable.TableName.Contains("_BHS") || fpdOutBoundTable.TableName.Contains("_BHS"))
                    departureEntranceTableName = GlobalNames.fpaFpdDepartureEntranceBHSSmoothedTableName;
                else
                    departureEntranceTableName = GlobalNames.fpaFpdDepartureEntranceSmoothedTableName;
            }
            else if (fpaInBoundTable.TableName.Contains("Instantaneous") && fpdOutBoundTable.TableName.Contains("Instantaneous"))
            {
                if (fpaInBoundTable.TableName.Contains("_BHS") || fpdOutBoundTable.TableName.Contains("_BHS"))                
                    departureEntranceTableName = GlobalNames.fpaFpdDepartureEntranceBHSInstantaneousTableName;
                 else
                    departureEntranceTableName = GlobalNames.fpaFpdDepartureEntranceInstantaneousTableName;
            }

            DataTable departureEntranceTable = fpdOutBoundTable.Copy();
            departureEntranceTable.TableName = departureEntranceTableName;

            if (departureEntranceTable != null && departureEntranceTable.Columns != null)
            {
                List<DataColumn> columnsToBeDeletedList = new List<DataColumn>();
                foreach (DataColumn departureEntranceColumn in departureEntranceTable.Columns)
                {
                    if (!fpdOutBoundColumnsNeededList.Contains(departureEntranceColumn.ColumnName))
                        columnsToBeDeletedList.Add(departureEntranceColumn);
                }
                if (columnsToBeDeletedList.Count > 0)
                {
                    foreach (DataColumn columnToBeDeleted in columnsToBeDeletedList)
                    {
                        if (departureEntranceTable.Columns.Contains(columnToBeDeleted.ColumnName))
                            departureEntranceTable.Columns.Remove(columnToBeDeleted);
                    }
                }
                OverallTools.DataFunctions.ConcateneTable(departureEntranceTable, fpaInBoundTable,
                        fpaInBoundColumnsNeededList, "_");
                foreach (DataColumn col in departureEntranceTable.Columns)
                {
                    if (col.ColumnName.Contains("_"))
                        col.ColumnName = col.ColumnName.Replace("_", "");
                }

            }
            return departureEntranceTable;            
        }
        // >> Task #9115 Pax2Sim - Static Analysis - FPD+FPA Departure Entrance

        /// <summary>
        /// Fonction qui s'occupe d'enregistrer tous les fichiers nécessaires pour la simulation 
        /// de la partie passager.
        /// </summary>
        /// <param name="nomScenario">Le nom du scénario qui doit être exporté.</param>
        /// <param name="sSimulationDirectory">Répertoire du modèle. (Si = "Default" alors on copy également le modèle automod.</param>
        /// <returns></returns>
        public bool SaveSimulationFiles(String nomScenario,
                                            String sSimulationDirectory,
                                            bool bSimulatePaxPlan,
                                            bool bSimulateBaggage,
                                            SIM_LoadingForm slfForm,
                                            out List<DataTable> automodTablesList)  // >> Task #13361 FP AutoMod Data tables V3
        {
            automodTablesList = new List<DataTable>();// >> Task #13361 FP AutoMod Data tables V3
            //Cette fonction va permettre la génération des fichiers pour la simulation.
            //Si un problème se produit alors elle retourne false (Pour ne pas lancer la simulation
            //dans de mauvaises conditions).
            if (GetDataManager(nomScenario) == null)
            {
                ListeErreurs.Add("Err00097 : The scenario does not exist in the data base.");
                return false;
            }
            String sRoot = System.IO.Path.GetPathRoot(Application.StartupPath);
            bool result = true;
            Classes.ParamScenario paParametres = GetScenario(nomScenario);
            if (paParametres.SimAnalyserSimulation)
            {
                return SaveSimulationFiles(nomScenario, sSimulationDirectory, slfForm);
            }
            if ((!bSimulatePaxPlan) && (!bSimulateBaggage))
            {
                ListeErreurs.Add("Err00098 : The simulation must simulate at least one part of the airport.");
                return false;
            }
            if ((((!paParametres.PaxSimulation) || (!paParametres.PaxPlan)) && (bSimulatePaxPlan)) ||
                ((!paParametres.BHSSimulation) && (bSimulateBaggage) && (paParametres.UsePaxPlan != bSimulatePaxPlan)))
            {
                ListeErreurs.Add("Err00099 : There's no information about the data to use for the simulation.");
                return false;
            }
            if (sSimulationDirectory == "Default")
            {
                #region Génération des fichiers pour le modele par défault
                sSimulationDirectory = sRoot + "Temp\\Model\\";
                if (slfForm != null)
                    slfForm.ChargementFichier("Generate directories");
                if (!GenerateSimulationDirectories())
                {
                    return false;
                }
                if (!OverallTools.ExternFunctions.CheckCreateDirectory(sSimulationDirectory + sHub2simModel + ".dir"))
                {
                    ListeErreurs.Add("Err00100 : Unable to create the " + sHub2simModel + ".dir directory.");
                    return false;
                }
                if (!OverallTools.ExternFunctions.CheckCreateDirectory(sSimulationDirectory + sHub2simModel + ".dir\\pax2sim.dir"))
                {
                    ListeErreurs.Add("Err00101 : Unable to create the pax2sim.dir directory.");
                    return false;
                }
                if (!OverallTools.ExternFunctions.CheckCreateDirectory(sSimulationDirectory + sHub2simModel + ".dir\\pax2sim.dir\\sm_pax3d.dir"))
                {
                    ListeErreurs.Add("Err00159 : Unable to create the sm_pax3d.dir directory.");
                    return false;
                }


                //On va dans un premier temps écrire tous les fichiers nécessaires

                if (slfForm != null)
                    slfForm.ChargementFichier("Copying files");
                String sRessourcesDirectory = Application.StartupPath + "\\Ressources\\hub2sim\\";
                Boolean bCopyFiles = true;
                //-- "bCopyFiles = bCopyFiles &&" est utilisé de cette manière afin que si la copie d'un fichier échoue, 
                //on n'essaie pas de copier les autres.
                bCopyFiles = bCopyFiles && OverallTools.ExternFunctions.CopyFile(sSimulationDirectory, sRessourcesDirectory, sHub2simModel + ".exe", "Err00102 : Unable to copy " + sHub2simModel + ".exe in the model directory.", ListeErreurs, slfForm);
                bCopyFiles = bCopyFiles && OverallTools.ExternFunctions.CopyFile(sSimulationDirectory + sHub2simModel + ".dir\\", sRessourcesDirectory, sHub2simModel + ".dll", "Err00103 : Unable to copy " + sHub2simModel + ".dll in the right directory.", ListeErreurs, slfForm);
                bCopyFiles = bCopyFiles && OverallTools.ExternFunctions.CopyFile(sSimulationDirectory + sHub2simModel + ".dir\\", sRessourcesDirectory, sHub2simModel + ".mod", "Err00106 : Unable to copy " + sHub2simModel + ".mod in the right directory.", ListeErreurs, slfForm);

                bCopyFiles = bCopyFiles && OverallTools.ExternFunctions.CopyFile(sSimulationDirectory + sHub2simModel + ".dir\\pax2sim.dir\\", sRessourcesDirectory, "pax2sim.mod", "Err00107 : Unable to copy pax2sim.mod in the right directory.", ListeErreurs, slfForm);
                bCopyFiles = bCopyFiles && OverallTools.ExternFunctions.CopyFile(sSimulationDirectory + sHub2simModel + ".dir\\pax2sim.dir\\sm_pax3d.dir\\", sRessourcesDirectory, "sm_pax3d.mod", "Err00160 : Unable to copy sm_pax3d.mod in the right directory.", ListeErreurs, slfForm);
                bCopyFiles = bCopyFiles && OverallTools.ExternFunctions.CopyFile(sSimulationDirectory + sHub2simModel + ".dir\\pax2sim.dir\\sm_pax3d.dir\\", sRessourcesDirectory, "cv_queues.sys", "Err00161 : Unable to copy cv_queues.sys in the right directory.", ListeErreurs, slfForm);
                bCopyFiles = bCopyFiles && OverallTools.ExternFunctions.CopyFile(sSimulationDirectory + sHub2simModel + ".dir\\pax2sim.dir\\sm_pax3d.dir\\", sRessourcesDirectory, "st_layout.sys", "Err00186 : Unable to copy st_layout.sys in the right directory.", ListeErreurs, slfForm);


                if (System.IO.File.Exists(sRessourcesDirectory + "bag2sim.mod"))
                {
                    //Le modèle contenu dans le dossier ressource est un modèle complet (bag + pax).
                    //Il faut donc copier les ressources liées au modèle bagage.

                    if (!OverallTools.ExternFunctions.CheckCreateDirectory(sSimulationDirectory + sHub2simModel + ".dir\\bag2sim.dir"))
                    {
                        ListeErreurs.Add("Err00049 : Unable to create the bag2sim.dir directory.");
                        return false;
                    }
                    if (!OverallTools.ExternFunctions.CheckCreateDirectory(sSimulationDirectory + sHub2simModel + ".dir\\bag2sim.dir\\sm_bhs3d.dir"))
                    {
                        ListeErreurs.Add("Err00048 : Unable to create the sm_pax3d.dir directory.");
                        return false;
                    }
                    if (!OverallTools.ExternFunctions.CheckCreateDirectory(sSimulationDirectory + sHub2simModel + ".dir\\bag2sim.dir\\sm_bhs3d.dir\\sm_qrl.dir"))
                    {
                        ListeErreurs.Add("Err00218 : Unable to create the sm_qrl.mod directory.");
                        return false;
                    }
                    if (!OverallTools.ExternFunctions.CheckCreateDirectory(sSimulationDirectory + sHub2simModel + ".dir\\bag2sim.dir\\sm_b2s.dir"))
                    {
                        ListeErreurs.Add("Err00214 : Unable to create the sm_b2s.dir directory.");
                        return false;
                    }
                    if (!OverallTools.ExternFunctions.CheckCreateDirectory(sSimulationDirectory + sHub2simModel + ".dir\\bag2sim.dir\\sm_p2p.dir"))
                    {
                        ListeErreurs.Add("Err00216 : Unable to create the sm_p2p.dir directory.");
                        return false;
                    }
                    bCopyFiles = bCopyFiles && OverallTools.ExternFunctions.CopyFile(sSimulationDirectory + sHub2simModel + ".dir\\bag2sim.dir\\", sRessourcesDirectory, "bag2sim.mod", "Err00047 : Unable to copy bag2sim.mod in the right directory.", ListeErreurs, slfForm);

                    bCopyFiles = bCopyFiles && OverallTools.ExternFunctions.CopyFile(sSimulationDirectory + sHub2simModel + ".dir\\bag2sim.dir\\sm_b2s.dir\\", sRessourcesDirectory, "sm_b2s.mod", "Err00215 : Unable to copy sm_b2s.mod in the right directory.", ListeErreurs, slfForm);
                    bCopyFiles = bCopyFiles && OverallTools.ExternFunctions.CopyFile(sSimulationDirectory + sHub2simModel + ".dir\\bag2sim.dir\\sm_p2p.dir\\", sRessourcesDirectory, "sm_p2p.mod", "Err00217 : Unable to copy sm_p2p.mod in the right directory.", ListeErreurs, slfForm);

                    bCopyFiles = bCopyFiles && OverallTools.ExternFunctions.CopyFile(sSimulationDirectory + sHub2simModel + ".dir\\bag2sim.dir\\sm_bhs3d.dir\\", sRessourcesDirectory, "sm_bhs3d.mod", "Err00046 : Unable to copy sm_bhs3d.mod in the right directory.", ListeErreurs, slfForm);
                    bCopyFiles = bCopyFiles && OverallTools.ExternFunctions.CopyFile(sSimulationDirectory + sHub2simModel + ".dir\\bag2sim.dir\\sm_bhs3d.dir\\", sRessourcesDirectory, "cv_arr_belt.sys", "Err00045 : Unable to copy cv_arr_belt.sys in the right directory.", ListeErreurs, slfForm);
                    bCopyFiles = bCopyFiles && OverallTools.ExternFunctions.CopyFile(sSimulationDirectory + sHub2simModel + ".dir\\bag2sim.dir\\sm_bhs3d.dir\\", sRessourcesDirectory, "cv_dep_belt.sys", "Err00041 : Unable to copy cv_dep_belt.sys in the right directory.", ListeErreurs, slfForm);
                    bCopyFiles = bCopyFiles && OverallTools.ExternFunctions.CopyFile(sSimulationDirectory + sHub2simModel + ".dir\\bag2sim.dir\\sm_bhs3d.dir\\sm_qrl.dir\\", sRessourcesDirectory, "sm_qrl.mod", "Err00219 : Unable to copy cv_dep_belt.sys in the right directory.", ListeErreurs, slfForm);

                    
                    bCopyFiles = bCopyFiles && OverallTools.ExternFunctions.CopyFile(sSimulationDirectory + sHub2simModel + ".dir\\bag2sim.dir\\sm_bhs3d.dir\\", sRessourcesDirectory, "cv_arr_rt.sys", "Err00044 : Unable to copy cv_arr_rt.sys in the right directory.", ListeErreurs, slfForm);
                    bCopyFiles = bCopyFiles && OverallTools.ExternFunctions.CopyFile(sSimulationDirectory + sHub2simModel + ".dir\\bag2sim.dir\\sm_bhs3d.dir\\", sRessourcesDirectory, "cv_dep_rt.sys", "Err00043 : Unable to copy cv_dep_rt.sys in the right directory.", ListeErreurs, slfForm);
                    bCopyFiles = bCopyFiles && OverallTools.ExternFunctions.CopyFile(sSimulationDirectory + sHub2simModel + ".dir\\bag2sim.dir\\sm_bhs3d.dir\\", sRessourcesDirectory, "cv_sorters.sys", "Err00042 : Unable to copy cv_sorters.sys in the right directory.", ListeErreurs, slfForm);
                }
                if (System.IO.File.Exists(sRessourcesDirectory + "\\Unikey.dll"))
                {
                    bCopyFiles = bCopyFiles && OverallTools.ExternFunctions.CopyFile(sSimulationDirectory, sRessourcesDirectory + "\\", "Unikey.dll", "Err00108b : Unable to copy Unikey.dll in the right directory.", ListeErreurs, slfForm);
                }
                else
                {
                    bCopyFiles = bCopyFiles && OverallTools.ExternFunctions.CopyFile(sSimulationDirectory, Application.StartupPath + "\\", "Unikey.dll", "Err00108 : Unable to copy Unikey.dll in the right directory.", ListeErreurs, slfForm);
                }
                if (!bCopyFiles)
                    return false;
                #endregion
            }

            string sDataPath = sSimulationDirectory + "Data\\";
            if (paParametres.clearAutomodMainData && Directory.Exists(sDataPath))
            {
                //delete all old files that could be found in the Data folder
                try
                {
                    DirectoryInfo dataDirInfo = new DirectoryInfo(sDataPath);
                    foreach (FileInfo dataFile in dataDirInfo.GetFiles())
                        dataFile.Delete();
                }
                catch (Exception ex)
                {
                    OverallTools.ExternFunctions.PrintLogFile("Saving simulation files warning: Could not delete the old files from the Data folder ( "
                        + sDataPath + "): " + ex.Message);
                }
            }

            if (bSimulateBaggage && paParametres.exportAutomodMainData)
            {
                if (slfForm != null)
                    slfForm.ChargementFichier("Saving BHS files");
                result = SaveBHSSimulationFile(paParametres, sSimulationDirectory + "Data\\") && result;
            }

            if (bSimulatePaxPlan && paParametres.exportAutomodMainData)
            {
                if (slfForm != null)
                    slfForm.ChargementFichier("Saving passengers files");
                #region La gestion du paxplan et des parametres pour la simulation passager
                //Ecriture du PaxPlan en le rangeant suivant l'heure de creation de chaque passager.
                if (getTable(nomScenario, "PaxPlanTable") == null)
                {
                    ListeErreurs.Add("Err00113 : The PaxPlanTable table is not valid.");
                    return false;
                }
                OverallTools.FonctionUtiles.EcritureFichier(
                    OverallTools.DataFunctions.sortTable(getTable(nomScenario, "PaxPlanTable"), "CreationTime"),
                    sSimulationDirectory + "Data\\PaxPlan.txt", "\t", false);
                if (!System.IO.File.Exists(sSimulationDirectory + "Data\\PaxPlan.txt"))
                {
                    ListeErreurs.Add("Err00117 : The \"" + sSimulationDirectory + "Data\\PaxPlan.txt\" haven't been written.");
                    return false;
                }

                if ((getTable(nomScenario, "FPD_Bags") == null) || (getTable(nomScenario, "FPA_Bags") == null))
                {
                    ListeErreurs.Add("Err00114 : The table for the number of bags is not valid.");
                    return false;
                }

                result = saveFile(nomScenario, "FPD_Bags", sSimulationDirectory + "Data\\FPD_Bags.txt") && result;
                result = saveFile(nomScenario, "FPA_Bags", sSimulationDirectory + "Data\\FPA_Bags.txt") && result;
                #endregion
            }

            if (paParametres.BagPlan && paParametres.exportAutomodMainData)
            {
                if (GetDataManager(paParametres.BagPlanScenarioName) == null)
                {
                    ListeErreurs.Add("Err00164 : The scenario for the baglist doesn't exist. Please select a valid scenario for the simulation.");
                    return false;
                }

                if ((getTable(paParametres.BagPlanScenarioName, "FPD_Bags") == null)
                    || (getTable(paParametres.BagPlanScenarioName, "FPA_Bags") == null))
                {
                    ListeErreurs.Add("Err00165 : The table for the number of bags is not valid.");
                    return false;
                }                
                result = saveFile(paParametres.BagPlanScenarioName, "FPD_Bags", sSimulationDirectory + "Data\\FPD_Bags.txt") && result;
                result = saveFile(paParametres.BagPlanScenarioName, "FPA_Bags", sSimulationDirectory + "Data\\FPA_Bags.txt") && result;

                DataTable dtBagPlan = getTable(paParametres.BagPlanScenarioName, sTableBagPlan);
                if (dtBagPlan != null)
                {
                    dtBagPlan = OverallTools.DataFunctions.sortTable(dtBagPlan, "Time(mn)");
                    result = saveFile(dtBagPlan, sSimulationDirectory + "Data\\" + sTableBagPlan + ".txt") && result;
                }
                // << Sodexi Task#7129 Bagplan Update
                DataTable dtBagPlan2 = getTable(paParametres.BagPlanScenarioName, GlobalNames.BagPlan2Name);
                if (dtBagPlan2 != null)
                {
                    dtBagPlan2 = OverallTools.DataFunctions.sortTable(dtBagPlan2, GlobalNames.sBagPlan2_Column_Time);
                    result = saveFile(dtBagPlan2, sSimulationDirectory + "Data\\" + GlobalNames.BagPlan2Name + ".txt") && result;
                }
                // >> Sodexi Task#7129 Bagplan Update                
            }
            if (paParametres.exportAutomodMainData)
            {
                SortedList<String, DataTable> sl_dt_List = GenerateSimulationFiles(paParametres, slfForm);
                foreach (KeyValuePair<String, DataTable> kvp_Value in sl_dt_List)
                {
                    saveFile(kvp_Value.Value, sDataPath + kvp_Value.Key);
                    // >> Task #13361 FP AutoMod Data tables V3
                    if (kvp_Value.Value != null)
                    {
                        DataTable simulationTableCopy = kvp_Value.Value.Copy();
                        simulationTableCopy.TableName = kvp_Value.Key;
                        automodTablesList.Add(simulationTableCopy);
                    }
                    // << Task #13361 FP AutoMod Data tables V3
                }
            }
                        
            string sUserPath = sSimulationDirectory + "Data\\User\\";
            if (paParametres.clearAutomodUserData && Directory.Exists(sUserPath))
            {
                //delete all old files that could be found in the Data\User folder
                try
                {
                    DirectoryInfo userDirInfo = new DirectoryInfo(sUserPath);
                    foreach (FileInfo userFile in userDirInfo.GetFiles())
                        userFile.Delete();
                }
                catch (Exception ex)
                {
                    OverallTools.ExternFunctions.PrintLogFile("Saving simulation files warning: Could not delete the old files from the User folder ( "
                        + sUserPath + "): " + ex.Message);
                }
            }
                        
            if (paParametres.ExportUserData)
            {
                if ((paParametres.UserData != null) && (paParametres.UserData.UserData != null))
                {
                    // >> Task #16728 PAX2SIM Improvements (Recurring) C#1
                    Dictionary<string, List<string>> allUserData = getUserData();                    
                    if (Directory.Exists(sUserPath))
                    {
                        //delete user data files that were into the Data\User directory and are not selected to be exported
                        try
                        {
                            DirectoryInfo userDirInfo = new DirectoryInfo(sUserPath);
                            foreach (FileInfo userFile in userDirInfo.GetFiles())
                            {
                                if (allUserData.ContainsKey(userFile.Name) && !paParametres.UserData.UserData.ContainsKey(userFile.Name))
                                    userFile.Delete();
                            }
                        }
                        catch (Exception ex)
                        {
                            OverallTools.ExternFunctions.PrintLogFile("Saving simulation files warning: Could not delete a file from the User folder ( "
                                + sUserPath + "): " + ex.Message);
                        }
                    }
                    // << Task #16728 PAX2SIM Improvements (Recurring) C#1

                    if (paParametres.DynamicReclaimAllocation)
                    {
                        ReclaimAllocation.SaveUserDataForScenario(InputData, sSimulationDirectory + "Data\\User\\", paParametres.UserData.UserData, paParametres.TerminalReclaimAllocation);
                    }
                    else
                    {
                        SaveUserDataForScenario(sSimulationDirectory + "Data\\User\\", paParametres.UserData.UserData);
                    }
                }
            }

            if (paParametres.exportAutomodMainData)
            {
                #region La gestion des settings.

                if (slfForm != null)
                    slfForm.ChargementFichier("Saving settings file");
                System.IO.StreamWriter monEcrivain = new System.IO.StreamWriter(sSimulationDirectory + "Data\\Settings.txt");

                monEcrivain.WriteLine("Ending Time: " + OverallTools.DataFunctions.MinuteDifference(paParametres.DateDebut, paParametres.DateFin).ToString());

                if (paParametres.DisplayModel)
                    monEcrivain.WriteLine("Animation: 1");
                else
                    monEcrivain.WriteLine("Animation: 0");

                if (paParametres.UseMakeUpSegregation)
                    monEcrivain.WriteLine("MU Segregation: 1");
                else
                    monEcrivain.WriteLine("MU Segregation: 0");
                if ((!bSimulatePaxPlan) || (paParametres.Opening_CITable == ""))
                    monEcrivain.WriteLine("Opening CI: 0");
                else
                    monEcrivain.WriteLine("Opening CI: 1");

                // << Task #9412 Pax2Sim - Scenario parameters files - Settings and OpeningOnSaturation            
                /*
                if ((!bSimulatePaxPlan) || (!paParametres.FillQueue))
                    monEcrivain.WriteLine("Filling: 0");
                else
                    monEcrivain.WriteLine("Filling: 1");
                 */
                if (!bSimulatePaxPlan || paParametres.StationGlobalFillingType.Equals(GlobalNames.FIRST_STATION_FILLING_TYPE))
                    monEcrivain.WriteLine("Filling: 0");
                else if (paParametres.StationGlobalFillingType.Equals(GlobalNames.SATURATE_STATION_FILLING_TYPE))
                    monEcrivain.WriteLine("Filling: 1");
                else if (paParametres.StationGlobalFillingType.Equals(GlobalNames.RANDOM_STATION_FILLING_TYPE))
                    monEcrivain.WriteLine("Filling: 2");
                // >> Task #9412 Pax2Sim - Scenario parameters files - Settings and OpeningOnSaturation

                if (paParametres.UseProcessSchedule)
                    monEcrivain.WriteLine("Scheduled process: 1");
                else
                    monEcrivain.WriteLine("Scheduled process: 0");
                /*if ((!bSimulatePaxPlan) || (!paParametres.ReclaimUS))
                    monEcrivain.WriteLine("Reclaim US: 0");
                else
                    monEcrivain.WriteLine("Reclaim US: 1");*/

                // >> Task #10764 Pax2Sim - new User attributes for Groups


                //if (find a way to detect automod version if >= 73 use old algo = 0 else use old algo = 1)
                //monEcrivain.WriteLine("Use Old algo to select transfer desks: 1");
                //else
                monEcrivain.WriteLine("Use Old algo to select transfer desks: 0");
                // << Task #10764 Pax2Sim - new User attributes for Groups

                monEcrivain.WriteLine("");
                if (bSimulatePaxPlan)
                    monEcrivain.WriteLine("PAX: 1");
                else
                    monEcrivain.WriteLine("PAX: 0");
                String sBagLine = "BHS_T";
                if (paParametres.DynamicReclaimAllocation)
                {
                    sBagLine += paParametres.TerminalReclaimAllocation.ToString() + ": 3";

                }
                else if (bSimulateBaggage)
                {
                    sBagLine += paParametres.iTerminal.ToString() + ": ";
                    if (paParametres.ModelName == "Default")
                        sBagLine += "3";
                    else if (paParametres.BagPlan)
                        sBagLine += "2";
                    else
                        sBagLine += "1";
                }
                else
                    sBagLine += "1: 0";
                monEcrivain.WriteLine(sBagLine);

                if (paParametres.TMSSimulation)
                    monEcrivain.WriteLine("TMS: 1");
                else
                    monEcrivain.WriteLine("TMS: 0");

                monEcrivain.Close();
                if (!System.IO.File.Exists(sSimulationDirectory + "Data\\Settings.txt"))
                {
                    ListeErreurs.Add("Err00118 : The \"" + sSimulationDirectory + "Data\\Settings.txt\" haven't be written.");
                    return false;
                }
                #endregion
            }
            return result;
        }

        /// <summary>
        /// Function that will convert and create all the tables that are needed for the simulation (PAX or BHS).
        /// </summary>
        /// <param name="paParametres"></param>
        /// <param name="cht"></param>
        /// <returns></returns>
        private SortedList<String, DataTable> GenerateSimulationFiles(Classes.ParamScenario paParametres, Prompt.SIM_LoadingForm cht)
        {            
            SortedList<String, DataTable> sl_dt_Results = new SortedList<String, DataTable>();
            List<String> lsOrderAirline = null;
            List<String> lsOrderFlightCategory = null;
            if ((paParametres.BagPlan) || (paParametres.PaxSimulation))
            {
                string inputDataSource = "Input";   // >> Bug #19471
                /*if (paParametres.BagPlan && paParametres.BagPlanScenarioName != null && ScenarioExist(paParametres.BagPlanScenarioName))
                    inputDataSource = paParametres.BagPlanScenarioName;*/

                lsOrderAirline = OverallTools.DataFunctions.getOrder(getTable(inputDataSource, paParametres.Airline), GlobalNames.sFPAirline_AirlineCode);
                lsOrderFlightCategory = new List<string>();
                DataTable dtOrder = getTable(inputDataSource, paParametres.OCT_BC);
                for (int i = 1; i < dtOrder.Columns.Count; i++)
                {
                    lsOrderFlightCategory.Add(dtOrder.Columns[i].ColumnName);
                }
                DataTable OCT_FPA = GestionDonneesHUB2SIM.calcOCT_FPA(getTable(inputDataSource, paParametres.FPA),
                                            GetTable(inputDataSource, paParametres.OCT_BC), lsOrderAirline, lsOrderFlightCategory,
                                            paParametres.DateDebut, structureAeroport, bUseAlphNumericForFlightInfo);
                sl_dt_Results.Add("FPA_Table.txt", OCT_FPA);

                // >> Task #13361 FP AutoMod Data tables V3
                List<String> aircraftTypesList = OverallTools.DataFunctions.getOrder(getTable(inputDataSource, paParametres.AircraftType), GlobalNames.sFPAircraft_AircraftTypes);
                DataTable fpa_Table_3 = GestionDonneesHUB2SIM.getFPATable3ForAutomod(getTable(inputDataSource, paParametres.FPA),
                                            GetTable(inputDataSource, paParametres.OCT_BC), lsOrderAirline, lsOrderFlightCategory, aircraftTypesList,
                                            paParametres.DateDebut, structureAeroport, bUseAlphNumericForFlightInfo);
                string fpaTable3TextFileName = FPA_TABLE_3_FOR_AUTOMOD_TABLE_NAME + ".txt";
                sl_dt_Results.Add(fpaTable3TextFileName, fpa_Table_3);
                // << Task #13361 FP AutoMod Data tables V3

                DataTable OCT_FPD = GestionDonneesHUB2SIM.calcOCT_FPD(getTable(inputDataSource, paParametres.FPD),
                                            GetTable(inputDataSource, paParametres.OCT_CI_Table),
                                            GetTable(inputDataSource, paParametres.OCT_BG),                                            
                                            lsOrderAirline,lsOrderFlightCategory,
                                            paParametres.DateDebut, structureAeroport, bUseAlphNumericForFlightInfo);
                sl_dt_Results.Add("FPD_Table.txt", OCT_FPD);

                // << Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop
                DataTable OCT_FPD_2 = GestionDonneesHUB2SIM.calcOCT_FPD_2(getTable(inputDataSource, paParametres.FPD),
                                            GetTable(inputDataSource, paParametres.OCT_CI_Table),
                                            GetTable(inputDataSource, paParametres.OCT_BG),
                                            GetTable(inputDataSource, paParametres.OCT_BagDropTableName),
                                            lsOrderAirline, lsOrderFlightCategory,
                                            paParametres.DateDebut, structureAeroport, bUseAlphNumericForFlightInfo);
                sl_dt_Results.Add("FPD_Table_2.txt", OCT_FPD_2);
                // >> Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop

                // >> Task #13361 FP AutoMod Data tables V3
                DataTable fpd_Table_3 = GestionDonneesHUB2SIM.getFPDTable3ForAutomod(getTable(inputDataSource, paParametres.FPD),
                                            GetTable(inputDataSource, paParametres.OCT_CI_Table),
                                            GetTable(inputDataSource, paParametres.OCT_BG),
                                            GetTable(inputDataSource, paParametres.OCT_BagDropTableName),
                                            GetTable("Input", paParametres.OCT_MakeUp),
                                            lsOrderAirline, lsOrderFlightCategory, aircraftTypesList,
                                            paParametres.DateDebut, structureAeroport, bUseAlphNumericForFlightInfo);
                string fpd3TableTextFileName = FPD_TABLE_3_FOR_AUTOMOD_TABLE_NAME + ".txt";
                sl_dt_Results.Add(fpd3TableTextFileName, fpd_Table_3);
                // << Task #13361 FP AutoMod Data tables V3
            }
            Hashtable htNames = new Hashtable();

            if ((paParametres.PaxSimulation) || ((paParametres.BHSSimulation) && (paParametres.ModelName == "Default")))
            {
                if (getTable("Input", paParametres.Oneof) != null)  // >> Bug #13579 BHS Analysis Assistant
                {
                    DataTable OneofTable = GestionDonneesHUB2SIM.generateOneofAutomod(getTable("Input", paParametres.Oneof), htNames);
                    sl_dt_Results.Add("Oneof.txt", OneofTable);
                }
            }
            if (paParametres.PaxSimulation)
            {

#if(NEWALLOCATIONSECU)
                //<< Task #7405 - new Desk and extra information for Pax                
                DataTable userAttributesTable = getTable("Input", GlobalNames.sUserAttributesTableName);
                //>> Task #7405 - new Desk and extra information for Pax
                List<DataTable> lsSecurityAllocation = GestionDonneesHUB2SIM.generateSecurityTable("Security",
                    getTable("Input", paParametres.Security),
                     paParametres.DateDebut,
                     paParametres.DateFin,
                     false,
                     lsOrderAirline,
                     lsOrderFlightCategory,
                     userAttributesTable,  //>> Task #7405 - new Desk and extra information for Pax
                     paParametres.userAttributesTablesDictionary);  // << Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab
                if (lsSecurityAllocation != null)
                {
                    sl_dt_Results.Add("SecurityAllocation.txt", lsSecurityAllocation[0]);
                    sl_dt_Results.Add("SecurityAllocationFC.txt", lsSecurityAllocation[1]);
                    sl_dt_Results.Add("SecurityAllocationAirline.txt", lsSecurityAllocation[2]);
                    sl_dt_Results.Add("SecurityAllocationFlights.txt", lsSecurityAllocation[3]);
                    //<< Task #7405 - new Desk and extra information for Pax
                    sl_dt_Results.Add("SecurityAllocationUserAtt.txt", lsSecurityAllocation[4]);
                    //>> Task #7405 - new Desk and extra information for Pax
                }

                // << Task #7570 new Desk and extra information for Pax -Phase I B
                List<DataTable> lsUserProcessAllocation = GestionDonneesHUB2SIM.generateSecurityTable("UserProcess",
                    getTable("Input", paParametres.UserProcess),
                     paParametres.DateDebut,
                     paParametres.DateFin,
                     false,
                     lsOrderAirline,
                     lsOrderFlightCategory,
                     userAttributesTable,  //>> Task #7405 - new Desk and extra information for Pax
                     paParametres.userAttributesTablesDictionary); // << Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab
                if (lsUserProcessAllocation != null)
                {
                    sl_dt_Results.Add("UserProcessAllocation.txt", lsUserProcessAllocation[0]);
                    sl_dt_Results.Add("UserProcessAllocationFC.txt", lsUserProcessAllocation[1]);
                    sl_dt_Results.Add("UserProcessAllocationAirline.txt", lsUserProcessAllocation[2]);
                    sl_dt_Results.Add("UserProcessAllocationFlights.txt", lsUserProcessAllocation[3]);
                    //<< Task #7405 - new Desk and extra information for Pax
                    sl_dt_Results.Add("UserProcessAllocationUserAtt.txt", lsUserProcessAllocation[4]);
                    //>> Task #7405 - new Desk and extra information for Pax
                }
                // >> Task #7570 new Desk and extra information for Pax -Phase I B


                List<DataTable> lsTransferAllocation = GestionDonneesHUB2SIM.generateSecurityTable("Transfer",
                    getTable("Input", paParametres.Transfer),
                     paParametres.DateDebut,
                     paParametres.DateFin,
                     false,
                     lsOrderAirline,
                     lsOrderFlightCategory,
                     userAttributesTable,  //>> Task #7405 - new Desk and extra information for Pax
                     paParametres.userAttributesTablesDictionary); // << Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab
                if (lsTransferAllocation != null)
                {
                    sl_dt_Results.Add("TransferAllocation.txt", lsTransferAllocation[0]);
                    sl_dt_Results.Add("TransferAllocationFC.txt", lsTransferAllocation[1]);
                    sl_dt_Results.Add("TransferAllocationAirline.txt", lsTransferAllocation[2]);
                    sl_dt_Results.Add("TransferAllocationFlights.txt", lsTransferAllocation[3]);
                    //<< Task #7405 - new Desk and extra information for Pax
                    sl_dt_Results.Add("TransferAllocationUserAtt.txt", lsTransferAllocation[4]);
                    //>> Task #7405 - new Desk and extra information for Pax
                }


                List<DataTable> lsPassportAllocation = GestionDonneesHUB2SIM.generateSecurityTable("Passport",
                    getTable("Input", paParametres.Passport),
                     paParametres.DateDebut,
                     paParametres.DateFin,
                     false,
                     lsOrderAirline,
                     lsOrderFlightCategory,
                     userAttributesTable,  //>> Task #7405 - new Desk and extra information for Pax
                     paParametres.userAttributesTablesDictionary);  // << Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab
                if (lsPassportAllocation != null)
                {
                    sl_dt_Results.Add("PassportAllocation.txt", lsPassportAllocation[0]);
                    sl_dt_Results.Add("PassportAllocationFC.txt", lsPassportAllocation[1]);
                    sl_dt_Results.Add("PassportAllocationAirline.txt", lsPassportAllocation[2]);
                    sl_dt_Results.Add("PassportAllocationFlights.txt", lsPassportAllocation[3]);
                    //<< Task #7405 - new Desk and extra information for Pax
                    sl_dt_Results.Add("PassportAllocationUserAtt.txt", lsPassportAllocation[4]);
                    //>> Task #7405 - new Desk and extra information for Pax
                }

                DataTable dtSaturationTable = ConvertSaturationTable(getTable("Input", paParametres.Saturation));
                if (dtSaturationTable != null)
                    sl_dt_Results.Add(dtSaturationTable.TableName, dtSaturationTable);
#else
                DataTable SecurityAllocation = generatePassportTable(/*getRacine(),*/ getTable("Input", paParametres.Security),
                    paParametres.DateDebut, paParametres.DateFin);
                sl_dt_Results.Add("SecurityAllocation.txt", SecurityAllocation);
                DataTable TransferAllocation = GestionDonneesHUB2SIM.generateSecurityTable(getTable("Input", paParametres.Transfer),
                    paParametres.DateDebut, paParametres.DateFin);
                sl_dt_Results.Add("TransferAllocation.txt", TransferAllocation);
                 DataTable PassportAllocation = GestionDonneesHUB2SIM.generatePassportTable(getTable("Input", paParametres.Passport),
                    paParametres.DateDebut, paParametres.DateFin);
                sl_dt_Results.Add("PassportAllocation.txt", PassportAllocation);
#endif


                DataTable CheckInAllocation = null;
                if (paParametres.Opening_CITable == "")
                {
                    CheckInAllocation = generateCheckInTable(null, paParametres.DateDebut, paParametres.DateFin);
                }
                else
                {
                    CheckInAllocation = generateCheckInTable(getTable("Input", paParametres.Opening_CITable),
                         paParametres.DateDebut, paParametres.DateFin);
                }
                sl_dt_Results.Add("CheckInTable.txt", CheckInAllocation);


                if (!paParametres.UseProcessSchedule)
                {

                    DataTable PaxPath;
                    DataTable GoalsPaxPath;
                    GestionDonneesHUB2SIM.generatePaxPath(getTable("Input", paParametres.Itinerary),
                            out PaxPath, out GoalsPaxPath, htNames);

                    sl_dt_Results.Add("StepsPlan.txt", PaxPath);
                    sl_dt_Results.Add("GoalsPaxPath.txt", GoalsPaxPath);

                    Dictionary<String, DataTable> dtProcessTimesTables = GestionDonneesHUB2SIM.generateProcessTimes(GetTable("Input", paParametres.ProcessTimes), lsOrderAirline, lsOrderFlightCategory, htNames);
                    //DataTable ProcessTable = 
                    foreach (String sKey in dtProcessTimesTables.Keys)
                    {
                        sl_dt_Results.Add("ProcessingsTimes" + sKey + ".txt", dtProcessTimesTables[sKey]);
                    }
                    //paParametres.Airline

                    // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)                    
                    //get the new version table into a new dictionary and add each element to sl_dt_Results(like above) with _V2 at the end of the txt file
                    Dictionary<String, DataTable> processTimesTablesDictionary = GestionDonneesHUB2SIM.generateProcessTimes_V2(GetTable("Input", paParametres.ProcessTimes),
                        lsOrderAirline, lsOrderFlightCategory, htNames);
                    foreach (String key in processTimesTablesDictionary.Keys)
                        sl_dt_Results.Add(GlobalNames.PROCESSING_TIMES_TEXT_FILE_NAME + "_V2" + key + ".txt", processTimesTablesDictionary[key]);
                    // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)


                    DataTable capaQueues = GestionDonneesHUB2SIM.generateCapaQueuesAutomod("CapaQueuesAutomod", getTable("Input", paParametres.CapaQueues));
                    sl_dt_Results.Add("CapaQueues.txt", capaQueues);
                    // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                    //for now we use the pax2sim capaProcess table. will have to use the capaProcess table from the parameters!
                    DataTable capaProcess = GestionDonneesHUB2SIM.generateCapaQueuesAutomod("CapaProcessAutomod", getTable("Input", paParametres.ProcessCapacities)); // << Task #8757 Pax2Sim - Scenario Properties - Capa Process table selection
                    sl_dt_Results.Add(GlobalNames.CAPA_PROCESS_TEXT_FILE_NAME + ".txt", capaProcess);
                    // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                    DataTable capaGroupQueues = GestionDonneesHUB2SIM.generateCapaQueuesAutomod("GroupQueuesAutomod", getTable("Input", paParametres.GroupQueues));
                    sl_dt_Results.Add("GroupQueues.txt", capaGroupQueues);
                }
                else
                {
                    DataTable[] PaxPath;
                    DataTable[] GoalsPaxPath;
                    DataTable ItinerarySchedule;
                    generatePaxPath(getTable("Input", paParametres.ProcessSchedule),
                            out PaxPath, out GoalsPaxPath, out ItinerarySchedule, htNames, paParametres.DateDebut, paParametres.DateFin);
                    if (ItinerarySchedule == null)
                        return null;
                    sl_dt_Results.Add("ScheduleItinerary.txt", ItinerarySchedule);
                    for (int i = 0; i < PaxPath.Length; i++)
                    {
                        sl_dt_Results.Add("StepsPlan_" + (i + 1).ToString() + ".txt", PaxPath[i]);
                        sl_dt_Results.Add("GoalsPaxPath_" + (i + 1).ToString() + ".txt", GoalsPaxPath[i]);
                    }

                    List<Dictionary<String,DataTable>> AutomodProcess;
                    DataTable ProcessSchedule;
                    generateProcessTimes(getTable("Input", paParametres.ProcessSchedule), out AutomodProcess, out ProcessSchedule,lsOrderAirline, lsOrderFlightCategory, htNames, paParametres.DateDebut, paParametres.DateFin);
                    if (ProcessSchedule == null)
                        return null;
                    sl_dt_Results.Add("ScheduleProcess.txt", ProcessSchedule);
                    for (int i = 0; i < AutomodProcess.Count; i++)
                    {
                        foreach (String sKey in AutomodProcess[i].Keys)
                        {
                            //sl_dt_Results.Add("ProcessingsTimes" + sKey + ".txt", dtProcessTimesTables[sKey]);
                            sl_dt_Results.Add("ProcessingsTimes_" + (i + 1).ToString()  +sKey + ".txt", AutomodProcess[i][sKey]);
                        }
                    }

                    // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                    AutomodProcess.Clear();
                    generateProcessTimes_V2(getTable("Input", paParametres.ProcessSchedule),
                        out AutomodProcess, out ProcessSchedule, lsOrderAirline, lsOrderFlightCategory, htNames,
                        paParametres.DateDebut, paParametres.DateFin);
                    for (int i = 0; i < AutomodProcess.Count; i++)
                    {
                        foreach (String key in AutomodProcess[i].Keys)
                        {
                            sl_dt_Results.Add(GlobalNames.PROCESSING_TIMES_TEXT_FILE_NAME + "_V2_" + (i + 1).ToString() + key + ".txt", AutomodProcess[i][key]);
                        }
                    }
                    // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)

                    DataTable[] AutomodGroupQueues;
                    DataTable GroupQueuesSchedule;
                    generateGroupQueuesAutomod(getTable("Input", paParametres.ProcessSchedule), out AutomodGroupQueues, out GroupQueuesSchedule, paParametres.DateDebut, paParametres.DateFin);
                    if (GroupQueuesSchedule == null)
                        return null;
                    sl_dt_Results.Add("ScheduleGroupQueues.txt", GroupQueuesSchedule);
                    for (int i = 0; i < AutomodGroupQueues.Length; i++)
                    {
                        sl_dt_Results.Add("GroupQueues_" + (i + 1).ToString() + ".txt", AutomodGroupQueues[i]);
                    }

                    DataTable[] AutomodCapaQueues;
                    DataTable CapaQueuesSchedule;
                    generateCapaQueuesAutomod(getTable("Input", paParametres.ProcessSchedule), out AutomodCapaQueues, out CapaQueuesSchedule, paParametres.DateDebut, paParametres.DateFin);
                    if (CapaQueuesSchedule == null)
                        return null;
                    sl_dt_Results.Add("ScheduleCapaQueues.txt", CapaQueuesSchedule);
                    for (int i = 0; i < AutomodCapaQueues.Length; i++)
                    {
                        sl_dt_Results.Add("CapaQueues_" + (i + 1).ToString() + ".txt", AutomodCapaQueues[i]);                        
                    }

                    // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)                    
                    //does the same thing as generateCapaQueuesAutomod, but changes the column name for the ScheduleCapaProcess.txt to CapaProcess Version
                    generateCapaQueuesAutomod_V2(getTable("Input", paParametres.ProcessSchedule), out AutomodCapaQueues, out CapaQueuesSchedule, paParametres.DateDebut, paParametres.DateFin);
                    sl_dt_Results.Add(GlobalNames.SCHEDULE_CAPA_PROCESS_FILE_NAME + ".txt", CapaQueuesSchedule);
                    
                    for (int i = 0; i < AutomodCapaQueues.Length; i++)
                    {   
                        sl_dt_Results.Add(GlobalNames.CAPA_PROCESS_TEXT_FILE_NAME + "_" + (i + 1).ToString() + ".txt", AutomodCapaQueues[i]);                        
                    }
                    // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)

                }
                if ((PAX2SIM.bAnimatedQueues) && (paParametres.AnimatedQueues != ""))
                {
                    DataTable AnimQueues = GestionDonneesHUB2SIM.generateAnimatedQueues("AM_Anim_Queues", getTable("Input", paParametres.AnimatedQueues));
                    sl_dt_Results.Add("Animated_Queues.txt", AnimQueues);
                }

                DataTable StructAeroport = GestionDonneesHUB2SIM.generateAiportStructure(getRacine());
                sl_dt_Results.Add("AirportStructure.txt", StructAeroport);
            }

            /*SGE : 11/06/2012 : Ajout de l'exportation des exceptions MakeUp vers le modèle Automod.*/
            if ((paParametres.BHSSimulation) &&  ((paParametres.UsePaxPlan) || (paParametres.BagPlan)))
            {
                int iTerminal = paParametres.iTerminal;
                String sPrefixeTerminal = GlobalNames.sBHS_Prefixe + iTerminal.ToString() + "_";
                NormalTable ntOCTMakeUpTable = GetTable("Input", paParametres.OCT_MakeUp);
                
                sl_dt_Results.Add(sPrefixeTerminal + "OCT_MakeUp.txt", ntOCTMakeUpTable.Table);
                sl_dt_Results.Add("MakeUp_OCT.txt", ntOCTMakeUpTable.Table);
                if(typeof(ExceptionTable).IsInstanceOfType( ntOCTMakeUpTable ))
                {
                    ExceptionTable etOCTMakeUpTable = (ExceptionTable)ntOCTMakeUpTable;

                    if(etOCTMakeUpTable.ExceptionFlight != null)
                    {
                        DataTable dtTable = etOCTMakeUpTable.ExceptionFlight.Table;
                        if (dtTable != null)
                        {
                            dtTable = dtTable.Copy();
                            for(int i=1;i<dtTable.Columns.Count;i++)
                            {
                                dtTable.Columns[i].ColumnName = dtTable.Columns[i].ColumnName.Substring(2);
                            }
                            sl_dt_Results.Add(sPrefixeTerminal + "OCT_MakeUpFlight.txt", dtTable);
                            sl_dt_Results.Add("MakeUp_OCT_Flight.txt", dtTable);
                        }
                    }
                    
                    if(etOCTMakeUpTable.ExceptionAirline != null)
                    {
                        //sPrefixeTerminal + "OCT_MakeUpAirline.txt"
                        DataTable dtTable = etOCTMakeUpTable.ExceptionAirline.Table;
                        if (dtTable != null)
                        {
                            dtTable = dtTable.Copy();
                            for (int i = 1; i < dtTable.Columns.Count; i++)
                            {
                                dtTable.Columns[i].ColumnName = lsOrderAirline.IndexOf( dtTable.Columns[i].ColumnName).ToString();
                            }
                            sl_dt_Results.Add(sPrefixeTerminal + "OCT_MakeUpAirline.txt", dtTable);
                            sl_dt_Results.Add("MakeUp_OCT_Airline.txt", dtTable);
                        }
                    }
                }

                if (paParametres.UseMakeUpSegregation)
                {
                    NormalTable segregationTable = GetTable("Input", "Segregation");
                    if (segregationTable != null && segregationTable.Table != null)
                    {
                        sl_dt_Results.Add("MakeUp_Segregations.txt", segregationTable.Table);
                        if (paParametres.UseExSegregation)
                        {
                            if (typeof(ExceptionTable).IsInstanceOfType(segregationTable))
                            {
                                ExceptionTable exceptionTable = (ExceptionTable)segregationTable;
                                if (exceptionTable != null && exceptionTable.ExceptionFlight != null)
                                {
                                    DataTable dtTable = exceptionTable.ExceptionFlight.Table;
                                    if (dtTable != null)
                                    {
                                        dtTable = dtTable.Copy();
                                        for (int i = 1; i < dtTable.Columns.Count; i++)
                                        {
                                            dtTable.Columns[i].ColumnName = dtTable.Columns[i].ColumnName.Substring(2);
                                        }
                                        sl_dt_Results.Add("MakeUp_Segregations_Flight.txt", dtTable);
                                    }
                                }
                                if (exceptionTable != null && exceptionTable.ExceptionAirline != null)
                                {
                                    DataTable dtTable = exceptionTable.ExceptionAirline.Table;
                                    if (dtTable != null)
                                    {
                                        dtTable = dtTable.Copy();
                                        for (int i = 1; i < dtTable.Columns.Count; i++)
                                        {
                                            dtTable.Columns[i].ColumnName = lsOrderAirline.IndexOf(dtTable.Columns[i].ColumnName).ToString();
                                        }
                                        sl_dt_Results.Add("MakeUp_Segregations_Airline.txt", dtTable);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            /*End SGE : 11/06/2012 : Ajout de l'exportation des exceptions MakeUp vers le modèle Automod.*/
            if ((paParametres.BHSSimulation) && (paParametres.ModelName == "Default"))
            {
                string key = "";
                //BHSAirportStructure==>BHS_T4_Structure.txt
                DataTable StructAeroport = GestionDonneesHUB2SIM.generateAiportStructureForBHS(getRacine(), paParametres.iTerminal);
                key = StructAeroport.TableName + ".txt";
                if (!sl_dt_Results.ContainsKey(key))
                    sl_dt_Results.Add(key, StructAeroport);
                
                //BHSPath==>BHS_T4_StepsPlan.txt
                DataTable BHSPath = GestionDonneesHUB2SIM.generateBHSPath(getTable("Input", GlobalNames.sBHS_Itinerary), paParametres.iTerminal, htNames);
                key = BHSPath.TableName + ".txt";
                if (!sl_dt_Results.ContainsKey(key))
                    sl_dt_Results.Add(key, BHSPath);

                //BHSPath==>BHS_T4_GroupQueues.txt
                DataTable capaGroupQueues = GestionDonneesHUB2SIM.generateBHSCapaQueuesAutomod("BHSGroupQueuesAutomod", getTable("Input", GlobalNames.sBHS_Group_Queues));
                key = capaGroupQueues.TableName + ".txt";
                if (!sl_dt_Results.ContainsKey(key))
                    sl_dt_Results.Add(key, capaGroupQueues);
                
                //BHSPath==>BHS_T4_CapaQueues.txt
                capaGroupQueues = GestionDonneesHUB2SIM.generateBHSCapaQueuesAutomod("BHSCapaQueuesAutomod", getTable("Input", GlobalNames.sBHS_Capa_Queues));
                key = capaGroupQueues.TableName + ".txt";
                if (!sl_dt_Results.ContainsKey(key))
                    sl_dt_Results.Add(key, capaGroupQueues);
            }
            return sl_dt_Results;
        }
        #endregion

        #region Fonction pour la génération des fichiers pour modifier le modèle Automod
        private Boolean GenerateSimulationDirectories()
        {
            String sRoot = System.IO.Path.GetPathRoot(Application.StartupPath);
            if (!OverallTools.ExternFunctions.CheckCreateDirectory(sRoot + "Temp\\Model"))
            {
                ListeErreurs.Add("Err00109 : Unable to create the Model directory.");
                OverallTools.ExternFunctions.PrintLogFile("Err00109 : Unable to create the Model directory.");
                return false;
            }

            if (!OverallTools.ExternFunctions.CheckCreateDirectory(sRoot + "Temp\\Model\\Data"))
            {
                ListeErreurs.Add("Err00110 : Unable to create the Data directory.");
                OverallTools.ExternFunctions.PrintLogFile("Err00110 : Unable to create the Data directory.");
                return false;
            }

            // >> Outputs deletion issue
            string outputsDirectoryPath = sRoot + "Temp\\Model\\Outputs";
            if (System.IO.Directory.Exists(outputsDirectoryPath))
            {
                System.IO.DirectoryInfo di = new DirectoryInfo(outputsDirectoryPath);
                if (di != null)
                {
                    if (di.GetFiles() != null && di.GetFiles().Length > 0)
                    {
                        foreach (FileInfo file in di.GetFiles())
                            file.Delete();
                    }
                    if (di.GetDirectories() != null && di.GetDirectories().Length > 0)
                    {
                        foreach (DirectoryInfo dir in di.GetDirectories())                        
                            dir.Delete(true);                        
                    }
                }
            }
            else
            {
                if (!OverallTools.ExternFunctions.CheckCreateDirectory(outputsDirectoryPath))
                {
                    ListeErreurs.Add("Err00111 : Unable to create the Output directory.");
                    OverallTools.ExternFunctions.PrintLogFile("Err00111 : Unable to create the Output directory.");
                    return false;
                }
            }            
            //if (!OverallTools.ExternFunctions.DeleteDirectory(sRoot + "Temp\\Model\\Outputs"))
            //{
            //    ListeErreurs.Add("Err00195 : Unable to empty the output directory of the model.");
            //    return false;
            //}
            //if (!OverallTools.ExternFunctions.CheckCreateDirectory(sRoot + "Temp\\Model\\Outputs"))
            //{
            //    ListeErreurs.Add("Err00111 : Unable to create the Output directory.");
            //    return false;
            //}
            // << Outputs deletion issue

            return true;
        }
        #endregion

        #region Fonction pour la génération des fichiers utilisés par le modèle Automod

        internal bool SaveSimulationFiles(String nomScenario,
                                          String sSimulationDirectory,
                                            SIM_LoadingForm slfForm)
        {
            Classes.ParamScenario paParametres = GetScenario(nomScenario);
            DataManagerInput gdDonnee = InputData;

            if (gdDonnee == null)
            {
                ListeErreurs.Add("Err00215 : Unable to export the data for the simulation.");
                return false;
            }
            if ((paParametres.SimReporterInputData != null) && (paParametres.SimReporterInputData.UserData != null))
            {
                Dictionary<String, String> htData = paParametres.SimReporterInputData.UserData;
                foreach (String sKey in htData.Keys)
                {
                    DataTable dtTable = gdDonnee.GetTable(htData[sKey]).Table;
                    if (dtTable == null)
                        return false;
                    OverallTools.FonctionUtiles.EcritureFichier(dtTable, sSimulationDirectory + "\\Data\\" + sKey + ".txt", "\t", false);
                }
            }
            return true;
        }

        private bool saveFile(String nomDataset, String nomTable, String path, bool bMeanFlows, DateTime dtBegin)
        {
            DataTable dtTable = getTable(nomDataset, nomTable);
            if (dtTable == null)
            {
                ListeErreurs.Add("Err00115 : The " + nomTable + " table for simulation is not valid.");
                return false;
            }
            if (bMeanFlows)
            {
                /*We are going to convert the mean flows tables into simple meanflows table.*/
                DataTable dtTable2 = new DataTable(dtTable.TableName);
                int i;

                for (i = 0; i < dtTable.Columns.Count; i++)
                {
                    if (i == 0)
                        dtTable2.Columns.Add(dtTable.Columns[0].ColumnName, typeof(Double));
                    else
                        dtTable2.Columns.Add(dtTable.Columns[i].ColumnName, dtTable.Columns[i].DataType);
                }
                Double[] iDefaultValues = new Double[dtTable.Columns.Count - 1];
                for (i = 0; i < iDefaultValues.Length; i++)
                    iDefaultValues[i] = 0;
                bool bStarted = false;
                DataRow drNewRow = null;
                for (i = 0; i < dtTable.Rows.Count; i++)
                {
                    DateTime dtTmp = (DateTime)dtTable.Rows[i][0];
                    if (dtTmp < dtBegin)
                        continue;
                    if (!bStarted)
                    {
                        bStarted = true;
                        if (i != 0)
                        {
                            for (int j = 1; j < dtTable.Columns.Count; j++)
                            {
                                iDefaultValues[j - 1] = FonctionsType.getDouble(dtTable.Rows[i - 1][j], dtTable.Columns[j].DataType);
                            }
                        }
                        drNewRow = dtTable2.NewRow();
                        drNewRow[0] = 0;
                        for (int j = 1; j < dtTable.Columns.Count; j++)
                            drNewRow[j] = drNewRow[j - 1];
                        dtTable2.Rows.Add(drNewRow);
                    }
                    Double dDiff = OverallTools.DataFunctions.MinuteDifference(dtBegin, dtTmp);
                    drNewRow = dtTable2.NewRow();
                    drNewRow[0] = dDiff;
                    for (int j = 1; j < dtTable.Columns.Count; j++)
                        drNewRow[j] = dtTable.Rows[i][j];
                    dtTable2.Rows.Add(drNewRow);
                }
                dtTable = dtTable2;
            }
            return saveFile(dtTable, path);
        }
        private bool saveFile(String nomDataset, String nomTable, String path)
        {
            return saveFile(nomDataset, nomTable, path, false, new DateTime());
        }
        private bool saveFile(DataTable dtTable, String path)
        {
            if (dtTable == null)
            {
                ListeErreurs.Add("Err00024 : Unable to export a table for the simulation.");
                return false;
            }

            OverallTools.FonctionUtiles.EcritureFichier(dtTable, path, "\t", false);
            if (!System.IO.File.Exists(path))
            {
                ListeErreurs.Add("Err00116 : The " + path + " hadn't be written.");
                return false;
            }
            return true;
        }

        #region Exportation des fichiers pour la partie BHS
        private bool SaveBHSSimulationFile(Classes.ParamScenario pbhsNomScenario, String sDirectory)
        {
            if (pbhsNomScenario == null)
                return false;
            int iTerminal = pbhsNomScenario.iTerminal;
            /*String Terminal = pbhsNomScenario.Terminal.Replace("Terminal", "");
            if (!Int32.TryParse(Terminal, out iTerminal))
                iTerminal = 1;*/
            String sPrefixeTerminal = GlobalNames.sBHS_Prefixe + iTerminal.ToString() + "_";

            bool bResult = saveFile("Input", pbhsNomScenario.CICollectors, sDirectory + "\\" + sPrefixeTerminal + GlobalNames.sBHS_CI_Collectors + ".txt");
            bResult = saveFile("Input", pbhsNomScenario.General, sDirectory + "\\" + sPrefixeTerminal + GlobalNames.sBHS_General + ".txt") && bResult;
            bResult = saveFile("Input", pbhsNomScenario.ArrivalInfeedGroups, sDirectory + "\\" + sPrefixeTerminal + GlobalNames.sBHS_ArrivalInfeed_Groups + ".txt") && bResult;
            bResult = saveFile("Input", pbhsNomScenario.CIGroups, sDirectory + "\\" + sPrefixeTerminal + GlobalNames.sBHS_CI_Groups + ".txt") && bResult;
            bResult = saveFile("Input", pbhsNomScenario.TransferInfeedGroups, sDirectory + "\\" + sPrefixeTerminal + GlobalNames.sBHS_TransferInfeed_Groups + ".txt") && bResult;
            bResult = saveFile("Input", pbhsNomScenario.CIRouting, sDirectory + "\\" + sPrefixeTerminal + GlobalNames.sBHS_CI_Routing + ".txt") && bResult;
            bResult = saveFile("Input", pbhsNomScenario.HBS3Routing, sDirectory + "\\" + sPrefixeTerminal + GlobalNames.sBHS_HBS3_Routing + ".txt") && bResult;
            bResult = saveFile("Input", pbhsNomScenario.TransferRouting, sDirectory + "\\" + sPrefixeTerminal + GlobalNames.sBHS_Transfer_Routing + ".txt") && bResult;
            bResult = saveFile("Input", pbhsNomScenario.FlowSplit, sDirectory + "\\" + sPrefixeTerminal + GlobalNames.sBHS_Flow_Split + ".txt") && bResult;
            bResult = saveFile("Input", pbhsNomScenario.Process, sDirectory + "\\" + sPrefixeTerminal + GlobalNames.sBHS_Process + ".txt") && bResult;
            if ((pbhsNomScenario.UsePaxPlan) || (pbhsNomScenario.BagPlan))
            {
                /*SGE : 11/06/2012 : Ajout de l'exportation des exceptions MakeUp vers le modèle Automod.*/
                //bResult = saveFile("Input", pbhsNomScenario.OCT_MakeUp, sDirectory + "\\" + sPrefixeTerminal + "OCT_MakeUp.txt") && bResult;
                /*End SGE : 11/06/2012 : Ajout de l'exportation des exceptions MakeUp vers le modèle Automod.*/
                
                bResult = saveFile("Input", pbhsNomScenario.ArrivalContainers, sDirectory + "\\" + sPrefixeTerminal + GlobalNames.sBHS_Arrival_Containers + ".txt") && bResult;
                if (pbhsNomScenario.ModelName == "Default")
                {
                    bResult = saveFile(pbhsNomScenario.Name, "BHSCapaQueuesAutomod", sDirectory + "\\" + sPrefixeTerminal + "CapaQueues.txt") && bResult;
                    bResult = saveFile(pbhsNomScenario.Name, "BHSGroupQueuesAutomod", sDirectory + "\\" + sPrefixeTerminal + "GroupQueues.txt") && bResult;
                    bResult = saveFile(pbhsNomScenario.Name, "BHSAirportStructure", sDirectory + "\\" + sPrefixeTerminal + "Structure.txt") && bResult;
                    bResult = saveFile(pbhsNomScenario.Name, "BHSPath", sDirectory + "\\" + sPrefixeTerminal + "StepsPlan.txt") && bResult;
                }
            }
            else
            {
                /*We are going to convert the mean flows tables into simple meanflows table.*/
                bResult = saveFile("Input", pbhsNomScenario.ArrivalMeanFlows, sDirectory + "\\" + sPrefixeTerminal + GlobalNames.sBHS_Mean_Flows_Arrival_Infeed + ".txt", true, pbhsNomScenario.DateDebut) && bResult;
                bResult = saveFile("Input", pbhsNomScenario.CheckInMeanFlows, sDirectory + "\\" + sPrefixeTerminal + GlobalNames.sBHS_Mean_Flows_Check_In + ".txt", true, pbhsNomScenario.DateDebut) && bResult;
                bResult = saveFile("Input", pbhsNomScenario.TransferMeanFlows, sDirectory + "\\" + sPrefixeTerminal + GlobalNames.sBHS_Mean_Flows_Transfer_Infeed + ".txt", true, pbhsNomScenario.DateDebut) && bResult;
            }
            return true;
        }
        #endregion

        #endregion

        #region Fonction pour mettre à jour un scénario djà existant.
        internal Hashtable Maj_Scenario(String Name,
                                 TreeNode tnScenario,
                                 ContextMenuStrip cmsContextMenuInput,
                                 Classes.ParamScenario parametres,
                                PAX2SIM.InsertPRKResultsDelegate InsertPRKResults,
                                 Prompt.SIM_LoadingForm cht,
                                 ContextMenuStrip cmsContextMenuFilter,
                                 ContextMenuStrip cmsAutomodMenu, 
                                 ContextMenuStrip cmsExceptionTable,
                                 ContextMenuStrip cmsExportScenarioTables)
        {
            if (GetDataManager(Name) == null)
            {
                ListeErreurs.Add("Err00085 : This name does not appear in the data base. Please check for mistakes in data.");
                return null;
            }
            ReplaceScenario(Name, parametres);
            Hashtable htResult_Pkg = MAJ_tablesScenario(Name, InsertPRKResults, cht, getPerimeter());
            if (tnScenario != null)
            {
                UpdateTreeNode(Name, tnScenario, parametres, cmsAutomodMenu, cmsExportScenarioTables);
                UpdateScenarioStaticTables(Name, tnScenario, cmsContextMenuInput, cmsContextMenuFilter, cmsExceptionTable, cmsExportScenarioTables);
            }
            return htResult_Pkg;

        }
        public void Maj_Scenario(String Name,
                                 TreeNode tnScenario,
                                 ContextMenuStrip cmsContextMenuInput,
                                 ContextMenuStrip cmsContextMenuFilter,
                                 ContextMenuStrip cmsAutomodMenu, 
                                 ContextMenuStrip cmsExceptionTable,
                                 ContextMenuStrip cmsExportScenarioTables)
        {
            if (GetDataManager(Name) == null)
            {
                ListeErreurs.Add("Err00086 : This name does not appear in the data base. Please check for mistakes in data.");
                return;
            }
            Classes.ParamScenario param = GetScenario(Name);
            if (param != null)
            {
                UpdateTreeNode(Name, tnScenario, param, cmsAutomodMenu, cmsExportScenarioTables);
                UpdateScenarioStaticTables(Name, tnScenario, /*param,*/ cmsContextMenuInput, cmsContextMenuFilter, cmsExceptionTable, cmsExportScenarioTables);
            }
        }
        public TreeNode AddReplaceScenarioResultsTableTree(String ScenarioName, TreeNode tnScenario, String TableName, ContextMenuStrip cmsContextMenuInput, DataTable Table, Boolean CalculatedFromTrace)
        {
            if (!ScenarioExist(ScenarioName))
            {
                ListeErreurs.Add("Err00087 : This name does not appear in the data base. Please check for mistakes in data.");
                return null;
            }
            if (tnScenario == null)
                return null;
            if (Table == null)
            {
                RemoveTable(ScenarioName, TableName);
                return null;
            }
            
            DataManager data = GetDataManager(ScenarioName);
            if (data == null)
                return null;
            if (typeof(DataManagerPaxBHS) != data.GetType() && typeof(DataManagerAllocation) != data.GetType())
                return null;

            if (data is DataManagerPaxBHS)
            {
                DataManagerPaxBHS gsData = (DataManagerPaxBHS)GetDataManager(ScenarioName);
                if (gsData.GetTable(Table.TableName) != null)
                {
                    gsData.UpdateTable(Table, CalculatedFromTrace);
                    // << Task #13391 IST tables standardization comment#47
                    TreeNode tableNode = OverallTools.TreeViewFunctions.RechercherNom(Table.TableName, tnScenario);
                    if (tableNode == null)
                    {
                        TreeViewTag Tag = TreeViewTag.getTableNode(ScenarioName, Table.TableName);
                        TreeNode result = OverallTools.TreeViewFunctions.createBranch(Table.TableName, Table.TableName, Tag, cmsContextMenuInput);
                        OverallTools.TreeViewFunctions.AddSortedNode(tnScenario, result);
                    }
                    return tableNode;
                    //return OverallTools.TreeViewFunctions.RechercherNom(Table.TableName, tnScenario);
                    // >> Task #13391 IST tables standardization comment#47
                }
                else
                {
                    gsData.AddTable(Table, new VisualisationMode(false, false, true, null, new int[1] { 0 }));
                    gsData.UpdateTable(Table, CalculatedFromTrace);
                    TreeViewTag Tag = TreeViewTag.getTableNode(ScenarioName, Table.TableName);
                    TreeNode result = OverallTools.TreeViewFunctions.createBranch(Table.TableName, Table.TableName, Tag, cmsContextMenuInput);
                    OverallTools.TreeViewFunctions.AddSortedNode(tnScenario, result);
                    return result;
                }
            }
            else if (data is DataManagerAllocation) // Bug #20103 PAX2SIM - View statistics right-click menu option
            {
                if (data.GetTable(Table.TableName) != null)
                {
                    data.UpdateTable(Table);
                    // << Task #13391 IST tables standardization comment#47
                    TreeNode tableNode = OverallTools.TreeViewFunctions.RechercherNom(Table.TableName, tnScenario);
                    if (tableNode == null)
                    {
                        TreeViewTag Tag = TreeViewTag.getTableNode(ScenarioName, Table.TableName);
                        TreeNode result = OverallTools.TreeViewFunctions.createBranch(Table.TableName, Table.TableName, Tag, cmsContextMenuInput);
                        OverallTools.TreeViewFunctions.AddSortedNode(tnScenario, result);
                    }
                    return tableNode;
                    //return OverallTools.TreeViewFunctions.RechercherNom(Table.TableName, tnScenario);
                    // >> Task #13391 IST tables standardization comment#47
                }
                else
                {
                    data.AddTable(Table, new VisualisationMode(false, false, true, null, new int[1] { 0 }));
                    data.UpdateTable(Table);
                    TreeViewTag Tag = TreeViewTag.getTableNode(ScenarioName, Table.TableName);
                    TreeNode result = OverallTools.TreeViewFunctions.createBranch(Table.TableName, Table.TableName, Tag, cmsContextMenuInput);
                    OverallTools.TreeViewFunctions.AddSortedNode(tnScenario, result);
                    return result;
                }
            }
            return null;
        }

        #endregion

        #region Fonctions pour l'ajout des tables de résultat pour le scénario courant.
        public TreeNode AddReplaceScenarioResultsTableTree(String ScenarioName, TreeNode tnScenario, String TableName, ContextMenuStrip cmsContextMenuInput, DataTable Table)
        {
            return AddReplaceScenarioResultsTableTree(ScenarioName, tnScenario, TableName, cmsContextMenuInput, Table, false);
        }
        
        public TreeNode getDynamicNode(String ScenarioName, TreeNode tnScenario)
        {
            if (!ScenarioExist(ScenarioName))
            {
                ListeErreurs.Add("Err00088 : This name does not appear in the data base. Please check for mistakes in data.");
                return null;
            }
            if (tnScenario == null)
                return null;
            TreeNode tmp = OverallTools.TreeViewFunctions.RechercherNomEnfantStrict(sPaxCapacityAnalysis, tnScenario);
            if (tmp == null)
            {
                tmp = createDynamicBranch();
                tnScenario.Nodes.Add(tmp);
            }
            return tmp;
        }
        public TreeNode AddReplaceScenarioResultsTable(String ScenarioName, TreeNode tnScenario, String TableName, ContextMenuStrip cmsContextMenuInput, DataTable Table)
        {
            if (!ScenarioExist(ScenarioName))
            {
                ListeErreurs.Add("Err00089 : This name does not appear in the data base. Please check for mistakes in data.");
                return null;
            }
            if (tnScenario == null)
                return null;
            if (Table == null)
            {
                RemoveTable(ScenarioName, TableName);
                return null;
            }
            DataManager gsData = GetDataManager(ScenarioName);
            if (gsData.GetTable(Table.TableName) != null)
            {
                gsData.UpdateTable(Table);
                return OverallTools.TreeViewFunctions.RechercherNom(Table.TableName, tnScenario);
            }
            else
            {
                gsData.AddTable(Table, new VisualisationMode(false, false, true, null, new int[1] { 0 }));
                TreeNode tmp = OverallTools.TreeViewFunctions.RechercherNomEnfantStrict(sPaxCapacityAnalysis, tnScenario);
                if (tmp == null)
                {
                    tmp = createDynamicBranch();
                    tnScenario.Nodes.Add(tmp);
                    if (tmp == null)
                        return null;
                }
                if (OverallTools.TreeViewFunctions.RechercherNomEnfants(Table.TableName, tmp) == null)
                {

                    TreeViewTag Tag = TreeViewTag.getTableNode(ScenarioName, Table.TableName);
                    TreeNode result = OverallTools.TreeViewFunctions.createBranch(Table.TableName, Table.TableName, Tag, cmsContextMenuInput);
                    tmp.Nodes.Add(result);
                    return result;
                }
            }
            return null;
        }

        #endregion

        #region Fonction pour mettre à jour l'arborescence du treeview avec les différentes tables qui doivent y apparaître.

        private void UpdateScenarioStaticTable(String sScenarioName,
                                               String sNodeName,
                                               String[] tsTablesNames,
                                               TreeNode tnRacine,
                                               bool bRemove,
                                               ContextMenuStrip cmsContextMenuInput,
                                               ContextMenuStrip cmsContextMenuFilter, 
                                               ContextMenuStrip cmsMenuException,
                                               ContextMenuStrip cmsExportScenarioTables)
        {
            TreeNode tnNode = OverallTools.TreeViewFunctions.RechercherNomEnfantStrict(sNodeName, tnRacine);
            if (tnNode == null)
                return;
            if (tnNode.Nodes.Count > 0)
            {
                tnNode.Nodes.Clear();
            }
            DataManager gs = GetDataManager(sScenarioName);
            if (gs == null)
                return;
            TreeNode tnAirline = OverallTools.TreeViewFunctions.CreateDirectory("Airline", cmsExportScenarioTables);
            TreeNode tnTerminal = OverallTools.TreeViewFunctions.CreateDirectory("Terminal", cmsExportScenarioTables);
            TreeNode tnFC = OverallTools.TreeViewFunctions.CreateDirectory("FlightCategory", cmsExportScenarioTables);
            // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
            TreeNode flightSubcategoriesNode = OverallTools.TreeViewFunctions.CreateDirectory("Flight Subcategory", cmsExportScenarioTables);            
            // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

            // << Task #9260 Pax2Sim - Static Analysis - EBS algorithm - EBS per Terminal
            TreeNode EBSTreeNode = OverallTools.TreeViewFunctions.CreateDirectory(GlobalNames.ebsDirectoryName, cmsExportScenarioTables);
            // >> Task #9260 Pax2Sim - Static Analysis - EBS algorithm - EBS per Terminal

            bool bAdded = false;
            bool bAddedTerminal = false;
            bool bAddedFC = false;
            bool addedFlightSubcategoryDirectory = false;   // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation

            foreach (String sTableName in tsTablesNames)
            {
                if (gs.Exist(sTableName))
                {
                    // >> Bug #13367 Liege allocation                    
                    if (sTableName == GlobalNames.FPI_TableName)
                    {
                        // Scenario Allocation FlightPlan Information table for gantt
                        VisualisationMode myMode = new VisualisationMode(true, false, true,
                            new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28 },
                            null, false, false,
                            Color.White, Color.Blue, Color.Black, Color.White, VisualisationMode.SelectionModeEnum.Cell, VisualisationMode.EditModeEnum.Cell,
                            new int[] { 0 }, null, null, null, null);
                        AddReplaceModeVisualisation(sScenarioName, sTableName, myMode);
                    }
                    // << Bug #13367 Liege allocation

                    TreeViewTag Tag = TreeViewTag.getTableNode(sScenarioName, sTableName);
                    TreeNode tnNewTable = OverallTools.TreeViewFunctions.createBranch(sTableName, sTableName, Tag, cmsContextMenuInput);

                    if (PAX2SIM.liegeMode)
                    {
                        tnNode.Nodes.Add(tnNewTable);
                    }
                    else
                    {
                        // << Task #9260 Pax2Sim - Static Analysis - EBS algorithm - EBS per Terminal
                        if (sTableName.Contains("EBS") && sTableName.Contains("Terminal"))
                        {
                            EBSTreeNode.Nodes.Add(tnNewTable);
                        }
                        // >> Task #9260 Pax2Sim - Static Analysis - EBS algorithm - EBS per Terminal
                        else if (sTableName.Contains("Airline"))
                        {
                            //tnAirline
                            tnAirline.Nodes.Add(tnNewTable);
                            if (!bAdded)
                            {
                                bAdded = true;
                                tnNode.Nodes.Add(tnAirline);
                            }
                        }
                        else if (sTableName.Contains("Terminal"))
                        {
                            //tnAirline
                            tnTerminal.Nodes.Add(tnNewTable);
                            if (!bAddedTerminal)
                            {
                                bAddedTerminal = true;
                                tnNode.Nodes.Add(tnTerminal);
                            }
                        }
                        else if (sTableName.Contains("_FC"))
                        {
                            //tnAirline
                            tnFC.Nodes.Add(tnNewTable);
                            if (!bAddedFC)
                            {
                                bAddedFC = true;
                                tnNode.Nodes.Add(tnFC);
                            }
                        }
                        else if (sTableName.Contains(GlobalNames.flight_subcategory_table_suffix))  // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                        {
                            flightSubcategoriesNode.Nodes.Add(tnNewTable);
                            //treeNode: FlightSubcategory
                            if (!addedFlightSubcategoryDirectory)
                            {
                                tnNode.Nodes.Add(flightSubcategoriesNode);
                                addedFlightSubcategoryDirectory = true;
                            }
                        }                                                                           // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                        else
                        {
                            tnNode.Nodes.Add(tnNewTable);
                        }
                    }
                    gs.UpdateFilters(tnRacine, cmsContextMenuFilter, cmsMenuException);
                }
            }
            // << Task #9260 Pax2Sim - Static Analysis - EBS algorithm - EBS per Terminal
            if (sNodeName.Equals("FPD"))
                tnTerminal.Nodes.Add(EBSTreeNode);
            // >> Task #9260 Pax2Sim - Static Analysis - EBS algorithm - EBS per Terminal
        }

        // >> Task #9915 Pax2Sim - BNP development - Peak Flows - USA Standard directory
        private void updateScenarioStatisticTablesForUSAStandard(String sScenarioName, String sUSAStandardNode, String[] usaStandartTableNames,
        TreeNode tnRacine, ContextMenuStrip cmsContextMenuInput, ContextMenuStrip cmsContextMenuFilter, ContextMenuStrip cmsMenuException)
        {
            TreeNode tnUSAStandard = OverallTools.TreeViewFunctions.RechercherNomEnfantStrict(sUSAStandardNode, tnRacine);
            if (tnUSAStandard == null)
                return;
            if (tnUSAStandard.Nodes.Count > 0)
            {
                tnUSAStandard.Nodes.Clear();
            }
            DataManager gs = GetDataManager(sScenarioName);
            if (gs == null)
                return;

            TreeNode tnInputData = OverallTools.TreeViewFunctions.CreateDirectory(GlobalNames.usaStandard_inputData_subdirectoryName);
            TreeNode tnEDSRequirements = OverallTools.TreeViewFunctions.CreateDirectory(GlobalNames.usaStandard_EDSRequiremenst_subdirectoryName);
            TreeNode tnEBSRequirements = OverallTools.TreeViewFunctions.CreateDirectory(GlobalNames.usaStandard_EBSRequiremenst_subdirectoryName);
            //TreeNode tnCartRequirements = OverallTools.TreeViewFunctions.CreateDirectory("Cart Requirements");
            tnUSAStandard.Nodes.Add(tnInputData);
            tnUSAStandard.Nodes.Add(tnEDSRequirements);
            tnUSAStandard.Nodes.Add(tnEBSRequirements);

            foreach (String sTableName in usaStandartTableNames)
            {
                if (gs.Exist(sTableName))
                {
                    TreeViewTag Tag = TreeViewTag.getTableNode(sScenarioName, sTableName);
                    TreeNode tnNewTable = OverallTools.TreeViewFunctions.createBranch(sTableName, sTableName, Tag, cmsContextMenuInput);
                    
                    if (usaStandard_EDSRequirements_StatisticTablesNames.Contains(sTableName))
                    {
                        tnEDSRequirements.Nodes.Add(tnNewTable);
                    }
                    else if (usaStandard_EBSRequirements_StatisticTablesNames.Contains(sTableName))
                    {
                        tnEBSRequirements.Nodes.Add(tnNewTable);
                    }
                    else if (usaStandard_InputData_TablesNames.Contains(sTableName))
                    {
                        tnInputData.Nodes.Add(tnNewTable);
                    } 

                    gs.UpdateFilters(tnRacine, cmsContextMenuFilter, cmsMenuException);
                }
            }
            
        }
        // << Task #9915 Pax2Sim - BNP development - Peak Flows - USA Standard directory
        
        // >> Bug #13367 Liege allocation
        private void updateScenarioStatisticTablesForLiege(String sScenarioName, String generatingResultsNodeName, String[] occupationTableNames,
            string[] occupationIssuesTableNames, TreeNode tnRacine, ContextMenuStrip cmsContextMenuInput, ContextMenuStrip cmsContextMenuFilter,
            ContextMenuStrip cmsMenuException, ContextMenuStrip cmsExportScenarioTables)
        {
            DataManager gs = GetDataManager(sScenarioName);
            if (gs == null)
                return;

            bool hasOccupationTables = false;
            foreach (String sTableName in occupationTableNames)
            {
                if (gs.Exist(sTableName))
                {
                    hasOccupationTables = true;
                    break;
                }
            }
            if (hasOccupationTables)
            {
                TreeNode generatingResults = OverallTools.TreeViewFunctions.RechercherNomEnfantStrict(generatingResultsNodeName, tnRacine);
                if (generatingResults == null)
                    return;

                TreeNode occupationDirectory = OverallTools.TreeViewFunctions.CreateDirectory("Boarding Rooms Occupation", cmsExportScenarioTables);
                generatingResults.Nodes.Add(occupationDirectory);


                foreach (String sTableName in occupationTableNames)
                {
                    if (gs.Exist(sTableName))
                    {
                        TreeViewTag Tag = TreeViewTag.getTableNode(sScenarioName, sTableName);
                        TreeNode tnNewTable = OverallTools.TreeViewFunctions.createBranch(sTableName, sTableName, Tag, cmsContextMenuInput);
                            
                        string resourceCodeFromMainTable = getResourceCodeFromOccupationTableName(sTableName);
                        if (resourceCodeFromMainTable != "")
                        {
                            foreach (String issuesName in occupationIssuesTableNames)
                            {
                                if (gs.Exist(issuesName))
                                {
                                    string resourceCodeFromIssues = getResourceCodeFromOccupationTableName(issuesName);
                                    if (resourceCodeFromMainTable == resourceCodeFromIssues)
                                    {
                                        TreeViewTag childTag = TreeViewTag.getTableNode(sScenarioName, issuesName);
                                        TreeNode childTableNode = OverallTools.TreeViewFunctions.createBranch(issuesName, issuesName, childTag, cmsContextMenuInput);
                                        tnNewTable.Nodes.Add(childTableNode);
                                    }
                                }
                            }
                        }
                        occupationDirectory.Nodes.Add(tnNewTable);
                        gs.UpdateFilters(tnRacine, cmsContextMenuFilter, cmsMenuException);
                    }
                }
            }
        }

        private string getResourceCodeFromOccupationTableName(string occupationTableName)
        {
            string resourceCode = "";
            if (occupationTableName != null && occupationTableName.Length > 4)
            {
                resourceCode = occupationTableName.Substring(0, 4);
            }
            return resourceCode;
        }
        // << Bug #13367 Liege allocation
        
        private void UpdateScenarioStaticTables(String Name, TreeNode tnRacine, ContextMenuStrip cmsContextMenuInput,
                                               ContextMenuStrip cmsContextMenuFilter, ContextMenuStrip cmsExceptionTable,
                                               ContextMenuStrip cmsExportScenarioTables)
        {
            Classes.ParamScenario parametres = GetScenario(Name);
            if (parametres == null)
                return;
            TreeNode tnPeakFlows = OverallTools.TreeViewFunctions.RechercherNomEnfantStrict(sPeakFlows, tnRacine);  // >> Bug #10415 Analysis - Peak Flow: tables not updated on existing scenario relaunch
            if (tnPeakFlows != null)
            {
                UpdateScenarioStaticTable(Name, "Allocation", StaticResultsAllocation, tnPeakFlows, false, cmsContextMenuInput, cmsContextMenuFilter, cmsExceptionTable, cmsExportScenarioTables);
                UpdateScenarioStaticTable(Name, "FPD", StaticResultsFPD, tnPeakFlows, parametres.DeparturePeak, cmsContextMenuInput, cmsContextMenuFilter, cmsExceptionTable, cmsExportScenarioTables);
                UpdateScenarioStaticTable(Name, "FPA", StaticResultsFPA, tnPeakFlows, parametres.ArrivalPeak, cmsContextMenuInput, cmsContextMenuFilter, cmsExceptionTable, cmsExportScenarioTables);
                UpdateScenarioStaticTable(Name, "FPD+FPA", StaticResultsFPDFPA, tnPeakFlows, parametres.DeparturePeak && parametres.ArrivalPeak, cmsContextMenuInput, cmsContextMenuFilter, cmsExceptionTable, cmsExportScenarioTables);
            }

            // >> Task #15556 Pax2Sim - Scenario Properties Assistant issues - C#8
            UpdateScenarioStaticTable(Name, "Pax_Plan", StaticResultsPaxplan, tnRacine, parametres.PaxPlan, cmsContextMenuInput, cmsContextMenuFilter, cmsExceptionTable, cmsExportScenarioTables);
            //UpdateScenarioStaticTable(Name, "Pax plan", StaticResultsPaxplan, tnRacine.Nodes[0], parametres.PaxPlan, cmsContextMenuInput, cmsContextMenuFilter, cmsExceptionTable, cmsExportScenarioTables);
            // << Task #15556 Pax2Sim - Scenario Properties Assistant issues - C#8

            if (PAX2SIM.bSodexi)
            {
                UpdateScenarioStaticTable(Name, "Generating Results", StaticSodexianalysisDirectory, tnRacine.Nodes[0], false, cmsContextMenuInput, cmsContextMenuFilter, cmsExceptionTable, cmsExportScenarioTables);
            }
            // >> Task #12393 Pax2Sim - File conversion for Athens
            if (PAX2SIM.bAIA)
            {
                UpdateScenarioStaticTable(Name, "Generating Results", staticAthensAnalysisDirectory, tnRacine.Nodes[0], false, cmsContextMenuInput, cmsContextMenuFilter, cmsExceptionTable, cmsExportScenarioTables);
            }
            // << Task #12393 Pax2Sim - File conversion for Athens

            // >> Task #12843 Pax2Sim - Dubai - allocate using Cplex
            if (PAX2SIM.dubaiMode)
            {
                UpdateScenarioStaticTable(Name, "Generating Results", staticDubaiAnalysisDirectory, tnRacine.Nodes[0], false, cmsContextMenuInput, cmsContextMenuFilter, cmsExceptionTable, cmsExportScenarioTables);                
            }
            // << Task #12843 Pax2Sim - Dubai - allocate using Cplex
            if (PAX2SIM.liegeMode)  // >> Task #12808 Pax2Sim - allocation Liege
            {
                UpdateScenarioStaticTable(Name, "Generating Results", staticLiegeAnalysisDirectory, tnRacine.Nodes[0], false, cmsContextMenuInput, cmsContextMenuFilter, cmsExceptionTable, cmsExportScenarioTables);
                updateScenarioStatisticTablesForLiege(Name, "Generating Results", staticLiegeAnalysisOccupationDirectory, staticLiegeAnalysisOccupationSubDirectory, tnRacine.Nodes[0], cmsContextMenuInput, cmsContextMenuFilter, cmsExceptionTable, cmsExportScenarioTables);
            }
            if (PAX2SIM.cdgMode)
            {
                UpdateScenarioStaticTable(Name, "Generating Results", staticCDGAnalysisDirectory, tnRacine.Nodes[0], false, cmsContextMenuInput, cmsContextMenuFilter, cmsExceptionTable, cmsExportScenarioTables);
            }

// >> Task #10069 Pax2Sim - no BNP development

            // >> Task #9915 Pax2Sim - BNP development - Peak Flows - USA Standard directory
            if (PAX2SIM.usaMode)
            {
                updateScenarioStatisticTablesForUSAStandard(Name, GlobalNames.usaStandard_directoryName, usaStandardStatisticTablesResults, tnRacine.Nodes[0],
                    cmsContextMenuInput, cmsContextMenuFilter, cmsExceptionTable);
            }
            // << Task #9915 Pax2Sim - BNP development - Peak Flows - USA Standard directory



        }
        #endregion

        #region Fonctions pour la gestion des graphics générés par Automod
        public bool AddReplaceAutomodGraphic(String sScenarioName, DataTable dtTable)
        {
            DataManagerPaxBHS gs = (DataManagerPaxBHS)GetDataManager(sScenarioName);
            if (gs == null)
                return false;
            if (!gs.AddAutomodGraphic(dtTable))
                return gs.UpdateAutomodGraphic(dtTable);
            return gs.AddAutomodGraphic(dtTable);
        }
        public void DeleteAutomodGraphic(String sScenarioName, String sTable)
        {
            DataManagerPaxBHS gs = (DataManagerPaxBHS)GetDataManager(sScenarioName);
            if (gs == null)
                return;
            gs.DeleteAutomodGraphic(sTable);
        }
        #endregion

        #region Fonction pour ajouter un scénario au projet
        public TreeNode AddScenario(String name,
                                    ContextMenuStrip cmsBranchTestMenu,
                                    ContextMenuStrip cmsContextMenuInput,
                                    ContextMenuStrip cmsContextMenuFilter,
                                    ContextMenuStrip cmsAutomodMenu, 
                                    ContextMenuStrip cmsExceptionTable,
                                    Classes.ParamScenario parametres,
                                    ContextMenuStrip cmsExportScenarioTables)
        {
            if (GetDataManager(name)!= null)
            {
                ListeErreurs.Add("Err00082 : This name is already in use. Please select another one");
                return null;
            }
            if (parametres == null)
            {
                return null;
            }

            TreeNode Result = createBranchScenario(name, parametres, cmsBranchTestMenu, cmsAutomodMenu, cmsExportScenarioTables);
            if (Result != null)
            {
                AddScenario(name, parametres);
                UpdateScenarioStaticTables(name, Result, /*parametres,*/ cmsContextMenuInput, cmsContextMenuFilter, cmsExceptionTable, cmsExportScenarioTables);
            }
            return Result;
        }

        #endregion

        #region Fonction pour exporter un scénario en XML et sauver toutes les branches utiles.

        #region Fonction pour générer la branche FormatTree du fichier XML.
        /// <summary>
        /// Fonction qui va parcourir le contenu de l'analyse, et sauve tous les emplacements des 
        /// noeuds qui ont une icone particulière
        /// </summary>
        /// <param name="ScenarioNode">Le noeud racine du scénario</param>
        /// <param name="documentSource">Le document xml source nécessaire pour la génération des enfants</param>
        /// <returns>Renvoie un arbre XML contenant les informations recueillies dans l'abre du scénario</returns>
        public static XmlNode generateFormatTree(TreeNode ScenarioNode, XmlDocument documentSource)
        {
            return generateFormatTree("", ScenarioNode, documentSource);
        }
        public static XmlNode generateFormatTree(String sPosition, TreeNode ScenarioNode, XmlDocument documentSource)
        {
            if ((ScenarioNode.Tag != null) && (ScenarioNode.Tag.GetType() == typeof(TreeViewTag))
                && (((TreeViewTag)ScenarioNode.Tag).isResultNode))
            {
            }
            sPosition += ScenarioNode.Name;
            foreach (TreeNode node in ScenarioNode.Nodes)
            {
                generateFormatTree(sPosition, node, documentSource);
            }
            return null;
        }
        #endregion
      

        #endregion

        #region Fonctions pour le chargement (ou la copie) d'un scénario

        private TreeNode LoadScenarioAllocation(XmlElement Scenario,
                                      String AncienScenario,
                                      Prompt.SIM_LoadingForm chForm,
                                      ContextMenuStrip cmsScenarioMenu,
                                      ContextMenuStrip contextMenuInput,
                                      ContextMenuStrip cmsMenuFilter,
                                      VersionManager sVersion)
        {
            ///To do : Loading the config
            if (Scenario.Name != typeof(DataManagerAllocation).Name)
                return null;
            if (!OverallTools.FonctionUtiles.hasNamedAttribute(Scenario, "Name"))
            {
                ListeErreurs.Add("Err00128 : The Scenario does not have a valid format");
                return null;
            }
            String RacineName = Scenario.Attributes["Name"].Value;
            DataManagement.DataManagerAllocation dmsScenario = new DataManagement.DataManagerAllocation(RacineName);

            dmsScenario.GetTableFunction = new GenerateAllocationTool.GetTable(getTableForScenario);
            dmsScenario.GetTableExceptionFunction = new GenerateAllocationTool.GetTableException(getExceptionTableForScenario);

            dmsScenario.GetPath = new DataManager.GetPathDelegate(getNomDuChemin);
            if (!dmsScenario.LoadInputData(Scenario, sVersion, nomDuChemin, chForm))
                return null;

            if (!AddScenario(dmsScenario))
            {
                ListeErreurs.Add("Err00129 : Impossible to add this Scenario :" + RacineName);
                return null;
            }

            return dmsScenario.GenerateScenarioNode(cmsScenarioMenu, contextMenuInput, cmsMenuFilter, null, null);
        }
        private TreeNode LoadScenarioParking(XmlElement Scenario,
                                      String AncienScenario,
                                      Prompt.SIM_LoadingForm chForm,
                                      ContextMenuStrip cmsScenarioMenu,
                                      ContextMenuStrip contextMenuInput,
                                      ContextMenuStrip cmsMenuFilter,
                                      VersionManager sVersion)
        {
            ///To do : Loading the config
            if (Scenario.Name != typeof(DataManagerParking).Name)
                return null;
            if (!OverallTools.FonctionUtiles.hasNamedAttribute(Scenario, "Name"))
            {
                ListeErreurs.Add("Err00128 : The Scenario does not have a valid format");
                return null;
            }
            String RacineName = Scenario.Attributes["Name"].Value;
            DataManagement.DataManagerParking dmsScenario = new DataManagement.DataManagerParking(RacineName);
            dmsScenario.GetPath = new DataManager.GetPathDelegate(getNomDuChemin);
            if (!dmsScenario.LoadInputData(Scenario, sVersion, nomDuChemin,chForm))
                return null;

            if (!AddScenario(dmsScenario))
            {
                ListeErreurs.Add("Err00129 : Impossible to add this Scenario :" + RacineName);
                return null;
            }

            return dmsScenario.GenerateScenarioNode(cmsScenarioMenu, contextMenuInput, cmsMenuFilter, null, null);
        }
        private TreeNode LoadScenarioNew(XmlElement Scenario,
                                      String AncienScenario,
                                      Prompt.SIM_LoadingForm chForm,
                                      ContextMenuStrip cmsScenarioMenu,
                                      ContextMenuStrip contextMenuInput,
                                      ContextMenuStrip cmsMenuFilter,
                                      ContextMenuStrip cmsAutomodMenu,
                                      ContextMenuStrip cmsUserGraphics,
                                      VersionManager sVersion)
        {
            ///To do : Loading the config
            if (((Scenario.Name != typeof(DataManagerPaxBHS).Name) && (sVersion>=new VersionManager(1,52))) ||
                ((Scenario.Name != typeof(DataManagerScenario).Name) && (sVersion<new VersionManager(1,52))))
                return null;
            if( !OverallTools.FonctionUtiles.hasNamedAttribute(Scenario, "Name"))
            {
                ListeErreurs.Add("Err00128 : The Scenario does not have a valid format");
                return null;
            }
            String RacineName = Scenario.Attributes["Name"].Value;
            DataManagement.DataManagerPaxBHS dmsScenario = new DataManagement.DataManagerPaxBHS(RacineName);
            dmsScenario.GetPath = new DataManager.GetPathDelegate(getNomDuChemin);
            if (!dmsScenario.LoadInputData(Scenario,sVersion,nomDuChemin,chForm))
                return null;

            if (! AddScenario(dmsScenario))
            {
                ListeErreurs.Add("Err00129 : Impossible to add this Scenario :" + RacineName);
                return null;
            }
            return dmsScenario.GenerateScenarioNode(cmsScenarioMenu, contextMenuInput, cmsMenuFilter, cmsAutomodMenu, cmsUserGraphics);
        }

        private TreeNode LoadScenario_old(XmlElement Scenario,
                                      String AncienScenario,
                                      Prompt.SIM_LoadingForm chForm,
                                      ContextMenuStrip cmsScenarioMenu,
                                      ContextMenuStrip contextMenuInput,
                                      ContextMenuStrip cmsMenuFilter,
                                      ContextMenuStrip cmsAutomodMenu,
                                      ContextMenuStrip cmsUserGraphics,
                                      VersionManager sVersion,
                                      ContextMenuStrip cmsExportScenarioTables)
        {
            if ((!OverallTools.FonctionUtiles.hasNamedChild(Scenario, "DataSource")) ||
               (!OverallTools.FonctionUtiles.hasNamedChild(Scenario, "Filters")) ||
               ((!OverallTools.FonctionUtiles.hasNamedChild(Scenario, "Config")) && (sVersion <= new VersionManager(1, 17)) && (!sVersion.isVersion(0, 0))) ||
               ((!OverallTools.FonctionUtiles.hasNamedChild(Scenario, "ParamScenario")) && ((sVersion > new VersionManager(1, 17)) || (sVersion.isVersion(0, 0)))) ||
               (!OverallTools.FonctionUtiles.hasNamedChild(Scenario, "GraphicFilters")) ||
               (!OverallTools.FonctionUtiles.hasNamedAttribute(Scenario, "Name")))
            {
                ListeErreurs.Add("Err00128 : The Scenario does not have a valid format");
                return null;
            }
            if ((sVersion < new VersionManager(1, 15)) && (!sVersion.isVersion(0, 0)))
            {
                ListeErreurs.Add("Err00158 : The Scenario is too old and can't be opened");
                return null;
            }
            String RacineName = Scenario.Attributes["Name"].Value;
            XmlNode xnTmp = Scenario["Config"];
            if ((sVersion > new VersionManager(1, 17)) || (sVersion.isVersion(0, 0)))
                xnTmp = Scenario["ParamScenario"];
            Classes.ParamScenario paramScenario = new SIMCORE_TOOL.Classes.ParamScenario(xnTmp, sVersion);
            if (paramScenario.Name != RacineName)
            {
                paramScenario.Name = RacineName;
            }

            ///On ajoute le paramétrage du nouveau scénario dans le système de données.
            htScenarios.Add(RacineName, paramScenario);
            ///On initialise le système de données qui contiendra l'ensemble des tables et informations du nouveau scénario.
            Data.Add(paramScenario.Name, new GestionDonnees(RacineName, new GestionDonnees.AnalyseTraces(AnalyseTraces), ListeErreurs));
            
            GestionDonnees gs = getGestionDonnees(RacineName);
            if (gs == null)
            {
                ListeErreurs.Add("Err00130 : The Scenario name does not exist on the current project");
                return null;
            }
            if (OverallTools.FonctionUtiles.hasNamedChild(Scenario, "Notes"))
            {
                gs.openNotes(Scenario["Notes"]);
            }

            GestionDonnees dgOldScenario = null;
            if (AncienScenario != null)
            {
                dgOldScenario = getGestionDonnees(AncienScenario);
            }

            bool bTraceSaved = false;

            //If the scenario has informations about his paxtrace.
            if (OverallTools.FonctionUtiles.hasNamedAttribute(Scenario, "PaxTrace"))
            {
                //We take the location of the paxtrace.
                String sOldFile = getDossierEnregistrement() + "\\" + Scenario.Attributes["PaxTrace"].Value;
                //If dgOldScenario is not null, that means we are copying that scenario.
                if (dgOldScenario != null)
                {
                    //The file location for the copied scenario.
                    sOldFile = dgOldScenario.PaxTraceLocation;
                }
                //If the paxtrace does exist, then we copy it in the UserDirectory.
                if (System.IO.File.Exists(sOldFile))
                {
                    OverallTools.ExternFunctions.CheckCreateDirectory(OverallTools.ExternFunctions.getTempDirectoryForPax2sim());
                    gs.PaxTraceLocation = OverallTools.ExternFunctions.getTempDirectoryForPax2sim() + RacineName + "_PaxTrace.tmp";
                    OverallTools.ExternFunctions.CopyFile(gs.PaxTraceLocation, sOldFile, "", null, null, chForm);
                    bTraceSaved = true;
                }
            }

            //If the scenario has informations about his Bagtrace.
            if (OverallTools.FonctionUtiles.hasNamedAttribute(Scenario, "BagTrace"))
            {
                //We take the location of the BagTrace.
                String sOldFile = getDossierEnregistrement() + "\\" + Scenario.Attributes["BagTrace"].Value;
                //If dgOldScenario is not null, that means we are copying that scenario.
                if (dgOldScenario != null)
                {
                    //The file location for the copied scenario.
                    sOldFile = dgOldScenario.BagTraceLocation;
                }
                //If the bagtrace does exist, then we copy it in the UserDirectory.
                if (System.IO.File.Exists(sOldFile))
                {
                    OverallTools.ExternFunctions.CheckCreateDirectory(OverallTools.ExternFunctions.getTempDirectoryForPax2sim());
                    gs.BagTraceLocation = OverallTools.ExternFunctions.getTempDirectoryForPax2sim() + RacineName + "_BagTrace.tmp";
                    OverallTools.ExternFunctions.CopyFile(gs.BagTraceLocation, sOldFile, "", null, null, chForm);
                    bTraceSaved = true;
                }
            }

            gs.loadFiltersXML(Scenario["Filters"]);
            gs.loadGraphicFilters(Scenario["GraphicFilters"]);
            if (OverallTools.FonctionUtiles.hasNamedChild(Scenario, "AutomodGraphic"))
                gs.LoadAutomodGraphics(Scenario["AutomodGraphic"]);

            TreeViewTag Tag = TreeViewTag.getDirectoryNode(RacineName);
            TreeNode ArbreTreeViewRacine = OverallTools.TreeViewFunctions.createBranch(RacineName, RacineName, Tag, cmsScenarioMenu);
            foreach (XmlElement noeud in Scenario["DataSource"].ChildNodes)
            {
                if (noeud.Name != "FiltersTables")
                {
                    TreeNode treeTmp = loadScenarioTables(noeud, gs, dgOldScenario, "Output\\" + RacineName + "\\" + noeud.Attributes["Name"].Value + "\\", -1, bTraceSaved, false, chForm, contextMenuInput, cmsMenuFilter, cmsUserGraphics, sVersion);
                    if (treeTmp == null)
                    {
                        RemoveScenario(RacineName);
                        return null;
                    }
                    else
                    {
                        ArbreTreeViewRacine.Nodes.Add(treeTmp);
                    }
                }
                else
                {
                    foreach (XmlElement FilterTable in noeud.ChildNodes)
                    {
                        DataTable tmp = null;

                        if (AncienScenario == null)
                        {
                            //Il faut charger la table et l'intégrer dans la base de données.
                            String fichier = getDossierEnregistrement() + FilterTable.FirstChild.Value;
                            if (!System.IO.File.Exists(fichier))
                            {
                                //RemoveScenario(RacineName);
                                return null;
                            }
                            tmp = new DataTable(FilterTable.Attributes["Name"].Value);
                            OverallTools.FonctionUtiles.LectureFichier(tmp, fichier, "\t", ListeErreurs);
                        }
                        else
                        {
                            tmp = getTable(AncienScenario, FilterTable.Attributes["Name"].Value);
                            if (tmp != null)
                                tmp = tmp.Copy();
                        }
                        if (tmp == null)
                            return null;
                        gs.AddTable(tmp, new VisualisationMode(false, false, true, null, new int[1] { 0 }));
                        gs.aEteModifiee(tmp.TableName);
                    }
                }
            }
            UpdateTreeNode(RacineName, ArbreTreeViewRacine, paramScenario, cmsAutomodMenu, cmsExportScenarioTables);
            return ArbreTreeViewRacine;
        }

        /// <summary>
        /// \deprecated
        /// </summary>
        /// <param name="CurrentNode"></param>
        /// <param name="newScenario"></param>
        /// <param name="AncienScenario"></param>
        /// <param name="sLoadPath"></param>
        /// <param name="iProfondeur"></param>
        /// <param name="bTraceSaveMode"></param>
        /// <param name="bLoadTable"></param>
        /// <param name="chForm"></param>
        /// <param name="contextMenuInput"></param>
        /// <param name="cmsMenuFilter"></param>
        /// <param name="cmsUserGraphics"></param>
        /// <param name="sVersion"></param>
        /// <returns></returns>
        private TreeNode loadScenarioTables(XmlElement CurrentNode,
                                      GestionDonnees newScenario,
                                      GestionDonnees AncienScenario,
                                      String sLoadPath,
                                      int iProfondeur,
                                      bool bTraceSaveMode,
                                      bool bLoadTable,
                                      Prompt.SIM_LoadingForm chForm,
                                      ContextMenuStrip contextMenuInput,
                                      ContextMenuStrip cmsMenuFilter,
                                      ContextMenuStrip cmsUserGraphics,
                                      VersionManager sVersion)
        {
            if (sVersion.isVersion(1, 1))
                return null;
            TreeNode Result = null;
            if (!CurrentNode.HasAttribute("Name"))
                return null;
            String Name = CurrentNode.Attributes["Name"].Value;

            if (Name.Contains("bound"))
            {
                bLoadTable = true;
                Name = Name.Replace("bound", "Bound");
            }
            if (Name.Contains("Capacity Analysis"))
            {
                Name = sPaxCapacityAnalysis;
            }
            String Text = Name;
            if (CurrentNode.HasAttribute("Text"))
                Text = CurrentNode.Attributes["Text"].Value;
            if (CurrentNode.Name == "Directory")
            {
                if ((sVersion <= new VersionManager(1, 18)) && (Text == "Customs graphics"))
                {
                    Name = Name.Replace("Customs g", "User G");
                    Text = Name;
                }
                if (Name == sScenarioCustomGraphic)
                    contextMenuInput = cmsUserGraphics;
                Result = OverallTools.TreeViewFunctions.CreateDirectory(Name, Text, null);
            }
            else if (CurrentNode.Name == "AirportObject")
            {
                if (chForm != null)
                    chForm.ChargementFichier("Load table (Scenario : " + newScenario.Nom + "): " + Text);
                Result = OverallTools.TreeViewFunctions.createBranch(Name, Text, TreeViewTag.getResultNode(newScenario.Nom, Name), null);
                if (!sVersion.isVersion(1, 0))
                {
                    DataTable tmp = null;
                    if (AncienScenario == null)
                    {
                        bool CalculatedFromTrace = false;
                        if (CurrentNode.HasAttribute("FromTrace"))
                            Boolean.TryParse(CurrentNode.Attributes["FromTrace"].Value, out CalculatedFromTrace);

                        if (CalculatedFromTrace)
                        {
                            newScenario.AddPartialTable(Name);
                        }
                        else
                        {
                            String fichier = getDossierEnregistrement() + sLoadPath + Name + ".txt";
                            if (System.IO.File.Exists(fichier))
                            {
                                if (!bLoadTable)
                                    newScenario.AddPartialTable(Name, fichier);
                                else
                                {
                                    tmp = new DataTable(Name);
                                    OverallTools.FonctionUtiles.LectureFichier(tmp, fichier, "\t", ListeErreurs);
                                }
                            }
                        }
                    }
                    else
                    {
                        if (AncienScenario.IsCalculatedFromTrace(Name))
                        {
                            if (!AncienScenario.isOpenned(Name))
                            {
                                newScenario.AddPartialTable(Name);
                            }
                            else
                            {
                                newScenario.AddCalculatedFromTrace(Name);
                                tmp = AncienScenario.GetTable(Name);
                            }
                        }
                        else
                        {
                            tmp = AncienScenario.GetTable(Name);
                        }
                        if (tmp != null)
                            tmp = tmp.Copy();
                    }
                    if (tmp != null)
                    {
                        AddTable(newScenario.Nom, tmp);
                    }
                    if ((iProfondeur >= 0) && (iProfondeur < 5))
                    {
                        newScenario.AddReplaceModeVisualisation(Name, RapportTableVisualisationMode[iProfondeur]);
                    }
                }
            }
            else if (CurrentNode.Name == "Table")
            {
                if (chForm != null)
                    chForm.ChargementFichier("Load table (Scenario : " + newScenario.Nom + "): " + Text);
                DataTable tmp = null;
                Result = OverallTools.TreeViewFunctions.createBranch(Name, Text, TreeViewTag.getTableNode(newScenario.Nom, Name), contextMenuInput);
                if (AncienScenario == null)
                {
                    bool CalculatedFromTrace = false;
                    if (CurrentNode.HasAttribute("FromTrace"))
                        Boolean.TryParse(CurrentNode.Attributes["FromTrace"].Value, out CalculatedFromTrace);

                    if (CalculatedFromTrace)
                    {
                        newScenario.AddPartialTable(Name);
                    }
                    else
                    {
                        //Il faut charger la table et l'intégrer dans la base de données.
                        String fichier = getDossierEnregistrement() + sLoadPath + CurrentNode.FirstChild.Value;
                        if (!System.IO.File.Exists(fichier))
                        {
                            //RemoveScenario(newScenario.Nom);
                            return null;
                        }
                        if (!bLoadTable)
                            newScenario.AddPartialTable(Name, fichier);
                        else
                        {
                            tmp = new DataTable(Name);
                            OverallTools.FonctionUtiles.LectureFichier(tmp, fichier, "\t", ListeErreurs);
                        }
                    }
                }
                else
                {
                    if (AncienScenario.IsCalculatedFromTrace(Name))
                    {
                        if (!AncienScenario.isOpenned(Name))
                        {
                            newScenario.AddPartialTable(Name);
                        }
                        else
                        {
                            newScenario.AddCalculatedFromTrace(Name);
                            tmp = AncienScenario.GetTable(Name);
                        }
                    }
                    else
                    {
                        tmp = AncienScenario.GetTable(Name);
                    }
                    if (tmp != null)
                        tmp = tmp.Copy();
                }
                if (tmp != null)
                    AddTable(newScenario.Nom, tmp);
                if (Name.Contains("Utilization"))
                {
                    if (Name.Contains("Group"))
                    {
                        newScenario.AddReplaceModeVisualisation(Name, UtilizationGroupTableVisualisationMode);
                    }
                    else
                    {
                        newScenario.AddReplaceModeVisualisation(Name, UtilizationTableVisualisationMode);
                    }
                }
                else
                {
                    if ((Name == "FPD_Peak_Stats") || (Name == "FPA_Peak_Stats") || (Name == "FPDFPA_Peak_Stats"))
                    {
                        newScenario.AddReplaceModeVisualisation(Name, StaticRapportVisualisationMode);
                    }
                    else if (Name.EndsWith("_Statistics"))
                    {
                        newScenario.AddReplaceModeVisualisation(Name, StaticRapportVisualisationMode);
                    }
                    else
                    {
                        if (modeVisualisation.ContainsKey(Name))
                            newScenario.AddReplaceModeVisualisation(Name, (VisualisationMode)modeVisualisation[Name]);
                        else
                            newScenario.AddReplaceModeVisualisation(Name, new VisualisationMode(false, false, true, null, new int[1] { 0 }));
                    }
                }
                if (newScenario.getFilter(Name) == null)
                {
                    Result = OverallTools.TreeViewFunctions.createBranch(Name, Text, TreeViewTag.getTableNode(newScenario.Nom, Name), contextMenuInput);
                }
                if (newScenario.getFilter(Name) == null)
                    newScenario.Maj_Filtres(Name, Result, cmsMenuFilter);
            }
            if ((Result != null) && (!((TreeViewTag)Result.Tag).isTableNode))
            {
                for (int i = 0; i < CurrentNode.ChildNodes.Count; i++)
                {
                    TreeNode treeTmp = loadScenarioTables((XmlElement)CurrentNode.ChildNodes[i], newScenario, AncienScenario, sLoadPath, iProfondeur + 1, bTraceSaveMode, bLoadTable, chForm, contextMenuInput, cmsMenuFilter, cmsUserGraphics, sVersion);
                    if (treeTmp == null)
                        return null;
                    Result.Nodes.Add(treeTmp);
                }
            }
            return Result;
        }

        #endregion

        #region Fonctions statiques pour la création ou la mise à jour de la structure de tous les scénarios
        private static TreeNode createStaticBranch(ContextMenuStrip cmsExportScenarioTables)
        {
            TreeNode noeudtmp = OverallTools.TreeViewFunctions.CreateDirectory(sPeakFlows, cmsExportScenarioTables);
            foreach (String sName in StaticResultsDirectory)
                noeudtmp.Nodes.Add(OverallTools.TreeViewFunctions.CreateDirectory(sName, cmsExportScenarioTables));
            if (PAX2SIM.bSodexi || PAX2SIM.liegeMode || PAX2SIM.dubaiMode || PAX2SIM.bAIA || PAX2SIM.cdgMode)   // >> Task #13367 Liege allocation C#109
            {
                noeudtmp.Nodes.Add(OverallTools.TreeViewFunctions.CreateDirectory("Generating Results", cmsExportScenarioTables));
            }
            return noeudtmp;

        }
        private static TreeNode createDynamicBranch()
        {
            TreeNode noeudtmp = OverallTools.TreeViewFunctions.CreateDirectory(sPaxCapacityAnalysis, null);
            return noeudtmp;
        }
        private static TreeNode createBHSBranch()
        {
            TreeNode noeudtmp = OverallTools.BagTraceAnalysis.GenerateDirectories(null);
            return noeudtmp;
        }
        private static TreeNode createAutomodGraphicsBranch(ContextMenuStrip cmsAutomodMenu)
        {
            TreeNode noeudtmp = OverallTools.TreeViewFunctions.CreateDirectory(sScenarioCustomGraphic, cmsAutomodMenu);
            return noeudtmp;
        }

        // >> Task #15556 Pax2Sim - Scenario Properties Assistant issues - C#8
        private static TreeNode createPaxPlanBranch(ContextMenuStrip contextMenuStrip)
        {
            TreeNode noeudtmp = OverallTools.TreeViewFunctions.CreateDirectory("Pax_Plan", contextMenuStrip);
            return noeudtmp;
        }
        // << Task #15556 Pax2Sim - Scenario Properties Assistant issues - C#8

        private static void UpdateTreeNode(String Name, TreeNode tnRacine, Classes.ParamScenario param, ContextMenuStrip cmsAutomodMenu,
            ContextMenuStrip cmsExportScenarioTables)   // >> Task #14533 Pax2Sim - Export Scenario tables from result tree
        {
            if (tnRacine == null)
                return;
            TreeNode tnNode = OverallTools.TreeViewFunctions.RechercherNomEnfantStrict(sScenarioCustomGraphic, tnRacine);
            if (tnNode == null)
            {
                tnRacine.Nodes.Add(createAutomodGraphicsBranch(cmsAutomodMenu));
            }
            else
            {
                tnNode.ContextMenuStrip = cmsAutomodMenu;
            }
            
            // >> Task #15556 Pax2Sim - Scenario Properties Assistant issues - C#8
            tnNode = OverallTools.TreeViewFunctions.RechercherNomEnfantStrict("Pax_Plan", tnRacine);
            if (tnNode == null)            
                tnRacine.Nodes.Add(createPaxPlanBranch(cmsExportScenarioTables));            
            else            
                tnNode.ContextMenuStrip = cmsExportScenarioTables;
            // << Task #15556 Pax2Sim - Scenario Properties Assistant issues - C#8

            if ((param.BHSSimulation) || ((param.ArrivalPeak) && (param.DeparturePeak) && (param.PaxPlan)) ||(param.DynamicReclaimAllocation))
            {
                if (OverallTools.TreeViewFunctions.RechercherNomEnfantStrict(sBHSAnalysis, tnRacine) == null)
                {
                    tnRacine.Nodes.Insert(tnRacine.Nodes.Count - 1, createBHSBranch());

                }
            }
            if (param.BHSSimulation || param.PaxSimulation)
            {
                if (OverallTools.TreeViewFunctions.RechercherNomEnfantStrict(sPaxCapacityAnalysis, tnRacine) == null)
                {
                    if (OverallTools.TreeViewFunctions.RechercherNomEnfantStrict(sPeakFlows, tnRacine) != null)
                        tnRacine.Nodes.Insert(1, createDynamicBranch());
                    else
                        tnRacine.Nodes.Insert(0, createDynamicBranch());
                }
            }
            if ((param.ArrivalPeak) || (param.DeparturePeak) || (param.PaxPlan))
            {
                TreeNode tnPeakFlows = OverallTools.TreeViewFunctions.RechercherNomEnfantStrict(sPeakFlows, tnRacine);
                if ((tnPeakFlows == null) ||
                    (tnPeakFlows.FirstNode.Text != StaticResultsDirectory[0]))
                {
                    if (tnPeakFlows != null)
                        tnPeakFlows.Remove();
                    tnRacine.Nodes.Insert(0, createStaticBranch(cmsExportScenarioTables));
                }
            }
        }
        public static TreeNode createBranchScenario(String Name,
                                                    Classes.ParamScenario parametres,
                                                    ContextMenuStrip cmsBranchTestMenu,
                                                    ContextMenuStrip cmsAutomodMenu,
                                                    ContextMenuStrip cmsExportScenarioTables)
        {
            TreeNode racine = OverallTools.TreeViewFunctions.CreateDirectory(Name, cmsBranchTestMenu);
            UpdateTreeNode(Name, racine, parametres, cmsAutomodMenu, cmsExportScenarioTables);
            return racine;
        }
        #endregion


        internal Boolean UpdateScenarioTree(string Name, TreeNode ScenarioPosition)
        {
            DataManager dm = GetDataManager(Name);
            if (dm == null)
                return false;
            if (!(dm is DataManagerScenario))
                return false;
            DataManagerScenario dmsScenario = (DataManagerScenario)dm;
            dmsScenario.UpdateAbro(ScenarioPosition);
            return true;
        }
        #endregion

        #region Ajout d'un scenario de type Parking
        internal void AddScenario(String sName, String sTitle, DataTable dtGeneral, DataTable dtDistribution, DataTable dtDistributionModal, DataTable dtOccupation)
        {
            ///On vérifie que le nouveau scénario à ajouter n'est pas déjà présent dans le projet courant.
            if (dmsScenarios.ContainsKey(sName))
                return;
            DataManagerParking dmpScenario = new DataManagerParking(sName);
            dmpScenario.Title = sTitle;
            dmpScenario.GeneralTableName= dtGeneral.TableName;
            dmpScenario.DistributionTableName= dtDistribution.TableName;
            dmpScenario.ModalDistributionTableName= dtDistributionModal.TableName;
            dmpScenario.OccupationTableName= dtOccupation.TableName;

            DataTable dtTmp = dtGeneral.Copy();
            dtTmp.TableName = GlobalNames.sParkingGeneralName;
            dmpScenario.AddTable(dtTmp);

            dtTmp = dtDistribution.Copy();
            dtTmp.TableName = GlobalNames.sParkingDitributionTimeName;
            dmpScenario.AddTable(dtTmp);

            dtTmp = dtDistributionModal.Copy();
            dtTmp.TableName = GlobalNames.sParkingModaleDistribName;
            dmpScenario.AddTable(dtTmp);

            dtTmp = dtOccupation.Copy();
            dtTmp.TableName = GlobalNames.sParkingOccupationTimeName;
            dmpScenario.AddTable(dtTmp);
            dmsScenarios.Add(sName, dmpScenario);
        }
        #endregion

        #region Ajout d'un scenario de type Allocation
        internal void AddScenario(String sName, GenerateAllocationTool gatAllocation)
        {
            ///On vérifie que le nouveau scénario à ajouter n'est pas déjà présent dans le projet courant.
            if (dmsScenarios.ContainsKey(sName))
                return;
            DataManagerAllocation dmpScenario = new DataManagerAllocation(gatAllocation);
            dmpScenario.GetTableFunction = new GenerateAllocationTool.GetTable(getTableForScenario);
            dmpScenario.GetTableExceptionFunction = new GenerateAllocationTool.GetTableException(getExceptionTableForScenario);
            AddScenario(dmpScenario);
        }
        internal void UpdateAllocationScenario(String sName, GenerateAllocationTool gatAllocation)
        {
            ///We check that the scenario is existing, if not we stop the function.
            if (!dmsScenarios.ContainsKey(sName))
                return;
            ///We check that the scenario is a \ref DataManager_Allocation
            if (!typeof(DataManagerAllocation).IsInstanceOfType(dmsScenarios[sName]))
                return;
            DataManagerAllocation dmaTmp = (DataManagerAllocation)dmsScenarios[sName];
            dmaTmp.AllocationDefinition = gatAllocation;
        }
        internal DataTable getTableForScenario(String sName)
        {
            if (dmiInputData == null)
                return null;
            return getTable("Input", sName);
        }
        internal ExceptionTable getExceptionTableForScenario(String sName)
        {
            if (dmiInputData == null)
                return null;
            NormalTable ntTable = GetTable("Input", sName);
            if (typeof(ExceptionTable).IsInstanceOfType(ntTable))
                return (ExceptionTable)ntTable;
            return null;
        }
        #endregion

        #region Fonctions pour la générations des fichiers de paramétrage Automod pour la partie PAX.

        #region generateProcessTimes()
        internal static Dictionary<String, DataTable> generateProcessTimes(NormalTable ntProcessTimes,List<String>lsAirline,List<String>lsFlightCategory, Hashtable htNames)
        {
            Dictionary<String, DataTable> dsdtResult = new Dictionary<string, DataTable>();
            if (ntProcessTimes == null)
                return null;
            DataTable dtNormal = generateProcessTimes(ntProcessTimes.Table, lsAirline, lsFlightCategory, htNames, null);
            if (dtNormal != null)
                dsdtResult.Add("", dtNormal);
            if (!(ntProcessTimes is ExceptionTable))
                return dsdtResult;
            ExceptionTable etTable = (ExceptionTable)ntProcessTimes;
            if (etTable.ExceptionAirline != null)
            {
                dtNormal = generateProcessTimes(etTable.ExceptionAirline.Table, lsAirline, lsFlightCategory, htNames, GlobalNames.Airline);
                if (dtNormal != null)
                    dsdtResult.Add("_Airline", dtNormal);
            }
            if (etTable.ExceptionAirlineFB != null)
            {
                dtNormal = generateProcessTimes(etTable.ExceptionAirlineFB.Table, lsAirline, lsFlightCategory, htNames, GlobalNames.Airline);
                if (dtNormal != null)
                    dsdtResult.Add("_AirlineFB", dtNormal);
            }
            if (etTable.ExceptionFlight != null)
            {
                dtNormal = generateProcessTimes(etTable.ExceptionFlight.Table, lsAirline, lsFlightCategory, htNames, GlobalNames.Flight);
                if (dtNormal != null)
                    dsdtResult.Add("_Flight", dtNormal);
            }
            if (etTable.ExceptionFlightFB != null)
            {
                dtNormal = generateProcessTimes(etTable.ExceptionFlightFB.Table, lsAirline, lsFlightCategory, htNames, GlobalNames.Flight);
                if (dtNormal != null)
                    dsdtResult.Add("_FlightFB", dtNormal);
            }
            if (etTable.ExceptionFB != null)
            {
                dtNormal = generateProcessTimes(etTable.ExceptionFB.Table, lsAirline, lsFlightCategory, htNames, null);
                if (dtNormal != null)
                    dsdtResult.Add("_FB", dtNormal);
            }
            if (etTable.ExceptionFC != null)
            {
                dtNormal = generateProcessTimes(etTable.ExceptionFC.Table, lsAirline, lsFlightCategory, htNames, GlobalNames.FlightCategory);
                if (dtNormal != null)
                    dsdtResult.Add("_FC", dtNormal);
            }
            if (etTable.ExceptionFCFB != null)
            {
                dtNormal = generateProcessTimes(etTable.ExceptionFCFB.Table, lsAirline, lsFlightCategory, htNames, GlobalNames.FlightCategory);
                if (dtNormal != null)
                    dsdtResult.Add("_FCFB", dtNormal);
            }

            return dsdtResult;
        }
        public static DataTable generateProcessTimes(DataTable ProcessTimes, List<String> lsAirline, List<String> lsFlightCategory, Hashtable htNames, String sColonneException)
        {
            DataTable resultats = new DataTable("ProcessingsTimes");
            int iIndexException = -1;
            int iOffset = 0;
            bool bAirline=false;
            if (ProcessTimes == null)
                return null;
            if (sColonneException != null)
            {
                bAirline = sColonneException == GlobalNames.Airline;
                iIndexException = ProcessTimes.Columns.IndexOf(sColonneException);
                if (iIndexException == -1)
                    return null;
                resultats.Columns.Add(new DataColumn(sColonneException, System.Type.GetType("System.Int32")));
                iOffset++;
                if (sColonneException == GlobalNames.Flight)
                {
                    resultats.Columns.Add(new DataColumn("TypeFlight", System.Type.GetType("System.Int32")));
                    iOffset++;
                }
            }
            resultats.Columns.Add(new DataColumn("Terminal", System.Type.GetType("System.Int32")));
            resultats.Columns.Add(new DataColumn("GroupType", System.Type.GetType("System.Int32")));
            resultats.Columns.Add(new DataColumn("GroupIndex", System.Type.GetType("System.Int32")));
            resultats.Columns.Add(new DataColumn("IndexDistrib", System.Type.GetType("System.Int32")));
            resultats.Columns.Add(new DataColumn("Distrib", System.Type.GetType("System.Int32")));
            resultats.Columns.Add(new DataColumn("Param1", System.Type.GetType("System.Double")));
            resultats.Columns.Add(new DataColumn("Param2", System.Type.GetType("System.Double")));
            resultats.Columns.Add(new DataColumn("Param3", System.Type.GetType("System.Double")));

            int isProcessTable_Items = ProcessTimes.Columns.IndexOf(GlobalNames.sProcessTable_Items);
            int isProcessTable_Distrib_1 = ProcessTimes.Columns.IndexOf(GlobalNames.sProcessTable_Distrib_1);
            int isProcessTable_Param1_1 = ProcessTimes.Columns.IndexOf(GlobalNames.sProcessTable_Param1_1);
            int isProcessTable_Param2_1 = ProcessTimes.Columns.IndexOf(GlobalNames.sProcessTable_Param2_1);
            int isProcessTable_Param3_1 = ProcessTimes.Columns.IndexOf(GlobalNames.sProcessTable_Param3_1);
            int isProcessTable_Distrib_2 = ProcessTimes.Columns.IndexOf(GlobalNames.sProcessTable_Distrib_2);
            int isProcessTable_Param1_2 = ProcessTimes.Columns.IndexOf(GlobalNames.sProcessTable_Param1_2);
            int isProcessTable_Param2_2 = ProcessTimes.Columns.IndexOf(GlobalNames.sProcessTable_Param2_2);
            int isProcessTable_Param3_2 = ProcessTimes.Columns.IndexOf(GlobalNames.sProcessTable_Param3_2);

            if ((isProcessTable_Items == -1) ||
                    (isProcessTable_Distrib_1 == -1) ||
                    (isProcessTable_Param1_1 == -1) ||
                    (isProcessTable_Param2_1 == -1) ||
                    (isProcessTable_Param3_1 == -1) ||
                    (isProcessTable_Distrib_2 == -1) ||
                    (isProcessTable_Param1_2 == -1) ||
                    (isProcessTable_Param2_2 == -1) ||
                    (isProcessTable_Param3_2 == -1))
                return null;

            int[] Group;
            Double[] distribution;
            DataRow newLine;
            int i;
            foreach (DataRow line in ProcessTimes.Rows)
            {
                Group = OverallTools.DataFunctions.AnalyzeGroupName(line.ItemArray[isProcessTable_Items].ToString());
                if (Group == null)
                    continue;
                for (int j = 0; j < 2; j++)
                {
                    newLine = resultats.NewRow();
                    if (iIndexException != -1)
                    {
                        String sExcept = line.ItemArray[iIndexException].ToString();
                        if (iOffset > 1)
                        {
                            String[] sValue = sExcept.Split('_');
                            if (sValue[0] == "D")
                                newLine[1] = 0;
                            else
                                newLine[1] = 1;
                            int iValue;
                            Int32.TryParse(sValue[1], out iValue);
                            newLine[0] = iValue;
                        }
                        else
                        {
                            if (bAirline)
                                newLine[0] = lsAirline.IndexOf(sExcept);
                            else
                                newLine[0] = lsFlightCategory.IndexOf(sExcept);
                            if (FonctionsType.getInt(newLine[0]) >= 0)
                                newLine[0] = FonctionsType.getInt(newLine[0]) + 1;
                        }
                    }
                    newLine[iOffset] = Group[0];
                    newLine[iOffset+1] = Group[2];
                    newLine[iOffset+2] = Group[3];
                    newLine[iOffset+3] = j + 1;
                    Double fv = 0, sv = 0, tv = 0;
                    int iIndexDistrib = isProcessTable_Distrib_1;
                    int iIndexParams1 = isProcessTable_Param1_1;
                    int iIndexParams2 = isProcessTable_Param2_1;
                    int iIndexParams3 = isProcessTable_Param3_1;
                    if (j == 1)
                    {
                        iIndexDistrib = isProcessTable_Distrib_2;
                        iIndexParams1 = isProcessTable_Param1_2;
                        iIndexParams2 = isProcessTable_Param2_2;
                        iIndexParams3 = isProcessTable_Param3_2;
                    }
                    if (line.ItemArray[iIndexParams1].ToString() != "")
                        Double.TryParse(line.ItemArray[iIndexParams1].ToString(), out fv);

                    if (line.ItemArray[iIndexParams2].ToString() != "")
                        Double.TryParse(line.ItemArray[iIndexParams2].ToString(), out sv);

                    if (line.ItemArray[iIndexParams3].ToString() != "")
                        Double.TryParse(line.ItemArray[iIndexParams3].ToString(), out tv);

                    distribution = DistributionType(line.ItemArray[iIndexDistrib].ToString(), fv, sv, tv, htNames);
                    if (distribution[0] == -1)
                        continue;

                    newLine[iOffset + 4] = (int)distribution[0];
                    for (i = 1; i < distribution.Length; i++)
                    {
                        newLine[iOffset + 4 + i] = distribution[i];
                    }
                    try
                    {
                        resultats.Rows.Add(newLine);
                    }
                    catch (Exception exc)
                    {
                        OverallTools.ExternFunctions.PrintLogFile("Except02037: GestionDonneesHUB2SIM.generateProcessTimes( throw an exception: " + exc.Message);
                    }
                }
            }
            return resultats;
        }

        // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
        internal static Dictionary<String, DataTable> generateProcessTimes_V2(NormalTable ntProcessTimes,
            List<String> lsAirline, List<String> lsFlightCategory, Hashtable htNames)
        {
            Dictionary<String, DataTable> dsdtResult = new Dictionary<string, DataTable>();
            if (ntProcessTimes == null)
                return null;
            DataTable dtNormal = generateProcessTimes_V2(ntProcessTimes.Table, lsAirline, lsFlightCategory, htNames, null);
            if (dtNormal != null)
                dsdtResult.Add("", dtNormal);
            if (!(ntProcessTimes is ExceptionTable))
                return dsdtResult;
            ExceptionTable etTable = (ExceptionTable)ntProcessTimes;
            if (etTable.ExceptionAirline != null)
            {
                dtNormal = generateProcessTimes_V2(etTable.ExceptionAirline.Table, lsAirline, lsFlightCategory, htNames, GlobalNames.Airline);
                if (dtNormal != null)
                    dsdtResult.Add("_Airline", dtNormal);
            }
            if (etTable.ExceptionAirlineFB != null)
            {
                dtNormal = generateProcessTimes_V2(etTable.ExceptionAirlineFB.Table, lsAirline, lsFlightCategory, htNames, GlobalNames.Airline);
                if (dtNormal != null)
                    dsdtResult.Add("_AirlineFB", dtNormal);
            }
            if (etTable.ExceptionFlight != null)
            {
                dtNormal = generateProcessTimes_V2(etTable.ExceptionFlight.Table, lsAirline, lsFlightCategory, htNames, GlobalNames.Flight);
                if (dtNormal != null)
                    dsdtResult.Add("_Flight", dtNormal);
            }
            if (etTable.ExceptionFlightFB != null)
            {
                dtNormal = generateProcessTimes_V2(etTable.ExceptionFlightFB.Table, lsAirline, lsFlightCategory, htNames, GlobalNames.Flight);
                if (dtNormal != null)
                    dsdtResult.Add("_FlightFB", dtNormal);
            }
            if (etTable.ExceptionFB != null)
            {
                dtNormal = generateProcessTimes_V2(etTable.ExceptionFB.Table, lsAirline, lsFlightCategory, htNames, null);
                if (dtNormal != null)
                    dsdtResult.Add("_FB", dtNormal);
            }
            if (etTable.ExceptionFC != null)
            {
                dtNormal = generateProcessTimes_V2(etTable.ExceptionFC.Table, lsAirline, lsFlightCategory, htNames, GlobalNames.FlightCategory);
                if (dtNormal != null)
                    dsdtResult.Add("_FC", dtNormal);
            }
            if (etTable.ExceptionFCFB != null)
            {
                dtNormal = generateProcessTimes_V2(etTable.ExceptionFCFB.Table, lsAirline, lsFlightCategory, htNames, GlobalNames.FlightCategory);
                if (dtNormal != null)
                    dsdtResult.Add("_FCFB", dtNormal);
            }

            return dsdtResult;
        }

        public static DataTable generateProcessTimes_V2(DataTable ProcessTimes,
            List<String> lsAirline, List<String> lsFlightCategory, Hashtable htNames, String sColonneException)
        {
            DataTable results = new DataTable("ProcessingTimes_V2");
            int indexException = -1;
            int offset = 0;
            bool airline = false;

            if (ProcessTimes == null)
                return null;

            if (sColonneException != null)
            {
                airline = sColonneException == GlobalNames.Airline;
                indexException = ProcessTimes.Columns.IndexOf(sColonneException);
                if (indexException == -1)
                    return null;
                results.Columns.Add(new DataColumn(sColonneException, System.Type.GetType("System.Int32")));
                offset++;
                if (sColonneException == GlobalNames.Flight)
                {
                    results.Columns.Add(new DataColumn("TypeFlight", System.Type.GetType("System.Int32")));
                    offset++;
                }
            }
            results.Columns.Add(new DataColumn(GlobalNames.TERMINAL_COLUMN_NAME, System.Type.GetType("System.Int32")));
            results.Columns.Add(new DataColumn(GlobalNames.GROUP_TYPE_COLUMN_NAME, System.Type.GetType("System.Int32")));
            results.Columns.Add(new DataColumn(GlobalNames.GROUP_INDEX_COLUMN_NAME, System.Type.GetType("System.Int32")));
            results.Columns.Add(new DataColumn(GlobalNames.DISTRIBUTION_INDEX_COLUMN_NAME, System.Type.GetType("System.Int32")));
            results.Columns.Add(new DataColumn(GlobalNames.WAIT_BASE_COLUMN_NAME, System.Type.GetType("System.Int32")));
            results.Columns.Add(new DataColumn(GlobalNames.DISTRIBUTION_COLUMN_NAME, System.Type.GetType("System.Int32")));
            results.Columns.Add(new DataColumn(GlobalNames.FIRST_PARAMETER_COLUMN_NAME, System.Type.GetType("System.Double")));
            results.Columns.Add(new DataColumn(GlobalNames.SECOND_PARAMETER_COLUMN_NAME, System.Type.GetType("System.Double")));
            results.Columns.Add(new DataColumn(GlobalNames.THIRD_PARAMETER_COLUMN_NAME, System.Type.GetType("System.Double")));

            #region Process Times Table columns indexes - definition and verification
            int processTableItemsColumnIndex = ProcessTimes.Columns.IndexOf(GlobalNames.sProcessTable_Items);
            int processTableDistrib1ColumnIndex = ProcessTimes.Columns.IndexOf(GlobalNames.sProcessTable_Distrib_1);
            int processTableParam1_1ColumnIndex = ProcessTimes.Columns.IndexOf(GlobalNames.sProcessTable_Param1_1);
            int processTableParam2_1ColumnIndex = ProcessTimes.Columns.IndexOf(GlobalNames.sProcessTable_Param2_1);
            int processTableParam3_1ColumnIndex = ProcessTimes.Columns.IndexOf(GlobalNames.sProcessTable_Param3_1);
            int processTableDistrib2ColumnIndex = ProcessTimes.Columns.IndexOf(GlobalNames.sProcessTable_Distrib_2);
            int processTableParam1_2ColumnIndex = ProcessTimes.Columns.IndexOf(GlobalNames.sProcessTable_Param1_2);
            int processTableParam2_2ColumnIndex = ProcessTimes.Columns.IndexOf(GlobalNames.sProcessTable_Param2_2);
            int processTableParam3_2ColumnIndex = ProcessTimes.Columns.IndexOf(GlobalNames.sProcessTable_Param3_2);
            int processTableWaitingReferenceColumnIndex = ProcessTimes.Columns.IndexOf(GlobalNames.sProcessTable_WaitingTimeReference);
            int processTableDistrib3ColumnIndex = ProcessTimes.Columns.IndexOf(GlobalNames.sProcessTable_Distrib_3);
            int processTableParam1_3ColumnIndex = ProcessTimes.Columns.IndexOf(GlobalNames.sProcessTable_Param1_3);
            int processTableParam2_3ColumnIndex = ProcessTimes.Columns.IndexOf(GlobalNames.sProcessTable_Param2_3);
            int processTableParam3_3ColumnIndex = ProcessTimes.Columns.IndexOf(GlobalNames.sProcessTable_Param3_3);

            if (processTableItemsColumnIndex == -1 || processTableDistrib1ColumnIndex == -1 || processTableParam1_1ColumnIndex == -1
                || processTableParam2_1ColumnIndex == -1 || processTableParam3_1ColumnIndex == -1 || processTableDistrib2ColumnIndex == -1
                || processTableParam1_2ColumnIndex == -1 || processTableParam2_2ColumnIndex == -1 || processTableParam3_2ColumnIndex == -1
                || processTableWaitingReferenceColumnIndex == -1 || processTableDistrib3ColumnIndex == -1 || processTableParam1_3ColumnIndex == -1
                || processTableParam2_3ColumnIndex == -1 || processTableParam3_3ColumnIndex == -1)
            {
                return null;
            }
            #endregion

            int[] group;
            Double[] distribution;
            DataRow newLine;
            int i;
            foreach (DataRow processTimesRow in ProcessTimes.Rows)
            {
                group = OverallTools.DataFunctions
                    .AnalyzeGroupName(processTimesRow.ItemArray[processTableItemsColumnIndex].ToString());
                if (group == null)
                    continue;

                for (int j = 0; j < 3; j++)
                {
                    newLine = results.NewRow();
                    if (indexException != -1)
                    {
                        String sExcept = processTimesRow.ItemArray[indexException].ToString();
                        if (offset > 1)
                        {
                            String[] sValue = sExcept.Split('_');
                            if (sValue[0] == "D")
                                newLine[1] = 0;
                            else
                                newLine[1] = 1;
                            int iValue;
                            Int32.TryParse(sValue[1], out iValue);
                            newLine[0] = iValue;
                        }
                        else
                        {
                            if (airline)
                                newLine[0] = lsAirline.IndexOf(sExcept);
                            else
                                newLine[0] = lsFlightCategory.IndexOf(sExcept);
                            if (FonctionsType.getInt(newLine[0]) >= 0)
                                newLine[0] = FonctionsType.getInt(newLine[0]) + 1;
                        }
                    }
                    newLine[offset] = group[0];
                    newLine[offset + 1] = group[2];
                    newLine[offset + 2] = group[3];
                    newLine[offset + 3] = j + 1;
                    Double fv = 0, sv = 0, tv = 0;
                    int iIndexDistrib = processTableDistrib1ColumnIndex;
                    int iIndexParams1 = processTableParam1_1ColumnIndex;
                    int iIndexParams2 = processTableParam2_1ColumnIndex;
                    int iIndexParams3 = processTableParam3_1ColumnIndex;
                    if (j == 1)
                    {
                        iIndexDistrib = processTableDistrib2ColumnIndex;
                        iIndexParams1 = processTableParam1_2ColumnIndex;
                        iIndexParams2 = processTableParam2_2ColumnIndex;
                        iIndexParams3 = processTableParam3_2ColumnIndex;
                    }
                    else if (j == 2)
                    {
                        iIndexDistrib = processTableDistrib3ColumnIndex;
                        iIndexParams1 = processTableParam1_3ColumnIndex;
                        iIndexParams2 = processTableParam2_3ColumnIndex;
                        iIndexParams3 = processTableParam3_3ColumnIndex;
                    }
                    if (processTimesRow.ItemArray[iIndexParams1].ToString() != "")
                        Double.TryParse(processTimesRow.ItemArray[iIndexParams1].ToString(), out fv);

                    if (processTimesRow.ItemArray[iIndexParams2].ToString() != "")
                        Double.TryParse(processTimesRow.ItemArray[iIndexParams2].ToString(), out sv);

                    if (processTimesRow.ItemArray[iIndexParams3].ToString() != "")
                        Double.TryParse(processTimesRow.ItemArray[iIndexParams3].ToString(), out tv);

                    distribution = DistributionType(processTimesRow.ItemArray[iIndexDistrib].ToString(), fv, sv, tv, htNames);
                    if (distribution[0] == -1)
                        continue;

                    //wait base computation
                    String waitTimeReference = processTimesRow.ItemArray[processTableWaitingReferenceColumnIndex].ToString();
                    int waitBase = 0;

                    if (j == 2 && !waitTimeReference.Equals(GlobalNames.STA) && !waitTimeReference.Equals(GlobalNames.STD))
                        continue;
                    if (waitTimeReference.Equals(GlobalNames.STD))
                        waitBase = 1;
                    else if (waitTimeReference.Equals(GlobalNames.STA))
                        waitBase = 2;
                    if (j == 2)
                        newLine[offset + 4] = waitBase;
                    else
                        newLine[offset + 4] = 0;

                    newLine[offset + 5] = (int)distribution[0];
                    for (i = 1; i < distribution.Length; i++)
                    {
                        newLine[offset + 5 + i] = distribution[i];
                    }
                    try
                    {
                        results.Rows.Add(newLine);
                    }
                    catch (Exception exc)
                    {
                        OverallTools.ExternFunctions
                            .PrintLogFile("Except02037: GestionDonneesHUB2SIM.generateProcessTimes_V2( threw an exception: "
                                            + exc.Message);
                    }
                }
            }
            return results;
        }
        // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)

        private static Double[] DistributionType(String distribution, Double FirstValue, Double SecondValue, Double ThirdValue, Hashtable htNames)
        {
            Double[] resultats = new Double[4];
            for (int i = 0; i < 4; i++)
            {
                resultats[i] = 0;
            }
            switch (distribution)
            {
                case "Constant":
                case "C":
                    resultats[0] = Constant;
                    resultats[1] = FirstValue;
                    break;
                case "Uniform":
                case "U":
                    resultats[0] = Uniform;
                    resultats[1] = FirstValue;
                    resultats[2] = SecondValue;
                    break;
                case "Triangular":
                case "T":
                    resultats[0] = Triangular;
                    resultats[1] = FirstValue;
                    resultats[2] = SecondValue;
                    resultats[3] = ThirdValue;
                    break;
                case "Normal":
                case "N":
                    resultats[0] = Normal;
                    resultats[1] = FirstValue;
                    resultats[2] = SecondValue;
                    break;
                case "Exponential":
                case "E":
                    resultats[0] = Exponential;
                    resultats[1] = FirstValue;
                    break;
                case "Gamma":
                case "G":
                    resultats[0] = Gamma;
                    resultats[1] = FirstValue;
                    resultats[2] = SecondValue;
                    break;
                case "LogNormal":
                case "L":
                    resultats[0] = LogNormal;
                    resultats[1] = FirstValue;
                    resultats[2] = SecondValue;
                    break;
                case "Weibull":
                case "W":
                    resultats[0] = Weibull;
                    resultats[1] = FirstValue;
                    resultats[2] = SecondValue;
                    break;
                default:
                    if ((distribution == "") || (distribution == null) || (!htNames.ContainsKey(distribution)))
                    {
                        resultats[0] = -1;
                    }
                    else
                    {
                        resultats[0] = (int)htNames[distribution];
                    }
                    break;
            }
            return resultats;
        }
        #endregion

        #region Generation SaturationTable
        private static DataTable ConvertSaturationTable(DataTable dtSource)
        {
            if(dtSource == null)
                return null;
            DataTable dtResult = new DataTable("OpeningOnSaturation.txt");
            dtResult.Columns.Add("Terminal", typeof(Int32));
            dtResult.Columns.Add("Group Type", typeof(Int32));
            dtResult.Columns.Add("Group Index", typeof(Int32));
            dtResult.Columns.Add("Filling Queue", typeof(Int32));
            dtResult.Columns.Add("%Opened", typeof(Int32));
            dtResult.Columns.Add("Accumulation", typeof(Int32));
            dtResult.Columns.Add("ReactionTime", typeof(Int32));

            int iIndex_Element = dtSource.Columns.IndexOf(GlobalNames.sCapaQueue_Element);
            int iIndex_ApplyRules = dtSource.Columns.IndexOf(GlobalNames.sSaturation_ApplyRules);
            int iIndex_Filling = dtSource.Columns.IndexOf(GlobalNames.sSaturation_Filling);
            int iIndex_Opened = dtSource.Columns.IndexOf(GlobalNames.sSaturation_Opened);
            int iIndex_Accumulation = dtSource.Columns.IndexOf(GlobalNames.sSaturation_Accumulation);
            int iIndex_ReactionTime = dtSource.Columns.IndexOf(GlobalNames.sSaturation_ReactionTime);

            if ((iIndex_Element == -1) ||
                (iIndex_ApplyRules == -1) ||
                (iIndex_Filling == -1) ||
                (iIndex_Opened == -1) ||
                (iIndex_Accumulation == -1) ||
                (iIndex_ReactionTime == -1))
            {
                return null;
            }



            foreach (DataRow drRow in dtSource.Rows)
            {
                if (!FonctionsType.getBoolean(drRow[iIndex_ApplyRules]))
                    continue;
                int[] group = OverallTools.DataFunctions.AnalyzeGroupName(FonctionsType.getString(drRow[iIndex_Element]));
                if (group == null)
                    continue;
                DataRow newLine = dtResult.NewRow();
                newLine[0] = group[0];
                newLine[1] = group[2];
                newLine[2] = group[3];

                // << Task #9412 Pax2Sim - Scenario parameters files - Settings and OpeningOnSaturation                
                /*
                if(FonctionsType.getBoolean(drRow[iIndex_Filling]))
                    newLine[3] = 1;
                else
                    newLine[3] = 0;
                 */
                String localFillingType = FonctionsType.getString(drRow[iIndex_Filling]);

                if (localFillingType.Equals(GlobalNames.FIRST_STATION_FILLING_TYPE))
                    newLine[3] = 0;
                else if (localFillingType.Equals(GlobalNames.SATURATE_STATION_FILLING_TYPE))
                    newLine[3] = 1;
                else if (localFillingType.Equals(GlobalNames.RANDOM_STATION_FILLING_TYPE))
                    newLine[3] = 2;
                // >> Task #9412 Pax2Sim - Scenario parameters files - Settings and OpeningOnSaturation

                newLine[4] = FonctionsType.getInt(drRow[iIndex_Opened]);
                newLine[5] = FonctionsType.getInt(drRow[iIndex_Accumulation]);
                newLine[6] = FonctionsType.getInt(drRow[iIndex_ReactionTime]);
                dtResult.Rows.Add(newLine);
            }

            return dtResult ;
        }

        #endregion

        #region Fonction pour la génération des horaires des Check In pour Automod
        public static DataTable generateCheckInTable(DataTable AllocationTable, DateTime dateHeureDebutAnalyse, DateTime dateHeureFinAnalyse)
        {
            DataTable Resultats = new DataTable("CheckInTable");
            Resultats.Columns.Add("Terminal", System.Type.GetType("System.Int32"));
            Resultats.Columns.Add("Index", System.Type.GetType("System.Int32"));
            Resultats.Columns.Add("Time", System.Type.GetType("System.Int32"));

            if (AllocationTable == null)
                return Resultats;
            int iIndexDebut = -1;
            int iIndexFin = -1;
            int i;
            DateTime dateTestee = new DateTime();
            for (i = 0; i < AllocationTable.Rows.Count; i++)
            {
                if (!DateTime.TryParse(AllocationTable.Rows[i].ItemArray[0].ToString(), out dateTestee))
                {
                    return null;
                }
                if ((dateTestee > dateHeureDebutAnalyse) && (iIndexDebut == -1))
                {
                    iIndexDebut = i;
                }
                else if (dateHeureFinAnalyse < dateTestee)
                {
                    iIndexFin = i;
                    break;
                }
            }
            if (iIndexDebut == -1)
            {
                return Resultats;
            }

            if (iIndexDebut != 0)
                iIndexDebut--;
            DataRow newLine;
            bool bLastValue;

            for (int iIndexColumn = 1; iIndexColumn < AllocationTable.Columns.Count; iIndexColumn++)
            {
                int[] group = OverallTools.DataFunctions.AnalyzeGroupName(AllocationTable.Columns[iIndexColumn].ColumnName);
                bLastValue = false;
                if (iIndexFin == -1)
                {
                    iIndexFin = AllocationTable.Rows.Count;
                }

                for (i = iIndexDebut; i < iIndexFin; i++)
                {
                    DateTime.TryParse(AllocationTable.Rows[i].ItemArray[0].ToString(), out dateTestee);
                    if (bLastValue == (Boolean)AllocationTable.Rows[i].ItemArray[iIndexColumn])
                        continue;
                    bLastValue = !bLastValue;
                    newLine = Resultats.NewRow();
                    newLine[0] = group[0];
                    //newLine[1] = group[1];
                    newLine[1] = group[3];
                    newLine[2] = (int)OverallTools.DataFunctions.MinuteDifference(dateHeureDebutAnalyse, dateTestee);
                    try
                    {
                        Resultats.Rows.Add(newLine);
                    }
                    catch (Exception exc)
                    {
                        OverallTools.ExternFunctions.PrintLogFile("Except02038: generateCheckInTable(...) throw an exception: " + exc.Message);
                    }
                }
            }
            return Resultats;
        }

        #endregion

#if(NEWALLOCATIONSECU)
        #region Fonction pour la génération des horaires des Security Check/ Passport Check et Transfer Desk pour Automod
        public static List<DataTable> generateSecurityTable(String sName, 
            DataTable AllocationTable, 
            DateTime dateHeureDebutAnalyse, 
            DateTime dateHeureFinAnalyse,
            bool bPassport,
            List<String> lsAirline, 
            List<String> lsFlightCategory,
            DataTable userAttributesTable,  //>> Task #7405 - new Desk and extra information for Pax
            Dictionary<String, String> userAttributesDictionary)    // << Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab
        {
            // << Task #7570 new Desk and extra information for Pax -Phase I B            
            if (AllocationTable == null)
                return null;            
            // >> Task #7570 new Desk and extra information for Pax -Phase I B
            if (AllocationTable.Rows.Count == 0)
                return null;
            #region Initialistion des tables 
            DataTable dtTableMain = new DataTable(sName);
            DataTable dtTableFC= new DataTable(sName+"_FC");
            DataTable dtTableAirline= new DataTable(sName+"_Airline");
            DataTable dtTableFlight= new DataTable(sName+"_Flight");
            //<< Task #7405 - new Desk and extra information for Pax
            DataTable dtTableUserAtt = new DataTable(sName + "_UserAtt");
            //>> Task #7405 - new Desk and extra information for Pax
            
            dtTableMain.Columns.Add("Terminal", System.Type.GetType("System.Int32"));
            dtTableMain.Columns.Add("GroupIndex", System.Type.GetType("System.Int32"));
            dtTableMain.Columns.Add("Time", System.Type.GetType("System.Int32"));
            dtTableMain.Columns.Add("NumberOpen", System.Type.GetType("System.Int32"));
            
            dtTableMain.Columns.Add("Passport", System.Type.GetType("System.Int32"));
            dtTableMain.Columns.Add("Classe", System.Type.GetType("System.Int32"));
            dtTableMain.Columns.Add("Remaining", System.Type.GetType("System.Int32"));

            dtTableMain.Columns.Add("FC", System.Type.GetType("System.Int32"));
            dtTableMain.Columns.Add("Airline", System.Type.GetType("System.Int32"));
            dtTableMain.Columns.Add("Flight", System.Type.GetType("System.Int32"));


            dtTableFC.Columns.Add("Terminal", System.Type.GetType("System.Int32"));
            dtTableFC.Columns.Add("GroupIndex", System.Type.GetType("System.Int32"));
            dtTableFC.Columns.Add("Time", System.Type.GetType("System.Int32"));
            dtTableFC.Columns.Add("Flight Category", System.Type.GetType("System.Int32"));


            dtTableAirline.Columns.Add("Terminal", System.Type.GetType("System.Int32"));
            dtTableAirline.Columns.Add("GroupIndex", System.Type.GetType("System.Int32"));
            dtTableAirline.Columns.Add("Time", System.Type.GetType("System.Int32"));
            dtTableAirline.Columns.Add("Airline", System.Type.GetType("System.Int32"));


            dtTableFlight.Columns.Add("Terminal", System.Type.GetType("System.Int32"));
            dtTableFlight.Columns.Add("GroupIndex", System.Type.GetType("System.Int32"));
            dtTableFlight.Columns.Add("Time", System.Type.GetType("System.Int32"));
            dtTableFlight.Columns.Add("Direction", System.Type.GetType("System.Int32"));
            dtTableFlight.Columns.Add("Flight", System.Type.GetType("System.Int32"));

            //<< Task #7405 - new Desk and extra information for Pax
            dtTableUserAtt.Columns.Add("Terminal", System.Type.GetType("System.Int32"));
            dtTableUserAtt.Columns.Add("GroupIndex", System.Type.GetType("System.Int32"));
            dtTableUserAtt.Columns.Add("Time", System.Type.GetType("System.Int32"));
            dtTableUserAtt.Columns.Add("Column Index", System.Type.GetType("System.Int32"));
            dtTableUserAtt.Columns.Add("Include", System.Type.GetType("System.Int32"));
            dtTableUserAtt.Columns.Add("Value", System.Type.GetType("System.String"));
            //>> Task #7405 - new Desk and extra information for Pax
            
            #endregion


            int iIndexDebut = -1;
            int iIndexFin = -1;
            DateTime dtCurrentTime;
            #region Récupération des index de lignes correspondantes aux données à exporter.
            //<< Task #7405 - new Desk and extra information for Pax
            int allocationTableRows = AllocationTable.Rows.Count;
            DateTime startAllocationTableDate = FonctionsType.getDate(AllocationTable.Rows[0][0]);
            DateTime endAllocationTableDate = FonctionsType.getDate(AllocationTable.Rows[allocationTableRows - 1][0]);
            if (endAllocationTableDate <= dateHeureDebutAnalyse || startAllocationTableDate >= dateHeureFinAnalyse)
                return new List<DataTable>(new DataTable[] { dtTableMain, dtTableFC, dtTableAirline, dtTableFlight, dtTableUserAtt });
            //>> Task #7405 - new Desk and extra information for Pax
            int i;
            for (i = 0; i < AllocationTable.Rows.Count; i++)
            {
                dtCurrentTime = FonctionsType.getDate(AllocationTable.Rows[i][0]);
                if ((dtCurrentTime > dateHeureDebutAnalyse) && (iIndexDebut == -1))
                {
                    iIndexDebut = i;
                }
                else if (dateHeureFinAnalyse <= dtCurrentTime)
                {
                    iIndexFin = i;
                    break;
                }
            }
            if (iIndexFin == -1)
                iIndexFin = AllocationTable.Rows.Count;
            #endregion



            if (iIndexDebut != 0) iIndexDebut--;
            DataRow newLine;
            Assistant.AllocationAssistantManager.GroupAllocation gaAllocation, gaAllocationOld;
                    
            int iEntierTeste = 0;
            //<< Task #7405 - new Desk and extra information for Pax
            List<string> userAttributesNames = OverallTools.StaticAnalysis.PaxPlanClass.getUserAttributesNames(userAttributesTable);
/*
            List<string> userAttributesNames = new List<string>();
            if (userAttributesTable != null)
            {
                // << Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab
                if (userAttributesDictionary != null)
                {
                    foreach (KeyValuePair<String, String> pair in userAttributesDictionary)
                    {
                        String userAttributeName = pair.Key;
                        String distributionTableName = pair.Value;

                        // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                        if (!GlobalNames.nonUserAttributesExceptionsList.Contains(userAttributeName))
                            userAttributesNames.Add(userAttributeName);                        
                        // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    }
                }
                // >> Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab
            }
*/
            //>> Task #7405 - new Desk and extra information for Pax
            for (int iIndexColumn = 1; iIndexColumn < AllocationTable.Columns.Count; iIndexColumn++)
            {
                int[] group = OverallTools.DataFunctions.AnalyzeGroupName(AllocationTable.Columns[iIndexColumn].ColumnName);
                newLine = dtTableMain.NewRow();
                dtCurrentTime = FonctionsType.getDate(AllocationTable.Rows[iIndexDebut][0]);
                int iCurrentTime = (int)OverallTools.DataFunctions.MinuteDifference(dateHeureDebutAnalyse, dtCurrentTime);
                gaAllocation =null;                
                if ((dtCurrentTime > dateHeureDebutAnalyse) && (iIndexDebut != 0))
                {
                    newLine[0] = group[0];
                    newLine[1] = group[3];
                    newLine[2] = 0;
                    newLine[3] = 0;

                    newLine[4] = 3;

                    newLine[5] = 3;
                    newLine[6] = 0;


                    newLine[7] = 0;
                    newLine[8] = 0;
                    newLine[9] = 0;
                }
                else
                {
                    #region Gestion de la première ligne de l'allocation (par colonne)
                    newLine[0] = group[0];
                    newLine[1] = group[3];
                    newLine[2] = iCurrentTime;                    
                    gaAllocation = new Assistant.AllocationAssistantManager.GroupAllocation(dtCurrentTime,
                        dtCurrentTime,
                        AllocationTable.Rows[iIndexDebut][iIndexColumn].ToString(),
                        bPassport,
                        userAttributesNames);
                    newLine[3] = gaAllocation.StationsNumber;

                    newLine[4] = gaAllocation.PassportTypeNumber;
                    newLine[5] = gaAllocation.ClassTypeNumber;
                    newLine[6] = FonctionsType.getDouble(gaAllocation.TimeType);


                    newLine[7] = gaAllocation.FlightCategoryStatus;
                    newLine[8] = gaAllocation.AirlinesStatus;
                    newLine[9] = gaAllocation.FlightIdentificationStatus;

                    if (gaAllocation.FlightCategoryStatus != 0)
                    {
                        CreateExceptionForAllocationTableForAutomod(dtTableFC,
                            gaAllocation.FlightCategory,
                            lsFlightCategory,
                            false,
                            group[0],
                            group[3],
                            iCurrentTime);

                    }
                    if (gaAllocation.AirlinesStatus != 0)
                    {
                        CreateExceptionForAllocationTableForAutomod(dtTableAirline,
                            gaAllocation.Airlines,
                            lsAirline,
                            false,
                            group[0],
                            group[3],
                            iCurrentTime);
                    }
                    if (gaAllocation.FlightIdentificationStatus != 0)
                    {
                        CreateExceptionForAllocationTableForAutomod(dtTableFlight,
                            gaAllocation.FlightIdentification,
                            null,
                            true,
                            group[0],
                            group[3],
                            iCurrentTime);
                    }
                    CreateExceptionForAllocationTableForAutomod(dtTableUserAtt, gaAllocation.userAttributeValuesDictionary,
                                                                userAttributesNames, group[0], group[3], iCurrentTime);
                    #endregion
                }
                #region Ajout de la ligne
                try
                {
                    dtTableMain.Rows.Add(newLine);
                }
                catch (Exception exc)
                {
                    OverallTools.ExternFunctions.PrintLogFile("Except02039: generateSecurityTable throw an exception: " + exc.Message);
                }
                #endregion

                int Value = iEntierTeste;
                gaAllocationOld = gaAllocation;
                gaAllocationOld.userAttributeValuesDictionary = new Dictionary<string, string>(gaAllocation.userAttributeValuesDictionary);

                for (i = iIndexDebut + 1; i < iIndexFin; i++)
                {
                    dtCurrentTime = FonctionsType.getDate(AllocationTable.Rows[i][0]);

                    gaAllocation = new Assistant.AllocationAssistantManager.GroupAllocation(dtCurrentTime,
                        dtCurrentTime,
                        AllocationTable.Rows[i][iIndexColumn].ToString(),
                        bPassport,
                        userAttributesNames);
                    if (gaAllocation == gaAllocationOld)
                        continue;
                    iCurrentTime = (int)OverallTools.DataFunctions.MinuteDifference(dateHeureDebutAnalyse, dtCurrentTime);

                    newLine = dtTableMain.NewRow();
                    newLine[0] = group[0];
                    newLine[1] = group[3];
                    newLine[2] = iCurrentTime;
                    newLine[3] = gaAllocation.StationsNumber;

                    newLine[4] = gaAllocation.PassportTypeNumber;
                    newLine[5] = gaAllocation.ClassTypeNumber;
                    newLine[6] = FonctionsType.getDouble(gaAllocation.TimeType);


                    newLine[7] = gaAllocation.FlightCategoryStatus;
                    newLine[8] = gaAllocation.AirlinesStatus;
                    newLine[9] = gaAllocation.FlightIdentificationStatus;
                    if (gaAllocation.FlightCategoryStatus != 0)
                    {
                        CreateExceptionForAllocationTableForAutomod(dtTableFC,
                            gaAllocation.FlightCategory,
                            lsFlightCategory,
                            false,
                            group[0],
                            group[3],
                            iCurrentTime);

                    }
                    if (gaAllocation.AirlinesStatus != 0)
                    {
                        CreateExceptionForAllocationTableForAutomod(dtTableAirline,
                            gaAllocation.Airlines,
                            lsAirline,
                            false,
                            group[0],
                            group[3],
                            iCurrentTime);
                    }
                    if (gaAllocation.FlightIdentificationStatus != 0)
                    {
                        CreateExceptionForAllocationTableForAutomod(dtTableFlight,
                            gaAllocation.FlightIdentification,
                            null,
                            true,
                            group[0],
                            group[3],
                            iCurrentTime);
                    }
                    CreateExceptionForAllocationTableForAutomod(dtTableUserAtt, gaAllocation.userAttributeValuesDictionary,
                                                                userAttributesNames, group[0], group[3], iCurrentTime);
                    try
                    {
                        dtTableMain.Rows.Add(newLine);
                    }
                    catch (Exception exc)
                    {
                        OverallTools.ExternFunctions.PrintLogFile("Except02040: generateSecurityTable throw an exception: " + exc.Message);
                    }
                    gaAllocationOld = gaAllocation;
                    gaAllocationOld.userAttributeValuesDictionary = new Dictionary<string, string>(gaAllocation.userAttributeValuesDictionary);
                }
            }
            //<< Task #7405 - new Desk and extra information for Pax            
            return new List<DataTable>(new DataTable[] { dtTableMain, dtTableFC, dtTableAirline, dtTableFlight, dtTableUserAtt });
            //>> Task #7405 - new Desk and extra information for Pax
        }
        private static void CreateExceptionForAllocationTableForAutomod(DataTable dtTable, 
            String sListExceptions, 
            List<String> lsIndexes, 
            bool bFlightExceptions,
            int iTerminal,
            int iGroupIndex,
            int iTime)
        {
            String[] lsObjets = sListExceptions.Split(',');
            bool bNegation = false;
            bool bIgnoreNegation = false;
            DataRow newRow;
            foreach (String sObjet in lsObjets)
            {
                if (sObjet.StartsWith("!"))
                {
                    bNegation = true;
                }
                else
                {
                    bIgnoreNegation = true;
                    break;
                }
            }
            foreach (String sObjet in lsObjets)
            {
                if (sObjet.StartsWith("!") && bIgnoreNegation)
                    continue;
                String sTmp = sObjet;
                if (bNegation)
                    sTmp = sObjet.Replace("!", "");
                bool bArrival = false;
                int iIndex = -1;
                if (bFlightExceptions)
                {
                    if (sTmp.StartsWith("A"))
                        bArrival = true;

                    iIndex = FonctionsType.getInt(sTmp.Substring(2));
                }
                else
                {
                    iIndex = lsIndexes.IndexOf(sTmp);
                    ///The starts indexes in Automd are 1 (not 0).
                    if (iIndex >= 0)
                        iIndex++;
                }

                newRow = dtTable.NewRow();
                newRow[0] = iTerminal;
                newRow[1] = iGroupIndex;
                newRow[2] = iTime;
                if (bFlightExceptions)
                {
                    if (bArrival)
                        newRow[3] = 0;
                    else
                        newRow[3] = 1;
                    newRow[4] = iIndex;
                }
                else
                {
                    newRow[3] = iIndex;
                }
                dtTable.Rows.Add(newRow);
            }
        }

        //<< Task #7405 - new Desk and extra information for Pax        
        private static void CreateExceptionForAllocationTableForAutomod(DataTable dtTable,
            Dictionary<string, string> sUserAttributeValues,
            List<string> userAttributeNames,
            int iTerminal,
            int iGroupIndex,
            int iTime)
        {
            for (int index = 0; index < userAttributeNames.Count; index++)
            {
                String currentUserAttributeName = userAttributeNames[index];
                if (!sUserAttributeValues.ContainsKey(currentUserAttributeName))
                    continue;

                String[] lsObjets = sUserAttributeValues[currentUserAttributeName].Split(',');
                bool bNegation = false;
                bool bIgnoreNegation = false;
                DataRow newRow;
                foreach (String sObjet in lsObjets)
                {
                    if (sObjet.StartsWith("!"))
                    {
                        bNegation = true;
                    }
                    else
                    {
                        bIgnoreNegation = true;
                        break;
                    }
                }
                foreach (String sObjet in lsObjets)
                {
                    if (sObjet.StartsWith("!") && bIgnoreNegation)
                        continue;
                    String sTmp = sObjet;
                    if (bNegation)
                        sTmp = sObjet.Replace("!", "");
                    bool bArrival = false;
                    int iIndex = -1;
  
                    newRow = dtTable.NewRow();
                    newRow[0] = iTerminal;
                    newRow[1] = iGroupIndex;
                    newRow[2] = iTime;
                    newRow[3] = index;
                    newRow[4] = bNegation ? -1 : 1;
                    newRow[5] = sTmp;
                    dtTable.Rows.Add(newRow);
                }
            }
        }
        //>> Task #7405 - new Desk and extra information for Pax
        #endregion
#else
        #region Fonction pour la génération des horaires des Security Check pour Automod
        public static DataTable generateSecurityTable(/*XmlNode racine,*/ DataTable AllocationTable, DateTime dateHeureDebutAnalyse, DateTime dateHeureFinAnalyse)
        {
            DataTable Resultats = new DataTable("SecurityTable");
            Resultats.Columns.Add("Terminal", System.Type.GetType("System.Int32"));
            Resultats.Columns.Add("GroupIndex", System.Type.GetType("System.Int32"));
            Resultats.Columns.Add("Time", System.Type.GetType("System.Int32"));
            Resultats.Columns.Add("NumberOpen", System.Type.GetType("System.Int32"));
            int iIndexDebut = -1;
            int iIndexFin = -1;
            int i;
            DateTime dateTestee = new DateTime();
            for (i = 0; i < AllocationTable.Rows.Count; i++)
            {
                if (!DateTime.TryParse(AllocationTable.Rows[i].ItemArray[0].ToString(), out dateTestee))
                {
                    return null;
                }
                if ((dateTestee > dateHeureDebutAnalyse) && (iIndexDebut == -1))
                {
                    iIndexDebut = i;
                }
                else if (dateHeureFinAnalyse < dateTestee)
                {
                    iIndexFin = i;
                    break;
                }
            }
            if (iIndexDebut == -1)
            {
                return Resultats;
            }
            if (iIndexDebut != 0) iIndexDebut--;
            DataRow newLine;
            int iEntierTeste = 0;
            for (int iIndexColumn = 1; iIndexColumn < AllocationTable.Columns.Count; iIndexColumn++)
            {
                int[] group = OverallTools.DataFunctions.AnalyzeGroupName(AllocationTable.Columns[iIndexColumn].ColumnName);
                newLine = Resultats.NewRow();
                DateTime.TryParse(AllocationTable.Rows[iIndexDebut].ItemArray[0].ToString(), out dateTestee);
                if ((dateTestee > dateHeureDebutAnalyse) && (iIndexDebut != 0))
                {
                    newLine[0] = group[0];
                    //newLine[1] = group[1];
                    newLine[1] = group[3];
                    //newLine[3] = getIndexFirstDesk(racine, group[0], group[1], group[2], group[3]);
                    newLine[2] = 0;
                    newLine[3] = 0;
                }
                else
                {
                    if (!Int32.TryParse(AllocationTable.Rows[iIndexDebut].ItemArray[iIndexColumn].ToString(), out iEntierTeste))
                    {
                        iEntierTeste = 0;
                    }
                    newLine[0] = group[0];
                    //newLine[1] = group[1];
                    newLine[1] = group[3];
                    //newLine[3] = getIndexFirstDesk(racine, group[0], group[1], group[2], group[3]);
                    newLine[2] = (int)OverallTools.DataFunctions.MinuteDifference(dateHeureDebutAnalyse, dateTestee);
                    newLine[3] = iEntierTeste;
                }
                try
                {
                    Resultats.Rows.Add(newLine);
                }
                catch (Exception exc)
                {
                    OverallTools.ExternFunctions.PrintLogFile("Except02039: generateSecurityTable throw an exception: " + exc.Message);
                }
                int Value = iEntierTeste;
                if (iIndexFin == -1)
                {
                    iIndexFin = AllocationTable.Rows.Count;
                }
                for (i = iIndexDebut + 1; i < iIndexFin; i++)
                {
                    DateTime.TryParse(AllocationTable.Rows[i].ItemArray[0].ToString(), out dateTestee);
                    if (!Int32.TryParse(AllocationTable.Rows[i].ItemArray[iIndexColumn].ToString(), out iEntierTeste))
                    {
                        iEntierTeste = 0;
                        //return null;
                    }
                    if (iEntierTeste != Value)
                    {
                        newLine = Resultats.NewRow();
                        newLine[0] = group[0];
                        //newLine[1] = group[1];
                        newLine[1] = group[3];
                        //newLine[3] = getIndexFirstDesk(racine, group[0], group[1], group[2], group[3]);
                        newLine[2] = (int)OverallTools.DataFunctions.MinuteDifference(dateHeureDebutAnalyse, dateTestee);
                        newLine[3] = iEntierTeste;
                        try
                        {
                            Resultats.Rows.Add(newLine);
                        }
                        catch (Exception exc)
                        {
                            OverallTools.ExternFunctions.PrintLogFile("Except02040: generateSecurityTable throw an exception: " + exc.Message);
                        }
                        Value = iEntierTeste;
                    }
                }
            }
            return Resultats;
        }
        #endregion
#endif

        #region Fonction pour la génération des horaires des Passport Check pour Automod

        private static int[] extractPassportDesc(String Desc)
        {
            if (Desc.IndexOf(',') == -1)
            {
                return null;
            }
            int[] Results = new int[2];
            if ((!Int32.TryParse(Desc.Substring(0, Desc.IndexOf(',')), out Results[0])) ||
                (!Int32.TryParse(Desc.Substring(Desc.IndexOf(',') + 1), out Results[1])))
            {
                return null;
            }
            return Results;
        }
        public static DataTable generatePassportTable(DataTable AllocationTable, DateTime dateHeureDebutAnalyse, DateTime dateHeureFinAnalyse)
        {
            if (AllocationTable == null)
                return null;
            DataTable Resultats = new DataTable("PassportAllocation");
            Resultats.Columns.Add("Terminal", System.Type.GetType("System.Int32"));
            Resultats.Columns.Add("GroupIndex", System.Type.GetType("System.Int32"));
            Resultats.Columns.Add("Time", System.Type.GetType("System.Int32"));
            Resultats.Columns.Add("Type", System.Type.GetType("System.Int32"));
            Resultats.Columns.Add("NumberOpen", System.Type.GetType("System.Int32"));
            int iIndexDebut = -1;
            int iIndexFin = -1;
            int i;
            int[] Type_NumberOpen = null;
            DateTime dateTestee = new DateTime();
            for (i = 0; i < AllocationTable.Rows.Count; i++)
            {
                if (!DateTime.TryParse(AllocationTable.Rows[i].ItemArray[0].ToString(), out dateTestee))
                {
                    return null;
                }
                if ((dateTestee > dateHeureDebutAnalyse) && (iIndexDebut == -1))
                {
                    iIndexDebut = i;
                }
                else if (dateHeureFinAnalyse < dateTestee)
                {
                    iIndexFin = i;
                    break;
                }
            }
            if (iIndexDebut == -1)
                return Resultats;
            if (iIndexDebut != 0) iIndexDebut--;
            DataRow newLine;
            for (int iIndexColumn = 1; iIndexColumn < AllocationTable.Columns.Count; iIndexColumn++)
            {
                int[] group = OverallTools.DataFunctions.AnalyzeGroupName(AllocationTable.Columns[iIndexColumn].ColumnName);
                newLine = Resultats.NewRow();
                DateTime.TryParse(AllocationTable.Rows[iIndexDebut].ItemArray[0].ToString(), out dateTestee);
                if ((dateTestee > dateHeureDebutAnalyse) && (iIndexDebut != 0))
                {
                    newLine[0] = group[0];
                    //newLine[1] = group[1];
                    newLine[1] = group[3];
                    //newLine[3] = getIndexFirstDesk(racine, group[0], group[1], group[2], group[3]);
                    newLine[2] = 0;
                    newLine[3] = 0;
                    newLine[4] = 0;
                }
                else
                {
                    Type_NumberOpen = extractPassportDesc(AllocationTable.Rows[iIndexDebut].ItemArray[iIndexColumn].ToString());
                    if (Type_NumberOpen == null)
                    {
                        Type_NumberOpen = new Int32[2] { 1, 0 };
                    }
                    newLine[0] = group[0];
                    //newLine[1] = group[1];
                    newLine[1] = group[3];
                    //newLine[3] = getIndexFirstDesk(racine, group[0], group[1], group[2], group[3]);
                    newLine[2] = (int)OverallTools.DataFunctions.MinuteDifference(dateHeureDebutAnalyse, dateTestee);
                    newLine[3] = Type_NumberOpen[0];
                    newLine[4] = Type_NumberOpen[1];
                }
                try
                {
                    Resultats.Rows.Add(newLine);
                }
                catch (Exception exc)
                {
                    OverallTools.ExternFunctions.PrintLogFile("Except02041: generateSecurityTable throw an exception: " + exc.Message);
                }
                int[] Value = Type_NumberOpen;
                if (iIndexFin == -1)
                    iIndexFin = AllocationTable.Rows.Count;
                for (i = iIndexDebut + 1; i < iIndexFin; i++)
                {
                    DateTime.TryParse(AllocationTable.Rows[i].ItemArray[0].ToString(), out dateTestee);

                    Type_NumberOpen = extractPassportDesc(AllocationTable.Rows[i].ItemArray[iIndexColumn].ToString());
                    if (Type_NumberOpen == null)
                    {
                        Type_NumberOpen = new Int32[2] { 1, 0 };
                    }
                    if ((Type_NumberOpen[0] != Value[0]) || (Type_NumberOpen[1] != Value[1]))
                    {
                        newLine = Resultats.NewRow();
                        newLine[0] = group[0];
                        //newLine[1] = group[1];
                        newLine[1] = group[3];
                        //newLine[3] = getIndexFirstDesk(racine, group[0], group[1], group[2], group[3]);
                        newLine[2] = (int)OverallTools.DataFunctions.MinuteDifference(dateHeureDebutAnalyse, dateTestee);
                        newLine[3] = Type_NumberOpen[0];
                        newLine[4] = Type_NumberOpen[1];
                        try
                        {
                            Resultats.Rows.Add(newLine);
                        }
                        catch (Exception exc)
                        {
                            OverallTools.ExternFunctions.PrintLogFile("Except02042: generatePassportTable throw an exception: " + exc.Message);
                        }
                        Value = Type_NumberOpen;
                    }
                }
            }
            return Resultats;
        }
        #endregion

        #region Fonction pour la génération du fichier Oneof.
        public static DataTable generateOneofAutomod(DataTable OneofTable, Hashtable htNames)
        {
            DataTable OneofAutomod = new DataTable("OneofAutomod");
            OneofAutomod.Columns.Add("Name", System.Type.GetType("System.Int32"));
            OneofAutomod.Columns.Add("Value", System.Type.GetType("System.Double"));
            OneofAutomod.Columns.Add("Frequency", System.Type.GetType("System.Double"));
            if (htNames.Count != 0)
                htNames.Clear();
            int iKey = StartingIndexOneof;

            foreach (DataColumn column in OneofTable.Columns)
            {
                String ColumnName = column.ColumnName;
                if (ColumnName.LastIndexOf("Value") == (ColumnName.Length - 5))
                    continue;
                if (ColumnName.LastIndexOf("Frequency") == -1)
                    continue;
                String DistributionName = ColumnName.Substring(0, ColumnName.LastIndexOf("Frequency") - 1);

                if (!htNames.ContainsKey(DistributionName))
                {
                    htNames.Add(DistributionName, iKey);
                }
                int iIndexValue = OneofTable.Columns.IndexOf(DistributionName + " Value");
                if (iIndexValue == -1)
                    continue;
                DataRow NewLine;//
                foreach (DataRow line in OneofTable.Rows)
                {
                    if (((Double)line[iIndexValue] == 0) && ((Double)line[column] == 0))
                        break;
                    NewLine = OneofAutomod.NewRow();
                    NewLine[0] = iKey;
                    NewLine[2] = (Double)line[column];
                    NewLine[1] = (Double)line[iIndexValue];
                    OneofAutomod.Rows.Add(NewLine);
                }
                iKey++;
            }
            return OverallTools.DataFunctions.sortTable(OneofAutomod, "Name"); ;
        }
        #endregion

        #region Fonction pour la génération du fichier avec les capacités de queues.
        public static DataTable generateCapaQueuesAutomod(String sTable, DataTable capaQueues)
        {
            DataTable capaQueuesAutomod = new DataTable(sTable);
            capaQueuesAutomod.Columns.Add("Terminal", System.Type.GetType("System.Int32"));
            capaQueuesAutomod.Columns.Add("Type", System.Type.GetType("System.Int32"));
            capaQueuesAutomod.Columns.Add("Index", System.Type.GetType("System.Int32"));
            capaQueuesAutomod.Columns.Add("Capa", System.Type.GetType("System.Int32"));
            foreach (DataRow line in capaQueues.Rows)
            {
                int[] res = OverallTools.DataFunctions.AnalyzeGroupName(line.ItemArray[0].ToString());
                if (res == null)
                    continue;
                int nb;
                if (!Int32.TryParse(line.ItemArray[1].ToString(), out nb))
                    continue;
                if (nb == -1)
                    continue;
                DataRow newLine = capaQueuesAutomod.NewRow();
                newLine[0] = res[0];
                //newLine[1] = res[1];
                newLine[1] = res[2];
                newLine[2] = res[3];
                newLine[3] = nb;
                try
                {
                    capaQueuesAutomod.Rows.Add(newLine);
                }
                catch (Exception exc)
                {
                    OverallTools.ExternFunctions.PrintLogFile("Except02043: generateCapaQueuesAutomod throw an exception: " + exc.Message);
                }
            }
            return capaQueuesAutomod;
        }
        internal static Dictionary<String, Int32> generateCapaQueues(DataTable[] dtTables)
        {
            Dictionary<String, Int32> dsiResults = new Dictionary<string, int>();
            int nb;
            foreach (DataTable dtTable in dtTables)
            {
                foreach (DataRow line in dtTable.Rows)
                {
                    if (dsiResults.ContainsKey(line.ItemArray[0].ToString()))
                        continue;
                    if (!Int32.TryParse(line.ItemArray[1].ToString(), out nb))
                        continue;
                    dsiResults.Add(line.ItemArray[0].ToString(), nb);
                }
            }
            return dsiResults;
        }
        public static DataTable generateBHSCapaQueuesAutomod(String sTable, DataTable capaQueues)
        {
            DataTable capaQueuesAutomod = new DataTable(sTable);
            capaQueuesAutomod.Columns.Add("Terminal", System.Type.GetType("System.Int32"));
            capaQueuesAutomod.Columns.Add("Type", System.Type.GetType("System.Int32"));
            capaQueuesAutomod.Columns.Add("Index", System.Type.GetType("System.Int32"));
            capaQueuesAutomod.Columns.Add("Capa", System.Type.GetType("System.Int32"));
            foreach (DataRow line in capaQueues.Rows)
            {
                int[] res = OverallTools.DataFunctions.AnalyzeGroupNameBHS(line.ItemArray[0].ToString());
                if (res == null)
                    continue;
                int nb;
                if (!Int32.TryParse(line.ItemArray[1].ToString(), out nb))
                    continue;
                if (nb == -1)
                    continue;
                DataRow newLine = capaQueuesAutomod.NewRow();
                newLine[0] = res[0];
                newLine[1] = res[1];
                newLine[2] = res[2];
                newLine[3] = nb;
                try
                {
                    capaQueuesAutomod.Rows.Add(newLine);
                }
                catch (Exception exc)
                {
                    OverallTools.ExternFunctions.PrintLogFile("Except02044: generateBHSCapaQueuesAutomod throw an exception: " + exc.Message);
                }
            }
            return capaQueuesAutomod;
        }
        #endregion

        #region Fonction pour la génération du fichier pour les queues animées
        public static DataTable generateAnimatedQueues(String sTable, DataTable animatedQueues)
        {
            DataTable capaQueuesAutomod = new DataTable(sTable);
            capaQueuesAutomod.Columns.Add("Index", typeof(Int32));
            foreach (DataRow line in animatedQueues.Rows)
            {
                int nb = OverallTools.FonctionUtiles.toGroupRepresentation(line[0].ToString());
                if (nb == -1)
                    continue;
                capaQueuesAutomod.Rows.Add(nb);
            }
            return capaQueuesAutomod;
        }
        #endregion

        #region Fonctions pour la génération de la structure de l'aéroport.
        public static DataTable generateAiportStructure(XmlNode structure)
        {
            DataTable AiportStructure = new DataTable("AirportStructure");
            AiportStructure.Columns.Add("Terminal", System.Type.GetType("System.Int32"));
            AiportStructure.Columns.Add("Level", System.Type.GetType("System.Int32"));
            AiportStructure.Columns.Add("GroupType", System.Type.GetType("System.Int32"));
            AiportStructure.Columns.Add("GroupIndex", System.Type.GetType("System.Int32"));
            AiportStructure.Columns.Add("Begin", System.Type.GetType("System.Int32"));
            AiportStructure.Columns.Add("End", System.Type.GetType("System.Int32"));
            foreach (XmlNode Terminaux in structure.ChildNodes)
            {
                int iTerminal;
                if (!Int32.TryParse(Terminaux.Attributes["Index"].Value, out iTerminal))
                    continue;
                foreach (XmlNode Levels in Terminaux.ChildNodes)
                {
                    int iLevel;
                    if (!Int32.TryParse(Levels.Attributes["Index"].Value, out iLevel))
                        continue;
                    foreach (XmlNode Groupe in Levels.ChildNodes)
                    {
                        if (Groupe.FirstChild == null)
                            continue;
                        int iGroupType = OverallTools.DataFunctions.AnalyzeName(Groupe.Attributes["Type"].Value);
                        if (iGroupType == -1)
                            continue;
                        int iGroupIndex;
                        if (!Int32.TryParse(Groupe.Attributes["Index"].Value, out iGroupIndex))
                            continue;
                        int iIndexDebut;
                        if (!Int32.TryParse(Groupe.FirstChild.Attributes["Index"].Value, out iIndexDebut))
                            continue;
                        int iIndexFin;
                        if (!Int32.TryParse(Groupe.LastChild.Attributes["Index"].Value, out iIndexFin))
                            continue;
                        DataRow newLine = AiportStructure.NewRow();
                        newLine[0] = iTerminal;
                        newLine[1] = iLevel;
                        newLine[2] = iGroupType;
                        newLine[3] = iGroupIndex;
                        newLine[4] = iIndexDebut;
                        newLine[5] = iIndexFin;
                        AiportStructure.Rows.Add(newLine);
                    }
                }
            }
            return AiportStructure;
        }
        public static DataTable generateAiportStructureForBHS(XmlNode structure, int Terminal)
        {
            DataTable AiportStructure = new DataTable("BHSAirportStructure");
            AiportStructure.Columns.Add("Type", System.Type.GetType("System.Int32"));
            AiportStructure.Columns.Add("Group", System.Type.GetType("System.Int32"));
            AiportStructure.Columns.Add("Start Index", System.Type.GetType("System.Int32"));
            AiportStructure.Columns.Add("End Index", System.Type.GetType("System.Int32"));

            foreach (XmlNode Terminaux in structure.ChildNodes)
            {
                int iTerminal;
                if (!Int32.TryParse(Terminaux.Attributes["Index"].Value, out iTerminal))
                    continue;
                if (iTerminal != Terminal)
                    continue;
                foreach (XmlNode Levels in Terminaux.ChildNodes)
                {
                    foreach (XmlNode Groupe in Levels.ChildNodes)
                    {
                        if (Groupe.FirstChild == null)
                            continue;
                        int iGroupType = OverallTools.DataFunctions.AnalyzeNameBHS(Groupe.Attributes["Type"].Value);
                        if (iGroupType == -1)
                            continue;
                        int iGroupIndex;
                        if (!Int32.TryParse(Groupe.Attributes["Index"].Value, out iGroupIndex))
                            continue;
                        int iIndexDebut;
                        if (!Int32.TryParse(Groupe.FirstChild.Attributes["Index"].Value, out iIndexDebut))
                            continue;
                        int iIndexFin;
                        if (!Int32.TryParse(Groupe.LastChild.Attributes["Index"].Value, out iIndexFin))
                            continue;
                        DataRow newLine = AiportStructure.NewRow();
                        newLine[0] = iGroupType;
                        newLine[1] = iGroupIndex;
                        newLine[2] = iIndexDebut;
                        newLine[3] = iIndexFin;
                        AiportStructure.Rows.Add(newLine);
                    }

                }
            }
            return AiportStructure;
        }
        #endregion
        #endregion

        #region Nouvelle fonction pour l'exportation de la table Itinerary

        #region classe ItineraryArrow
        private class ItineraryArrow
        {
            public String Originating__;
            public String Destination__;
            public Double Weight__;
            public String Distribution__;
            public Double param1__;
            public Double param2__;
            public Double param3__;

            public String goals__;
            private void Initialize(String Originating, String Destination,
                                  Double Weight, String Distribution,
                                  Double param1, Double param2, Double param3,
                                  String goals)
            {
                Originating__ = Originating;
                Destination__ = Destination;
                Weight__ = Weight;
                Distribution__ = Distribution;
                param1__ = param1;
                param2__ = param2;
                param3__ = param3;
                goals__ = goals;
            }
            public ItineraryArrow(String Originating, String Destination,
                                  Double Weight, String Distribution,
                                  Double param1, Double param2, Double param3)
            {
                Initialize(Originating, Destination, Weight, Distribution, param1, param2, param3, "");
            }
            public ItineraryArrow(String Originating, String Destination,
                                  Double Weight, String Distribution,
                                  Double param1, Double param2, Double param3,
                                  String goals)
            {
                Initialize(Originating, Destination, Weight, Distribution, param1, param2, param3, goals);
            }

            #region public override string ToString()
            public Object[] ToObjects(Hashtable htNames)
            {
                Object[] result = new Object[13];
                Int32[] tmp = OverallTools.DataFunctions.AnalyzeGroupName(Originating__);
                Double[] tmp2;
                if (tmp == null)
                    return null;

                result[0] = tmp[0];
                result[1] = tmp[2];
                result[2] = tmp[3];
                if (tmp[2] == 0)
                    result[2] = tmp[1];
                tmp = OverallTools.DataFunctions.AnalyzeGroupName(Destination__);
                if (tmp == null)
                    return null;
                result[3] = tmp[0];
                result[4] = tmp[2];
                result[5] = tmp[3];
                if (tmp[2] == 0)
                    result[5] = tmp[1];

                result[6] = Weight__;
                tmp2 = DistributionType(Distribution__, param1__, param2__, param3__, htNames);
                for (int i = 0; i < tmp2.Length; i++)
                {
                    result[7 + i] = tmp2[i];
                }

                return result;
            }
            public override string ToString()
            {
                String Result = "";
                Int32[] tmp = OverallTools.DataFunctions.AnalyzeGroupName(Originating__);
                if (tmp == null)
                    return null;
                Result = toFormatedString(tmp);
                tmp = OverallTools.DataFunctions.AnalyzeGroupName(Destination__);
                if (tmp == null)
                    return null;
                Result += "\t" + toFormatedString(tmp);
                Result += "\t" + Weight__.ToString();
                Result += "\t" + Distribution__;
                Result += "\t" + param1__.ToString();
                Result += "\t" + param2__.ToString();
                Result += "\t" + param3__.ToString();
                return Result;
            }
            public int getNumberOfGoals()
            {
                if (goals__.Length == 0)
                    return 0;
                return goals__.Split(',').Length;
            }
            public Object[][] GoalsToObjects()
            {
                String[] goals = goals__.Split(',');
                Object[][] Result = new Object[goals.Length][];
                Int32[] tmp;
                for (int i = 0; i < goals.Length; i++)
                {
                    tmp = OverallTools.DataFunctions.AnalyzeGroupName(goals[i]);
                    if (tmp == null)
                        return null;
                    Result[i] = new Object[3];
                    Result[i][0] = tmp[0];
                    Result[i][1] = tmp[2];
                    Result[i][2] = tmp[3];
                    if (tmp[2] == 0)
                        Result[i][2] = tmp[1];
                }
                return Result;

            }
            public String[] GoalsToString()
            {
                String[] goals = goals__.Split(',');
                String[] Result = new String[goals.Length];
                Int32[] tmp;
                for (int i = 0; i < goals.Length; i++)
                {
                    tmp = OverallTools.DataFunctions.AnalyzeGroupName(goals[i]);
                    if (tmp == null)
                        return null;
                    Result[i] = toFormatedString(tmp);
                }
                return Result;
            }
            private String toFormatedString(Int32[] type)
            {
                return type[0].ToString() + "\t" + type[1].ToString() + "\t" + type[2].ToString() + "\t" + type[3].ToString();
            }
            #endregion
        }
        #endregion


        #region Gestion de la génération des tables utilisées pour le ProcessSchedule

        // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)

        public static String[] getProcessScheduleNames(DataTable ProcessSchedule,
                                                       String sObservedColumn,
                                                       String sDefaultTable,
                                                       DateTime dtBegin,
                                                       DateTime dtEnd,
                                                       out DataTable dt_Schedule)
        {
            return getProcessScheduleNames(ProcessSchedule, sObservedColumn, sDefaultTable,
                                             dtBegin, dtEnd, out dt_Schedule, false);
        }

        public static String[] getProcessScheduleNames(DataTable ProcessSchedule,
                                                       String sObservedColumn,
                                                       String sDefaultTable,
                                                       DateTime dtBegin,
                                                       DateTime dtEnd,
                                                       out DataTable dt_Schedule,
                                                       bool forCapaQueues)
        {
            int iIndexBegin = ProcessSchedule.Columns.IndexOf("Begin");
            int iIndexEnd = ProcessSchedule.Columns.IndexOf("End");
            int iIndexItinerary = ProcessSchedule.Columns.IndexOf(sObservedColumn);
            dt_Schedule = null;
            if (iIndexBegin == -1) return null;
            if (iIndexEnd == -1) return null;
            if (iIndexItinerary == -1) return null;
            List<String> l_s_Results = new List<string>();
            dt_Schedule = new DataTable("ProcessSchedule");
            dt_Schedule.Columns.Add("Time", typeof(Int32));
            // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
            if (forCapaQueues)
                dt_Schedule.Columns.Add(GlobalNames.CAPA_PROCESS_VERSION_COLUMN_NAME, typeof(Int32));
            else
                dt_Schedule.Columns.Add(sObservedColumn, typeof(Int32));
            // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)            

            DataTable dt_Tmp = OverallTools.DataFunctions.sortTable(ProcessSchedule, "Begin");
            for (int i = 0; i < dt_Tmp.Rows.Count; i++)
            {
                DateTime dtRowBegin = (DateTime)dt_Tmp.Rows[i][iIndexBegin];
                DateTime dtRowEnd = (DateTime)dt_Tmp.Rows[i][iIndexEnd];
                if (((dtRowBegin > dtBegin) && (dtRowBegin < dtEnd)) ||
                   ((dtRowEnd > dtBegin) && (dtRowEnd < dtEnd)))
                {
                    if ((dtRowBegin > dtBegin) && (dt_Schedule.Rows.Count == 0))
                    {
                        l_s_Results.Add(sDefaultTable);
                        dt_Schedule.Rows.Add(new Object[] { 0, 1 });
                    }


                    String sNomTable = dt_Tmp.Rows[i][iIndexItinerary].ToString();
                    if (!l_s_Results.Contains(sNomTable))
                        l_s_Results.Add(sNomTable);
                    int iIndexTable = l_s_Results.IndexOf(sNomTable) + 1;
                    Double dTime = OverallTools.DataFunctions.MinuteDifference(dtBegin, dtRowBegin);
                    dt_Schedule.Rows.Add(new Object[] { FonctionsType.getInt(Math.Round(dTime, 0)), iIndexTable });
                }
            }
            if (l_s_Results.Count == 0)
            {
                l_s_Results.Add(sDefaultTable);
                dt_Schedule.Rows.Add(new Object[] { 0, 1 });

            }
            return l_s_Results.ToArray();
        }
        // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)



        #region Pour les process times
        public void generateProcessTimes(DataTable ProcessSchedule,
                                            out List<Dictionary<String,DataTable>> AutomodProcess,
                                            out DataTable dt_Schedule,
                                            List<String> lsAirline, 
                                            List<String> lsFlightCategory,
                                            Hashtable htNames,
                                            DateTime dtBegin,
                                            DateTime dtEnd)
        {
            AutomodProcess = null;
            dt_Schedule = null;
            if (ProcessSchedule == null)
                return;
            String[] ts_Process = getProcessScheduleNames(ProcessSchedule, GlobalNames.sTableProcessScheduleProcess, GlobalNames.Times_ProcessTableName, dtBegin, dtEnd, out dt_Schedule);
            if (ts_Process == null)
                return;
            if (ts_Process.Length == 0)
            {
                dt_Schedule = null;
                return;
            }
            AutomodProcess = new List<Dictionary<String,DataTable>>();

            for (int i = 0; i < ts_Process.Length; i++)
            {
                NormalTable dtProcess = GetTable("Input", ts_Process[i]);
                if (dtProcess == null)
                {
                    AutomodProcess = null;
                    dt_Schedule = null;
                    return;
                }
                AutomodProcess.Add(generateProcessTimes(dtProcess,lsAirline,lsFlightCategory, htNames));
            }
        }

        // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
        public void generateProcessTimes_V2(DataTable ProcessSchedule,
                                            out List<Dictionary<String, DataTable>> AutomodProcess,
                                            out DataTable dt_Schedule,
                                            List<String> lsAirline,
                                            List<String> lsFlightCategory,
                                            Hashtable htNames,
                                            DateTime dtBegin,
                                            DateTime dtEnd)
        {
            AutomodProcess = null;
            dt_Schedule = null;
            if (ProcessSchedule == null)
                return;
            String[] ts_Process = getProcessScheduleNames(ProcessSchedule, GlobalNames.sTableProcessScheduleProcess, GlobalNames.Times_ProcessTableName, dtBegin, dtEnd, out dt_Schedule);
            if (ts_Process == null)
                return;
            if (ts_Process.Length == 0)
            {
                dt_Schedule = null;
                return;
            }
            AutomodProcess = new List<Dictionary<String, DataTable>>();

            for (int i = 0; i < ts_Process.Length; i++)
            {
                NormalTable dtProcess = GetTable("Input", ts_Process[i]);
                if (dtProcess == null)
                {
                    AutomodProcess = null;
                    dt_Schedule = null;
                    return;
                }
                AutomodProcess.Add(generateProcessTimes_V2(dtProcess, lsAirline, lsFlightCategory, htNames));
            }
        }
        // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
        #endregion

        #region Pour les queues
        public void generateGroupQueuesAutomod(DataTable GroupQueuesSchedule,
                                            out DataTable[] GroupQueuesAutomod,
                                            out DataTable dt_Schedule,
                                            DateTime dtBegin,
                                            DateTime dtEnd)
        {
            generateCapaQueuesAutomod(GroupQueuesSchedule,
                                           out GroupQueuesAutomod,
                                            out dt_Schedule,
                                             dtBegin,
                                             dtEnd,
                                            GlobalNames.sTableProcessScheduleGroupQueues,
                                            GlobalNames.Group_QueuesName);
        }
        public void generateCapaQueuesAutomod(DataTable CapaQueuesSchedule,
                                            out DataTable[] CapaQueuesAutomod,
                                            out DataTable dt_Schedule,
                                            DateTime dtBegin,
                                            DateTime dtEnd)
        {
            generateCapaQueuesAutomod(CapaQueuesSchedule,
                                           out CapaQueuesAutomod,
                                            out dt_Schedule,
                                             dtBegin,
                                             dtEnd,
                                            GlobalNames.sTableProcessScheduleProcessQueues,
                                            GlobalNames.Capa_QueuesTableName);
        }

        public void generateCapaQueuesAutomod(DataTable CapaQueuesSchedule,
                                            out DataTable[] CapaQueuesAutomod,
                                            out DataTable dt_Schedule,
                                            DateTime dtBegin,
                                            DateTime dtEnd,
                                            String sProcessColumnName,
                                            String sDefaultTableName)
        {
            CapaQueuesAutomod = null;
            dt_Schedule = null;
            if (CapaQueuesSchedule == null)
                return;
            String[] ts_Itinerary = getProcessScheduleNames(CapaQueuesSchedule, sProcessColumnName, sDefaultTableName, dtBegin, dtEnd, out dt_Schedule);
            if (ts_Itinerary == null)
                return;
            if (ts_Itinerary.Length == 0)
            {
                dt_Schedule = null;
                return;
            }
            CapaQueuesAutomod = new DataTable[ts_Itinerary.Length];

            for (int i = 0; i < ts_Itinerary.Length; i++)
            {
                DataTable dtCapaQueues = getTable("Input", ts_Itinerary[i]);
                if (dtCapaQueues == null)
                {
                    CapaQueuesAutomod = null;
                    dt_Schedule = null;
                    return;
                }
                CapaQueuesAutomod[i] = generateCapaQueuesAutomod(ts_Itinerary[i], dtCapaQueues);
            }
        }
        // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
        public void generateCapaQueuesAutomod_V2(DataTable CapaQueuesSchedule,
                                            out DataTable[] CapaQueuesAutomod,
                                            out DataTable dt_Schedule,
                                            DateTime dtBegin,
                                            DateTime dtEnd)
        {
            generateCapaQueuesAutomod_V2(CapaQueuesSchedule,
                                           out CapaQueuesAutomod,
                                            out dt_Schedule,
                                             dtBegin,
                                             dtEnd,
                                            GlobalNames.sTableProcessScheduleProcessCapacity,
                                            GlobalNames.capaProcessTableName);
        }

        public void generateCapaQueuesAutomod_V2(DataTable CapaQueuesSchedule,
                                            out DataTable[] CapaQueuesAutomod,
                                            out DataTable dt_Schedule,
                                            DateTime dtBegin,
                                            DateTime dtEnd,
                                            String sProcessColumnName,
                                            String sDefaultTableName)
        {
            CapaQueuesAutomod = null;
            dt_Schedule = null;
            if (CapaQueuesSchedule == null)
                return;
            String[] ts_Itinerary = getProcessScheduleNames(CapaQueuesSchedule, sProcessColumnName,
                sDefaultTableName, dtBegin, dtEnd, out dt_Schedule, true);
            if (ts_Itinerary == null)
                return;
            if (ts_Itinerary.Length == 0)
            {
                dt_Schedule = null;
                return;
            }
            CapaQueuesAutomod = new DataTable[ts_Itinerary.Length];

            for (int i = 0; i < ts_Itinerary.Length; i++)
            {
                DataTable dtCapaQueues = getTable("Input", ts_Itinerary[i]);
                if (dtCapaQueues == null)
                {
                    CapaQueuesAutomod = null;
                    dt_Schedule = null;
                    return;
                }
                CapaQueuesAutomod[i] = generateCapaQueuesAutomod(ts_Itinerary[i], dtCapaQueues);
            }
        }
        // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
        #endregion
        #region Pour l'itinerary
        public void generatePaxPath(DataTable ProcessSchedule,
                                            out DataTable[] AutomodItinerary,
                                            out DataTable[] AutomodGoals,
                                            out DataTable dt_Schedule,
                                            Hashtable htNames,
                                            DateTime dtBegin,
                                            DateTime dtEnd)
        {
            AutomodItinerary = null;
            AutomodGoals = null;
            dt_Schedule = null;
            if (ProcessSchedule == null)
                return;
            String[] ts_Itinerary = getProcessScheduleNames(ProcessSchedule, GlobalNames.sTableProcessScheduleItinerary, GlobalNames.ItineraryTableName, dtBegin, dtEnd, out dt_Schedule);
            if (ts_Itinerary == null)
                return;
            if (ts_Itinerary.Length == 0)
            {
                dt_Schedule = null;
                return;
            }
            AutomodItinerary = new DataTable[ts_Itinerary.Length];
            AutomodGoals = new DataTable[ts_Itinerary.Length];

            for (int i = 0; i < ts_Itinerary.Length; i++)
            {
                DataTable dtItinerary = getTable("Input", ts_Itinerary[i]);
                if (dtItinerary == null)
                {
                    AutomodItinerary = null;
                    AutomodGoals = null;
                    dt_Schedule = null;
                    return;
                }
                generatePaxPath(dtItinerary, out AutomodItinerary[i], out AutomodGoals[i], htNames);
            }
        }
        #endregion
        #endregion
        public static void generatePaxPath(DataTable ItineraryTable,
            out DataTable AutomodItinerary,
            out DataTable AutomodGoals,
            Hashtable htNames)
        {
            AutomodItinerary = null;
            AutomodGoals = null;
            if (ItineraryTable == null)
                return;
            ItineraryArrow ia_tmp;
            AutomodItinerary = new DataTable("PaxPath");
            AutomodItinerary.Columns.Add("Origin_T", typeof(Int32));
            //AutomodItinerary.Columns.Add("Origin_L", typeof(Int32));
            AutomodItinerary.Columns.Add("Origin_GroupType", typeof(Int32));
            AutomodItinerary.Columns.Add("Origin_GroupIndex", typeof(Int32));
            AutomodItinerary.Columns.Add("Destination_T", typeof(Int32));
            //AutomodItinerary.Columns.Add("Destination_L", typeof(Int32));
            AutomodItinerary.Columns.Add("Destination_GroupType", typeof(Int32));
            AutomodItinerary.Columns.Add("Destination_GroupIndex", typeof(Int32));

            AutomodItinerary.Columns.Add("Weight", typeof(Double));
            AutomodItinerary.Columns.Add("Distribution", typeof(Int32));
            AutomodItinerary.Columns.Add("Param1", typeof(Double));
            AutomodItinerary.Columns.Add("Param2", typeof(Double));
            AutomodItinerary.Columns.Add("Param3", typeof(Double));

            AutomodItinerary.Columns.Add("IndexGoals", typeof(Int32));
            AutomodItinerary.Columns.Add("NumberGoals", typeof(Int32));

            AutomodGoals = new DataTable("GoalsPaxPath");
            AutomodGoals.Columns.Add("T", typeof(Int32));
            //AutomodGoals.Columns.Add("L", typeof(Int32));
            AutomodGoals.Columns.Add("GroupType", typeof(Int32));
            AutomodGoals.Columns.Add("GroupIndex", typeof(Int32));

            ArrayList ItineraryTmp = new ArrayList();

            foreach (DataRow ligne in ItineraryTable.Rows)
            {
                ArrayList AccessibleGroups = new ArrayList();
                ArrayList AlreadyPassed = new ArrayList();
                ia_tmp = new ItineraryArrow(ligne.ItemArray[0].ToString(), ligne.ItemArray[1].ToString(), (Double)ligne.ItemArray[2], ligne.ItemArray[3].ToString(), (Double)ligne.ItemArray[4], (Double)ligne.ItemArray[5], (Double)ligne.ItemArray[6]);
                AlreadyPassed.Add(ligne.ItemArray[0].ToString());
                AlreadyPassed.Add(ligne.ItemArray[1].ToString());
                getRecursiveGoals(ItineraryTable, ligne.ItemArray[1].ToString(), ref AccessibleGroups, AlreadyPassed);
                ia_tmp.goals__ = GoalsToString(AccessibleGroups);
                ItineraryTmp.Add(ia_tmp);
            }
            int iIndex = 0;
            Object[] Link;
            Object[][] Goals;
            int iNbGoals;
            foreach (ItineraryArrow ia_tmp2 in ItineraryTmp)
            {
                Link = ia_tmp2.ToObjects(htNames);
                if (Link == null)
                    continue;

                iNbGoals = ia_tmp2.getNumberOfGoals();
                Link[Link.Length - 2] = iIndex;
                Link[Link.Length - 1] = iNbGoals;
                if (ia_tmp2.getNumberOfGoals() != 0)
                {
                    Goals = ia_tmp2.GoalsToObjects();
                    if (Goals == null)
                        continue;
                    iIndex += iNbGoals;
                    for (int i = 0; i < iNbGoals; i++)
                    {
                        try
                        {
                            AutomodGoals.Rows.Add(Goals[i]);
                        }
                        catch (Exception exc)
                        {
                            OverallTools.ExternFunctions.PrintLogFile("Except02045: generatePaxPath throw an exception: " + exc.Message);
                        }
                    }
                }
                try
                {
                    AutomodItinerary.Rows.Add(Link);
                }
                catch (Exception exc)
                {
                    OverallTools.ExternFunctions.PrintLogFile("Except02046: generatePaxPath throw an exception: " + exc.Message);
                }
            }
        }

        public static DataTable generateBHSPath(DataTable ItineraryTable, int iTerminal, Hashtable htNames)
        {
            if (ItineraryTable == null)
                return null;
            DataTable AutomodItinerary = new DataTable("BHSPath");
            AutomodItinerary.Columns.Add("OriginGroupType", typeof(Int32));
            AutomodItinerary.Columns.Add("OriginGroupIndex", typeof(Int32));
            AutomodItinerary.Columns.Add("Succeed", typeof(Int32));
            AutomodItinerary.Columns.Add("DestGroupType", typeof(Int32));
            AutomodItinerary.Columns.Add("DestGroupIndex", typeof(Int32));

            AutomodItinerary.Columns.Add("Distribution", typeof(Int32));
            AutomodItinerary.Columns.Add("Param1", typeof(Double));
            AutomodItinerary.Columns.Add("Param2", typeof(Double));
            AutomodItinerary.Columns.Add("Param3", typeof(Double));

            ArrayList ItineraryTmp = new ArrayList();


            foreach (DataRow ligne in ItineraryTable.Rows)
            {
                int[] Origin = OverallTools.DataFunctions.AnalyzeGroupNameBHS(ligne[0].ToString());
                int[] Dest = OverallTools.DataFunctions.AnalyzeGroupNameBHS(ligne[1].ToString());
                if ((Origin == null) || (Dest == null))
                    return null;
                DataRow drRow = AutomodItinerary.NewRow();
                if (Origin[0] != iTerminal)
                    continue;
                if (Dest[0] != iTerminal)
                    continue;
                drRow[0] = Origin[1];
                drRow[1] = Origin[2];
                
                bool succeed = false;
                if (ligne[2] != null)
                {
                    bool.TryParse(ligne[2].ToString(), out succeed);
                }
                drRow[2] = succeed;   //(bool)ligne[2];
                
                drRow[3] = Dest[1];
                drRow[4] = Dest[2];

                Double[] tmp2 = DistributionType(ligne[3].ToString(), (Double)ligne[4], (Double)ligne[5], (Double)ligne[6], htNames);
                for (int i = 0; i < tmp2.Length; i++)
                    drRow[5 + i] = tmp2[i];
                AutomodItinerary.Rows.Add(drRow);
            }
            return AutomodItinerary;
        }

        #region Fonctions pour rechercher tous les groupes atteignables à partir d'un groupe défini
        private static String GoalsToString(ArrayList list)
        {
            String resultat = "";
            for (int i = 0; i < list.Count; i++)
            {
                resultat += list[i].ToString();
                if (i != (list.Count - 1))
                {
                    resultat += ',';
                }
            }
            return resultat;
        }
        private static void getRecursiveGoals(DataTable ItineraryTable, String Group, ref ArrayList Resultats, ArrayList AlreadyPassed)
        {
            int[] types = OverallTools.DataFunctions.AnalyzeGroupName(Group);
            if (types == null)
                return;
            switch (types[2])
            {
                case GestionDonneesHUB2SIM.BaggageClaimGroup:
                case GestionDonneesHUB2SIM.BoardingGateGroup:
                case GestionDonneesHUB2SIM.CheckInGroup:
                case GestionDonneesHUB2SIM.TransferGroup:
                case GestionDonneesHUB2SIM.ArrivalGateGroup:
                    return;
                default:
                    break;
            }
            foreach (DataRow ligne in ItineraryTable.Rows)
            {
                if (ligne.ItemArray[0].ToString() != Group)
                    continue;

                if (Resultats.Contains(ligne.ItemArray[1].ToString()))
                    continue;

                if (AlreadyPassed.Contains(ligne.ItemArray[1].ToString()))
                    continue;
                types = OverallTools.DataFunctions.AnalyzeGroupName(ligne.ItemArray[1].ToString());
                if (types == null)
                    continue;
                switch (types[2])
                {
                    case GestionDonneesHUB2SIM.BaggageClaimGroup:
                    case GestionDonneesHUB2SIM.BoardingGateGroup:
                    case GestionDonneesHUB2SIM.CheckInGroup:
                    case GestionDonneesHUB2SIM.TransferGroup:
                    case GestionDonneesHUB2SIM.ArrivalGateGroup:
                    case GestionDonneesHUB2SIM.TerminalLevelEntry:
                    //case GestionDonneesHUB2SIM.ShuttleGroup:  // << Task #7570 new Desk and extra information for Pax -Phase I B
                    //case GestionDonneesHUB2SIM.ModelInGroup:
                    case GestionDonneesHUB2SIM.ModelOutGroup:
                        Resultats.Add(ligne.ItemArray[1].ToString());
                        if ((types[2] == GestionDonneesHUB2SIM.TerminalLevelEntry) || (types[2] == GestionDonneesHUB2SIM.ShuttleGroup))
                        {
                            AlreadyPassed.Add(ligne.ItemArray[1].ToString());
                            getRecursiveGoals(ItineraryTable, ligne.ItemArray[1].ToString(), ref Resultats, AlreadyPassed);
                        }
                        break;
                    default:
                        AlreadyPassed.Add(ligne.ItemArray[1].ToString());
                        getRecursiveGoals(ItineraryTable, ligne.ItemArray[1].ToString(), ref Resultats, AlreadyPassed);
                        break;
                }
            }
        }
        #endregion

        #endregion

        #region Fonction pour la mise à jour de l'affichage du BHS.

        public void SaveBHSDatas(XmlNode InPutData, TreeNode AirportNode, String folder, String relativeFolder, Prompt.SIM_LoadingForm chForm)
        {
            if (OverallTools.FonctionUtiles.estPresentDansListe(GlobalNames.sBHS_Itinerary, ListeNomTable))
            {
                //On doit sauvegarder les tables BHS globales
                foreach (String sName in ListeNomTablesBHS_Racine)
                {
                    if ((HiddenTables != null) && HiddenTables.Contains(sName))
                        continue;
                    DataTable tmp = getTable("Input", sName);
                    if (tmp == null)
                        continue;
                    if (chForm != null)
                        chForm.ChargementFichier("Saving project : " + sName);
                    XmlElement newNoeud = projet.CreateElement("Table");
                    newNoeud.SetAttribute("Name", sName);
                    newNoeud.AppendChild(projet.CreateTextNode("\\" + relativeFolder + "\\" + sName + ".txt"));
                    InPutData.AppendChild(newNoeud);
                    OverallTools.FonctionUtiles.EcritureFichier(tmp, folder + "\\" + newNoeud.FirstChild.Value, "\t", true);
                }
            }
            foreach (TreeNode tnAirportNode in AirportNode.Nodes)
            {
                TreeViewTag AirportTag = (TreeViewTag)tnAirportNode.Tag;
                if (AirportTag.AirportObjectType != PAX2SIM.sTerminalName)
                    continue;
                String TerminalName = GlobalNames.sBHS_PrefixeLong + AirportTag.Index.ToString();
                bool bFind = false;
                foreach (TreeNode tnAirportChild in tnAirportNode.Nodes)
                {
                    if (((TreeViewTag)tnAirportChild.Tag).AirportObjectType == PAX2SIM.sBHSName)
                    {
                        bFind = true;
                        break;
                    }
                }
                if (!bFind)
                    continue;
                //Sauvegarde de la partie BHS pour le Terminal concerné.

                foreach (String name in ListeNomTableBHS)
                {
                    String Name = TerminalName + "_" + name;
                    if (chForm != null)
                        chForm.ChargementFichier("Saving project : " + Name);
                    if (!tableEstPresente("Input", Name))
                        continue;
                    XmlElement newNoeud = projet.CreateElement("Table");
                    newNoeud.SetAttribute("Name", Name);
                    newNoeud.AppendChild(projet.CreateTextNode("\\" + relativeFolder + "\\" + Name + ".txt"));
                    InPutData.AppendChild(newNoeud);
                    OverallTools.FonctionUtiles.EcritureFichier(getTable("Input", Name), folder + "\\" + newNoeud.FirstChild.Value, "\t", true);
                }
            }
        }


        /// <summary>
        /// Fonction qui se charge de mettre à jour l'affichage du répertoire du treeview destiné au BHS.
        /// </summary>
        /// <param name="AirportNode">Le lien vers la structure de l'aéroport.</param>
        /// <param name="BHSNode">Le lien vers la structure des tables pour le BHS.</param>
        /// <param name="cmsTableMenu">Le menu contextuel lié aux tables.</param>
        public void UpdateBHSDirectory(TreeNode AirportNode, TreeNode BHSNode, ContextMenuStrip cmsTableMenu)
        {
            //Booléen servant à savoir s'il y a un terminal qui possède des définitions pour la partie BHS.
            //bool bHasBHSDefinition = false;
            List<Int32> liTerminauxPresents = new List<int>();
            foreach (TreeNode tnAirportNode in AirportNode.Nodes)
            {
                //On recherche dans le terminal observé, le noeud BHS, pour savoir le comportement qu'il va y falloir
                //appliqué.
                TreeViewTag AirportTag = (TreeViewTag)tnAirportNode.Tag;
                if (AirportTag.AirportObjectType != PAX2SIM.sTerminalName)
                    continue;
                liTerminauxPresents.Add(AirportTag.Index);
                String TerminalName = GlobalNames.BHS_Prefixe_Name + AirportTag.Index.ToString();
                String PrefixeTerminal = GlobalNames.sBHS_PrefixeLong + AirportTag.Index.ToString();
                bool bFind = false;
                foreach (TreeNode tnAirportChild in tnAirportNode.Nodes)
                {
                    if (((TreeViewTag)tnAirportChild.Tag).AirportObjectType == PAX2SIM.sBHSName)
                    {
                        bFind = true;
                        break;
                    }
                }

                if (!DataManagerInput.IsTerminalBHSAlreadyPresent(AirportTag.Index) && bFind)
                {
                    //Le noeud BHS pour le terminal considérer n'était pas encore présent, il faut donc ajouter
                    //ce noeud aux définitions et lancé la mise à jour des tables.
                    DataManagerInput.AddTerminalInputTables(AirportTag.Index);
                    if (liTerminalBHS == null)
                    {
                        liTerminalBHS = new List<int>();
                    }
                    liTerminalBHS.Add(AirportTag.Index);
                    liTerminalBHS.Sort();
                }
                else if (DataManagerInput.IsTerminalBHSAlreadyPresent(AirportTag.Index) && (!bFind))
                {
                    //Le noeud BHS a été supprimé dans le terminal considérer, il faut donc le supprimer dans
                    //la partie parametrage
                    RemoveTerminal(AirportTag.Index);
                }
            }
            if (liTerminalBHS != null)
            {
                if (liTerminauxPresents.Count != liTerminalBHS.Count)
                {
                    //Si certains terminaux ont été supprimés, il faut vérifier et supprimer les noeuds liés aux 
                    //BHS pour ces terminaux.
                    List<Int32> liTerminauxToRemove = new List<int>();
                    foreach (int iTerminal in liTerminalBHS)
                        if (!liTerminauxPresents.Contains(iTerminal))
                            liTerminauxToRemove.Add(iTerminal);
                    foreach (int iTerminal in liTerminauxToRemove)
                        RemoveTerminal(iTerminal);
                }
            }
            dmiInputData.InitializeTables();
            if (!bAirportStructureHadBeenModified)
            {
                bAirportStructureHadBeenModified = true;
                MAJ_TablesSuivantStructureAeroport(AirportNode);
                //MAJ_TablesSuivantStructureAeroport(structureAeroport);
                Update_FlightCategorie();

            }
        }
        //<< Task #7405 - new Desk and extra information for Pax        
        public void updateUserAttributes(DataTable userAttributes, DataTable oldUserAttributes)
        {
            List<String> tablesToBeDeleted = DataManagerInput.createUserAttributesTablesFromUserAttributesColumnNames(userAttributes);
            if (tablesToBeDeleted.Count > 0)
                foreach(String tableName in tablesToBeDeleted)
                    RemoveTable("Input", tableName);            
            dmiInputData.InitializeTables();
            initializeFlightSubcategoriesTables(ListeErreurs);  // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
            initializeReclaimLogTable(ListeErreurs);    // >> Task #8958 Reclaim Synchronisation mode Gantt
            Update_FlightCategorie();
            updateAllocationTablesWithDefaultValues(userAttributes, oldUserAttributes);
        }

        private void updateAllocationTablesWithDefaultValues(DataTable newUserAttributes, DataTable oldUserAttributes)
        {
            DataTable passportAllocationTable = dmiInputData.GetTable(GlobalNames.Alloc_PassportCheckTableName).Table;
            DataTable securityAllocationTable = dmiInputData.GetTable(GlobalNames.Alloc_SecurityCheckTableName).Table;
            DataTable transferAllocationTable = dmiInputData.GetTable(GlobalNames.Alloc_TransferDeskTableName).Table;
            // << Task #7570 new Desk and extra information for Pax -Phase I B
            DataTable userProcessAllocationTable = dmiInputData.GetTable(GlobalNames.Alloc_UserProcessCheckTableName).Table;
            // >> Task #7570 new Desk and extra information for Pax -Phase I B
            //This list contains the new indexes found in the newUserAttributeTable for the value from the oldUserAttributeTable
            // If an old value is not found then the list will get -1;
            //The index in this list reflects the place of the value in the oldUserAttributeTable
            List<int> linkBetweenRows = new List<int>();
            Dictionary<String, int> oldValuesAndIndexInOldTableDictionary = new Dictionary<String, int>();     // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant       

            for (int i = 0; i < oldUserAttributes.Rows.Count; i++)
            {
                // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant                    
                int indexForOldRowValueFromOldTable = -1;
                int nbOfnonUserAttributes = 0;
                String oldValue = oldUserAttributes.Rows[i][GlobalNames.sUserAttributes_ColumnName].ToString();

                foreach (DataRow newDr in newUserAttributes.Rows)
                {
                    String value = newDr[GlobalNames.sUserAttributes_ColumnName].ToString();
                    
                    if (GlobalNames.nonUserAttributesExceptionsList.Contains(value))
                    {
                        nbOfnonUserAttributes++;
                        continue;
                    }                    
                    if (oldValue == value)
                    {
                        indexForOldRowValueFromOldTable = i - nbOfnonUserAttributes;
                        //indexForOldRowValueFromOldTable = newUserAttributes.Rows.IndexOf(newDr);                        
                        break;
                    }
                }                
                if (indexForOldRowValueFromOldTable != -1) {
                    linkBetweenRows.Add(indexForOldRowValueFromOldTable);
                    oldValuesAndIndexInOldTableDictionary.Add(oldValue, indexForOldRowValueFromOldTable);
                }
                // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant                
            }
            updateAllocationTables(passportAllocationTable, linkBetweenRows, oldValuesAndIndexInOldTableDictionary,
                newUserAttributes);
            updateAllocationTables(securityAllocationTable, linkBetweenRows, oldValuesAndIndexInOldTableDictionary,
                newUserAttributes);
            updateAllocationTables(transferAllocationTable, linkBetweenRows, oldValuesAndIndexInOldTableDictionary,
                newUserAttributes);
            // << Task #7570 new Desk and extra information for Pax -Phase I B
            updateAllocationTables(userProcessAllocationTable, linkBetweenRows, oldValuesAndIndexInOldTableDictionary,
                newUserAttributes);
            // >> Task #7570 new Desk and extra information for Pax -Phase I B            
        }

        private void updateAllocationTables(DataTable allocationTable, List<int> linkBetweenRows,
            Dictionary<String, int> oldValuesAndIndexInOldTableDictionary,DataTable newUserAttributesTable)
        {
            foreach (DataColumn col in allocationTable.Columns)
            {
                if (col.ColumnName != "Time")
                {
                    foreach (DataRow dr in allocationTable.Rows)
                    {
                        String currentValue = dr[col].ToString();
                        string[] values = currentValue.Split(';');
                        String newValue = "";
                        int index = 7;
                        // we fill the newValue with all the values except new user attribute values -> the values from the old version
                        for (int i = 0; i < index; i++)
                        {
                            if (i == 0)
                                newValue = newValue + values[i];
                            else
                                newValue = newValue + ";" + values[i];
                        }
                        // if the allocation table is in the old format(without any new user attribute value)
                        // we add "All" value for every user attribute value
                        if (values.Length == 7)
                        {
                            // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                            int nbOfNonUserAttributes = 0;
                            foreach (DataRow row in newUserAttributesTable.Rows)
                            {
                                /*
                                if (row[GlobalNames.sUserAttributes_ColumnName].ToString().Equals(GlobalNames.sUserAttributesBaggLoadingDelayTableName)
                                    || row[GlobalNames.sUserAttributes_ColumnName].ToString().Equals(GlobalNames.sUserAttributesBaggLoadingRateTableName))                                
                                 */ 
                                if (row[GlobalNames.sUserAttributes_ColumnName] != null 
                                    && GlobalNames.nonUserAttributesExceptionsList
                                                    .Contains(row[GlobalNames.sUserAttributes_ColumnName].ToString()))
                                {
                                    nbOfNonUserAttributes++;
                                }
                            }
                            for (int i = 0; i < newUserAttributesTable.Rows.Count - nbOfNonUserAttributes; i++)
                                newValue = newValue + ";All";
                            /*
                            for (int i = 0; i < newUserAttributesTable.Rows.Count; i++)
                                newValue = newValue + ";All";
                             */ 
                            // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant                            
                        }
                        else
                        {
                            for (int i = 0; i < newUserAttributesTable.Rows.Count; i++)
                            {
                             // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                DataRow rw = newUserAttributesTable.Rows[i];
                                if (rw[GlobalNames.sUserAttributes_ColumnName] != null
                                    && GlobalNames.nonUserAttributesExceptionsList
                                                    .Contains(rw[GlobalNames.sUserAttributes_ColumnName].ToString()))                                    
                                {
                                    continue;
                                }                                
                                //if (linkBetweenRows.Contains(i))
                                if (rw[GlobalNames.sUserAttributes_ColumnName] != null) {
                                    String newUserAttributeName = rw[GlobalNames.sUserAttributes_ColumnName].ToString();

                                    if (oldValuesAndIndexInOldTableDictionary.ContainsKey(newUserAttributeName))
                                    {
                                        int indexInOldTable = -1;
                                        if (oldValuesAndIndexInOldTableDictionary.TryGetValue(newUserAttributeName, out indexInOldTable))
                                        {
                                            if (values.Length > index + indexInOldTable)
                                                newValue = newValue + ";" + values[index + indexInOldTable];
                                            else
                                                newValue = newValue + ";All";
                                        }
                                    }
                                    else
                                        newValue = newValue + ";All";
                                }
                            }
                            // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                        }
                        dr[col] = newValue;
                    }
                }
            }
        }
        //>> Task #7405 - new Desk and extra information for Pax
        private void RemoveTerminal(int iIndexTerminal)
        {
            List<String> lsTables = DataManagerInput.RemoveTerminalInputTable(iIndexTerminal);
            foreach (String sNomTable in lsTables)
            {
                RemoveTable("Input", sNomTable);
            }
            if (liTerminalBHS != null)
                liTerminalBHS.Remove(iIndexTerminal);
        }
        public List<Int32> getTerminalBHS()
        {
            return liTerminalBHS;
        }
        #endregion

        #region Fonction pour les spécificités Delhi
        public static void setDelhiMode()
        {
            ListeLignesFlowSplit_BHS = new String[]{ "% HBS1 to HBS2", 
                                                           "% HBS2 to HBS3 auto.", 
                                                           "% HBS3 auto. to HBS3 manu.", 
                                                           "% HBS3 manu. to HBS4", 
                                                           "% MES (Originating Bags)",
                                                           "% MES (Transfer Bags)",
                                                           "% MES (DMRC Bags)",
                                                           "% Interlink (Transfer Bags)-optional",
                                                           "% Interlink (Originating Bags)-optional"};

            ListeLignesProcess_BHS = new String[]{"Check-In Bag process time (mean flows mode) (sec)",
                                    "HBS Lev.2 tracking loss rate (%)",
                                    "MES Short Process rate (%)",
                                    "MES Short process time (sec)",
                                    "MES Long process time (sec)",
                                    "HBS Lev.2 process time Min (sec)",
                                    "HBS Lev.2 process time Mode (sec)",
                                    "HBS Lev.2 process time Max (sec)",
                                    "HBS Lev.2 Operators",
                                    "HBS Lev.3 Automatic process time Min (sec)",
                                    "HBS Lev.3 Automatic process time Mode (sec)",
                                    "HBS Lev.3 Automatic process time Max (sec)",
                                    "HBS Lev.3 spacing (m)",
                                    "HBS Lev.3 Velocity (m/s)",
                                    "HBS Lev.3 Manual process time Min (sec)",
                                    "HBS Lev.3 Manual process time Mode (sec)",
                                    "HBS Lev.3 Manual process time Max (sec)",
                                    "HBS Lev.3 Operators",
                                    "HBS Lev.4 process time Min (sec)",
                                    "HBS Lev.4 process time Mode (sec)",
                                    "HBS Lev.4 process time Max (sec)",
                                    "Transfer Infeed 1 operator throughput (bag/h)",
                                    "Transfer Infeed 2 operator throughput (bag/h)",
                                    "DMRC Infeed operator throughput (bag/h)",
                                    "Arrival Infeed operator throughput (bag/h)",
                                    "Number of Tray Sorters",
                                    "Sorter velocity (m/s)",
                                    "Sorter tray length (m)",
                                    "Sorter filling limit (nb bags)",
                                    "Sorter recirculation limit (nb laps)",
                                    "Sorter Induction interval (trays)",
                                    "Sorter Tilt interval (trays)"};

            ListeLignesFixes_BHS = new String[][] { ListeLignesGeneral_BHS, /*ListeLignesOCT_MakeUp,*/ ListeLignesFlowSplit_BHS, ListeLignesProcess_BHS, ListeLignesArrival_Containers };

            Default_Flow_Split = new double[] { 40, 12.5, 40, 0, 5, 5, 50, 10 };
            ListeTableDefaultValues_BHS = new double[][] { /*Default_OCT_MakeUp,*/ Default_Flow_Split, Default_Arrival_Containers };

            if (HiddenTables == null)
                HiddenTables = new ArrayList();

            HiddenTables.AddRange(new String[]{"Mean_Flows_Arrival_Infeed",
                                   "Mean_Flows_Check_In",
                                   "Mean_Flows_Transfer_Infeed"});
        }
        #endregion

        #region Fonction pour les spécificités de la version Trial

        internal bool TrialCanAddRow(String sDataSet, String sTableName)
        {
            if (!PAX2SIM.bTrialVersion)
                return true;
            if (!htSizeTable.ContainsKey(sTableName))
                return true;

            DataManager gd = GetDataManager(sTableName);

            if (gd == null)
                return false;

            DataTable dtTable = gd.GetTable(sTableName).Table;

            if (dtTable == null)
                return false;
            if (dtTable.Rows.Count >= ((int)htSizeTable[sTableName]))
                return false;
            return true;
        }
        internal bool TrialCanAddRow(SIMCORE_TOOL.Classes.TreeViewTag tvtTmp)
        {
            if (!PAX2SIM.bTrialVersion)
                return true;
            if (tvtTmp == null)
                return false;
            if (!htSizeTable.ContainsKey(tvtTmp.Name))
                return true;

            DataManager gd = GetDataManager(tvtTmp.ScenarioName);

            if (gd == null)
                return false;

            DataTable dtTable = gd.GetTable(tvtTmp.Name).Table;

            if (dtTable == null)
                return false;
            if (dtTable.Rows.Count >= ((int)htSizeTable[dtTable.TableName]))
                return false;
            return true;
        }
        internal bool TrialEraseLines(SIMCORE_TOOL.Classes.TreeViewTag tvtTmp)
        {
            if (!PAX2SIM.bTrialVersion)
                return false;
            if (tvtTmp == null)
                return false;
            if (!htSizeTable.ContainsKey(tvtTmp.Name))
                return false;
            

            DataManager gd = GetDataManager(tvtTmp.ScenarioName);

            if (gd == null)
                return false;

            DataTable dtTable = gd.GetTable(tvtTmp.Name).Table;

            if (dtTable == null)
                return false;
            int i = (int)htSizeTable[dtTable.TableName];
            if (i >= dtTable.Rows.Count)
                return false;
            while (i < dtTable.Rows.Count)
            {
                dtTable.Rows.RemoveAt(i);
            }
            return true;
        }
        internal static bool IsValidShowUp(DataTable dtTable)
        {
            if (!PAX2SIM.bTrialVersion)
                return true;
            if (dtTable == null)
                return true;
            if (dtTable.Columns.Count < 2)
                return true;
            double dMax1 = OverallTools.DataFunctions.getMaxValue(dtTable, 0);
            double dMax2 = OverallTools.DataFunctions.getMaxValue(dtTable, 1);
            if ((dMax1 > CI_ShowUpMax) || (dMax2 > CI_ShowUpMax))
                return false;
            return true;
        }
        public bool CanAddScenario()
        {
            if (!PAX2SIM.bTrialVersion)
                return true;

            if (htScenarios.Count >= NBScenarios)

            
                return false;
            return true;
        }
        internal bool IsValidFilter(Filter filtre)
        {
            if (!PAX2SIM.bTrialVersion)
                return true;
            if (filtre.copyTable)
                return false;
            return true;
        }
        internal static void setTrialMode()
        {
            sHub2simModel += "_eval";
            NbTerminaux = 1;
            NbLevels = 5;
            NbTypes = LastGroupIndex;
            NbGroupes = 2;
            NbDesks = 10;
            NbCheckInDesks = 10;

            htSizeAutomodModel[PAX2SIM.sTerminalName] = NbTerminaux;
            htSizeAutomodModel[PAX2SIM.sLevelName] = NbLevels;
            htSizeAutomodModel[PAX2SIM.sBHSName] = 0;

            htSizeAutomodModel["Check In"] = NbCheckInDesks;
            htSizeAutomodModel[PAX2SIM.sCheckInGroup] = NbGroupes;
            htSizeAutomodModel["Passport Check"] = NbDesks;
            htSizeAutomodModel["Passport Check Group"] = NbGroupes;
            htSizeAutomodModel["Security Check"] = NbDesks;
            htSizeAutomodModel["Security Check Group"] = NbGroupes;
            htSizeAutomodModel["Arrival Gate"] = NbDesks;
            htSizeAutomodModel["Arrival Gate Group"] = NbGroupes;
            htSizeAutomodModel["Baggage Claim"] = NbDesks;
            htSizeAutomodModel["Baggage Claim Group"] = NbGroupes;
            htSizeAutomodModel["Transfer"] = NbDesks;
            htSizeAutomodModel["Transfer Group"] = NbGroupes;
            // << Task #7570 new Desk and extra information for Pax -Phase I B
            //htSizeAutomodModel["ShuttleS"] = NbDesks;
            //htSizeAutomodModel["ShuttleS Group"] = NbGroupes;
            htSizeAutomodModel[PAX2SIM.sUserProcessObject] = NbDesks;
            htSizeAutomodModel[PAX2SIM.sUserProcessGroup] = NbGroupes;
            // >> Task #7570 new Desk and extra information for Pax -Phase I B            
            htSizeAutomodModel["Boarding Gate"] = NbDesks;
            htSizeAutomodModel["Boarding Gate Group"] = NbGroupes;

            htSizeAutomodModel.Add("Runways", 0);
            htSizeAutomodModel.Add("Runway", 0);
            htSizeAutomodModel.Add("Aircraft Parking Stands", 0);
            htSizeAutomodModel.Add("Aircraft Parking Stand", 0);

            htSizeTable[GlobalNames.FPDTableName] = 10;
            htSizeTable[GlobalNames.FPATableName] = 10;
            htSizeTable[GlobalNames.FP_FlightCategoriesTableName] = 3;
            //InitialiazePaxCheck();
            DataManagerInput.SetTrialModeVersion();
            /*#region Gestion des tables qui ne doivent pas apparaitre dans le projet.
            ArrayList alRemovedTable = new ArrayList();
            alRemovedTable.Add(GlobalNames.Transfer_TerminalDitributionTableName);
            alRemovedTable.Add(GlobalNames.Transfer_FlightCategoryDitributionTableName);
            alRemovedTable.Add("OCT_ParkingTable");
            alRemovedTable.Add("Alloc_ParkingTable");

            alRemovedTable.Add("OCT_MakeUp");
            alRemovedTable.Add("Segregation");
            alRemovedTable.Add("TransferInfeedAllocationRulesTable");
            alRemovedTable.Add("Baggage_Claim_Constraint");
            alRemovedTable.Add("Animated_Queues");
            alRemovedTable.Add(GlobalNames.ProcessScheduleName);

            foreach (String sName in alRemovedTable)
            {
                int iIndex = OverallTools.FonctionUtiles.indexDansListe(sName, ListeNomTablePAX);
                if (iIndex == -1)
                    continue;
                ListeTablePAXSauvegardee[iIndex] = false;
                ListeTablePAXVisible[iIndex] = false;
            }
            #endregion*/
        }
        #endregion

        public static void setSpecificMode()
        {
            if (HiddenTables == null)
                HiddenTables = new ArrayList();

            if (PAX2SIM.bRuntime)
            {
                HiddenTables.AddRange(new String[]{GlobalNames.sBHS_General,
                                                    GlobalNames.sBHS_ArrivalInfeed_Groups,
                                                    GlobalNames.sBHS_CI_Groups,
                                                    GlobalNames.sBHS_TransferInfeed_Groups,
                                                    GlobalNames.sBHS_CI_Collectors,
                                                    GlobalNames.sBHS_CI_Routing,
                                                    GlobalNames.sBHS_HBS3_Routing,
                                                    GlobalNames.sBHS_Transfer_Routing});
            }
            if (PAX2SIM.bBHS_MeanFlows)
            {
                HiddenTables.AddRange(new String[]{"OCT_MakeUp",
                                                   GlobalNames.sBHS_Alloc_MakeUp,
                                                   GlobalNames.sBHS_Arrival_Containers});
            }
            if (PAX2SIM.bBHS_PaxPlan)
            {
                HiddenTables.AddRange(new String[]{GlobalNames.sBHS_Mean_Flows_Arrival_Infeed,
                                   GlobalNames.sBHS_Mean_Flows_Check_In,
                                   GlobalNames.sBHS_Mean_Flows_Transfer_Infeed});
            }
        }
        
        //public Dictionary<string, double[]> scenariosDistributionLevelsDictionary = new Dictionary<string, double[]>(); // << Task #8302 Pax2Sim - Scenario Parameters - Intermediate distribution levels
        
        internal delegate void AnalyseTracesDelegate(Classes.ParamScenario psParam,GestionDonneesHUB2SIM ghdData, String sBagTraceLocation, String sPaxTraceLocation);

        AnalyseTracesDelegate AnalyseTracesFunction;

        internal void AnalyseTraces(String sScenarioName, String sPaxTraceLocation, String sBagTraceLocation)
        {
            if ((!ScenarioExist(sScenarioName)))
            {
                return;
            }
            Classes.ParamScenario psTmp = ((DataManagerPaxBHS)GetDataManager(sScenarioName)).Scenario;

            if (psTmp == null)
                return;
            // << Task #8302 Pax2Sim - Scenario Parameters - Intermediate distribution levels
            //Search in the txt file for the distribution levels related to this scenario. If found set the DonneesEnCours.Levels.
            String scenarioName = psTmp.Name;
            String distributionLevelsFilePath = this.getDossierEnregistrement() + "Output\\" + scenarioName + "\\"
                                        + Model.distributionLevelsTextFilePrefix + scenarioName + Model.distributionLevelsTextFileExtention;
            double[] distributionLevels = new double[3] { 0, 0, 0 };

            bool percentilesRetrievedFromFile = false;
            if (File.Exists(distributionLevelsFilePath))
            {
                try
                {
                    FileInfo distributionLevelsFileInfo = new FileInfo(distributionLevelsFilePath);
                    if (distributionLevelsFileInfo != null && distributionLevelsFileInfo.Exists)
                    {
                        System.IO.StreamReader reader = new StreamReader(distributionLevelsFileInfo.OpenRead());
                        String distributionLevelsInfoLine = "";
                        while ((distributionLevelsInfoLine = reader.ReadLine()) != null)
                        {
                            string[] distributionLevelList = distributionLevelsInfoLine.Split(';');
                            if (distributionLevelList.Length == 4)
                            {
                                double value = 0;
                                double.TryParse(distributionLevelList[1], out  value);
                                distributionLevels[0] = value;
                                double.TryParse(distributionLevelList[2], out  value);
                                distributionLevels[1] = value;
                                double.TryParse(distributionLevelList[3], out  value);
                                distributionLevels[2] = value;

                                percentilesRetrievedFromFile = true;
                            }
                        }
                        reader.Close();
                        reader.Dispose();
                    }
                }
                catch (Exception ex)
                {
                    OverallTools.ExternFunctions.PrintLogFile("Error while trying to access the distribution parameters file.(GestionDoneesHUB2SIM.AnalyseTraces()) " 
                        + ex.Message);
                }
            }
            if (psTmp.percentilesLevels.Count == 0)
            {
                if (percentilesRetrievedFromFile)
                {
                    this.Levels[0] = distributionLevels[0];
                    this.Levels[1] = distributionLevels[1];
                    this.Levels[2] = distributionLevels[2];

                    psTmp.percentilesLevels.Add(distributionLevels[0]);
                    psTmp.percentilesLevels.Add(distributionLevels[1]);
                    psTmp.percentilesLevels.Add(distributionLevels[2]);
                }
                else
                {
                    psTmp.percentilesLevels.Add(this.Levels[0]);
                    psTmp.percentilesLevels.Add(this.Levels[1]);
                    psTmp.percentilesLevels.Add(this.Levels[2]);
                }
            }
            else if (psTmp.percentilesLevels.Count == 3)
            {
                this.Levels[0] = psTmp.percentilesLevels[0];
                this.Levels[1] = psTmp.percentilesLevels[1];
                this.Levels[2] = psTmp.percentilesLevels[2];
            }

            //save the Levels of distribution into dictionary
            //if (!scenariosDistributionLevelsDictionary.ContainsKey(psTmp.Name))
            //    scenariosDistributionLevelsDictionary.Add(psTmp.Name, this.Levels);
            //else
            //{
            //    scenariosDistributionLevelsDictionary.Remove(psTmp.Name);
            //    scenariosDistributionLevelsDictionary.Add(psTmp.Name, this.Levels);
            //}
            // >> Task #8302 Pax2Sim - Scenario Parameters - Intermediate distribution levels

            AnalyseTracesFunction(psTmp, this,sPaxTraceLocation, sBagTraceLocation);
        }

        #region Fonction pour la génération du rapport

        /// <summary>
        /// Generate the HTML report.
        /// </summary>
        /// <param name="Collection">Nodes</param>
        /// <param name="Path">Report path</param>
        /// <param name="AirportRoot">Airport nodes</param>
        /// <param name="cht"></param>
        /// <param name="parameters">Parameters of the report.</param>
        /// <returns>Boolean that mean all finished all right</returns>
        public bool generateReport(TreeNodeCollection Collection,
                                   String Path,
                                   TreeNode AirportRoot,
                                   SIMCORE_TOOL.Prompt.SIM_LoadingForm cht,
                                   ReportParameters parameters)
        {
            if (cht != null)
            {
                int nbNode = OverallTools.TreeViewFunctions.CountNodes(Collection);
                if (AirportRoot != null)
                    nbNode++;
                cht.setFileNumber(nbNode);
            }


            if (!OverallTools.ExternFunctions.CheckCreateDirectory(Path))
                return false;
            if (!OverallTools.ExternFunctions.CheckCreateDirectory(Path + "\\Images"))
                return false;
            System.Drawing.Image Img = OverallTools.FonctionUtiles.dessinerFondEcran(2, 600, PAX2SIM.Couleur1, PAX2SIM.Couleur2, PAX2SIM.Angle);
            Img.Save(Path + "\\Images\\Fond.png", System.Drawing.Imaging.ImageFormat.Png);

            //Exportation des fichiers images et css et js nécessaires pour l'arbre dynamique.
            String[] fichiers = new String[] { "arbo_join.gif", "arbo_joinbottom.gif", "arbo_line.gif", "arbo_minus.gif", "arbo_plus.gif" };
            for (int i = 0; i < fichiers.Length; i++)
                OverallTools.ExternFunctions.copyResourceFile(fichiers[i], Path + "\\Images\\" + fichiers[i]);
            OverallTools.ExternFunctions.copyResourceFile("arbo.js", Path + "\\arbo.js");
            OverallTools.ExternFunctions.copyResourceFile("report.css", Path + "\\report.css");

            System.IO.StreamWriter monLecteur;
            if (AirportRoot != null)
            {
                if (cht != null)
                    cht.ChargementFichier("Build Airport Structure...");
                monLecteur = new System.IO.StreamWriter(Path + "\\AirportStructure.html");
                monLecteur.WriteLine(OverallTools.FonctionUtiles.CreateTreePageHTML(
                    printHTMLAirport(AirportRoot)));
                monLecteur.Close();
            }
            monLecteur = new System.IO.StreamWriter(Path + "\\" + parameters.Name + ".html");
            monLecteur.WriteLine(OverallTools.FonctionUtiles.CreateTreePageHTML(
                printHTMLTables(Collection, Path, cht, parameters)));
            monLecteur.Close();

            return true;
        }
        #region Fonction pour la génération du rapport en HTML
        

        public String printHTMLTables(TreeNodeCollection Structure,
                                     String Path,
                                     SIMCORE_TOOL.Prompt.SIM_LoadingForm cht,
                                     ReportParameters parameters)
        {
            // create the root              
            String Result = "<table border=\"0\" style=\"width: 100%;\"><tr><td>";
            Result += "<div id=\"arborescence\" class=\"code\"><font face=\"arial\">\n<ul id=\"racine\">\n";
            Result += "<li><b>" + (parameters.Titre == null || parameters.Titre == "" ? parameters.Name : parameters.Titre) + "</b>\n";
            Result += "<font size=\"-1\">&nbsp;&nbsp;&nbsp;<A onClick=\"collapseAll();\">[ Collapse tree</a> | ";
            Result += "<A onClick=\"expandAll();\">Expand tree ]</a></b><br/><br/></font>";
            Result += "<ul id=\"niv1\" class=\"niv1\">";
            StringBuilder content = new StringBuilder("\n\n");

            foreach (TreeNode node in Structure)
            {
                if(cht != null)
                    cht.ChargementFichier("Build Section (" + node.Name + ")");
                Result += printHTMLTable(node, ref content, node.Name + "\\", Path, cht, parameters);
            }

            Result += "</ul></li></ul></font></div></td></tr><tr><td>";
            Result += content + "</td></tr><table>";
            return Result;
        }

        private String printHTMLTable(TreeNode NodeMere, ref StringBuilder content, String path, String SavePath, SIMCORE_TOOL.Prompt.SIM_LoadingForm cht, ReportParameters parameters)
        {
            if ((NodeMere.Tag == null) || (NodeMere.Tag.GetType() != typeof(TreeViewTag)))
                return null;
            TreeViewTag Tag = (TreeViewTag)NodeMere.Tag;
            StringBuilder Result = new StringBuilder();
            bool isLastNode;
            if (NodeMere.Parent != null)
                isLastNode = NodeMere.Parent.LastNode == NodeMere; // is it the last node of its parent children
            else
                isLastNode = NodeMere.TreeView.Nodes.IndexOf(NodeMere) == NodeMere.TreeView.Nodes.Count - 1;


            // Affichage de l'image pour l'arbre dépliable HTML
            if (NodeMere.Nodes.Count > 0) // est-ce qu'il y aura des sous node à afficher ?
                Result.Append("<li>" + imgMinus);
            else if (isLastNode) // est-ce la derniere node à afficher ?
                Result.Append("<li>" + imgJoinBottom);
            else
                Result.Append("<li>" + imgJoin);

            // content table linked element
            String link_ref = NodeMere.Name + NodeMere.GetHashCode();
            Result.Append("<a href=\"#" + link_ref + "\" >" + NodeMere.Text + "</a>");
            
            // Y a un truc qui va pas, on arrête !
            if ((NodeMere.Tag == null) || (NodeMere.Tag.GetType() != typeof(TreeViewTag)))
                return null;

            // The node is a directory
            if (Tag.isDirectoryNode)
            {
                // Add Title to content
                content.Append("<br/><font id=\"" + link_ref + "\" size=\"+1\" >" + NodeMere.Text + "</font>"); // title with id for Anchor
                content.Append("&nbsp;&nbsp;&nbsp;\n<a href=\"#arborescence\"><font color=\"black\" >top</font></a><br/>");
            }

            // The node is a Chart
            else if (Tag.isChartNode)
            {
                content.Append("<a id=\"" + link_ref + "\"/>"); // Anchor for table of content
                String SaveChartPath = SavePath + "\\";
                String imgPath;
                if ((Tag.ScenarioName == null || Tag.ScenarioName == "") && (GetGeneralGraphicFilter(NodeMere.Name) != null))
                {
                    SaveChartPath += "Charts\\";
                    imgPath = SaveChartPath + NodeMere.Name + "_Chart.png";
                    imgPath = imgPath.Replace(@"\\", @"\");
                    if (OverallTools.ExternFunctions.CheckCreateDirectory(SaveChartPath))
                    {
                        if (OverallTools.ExternFunctions.IsOlderThan(imgPath, 60)) // si le fichier a était créé il y a moins d'une minute on peut considérer que c'est la derniere version
                            SaveGraphique(NodeMere.Name, imgPath);
                        // >> Report generate/preview error - Illegal char in path
                        foreach (string illegalChar in GlobalNames.ILLEGAL_CHARACTERS_IN_FILE_PATH)
                        {
                            if (imgPath.Contains(illegalChar))
                                imgPath = imgPath.Replace(illegalChar, GlobalNames.SPECIAL_CHAR_UNDERSCORE);
                        }                        
                        // Report generate/preview error - Illegal char in path
                        content.Append(
                            "<a target=\"" + NodeMere.Text + "\" href = \"" + imgPath + "\">" +
                            "<img src=\"" + imgPath + "\" alt=\"" + NodeMere.Text + "\" style=\"width: 60%;\" style=\"border:0px;\" /></a><br/><br/>");
                    }
                }
                else
                {
                    GraphicFilter gf = getGraphicFilter(Tag.ScenarioName, NodeMere.Name);
                    SaveChartPath += Tag.ScenarioName + "\\";
                    if (Tag.IsExceptionNode){
                        imgPath = SaveChartPath + Tag.Name + Tag.ExceptionName + "_Chart.png";
                        gf = getExceptionTableGraphicFilter(Tag.ScenarioName, Tag.Name,Tag.ExceptionName);
                    }
                    else
                        imgPath = SaveChartPath + NodeMere.Name + "_Chart.png";
                    imgPath = imgPath.Replace(@"\\", @"\");
                    if (gf != null)
                    {
                        if (OverallTools.ExternFunctions.CheckCreateDirectory(SaveChartPath))
                        {
                            // >> Report generate/preview error - Illegal char in path
                            foreach (string illegalChar in GlobalNames.ILLEGAL_CHARACTERS_IN_FILE_PATH)
                            {
                                if (imgPath.Contains(illegalChar))
                                    imgPath = imgPath.Replace(illegalChar, GlobalNames.SPECIAL_CHAR_UNDERSCORE);
                            }
                            // Report generate/preview error - Illegal char in path
                            if (OverallTools.ExternFunctions.IsOlderThan(imgPath, 60)) // si le fichier a était créé il y a moins de 2 minutes on peut considérer que c'est la derniere version
                                if (Tag.IsExceptionNode)
                                    SaveGraphique(Tag.ScenarioName, Tag.Name, Tag.ExceptionName, imgPath);
                                else
                                    SaveGraphique(Tag.ScenarioName, NodeMere.Name, imgPath);
                            content.Append(
                                "<a target=\"" + NodeMere.Text + "\" href = \"" + imgPath + "\">" +
                                "<img src=\"" + imgPath + "\" alt=\"" + NodeMere.Text + "\" style=\"width: 60%;\" style=\"border:0px;\" /></a><br/><br/>");
                        }
                    }
                }
            }

            // The node is a paragraph
            else if (Tag.isParagraphNode)
            {
                Paragraph p = null;
                String note = null;
                content.Append("<a id=\"" + link_ref + "\"/>"); // Anchor for table of content
                if ((p = getParagraph(NodeMere.Name)) != null)
                {
                    content.Append(
                        OverallTools.FonctionUtiles.GetHtmlContent(p.Content) +
                        "<br/><br/>");
                }
                else if (Tag.IsExceptionNode && (note = getExNote(Tag.ScenarioName, Tag.Name, Tag.ExceptionName)) != null)
                {
                    content.Append(
                        OverallTools.FonctionUtiles.GetHtmlContent(note) +
                        "<br/><br/>");
                }
                else if (((note = getNote(Tag.ScenarioName, NodeMere.Name)) != null || (note = getGeneralNote(NodeMere.Name)) != null)
                        && (Tag.ImageIndex != Model.GANTT_NOTE_IMAGE_INDEX && Tag.ImageIndex != GlobalNames.DASHBOARD_NOTE_IMAGE_INDEX))   //>>GanttNote for Report // >> Task #10645 Pax2Sim - Pax analysis - Summary: dashboard image for Reports
                {
                    content.Append(
                        OverallTools.FonctionUtiles.GetHtmlContent(note) +
                        "<br/><br/>");
                }
                else if ((note = getGanttNote(Tag.ScenarioName, NodeMere.Name)) != null && Tag.ImageIndex == Model.GANTT_NOTE_IMAGE_INDEX)
                {  // use the Gantt Note if the Node holds the Gantt image //>>GanttNote for Report
                    content.Append(
                            OverallTools.FonctionUtiles.GetHtmlContent(note) +
                            "<br/><br/>");
                }
                else if ((note = getDashboardNote(Tag.ScenarioName, NodeMere.Name)) != null && Tag.ImageIndex == GlobalNames.DASHBOARD_NOTE_IMAGE_INDEX)
                {   // >> Task #10645 Pax2Sim - Pax analysis - Summary: dashboard image for Reports
                    content.Append(
                            OverallTools.FonctionUtiles.GetHtmlContent(note) +
                            "<br/><br/>");
                }
            }

            // The node is a table
            else if ((Tag.isTableNode) || (Tag.isResultNode) || (Tag.isFilterNode) || (Tag.IsExceptionNode && !Tag.isParagraphNode)) // c'est une table
            {
                content.Append("<a id=\"" + link_ref + "\"/>"); // Anchor for table of content
                String SaveTablePath = SavePath + "\\" + Tag.ScenarioName + "\\";
                SaveTablePath = SaveTablePath.Replace(@"\\", @"\");
                DataTable table = null;
                if (Tag.IsExceptionNode)
                {
                    NormalTable nt = GetExceptionTable(Tag.ScenarioName, Tag.Name, Tag.ExceptionName);
                    if (nt != null) table = nt.Table;
                }
                else
                    table = getTable(Tag.ScenarioName, NodeMere.Name);
                if (table != null)
                {
                    if (cht != null)
                        cht.ChargementFichier("Export : " + NodeMere.Text);
                    VisualisationMode mode = null;
                    if (Tag.IsExceptionNode)
                        mode = getModeVisualisation(Tag.ScenarioName, NodeMere.Name, Tag.ExceptionName);
                    else
                        mode = getModeVisualisation(Tag.ScenarioName, NodeMere.Name);
                    if (OverallTools.ExternFunctions.CheckCreateDirectory(SaveTablePath))
                    {
                        String htmlTable = OverallTools.FonctionUtiles.GetHtmlTable(table, mode);
                        content.Append(htmlTable + "<br />");
                        
                    }
                }
            }

            // Affichage des autres fils 
            if ((NodeMere.Nodes.Count > 0)) // si il a des node fille
            {
                if (Tag.isDirectoryNode)
                    content.Append("<table border=\"0\" class=\"chap\"><tr><td>");
                    //content.Append("\n<div class=\"chap\">");

                if (isLastNode)
                    Result.Append("<ul class=\"niv2 last\">");
                else
                    Result.Append("<ul class=\"niv2\">");
                for (int i = 0; i < NodeMere.Nodes.Count; i++)
                {
                    Result.Append(
                        printHTMLTable(NodeMere.Nodes[i], ref content, path, SavePath, cht, parameters));
                }
                Result.Append("</ul>");

                if (Tag.isDirectoryNode)
                    content.Append("</td></tr></table>");
                    //content.Append("\n</div>");
            }
            Result.Append("</li>");
            return Result.ToString();
        }

        #region Fonctions pour la génération de l'aéroport
        /// <summary>
        /// Generate airport structure list.
        /// </summary>
        /// <param name="AirportStructure"></param>
        /// <returns>genarated list</returns>
        public String printHTMLAirport(TreeNode AirportStructure)
        {

            String Result = "<font face=\"arial\">\n";
            Result += "<b><A onClick=\"collapseAll();\">[ Collapse tree</a> | ";
            Result += "<A onClick=\"expandAll();\">Expand tree ]</a></b><br/><br/></font>\n";
            Result += "<div id=\"arborescence\" class=\"code\"><ul id=\"racine\">";
            Result += "<li>Airport";
            Result += "<ul id=\"niv1\" class=\"niv1\">";
            foreach (TreeNode node in AirportStructure.Nodes)
            {
                Result += printHTMLAirportNode(node);
            }
            Result += "</ul></li></ul></div>";

            return Result;
        }
        /// <summary>
        /// Simply add the node name as an element of a list. also add its chirldren.
        /// </summary>
        /// <param name="NodeMere"></param>
        /// <returns></returns>
        private String printHTMLAirportNode(TreeNode NodeMere)
        {
            String Result;
            if (NodeMere.Nodes.Count != 0)
            {
                Result = "<li>" + imgMinus + NodeMere.Text;
                if (NodeMere.Parent.LastNode == NodeMere) // est-ce la derniere node de sa mere ?
                    Result += "<ul class=\"niv2 last\">";
                else
                    Result += "<ul class=\"niv2\">";
                foreach (TreeNode node in NodeMere.Nodes)
                {
                    Result += printHTMLAirportNode(node);
                }
                Result += "</ul></li>";
            }
            else
                if (NodeMere.Parent.LastNode == NodeMere) // est-ce la derniere node de sa mere ?
                    Result = "<li>" + imgJoinBottom + NodeMere.Text + "</li>";
                else
                    Result = "<li>" + imgJoin + NodeMere.Text + "</li>";
            return Result;
        }
        #endregion
        #endregion

        #region Exportation des graphiques
        private static NChartControl Graphique = null;
        private static NLabel m_Header;
        private static NLegend m_legend;

        private static void initializeGraphique()
        {
            if (Graphique != null)
                return;
            Graphique = new NChartControl();
            Graphique.AutoRefresh = false;
            m_Header = new NLabel("");
            m_Header.Dock = DockStyle.Top;
            m_Header.ContentAlignment = ContentAlignment.MiddleCenter;
            m_Header.TextStyle.FontStyle.Name = "Arial Black";
            m_Header.TextStyle.FontStyle.EmSize = new NLength(16, NGraphicsUnit.Point);
            m_Header.TextStyle.FillStyle = new NGradientFillStyle(Color.LightBlue, Color.DarkBlue);
            m_Header.TextStyle.ShadowStyle.Type = ShadowType.LinearBlur;
            m_Header.TextStyle.BackplaneStyle.Visible = true;
            m_Header.TextStyle.BackplaneStyle.FillStyle.SetTransparencyPercent(50);
            m_Header.TextStyle.BorderStyle.Width = new NLength(1);
            m_Header.TextStyle.BorderStyle.Color = Color.Black;
            Graphique.Panels.Add(m_Header);

            m_legend = (NLegend)Graphique.Legends[0];
        }
        /// <summary>
        /// Generate a graphic and save it on disk as image.
        /// </summary>
        /// <param name="nom">Table name</param>
        /// <param name="saveFile">File name</param>
        public void SaveGraphique(String nom, String saveFile)
        {
            initializeGraphique();
            GraphicFilter gf = GetGeneralGraphicFilter(nom);
            if (gf == null)
                return;
            Graphique.Charts.Clear();
            GraphicFilter.EraseLegend(m_legend);
            m_Header.Text = gf.Title;
            m_legend = Graphique.Legends[0];
            m_legend.Mode = LegendMode.Manual;
            DataTable dtGraphic;
            gf.CreateGraphicZone(Graphique, this, m_legend, out dtGraphic);
            if (Graphique.Charts.Count != 0)
            {
                gf.CreateLegend(m_legend);
                //gf.CreateSetPoint(Graphique, Graphique.Charts[0]);    // >> Bug #15147 Charts Setpoints only work for first series chart location (frame)
                gf.DisplayAnnotation(Graphique);
                m_Header.BringToFront();
                m_legend.BringToFront();
                // >> Report generate/preview error - Illegal char in path
                foreach (string illegalChar in GlobalNames.ILLEGAL_CHARACTERS_IN_FILE_PATH)
                {
                    if (saveFile.Contains(illegalChar))
                        saveFile = saveFile.Replace(illegalChar, GlobalNames.SPECIAL_CHAR_UNDERSCORE);
                }
                //OverallTools.ExternFunctions.PrintLogFile(saveFile);
                // Report generate/preview error - Illegal char in path
                Graphique.ImageExporter.SaveToFile(saveFile, new NSize(1024, 768), new NResolution(100, 100), NImageFormat.CreateImageFormat("Raster Image"));

            }
        }
        /// <summary>
        /// Generate a graphic and save it on disk as image.
        /// </summary>
        /// <param name="dataset">Scenario name</param>
        /// <param name="nomTable">Table name</param>
        /// <param name="saveFile">File name</param>
        public void SaveGraphique(String dataset, String nomTable, String saveFile)
        {
            initializeGraphique();

            #region Vérification préalable avant l'affichage de n'importe quelle courbe.
            if ((nomTable == null) ||
                (!tableEstPresente(dataset, nomTable)))
            {
                return;
            }
            #endregion
            GraphicFilter gf = getGraphicFilter(dataset, nomTable);
            if (gf == null)
                return;
            Graphique.Charts.Clear();
            GraphicFilter.EraseLegend(m_legend);
            m_Header.Text = gf.Title;
            m_legend = Graphique.Legends[0];
            m_legend.Mode = LegendMode.Manual;

            DataTable dtTable = getTable(dataset, nomTable);
            gf.CreateGraphicZone(Graphique, dtTable, m_legend);
            
            m_Header.BringToFront();
             if (Graphique.Charts.Count != 0)
            {
                gf.CreateLegend(m_legend);
                //gf.CreateSetPoint(Graphique, Graphique.Charts[0]);    // >> Bug #15147 Charts Setpoints only work for first series chart location (frame)
                gf.DisplayAnnotation(Graphique);
                m_Header.BringToFront();
                m_legend.BringToFront();
                // >> Report generate/preview error - Illegal char in path
                foreach (string illegalChar in GlobalNames.ILLEGAL_CHARACTERS_IN_FILE_PATH)
                {
                    if (saveFile.Contains(illegalChar))
                        saveFile = saveFile.Replace(illegalChar, GlobalNames.SPECIAL_CHAR_UNDERSCORE);
                }                
                // Report generate/preview error - Illegal char in path
                Graphique.ImageExporter.SaveToFile(saveFile, new NSize(1024, 768), new NResolution(100, 100), NImageFormat.CreateImageFormat("image/png"));
            }
            return;
        }

        /// <summary>
        /// Generate a graphic and save it on disk as image.
        /// </summary>
        /// <param name="dataset">Scenario name</param>
        /// <param name="nomTable">Table name</param>
        /// <param name="saveFile">File name</param>
        public void SaveGraphique(String dataset, String nomTable,String sException, String saveFile)
        {
            initializeGraphique();

            #region Vérification préalable avant l'affichage de n'importe quelle courbe.
            if ((nomTable == null) ||
                (!tableEstPresente(dataset, nomTable)))
            {
                return;
            }
            #endregion
            GraphicFilter gf = getExceptionTableGraphicFilter(dataset, nomTable,sException);
            if (gf == null)
                return;
            Graphique.Charts.Clear();
            GraphicFilter.EraseLegend(m_legend);
            m_Header.Text = gf.Title;
            m_legend = Graphique.Legends[0];
            m_legend.Mode = LegendMode.Manual;

            DataTable dtTable = getExceptionTable(dataset, nomTable,sException);
            gf.CreateGraphicZone(Graphique, dtTable, m_legend);

            m_Header.BringToFront();
            if (Graphique.Charts.Count != 0)
            {
                gf.CreateLegend(m_legend);
                //gf.CreateSetPoint(Graphique, Graphique.Charts[0]);    // >> Bug #15147 Charts Setpoints only work for first series chart location (frame)
                gf.DisplayAnnotation(Graphique);
                m_Header.BringToFront();
                m_legend.BringToFront();
                // >> Report generate/preview error - Illegal char in path
                foreach (string illegalChar in GlobalNames.ILLEGAL_CHARACTERS_IN_FILE_PATH)
                {
                    if (saveFile.Contains(illegalChar))
                        saveFile = saveFile.Replace(illegalChar, GlobalNames.SPECIAL_CHAR_UNDERSCORE);
                }
                // Report generate/preview error - Illegal char in path
                Graphique.ImageExporter.SaveToFile(saveFile, new NSize(1024, 768), new NResolution(100, 100), NImageFormat.CreateImageFormat("image/png"));
            }
            return;
        }
        #endregion

        #region Fonction pour la génération du rapport en PDF
        /// <summary>
        /// Generate PDF report according to a TreeNodeCollection and PDF airport structure.
        /// </summary>
        /// <param name="Collection">Collection of TreeNode</param>
        /// <param name="Path">Place to save the report</param>
        /// <param name="AirportRoot">Airport root node description</param>
        /// <param name="cht">Loading form</param>
        /// <param name="parameters">Parameters</param>
        public bool generatePDFReport(TreeNodeCollection Collection,
                                       String Path,
                                       TreeNode AirportRoot,
                                       SIMCORE_TOOL.Prompt.SIM_LoadingForm cht,
                                       ReportParameters parameters)
        {
            if (cht != null)
            {
                int nbNode = OverallTools.TreeViewFunctions.CountNodes(Collection);
                nbNode = nbNode * 2; // double parce qu'il y a deux parcours de la list
                if (AirportRoot != null)
                    nbNode++; // +1 pour la generation de la structure
                cht.setFileNumber(nbNode);
            }
            if (!OverallTools.ExternFunctions.CheckCreateDirectory(Path))
                return false;
            if (!OverallTools.ExternFunctions.CheckCreateDirectory(Path + "\\Images"))
                return false;
            try
            {
                PDFGenerator pdf;
                /// Create airport structure document
                // ----------------------------------
                if (AirportRoot != null)
                {
                    if (cht != null)
                        cht.ChargementFichier("Build Airport Structure file");
                    pdf = new PDFGenerator(Path + "\\AirportStructure.pdf");
                    pdf.PageFormat = ReportParameters.PageSizes[parameters.PageFormat];
                    pdf.SetHeaderText(parameters.Name, "", OverallTools.AssemblyActions.AssemblyTitle);
                    pdf.SetFooterText(parameters.Author, "", "%PAGE%");
                    //pdf.LaodImage("logoLogiciel", "C:\\Documents and Settings\\FLE\\Mes documents\\Projets\\reporting\\SIMCORE_TOOL_2010.12.20\\Resources\\Bande Logo_PAX2SIM 2009.jpg");
                    //                       OverallTools.ExternFunctions.copyResourceFile("PAX2SIM", OverallTools.ExternFunctions.getUserDirectoryForPax2sim() + "\\PAX2SIM.JPEG");
                    global::SIMCORE_TOOL.Properties.Resources.PAX2SIM_2010.Save(OverallTools.ExternFunctions.getUserDirectoryForPax2sim() + "\\PAX2SIM.JPEG", System.Drawing.Imaging.ImageFormat.Jpeg);

                    // chargement des images
                    pdf.LaodImage("logoLogiciel", OverallTools.ExternFunctions.getUserDirectoryForPax2sim() + "\\PAX2SIM.JPEG"); // you need to load all images before creating any page
                    pdf.LaodImage("userLogo", parameters.UserLogo); // if the field is null it will do nothing
                    if (parameters.Template != null)
                    {
                        if (parameters.Template.Equals(ReportParameters.defaultTemplateString))
                        {
                            OverallTools.ExternFunctions.copyResourceFile("doc_template.jpg", Path + "\\doc_template.jpg");
                            pdf.LaodImage("template", Path + "\\doc_template.jpg");
                        }
                        else
                            pdf.LaodImage("template", parameters.Template);
                    }
                    // draw the cover page
                    pdf.MakeFirstPage(parameters.Titre, parameters.Author, parameters.Version, parameters.Date, "template", "logoLogiciel", "userLogo");
                    printPDFAirport(pdf, AirportRoot, parameters);
                    pdf.Close();
                }

                /// Create report
                // --------------
                pdf = new PDFGenerator(Path + "\\" + parameters.Name + ".pdf");
                pdf.PageFormat = ReportParameters.PageSizes[parameters.PageFormat];
                pdf.SetHeaderText(parameters.Titre, "", OverallTools.AssemblyActions.AssemblyTitle);
                String dateVersion = parameters.Version == null || parameters.Version.Equals("") ? "" : parameters.Version; // properly format the midle footer string ( "version" - "date")
                dateVersion += dateVersion.Equals("") || parameters.Date == null || parameters.Date.Equals("") ? "" : " - ";
                dateVersion += parameters.Date == null || parameters.Date.Equals("") ? "" : parameters.Date;
                pdf.SetFooterText(parameters.Author, dateVersion, "%PAGE%");

                // chargement des images
                LoadPDFImage(pdf, Collection, Path, cht, parameters);
                global::SIMCORE_TOOL.Properties.Resources.PAX2SIM_2010.Save(OverallTools.ExternFunctions.getUserDirectoryForPax2sim() + "\\PAX2SIM.JPEG", System.Drawing.Imaging.ImageFormat.Jpeg);
                pdf.LaodImage("logoLogiciel", OverallTools.ExternFunctions.getUserDirectoryForPax2sim() + "\\PAX2SIM.JPEG");
                pdf.LaodImage("userLogo", parameters.UserLogo);
                if (parameters.Template != null)
                {
                    if (parameters.Template.Equals(ReportParameters.defaultTemplateString))
                    {
                        //OverallTools.ExternFunctions.copyResourceFile("doc_template.JPG", Path + "\\doc_template.JPG");
                        OverallTools.ExternFunctions.copyResourceFile("doc_template", Path + "\\doc_template.JPG");
                        pdf.LaodImage("template", Path + "\\doc_template.JPG");
                    }
                    else
                        pdf.LaodImage("template", parameters.Template);
                }
                // draw the cover page
                pdf.MakeFirstPage(parameters.Titre, parameters.Author, parameters.Version, parameters.Date, "template", "logoLogiciel", "userLogo");
                PutDocControlTables(pdf, parameters);
                PrintPDFTreeView(pdf, Collection, Path, parameters, cht, true); // to build the table of contents
                PrintPDFTreeView(pdf, Collection, Path, parameters, cht, false);
                pdf.Close();

                /// Clean the folder
                // if there arn't html generated page, then delete the image
                String[] files = System.IO.Directory.GetFiles(Path);
                bool hasHTML = false;
                foreach (String file in files)
                    if (file.EndsWith(".html") || file.EndsWith(".HTML")) hasHTML = true;
                if (!hasHTML)
                {
                    String[] folders = System.IO.Directory.GetDirectories(Path);
                    foreach (String folder in folders)
                        System.IO.Directory.Delete(folder, true);
                    foreach (String file in files)
                    {
                        if (!file.EndsWith(".pdf") && !file.EndsWith(".PDF"))
                            System.IO.File.Delete(file);
                    }
                }
            }
            catch (System.IO.IOException ioe) // file is using by another application
            {
                MessageBox.Show("Err0771 : File used by another application. \n" + ioe.Message, "Access error", MessageBoxButtons.OK);
                OverallTools.ExternFunctions.PrintLogFile("Err0771: " + this.GetType().ToString() + " throw an exception: " + ioe.Message);
                return false;
            }
            return true;
        }

        /// <summary>
        /// Add to the pdf a list of the airport stucture.
        /// </summary>
        private void printPDFAirport(PDFGenerator pdf, TreeNode AirportStructure, ReportParameters parameters)
        {
            pdf.StartList(textFont, textFontSize, "Airport");

            foreach (TreeNode node in AirportStructure.Nodes)
            {
                printPDFAirportNode(pdf, node, 0);
            }
        }
        /// <summary>
        /// Simply add the node name as an element of a list. also add its chirldren.
        /// </summary>
        /// <param name="level">Tabulation level here to add the node</param>
        private void printPDFAirportNode(PDFGenerator pdf, TreeNode NodeMere, int level)
        {
            pdf.AddToList(NodeMere.Text, level);
            if (NodeMere.Nodes.Count != 0)
                foreach (TreeNode node in NodeMere.Nodes)
                    printPDFAirportNode(pdf, node, level + 1);
        }

        /// <summary>
        /// Add information related to a scenario. (not used)
        /// </summary>
        /// <param name="pdf"></param>
        /// <param name="scenarioName"></param>
        void PrintReview(PDFGenerator pdf, String scenarioName)
        {
            List<string> review = GetScenario(scenarioName).getReview(true);
            //pdf.PutTitleFont("");
            pdf.CRLF(2);
            foreach (String entry in review)
            {
                if (entry == null)
                    continue;
                if (entry.Length == 0)
                    continue;
                string tmp = entry;
                if ((entry[0] >= '0') && (entry[0] <= '9'))
                    tmp = entry.Substring(1);
                pdf.PutTextLine(tmp);
            }
        }

        /// <summary>
        /// Add elements of the given TreeView into the pdf.
        /// </summary>
        /// <param name="pdf">pdf affected</param>
        /// <param name="Structure">TreeView node collection</param>
        /// <param name="Path">Data path</param>
        /// <param name="parameters">Report creation parameters</param>
        /// <param name="cht"></param>
        /// <param name="MakeSummary">Do a passe to make the table of conten</param>
        private void PrintPDFTreeView(PDFGenerator pdf,
                                    TreeNodeCollection Structure,
                                    String Path,
                                    ReportParameters parameters,
                                    SIMCORE_TOOL.Prompt.SIM_LoadingForm cht,
                                    bool MakeSummary)
        {
            if (MakeSummary)
                pdf.StartContentTable(textFont, textFontSize, "Table of contents", titleFont, titleFontSize);
            else
                //pdf.PageBreak();
                pdf.CursorPosition = new double[2] { pdf.CursorPosition[0], pdf.PageFormat[1] - pdf.Margin[1] - pdf.FontSize * 3 }; // to force a page break only if needed

            foreach (TreeNode node in Structure)
            {
                //TreeViewTag tt = (TreeViewTag)node.Tag;
                PrintPDFTreeNode(pdf, node, cht, parameters, MakeSummary);
            }
        }

        /// <summary>
        /// Add a TreeNode and its child to the pdf.
        /// </summary>
        /// <param name="pdf">pdf affected</param>
        /// <param name="NodeMere">Node to add</param>
        /// <param name="SavePath"></param>
        /// <param name="cht"></param>
        /// <param name="parameters">report creation parameters</param>
        /// <param name="MakeContentTable">do a passe to make the table of content</param>
        private void PrintPDFTreeNode(PDFGenerator pdf, TreeNode NodeMere, SIMCORE_TOOL.Prompt.SIM_LoadingForm cht, ReportParameters parameters, bool MakeContentTable)
        {
            if ((NodeMere.Tag == null) || (NodeMere.Tag.GetType() != typeof(TreeViewTag)))
                return;
            if (!MakeContentTable && cht != null)
                cht.ChargementFichier("Build Chapter (" + NodeMere.Text + ") ...");

            TreeViewTag Tag = (TreeViewTag)NodeMere.Tag;

            // La node est un graphique
            if (Tag.isChartNode && !MakeContentTable)
            {
                double imgScale = 0.5;
                double[] imgSize = pdf.GetImageSize(NodeMere.GetHashCode() + NodeMere.Name);
                imgSize[0] *= imgScale;
                imgSize[1] *= imgScale;
                if (pdf.GetPageLeftSpace() < imgSize[1])
                    pdf.PageBreak();
                pdf.DrawImage(NodeMere.GetHashCode() + NodeMere.Name, imgScale, PDFGenerator.HorizontalPosition.CENTER);
                pdf.CRLF();
            }

            // the node is a html note
            else if (Tag.isParagraphNode && !MakeContentTable)
            {
                Paragraph p = null;
                String note = null;
                if ((p = getParagraph(NodeMere.Name)) != null)
                {
                    bool hasTitle = p.Title != null && p.Title != "";
                    if (pdf.GetPageLeftSpace() < pdf.FontSize * 6) // s'il rest moins de 6 lignes, on passe la page
                        pdf.PageBreak();
                    pdf.Font = textFont; pdf.FontSize = textFontSize;
                    pdf.AddSimpleHTML(p.Content);
                }
                else if (Tag.IsExceptionNode && (note = getExNote(Tag.ScenarioName, Tag.Name, Tag.ExceptionName)) != null)
                {
                    if (pdf.FontSize * 7 > pdf.GetPageLeftSpace())
                        pdf.PageBreak();
                    pdf.Font = textFont; pdf.FontSize = textFontSize;
                    pdf.AddSimpleHTML(note);
                }
                else if (((note = getNote(Tag.ScenarioName, Tag.Name)) != null || (note = getGeneralNote(NodeMere.Name)) != null)
                        && Tag.ImageIndex != Model.GANTT_NOTE_IMAGE_INDEX && Tag.ImageIndex != GlobalNames.DASHBOARD_NOTE_IMAGE_INDEX) //>>GanttNote for Report // >> Task #10645 Pax2Sim - Pax analysis - Summary: dashboard image for Reports
                {
                    if (pdf.FontSize * 7 > pdf.GetPageLeftSpace())
                        pdf.PageBreak();
                    pdf.Font = textFont; pdf.FontSize = textFontSize;
                    pdf.AddSimpleHTML(note);
                }
                else if (((note = getGanttNote(Tag.ScenarioName, Tag.Name)) != null) && Tag.ImageIndex == Model.GANTT_NOTE_IMAGE_INDEX)
                {  
                // << Task #6386 Itinerary process                    
                    // use the Gantt Note if the Node holds the Gantt image   //>>GanttNote for Report
                    /*Don't add it as a HTML note because it needs resizing!!!
                    if (pdf.FontSize * 7 > pdf.GetPageLeftSpace())
                        pdf.PageBreak();
                    pdf.Font = textFont; pdf.FontSize = textFontSize;
                    pdf.AddSimpleHTML(note);
                    */
                    
                    //get the path from the HTML note
                    String completeFilePath = "";
                    int start = note.IndexOf("<img src=") + 10;
                    int end = note.IndexOf("/></BODY>") - 2;
                    if (start > 0 && end > 0)
                        completeFilePath = note.Substring(start, end - start);
                    else
                        OverallTools.ExternFunctions.PrintLogFile("GestionDonneesHUB2SIM.PrintPDFTreeNode(...):" +
                            " Error while creating PDF Report with Gantt/ProcessFlow Image: the file path could not be determined.");
                    if (completeFilePath != "")
                    {
                        // add the image into the images list(dictionary) with the complete path as key
                        //pdf.LaodImage(completeFilePath, completeFilePath);
                        double imgScale = 0.5;
                        double[] imgSize = pdf.GetImageSize(NodeMere.GetHashCode() + completeFilePath);
                        imgSize[0] *= imgScale;
                        imgSize[1] *= imgScale;
                        if (pdf.GetPageLeftSpace() < imgSize[1])
                            pdf.PageBreak();
                        pdf.DrawImage(NodeMere.GetHashCode() + completeFilePath, imgScale, PDFGenerator.HorizontalPosition.CENTER);
                        pdf.CRLF();
                    }
                // >> Task #6386 Itinerary process
                }
                else if (((note = getDashboardNote(Tag.ScenarioName, Tag.Name)) != null) && Tag.ImageIndex == GlobalNames.DASHBOARD_NOTE_IMAGE_INDEX)
                {   // >> Task #10645 Pax2Sim - Pax analysis - Summary: dashboard image for Reports
                    // << Task #6386 Itinerary process                    
                    // use the Dashboard Note if the Node holds the Dashboard image
                    /*Don't add it as a HTML note because it needs resizing!!!
                    if (pdf.FontSize * 7 > pdf.GetPageLeftSpace())
                        pdf.PageBreak();
                    pdf.Font = textFont; pdf.FontSize = textFontSize;
                    pdf.AddSimpleHTML(note);
                    */

                    //get the path from the HTML note
                    String completeFilePath = "";
                    int start = note.IndexOf("<img src=") + 10;
                    int end = note.IndexOf("/></BODY>") - 2;
                    if (start > 0 && end > 0)
                        completeFilePath = note.Substring(start, end - start);
                    else
                        OverallTools.ExternFunctions.PrintLogFile("GestionDonneesHUB2SIM.PrintPDFTreeNode(...):" +
                            " Error while creating PDF Report with Dashboard Image: the file path could not be determined.");
                    if (completeFilePath != "")
                    {
                        // add the image into the images list(dictionary) with the complete path as key
                        //pdf.LaodImage(completeFilePath, completeFilePath);
                        double imgScale = 0.5;
                        double[] imgSize = pdf.GetImageSize(NodeMere.GetHashCode() + completeFilePath);
                        imgSize[0] *= imgScale;
                        imgSize[1] *= imgScale;
                        if (pdf.GetPageLeftSpace() < imgSize[1])
                            pdf.PageBreak();
                        pdf.DrawImage(NodeMere.GetHashCode() + completeFilePath, imgScale, PDFGenerator.HorizontalPosition.CENTER);
                        pdf.CRLF();
                    }
                    // >> Task #6386 Itinerary process
                }
                pdf.CRLF();
            }

            // the node is a table node
            else if (((Tag.isTableNode) || (Tag.isResultNode) || (Tag.isFilterNode) || (Tag.IsExceptionNode && !Tag.isParagraphNode)) && !MakeContentTable)
            {
                DataTable table = null;
                if (Tag.IsExceptionNode)
                {
                    NormalTable nt = GetExceptionTable(Tag.ScenarioName, Tag.Name, Tag.ExceptionName);
                    if (nt != null) table = nt.Table;
                }
                else
                    table = getTable(Tag.ScenarioName, NodeMere.Name);
                if (table != null) // check scenario name
                {
                    if (cht != null)
                        cht.ChargementFichier("Export : " + NodeMere.Text);
                    if (pdf.GetPageLeftSpace() < pdf.FontSize * 8) // if there is less than 8 text line in the page then go to the next page
                        pdf.PageBreak();
                    VisualisationMode mode = getModeVisualisation(Tag.ScenarioName, NodeMere.Name);

                    // >> Task #10352 Pax2Sim - PDF Report - split Time table
                    bool isTimeTable = false;
                    if (table.Columns.Count > 0)
                    {
                        DataColumn firstColumn = table.Columns[0];
                        if (firstColumn.ColumnName != null && firstColumn.ColumnName.Equals(GlobalNames.sColumnTime))
                            isTimeTable = true;
                    }
                    // << Task #10352 Pax2Sim - PDF Report - split Time table

                    // >> Task #10156 Pax2Sim - Statistic dev - Target
                    if ((nodeBelongsToTargetDirectory(NodeMere)
                        || table.TableName.Contains(GlobalNames.TARGET_TABLE_NAME_SUFIX))
                        && !table.TableName.Contains(GlobalNames.VIEW_STATS_TABLE_SUFFIX))  // >> Task #10254 Pax2Sim - View statistics option
                    {
                        PrintPDFStatisticTargetDataTable(pdf, table, mode,
                            parameters.GetResizePolicy(Tag.ScenarioName, Tag.Name, Tag.ExceptionName));
                    }
                    else if ((isTimeTable && table.Columns.Count > 4)   // >> Task #10352 Pax2Sim - PDF Report - split Time table
                            || table.TableName.Equals(GlobalNames.FPI_TableName)   // >> Task #10355 Pax2Sim - Allocation - Flight Plan Information new column
                            || table.TableName.Contains(GlobalNames.IST_TABLE_SUFFIX + GlobalNames.COUNTED_ITEMS_TABLE_SUFIX))  // >> Task #10359 Pax2Sim - Counting functionality
                    {
                        int firstColumnIndex = 1;
                        int lastColumnIndex = table.Columns.Count / 2;
                        DataTable splitedTable = getSplitedTable(table, firstColumnIndex, lastColumnIndex);

                        if (splitedTable != null)
                        {
                            PrintPDFDataTable(pdf, splitedTable, mode,
                            parameters.GetResizePolicy(Tag.ScenarioName, Tag.Name, Tag.ExceptionName));
                        }

                        firstColumnIndex = (table.Columns.Count / 2) + 1;
                        lastColumnIndex = table.Columns.Count - 1;
                        splitedTable = getSplitedTable(table, firstColumnIndex, lastColumnIndex);

                        if (splitedTable != null)
                        {
                            PrintPDFDataTable(pdf, splitedTable, mode,
                            parameters.GetResizePolicy(Tag.ScenarioName, Tag.Name, Tag.ExceptionName));
                        }
                    }
                    else
                    {
                        PrintPDFDataTable(pdf, table, mode,
                            parameters.GetResizePolicy(Tag.ScenarioName, Tag.Name, Tag.ExceptionName));
                    }
                    // << Task #10156 Pax2Sim - Statistic dev - Target
                    pdf.CRLF(2);
                }
            }

            // the node is a directory (exported as a chapter)
            else if (Tag.isDirectoryNode)
            {
                if (MakeContentTable)
                    pdf.AddContentElement(NodeMere.GetHashCode().ToString() + NodeMere.Name, NodeMere.Text);
                else
                {
                    // check space for the next node (in aim to doesn't separate title and content)
                    double space = pdf.GetPageLeftSpace();
                    bool putDivider = NodeMere.Level < parameters.DividerLevel; // Bug Divider level
                    TreeNode firstChild = NodeMere.FirstNode;
                    if (firstChild != null && firstChild.Tag != null && !(firstChild.Tag as TreeViewTag).isDirectoryNode)
                    {
                        TreeViewTag childTag = firstChild.Tag as TreeViewTag;
                        // in case first child is a chart
                        if (childTag.isChartNode)
                        {
                            double imgScale = 0.5;
                            double[] imgSize = pdf.GetImageSize(firstChild.GetHashCode() + firstChild.Name);
                            imgSize[1] *= imgScale;
                            if (space < (imgSize[1] + titleFontSize * 2))
                                pdf.PageBreak();
                        }
                        // in case first child is a table or a paragraph
                        else if (childTag.isResultNode || childTag.isTableNode || childTag.isFilterNode || childTag.isParagraphNode)
                        {
                            if (space < titleFontSize * 6)
                                pdf.PageBreak();
                        }
                    }
                    pdf.Font = textFont; pdf.FontSize = textFontSize;
                    if (NodeMere.PrevNode != null && !putDivider)
                    {
                        pdf.CRLF();
                    }

                    // Put divider page if necessary
                    if (putDivider)
                    {
                        pdf.SetContentElementPage(NodeMere.GetHashCode().ToString() + NodeMere.Name);
                        PutIntercalaire(pdf, NodeMere, NodeMere.Text);
                    }
                    else
                        pdf.PutContentElement(NodeMere.GetHashCode().ToString() + NodeMere.Name, titleFont, titleFontSize);
                    pdf.CRLF();
                }
            }

            // Print all child
            if (NodeMere.Nodes.Count > 0)
            {
                if (MakeContentTable) pdf.ContentTableLevelUp(); else pdf.ListLevelUp();
                for (int i = 0; i < NodeMere.Nodes.Count; i++)
                {
                    PrintPDFTreeNode(pdf, NodeMere.Nodes[i], cht, parameters, MakeContentTable);
                }
                if (MakeContentTable) pdf.ContentTableLevelDown(); else pdf.ListLevelDown();
            }
        }

        // >> Task #10352 Pax2Sim - PDF Report - split Time table
        /// <summary>
        /// For a table that has the 1st column named 'Time': we split it into 2 tables,
        /// each of the resulted tables have as 1st column the column 'Time' from the source table.
        /// </summary>
        /// <param name="sourceTable"></param>
        /// <param name="firstRemainingColumnIndex"></param>
        /// <param name="lastRemainingColumnIndex"></param>
        /// <returns></returns>
        public DataTable getSplitedTable(DataTable sourceTable, int firstRemainingColumnIndex, int lastRemainingColumnIndex)
        {
            DataTable resultedTable = sourceTable.Copy();

            if (resultedTable != null && resultedTable.Columns != null)
            {
                ArrayList unwantedColumnNamesList = new ArrayList();

                if (firstRemainingColumnIndex <= lastRemainingColumnIndex
                    && lastRemainingColumnIndex < resultedTable.Columns.Count)
                {
                    for (int i = 1; i < resultedTable.Columns.Count; i++)
                    {
                        if (i < firstRemainingColumnIndex || i > lastRemainingColumnIndex)
                            unwantedColumnNamesList.Add(resultedTable.Columns[i].ColumnName);
                    }

                    for (int j = 0; j < unwantedColumnNamesList.Count; j++)
                    {
                        String columnName = unwantedColumnNamesList[j].ToString();
                        if (resultedTable.Columns.IndexOf(columnName) != -1)
                        {
                            resultedTable.Columns.Remove(columnName);
                        }
                    }
                }
            }
            return resultedTable;
        }
        // << Task #10352 Pax2Sim - PDF Report - split Time table

        /// <summary>
        /// Add a divider page with a small table of content
        /// </summary>
        /// <param name="pdf"></param>
        /// <param name="Node"></param>
        /// <param name="title">page title</param>
        private void PutIntercalaire(PDFGenerator pdf, TreeNode Node, String title)
        {
            if (!pdf.IsNewPage())
                pdf.AddBlankPage();

            // draw intercalaire image
            double[] Pos = { 0.0, 0.0 };
            pdf.DrawImage("template", PDFGenerator.ScaleMethod.WIDTH, 1, PDFGenerator.HorizontalPosition.CENTER, PDFGenerator.VerticalPosition.TOP);

            // draw title
            pdf.Font = bigTitleFont;
            pdf.FontSize = bigTitleFontSize;
            // center title
            Pos[0] = pdf.PageFormat[0] / 2 - pdf.GetTextLength(title) / 2;
            Pos[1] = pdf.PageFormat[1] / 2;
            pdf.CursorPosition = Pos;
            pdf.PutTitle(title);
            pdf.Font = textFont; pdf.FontSize = textFontSize;

            // print a small table of contents
            foreach (TreeNode node in Node.Nodes)
            {
                if (node.Tag != null && (node.Tag as TreeViewTag).isDirectoryNode)
                    pdf.ReDrawContentElement(node.GetHashCode().ToString() + node.Name);
            }
            //pdf.PageBreak();
            pdf.CursorPosition = new double[2] { pdf.CursorPosition[0], pdf.PageFormat[1] - pdf.Margin[1] - pdf.FontSize * 3 }; // to force a page break only if needed
        }

        /// <summary>
        /// Draw tables containing version overview  and document
        /// control in the pdf.
        /// </summary>
        /// <param name="pdf">PDF to affect</param>
        /// <param name="parameters">Document generation properties</param>
        void PutDocControlTables(PDFGenerator pdf, ReportParameters parameters)
        {
            bool hasPrint = false;
            bool hasControl = !(parameters.ProjStep == null || parameters.ProjStep == "") ||
                                !(parameters.IssuedDept == null || parameters.IssuedDept == "") ||
                                !(parameters.PartOf == null || parameters.PartOf == "") ||
                                !(parameters.IntDocRef == null || parameters.IntDocRef == "") ||
                                !(parameters.ExtDocRef == null || parameters.ExtDocRef == "");
            bool hasProp = !(parameters.DocStatus == null || parameters.DocStatus == "") ||
                            !(parameters.Appendices == null || parameters.Appendices == "");
            if (hasControl || hasProp)
            {
                hasPrint = true;
                // Document properties
                // put title
                pdf.CRLF();
                pdf.Font = titleFont; pdf.FontSize = titleFontSize;
                pdf.PutTitle("Document Control");
                pdf.Font = textFont; pdf.FontSize = textFontSize;

            }

            if (hasControl)
            {
                hasPrint = true;
                // Document properties
                // put content line
                List<List<PDFjet.NET.Cell>> pdfTable;
                List<PDFjet.NET.Cell> line;
                PDFjet.NET.Cell cell;
                pdfTable = new List<List<PDFjet.NET.Cell>>();

                line = new List<PDFjet.NET.Cell>();
                cell = new PDFjet.NET.Cell(pdf.GetCurrentFont(), "Issued dept.");
                cell.SetBgColor(new int[4] { 192, 192, 192, 0 });
                line.Add(cell);
                cell = new PDFjet.NET.Cell(pdf.GetCurrentFont(), parameters.IssuedDept == null ? "" : parameters.IssuedDept);
                line.Add(cell);
                pdfTable.Add(line);

                line = new List<PDFjet.NET.Cell>();
                cell = new PDFjet.NET.Cell(pdf.GetCurrentFont(), "Project step");
                cell.SetBgColor(new int[4] { 192, 192, 192, 0 });
                line.Add(cell);
                cell = new PDFjet.NET.Cell(pdf.GetCurrentFont(), parameters.ProjStep == null ? "" : parameters.ProjStep);
                line.Add(cell);
                pdfTable.Add(line);

                line = new List<PDFjet.NET.Cell>();
                cell = new PDFjet.NET.Cell(pdf.GetCurrentFont(), "Part of");
                cell.SetBgColor(new int[4] { 192, 192, 192, 0 });
                line.Add(cell);
                cell = new PDFjet.NET.Cell(pdf.GetCurrentFont(), parameters.PartOf == null ? "" : parameters.PartOf);
                line.Add(cell);
                pdfTable.Add(line);

                line = new List<PDFjet.NET.Cell>();
                cell = new PDFjet.NET.Cell(pdf.GetCurrentFont(), "Intern document No.");
                cell.SetBgColor(new int[4] { 192, 192, 192, 0 });
                line.Add(cell);
                cell = new PDFjet.NET.Cell(pdf.GetCurrentFont(), parameters.IntDocRef == null ? "" : parameters.IntDocRef);
                line.Add(cell);
                pdfTable.Add(line);

                line = new List<PDFjet.NET.Cell>();
                cell = new PDFjet.NET.Cell(pdf.GetCurrentFont(), "Extern document No.    ");
                cell.SetBgColor(new int[4] { 192, 192, 192, 0 });
                line.Add(cell);
                cell = new PDFjet.NET.Cell(pdf.GetCurrentFont(), parameters.ExtDocRef == null ? "" : parameters.ExtDocRef);
                line.Add(cell);
                pdfTable.Add(line);

                pdf.Font = textFont; pdf.FontSize = textFontSize;
                pdf.AddTable(pdfTable, null);
            }
            if (hasProp)
            {
                hasPrint = true;
                List<List<PDFjet.NET.Cell>> pdfTable = new List<List<PDFjet.NET.Cell>>();
                List<PDFjet.NET.Cell> line = new List<PDFjet.NET.Cell>();
                PDFjet.NET.Cell cell = new PDFjet.NET.Cell(pdf.GetCurrentFont(), "Version");
                cell.SetBgColor(new int[4] { 192, 192, 192, 0 });
                line.Add(cell);
                cell = new PDFjet.NET.Cell(pdf.GetCurrentFont(), parameters.Version == null ? "" : parameters.Version);
                line.Add(cell);
                pdfTable.Add(line);
                line = new List<PDFjet.NET.Cell>();
                cell = new PDFjet.NET.Cell(pdf.GetCurrentFont(), "Status");
                cell.SetBgColor(new int[4] { 192, 192, 192, 0 });
                line.Add(cell);
                cell = new PDFjet.NET.Cell(pdf.GetCurrentFont(), parameters.DocStatus == null ? "" : parameters.DocStatus);
                line.Add(cell);
                pdfTable.Add(line);
                line = new List<PDFjet.NET.Cell>();
                cell = new PDFjet.NET.Cell(pdf.GetCurrentFont(), "Appendices     ");
                cell.SetBgColor(new int[4] { 192, 192, 192, 0 });
                line.Add(cell);
                cell = new PDFjet.NET.Cell(pdf.GetCurrentFont(), parameters.Appendices == null ? "" : parameters.Appendices);
                line.Add(cell);
                pdfTable.Add(line);
                //pdf.CurrentFont = PDFGenerator.FontList.NORMAL;
                pdf.Font = textFont; pdf.FontSize = textFontSize;
                pdf.AddTable(pdfTable, null);
                pdf.CRLF();
            }

            // document approval list
            List<String[]> table = parameters.ApprovalList;
            if (!(table == null || table.Count == 0))
            {
                hasPrint = true;
                List<List<PDFjet.NET.Cell>> pdfTable = new List<List<PDFjet.NET.Cell>>();

                // put title
                pdf.CRLF();
                pdf.Font = titleFont; pdf.FontSize = titleFontSize;
                pdf.PutTitle("Approval");
                pdf.CRLF();
                pdf.Font = textFont; pdf.FontSize = textFontSize;

                String[] titleLine = new String[] { "Act.", "Name", "Org. unit", "Signature", "Date" };
                List<PDFjet.NET.Cell> line = new List<PDFjet.NET.Cell>();
                foreach (String columnTitle in titleLine)
                {
                    PDFjet.NET.Cell cell = new PDFjet.NET.Cell(pdf.GetCurrentFont(), columnTitle);
                    cell.SetBgColor(new int[4] { 192, 192, 192, 0 });
                    line.Add(cell);
                }
                pdfTable.Add(line);

                // put content line
                foreach (String[] ligne in table)
                {
                    line = new List<PDFjet.NET.Cell>();
                    for (int i = 0; i < table[0].Length; i++)
                    {
                        PDFjet.NET.Cell cell = new PDFjet.NET.Cell(pdf.GetCurrentFont(), ligne[i]);
                        line.Add(cell);
                    }
                    pdfTable.Add(line);
                }
                pdf.Font = textFont; pdf.FontSize = textFontSize;

                pdf.AddTable(pdfTable, parameters.ApprovalColumnWidth, true);
                pdf.CRLF();
            }

            // Document version change
            table = parameters.VersionList;
            if (!(table == null || table.Count == 0))
            {
                hasPrint = true;
                List<List<PDFjet.NET.Cell>> pdfTable = new List<List<PDFjet.NET.Cell>>();

                // put title
                pdf.CRLF();
                pdf.Font = titleFont; pdf.FontSize = titleFontSize;
                pdf.PutTitle("Version Overview");
                pdf.Font = textFont; pdf.FontSize = textFontSize;
                pdf.CRLF();

                String[] titleLine = new String[] { "Version", "Reissue Date", "Description of Change", "page(s)", "Department" };
                List<PDFjet.NET.Cell> line = new List<PDFjet.NET.Cell>();
                foreach (String columnTitle in titleLine)
                {
                    PDFjet.NET.Cell cell = new PDFjet.NET.Cell(pdf.GetCurrentFont(), columnTitle);
                    cell.SetBgColor(new int[4] { 192, 192, 192, 0 });
                    line.Add(cell);
                }
                pdfTable.Add(line);

                // put content line
                foreach (String[] ligne in table)
                {
                    line = new List<PDFjet.NET.Cell>();
                    for (int i = 0; i < table[0].Length; i++)
                    {
                        PDFjet.NET.Cell cell = new PDFjet.NET.Cell(pdf.GetCurrentFont(), ligne[i]);
                        line.Add(cell);
                    }
                    pdfTable.Add(line);
                }
                //pdf.CurrentFont = PDFGenerator.FontList.NORMAL;
                pdf.Font = textFont; pdf.FontSize = textFontSize;
                pdf.AddTable(pdfTable, parameters.VersionColumnWidth, true);
                pdf.CRLF();
            }
            if (hasPrint) pdf.PageBreak();
        }

        /// <summary>
        /// Add a table in the PDF
        /// </summary>
        /// <param name="resize">If the table is biger than page width, this parameters allow to resize the table</param>
        private void PrintPDFDataTable(PDFGenerator pdf, DataTable table, VisualisationMode vmMode, ReportParameters.ColumnSizePolicy cspPolicy)
        {

            if (table == null)
                return;

            double[] columnWidth = null;
            bool bCompressTab = table.TableName.StartsWith("Alloc_") && table.Columns.Count > 6; // !!! reduction de la largeur des tables "Alloc_" !!!
            List<List<PDFjet.NET.Cell>> pdfTable = new List<List<PDFjet.NET.Cell>>();

            // add the first line
            List<PDFjet.NET.Cell> line = new List<PDFjet.NET.Cell>();
            foreach (DataColumn colonne in table.Columns)
            {
                PDFjet.NET.Cell cell = new PDFjet.NET.Cell(pdf.GetCurrentFont(), colonne.ColumnName);
                if (bCompressTab && table.Columns[0] != colonne) cell.SetText(""); // !!! reduction de la largeur des tables "Alloc_" !!!
                line.Add(cell);
            }
            pdfTable.Add(line);

            bool bUseMode = false;
            bool bUseError = false;
            int[] DefaultRGBColor = new int[4] { 255, 255, 255, 0 };
            Color color;

            if ((vmMode != null) && (vmMode.ConditionnalFormatClass != null) && (vmMode.ConditionnalFormatClass[0] != null))
            {
                bUseMode = true;
                color = vmMode.BackgroundDefaultColor;
                DefaultRGBColor = new int[4] { color.R, color.G, color.B, color.A };
                if ((vmMode.ConditionnalFormatClass[0].GetType() == typeof(ConditionnalFormatErrors)) || vmMode.ConditionnalFormatClass[0].GetType() == typeof(ConditionnalFormatLine))
                {
                    bUseError = true;
                }
            }

            int j = 0;
            foreach (DataRow ligne in table.Rows)
            {
                line = new List<PDFjet.NET.Cell>();
                for (int i = 0; i < table.Columns.Count; i++)
                {
                    String sText =  ligne[i].ToString();
                    if (bUseMode  && bUseError)
                    {
                        sText = vmMode.getPrefixe(i, j) + sText + vmMode.getSuffixe(i, j);
                    }
                    PDFjet.NET.Cell cell = new PDFjet.NET.Cell(pdf.GetCurrentFont(), sText);
                    if (bCompressTab && i != 0) cell.SetText(""); // !!! reduction de la largeur des tables "Alloc_" !!!
                    if (bUseMode) // with color
                    {
                        if (bUseError)
                        {
                            color = vmMode.getVisualisationMode(i, j);
                        }
                        else
                            color = vmMode.getVisualisationMode(i, ligne[i]);
                        cell.SetBgColor(new int[4] { color.R, color.G, color.B, color.A, });
                    }
                    else
                        cell.SetBgColor(DefaultRGBColor);
                    line.Add(cell);
                }
                pdfTable.Add(line);
                j++;
            }
            //pdf.CurrentFont = PDFGenerator.FontList.NORMAL;
            pdf.Font = textFont; pdf.FontSize = textFontSize;

            /*if (table.TableName.StartsWith("Alloc_") && table.Columns.Count > 6) // !!! reduction de la largeur des tables "Alloc_" !!!
            {
                columnWidth = new int[pdfTable[0].Count];
                columnWidth[0] = 72;
                for (int i = 1; i < pdfTable[0].Count; i++)
                    columnWidth[i] = 4; // !!! reduction de largeur des colonnes
            }*/
            if (cspPolicy == ReportParameters.ColumnSizePolicy.AdjustPage)
            {
                // recuperation de la largeur des colonnes
                double pageSize = pdf.PageFormat[0] - (pdf.Margin[2] + 2);
                if (vmMode != null && vmMode.ColumnWidth != null)
                {
                    columnWidth = new double[vmMode.ColumnWidth.Length];
                    for (int i =0; i<vmMode.ColumnWidth.Length; i++)
                        columnWidth[i] = (double)vmMode.ColumnWidth[i];
                }
                else
                {
                    double[] dColumnWidth = pdf.GetTableColumnWidth(pdfTable);
                    columnWidth = new double[dColumnWidth.Length];
                    for (int i = 0; i < dColumnWidth.Length; i++)
                        columnWidth[i] = dColumnWidth[i];
                }
                
                // reduction de la largeur des colonnes
                double tableSize = 0;
                double reduction;
                foreach (double size in columnWidth)
                    tableSize += size;
                reduction = pageSize / tableSize;
                for (int i=0; i<columnWidth.Length; i++)
                    columnWidth[i] *= reduction;
            }
            else if (cspPolicy == ReportParameters.ColumnSizePolicy.AdjustContent)
            {
                columnWidth = null;
            }
            else
            {
                if (vmMode == null)
                    columnWidth = null;
                else
                {
                    if (vmMode.ColumnWidth != null)
                    {
                        columnWidth = new double[vmMode.ColumnWidth.Length];
                        for (int i = 0; i < vmMode.ColumnWidth.Length; i++)
                            columnWidth[i] = (double)vmMode.ColumnWidth[i];
                    }
                }
            }
            pdf.AddTable(pdfTable, columnWidth);
        }

        // >> Task #10156 Pax2Sim - Statistic dev - Target        
        /// <summary>
        /// Add a Target table in the PDF
        /// </summary>
        /// <param name="resize">If the table is biger than page width, this parameters allow to resize the table</param>
        private void PrintPDFStatisticTargetDataTable(PDFGenerator pdf, DataTable table, VisualisationMode vmMode, ReportParameters.ColumnSizePolicy cspPolicy)
        {

            if (table == null)
                return;

            double[] columnWidth = null;
            bool bCompressTab = table.TableName.StartsWith("Alloc_") && table.Columns.Count > 6; // !!! reduction de la largeur des tables "Alloc_" !!!
            List<List<PDFjet.NET.Cell>> pdfTable = new List<List<PDFjet.NET.Cell>>();

            // add the first line
            List<PDFjet.NET.Cell> line = new List<PDFjet.NET.Cell>();
            int colIndex = 0;
            foreach (DataColumn colonne in table.Columns)
            {
                PDFjet.NET.Cell cell = new PDFjet.NET.Cell(pdf.GetCurrentFont(), colonne.ColumnName);                
                line.Add(cell);
                if (colIndex == 5)
                {
                    pdfTable.Add(line);
                    line = new List<PDFjet.NET.Cell>();
                }
                colIndex++;
            }
            pdfTable.Add(line);

            bool bUseMode = false;
            bool bUseError = false;
            int[] DefaultRGBColor = new int[4] { 255, 255, 255, 0 };
            Color color;

            if ((vmMode != null) && (vmMode.ConditionnalFormatClass != null) && (vmMode.ConditionnalFormatClass[0] != null))
            {
                bUseMode = true;
                color = vmMode.BackgroundDefaultColor;
                DefaultRGBColor = new int[4] { color.R, color.G, color.B, color.A };
                if ((vmMode.ConditionnalFormatClass[0].GetType() == typeof(ConditionnalFormatErrors)) || vmMode.ConditionnalFormatClass[0].GetType() == typeof(ConditionnalFormatLine))
                {
                    bUseError = true;
                }
            }

            int j = 0;
            int targetAchivedColumnIndex = table.Columns.IndexOf(GlobalNames.target_targetAchived_columnName);
            foreach (DataRow ligne in table.Rows)
            {
                line = new List<PDFjet.NET.Cell>();
                
                String targetAchived = "";
                if (targetAchivedColumnIndex != -1)
                    targetAchived = ligne[targetAchivedColumnIndex].ToString();

                for (int i = 0; i < table.Columns.Count; i++)
                {                    

                    String sText = ligne[i].ToString();
                    if (bUseMode && bUseError)
                    {
                        sText = vmMode.getPrefixe(i, j) + sText + vmMode.getSuffixe(i, j);
                    }
                    PDFjet.NET.Cell cell = new PDFjet.NET.Cell(pdf.GetCurrentFont(), sText);
                    
                    if (targetAchived.Equals(GlobalNames.TARGET_ACHIEVED_POSITIVE))
                    {
                        cell.SetBgColor(new int[4] { Color.LightGreen.R, Color.LightGreen.G, Color.LightGreen.B, Color.LightGreen.A });
                    }
                    else if (targetAchived.Equals(GlobalNames.TARGET_ACHIEVED_NEGATIVE))
                    {
                        cell.SetBgColor(new int[4] { ControlPaint.LightLight(Color.Red).R, ControlPaint.LightLight(Color.Red).G,
                            ControlPaint.LightLight(Color.Red).B, ControlPaint.LightLight(Color.Red).A });
                    }
                    line.Add(cell);

                    if (i == 5)
                    {
                        pdfTable.Add(line);
                        j++;
                        line = new List<PDFjet.NET.Cell>();                        
                    }
                }
                pdfTable.Add(line);
                j++;
            }

            pdf.Font = textFont; pdf.FontSize = textFontSize;


            if (cspPolicy == ReportParameters.ColumnSizePolicy.AdjustPage)
            {
                // recuperation de la largeur des colonnes
                double pageSize = pdf.PageFormat[0] - (pdf.Margin[2] + 2);
                if (vmMode != null && vmMode.ColumnWidth != null)
                {
                    columnWidth = new double[vmMode.ColumnWidth.Length];
                    for (int i = 0; i < vmMode.ColumnWidth.Length; i++)
                        columnWidth[i] = (double)vmMode.ColumnWidth[i];
                }
                else
                {
                    double[] dColumnWidth = pdf.GetTableColumnWidth(pdfTable);
                    columnWidth = new double[dColumnWidth.Length];
                    for (int i = 0; i < dColumnWidth.Length; i++)
                        columnWidth[i] = dColumnWidth[i];
                }

                // reduction de la largeur des colonnes
                double tableSize = 0;
                double reduction;
                foreach (double size in columnWidth)
                    tableSize += size;
                reduction = pageSize / tableSize;
                for (int i = 0; i < columnWidth.Length; i++)
                    columnWidth[i] *= reduction;
            }
            else if (cspPolicy == ReportParameters.ColumnSizePolicy.AdjustContent)
            {
                columnWidth = null;
            }
            else
            {
                if (vmMode == null)
                    columnWidth = null;
                else
                {
                    if (vmMode.ColumnWidth != null)
                    {
                        columnWidth = new double[vmMode.ColumnWidth.Length];
                        for (int i = 0; i < vmMode.ColumnWidth.Length; i++)
                            columnWidth[i] = (double)vmMode.ColumnWidth[i];
                    }
                }
            }
            pdf.AddTable(pdfTable, columnWidth);
        }

        private bool nodeBelongsToTargetDirectory(TreeNode node)
        {
            if (node != null)
            {
                while (node.Parent != null)
                {
                    if (node.Parent.Tag != null && node.Parent.Name != null)
                    {
                        TreeViewTag parentTag = (TreeViewTag)node.Parent.Tag;
                        if (parentTag.isDirectoryNode && node.Parent.Name.Equals(GlobalNames.TARGET_DIRECTORY_NAME))
                            return true;
                    }
                    node = node.Parent;
                }
            }
            return false;
        }
        // << Task #10156 Pax2Sim - Statistic dev - Target

        /// <summary>
        /// Go all over tree to search image in html part (Paragraph, Note) and launch 
        /// chart image generation.
        /// </summary>
        /// <param name="pdf"></param>
        /// <param name="Nodes">Nodes to check</param>
        /// <param name="path">path where save the generated chart image</param>
        /// <param name="cht"></param>
        /// <param name="parameters">report generation parameters</param>
        private void LoadPDFImage(
                        PDFGenerator pdf,
                        TreeNodeCollection Nodes,
                        String path,
                        SIMCORE_TOOL.Prompt.SIM_LoadingForm cht,
                        ReportParameters parameters)
        {
            foreach (TreeNode Node in Nodes)
            {
                // Y a un truc qui va pas, on arrête !
                if ((Node.Tag == null) || (Node.Tag.GetType() != typeof(TreeViewTag)))
                    return;
                TreeViewTag Tag = (TreeViewTag)Node.Tag;
                if (cht != null)
                    cht.ChargementFichier("Build Graphics ...");

                if (Tag.isChartNode)
                {
                    String SavePath = "";
                    if (!path.EndsWith("\\"))   // >> Report generate/preview error - Illegal char in path
                        SavePath = path + "\\";
                    else
                        SavePath = path;
                    if ((Tag.ScenarioName == null || Tag.ScenarioName == "") && (GetGeneralGraphicFilter(Node.Name) != null) && (getFilter(Tag.ScenarioName,Node.Name)==null))
                    {
                        SavePath += "Charts\\";
                        {
                            if (OverallTools.ExternFunctions.IsOlderThan(SavePath + Node.Name + "_Chart.png", 120)) // si le fichier a était créé il y a moins de 2 minutes on peut considérer que c'est la derniere version
                                if (OverallTools.ExternFunctions.CheckCreateDirectory(SavePath))
                                    SaveGraphique(Node.Name, SavePath + Node.Name + "_Chart.png");
                            pdf.LaodImage(Node.GetHashCode() + Node.Name, SavePath + Node.Name + "_Chart.png");
                        }
                    }
                    else
                    {
                        SavePath += Tag.ScenarioName + "\\";
                        if (Tag.IsExceptionNode)
                        {
                            if (OverallTools.ExternFunctions.IsOlderThan(SavePath + Tag.Name + Tag.ExceptionName + "_Chart.png", 120)) // si le fichier a était créé il y a moins de 2 minutes on peut considérer que c'est la derniere version
                                if (OverallTools.ExternFunctions.CheckCreateDirectory(SavePath))
                                    SaveGraphique(Tag.ScenarioName, Tag.Name, Tag.ExceptionName, SavePath + Tag.Name + Tag.ExceptionName + "_Chart.png");
                            pdf.LaodImage(Node.GetHashCode() + Node.Name, SavePath + Tag.Name + Tag.ExceptionName + "_Chart.png");
                        }else if (getGraphicFilter(Tag.ScenarioName, Node.Name) != null)
                        {
                            if (OverallTools.ExternFunctions.IsOlderThan(SavePath + Node.Name + "_Chart.png", 120)) // si le fichier a était créé il y a moins de 2 minutes on peut considérer que c'est la derniere version
                                if (OverallTools.ExternFunctions.CheckCreateDirectory(SavePath))
                                    SaveGraphique(Tag.ScenarioName, Node.Name, SavePath + Node.Name + ".png");
                            pdf.LaodImage(Node.GetHashCode() + Node.Name, SavePath + Node.Name + ".png");
                        }
                    }
                }
                // Check if paragraph contains image
                else if (Tag.isParagraphNode)
                {
                    Paragraph p = getParagraph(Node.Name);
                    if (p != null)
                        pdf.LoadhtmlIMG(p.Content);
                }

                // print note
                String note = getNote(Tag.ScenarioName, Node.Name);
                if (/*parameters.ExportNote &&*/ note != null)
                {
                    pdf.LoadhtmlIMG(note);
                }
                // print Gantt Note
                String ganttNote = getGanttNote(Tag.ScenarioName, Node.Name);
                if (/*parameters.ExportNote &&*/ ganttNote != null)
                {
                    // << Task #6386 Itinerary process 
                    String completeFilePath = "";
                    int start = ganttNote.IndexOf("<img src=") + 10;
                    int end = ganttNote.IndexOf("/></BODY>") - 2;
                    if (start > 0 && end > 0)
                        completeFilePath = ganttNote.Substring(start, end - start);
                    else
                        OverallTools.ExternFunctions.PrintLogFile("GestionDonneesHUB2SIM.LoadPDFImage(...):" +
                            " Error while creating PDF Report with Gantt/ProcessFlow Image: the file path could not be determined.");
                    if (completeFilePath != "")
                    {
                        pdf.LaodImage(Node.GetHashCode() + completeFilePath, completeFilePath);
                    }
                    //pdf.LoadhtmlIMG(ganttNote);
                    // >> Task #6386 Itinerary process
                }

                // >> Task #10645 Pax2Sim - Pax analysis - Summary: dashboard image for Reports
                // print dashboard note
                String dashboardNote = getDashboardNote(Tag.ScenarioName, Node.Name);
                if (dashboardNote != null)
                {
                    // << Task #6386 Itinerary process 
                    String completeFilePath = "";
                    int start = dashboardNote.IndexOf("<img src=") + 10;
                    int end = dashboardNote.IndexOf("/></BODY>") - 2;
                    if (start > 0 && end > 0)
                        completeFilePath = dashboardNote.Substring(start, end - start);
                    else
                        OverallTools.ExternFunctions.PrintLogFile("GestionDonneesHUB2SIM.LoadPDFImage(...):" +
                            " Error while creating PDF Report with Dashboard Image: the file path could not be determined.");
                    if (completeFilePath != "")
                    {
                        pdf.LaodImage(Node.GetHashCode() + completeFilePath, completeFilePath);
                    }
                }
                // << Task #10645 Pax2Sim - Pax analysis - Summary: dashboard image for Reports

                // continue search in child nodes 
                if (Node.Nodes.Count != 0)
                {
                    LoadPDFImage(pdf, Node.Nodes, path, cht, parameters);
                }
            }
        }

        #endregion
        #endregion

        /// <summary>
        /// Cette fonction est utilisée pour faire en sorte de pouvoir charger des projets étrangers
        /// à Pax2sim. Toutes les fonctions de bases de Pax2sim sont alors déasctivées.
        /// </summary>
        /// <param name="sPath"></param>
        /// <returns></returns>
        internal static bool UpdateTables(string sPath)
        {
            //If the file does not exists. We stop return false.
            if (!System.IO.File.Exists(sPath))
            {
                return false;
            }
            XmlDocument xdDocument = new XmlDocument();
            xdDocument.Load(sPath);
            //If the file does not have any informations about the Input data.
            //We stop here.
            if (!OverallTools.FonctionUtiles.hasNamedChild(xdDocument, "Config"))
                return false;
            if (!OverallTools.FonctionUtiles.hasNamedChild(xdDocument["Config"], "Input"))
                return false;

            if (!OverallTools.FonctionUtiles.hasNamedChild(xdDocument["Config"], "Separator"))
                return false;

            List<String> lsInputTables = new List<string>();
            List<String> lsDisplayNameTables = new List<string>();
            List<List<String>> lsListeEntetes = new List<List<String>>();
            List<List<Type>> lsListeTypes = new List<List<Type>>();
            List<List<Int32>> lsListePrimary = new List<List<Int32>>();
            List<String> lsSeparator = new List<string>();
            List<Int32> lsIndexSeparator = new List<int>();

            foreach (XmlNode xnChild in xdDocument["Config"]["Input"].ChildNodes)
            {
                if (!OverallTools.FonctionUtiles.hasNamedAttribute(xnChild, "Name"))
                    continue;
                String sName = xnChild.Attributes["Name"].Value;
                lsInputTables.Add(sName);
                if (OverallTools.FonctionUtiles.hasNamedAttribute(xnChild, "DisplayName"))
                {
                    lsDisplayNameTables.Add(xnChild.Attributes["DisplayName"].Value);
                }
                else
                {
                    lsDisplayNameTables.Add(sName);
                }
                lsListeEntetes.Add(new List<string>());
                lsListeTypes.Add(new List<Type>());
                lsListePrimary.Add(new List<int>());
                foreach (XmlNode xnChild2 in xnChild.ChildNodes)
                {
                    if (xnChild2.Name == "Column")
                    {
                        if (OverallTools.FonctionUtiles.hasNamedAttribute(xnChild2, "Name") &&
                           OverallTools.FonctionUtiles.hasNamedAttribute(xnChild2, "Type"))
                        {
                            lsListeEntetes[lsListeEntetes.Count - 1].Add(xnChild2.Attributes["Name"].Value);
                            lsListeTypes[lsListeTypes.Count - 1].Add(Type.GetType(xnChild2.Attributes["Type"].Value));
                        }
                        if (OverallTools.FonctionUtiles.hasNamedAttribute(xnChild2, "Primary"))
                            lsListePrimary[lsListePrimary.Count - 1].Add(lsListeEntetes.Count - 1);
                    }
                }
            }

            String[] sNoms = new string[ListeNomTablePAX.Length + lsInputTables.Count];
            String[] sNomsComplets = new string[ListeNomTablePAX.Length + lsInputTables.Count];
            bool[] bVisible = new bool[ListeNomTablePAX.Length + lsInputTables.Count];
            bool[] bSaved = new bool[ListeNomTablePAX.Length + lsInputTables.Count];

            String[][] tsEntetes = new string[ListeNomTablePAX.Length + lsInputTables.Count][];
            Type[][] ttTypesEntetes = new Type[ListeNomTablePAX.Length + lsInputTables.Count][];
            Int32[][] tiPrimaryKey = new Int32[ListeNomTablePAX.Length + lsInputTables.Count][];
            int i;
            int iLenght = lsInputTables.Count;
            InitializeVisualisationMode();
            VisualisationMode mode = new VisualisationMode(true, true, false, null, null);
            mode.EditMode = VisualisationMode.EditModeEnum.Cell;
            for (i = 0; i < iLenght; i++)
            {
                sNoms[i] = lsInputTables[i];

                modeVisualisation.Add(sNoms[i], mode.Clone());
                sNomsComplets[i] = lsDisplayNameTables[i];
                bVisible[i] = true;
                bSaved[i] = true;
                tsEntetes[i] = new string[lsListeEntetes[i].Count];
                for (int j = 0; j < tsEntetes[i].Length; j++)
                    tsEntetes[i][j] = lsListeEntetes[i][j];
                ttTypesEntetes[i] = new Type[lsListeTypes[i].Count];
                for (int j = 0; j < ttTypesEntetes[i].Length; j++)
                    ttTypesEntetes[i][j] = lsListeTypes[i][j];
                tiPrimaryKey[i] = new int[lsListePrimary[i].Count];
                for (int j = 0; j < tiPrimaryKey[i].Length; j++)
                    tiPrimaryKey[i][j] = lsListePrimary[i][j];
            }
            for (; i < sNoms.Length; i++)
            {
                sNoms[i] = ListeNomTablePAX[i - iLenght];
                sNomsComplets[i] = ListeNomsCompletsTablesPAX[i - iLenght];
                bVisible[i] = false;// ListeTablePAXVisible[i - iLenght];
                bSaved[i] = false;//ListeTablePAXSauvegardee[i - iLenght];

                tsEntetes[i] = listeEntetes[i - iLenght];
                ttTypesEntetes[i] = listeTypeEntetes[i - iLenght];
                tiPrimaryKey[i] = listePrimaryKey[i - iLenght];
            }

            ListeNomTablePAX = sNoms;
            ListeNomsCompletsTablesPAX = sNomsComplets;
            ListeTablePAXVisible = bVisible;
            ListeTablePAXSauvegardee = bSaved;
            listeEntetes = tsEntetes;
            listeTypeEntetes = ttTypesEntetes;
            listePrimaryKey = tiPrimaryKey;



            foreach (XmlNode xnChild in xdDocument["Config"]["Separator"].ChildNodes)
            {
                if ((!OverallTools.FonctionUtiles.hasNamedAttribute(xnChild, "Name")) ||
                    (!OverallTools.FonctionUtiles.hasNamedAttribute(xnChild, "Number")))
                    continue;
                lsSeparator.Add(xnChild.Attributes["Name"].Value);
                int iTmp = 0;
                Int32.TryParse(xnChild.Attributes["Number"].Value, out iTmp);
                lsIndexSeparator.Add(iTmp);
            }

            ListeSeparation = new int[lsSeparator.Count + 1];
            ListeNomsSeparation = new string[lsSeparator.Count + 1];
            ListeNomsCompletsSeparation = new string[lsSeparator.Count + 1];


            iLenght = lsSeparator.Count;
            for (i = 0; i < iLenght; i++)
            {
                ListeSeparation[i] = lsIndexSeparator[i];
                ListeNomsSeparation[i] = lsSeparator[i];
                ListeNomsCompletsSeparation[i] = lsSeparator[i];
            }
            ListeSeparation[i] = -1;
            ListeNomsSeparation[i] = "User Data";
            ListeNomsCompletsSeparation[i] = "User Data";



            if (OverallTools.FonctionUtiles.hasNamedChild(xdDocument["Config"], "Output"))
            {
                //We gonna set the imported tables after simulation.
                lsOutputTables = new List<string>();
                lsOutputTablesPath = new List<string>();
                List<List<String>> lsOutputListeEntetes = new List<List<String>>();
                List<List<Type>> lsOutputListeTypes = new List<List<Type>>();
                List<List<Int32>> lsOutputListePrimary = new List<List<Int32>>();

                lccot_OutputConversion = new List<List<ConvertTables.ConvertColumnOutputTables>>();

                foreach (XmlNode xnChild in xdDocument["Config"]["Output"].ChildNodes)
                {
                    if (!OverallTools.FonctionUtiles.hasNamedAttribute(xnChild, "Name"))
                        continue;
                    if (!OverallTools.FonctionUtiles.hasNamedAttribute(xnChild, "OutputName"))
                        continue;

                    lsOutputTables.Add(xnChild.Attributes["Name"].Value);
                    lsOutputTablesPath.Add(xnChild.Attributes["OutputName"].Value);
                    lsOutputListeEntetes.Add(new List<string>());
                    lsOutputListeTypes.Add(new List<Type>());
                    lsOutputListePrimary.Add(new List<int>());

                    lccot_OutputConversion.Add(new List<ConvertTables.ConvertColumnOutputTables>());
                    foreach (XmlNode xnChild2 in xnChild.ChildNodes)
                    {
                        if (xnChild2.Name == "Column")
                        {
                            if (OverallTools.FonctionUtiles.hasNamedAttribute(xnChild2, "Name") &&
                               OverallTools.FonctionUtiles.hasNamedAttribute(xnChild2, "Type"))
                            {
                                String sNameColumn = xnChild2.Attributes["Name"].Value;
                                Type tType = Type.GetType(xnChild2.Attributes["Type"].Value);
                                lsOutputListeEntetes[lsOutputListeEntetes.Count - 1].Add(sNameColumn);
                                lsOutputListeTypes[lsOutputListeTypes.Count - 1].Add(tType);
                                if (OverallTools.FonctionUtiles.hasNamedAttribute(xnChild2, "Primary"))
                                    lsOutputListePrimary[lsOutputListePrimary.Count - 1].Add(lsListeEntetes.Count - 1);
                                if (OverallTools.FonctionUtiles.hasNamedAttribute(xnChild2, "ImportationType"))
                                {
                                    String sUnit = null;
                                    if (OverallTools.FonctionUtiles.hasNamedAttribute(xnChild2, "ImportationUnit"))
                                        sUnit = xnChild2.Attributes["ImportationUnit"].Value;
                                    lccot_OutputConversion[lccot_OutputConversion.Count - 1].Add(new ConvertTables.ConvertColumnOutputTables(sNameColumn, Type.GetType(xnChild2.Attributes["ImportationType"].Value), tType, sUnit));
                                }
                            }
                            else
                            {
                            }

                        }
                    }
                }
                /*SGE 21.01.2011*/
                ltsOutputColumns = new List<string[]>();
                ltsOutputTypeColumns = new List<Type[]>();
                ltiOutputPrimaryKey = new List<int[]>();


                for (i = 0; i < lsOutputTables.Count; i++)
                {
                    ltsOutputColumns.Add(new string[lsOutputListeEntetes[i].Count]);
                    for (int j = 0; j < lsOutputListeEntetes[i].Count; j++)
                        ltsOutputColumns[i][j] = lsOutputListeEntetes[i][j];

                    ltsOutputTypeColumns.Add(new Type[lsOutputListeTypes[i].Count]);
                    for (int j = 0; j < lsOutputListeTypes[i].Count; j++)
                        ltsOutputTypeColumns[i][j] = lsOutputListeTypes[i][j];

                    ltiOutputPrimaryKey.Add(new int[lsOutputListePrimary[i].Count]);
                    for (int j = 0; j < lsOutputListePrimary[i].Count; j++)
                        ltiOutputPrimaryKey[i][j] = lsOutputListePrimary[i][j];
                }
            }
            return true;
        }

        /// <summary>
        /// Fonction utilisée pour la partie SimReporter.
        /// </summary>
        /// <returns></returns>
        internal List<string> getShowTable()
        {
            List<String> lsResult = new List<string>();
            for (int i = 0; i < ListeNomTablePAX.Length; i++)
            {
                if (ListeTablePAXSauvegardee[i])
                    lsResult.Add(ListeNomTablePAX[i]);
            }
            return lsResult;
        }

        /// <summary>
        /// Fonction qui permet de mettre à jour l'arborescence visuelle qui doit être affichée pour le dossier Input.
        /// </summary>
        /// <param name="tnRoot"></param>
        /// <param name="cmsTableContextMenu"></param>
        internal static void UpdateInputTreeNode(TreeNode tnRoot, ContextMenuStrip cmsTableContextMenu)
        {
            DataManagerInput.UpdateTreeNode(tnRoot,cmsTableContextMenu);
        }
    
        // >> Task #10764 Pax2Sim - new User attributes for Groups
        public List<String> getAllTerminalNbGroupNbPairsByGroupType(String groupType)
        {
            List<String> paxTerminalAndGroupNumbersList = new List<String>();

            string[] terminalsList = getTerminal();
            foreach (String terminal in terminalsList)
            {
                int terminalNb = getTerminalNbFromTerminalName(terminal);
                if (terminalNb != -1)
                {
                    XmlNode[] groupsList = getGroup(structureAeroport, terminalNb, groupType);
                    if (groupsList != null)
                    {
                        foreach (XmlNode groupNode in groupsList)
                        {
                            if (groupNode.ChildNodes == null)
                            {
                                OverallTools.ExternFunctions.PrintLogFile("The group " + groupNode.Name + " doesn't have desks.");
                                continue;
                            }

                            foreach (XmlNode deskNode in groupNode.ChildNodes)
                            {
                                int currentGroupNb = -1;
                                int currentDeskNb = -1;

                                if (Int32.TryParse(groupNode.Attributes["Index"].Value, out currentGroupNb)
                                    && Int32.TryParse(deskNode.Attributes["Index"].Value, out currentDeskNb))
                                {
                                    String terminalNbGroupNbLabel = terminalNb + "_" + currentGroupNb;
                                    if (!paxTerminalAndGroupNumbersList.Contains(terminalNbGroupNbLabel))
                                    {
                                        paxTerminalAndGroupNumbersList.Add(terminalNbGroupNbLabel);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return paxTerminalAndGroupNumbersList;
        }

        private int getTerminalNbFromTerminalName(String terminalName)
        {
            int terminalNb = -1;
            int parsingStart = -1;
            int parsingLength = -1;

            if (UseAlphaNumericForFlightInfo)
            {
                parsingStart = terminalName.IndexOf("(") + 1;
                parsingLength = terminalName.IndexOf(":") - parsingStart;
            }
            else
            {
                parsingStart = 0;
                parsingLength = 1;
            }

            if (parsingStart != -1 && parsingLength != -1)
            {
                Int32.TryParse(terminalName.Substring(parsingStart, parsingLength), out terminalNb);
            }
            return terminalNb;
        }

        public String getTerminalNbGroupNbLabelByGroupType(String groupType, DataRow flightPlanRow)
        {
            String terminalNbGroupNbLabel = "";
            
            int terminalColumnIndex = -1;
            int deskColumnIndex = -1;

            int terminalNb = -1;
            int deskNb = -1;
            int groupNb = -1;

            if (groupType.Equals(GlobalNames.RECLAIM_GROUP_TYPE))
            {
                terminalColumnIndex = flightPlanRow.Table.Columns.IndexOf(GlobalNames.sFPA_Column_TerminalReclaim);
                deskColumnIndex = flightPlanRow.Table.Columns.IndexOf(GlobalNames.sFPA_Column_ReclaimObject);
            }
            else if (groupType.Equals(GlobalNames.BOARDING_GATE_GROUP_TYPE))
            {
                terminalColumnIndex = flightPlanRow.Table.Columns.IndexOf(GlobalNames.sFPD_A_Column_TerminalGate);
                deskColumnIndex = flightPlanRow.Table.Columns.IndexOf(GlobalNames.sFPD_Column_BoardingGate);
            }

            if (terminalColumnIndex != -1 && deskColumnIndex != -1)
            {
                if (Int32.TryParse(flightPlanRow[terminalColumnIndex].ToString(), out terminalNb)
                    && Int32.TryParse(flightPlanRow[deskColumnIndex].ToString(), out deskNb))
                {
                    groupNb = getGroupNbByTerminalNbDeskNbAndGroupType(terminalNb, deskNb, groupType);
                    if (groupNb == -1)
                    {
                        OverallTools.ExternFunctions.PrintLogFile("Error while getting the terminalNb_groupNb from the Flight Plans. "
                                                                + "Please check the airport structure.");
                    }
                }
                else
                {
                    OverallTools.ExternFunctions.PrintLogFile("Error while getting the terminalNb_groupNb from the Flight Plans. "
                                                                + "Could not parse the terminal or group from the Flight Plans.");
                }
            }

            if (terminalNb != -1 && groupNb != -1)
            {
                terminalNbGroupNbLabel = terminalNb + "_" + groupNb;
            }

            return terminalNbGroupNbLabel;
        }

        public Dictionary<String, List<String>> getFlightsAndListOfPaxGroupsDictionary()
        {
            Dictionary<String, List<String>> flightsAndListOfPaxGroupsDictionary = new Dictionary<String, List<String>>();
            DataTable arrivalFlightPlan = getTable("Input", GlobalNames.FPATableName);
            DataTable departureFlightPlan = getTable("Input", GlobalNames.FPDTableName);

            if (arrivalFlightPlan != null && departureFlightPlan != null)
            {
                #region column indexes
                int fpaFlightIdColumnIndex = arrivalFlightPlan.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID);
                int fpaReclaimTerminalColumnIndex = arrivalFlightPlan.Columns.IndexOf(GlobalNames.sFPA_Column_TerminalReclaim);
                int fpaReclaimDeskColumnIndex = arrivalFlightPlan.Columns.IndexOf(GlobalNames.sFPA_Column_ReclaimObject);
                int fpaTransferInfeedTerminalColumnIndex = arrivalFlightPlan.Columns.IndexOf(GlobalNames.sFPA_Column_TerminalInfeedObject);
                int fpaTransferInfeedDeskColumnIndex = arrivalFlightPlan.Columns.IndexOf(GlobalNames.sFPA_Column_TransferInfeedObject);

                int fpdFlightIdColumnIndex = departureFlightPlan.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID);
                int fpdCheckInTerminalColumnIndex = departureFlightPlan.Columns.IndexOf(GlobalNames.sFPD_Column_TerminalCI);
                int fdpEcoCheckInStartDeskColumnIndex = departureFlightPlan.Columns.IndexOf(GlobalNames.sFPD_Column_Eco_CI_Start);
                int fpdEcoCheckInEndDeskColumnIndex = departureFlightPlan.Columns.IndexOf(GlobalNames.sFPD_Column_Eco_CI_End);
                int fdpFBCheckInStartDeskColumnIndex = departureFlightPlan.Columns.IndexOf(GlobalNames.sFPD_Column_FB_CI_Start);
                int fpdFBCheckInEndDeskColumnIndex = departureFlightPlan.Columns.IndexOf(GlobalNames.sFPD_Column_FB_CI_End);
                int fpdBoardingGateTerminalColumnIndex = departureFlightPlan.Columns.IndexOf(GlobalNames.sFPD_A_Column_TerminalGate);
                int fpdBoardingGateDeskColumnIndex = departureFlightPlan.Columns.IndexOf(GlobalNames.sFPD_Column_BoardingGate);

                List<int> arrivalFlightPlanColumnIndexes
                    = new List<int>(new int[] { fpaFlightIdColumnIndex,
                                                fpaReclaimTerminalColumnIndex, fpaReclaimDeskColumnIndex,
                                                fpaTransferInfeedTerminalColumnIndex, fpaTransferInfeedDeskColumnIndex, 
                                                });
                List<int> departureFlightPlanColumnIndexes
                    = new List<int>(new int[] { fpdFlightIdColumnIndex,
                                                fpdCheckInTerminalColumnIndex, 
                                                fdpEcoCheckInStartDeskColumnIndex, fpdEcoCheckInEndDeskColumnIndex,
                                                fdpFBCheckInStartDeskColumnIndex, fpdFBCheckInEndDeskColumnIndex,
                                                fpdBoardingGateTerminalColumnIndex, fpdBoardingGateDeskColumnIndex});
                #endregion

                if (columnIndexesAreValid(arrivalFlightPlanColumnIndexes))
                {
                    foreach (DataRow row in arrivalFlightPlan.Rows)
                    {
                        int flightId = -1;
                        int reclaimTerminalNb = -1;
                        int reclaimDeskNb = -1;
                        int transferInfeedTerminalNn = -1;
                        int transferInfeedDeskNb = -1;

                        if (Int32.TryParse(row[fpaFlightIdColumnIndex].ToString(), out flightId)
                            && Int32.TryParse(row[fpaReclaimTerminalColumnIndex].ToString(), out reclaimTerminalNb)
                            && Int32.TryParse(row[fpaReclaimDeskColumnIndex].ToString(), out reclaimDeskNb)
                            && Int32.TryParse(row[fpaTransferInfeedTerminalColumnIndex].ToString(), out transferInfeedTerminalNn)
                            && Int32.TryParse(row[fpaTransferInfeedDeskColumnIndex].ToString(), out transferInfeedDeskNb))
                        {

                            int reclaimGroupNb = getGroupNbByTerminalNbDeskNbAndGroupType(reclaimTerminalNb, reclaimDeskNb, GlobalNames.RECLAIM_GROUP_TYPE);
                            if (reclaimGroupNb != -1)
                            {
                                String flightIdLabel = "A_" + flightId;
                                String groupAndDeskNb = reclaimGroupNb + "_" + reclaimDeskNb;
                            }
                        }
                    }
                }
            }            

            return flightsAndListOfPaxGroupsDictionary;
        }

        private bool columnIndexesAreValid(List<int> columnIndexes)
        {
            foreach (int columnIndex in columnIndexes)
            {
                if (columnIndex == -1)
                {
                    return false;
                }
            }
            return true;
        }

        private int getGroupNbByTerminalNbDeskNbAndGroupType(int terminalNb, int deskNb, String groupType)
        {
            int groupNb = -1;

            XmlNode[] groupsList = getGroup(structureAeroport, terminalNb, groupType);
            if (groupsList == null)
            {
                return groupNb;
            }
            foreach (XmlNode groupNode in groupsList)
            {
                if (groupNode.ChildNodes == null)
                {
                    OverallTools.ExternFunctions.PrintLogFile("Error while retrieveing the group number for a given desk. The group doesn't have desks.");
                    return groupNb;
                }

                foreach (XmlNode deskNode in groupNode.ChildNodes)
                {
                    int currentGroupNb = -1;
                    int currentDeskNb = -1;                    

                    if (Int32.TryParse(groupNode.Attributes["Index"].Value, out currentGroupNb)
                        && Int32.TryParse(deskNode.Attributes["Index"].Value, out currentDeskNb))
                    {
                        if (currentDeskNb == deskNb)
                        {
                            return currentGroupNb;
                        }
                    }
                }
            }

            return groupNb;
        }
        // << Task #10764 Pax2Sim - new User attributes for Groups
    }
    #endregion
}
