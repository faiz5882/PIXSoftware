//  #define UNIKEY_PROTECTION
#define PARKINGMULHOUSE
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Data;
using System.Collections;
using System.Windows.Forms;
using System.Drawing.Drawing2D;
//Pour l'utilisation des DLL permettant l'interrogation pour la protection.
using System.Runtime.InteropServices;
using System.IO;
using System.Reflection;
using System.Diagnostics;
using System.Management;
using Microsoft.Win32;
using System.Security.Cryptography;
using System.Xml;
using SIMCORE_TOOL.Classes;
using System.Text.RegularExpressions;
using SIMCORE_TOOL.DataManagement;
using SIMCORE_TOOL.Prompt.Vinci;
using SIMCORE_TOOL.Prompt;
using System.Linq;
using System.Security.Principal;
using SIMCORE_TOOL.com.crispico.BHS_Analysis;
using SIMCORE_TOOL.com.crispico.EBS;
using SIMCORE_TOOL.com.crispico.dashboard;
using SIMCORE_TOOL.com.crispico.BHS_Analysis.bhsTrace;
using SIMCORE_TOOL.com.crispico.FlightPlansUtils;
using SIMCORE_TOOL.com.crispico.inputs.deterministic_transfer_distribution;
using SIMCORE_TOOL.com.crispico.inputs.flight_group_rules;

namespace SIMCORE_TOOL
{
    public static class OverallTools
    {
        #region UNIKEY_PROTECTION
#if (UNIKEY_PROTECTION)
        internal class Unikey
        {
        #region Constantes
            // error codes
            const long SUCCESS = 0;					//Success
            const long ERROR_UNIKEY_NOT_FOUND = 200;	//No UniKey dongle
            const long ERROR_UNIKEY_INVALID_PASSWORD = 201;	//Found UniKey dongle, but basic password is wrong
            const long ERROR_UNIKEY_INVALID_PASSWORD_OR_ID = 202;	//Wrong password or UniKey HID
            const long ERROR_UNIKEY_SET_SOFTID_FAILED = 203;	//Set UniKey ID failed
            const long ERROR_INVALID_ADDR_OR_SIZE = 204;	//Read/Write address or length is wrong
            const long ERROR_UNIKEY_UNKNOWN_COMMAND = 205;	//No such command
            const long ERROR_UNIKEY_READ_MEMORY = 207;	//Read memory failed
            const long ERROR_UNIKEY_WRITE_MEMORY = 208;	//Write memory failed
            const long ERROR_UNIKEY_RANDOM = 209;	//Random number failed
            const long ERROR_UNIKEY_SEED = 210;	//Get seed code failed
            const long ERROR_UNIKEY_CALCULATE = 211;	//Calculate failed
            const long ERROR_UNIKEY_NEED_OPEN = 212;	//Need open dongle before operating dongle
            const long ERROR_UNIKEY_OPEN_OVERFLOW = 213;	//Too many open dongles (>16)
            const long ERROR_UNIKEY_NOMORE = 214;	//No more dongle
            const long ERROR_UNIKEY_UNIKEYNEED_FIND = 215;	//No Find before FindNext
            const long ERROR_UNIKEY_MODULE = 216;	//License module error
            const long ERROR_UNIKEY_AR_BAD_COMMAND = 217;	//Arithmetic instruction Error
            const long ERROR_UNIKEY_AR_UNKNOWN_OPCODE = 218;	//Arithmetic operator Error
            const long ERROR_UNIKEY_AR_WRON_GBEGIN = 219;	//Const number can't use on first arithmetic instruction
            const long ERROR_UNIKEY_AR_WRONG_END = 220;	//Const number can't use on last arithmetic instruction
            const long ERROR_UNIKEY_AR_VALUE_OVERFLOW = 221;	//Const number > 63
            const long ERROR_UNIKEY_INVALID_KEY = 222;	//The key in the key storage is wrong
            const long ERROR_UNIKEY_VERIFY_ADV_PASSWORD = 223;	//Advanced passwords (password3 and passowrd4) not verified
            const long ERROR_UNIKEY_INVALID_KEY_STORE = 224;	//Wrong key storage number
            const long ERROR_UNIKEY_GENERATE_NEW_PASSWORD = 225;	//Generate new password failed
            const long ERROR_UNIKEY_READ_UPDATETAG = 226;	//Read UpdateTag failed
            const long ERROR_UNIKEY_WRITE_UPDATETAG = 227;	//Write UpdateTag failed
            const long ERROR_UNIKEY_ENCRYPT_FAILED = 228;	//Encrypt data failed
            const long ERROR_UNIKEY_DECRYPT_FAILED = 229;	//Decrypt datafailed
            const long ERROR_UNIKEY_READ_TIME = 230;	//Get UniKey time failed
            const long ERROR_UNIKEY_WRITE_TIME = 231;	//Set UniKey time failed
            const long ERROR_UNIKEY_WRITE_TIME_MODULE = 232;	//Write time module error
            const long ERROR_UNIKEY_COMPARE_TIME_MODULE = 233;	//The specific time is before the module’s start time
            const long ERROR_UNIKEY_TIME_MODULE_NOT_NULL = 234;	//The real time module is not null, this error is returned when write once flag is set
            const long ERROR_UNIKEY_TIME_MODULE_OVERDUR = 235;	//The specific time is later than the module’s end time, or the module is expired
            const long ERROR_UNIKEY_ALREADY_LOCKED = 236;	//Dongle Already Locked (when lock twice or open after lock)
            // NetUniKey Error Code
            const long NET_UNIEKY_ERROR_BASE = 100;							// net unikey error base
            const long NET_UNIKEY_MEMORY_ERROR = NET_UNIEKY_ERROR_BASE + 1;		// memory allocation error
            const long NET_UNIKEY_SEND_ERROR = NET_UNIEKY_ERROR_BASE + 2;		// send error
            const long NET_UNIKEY_RECEIVE_ERROR = NET_UNIEKY_ERROR_BASE + 3;		// receive error
            const long NET_UNIKEY_MESSAGE_WRONG = NET_UNIEKY_ERROR_BASE + 4;		// communication message is modified
            const long NET_UNIKEY_SETUP_SOCKET_ERROR = NET_UNIEKY_ERROR_BASE + 5;		// setup socket error
            const long NET_UNIKEY_CLIENT_EXSIT = NET_UNIEKY_ERROR_BASE + 6;		// the client already exists, per this mode
            const long NET_UNIKEY_TOO_MANY_CLIENT = NET_UNIEKY_ERROR_BASE + 7;		// the number of client reach the limitation
            const long NET_UNIKEY_IN_BLACKLIST = NET_UNIEKY_ERROR_BASE + 8;		// the client is in the black list
            const long NET_UNIKEY_OUT_WHITELIST = NET_UNIEKY_ERROR_BASE + 9;		// the client is not in the white list
            const long NET_UNIKEY_MESSAGE_CHANGE = NET_UNIEKY_ERROR_BASE + 10;	// the message packet was changed
            const long NET_UNIKEY_AREADY_START = NET_UNIEKY_ERROR_BASE + 11;	// the server has already started
            const long NET_UNIKEY_SOCKET_INIT_FAILED = NET_UNIEKY_ERROR_BASE + 12;	// cannot initialize the socket
            const long NET_UNIKEY_SOCKET_BIND_FAILED = NET_UNIEKY_ERROR_BASE + 13;	// cannot bind the port with the socket
            const long NET_UNIKEY_SOCKET_LISTEN_FAILED = NET_UNIEKY_ERROR_BASE + 14;	// cannot start listening with the socket
            const long NET_UNIKEY_START_UDP_SERVER_FAILED = NET_UNIEKY_ERROR_BASE + 15;	// start udp server failed
            const long NET_UNIKEY_TOO_LONG_MESSAGE = NET_UNIEKY_ERROR_BASE + 16;	// too long message
            const long NET_UNIKEY_NOT_WORKING = NET_UNIEKY_ERROR_BASE + 17;	// cannot connect remote netunikey server	
            const long NET_UNIKEY_DISCARD_BY_SERVER = NET_UNIEKY_ERROR_BASE + 18;	// the client is discarded by the server

            // declare function 
            [DllImport("UniKey")]
            public static extern uint UniKey_Find(ref ushort pHandle, ref uint pPassword1, ref uint pPassword2);
            [DllImport("UniKey")]
            public static extern uint UniKey_Find_Next(ref ushort pHandle, ref uint pPassword1, ref uint pPassword2);
            [DllImport("UniKey")]
            public static extern uint UniKey_Lock(ref ushort pHandle);
            [DllImport("UniKey")]
            public static extern uint UniKey_UnLock(ref ushort pHandle);
            [DllImport("UniKey")]
            public static extern uint UniKey_User_Logon(ref ushort pHandle, ref ushort pPassword1, ref ushort pPassword2);
            [DllImport("UniKey")]
            public static extern uint UniKey_Vender_Logon(ref ushort pHandle, ref ushort pPassword1, ref ushort pPassword2, ref ushort pPassword3, ref ushort pPassword4);
            [DllImport("UniKey")]
            public static extern uint UniKey_Logoff(ref ushort pHandle);
            [DllImport("UniKey")]
            public static extern uint UniKey_Read_Memory(ref ushort pHandle, ref ushort pStartAddress, ref ushort pBufferLength, Byte[] pBuffer);
            [DllImport("UniKey")]
            public static extern uint UniKey_Write_Memory(ref ushort pHandle, ref ushort pStartAddress, ref ushort pBufferLength, Byte[] pBuffer);
            [DllImport("UniKey")]
            public static extern uint UniKey_Random(ref ushort pHandle, ref ushort pReturn1, ref ushort pReturn2, ref ushort pReturn3, ref ushort pReturn4);
            [DllImport("UniKey")]
            public static extern uint UniKey_Seed(ref ushort pHandle, ref uint pSeed, ref ushort pReturn1, ref ushort pReturn2, ref ushort pReturn3, ref ushort pReturn4);
            [DllImport("UniKey")]
            public static extern uint UniKey_Write_SoftID(ref ushort pHandle, ref uint pSoftID);
            [DllImport("UniKey")]
            public static extern uint UniKey_Read_SoftID(ref ushort pHandle, ref uint pSoftID);
            [DllImport("UniKey")]
            public static extern uint UniKey_Set_Module(ref ushort pHandle, ref ushort pModule, ref ushort pValue, ref ushort pDecrease);
            [DllImport("UniKey")]
            public static extern uint UniKey_Check_Module(ref ushort pHandle, ref ushort pModule, ref ushort pValue, ref ushort pDecrease);
            [DllImport("UniKey")]
            public static extern uint UniKey_Write_Arithmetic(ref ushort pHandle, ref ushort pStartAddress, Byte[] pBuffer);
            [DllImport("UniKey")]
            public static extern uint UniKey_Calculate1(ref ushort pHandle, ref uint lp1, ref uint lp2, ref ushort p1, ref ushort p2, ref ushort p3, ref ushort p4); //start, seed, register
            [DllImport("UniKey")]
            public static extern uint UniKey_Calculate2(ref ushort pHandle, ref uint lp1, ref uint lp2, ref ushort p1, ref ushort p2, ref ushort p3, ref ushort p4);
            [DllImport("UniKey")]
            public static extern uint UniKey_Calculate3(ref ushort pHandle, ref uint lp1, ref uint lp2, ref ushort p1, ref ushort p2, ref ushort p3, ref ushort p4);
            [DllImport("UniKey")]
            public static extern uint UniKey_Module_Decrase(ref ushort pHandle, ref ushort p1);
            [DllImport("UniKey")]
            public static extern uint UniKey_Generate_New_Password(ref ushort pHandle, ref uint pSeed1, ref ushort pPassword1, ref ushort pPassword2, ref ushort pPassword3, ref ushort pPassword4);
            [DllImport("UniKey")]
            public static extern uint UniKey_Generate_Key(ref ushort pHandle, ref uint pKeyNumber);
            [DllImport("UniKey")]
            public static extern uint UniKey_Encrypt(ref ushort pHandle, ref uint pKeyNumber, ref uint pBufferLength, Byte[] pBuffer);
            [DllImport("UniKey")]
            public static extern uint UniKey_Decrypt(ref ushort pHandle, ref uint pKeyNumber, ref uint pBufferLength, Byte[] pBuffer);
            [DllImport("UniKey")]
            public static extern uint UniKey_MD5(ref ushort pHandle, ref uint pBufferLength, Byte[] pBuffer);
            [DllImport("UniKey")]
            public static extern uint UniKey_Write_UpdateTag(ref ushort pHandle, ref uint pUpdateTag);
            [DllImport("UniKey")]
            public static extern uint UniKey_Read_UpdateTag(ref ushort pHandle, ref uint pUpdateTag);
            [DllImport("UniKey")]
            public static extern uint UniKey_Set_Time(ref ushort pHandle, ref uint pYear, ref uint pMonth, ref ushort pDay, ref ushort pHour, ref ushort pMinute, ref ushort pSecond);
            [DllImport("UniKey")]
            public static extern uint UniKey_Set_Time_Now(ref ushort pHandle);
            [DllImport("UniKey")]
            public static extern uint UniKey_Get_Time(ref ushort pHandle, ref uint pYear, ref uint pMonth, ref ushort pDay, ref ushort pHour, ref ushort pMinute, ref ushort pSecond);
            [DllImport("UniKey")]
            public static extern uint UniKey_Erase_Time_Module(ref ushort pHandle, ref uint pModule);
            [DllImport("UniKey")]
            public static extern uint UniKey_Set_Time_Module_Start_Time(ref ushort pHandle, ref uint pModule, ref ushort pYear, ref ushort pMonth, ref ushort pDay, ref ushort pHour);
            [DllImport("UniKey")]
            public static extern uint UniKey_Set_Time_Module_Start_Time_Now(ref ushort pHandle, ref uint pModule);
            [DllImport("UniKey")]
            public static extern uint UniKey_Set_Time_Module_Start_Time_Now_PC(ref ushort pHandle, ref uint pModule);
            [DllImport("UniKey")]
            public static extern uint UniKey_Set_Time_Module_End_Time(ref ushort pHandle, ref uint pModule, ref ushort pYear, ref ushort pMonth, ref ushort pDay, ref ushort pHour);
            [DllImport("UniKey")]
            public static extern uint UniKey_Set_Time_Module_Duration(ref ushort pHandle, ref uint pModule, ref uint pDays, ref ushort pHours);
            [DllImport("UniKey")]
            public static extern uint UniKey_Check_Time_Module(ref ushort pHandle, ref uint pModule, ref uint lp2, ref ushort pYear, ref ushort pMonth, ref ushort pDay, ref ushort pHour);
            [DllImport("UniKey")]
            public static extern uint UniKey_Check_Time_Module_Now(ref ushort pHandle, ref uint pModule, ref uint lp2, ref ushort p1);
            [DllImport("UniKey")]
            public static extern uint UniKey_Check_Time_Module_Now_PC(ref ushort pHandle, ref uint pModule, ref  uint lp2, ref ushort p1);
            [DllImport("UniKey")]
            public static extern uint UniKey_Get_Version(ref ushort pHandle, ref uint lp1);


            //Custom Messages
            const int HARDWAREKEY_SUCCESSFUL_AUTHENTIFICATION = 1;
            const int HARDWAREKEY_BAD_PARAMETERS = 0;

            const int HARDWAREKEY_NOT_FOUND = -1;
            const int HARDWAREKEY_UNVALID_LOGON = -2;
            const int HARDWAREKEY_EXPIRED = -3;
            const int HARDWAREKEY_MD5_FAILED_WRITE = -4;
            const int HARDWAREKEY_MD5_FAILED_READ = -5;
            const int HARDWAREKEY_ENCRYPT_FAILED_WRITE = -6;
            const int HARDWAREKEY_ENCRYPT_FAILED_READ = -7;
            const int HARDWAREKEY_WRITE_MEMORY_FAILED = -8;
            const int HARDWAREKEY_READ_MEMORY_FAILED = -9;
            const int HARDWAREKEY_NOT_ORIGINAL_HARDWARE = -10;
            const int HARDWAREKEY_CALCULATE = -11;
            const int HARDWAREKEY_RANDOM_FUNCTION = -12;
            const int HARDWAREKEY_NOT_ORIGINAL = -13;
            const int HARDWAREKEY_READ_MEMORY = -14;
            /*Used only on the Automod Model*/
            const int HARDWAREKEY_DYNAMIC = -15;
            const int HARDWAREKEY_UNABLE_READ_INFORMATIONS = -16;

            const int HARDWAREKEY_CONFIGURATION_POSITION = 34;
        #endregion



            //Test la validité de la date sur la clef.
            static int TestDate(ushort ptHandle, ushort p1)
            {
                uint retcode;
                uint lp1, lp2 = 0;
                Byte[] buffer = new byte[4096];
                // ***********************************************************************
                // Section Une, opération réalisée au démarrage de l'application
                //1. Contrôle la date d’expiration
                // ***********************************************************************
                // Vérifie si le module est valide
                lp1 = 1; // numéro de module temps réel
                retcode = UniKey_Check_Time_Module_Now(ref ptHandle, ref lp1, ref lp2, ref p1);
                if (retcode != SUCCESS)
                {
                    //Le logiciel a expiré, nous devons arrêter le logiciel maintenant
                    return HARDWAREKEY_EXPIRED;
                }
                return 0;
            }

            //Teste le calcul arithémtique.
            static int TestCode(ushort ptHandle/*, uint p1*/)
            {
                return HARDWAREKEY_SUCCESSFUL_AUTHENTIFICATION;/*
	uint p1, p2, p3, p4, valCal1,valCal2,CalVal1,CalVal2,CalVal3,CalVal4,function;
    ushort lp1, lp2, lp3, lp4;
    Byte[] buffer = new byte[4096];
    uint retcode;

	function=UNIKEY_RANDOM;
	lp1=1000;
	lp2=1101;
	lp3=5002;
	lp4=603;
	p3=5;
	p4=8;

	retcode = UniKey_Random(ref ptHandle,ref lp1, ref lp2, ref lp3, ref lp4);
	if (retcode != SUCCESS)
	{	return HARDWAREKEY_RANDOM_FUNCTION;	}
    CalVal1 = lp1;
    retcode = UniKey_Random(ref ptHandle, ref lp1, ref lp2, ref lp3, ref lp4);
	if (retcode != SUCCESS)
	{	return HARDWAREKEY_RANDOM_FUNCTION;	}
    CalVal2 = lp1;
    retcode = UniKey_Random(ref ptHandle, ref lp1, ref lp2, ref lp3, ref lp4);
	if (retcode != SUCCESS)
	{	return HARDWAREKEY_RANDOM_FUNCTION;	}				
	CalVal3=p1;
	retcode = UniKey(function,&ptHandle, &lp1, &lp2, &p1, &p2, &p3, &p4, buffer);
	if (retcode != SUCCESS)
	{	return HARDWAREKEY_RANDOM_FUNCTION;	}				
	CalVal4=p1;

	lp1 = 0;
	lp2 = 7;
	p1 = CalVal1;
	p2 = CalVal2;
	p3 = CalVal3;
	p4 = CalVal4;
	retcode = UniKey(UNIKEY_CALCULATE1, &ptHandle, &lp1, &lp2, &p1, &p2, &p3, &p4, buffer);
	if (retcode != SUCCESS)
	{	return HARDWAREKEY_CALCULATE;	}				
	valCal1=p1;
	lp1 = 10;
	lp2 = 7;
	p1 = CalVal1;
	p2 = CalVal2;
	p3 = CalVal3;
	p4 = CalVal4;
	retcode = UniKey(UNIKEY_CALCULATE1, &ptHandle, &lp1, &lp2, &p1, &p2, &p3, &p4, buffer);
	if (retcode != SUCCESS)
	{	return HARDWAREKEY_CALCULATE;	}				
	lp1 = 17;
	lp2 = 7;
	p1 = p1;
	p2 = p2;
	p3 = p3;
	p4 = p4;
	retcode = UniKey(UNIKEY_CALCULATE1, &ptHandle, &lp1, &lp2, &p1, &p2, &p3, &p4, buffer);
	valCal2=p1;
	if (retcode != SUCCESS)
	{	return HARDWAREKEY_CALCULATE;	}				
	lp1 = 27;
	lp2 = 7;
	p1 = valCal1;
	p2 = valCal1;
	p3 = valCal2;
	p4 = valCal2;
	retcode = UniKey(UNIKEY_CALCULATE1, &ptHandle, &lp1, &lp2, &p1, &p2, &p3, &p4, buffer);
	if (retcode != SUCCESS)
	{	return HARDWAREKEY_CALCULATE;	}				

 	if ( ! CheckSN(p1,p2,p3,p4) )
	{
		return HARDWAREKEY_NOT_ORIGINAL;	
	}
	else
	{ return HARDWAREKEY_SUCCESSFUL_AUTHENTIFICATION;	}
    */
            }

            static Byte[] getConfigurationMode(ushort ptHandle, int iIndexInfo)
            {
                long retcode;
                ushort lp1, lp2;
                Byte[] buffer = new byte[4096];
                Byte[] bResult = new byte[32];
                if ((iIndexInfo < 0) || iIndexInfo >= 32)
                    return null;

                // Lit la valeur chiffrée dans UniKey
                lp1 = HARDWAREKEY_CONFIGURATION_POSITION;
                lp2 = 32;

                // read dongle memory
                retcode = UniKey_Read_Memory(ref ptHandle, ref lp1, ref lp2, bResult);
                if (retcode != 0)
                {
                    return null;
                }
                return bResult;
            }

            static internal int TestDongle(int iWriteOnDongle, out Byte[] bResult)
            {
                ushort handle = 0;
                uint p1, p2;
                uint retcode = 0;
                int iErreur = 2;
                ushort lp1, lp2;
                Byte[] buffer = new Byte[4096];
                bResult = null;
                int i = 0;

                /**/

                p1 = 10159;
                p2 = 48838;

                //	FILE * f = fopen("c:\\Test.txt","a");
                //	fprintf(f,"We start.\n");

                while (true)
                {
                    if (i == 0)
                    {
                        //Premier passage dans la boucle, on teste si il y une clefs de connectée.
                        retcode = UniKey_Find(ref handle, ref p1, ref p2);
                        if (retcode != 0)
                        {
                            //Aucune clef connectée.
                            //ERROR_NO_UNIEKY ou ERROR_UNKNOWN_SYSTEM
                            return HARDWAREKEY_NOT_FOUND;
                        }
                    }
                    else
                    {
                        //Passages suivant, on regarde la clef suivante.
                        retcode = UniKey_Find_Next(ref handle, ref p1, ref p2);
                        if (retcode != 0)
                        {
                            //Il n'y a pas d'autres clefs.
                            if (iErreur != 2)
                            {
                                //Si le code erreur est différent de 2, alors on renvoie le code erreur renvoyé par
                                //la clef précédemment trouvé et qui a généré peut être une autre exception.
                                return iErreur;
                            }
                            //ERROR_NO_MORE ou ERROR_NEED_FIND
                            return HARDWAREKEY_NOT_FOUND;
                        }
                    }
                    // open dongle
                    lp1 = 10159;
                    lp2 = 48838;
                    retcode = UniKey_User_Logon(ref handle, ref lp1, ref lp2);
                    if (retcode != 0)
                    {
                        //Impossible de se loguer sur la clef.
                        i++;
                        continue;
                    }

                    // TEST DATE
                    iErreur = TestDate(handle, lp1);
                    if (iErreur != 0)
                    {
                        //La date a expirée
                        i++;
                        continue;
                    }
                    // TEST CODE
                    iErreur = TestCode(handle);
                    if (retcode != 0)
                    {
                        //Le code n'est pas bon.
                        i++;
                        continue;
                    }
                    if (iWriteOnDongle == 1)
                    {
                        //On est dans la phase d'initialisation.
                        /*if (TestInfoExist(handle) == 0)
                        {
                            //Les valeurs sur la clef sont vierge, on va écrire les informations de l'ordinateur.
                            // Init donc mise à jour
                            iErreur = MajInfo(handle);
                            return iErreur;
                        }*/
                    }
                    //On teste les informations sur la clef avec l'identifiant du pc.
                    iErreur = HARDWAREKEY_SUCCESSFUL_AUTHENTIFICATION;//TestInfo(handle);
                                        
                    if ((iErreur == HARDWAREKEY_SUCCESSFUL_AUTHENTIFICATION) || (iWriteOnDongle > 1))
                    {
                        if (iWriteOnDongle > 1)
                        {
                            bResult = getConfigurationMode(handle, iWriteOnDongle - 2);
                        }

                        //La clef est valide.
                        return HARDWAREKEY_SUCCESSFUL_AUTHENTIFICATION;
                    }
                    else
                    {

                        //La clef n'est pas valide, on cherche une autre clef.
                        i++;
                        continue;
                    }
                }
                //En principe impossible.
                //return HARDWAREKEY_BAD_PARAMETERS;
            }

            internal static bool Distributions(string sChaine)
            {
                int iNBDistrib = 8;
                string[] Distrib = new string[] { "Uniform", "Normal", "Gamma", "LogNormal", "Weibull", "Triangular", "Constant", "Exponential" };
                //int[] iDistrib = new int[]{ 7, 6, 5, 9, 7, 10, 8, 11 };
                int i;
                for (i = 0; i < iNBDistrib; i++)
                {
                    if (Distrib[i] == sChaine)
                        return true;
                }
                return false;
            }


            //Teste si la clef est vierge ou pas.
            static int TestInfoExist(ushort ptHandle)
            {
                long retcode;
                ushort lp1, lp2;
                Byte[] buffer = new byte[32];


                string mHardwareInfo = "c18ba810d7fe201bdc016c821196c443";//+1

                // Lit la valeur chiffrée dans UniKey
                lp1 = 1;
                lp2 = 32;

                // read dongle memory
                retcode = UniKey_Read_Memory(ref ptHandle, ref lp1, ref lp2, buffer);
                if (retcode != 0)
                {
                    return HARDWAREKEY_READ_MEMORY;
                }

                for (int i = 0; i < mHardwareInfo.Length; i++)
                {
                    if (mHardwareInfo[i] != (char)buffer[i])
                        return 1;
                }
                return 0;
            }


            //Test les informations de la clef et les compare à celle de l'ordinateur courant.
            static int TestInfo(ushort ptHandle)
            {
                uint p1, p2;
                uint retcode;
                ushort lp1, lp2;
                Byte[] buffer = new byte[32];
                Byte[] buffer_old = new byte[32];

                /* Récupère les infos sur le PC :	GetCPUIDHash , GetNetMacHash, GetHarddiskHash */
                string ID = getProcID();
                if (ID == null)
                    return HARDWAREKEY_DYNAMIC;
                for (int i = 0; i < 32; i++)
                    buffer[i] = (Byte)ID[i];
                p1 = 32;
                lp2 = 0;
                retcode = UniKey_MD5(ref ptHandle, ref p1, buffer);
                if (retcode != SUCCESS)
                { return HARDWAREKEY_MD5_FAILED_READ; }
                // encrypt

                // Lit la valeur chiffrée dans UniKey
                lp1 = 1;
                lp2 = 32;

                // read dongle memory
                retcode = UniKey_Read_Memory(ref ptHandle, ref lp1, ref lp2, buffer_old);
                if (retcode != 0)
                {
                    return HARDWAREKEY_READ_MEMORY_FAILED;
                }


                // On décrypte
                p1 = 1;
                p2 = 32;
                retcode = UniKey_Decrypt(ref ptHandle, ref p2, ref p1, buffer_old);

                // Compare
                for (int i = 0; i < 32; i++)
                {
                    if (buffer[i] != buffer_old[i])
                        return HARDWAREKEY_NOT_ORIGINAL_HARDWARE;
                }

                return HARDWAREKEY_SUCCESSFUL_AUTHENTIFICATION;
            }


            //Mise à jour sur la clef des informations de protection pour cet ordinateur.
            static int MajInfo(ushort ptHandle)
            {
                uint p1, p2;
                uint retcode;
                ushort lp1, lp2;
                Byte[] buffer = new byte[32];

                p1 = 10159;	// passwords
                p2 = 48838;

                /* Récupère les infos sur le PC :	GetCPUIDHash , GetNetMacHash, GetHarddiskHash */
                string ID = getProcID();
                if (ID == null)
                    return HARDWAREKEY_DYNAMIC;
                for (int i = 0; i < 32; i++)
                    buffer[i] = (Byte)ID[i];


                p1 = 32;
                lp2 = 0;

                retcode = UniKey_MD5(ref ptHandle, ref p1, buffer);
                if (retcode != SUCCESS)
                { return HARDWAREKEY_MD5_FAILED_WRITE; }

                // encrypt

                p1 = 32;
                p2 = 1;
                retcode = UniKey_Encrypt(ref ptHandle, ref p1, ref p2, buffer);
                if (retcode != 0)
                { 
                    return HARDWAREKEY_ENCRYPT_FAILED_WRITE; }

                // Sauvegarde la valeur cryptée dans UniKey
                //UniKey(UNIKEY_WRITE_MEMORY, ..,mHardwareInfo);
                lp1 = 1;
                lp2 = 32;

                // write dongle memory
                retcode = UniKey_Write_Memory(ref ptHandle, ref lp1, ref lp2, buffer);
                if (retcode != 0)
                { 
                    return HARDWAREKEY_WRITE_MEMORY_FAILED; }

                return HARDWAREKEY_SUCCESSFUL_AUTHENTIFICATION;
            }





            [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
            extern static bool GetVolumeInformation(
                string RootPathName,
                StringBuilder VolumeNameBuffer,
                int VolumeNameSize,
                out uint VolumeSerialNumber,
                out uint MaximumComponentLength,
                out uint FileSystemFlags,
                StringBuilder FileSystemNameBuffer,
                int nFileSystemNameSize);

            internal static string ConvertToHex(string Chaine)
            {
                if (Chaine == null)
                    return null;
                char[] datOut = new char[Chaine.Length * 2];

                for (int i = 0; i < Chaine.Length; i++)
                {
                    int c0 = (Chaine[i] >> 4) & 15;
                    int c1 = Chaine[i] & 15;
                    datOut[i * 2] = (char)((c0 >= 0 && c0 <= 9) ? c0 + 48 : c0 + 55);
                    datOut[i * 2 + 1] = (char)((c1 >= 0 && c1 <= 9) ? c1 + 48 : c1 + 55);
                }
                string sResult = new string(datOut);
                return sResult;
            }

            internal static string ConvertToHex(Byte[] Chaine)
            {
                if (Chaine == null)
                    return null;
                char[] datOut = new char[Chaine.Length * 2];

                for (int i = 0; i < Chaine.Length; i++)
                {
                    int c0 = (Chaine[i] >> 4) & 15;
                    int c1 = Chaine[i] & 15;
                    datOut[i * 2] = (char)((c0 >= 0 && c0 <= 9) ? c0 + 48 : c0 + 55);
                    datOut[i * 2 + 1] = (char)((c1 >= 0 && c1 <= 9) ? c1 + 48 : c1 + 55);
                }
                string sResult = new string(datOut);
                return sResult;
            }

            internal static string getProcID()
            {
                String Serial = getSerial();
                Byte[] WindowSerial = getWindowsKey();
                const string key = "Chaine qui encodera également";

                int iSerial=0;
                int iWindowSerial=0;
                int iKey = 0;
                int iMax = Math.Max(Math.Max(Serial.Length, WindowSerial.Length), key.Length);
                for (int i = 0; i < iMax; i++)
                {

                    WindowSerial[iWindowSerial] = (Byte)((Byte)WindowSerial[iWindowSerial] | (Byte)Serial[iSerial] | (Byte)key[iKey]);
                    iWindowSerial = (iWindowSerial<WindowSerial.Length-1)?iWindowSerial+1:0;
                    iSerial = (iSerial < Serial.Length - 1) ? iSerial+1 : 0;
                    iKey = (iKey < key.Length - 1) ? iKey+1 : 0;
                }


                String sConverted = ConvertToHex(MD5Compute(WindowSerial));
                return sConverted;
            }

            internal static Byte[] MD5Compute(Byte[] tmp )
            {
                if (tmp == null)
                    return null;
                MD5 md5Tmp = new System.Security.Cryptography.MD5CryptoServiceProvider();
                Byte[] Encoded = md5Tmp.ComputeHash(tmp);
                return Encoded;
            }

            private static string getSerial()
            {
                ManagementObjectSearcher searcher = new
                    ManagementObjectSearcher("SELECT * FROM Win32_Processor");
                foreach (ManagementObject wmi_HD in searcher.Get())
                {
                    /*HardDrive hd = new HardDrive();
                    try
                    {
                        hd.Model = wmi_HD["DeviceID"].ToString();
                    }
                    catch (Exception e)
                    {
                        hd.Model = name;
                        OverallTools.ExternFunctions.PrintLogFile("Except02053: " + this.GetType().ToString() + " throw an exception: " + e.Message);
                    }
                    listBox1.Items.Add(hd.Model);
*/
                    PropertyDataCollection pdColl = wmi_HD.Properties;
                    PropertyDataCollection.PropertyDataEnumerator Enumerator = pdColl.GetEnumerator();

                    Enumerator.Reset();
                    Enumerator.MoveNext();

                    for (int j = 0; j < pdColl.Count; j++)
                    {
                        if (Enumerator.Current.Name == "ProcessorId")
                            return wmi_HD[Enumerator.Current.Name].ToString();
                        Enumerator.MoveNext();
                    }
                }
                searcher = null;
                return null;
            }

            private static Byte[] getWindowsKey()
            {
                try
                {
                    RegistryKey rk = Registry.LocalMachine;
                    RegistryKey rkauthentification = rk.OpenSubKey("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", false);
                    if (rkauthentification == null)
                    {
                        return null;
                    }
                    return (Byte[])rkauthentification.GetValue("DigitalProductId");
                }
                catch(Exception e)
                {
                    //OverallTools.ExternFunctions.PrintLogFile("Except02054: " + this.GetType().ToString() + " throw an exception while accessing the Windows registry: " + e.Message);
                }
                return null;
            }


        }
#endif
        #endregion

        #region La classe Flight
        internal class TableInformations
        {
            internal class FlightInformation
            {
                int iID;
                DateTime dtTime;
                string sFlightN;
                String sAirlineCode;
                String sAircraftType;
                String sFlightCategory;
                internal int ID
                {
                    get
                    {
                        return iID;
                    }
                    set
                    {
                        iID = value;
                    }
                }
                internal DateTime Time
                {
                    get
                    {
                        return dtTime;
                    }
                    set
                    {
                        dtTime = value;
                    }
                }
                internal String FlightN
                {
                    get
                    {
                        return sFlightN;
                    }
                    set
                    {
                        sFlightN = value;
                    }
                }
                internal String AirlineCode
                {
                    get
                    {
                        return sAirlineCode;
                    }
                    set
                    {
                        sAirlineCode = value;
                    }
                }
                internal String AircraftType
                {
                    get
                    {
                        return sAircraftType;
                    }
                    set
                    {
                        sAircraftType = value;
                    }
                }
                internal String FlightCategory
                {
                    get
                    {
                        return sFlightCategory;
                    }
                    set
                    {
                        sFlightCategory = value;
                    }
                }
                internal FlightInformation(int iID_, DateTime dtTime_, string sFlightN_, String sAirlineCode_, String sAircraftType_, String sFlightCategory_)
                {
                    iID = iID_;
                    dtTime = dtTime_;
                    sFlightN = sFlightN_;
                    sAirlineCode = sAirlineCode_;
                    sAircraftType = sAircraftType_;
                    sFlightCategory = sFlightCategory_;
                }
                internal FlightInformation()
                {
                    iID = 0;
                    dtTime = DateTime.Now;
                    sFlightN = "";
                    sAirlineCode = "";
                    sAircraftType = "";
                    sFlightCategory = "";
                }
                internal FlightInformation(FlightInformation fiOld)
                {
                    iID = fiOld.iID;
                    dtTime = fiOld.dtTime;
                    sFlightN = fiOld.sFlightN;
                    sAirlineCode = fiOld.sAirlineCode;
                    sAircraftType = fiOld.sAircraftType;
                    sFlightCategory = fiOld.sFlightCategory;
                }
                public override string ToString()
                {
                    return iID.ToString();
                }
            }
            internal class ArrivalFlightInformation : FlightInformation
            {
                internal ArrivalFlightInformation(int iID_, DateTime dtTime_, string sFlightN_, String sAirlineCode_, String sAircraftType_, String sFlightCategory_)
                    : base(iID_, dtTime_, sFlightN_, sAirlineCode_, sAircraftType_, sFlightCategory_)
                {

                }
                internal ArrivalFlightInformation(ArrivalFlightInformation afiOld)
                    : base(afiOld)
                {

                }
            }
            internal class DepartureFlightInformation : FlightInformation
            {
                internal DepartureFlightInformation(int iID_, DateTime dtTime_, string sFlightN_, String sAirlineCode_, String sAircraftType_, String sFlightCategory_)
                    : base(iID_, dtTime_, sFlightN_, sAirlineCode_, sAircraftType_, sFlightCategory_)
                {
                }
                internal DepartureFlightInformation(DepartureFlightInformation dfiOld)
                    : base(dfiOld)
                {
                }
            }

            internal static Dictionary<Int32, FlightInformation> getFlightsInformation(DataTable dtTable)
            {
                if (dtTable == null)
                    return null;
                int iIndexID = dtTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID);
                int iIndexN = dtTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightN);
                int iIndexDate = dtTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_DATE);
                int iIndexSTD = dtTable.Columns.IndexOf(GlobalNames.sFPD_Column_STD);
                if (iIndexSTD == -1)
                    iIndexSTD = dtTable.Columns.IndexOf(GlobalNames.sFPA_Column_STA);
                int iIndexFC = dtTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightCategory);

                int iIndexAircraft = dtTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_AircraftType);
                int iIndexAirline = dtTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_AirlineCode);
                if ((iIndexID == -1) ||
                    (iIndexDate == -1) ||
                    (iIndexSTD == -1) ||
                    (iIndexAircraft == -1) ||
                    (iIndexAirline == -1) ||
                    (iIndexN == -1) ||
                    (iIndexFC == -1))
                {
                    return null;
                }
                Dictionary<Int32, FlightInformation> lfList = new Dictionary<Int32, FlightInformation>();
                foreach (DataRow drRow in dtTable.Rows)
                {
                    try
                    {
                        lfList.Add((int)drRow[iIndexID], new FlightInformation((int)drRow[iIndexID],
                            ((DateTime)drRow[iIndexDate]).Add((TimeSpan)drRow[iIndexSTD]),
                            drRow[iIndexN].ToString(),
                            drRow[iIndexAirline].ToString(),
                            drRow[iIndexAircraft].ToString(),
                            drRow[iIndexFC].ToString()));
                    }
                    catch (Exception ex)
                    {
                        string errorMessage = "Error while importing flight plan data";
                        int flightId = 0;
                        if (drRow[iIndexID] != null && Int32.TryParse(drRow[iIndexID].ToString(), out flightId))
                        {
                            errorMessage += " for the flight with the id = " + flightId + ". ";
                        }
                        else
                        {
                            errorMessage += ". ";
                        }
                        OverallTools.ExternFunctions.PrintLogFile(errorMessage + ex.Message);
                    }
                }
                return lfList;
            }
        }
        #endregion

        #region public class TimeSpanCulture
        /*
        public class TimeSpanCulture
        {
            TimeSpan tsValue;
            public TimeSpanCulture(TimeSpanCulture tsc)
            {
                tsValue = tsc.tsValue;
            }
            public TimeSpanCulture(TimeSpan ts)
            {
                tsValue = ts;
            }
            public TimeSpanCulture()
            {
                tsValue = new TimeSpan(0, 0, 0);
            }
            public TimeSpanCulture(long ticks)
            {
                tsValue = new TimeSpan(ticks);
            }
            public TimeSpanCulture(int hours, int minutes, int seconds)
            {
                tsValue = new TimeSpan(hours, minutes, seconds);
            }
            public TimeSpanCulture(int hours, int minutes, int seconds, int milliseconds)
            {
                tsValue = new TimeSpan(0, hours, minutes, seconds, milliseconds);
            }
            public TimeSpanCulture Add(TimeSpanCulture tsc)
            {
                TimeSpanCulture tscResult = new TimeSpanCulture(this);
                tscResult.tsValue = tscResult.tsValue.Add(tsc.tsValue);
                return tscResult;
            }

            #region Les opérations de comparaison.
            public static bool operator ==(TimeSpanCulture tsc1, TimeSpanCulture tsc2)
            {
                return (tsc1.tsValue == tsc2.tsValue);
            }
            public static bool operator !=(TimeSpanCulture tsc1, TimeSpanCulture tsc2)
            {
                return (tsc1.tsValue != tsc2.tsValue);
            }
            public static bool operator >=(TimeSpanCulture tsc1, TimeSpanCulture tsc2)
            {
                return (tsc1.tsValue >= tsc2.tsValue);
            }
            public static bool operator >(TimeSpanCulture tsc1, TimeSpanCulture tsc2)
            {
                return (tsc1.tsValue > tsc2.tsValue);
            }
            public static bool operator <(TimeSpanCulture tsc1, TimeSpanCulture tsc2)
            {
                return (tsc1.tsValue < tsc2.tsValue);
            }
            public static bool operator <=(TimeSpanCulture tsc1, TimeSpanCulture tsc2)
            {
                return (tsc1.tsValue <= tsc2.tsValue);
            }
            public override int GetHashCode()
            {
                return base.GetHashCode();
            }
            public override bool Equals(object obj)
            {
                if (obj.GetType() == typeof(TimeSpanCulture))
                    return (this == (TimeSpanCulture)obj);
                if (obj.GetType() == typeof(TimeSpan))
                    return (this.tsValue == (TimeSpan)obj);
                return base.Equals(obj);
            }
            #endregion

            public static String CurrentSeparator()
            {
                return Application.CurrentCulture.DateTimeFormat.TimeSeparator;
            }
            /// <summary>
            /// Returns the hours of that TimeSpanCulture on 2 or more digits.
            /// </summary>
            /// <returns></returns>
            public String FormatedHours()
            {
                String sResult = "";
                if (tsValue.Hours.ToString().Length < 2)
                    sResult = "0";
                sResult += tsValue.Hours.ToString();
                return sResult;
            }
            /// <summary>
            /// Returns the minutes of that TimeSpanCulture on 2 or more digits.
            /// </summary>
            /// <returns></returns>
            public String FormatedMinutes()
            {
                String sResult = "";
                if (tsValue.Minutes.ToString().Length < 2)
                    sResult = "0";
                sResult += tsValue.Minutes.ToString();
                return sResult;
            }
            /// <summary>
            /// Returns the seconds of that TimeSpanCulture on 2 or more digits.
            /// </summary>
            /// <returns></returns>
            public String FormatedSeconds()
            {
                String sResult = "";
                if (tsValue.Seconds.ToString().Length < 2)
                    sResult = "0";
                sResult += tsValue.Seconds.ToString();
                return sResult;
            }
            public override string ToString()
            {
                return FormatedHours() + CurrentSeparator() + FormatedMinutes() + CurrentSeparator() + FormatedSeconds();
            }
            public string ToShortString()
            {
                return FormatedHours() + CurrentSeparator() + FormatedMinutes();
            }
            public static bool TryParse(String Value, out TimeSpanCulture tscTime)
            {
                tscTime = new TimeSpanCulture();
                if (!TimeSpan.TryParse(Value, out tscTime.tsValue))
                {
                    DateTime dtTmp ;
                    if (!DateTime.TryParse(Value, Application.CurrentCulture, System.Globalization.DateTimeStyles.NoCurrentDateDefault, out dtTmp))
                        return false;
                    tscTime.tsValue = new TimeSpan(0, dtTmp.Hour, dtTmp.Minute, dtTmp.Second, dtTmp.Millisecond);
                }
                return true;
            }
            public static implicit operator TimeSpan(TimeSpanCulture tscTime)
            {
                return tscTime.tsValue;
            }
            public static implicit operator TimeSpanCulture(TimeSpan tsTime)
            {
                return new TimeSpanCulture(tsTime);
            }
            public static implicit operator TimeSpanCulture(String sTime)
            {
                TimeSpanCulture tscConvert;
                if (!TimeSpanCulture.TryParse(sTime, out tscConvert))
                    return new TimeSpanCulture();
                return tscConvert;
            }
        }*/
        #endregion

        #region La classe TreeViewFunctions
        /// <summary>
        /// Classes contenant des fonctions statiques permettant la gestion des nodes d'un treeview.
        /// Recherche, Ajout, Suppression, Copy ....
        /// </summary>
        public static class TreeViewFunctions
        {
            #region Fonction pour la création d'une nouvelle branche.
            /// <summary>
            /// Function which create a new Treenode with the specified properties
            /// </summary>
            /// <param name="name">The name of the TreeNode</param>
            /// <param name="text">The text which must appear</param>
            /// <param name="tag">A tag (can be null)</param>
            /// <param name="contextMenu">The contextMenu (can be null)</param>
            /// <returns></returns>
            public static TreeNode createBranch(String name,
                                                String text,
                                                Object tag,
                                                ContextMenuStrip contextMenu)
            {
                return createBranch(name, text, tag, contextMenu, false, false);
            }
            public static TreeNode createBranch(String name,
                                    String text,
                                    Object tag,
                                    ContextMenuStrip contextMenu,
                                    bool checked_,
                                    bool unleashedTag)
            {
                TreeViewTag Tag = (TreeViewTag)tag;
                TreeNode noeud = new TreeNode(text, Tag.ImageIndex, Tag.SelectedImageIndex);
                noeud.Name = name;
                if (unleashedTag)
                {
                    noeud.Tag = Tag.Clone();
                    Tag.IsUnleashed = true;
                }
                else
                    noeud.Tag = tag;
                //noeud.Tag = tag;
                noeud.ContextMenuStrip = contextMenu;
                noeud.Checked = checked_;
                return noeud;
            }
            public static TreeNode CreateDirectory(String Name)
            {
                return CreateDirectory(Name, null);
            }
            public static TreeNode CreateDirectory(String Name, ContextMenuStrip contextMenu)
            {
                return CreateDirectory(Name, Name, contextMenu);
            }
            public static TreeNode CreateDirectory(String Name, String Text, ContextMenuStrip contextMenu)
            {
                return createBranch(Name, Text, TreeViewTag.getDirectoryNode(Name), contextMenu);
            }
            #endregion

            #region Fonction pour récupérer le noedu désiré.
            public static TreeNode getAirportChild(TreeNode AirportRacine, String Name)
            {
                bool bBHS = false;
                int[] Types = DataFunctions.AnalyzeGroupName(Name);
                if (Types == null)
                {
                    bBHS = true;
                    Types = DataFunctions.AnalyzeGroupNameBHS(Name);
                    if (Types == null)
                        return null;
                }
                if (Types[1] == 0)
                    return null;
                TreeNode level = null;
                if (!bBHS)
                    level = getLevel(AirportRacine, Types[0], Types[1]);
                else
                {
                    level = getBHSSystem(AirportRacine, Types[0]);
                }
                //AirportRacine.Nodes[Types[0] - 1].Nodes[Types[1] - 1];

                if ((!bBHS) && (Types[2] == 0))
                    return level;
                if (bBHS)
                {
                    return fingGroupDefinition(level, DataFunctions.AnalyzeNameBHS(Types[1]), Types[2]);
                }
                else
                {
                    return fingGroupDefinition(level, DataFunctions.AnalyzeName(Types[2]), Types[3]);
                }
            }
            public static TreeNode fingGroupDefinition(TreeNode level, String Type, int index)
            {
                foreach (TreeNode node in level.Nodes)
                {
                    TreeViewTag obj = (TreeViewTag)node.Tag;
                    if ((obj.AirportObjectType == Type) && (obj.Index == index))
                        return node;
                }
                return null;
            }
            #endregion

            #region Fonction pour recherché un groupe dans une arborescence.
            public static TreeNode RechercheGroupe(TreeNode CurrentNode, String GroupType, String GroupName)
            {
                foreach (TreeNode node in CurrentNode.Nodes)
                {
                    TreeViewTag tag = (TreeViewTag)node.Tag;
                    if (tag.AirportObjectType == GroupType)
                    {
                        if (tag.Name == GroupName)
                        {
                            return node;
                        }
                    }
                }
                return null;
            }
            public static TreeNode RechercheGroupe(TreeNode CurrentNode, String GroupType)
            {
                foreach (TreeNode node in CurrentNode.Nodes)
                {
                    TreeViewTag tag = (TreeViewTag)node.Tag;
                    if (tag.AirportObjectType == GroupType)
                    {
                        return node;
                    }
                }
                return null;
            }

            public static bool ContainsNode(TreeNode Root, TreeNode SearchedNode)
            {
                if (Root.Nodes.Contains(SearchedNode))
                    return true;
                foreach (TreeNode tnNode in Root.Nodes)
                {
                    if (ContainsNode(tnNode, SearchedNode))
                        return true;
                }
                return false;
            }
            #endregion

            #region Fonctions pour la création de l'arbre du treeview à partir de celui en XML
            public static void construireArbre(System.Xml.XmlNode NoeudRacine, TreeNode NoeudTreeView, ContextMenuStrip cmsAirport)
            {
                TreeNode nouvelleBranche;
                foreach (System.Xml.XmlNode Noeud in NoeudRacine.ChildNodes)
                {
                    String Type = Noeud.Attributes["Type"].Value;
                    String Index = Noeud.Attributes["Index"].Value;
                    int iIndex;
                    if (!Int32.TryParse(Index, out iIndex))
                    {
                        return;
                    }
                    String Name = Noeud.Attributes["Name"].Value;
                    TreeViewTag newTag = null;
                    if ((FonctionUtiles.hasNamedAttribute(Noeud, "X")) && (FonctionUtiles.hasNamedAttribute(Noeud, "Y")))
                    {
                        int PositionX, PositionY;
                        if ((Int32.TryParse(Noeud.Attributes["X"].Value, out PositionX)) &&
                            (Int32.TryParse(Noeud.Attributes["Y"].Value, out PositionY)))
                        {
                            newTag = TreeViewTag.getAirportNode(Type, iIndex, Name, new Point(PositionX, PositionY), true);
                        }
                    }
                    if ((FonctionUtiles.hasNamedAttribute(Noeud, "BHS_X")) && (FonctionUtiles.hasNamedAttribute(Noeud, "BHS_Y")))
                    {
                        int PositionX, PositionY;
                        if ((Int32.TryParse(Noeud.Attributes["BHS_X"].Value, out PositionX)) &&
                            (Int32.TryParse(Noeud.Attributes["BHS_Y"].Value, out PositionY)))
                        {
                            if (newTag == null)
                            {
                                newTag = TreeViewTag.getAirportNode(Type, iIndex, Name, new Point(0, 0), false, new Point(PositionX, PositionY), true);
                            }
                            else
                            {
                                newTag.BHSLocation = new Point(PositionX, PositionY);
                                newTag.BHSVisible = true;
                            }
                        }
                    }
                    if (newTag == null)
                    {
                        newTag = TreeViewTag.getAirportNode(Type, iIndex, Name);
                    }

                    nouvelleBranche = CreationObjet(newTag, cmsAirport);
                    NoeudTreeView.Nodes.Add(nouvelleBranche);
                    construireArbre(Noeud, nouvelleBranche, cmsAirport);
                }
            }

            public static TreeNode CreationObjet(String Type, int index, String Name, ContextMenuStrip cmsAirport)
            {
                TreeViewTag tag = TreeViewTag.getAirportNode(Type, index, Name);
                return CreationObjet(tag, cmsAirport);
            }
            private static TreeNode CreationObjet(object tag, ContextMenuStrip cmsAirport)
            {
                TreeViewTag tvttag = (TreeViewTag)tag;
                return OverallTools.TreeViewFunctions.createBranch(tvttag.AirportObjectType, tvttag.ToString(), tvttag, cmsAirport);
            }
            #endregion

            #region fonction pour la copie d'un treeview dans un second.
            public static void copyChilds(TreeNode Destination, TreeNode Origin, Boolean bChart, GestionDonneesHUB2SIM Donnees, bool includeUnchecked, bool unleashedTag)
            {
                if (bChart)
                {
                    if ((Destination.Tag != null) && (Destination.Tag.GetType() == typeof(TreeViewTag)))
                    {
                        TreeViewTag tvTag = (TreeViewTag)Destination.Tag;
                        if ((tvTag.isFilterNode) || (tvTag.isTableNode) || (tvTag.IsExceptionNode))
                        {

                            if (((Donnees != null) && (Donnees.getGraphicFilter(tvTag.ScenarioName, tvTag.Name) != null) && (!tvTag.IsExceptionNode)) ||
                                ((tvTag.IsExceptionNode) && (Donnees.getExceptionTableGraphicFilter(tvTag.ScenarioName, tvTag.Name, tvTag.ExceptionName) != null)))
                            {
                                TreeViewTag tvtTmp = TreeViewTag.getChartNode("Chart");
                                if (tvTag.IsExceptionNode)
                                {
                                    tvtTmp.Name = tvTag.Name;
                                    tvtTmp.ExceptionName = tvTag.ExceptionName;
                                    tvtTmp.IsUnleashed = true;
                                    tvtTmp.IsExceptionNode = true;

                                }
                                TreeNode newNode = createBranch("Chart", "Chart", tvtTmp, null);
                                if (newNode != null)
                                    Destination.Nodes.Add(newNode);
                            }
                        }
                    }
                }
                foreach (TreeNode child in Origin.Nodes)
                {
                    if (includeUnchecked ||
                         child.Checked ||
                         OverallTools.TreeViewFunctions.HasCheckedDescendants(child))
                    {
                        TreeNode tnNewNode = createBranch(child.Name, child.Text, child.Tag, null, child.Checked, unleashedTag);
                        Destination.Nodes.Add(tnNewNode);
                        copyChilds(tnNewNode, child, bChart, Donnees, includeUnchecked, unleashedTag);
                    }
                }
            }

            // >> Task #13384 Report Tree-view
            public static void copyChildsWithContextMenu_v1(TreeNode Destination, TreeNode Origin, GestionDonneesHUB2SIM Donnees,
                bool includeUnchecked, bool unleashedTag, ContextMenuStrip contextMenuStrip)
            {
                foreach (TreeNode child in Origin.Nodes)
                {
                    if (includeUnchecked ||
                         child.Checked ||
                         OverallTools.TreeViewFunctions.HasCheckedDescendants(child))
                    {
                        TreeNode tnNewNode = createBranch(child.Name, child.Text, child.Tag, contextMenuStrip, child.Checked, unleashedTag);
                        Destination.Nodes.Add(tnNewNode);
                        copyChildsWithContextMenu(tnNewNode, child, Donnees, includeUnchecked, unleashedTag, contextMenuStrip);
                    }
                }
            }

            public static void copyChildsWithContextMenu(TreeNode Destination, TreeNode Origin, GestionDonneesHUB2SIM Donnees,
                bool includeUnchecked, bool unleashedTag, ContextMenuStrip contextMenuStrip)
            {
                foreach (TreeNode child in Origin.Nodes)
                {
                    if (includeUnchecked ||
                         child.Checked ||
                         OverallTools.TreeViewFunctions.HasCheckedDescendants(child))
                    {
                        TreeNode tnNewNode = null;
                        if (child.Tag != null && child.Tag.GetType() == typeof(TreeViewTag))
                        {
                            TreeViewTag childTag = (TreeViewTag)child.Tag;
                            childTag.reportTreeIndex = reportIndex;
                            reportIndex++;

                            if (childTag.isChartNode)
                            {
                                string scenarioName = childTag.ScenarioName;
                                string parentTableName = child.Name;
                                if (scenarioName == null || scenarioName == "")//chart from the Charts directory - If adding normaly it will not see the chart => must add the table and chart separatly.
                                {
                                    if (scenarioName == null)//chart created from several tables (in the Charts directory)
                                    {
                                        TreeNode chartNode = createBranch(child.Name, child.Text, child.Tag, contextMenuStrip, child.Checked, unleashedTag);
                                        Destination.Nodes.Add(chartNode);
                                        tnNewNode = chartNode;

                                        TreeViewTag filterTableTag = TreeViewTag.getFilterNode(scenarioName, child.Name);
                                        TreeNode tnNewTable = OverallTools.TreeViewFunctions.createBranch(child.Name, child.Name, filterTableTag, contextMenuStrip);
                                        chartNode.Nodes.Add(tnNewTable);
                                        /* remove after validation
                                        GraphicFilter graphicFilter = Donnees.GetGraphicFilter(child.Name);

                                        Filter filter = Donnees.GetFilter(child.Name);
                                        GraphicFilter parentGraphicFilter = Donnees.GetGeneralGraphicFilter(filter.MotherTableName);
                                        bool hasUnloadedParent = false;
                                        if (parentGraphicFilter != null && parentGraphicFilter.getlistColumnsOrigin() != null)
                                        {
                                            for (int i = 0; i < parentGraphicFilter.getlistColumnsOrigin().Count; i++)
                                            {
                                                if (columnsOrigin[i] == null || columnsOrigin[i].GetType() != typeof(ColumnInformation))
                                                    continue;
                                                ColumnInformation info = (ColumnInformation)columnsOrigin[i];
                                                NormalTable nt = Donnees.GetScenarioNormalTable(info.DataSet, info.TableName);
                                                if (filterTableHasUnloadedParent(nt))
                                                {
                                                    hasUnloadedParent = true;
                                                    break;
                                                }
                                            }
                                        }
                                        if (!hasUnloadedParent)
                                        {
                                            //NormalTable motherNt = Donnees.GetTable(
                                            

                                            TreeViewTag filterTableTag = TreeViewTag.getFilterNode(scenarioName, child.Name);
                                            TreeNode tnNewTable = OverallTools.TreeViewFunctions.createBranch(child.Name, child.Name, filterTableTag, contextMenuStrip);
                                            chartNode.Nodes.Add(tnNewTable);
                                        }
                                        */
                                    }
                                    else
                                    {
                                        //TreeViewTag parentTag = TreeViewTag.getTableNode(scenarioName, parentTableName);
                                        //TreeNode tnNewTable = OverallTools.TreeViewFunctions.createBranch(parentTableName, parentTableName, parentTag, contextMenuStrip);

                                        TreeNode chartNode = createBranch(child.Name, child.Text, child.Tag, contextMenuStrip, child.Checked, unleashedTag);
                                        //tnNewTable.Nodes.Add(chartNode);
                                        //tnNewNode.Nodes.Add(tnNewTable); 
                                        //chartNode.Nodes.Add(tnNewTable);
                                        Destination.Nodes.Add(chartNode);
                                        tnNewNode = chartNode;

                                        GraphicFilter graphicFilter = Donnees.GetGeneralGraphicFilter(child.Name);
                                        if (graphicFilter != null)
                                        {
                                            ArrayList columnsOrigin = graphicFilter.getlistColumnsOrigin();
                                            if (columnsOrigin != null)
                                            {
                                                List<string> usedScenarioTables = new List<string>();
                                                for (int i = 0; i < columnsOrigin.Count; i++)
                                                {
                                                    if (columnsOrigin[i] == null || columnsOrigin[i].GetType() != typeof(ColumnInformation))
                                                        continue;
                                                    ColumnInformation info = (ColumnInformation)columnsOrigin[i];
                                                    if (info != null)
                                                    {
                                                        //Filter check

                                                        NormalTable nt = Donnees.GetScenarioNormalTable(info.DataSet, info.TableName);
                                                        bool hasUnloadedParent = filterTableHasUnloadedParent(nt);
                                                        //if (nt.isFilter && nt is DataManagement.IFilterTable)
                                                        //{
                                                        //    DataManagement.IFilterTable filterTable = (DataManagement.IFilterTable)nt;
                                                        //    if (filterTable != null && filterTable.Parent != null)
                                                        //    {
                                                        //        if (!filterTable.Parent.tableIsLoaded && filterTable.Parent is ResultsTable)
                                                        //        {
                                                        //            ResultsTable resultsTable = (ResultsTable)filterTable.Parent;
                                                        //            if (resultsTable.CalculatedFromTrace)
                                                        //                canAddChild = false;
                                                        //        }
                                                        //    }
                                                        //}
                                                        if (!hasUnloadedParent)
                                                        {
                                                            TreeViewTag tag = TreeViewTag.getTableNode(info.DataSet, info.TableName);
                                                            string branchName = info.DataSet + "-" + info.TableName;
                                                            if (!usedScenarioTables.Contains(branchName))
                                                            {
                                                                TreeNode infoTableNode = OverallTools.TreeViewFunctions.createBranch(branchName, branchName, tag, contextMenuStrip);
                                                                chartNode.Nodes.Add(infoTableNode);
                                                                usedScenarioTables.Add(branchName);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    TreeNode chartNode = createBranch(child.Name, child.Text, child.Tag, contextMenuStrip, child.Checked, unleashedTag);

                                    NormalTable nt = Donnees.GetScenarioNormalTable(scenarioName, parentTableName);
                                    bool hasUnloadedParent = filterTableHasUnloadedParent(nt);
                                    if (!hasUnloadedParent)
                                    {
                                        TreeViewTag parentTag = TreeViewTag.getTableNode(scenarioName, parentTableName);
                                        TreeNode tnNewTable = OverallTools.TreeViewFunctions.createBranch(parentTableName, parentTableName, parentTag, contextMenuStrip);
                                        chartNode.Nodes.Add(tnNewTable);
                                    }
                                    Destination.Nodes.Add(chartNode); //tnNewNode.Nodes.Add(tnNewTable);
                                    tnNewNode = chartNode;
                                }
                            }
                            else
                            {
                                NormalTable nt = Donnees.GetScenarioNormalTable(childTag.ScenarioName, child.Name);
                                bool hasUnloadedParent = filterTableHasUnloadedParent(nt);
                                if (!hasUnloadedParent)
                                {
                                    tnNewNode = createBranch(child.Name, child.Text, child.Tag, contextMenuStrip, child.Checked, unleashedTag);
                                    Destination.Nodes.Add(tnNewNode);
                                }
                            }
                        }
                        else
                        {
                            tnNewNode = createBranch(child.Name, child.Text, child.Tag, contextMenuStrip, child.Checked, unleashedTag);
                            Destination.Nodes.Add(tnNewNode);
                        }
                        //Destination.Nodes.Add(tnNewNode);
                        copyChildsWithContextMenu(tnNewNode, child, Donnees, includeUnchecked, unleashedTag, contextMenuStrip);
                    }
                }
            }
            internal static bool filterTableHasUnloadedParent(NormalTable normalTable)
            {
                if (normalTable is DataManagement.IFilterTable)
                {
                    DataManagement.IFilterTable filterTable = (DataManagement.IFilterTable)normalTable;
                    if (filterTable != null && filterTable.Parent != null)
                    {
                        if (!filterTable.Parent.tableIsLoaded && filterTable.Parent is ResultsTable)
                        {
                            ResultsTable resultsTable = (ResultsTable)filterTable.Parent;
                            if (resultsTable.CalculatedFromTrace)
                                return true;
                        }
                    }
                }
                return false;
            }

            public static void copyChildsWithContextMenu_(TreeNode Destination, TreeNode Origin, GestionDonneesHUB2SIM Donnees,
                bool includeUnchecked, bool unleashedTag, ContextMenuStrip contextMenuStrip)
            {
                foreach (TreeNode child in Origin.Nodes)
                {
                    if (includeUnchecked ||
                         child.Checked ||
                         OverallTools.TreeViewFunctions.HasCheckedDescendants(child))
                    {
                        TreeNode tnNewNode = null;
                        //if (child.Tag != null && child.Tag.GetType() == typeof(TreeViewTag))
                        //{
                        //    TreeViewTag childTag = (TreeViewTag)child.Tag;
                        //    if (childTag.isChartNode)
                        //    {
                        //        tnNewNode = createBranch(child.Name, child.Text, Destination.Tag, contextMenuStrip, child.Checked, unleashedTag);
                        //        string scenarioName = childTag.ScenarioName;
                        //        string parentTableName = child.Name;
                        //        if (scenarioName == null || scenarioName == "")//chart from the Charts directory - If adding normaly it will not see the chart => must add the table and chart separatly.
                        //        {
                        //            if (scenarioName == null)//chart created from several tables (in the Charts directory)
                        //            {
                        //                TreeNode chartNode = createBranch(child.Name, child.Text, child.Tag, contextMenuStrip, child.Checked, unleashedTag);
                        //                tnNewNode.Nodes.Add(chartNode);
                        //            }
                        //            else
                        //            {
                        //                TreeViewTag parentTag = TreeViewTag.getTableNode(scenarioName, parentTableName);
                        //                TreeNode tnNewTable = OverallTools.TreeViewFunctions.createBranch(parentTableName, parentTableName, parentTag, contextMenuStrip);

                        //                TreeNode chartNode = createBranch(child.Name, child.Text, child.Tag, contextMenuStrip, child.Checked, unleashedTag);
                        //                tnNewTable.Nodes.Add(chartNode);
                        //                tnNewNode.Nodes.Add(tnNewTable);
                        //            }
                        //        }
                        //        else
                        //        {
                        //            TreeViewTag parentTag = TreeViewTag.getTableNode(scenarioName, parentTableName);
                        //            TreeNode tnNewTable = OverallTools.TreeViewFunctions.createBranch(parentTableName, parentTableName, parentTag, contextMenuStrip);
                        //            tnNewNode.Nodes.Add(tnNewTable);
                        //        }
                        //    }
                        //    else
                        //    {
                        //        tnNewNode = createBranch(child.Name, child.Text, child.Tag, contextMenuStrip, child.Checked, unleashedTag);
                        //    }
                        //}
                        //else
                        //{
                        tnNewNode = createBranch(child.Name, child.Text, child.Tag, contextMenuStrip, child.Checked, unleashedTag);
                        //}                                                
                        Destination.Nodes.Add(tnNewNode);
                        copyChildsWithContextMenu(tnNewNode, child, Donnees, includeUnchecked, unleashedTag, contextMenuStrip);
                    }
                }
            }
            // << Task #13384 Report Tree-view

            public static void copyChilds(TreeView tvTree, TreeNode Origin, bool bResult, bool includeUnchecked, bool unleashedTag)
            {
                tvTree.Nodes.Clear();
                foreach (TreeNode childs in Origin.Nodes)
                {
                    if (includeUnchecked ||
                         childs.Checked ||
                         OverallTools.TreeViewFunctions.HasCheckedDescendants(childs))// fait ce qui suit si : includeUnchecked est vrai ou childs ou un de ses fils est checked
                    {
                        TreeNode tnNewNode = OverallTools.TreeViewFunctions.createBranch(childs.Name, childs.Text, childs.Tag, null, includeUnchecked, unleashedTag);
                        tvTree.Nodes.Add(tnNewNode);
                        OverallTools.TreeViewFunctions.copyChilds(tnNewNode, childs, bResult, null, includeUnchecked, unleashedTag);
                    }
                }
            }

            #endregion

            #region Functions check the checked nodes
            /// <summary>
            ///  Return true if one of the descendants is set to checked
            /// </summary>
            /// <param name="node"></param>
            /// <returns></returns>
            public static Boolean HasCheckedDescendants(TreeNode node)
            {
                Boolean test = false;
                if (node.Nodes.Count == 0)
                    return false; // if there is no descendant, there is no checked descendant
                foreach (TreeNode childNode in node.Nodes)
                {
                    if (childNode.Checked)
                        return true;
                    if (HasCheckedDescendants(childNode))
                        return true;
                }
                return test;
            }
            /// <summary>
            /// Return true if "Node" is the last checked node in her mother branch
            /// </summary>
            /// <param name="Node"></param>
            /// <returns></returns>
            public static Boolean IsLastSelectedChild(TreeNode Node)
            {
                Boolean test = true;
                if (Node.Parent == null) return false;
                TreeNode brotherNode = Node.NextNode;
                while (brotherNode != null)
                {
                    if (brotherNode.Checked) return false;
                    else
                        if (HasCheckedDescendants(brotherNode))
                        return false;
                    brotherNode = brotherNode.NextNode;
                }
                return test;
            }
            #endregion

            #region Fonction qui insère dans l'ordre alphabétique dans le treeview
            public static void AddSortedNode(TreeNode tnNodeParent, TreeNode tnNode)
            {
                AddSortedNode(tnNodeParent, tnNode, false);
            }
            public static void AddSortedNode(TreeNode tnNodeParent, TreeNode tnNode, bool bUseText)
            {
                AddSortedNode(tnNodeParent, tnNode, bUseText, false, false);
            }
            public static void AddSortedNode(TreeNode tnNodeParent, TreeNode tnNode, bool bUseText, bool bTypeSensitive, bool bBefore)
            {
                if (tnNodeParent.Nodes.Count == 0)
                {
                    tnNodeParent.Nodes.Add(tnNode);
                    return;
                }
                if (((tnNode.Tag == null) || (tnNode.Tag.GetType() != typeof(TreeViewTag)))
                    && (bTypeSensitive))
                    return;
                TreeViewTag.TreeViewTypeTag etvttType = TreeViewTag.TreeViewTypeTag.TableNode;
                if (bTypeSensitive)
                    etvttType = ((TreeViewTag)tnNode.Tag).TypeClass;


                String sNodeName = tnNode.Name;
                if (bUseText)
                    sNodeName = tnNode.Text;
                int i = 0;
                int bFindSameType = -1;
                for (; i < tnNodeParent.Nodes.Count; i++)
                {
                    if (bTypeSensitive)
                    {
                        if ((tnNodeParent.Nodes[i].Tag == null) || (tnNodeParent.Nodes[i].Tag.GetType() != typeof(TreeViewTag)) ||
                            (etvttType != ((TreeViewTag)tnNodeParent.Nodes[i].Tag).TypeClass))
                        {
                            if (bFindSameType != -1)
                                break;
                            continue;
                        }
                        if (bFindSameType == -1)
                            bFindSameType = i;
                    }
                    String sCurrentNodeName = tnNodeParent.Nodes[i].Name;
                    if (bUseText)
                        sCurrentNodeName = tnNodeParent.Nodes[i].Text;

                    int iComp = FonctionUtiles.CompareString(sCurrentNodeName, sNodeName, true);
                    if (iComp >= 0)
                        break;
                }
                if (bTypeSensitive)
                {
                    if (bFindSameType == -1)
                    {
                        i = 0;
                        if (!bBefore)
                            i = tnNodeParent.Nodes.Count;
                    }
                }
                tnNodeParent.Nodes.Insert(i, tnNode);
            }
            // >> Task #13422 Keywords improvement
            public static void AddSortedNodeBeforeLast(TreeNode tnNodeParent, TreeNode tnNode)
            {
                if (tnNodeParent == null || tnNode == null)
                    return;
                if (tnNodeParent.Nodes.Count == 0)
                {
                    tnNodeParent.Nodes.Add(tnNode);
                    return;
                }
                else if (tnNodeParent.Nodes.Count == 1)
                {
                    tnNodeParent.Nodes.Insert(0, tnNode);
                    return;
                }
                String sNodeName = tnNode.Name;
                int i = 0;
                for (i = 0; i < tnNodeParent.Nodes.Count - 1; i++)
                {
                    String sCurrentNodeName = tnNodeParent.Nodes[i].Name;
                    int iComp = FonctionUtiles.CompareString(sCurrentNodeName, sNodeName, true);
                    if (iComp >= 0)
                        break;
                }
                tnNodeParent.Nodes.Insert(i, tnNode);
            }
            // << Task #13422 Keywords improvement
            #endregion

            #region Fonctions pour trouver le Terminal

            /// <summary>
            /// Fonction qui renvoie le noeud du terminal désigné.
            /// </summary>
            /// <param name="racine">La racine de l'aéroport</param>
            /// <param name="iIndexTerminalRecherche">l'index du terminal recherché</param>
            /// <returns></returns>
            public static TreeNode getTerminal(TreeNode racine, int iIndexTerminalRecherche)
            {
                if (racine == null)
                    return null;
                if (racine.Nodes.Count == 0)
                    return null;
                if (iIndexTerminalRecherche <= -1)
                    return null;
                for (int i = 0; i < racine.Nodes.Count; i++)
                {
                    if ((racine.Nodes[i].Tag == null) ||
                        (racine.Nodes[i].Tag.GetType() != typeof(TreeViewTag)))
                        continue;
                    TreeViewTag tvtTag = (TreeViewTag)racine.Nodes[i].Tag;
                    if (tvtTag.AirportObjectType != PAX2SIM.sTerminalName)
                        continue;
                    if (iIndexTerminalRecherche == tvtTag.Index)
                    {
                        return racine.Nodes[i];
                    }
                }
                return null;
            }
            #endregion

            #region fonctions pour déterminer le Level

            /// <summary>
            /// Fonction qui renvoie le noeud XML du level désiré.
            /// </summary>
            /// <param name="racine">La racine Xml de l'aéroport</param>
            /// <param name="iTerminal">Le terminal dans lequel le level se situe</param>
            /// <param name="iLevel">Le nom du level désiré</param>
            /// <returns></returns>
            public static TreeNode getLevel(TreeNode racine, int iTerminal, int iLevel)
            {
                if (racine == null)
                    return null;
                if ((iLevel <= 0) || (iTerminal <= 0))
                    return null;
                if (racine.Nodes.Count == 0)
                    return null;
                TreeNode tnTerminal = getTerminal(racine, iTerminal);
                if (tnTerminal == null)
                    return null;
                for (int i = 0; i < tnTerminal.Nodes.Count; i++)
                {
                    if ((tnTerminal.Nodes[i].Tag == null) ||
                        (tnTerminal.Nodes[i].Tag.GetType() != typeof(TreeViewTag)))
                        continue;
                    TreeViewTag tvtTag = (TreeViewTag)tnTerminal.Nodes[i].Tag;
                    if (tvtTag.AirportObjectType != PAX2SIM.sLevelName)
                        continue;
                    if (iLevel == tvtTag.Index)
                    {
                        return tnTerminal.Nodes[i];
                    }
                }
                return null;
            }
            /// <summary>
            /// Fonction qui compte le nombre de node et de sous node dans une collection de node.
            /// </summary>
            /// <param name="nodes"></param>
            /// <returns></returns>
            public static int CountNodes(TreeNodeCollection nodes)
            {
                if (nodes == null)
                    return 0;
                int nb = nodes.Count;
                foreach (TreeNode node in nodes)
                    if (node.Nodes != null)
                        nb += CountNodes(node.Nodes);
                return nb;
            }
            #endregion

            #region Fonctions pour trouver le system BHS

            /// <summary>
            /// Fonction qui renvoie le noeud du terminal désigné.
            /// </summary>
            /// <param name="racine">La racine de l'aéroport</param>
            /// <param name="iIndexTerminalRecherche">l'index du terminal recherché</param>
            /// <returns></returns>
            public static TreeNode getBHSSystem(TreeNode racine, int iIndexTerminalRecherche)
            {
                TreeNode Terminal = getTerminal(racine, iIndexTerminalRecherche);
                if (Terminal == null)
                    return null;
                if (Terminal.Nodes.Count == 0)
                    return null;
                for (int i = 0; i < Terminal.Nodes.Count; i++)
                {
                    if ((Terminal.Nodes[i].Tag == null) ||
                        (Terminal.Nodes[i].Tag.GetType() != typeof(TreeViewTag)))
                        continue;
                    TreeViewTag tvtTag = (TreeViewTag)Terminal.Nodes[i].Tag;
                    if (tvtTag.AirportObjectType != PAX2SIM.sBHSName)
                        continue;
                    return Terminal.Nodes[i];
                }
                return null;
            }
            #endregion

            #region Fonction de recherche dans le treeview
            /// <summary>
            ///  Fonction qui recherche un nom dans l'arbre qu'on lui passe en paramètre.
            /// </summary>
            /// <param name="name">Le nom de l'objet recherché</param>
            /// <param name="racine">La racine de l'arbre dans lequel recherché.</param>
            /// <returns>Renvoie le noeud recherché ou null.</returns>
            internal static TreeNode RechercherNomEnfants(String name, TreeNode racine)
            {
                if (racine.Name == name)
                    return racine;
                foreach (TreeNode noeud in racine.Nodes)
                {
                    if (noeud.Name == name)
                        return noeud;
                }
                return null;
            }
            /// <summary>
            /// Effectue une recherche recursive d'un nom dans les nodes qu'on lui passe en paramètre.
            /// </summary>
            /// <param name="nom">Nom recherché</param>
            /// <param name="nodes">Collection de nodes ou chercher</param>
            /// <param name="NodeList">Liste ou seront stroqué les nodes trouvées</param>
            internal static void RechercheNodes(String nom, TreeNodeCollection nodes, ref List<TreeNode> NodeList)
            {
                if (NodeList == null || nodes == null)
                    return;
                foreach (TreeNode node in nodes)
                {
                    if (node.Name == nom)
                    {
                        NodeList.Add(node);
                    }
                    RechercheNodes(nom, node.Nodes, ref NodeList);
                }
            }
            internal static TreeNode RechercherNomEnfantStrict(String name, TreeNode racine)
            {
                foreach (TreeNode noeud in racine.Nodes)
                {
                    if (noeud.Name == name)
                        return noeud;
                }
                return null;
            }
            /// <summary>
            ///  Fonction qui recherche un nom dans les enfants qu'on lui passe en paramètre.
            /// </summary>
            /// <param name="name">Le nom de l'objet recherché</param>
            /// <param name="racine">La racine de l'arbre dans lequel recherché.</param>
            /// <returns>Renvoie le noeud recherché ou null.</returns>
            internal static TreeNode RechercherNom(String name, TreeNode racine)
            {
                if (racine.Name == name)
                    return racine;
                foreach (TreeNode noeud in racine.Nodes)
                {
                    TreeNode noeudTrouve = RechercherNom(name, noeud);
                    if (noeudTrouve != null)
                    {
                        return noeudTrouve;
                    }
                }
                return null;
            }

            /// <summary>
            /// Fonction pour récupérer les noms des groupes contenus dans un level.
            /// </summary>
            /// <param name="NoeudLevel">Le level</param>
            /// <returns>la liste des noms des groupes</returns>
            public static String[] getNomGroupes(TreeNode NoeudLevel, String SelectedItemGroupe)
            {
                //Renvoie la liste des différents groupes présents dans le level passé en paramètre.
                ArrayList listeResultat = new ArrayList();
                foreach (TreeNode group in NoeudLevel.Nodes)
                {
                    String Nom = ((TreeViewTag)group.Tag).Name;
                    if (SelectedItemGroupe == ((TreeViewTag)group.Tag).AirportObjectType)
                    {
                        listeResultat.Add(Nom);
                    }
                }
                String[] resultats = new String[listeResultat.Count];
                for (int i = 0; i < listeResultat.Count; i++)
                {
                    resultats[i] = listeResultat[i].ToString();
                }
                return resultats;
            }
            #endregion

            #region Functions for the static scenarios.

            public static bool InsertStaticResults(String sScenarioName,
                                                   TreeNode tnStaticNode,
                                                   Hashtable htResults,
                                                   GestionDonneesHUB2SIM gdhData,
                                                   ContextMenuStrip contextMenuInput)
            {
                if (htResults == null)
                    return false;
                if (tnStaticNode == null)
                    return false;
                if (gdhData == null)
                    return false;
                foreach (TreeNode tnChilds in tnStaticNode.Nodes)
                {
                    String sName = tnChilds.Name;
                    if (!htResults.ContainsKey(sName))
                        continue;
                    if (tnChilds.Nodes.Count > 0)
                    {

                    }
                    Hashtable htResultsTmp = (Hashtable)htResults[sName];
                    foreach (String sTableName in htResultsTmp.Keys)
                    {
                        OverallTools.TreeViewFunctions.AddSortedNode(tnChilds,
                            OverallTools.TreeViewFunctions.createBranch(sTableName, sTableName,
                                TreeViewTag.getTableNode(sScenarioName, sTableName), contextMenuInput), false, true, true);
                        gdhData.AddReplaceTable(sScenarioName, (DataTable)htResultsTmp[sTableName]);
                    }
                }
                return true;
            }
            #endregion

            // >> Task #13384 Report Tree-view
            static int reportIndex = 0;
            internal const string REPORT_IMAGE_TREEVIEW_KEY = "Report_Icon_16.png";
            public static void refreshMainReportsNode(Dictionary<string, ReportParameters> reportParametersDictionary,
                TreeNodeCollection mainTreeViewNodes, GestionDonneesHUB2SIM donnees, ContextMenuStrip cmsReports)
            {
                reportIndex = 0;
                if (reportParametersDictionary == null || mainTreeViewNodes == null || donnees == null)
                {
                    //ExternFunctions.PrintLogFile("Warning: The Reports node couldn't be updated.");
                    return;
                }
                TreeNode pax2simReportsNode = OverallTools.TreeViewFunctions.getTreeNodeByNameFromCollection(mainTreeViewNodes, GlobalNames.REPORTS_MAIN_NODE_NAME);
                if (pax2simReportsNode != null)
                {
                    pax2simReportsNode.Nodes.Clear();
                    foreach (KeyValuePair<string, ReportParameters> pair in reportParametersDictionary)
                    {
                        ReportParameters report = pair.Value;
                        string reportName = pair.Key;
                        if (report == null)
                            continue;

                        TreeNode reportTreeNode = OverallTools.TreeViewFunctions
                            .createBranch(reportName, reportName, TreeViewTag.getDirectoryNode(reportName), cmsReports);
                        pax2simReportsNode.Nodes.Add(reportTreeNode);

                        if (reportTreeNode != null)
                        {
                            int reportImageIndex = getTreeviewImageByImageName(reportTreeNode.TreeView, REPORT_IMAGE_TREEVIEW_KEY);
                            if (reportImageIndex != -1)
                            {
                                reportTreeNode.ImageIndex = reportImageIndex;
                                reportTreeNode.SelectedImageIndex = reportImageIndex;
                            }
                        }
                        if (report.tv_CustomTree != null)
                        {
                            for (int i = 0; i < report.tv_CustomTree.Nodes.Count; i++)
                            {
                                TreeNode reportChildNode = ((TreeNode)report.tv_CustomTree.Nodes[i]);
                                TreeNode newReportChildNode = OverallTools.TreeViewFunctions.createBranch(reportChildNode.Name, reportChildNode.Text, reportChildNode.Tag, cmsReports);
                                reportTreeNode.Nodes.Add(newReportChildNode);
                                OverallTools.TreeViewFunctions.copyChildsWithContextMenu(newReportChildNode, reportChildNode, donnees, true, true, cmsReports);
                            }
                        }
                    }
                }
            }
            public static TreeNode getTreeNodeByNameFromCollection(TreeNodeCollection sourceNodes, string searchedNodeName)
            {
                if (sourceNodes != null)
                {
                    foreach (TreeNode node in sourceNodes)
                    {
                        if (node.Name == searchedNodeName)
                            return node;
                    }
                }
                return null;
            }

            public static int getTreeviewImageByImageName(TreeView treeview, string imageKey)
            {
                int index = -1;
                if (treeviewHasImages(treeview)
                    && treeviewHasImage(treeview, imageKey))
                {
                    index = treeview.ImageList.Images.IndexOfKey(imageKey);
                }
                return index;
            }

            public static bool treeviewHasImages(TreeView treeview)
            {
                if (treeview != null && treeview != null
                    && treeview.ImageList != null && treeview.ImageList.Images != null)
                {
                    return true;
                }
                return false;
            }

            public static bool treeviewHasImage(TreeView treeview, string imageKey)
            {
                if (treeviewHasImages(treeview))
                {
                    return treeview.ImageList.Images.ContainsKey(imageKey);
                }
                return false;
            }

            public static TreeNode getGlobalChartNodeByUniqueName(TreeNode root, string globalChartName)
            {
                if (hasChartTag(root) && root.Name == globalChartName)
                {
                    return root;
                }
                foreach (TreeNode node in root.Nodes)
                {
                    TreeNode nodeFound = getGlobalChartNodeByUniqueName(node, globalChartName);
                    if (nodeFound != null)
                    {
                        return nodeFound;
                    }
                }
                return null;
            }

            private static bool hasChartTag(TreeNode node)
            {
                if (node == null)
                {
                    return false;
                }
                TreeViewTag tvt = (TreeViewTag)node.Tag;
                if (tvt != null && tvt.isChartNode)
                {
                    return true;
                }
                return false;
            }
            // << Task #13384 Report Tree-view

            public static void refreshDocumentsNode(List<string> documentTableNames, TreeNodeCollection mainTreeViewNodes,
                GestionDonneesHUB2SIM donnees, ContextMenuStrip cmsDocument)    // >> Task #16578 PAX2SIM - Documents - new node in main tree-view
            {
                if (documentTableNames == null || mainTreeViewNodes == null || donnees == null)
                    return;
                TreeNode pax2simDocumentsNode = OverallTools.TreeViewFunctions.getTreeNodeByNameFromCollection(mainTreeViewNodes, GlobalNames.DOCUMENTS_MAIN_NODE_NAME);
                if (pax2simDocumentsNode == null)
                    return;
                pax2simDocumentsNode.Nodes.Clear();
                foreach (string documentTableName in documentTableNames)
                {
                    DataTable documentTable = donnees.getTable("Input", documentTableName);
                    if (documentTable != null)
                    {
                        TreeNode documentTableNode = OverallTools.TreeViewFunctions
                            .createBranch(documentTable.TableName, documentTable.TableName, TreeViewTag.getTableNode("Input", documentTable.TableName), cmsDocument);
                        pax2simDocumentsNode.Nodes.Add(documentTableNode);
                    }
                }
            }

            public static TreeNode addDocumentTableNode(DataTable documentTable, TreeView mainTreeView, ContextMenuStrip cmsDocument)
            {
                TreeNode newDocumentNode = OverallTools.TreeViewFunctions
                    .createBranch(documentTable.TableName, documentTable.TableName, TreeViewTag.getTableNode("Input", documentTable.TableName), cmsDocument);
                OverallTools.TreeViewFunctions.AddSortedNode(mainTreeView.Nodes[mainTreeView.Nodes.Count - 1], newDocumentNode);
                return newDocumentNode;
            }


        }
        #endregion

        #region La classe FonctionUtiles
        public static class FonctionUtiles
        {

#if !(UNIKEY_PROTECTION)
            [DllImport("FonctionsCritiques.dll")]
            public static unsafe extern bool o(String a);
#endif
            private static String beginHTMLcss = "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\">\n\n<html>\n<head>\n     <link rel=\"stylesheet\" type=\"text/css\" href=\"../report.css\">\n</head>\n<body>\n\n";
            private static String beginHTML = "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\">\n\n<html>\n<head></head>\n<body>\n\n";
            private static String endHTML = "\n\n</body></html>";

            #region Cursor

            public struct IconInfo
            {
                public bool fIcon;
                public int xHotspot;
                public int yHotspot;
                public IntPtr hbmMask;
                public IntPtr hbmColor;
            }

            [DllImport("user32.dll")]
            [return: MarshalAs(UnmanagedType.Bool)]
            public static extern bool GetIconInfo(IntPtr hIcon, ref IconInfo pIconInfo);

            [DllImport("user32.dll")]
            public static extern IntPtr CreateIconIndirect(ref IconInfo icon);
            /// <summary>
            /// Function that convert the given image into a cursor.
            /// </summary>
            /// <param name="iImg">Image to be converted</param>
            /// <param name="xHotSpot">x position of the hotspot</param>
            /// <param name="yHotSpot">y position of the hotspot</param>
            /// <returns>Converted cursor.</returns>
            public static Cursor CreateCursor(Image iImg, int xHotSpot, int yHotSpot)
            {
                Bitmap bmp = new Bitmap(iImg);
                IntPtr ptr = bmp.GetHicon();
                IconInfo tmp = new IconInfo();
                GetIconInfo(ptr, ref tmp);
                tmp.xHotspot = xHotSpot;
                tmp.yHotspot = yHotSpot;
                tmp.fIcon = false;
                ptr = CreateIconIndirect(ref tmp);
                return new Cursor(ptr);
            }
            /// <summary>
            /// Function that convert the given image into a cursor.
            /// </summary>
            /// <param name="iImg">Image to be converted</param>
            /// <returns>Converted cursor.</returns>
            public static Cursor CreateCursor(Image iImg)
            {
                Bitmap tmp = new Bitmap(iImg);
                IntPtr ptr = tmp.GetHicon();
                return new Cursor(ptr);
            }
            #endregion


            internal static String CrypteString(String sValue, String sSentence)
            {
                if ((sValue == null) || sValue.Length == 0)
                    return null;
                Byte[] bValue = new byte[sValue.Length];

                int iHashCode = sValue.GetHashCode();
                for (int i = 0; i < sValue.Length; i++)
                {
                    bValue[i] = (Byte)((int)sValue[i]);
                }
                Byte[] btmp = CrypteString(bValue, sSentence, false, iHashCode);
                bValue = null;
                bValue = CrypteString(btmp, sSentence, true, iHashCode);
                btmp = null;
                String sResult = "";
                for (int i = 0; i < bValue.Length; i++)
                {
                    char c = (char)((int)bValue[i]);
                    if (c == '\0')
                        c = 'ù';
                    sResult += c;
                }
                return sResult;
            }
            private static Byte[] CrypteString(Byte[] sValue, String sSentence, bool bReverse, int iHashcodes)
            {
                int iSum = 0;
                for (int i = 0; i < sValue.Length; i++)
                {
                    iSum += (int)sValue[i];
                }
                int iLenght = 64;
                int iCurrent = 0;
                if (bReverse)
                    iCurrent = iLenght - 1;
                Byte[] sBuffer = new Byte[iLenght];
                int iIndexValue = 0;
                Random rd = new Random(iSum * iHashcodes);
                int iOldValue = rd.Next(256);
                while ((iCurrent < iLenght) && (iCurrent >= 0))
                {
                    //char cNewchar = sValue[iIndexValue];
                    char cKey = sSentence[iOldValue % sSentence.Length];
                    Byte bCrypted = sValue[iIndexValue];// (Byte)((int)cNewchar);
                    Byte bKey = (Byte)((int)cKey);
                    bCrypted = (Byte)(bCrypted | bKey);
                    bCrypted = (Byte)(bCrypted & rd.Next(256));
                    if ((rd.Next(2) == 0) && (((int)bCrypted) < 128))
                        bCrypted = (Byte)(bCrypted + rd.Next(128));

                    iOldValue = rd.Next(256) | (int)bCrypted;
                    if (bCrypted == 0)
                        bCrypted = (Byte)(iLenght % 256);
                    sBuffer[iCurrent] = bCrypted;
                    if (!bReverse)
                        iCurrent++;
                    else
                        iCurrent--;
                    iIndexValue++;
                    if (iIndexValue >= sValue.Length)
                        iIndexValue = 0;
                }
                return sBuffer;
            }
            public static String toHexa(int Value)
            {
                String Resultat = "";
                if (Value < 0)
                    return "";
                int Dividende = Value;
                int Quotient;
                int Reste;
                do
                {
                    Quotient = Dividende / 16;
                    Reste = Dividende % 16;
                    switch (Reste)
                    {
                        case 10:
                            Resultat = "A" + Resultat;
                            break;
                        case 11:
                            Resultat = "B" + Resultat;
                            break;
                        case 12:
                            Resultat = "C" + Resultat;
                            break;
                        case 13:
                            Resultat = "D" + Resultat;
                            break;
                        case 14:
                            Resultat = "E" + Resultat;
                            break;
                        case 15:
                            Resultat = "F" + Resultat;
                            break;
                        default:
                            Resultat = Reste + Resultat;
                            break;
                    }
                    Dividende = Quotient;
                } while (Quotient != 0);
                return Resultat;
            }

            public static String toHexa(Color color)
            {
                return toHexa(color.R) + toHexa(color.G) + toHexa(color.B);
            }


            /// <summary>
            /// Converts an hexadecimal color to a Color.
            /// </summary>
            /// <param name="hexa">hexadecimal color (ex: A144EF)</param>
            /// <returns></returns>
            public static int[] fromHexa(String hexa)
            {
                return new int[3] {
                    HexaToInt(hexa.Substring(0, 2)),
                    HexaToInt(hexa.Substring(2, 2)),
                    HexaToInt(hexa.Substring(4, 2))
                };
            }
            public static int HexaToInt(String hexa)
            {
                int result = 0;
                int pow = 0;
                for (int i = hexa.Length; i > 0; i--)
                {
                    char c = hexa[i - 1];
                    int n = 0;
                    if (c < 58) n = c - 48; // chiffre
                    else if (c < 71) n = c - 55; // lettre majuscule
                    else n = c - 87; // lettre muniscule
                    result += n * (int)Math.Pow(16, pow++);
                }
                return result;
            }

            internal static Object ConvertObject(Object obj, Type tDestinationType)
            {
                if (obj == null)
                    return null;
                if (obj.GetType() == tDestinationType)
                    return obj;
                if ((tDestinationType == typeof(String)) ||
                    (tDestinationType == typeof(string)))
                    return obj.ToString();
                if (tDestinationType == typeof(DateTime))
                {
                    DateTime dtResult;
                    if (!DateTime.TryParse(obj.ToString(), out dtResult))
                        return null;
                    return dtResult;
                }
                if (tDestinationType == typeof(TimeSpan))
                {
                    if (obj.GetType() == typeof(DateTime))
                        return ((DateTime)obj).TimeOfDay;
                    TimeSpan tsResult;
                    if (!TimeSpan.TryParse(obj.ToString(), out tsResult))
                        return null;
                    return tsResult;
                }
                if ((tDestinationType == typeof(Double)) ||
                    (tDestinationType == typeof(double)))
                {
                    Double dResult;
                    if (!Double.TryParse(obj.ToString(), out dResult))
                        return 0;
                    return dResult;
                }
                if ((tDestinationType == typeof(int)) ||
                    (tDestinationType == typeof(Int32)))
                {
                    Int32 iResult;
                    if (!Int32.TryParse(obj.ToString(), out iResult))
                        return 0;
                    return iResult;
                }
                if (tDestinationType == typeof(Int16))
                {
                    Int16 iResult;
                    if (!Int16.TryParse(obj.ToString(), out iResult))
                        return 0;
                    return iResult;
                }
                if (tDestinationType == typeof(Int64))
                {
                    Int64 iResult;
                    if (!Int64.TryParse(obj.ToString(), out iResult))
                        return 0;
                    return iResult;
                }
                if ((tDestinationType == typeof(bool)) ||
                    tDestinationType == typeof(Boolean))
                {
                    if ((obj.GetType() == typeof(Double)) ||
                        (obj.GetType() == typeof(double)) ||
                        (obj.GetType() == typeof(int)) ||
                        (obj.GetType() == typeof(Int32)) ||
                        (obj.GetType() == typeof(Int16)) ||
                        (obj.GetType() == typeof(Int64)))
                        return ((Double)ConvertObject(obj, typeof(Double)) != 0);
                    Boolean bResult;
                    if (!Boolean.TryParse(obj.ToString(), out bResult))
                        return 0;
                    return bResult;
                }
                return obj;
            }

            /// <summary>
            /// Convert the string representation of a group to an Automod index representation
            /// </summary>
            /// <param name="sGroupName">String representation</param>
            /// <returns></returns>
            public static Int32 toGroupRepresentation(String sGroupName)
            {
                int[] res = OverallTools.DataFunctions.AnalyzeGroupName(sGroupName);
                if (res == null)
                    return -1;
                int nb = (res[0] - 1) * GestionDonneesHUB2SIM.NbGroupes * GestionDonneesHUB2SIM.NbTypes + (res[2] - 1) * GestionDonneesHUB2SIM.NbGroupes + res[3];
                return nb;
            }

            #region Les fonctions pour convertir des distances en des notions de temps et vice versa
            private static Double coefficient = 1.0;
            public static String DistanceInitial = "m";
            public static Double Tolerance = 5.0;
            public static void setCoefficient(Double speed, String TimeUnit, Double Tolerance_, String DistanceInitial_)
            {
                DistanceInitial = DistanceInitial_;
                Tolerance = Tolerance_;
                if (speed == 0)
                {
                    coefficient = 0;
                    Tolerance = 0;
                    return;
                }
                Double coef = 1;
                if (TimeUnit == "Seconds")
                {
                    coef = 1.0; /* / 60.0*/
                }
                else if (TimeUnit == "Hours")
                {
                    coef = 3600;
                }
                else
                {
                    coef = 60;
                }
                coefficient = coef / speed;

            }
            public static Double ConvertToTime(Double distance)
            {
                return distance * coefficient;
            }
            public static Double ConvertToDistance(Double time)
            {
                if (coefficient == 0)
                    return 0;
                return time / coefficient;
            }
            #endregion

            #region les différentes fonctions qui ont un rapport avec les couleurs où les images
            /// <summary>
            /// Uns sequence de couleurs définie pour faciliter lutilisation des couleurs pour les graphiques.
            /// </summary>
            private static Color[] Couleurs = {
                Color.Magenta,
                Color.GreenYellow,
                Color.Yellow,
                Color.Orange,
                Color.Red,
                Color.LightBlue,
                Color.Cyan,
                Color.SpringGreen,
                Color.LightSalmon,
                Color.MediumPurple,
                Color.Pink,
                Color.SandyBrown,
                Color.Silver ,
                Color.FromArgb(-9577),
                Color.FromArgb(-34953),
                Color.FromArgb(-2058242),
                Color.LightGray,
                Color.LightSkyBlue,
                Color.LightYellow,
                Color.MediumSlateBlue,
                Color.MediumVioletRed,
                Color.MintCream,
                Color.LightSteelBlue,
                Color.CadetBlue};

            private static Color[] CouleursStroke = {
                Color.FromArgb(50,50,255),
                Color.FromArgb(50,255,50),
                Color.FromArgb(255,255,50),
                Color.FromArgb(255,81,50),
                Color.FromArgb(210,210,210),
                Color.FromArgb(255,50,50),
                Color.FromArgb(50,50,255),
                Color.LightGreen,
                Color.LightSalmon,
                Color.LightYellow,
                Color.Pink,
                Color.SandyBrown,
                Color.Silver,
                Color.FromArgb(-26266),
                Color.FromArgb(-60653),
                Color.FromArgb(-917323),
                Color.LightBlue,
                Color.LightSkyBlue,
                Color.MediumPurple,
                Color.MediumSlateBlue,
                Color.MediumVioletRed,
                Color.MintCream,
                Color.LightSteelBlue,
                Color.CadetBlue};
            /// <summary>
            /// Fonction qui permet de dessiner une image à la taille spécifiée et avec un dégradé souhaité
            /// </summary>
            /// <param name="width">Largeur de l'image</param>
            /// <param name="height">Hauteur de l'image</param>
            /// <param name="couleur1">Premère couleur</param>
            /// <param name="couleur2">Seconde couleur</param>
            /// <param name="angle">Orientation du dégradé</param>
            /// <returns>Renvoie une image à la taille spécifiée</returns>
            public static Image dessinerFondEcran(int width, int height, Color couleur1, Color couleur2, float angle)
            {
                //Si les tailles sont mauvaises, alors on renvoir une image null.
                if (width == 0 || height == 0) return null;
                //Création de la nouvelle image
                Image img = new Bitmap(width, height);
                //Initialisation du format de la nouvelle image
                GraphicsUnit formats = GraphicsUnit.Pixel;
                RectangleF rect = img.GetBounds(ref formats);
                //Création d'un nouveau graphique afin de pouvoir desiner la nouvelle image.
                Graphics g = Graphics.FromImage(img);
                //Création d'une brosse de dessin avec les paramêtres spécifiés et dessin de la nouvelle image
                LinearGradientBrush brush = new LinearGradientBrush(rect, couleur1, couleur2, angle);
                g.FillRectangle(brush, rect);
                return img;
            }

            public static Image dessinerFleche(int Width, int Height, Color couleur, bool Up, bool right)
            {
                //Si les tailles sont mauvaises, alors on renvoir une image null.
                if (Width == 0 || Height == 0) return null;
                //Création de la nouvelle image
                Image img = new Bitmap(Width, Height);
                //Initialisation du format de la nouvelle image
                GraphicsUnit formats = GraphicsUnit.Pixel;
                RectangleF rect = img.GetBounds(ref formats);
                //Création d'un nouveau graphique afin de pouvoir desiner la nouvelle image.
                Graphics g = Graphics.FromImage(img);
                //Création d'une brosse de dessin avec les paramêtres spécifiés et dessin de la nouvelle image

                Pen p = new Pen(couleur, 3);
                p.EndCap = System.Drawing.Drawing2D.LineCap.Custom;
                p.CustomEndCap = new System.Drawing.Drawing2D.AdjustableArrowCap(4, 4);

                Point Begin, End;
                Begin = new Point(5, 5);
                End = new Point(5, 5);
                if (!Up)
                {
                    Begin.Y = Height - 5;
                }
                else
                {
                    End.Y = Height - 5;
                }
                if (!right)
                {
                    End.X = Width - 5;
                }
                else
                {
                    Begin.X = Width - 5;
                }
                LinearGradientBrush brush = new LinearGradientBrush(rect, Color.FromArgb(0, 0, 0, 0), Color.FromArgb(0, 0, 0, 0), (float)0);
                g.FillRectangle(brush, rect);
                g.DrawLine(p, Begin, End);
                return img;
            }

            public static ToolStripMenuItem AddSortedItem(ToolStripMenuItem cmsMenu, String sName)
            {
                return AddSortedItem(cmsMenu, sName, 0);
            }
            public static ToolStripMenuItem AddSortedItem(ToolStripMenuItem cmsMenu, String sName, int iFixedButtons)
            {

                if (cmsMenu.DropDownItems.Count <= iFixedButtons)
                {
                    cmsMenu.DropDownItems.Add(sName);
                    return (ToolStripMenuItem)cmsMenu.DropDownItems[cmsMenu.DropDownItems.Count - 1];
                }
                int i = iFixedButtons;
                for (; i < cmsMenu.DropDownItems.Count; i++)
                {
                    String sCurrentNodeName = cmsMenu.DropDownItems[i].Text;

                    int iComp = FonctionUtiles.CompareString(sCurrentNodeName, sName, true);
                    if (iComp >= 0)
                        break;
                }
                cmsMenu.DropDownItems.Insert(i, new ToolStripMenuItem(sName));
                return (ToolStripMenuItem)cmsMenu.DropDownItems[i];
            }

            public static void AddSortedItem(ComboBox cb_Combo, Object sObject)
            {
                if (cb_Combo.Items.Count == 0)
                {
                    cb_Combo.Items.Add(sObject);
                    return;
                }
                int i = 0;
                String sObjectName = sObject.ToString();
                for (; i < cb_Combo.Items.Count; i++)
                {
                    String sCurrentNodeName = cb_Combo.Items[i].ToString();

                    int iComp = FonctionUtiles.CompareString(sCurrentNodeName, sObjectName, true);
                    if (iComp >= 0)
                        break;
                }
                cb_Combo.Items.Insert(i, sObject);
            }

            public static void MajBackground(Form fenetre)
            {
                if (fenetre == null)
                    return;
                fenetre.BackgroundImage = dessinerFondEcran(100, 100, PAX2SIM.Couleur1, PAX2SIM.Couleur2, PAX2SIM.Angle);
                fenetre.BackgroundImageLayout = ImageLayout.Stretch;
                fenetre.Refresh();
            }
            public static void MajBackground(Form fenetre, int iWidth, int iHeight)
            {
                if (fenetre == null)
                    return;
                fenetre.BackgroundImage = dessinerFondEcran(iWidth, iHeight, PAX2SIM.Couleur1, PAX2SIM.Couleur2, PAX2SIM.Angle);
                fenetre.BackgroundImageLayout = ImageLayout.Stretch;
                fenetre.Refresh();
            }
            /// <summary>
            /// Fonction qui permet de récupérer la couleur située dans la sequence à l'index spécifié.
            /// Si l'index est trop grand par rapport au nombre de couleur contenu dans la séquence, alors
            /// un modulo est fait.
            /// </summary>
            /// <param name="iIndex">index de la couleur</param>
            /// <returns>Couleur renvoyée</returns>
            public static Color getColor(int iIndex)
            {
                return Couleurs[iIndex % Couleurs.Length];
            }
            public static Color getColorStroke(int iIndex)
            {
                return CouleursStroke[iIndex % CouleursStroke.Length];
            }
            public static int getUnusedColor(ArrayList alList)
            {
                if (alList == null)
                    return 0;
                bool bfind;
                for (int i = 0; i < Couleurs.Length; i++)
                {

                    // << Task #7869 Chart - color for the 2nd column used
                    if (Couleurs[i] == Color.GreenYellow)
                        continue;
                    // >> Task #7869 Chart - color for the 2nd column used
                    bfind = false;
                    foreach (Nevron.GraphicsCore.NColorFillStyle ncfstmp in alList)
                    {
                        if (Couleurs[i].ToArgb() == ncfstmp.Color.ToArgb())
                        {
                            bfind = true;
                            break;
                        }
                    }
                    if (!bfind)
                        return i;
                }
                return 0;
            }

            /// <summary>
            /// Function that will create a personilze image from the given image and 
            /// the group. That would put a different color following the terminal, the
            /// level and the index of groupe.
            /// </summary>
            /// <param name="iImageSource"></param>
            /// <param name="sGroupName"></param>
            /// <returns></returns>
            internal static Image CreateSimul8Image(Image iImageSource, String sGroupName)
            {
                int[] iTerminal = DataFunctions.AnalyzeGroupName(sGroupName);
                if ((iTerminal == null) || (iTerminal.Length != 4))
                {
                    return null;
                }
                return CreateSimul8Image(iImageSource, iTerminal[0], iTerminal[1], iTerminal[3]);
            }

            internal static Image CreateSimul8Image(Image iImageSource, int iTerminal, int iLevel, int iIndexGroup)
            {
                if (iImageSource == null)
                    return null;

                //Width of the original image
                int iWidth = iImageSource.Width;

                //Half of the width of the original image
                int iHalfWidth = (iWidth / 2);

                //Width of the new image
                int iNewWidth = iWidth + iHalfWidth;

                //New image
                Image iImageDestination = new Bitmap(iNewWidth, iNewWidth);
                Graphics gGraphics = Graphics.FromImage(iImageDestination);

                //We draw the origine image in the new image
                gGraphics.DrawImage(iImageSource, new Point(0, iHalfWidth));


                Brush b = new SolidBrush(getColor(iTerminal));
                gGraphics.FillRectangle(b, 0, 0, iHalfWidth, iHalfWidth);

                b = new SolidBrush(getColor(iLevel));
                gGraphics.FillRectangle(b, iHalfWidth, 0, iHalfWidth, iHalfWidth);

                Color tmp = getColor(iIndexGroup);
                if (iIndexGroup == 0)
                    tmp = Color.White;
                b = new SolidBrush(tmp);
                gGraphics.FillRectangle(b, iWidth, 0, iHalfWidth, iNewWidth);


                Pen p = new Pen(Color.Black, 1);
                gGraphics.DrawLine(p, new Point(0, 0), new Point(0, iImageDestination.Width - 1));
                gGraphics.DrawLine(p, new Point(0, 0), new Point(iImageDestination.Height - 1, 0));
                gGraphics.DrawLine(p, new Point(0, iImageDestination.Width - 1), new Point(iImageDestination.Height - 1, iImageDestination.Width - 1));
                gGraphics.DrawLine(p, new Point(iImageDestination.Height - 1, iImageDestination.Width - 1), new Point(iImageDestination.Height - 1, 0));
                gGraphics.DrawLine(p, new Point(iWidth, 0), new Point(iWidth, iImageDestination.Height));
                gGraphics.DrawLine(p, new Point(0, iHalfWidth), new Point(iWidth, iHalfWidth));
                gGraphics.DrawLine(p, new Point(iHalfWidth, 0), new Point(iHalfWidth, iHalfWidth));


                b = new SolidBrush(Color.Black);
                gGraphics.DrawString("T" + iTerminal.ToString(), new Font("Arial", 6, FontStyle.Bold), b, new PointF(2, 2));

                gGraphics.DrawString("L" + iLevel.ToString(), new Font("Arial", 6, FontStyle.Bold), b, new PointF(iHalfWidth + 2, 2));

                if (iIndexGroup != 0)
                {
                    gGraphics.RotateTransform(90.0f, MatrixOrder.Append);
                    gGraphics.TranslateTransform(0, -iWidth - iHalfWidth);
                    gGraphics.DrawString("G" + iIndexGroup.ToString(), new Font("Arial", 6, FontStyle.Bold), b, new PointF(iHalfWidth, 2));
                }
                gGraphics.Flush();
                return iImageDestination;
            }
            private static Color getColorFromValue(int iNumber)
            {
                int irColor = 0;
                int igColor = 0;
                int ibColor = 200;
                if (iNumber <= 2)
                {
                    ibColor += iNumber * 25;
                }
                else if (iNumber <= 8)
                {
                    ibColor = 255;
                    igColor = 100 + 25 * (iNumber - 2);
                }
                else
                {
                    ibColor = 255;
                    igColor = 255;
                    irColor = 25 * (iNumber - 8);
                }
                return Color.FromArgb(irColor, igColor, ibColor);
            }
            #endregion

            #region Fonctions pour exporte au format HTML la table spécifiée.
            public static void ExportHTML(DataTable table, String SavePath)
            {

                if (table == null)
                    return;
                //if (!System.IO.File.Exists(SavePath))
                //    return;

                System.IO.StreamWriter monEcrivain = new System.IO.StreamWriter(SavePath);
                monEcrivain.WriteLine(beginHTMLcss);
                monEcrivain.WriteLine("<TABLE BORDER=\"1\">");
                monEcrivain.WriteLine("<TR>");
                foreach (DataColumn colonne in table.Columns)
                {
                    monEcrivain.WriteLine("\t<TH>" + colonne.ColumnName + "</TH>");
                }
                monEcrivain.WriteLine("</TR>");

                foreach (DataRow ligne in table.Rows)
                {
                    monEcrivain.WriteLine("<TR>");
                    for (int i = 0; i < table.Columns.Count; i++)
                    {
                        monEcrivain.WriteLine("\t<TD BGCOLOR =\"#EAFFFF\">" + ligne[i].ToString() + "</TD>");
                    }
                    monEcrivain.WriteLine("</TR>");
                }
                monEcrivain.WriteLine(endHTML);
                monEcrivain.Close();
            }

            /// <summary>
            /// Fonction pour enregister une DataTable au format html.
            /// </summary>
            /// <param name="table"></param>
            /// <param name="SavePath">Emplacement où créer le fichier html.</param>
            /// <param name="vmMode"></param>
            public static void ExportHTML(DataTable table, String SavePath, VisualisationMode vmMode)
            {

                if (table == null)
                    return;
                //if (!System.IO.File.Exists(SavePath))
                //    return;

                System.IO.StreamWriter monEcrivain = new System.IO.StreamWriter(SavePath);
                monEcrivain.WriteLine(beginHTMLcss);
                monEcrivain.WriteLine(GetHtmlTable(table, vmMode));
                monEcrivain.WriteLine(endHTML);

                monEcrivain.Close();
            }

            /// <summary>
            /// Fonction qui crée une table html a partir d'une DataTable.
            /// </summary>
            /// <returns>Le code html généré</returns>
            public static String GetHtmlTable(DataTable table, VisualisationMode vmMode)
            {

                if (table == null)
                    return "";

                StringBuilder html = new StringBuilder();

                html.Append("<TABLE BORDER=\"1\">");
                html.Append("<TR>");
                foreach (DataColumn colonne in table.Columns)
                {
                    html.Append("\t<TH>" + colonne.ColumnName + "</TH>");
                }
                html.Append("</TR>");

                bool bUseMode = false;
                bool bUseError = false;
                String DefaultColor = "FFFFFF";
                if ((vmMode != null) && (vmMode.ConditionnalFormatClass != null) && (vmMode.ConditionnalFormatClass[0] != null))
                {
                    bUseMode = true;
                    DefaultColor = toHexa(vmMode.BackgroundDefaultColor);
                    if ((vmMode.ConditionnalFormatClass[0].GetType() == typeof(ConditionnalFormatErrors)) || vmMode.ConditionnalFormatClass[0].GetType() == typeof(ConditionnalFormatLine))
                    {
                        bUseError = true;
                    }
                }
                int j = 0;
                foreach (DataRow ligne in table.Rows)
                {
                    html.Append("<TR>");
                    for (int i = 0; i < table.Columns.Count; i++)
                    {
                        String sText = ligne[i].ToString();
                        html.Append("\t<TD");
                        if (bUseMode)
                        {
                            html.Append(" BGCOLOR =\"#");
                            if (bUseError)
                            {

                                html.Append(toHexa(vmMode.getVisualisationMode(i, j)));
                                sText = vmMode.getPrefixe(i, j) + sText + vmMode.getSuffixe(i, j);
                            }
                            else
                            {
                                html.Append(toHexa(vmMode.getVisualisationMode(i, ligne[i])));
                            }
                            html.Append("\"");
                        }
                        html.Append(">" + ligne[i].ToString() + "</TD>\n");
                    }
                    html.Append("</TR>");
                    j++;
                }
                html.Append("</TABLE>");

                return html.ToString();
            }

            internal static String AsumptionToHtml(List<String> review)
            {
                StringBuilder note = new StringBuilder();
                note.Append(beginHTML); //"<html><body>");
                foreach (String str in review)
                    note.Append(str).Append("<BR />\n");
                note.Append(endHTML);   //"</body></html>");
                return note.ToString();
            }
            #endregion

            #region Fonctions pour l'export au format HTML
            public static String CreatePageHTML(String Contenu)
            {
                String Result = "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\">\n\n";
                Result += "<HTML>\n";
                Result += "<head>\n";
                Result += "     <LINK rel=\"stylesheet\" type=\"text/css\" href=\"report.css\">\n";
                Result += "</head>\n";
                Result += "<body>\n";
                Result += "<font face=\"arial\">\n";
                Result += Contenu;
                Result += "</font>\n";
                Result += "</body>";

                return Result;
            }
            public static String CreateTreePageHTML(String Contenu)
            {
                String Result = "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\">\n\n";
                Result += "<html>\n";
                Result += "<head>\n";
                Result += "     <LINK rel=\"stylesheet\" type=\"text/css\" href=\"report.css\">\n";
                Result += "     <script type=\"text/javascript\" src=\"arbo.js\"></script>\n";
                Result += "</head>\n";
                Result += "<body>\n";
                Result += Contenu;
                Result += "\n<script type=\"text/javascript\">\n" +  // initialise l'arborescence (ferme l'arbre)
                          "         window.onLoad = collapseMultiple();\n</script>\n";
                Result += "</body></html>";

                return Result;
            }

            /// <summary>
            /// Fontion pour obtenir uniquement la partie du html qui ce trouve dans la balise "Body"
            /// </summary>
            /// <param name="htmlPageCode"></param>
            /// <returns></returns>
            internal static String GetHtmlContent(String htmlPageCode)
            {
                int iDebut = 0;
                int iFin = htmlPageCode.Length;

                String[] bodyTag = new String[] { "<body>", "<BODY>" };
                foreach (String tag in bodyTag)
                {
                    int i = htmlPageCode.IndexOf(tag);
                    if (i != -1)
                    {
                        iDebut = i + tag.Length;
                        break;
                    }
                }


                String[] endBodyTag = new String[] { "</body>", "</BODY>" };
                foreach (String tag in endBodyTag)
                {
                    int i = htmlPageCode.LastIndexOf(tag);
                    if (i != -1)
                    {
                        iFin = i;
                        break;
                    }
                }

                return htmlPageCode.Substring(iDebut, iFin - iDebut);
            }

            /// <summary>
            /// Fonction qui extrait du text d'un code html.
            /// </summary>
            /// <param name="html"></param>
            /// <returns>Le texte extrait</returns>
            public static String HTMLToPlainText(String html)
            {
                String plainText = "";


                // Replace HTML newlines with plaintext newlines
                plainText = Regex.Replace(html, @"<br[\s/]*>|</p>", "\n", RegexOptions.IgnoreCase);

                // Remove all HTML tags
                plainText = Regex.Replace(plainText, @"<head[^>]*>.*?</head>", "", RegexOptions.IgnoreCase);
                plainText = Regex.Replace(plainText, @"<script[^>]*>.*?</script>", "", RegexOptions.IgnoreCase);
                plainText = Regex.Replace(plainText, @"<[^>]+>|</\w+>", "", RegexOptions.IgnoreCase);

                // Replace &lt; and &gt;
                plainText.Replace("<", "&lt;").Replace(">", "&gt;");

                // Remove began space
                plainText = plainText.Trim();

                return plainText;
            }
            #endregion Fonctions pour l'export au format HTML

            #region Les fonctions pour la lecture et l'écriture des fichiers des tables.


            /// <summary>
            /// Fonction qui se charge de lire le contenu d'un fichier et de le charger dans une table.
            /// </summary>
            /// <param name="table">La table de destination </param>
            /// <param name="columnsName">La liste des colonnes qui doivent être contenues dans la table</param>
            /// <param name="columnsType">Les types des colonnes à charger</param>
            /// <param name="nomFichier">Le nom du fichier, avec tout le chemin d'accès.</param>
            /// <param name="Separateur">Le type de séparateur utilisé pour séparer les champs</param>
            /// <param name="bAllowAddDoubleColumns">Booléen indiquant si l'on peut ajouter des champs contenant des nombres</param>
            /// <param name="bAllowAddStringColumns">Booléen indiquant si l'on peut ajouter des champs contenant des chaines de caractères</param>
            /// <param name="bAllowAddBoolColumns">Booléen indiquant si l'on peut ajouter des champs contenant des booléens</param>
            /// <param name="bRessources">Booléen indiquant si le fichier est en réalité une ressources stockée dans l'application</param>
            /// <returns>retourne un booléen indiquant si la lecture s'est bien déroulée</returns>
            public static bool LectureFichier(DataTable table,
                                              String[] columnsName,
                                              Type[] columnsType,
                                              String nomFichier,
                                              String Separateur,
                                              bool bAllowAddDoubleColumns,
                                              bool bAllowAddStringColumns,
                                              bool bAllowAddBoolColumns,
                                              bool bRessources,
                                              bool bIgnored,
                                              ArrayList alListeErrors)
            {
                //Fonction permettant le chargement dans la table spécifiée du contenu du fichier.
                //Le fichier se trouve au format texte, avec ses colonnes séparées par des "Separateur"
                DataColumn uneColonne;
                DataRow nouvelleLigne;
                string uneLigne;
                string[] result;
                int NbLigne;
                int iNbLignesEntete = 1;
                System.IO.StreamReader monLecteur;
                if (alListeErrors == null)
                    alListeErrors = new ArrayList();
                bool bAllowAddColumns = bAllowAddDoubleColumns || bAllowAddStringColumns || bAllowAddBoolColumns;
                if (table == null)
                {
                    alListeErrors.Add("Err00001 : Invalid table for opening the file \"" + nomFichier + "\".");
                    OverallTools.ExternFunctions.PrintLogFile("Err00001 : Invalid table for opening the file \"" + nomFichier + "\".");
                    return false;
                }
                if (bRessources)
                {
                    System.Reflection.Assembly a = System.Reflection.Assembly.GetExecutingAssembly();
                    System.IO.Stream s = a.GetManifestResourceStream(nomFichier);
                    //String[] t = a.GetManifestResourceNames();
                    if (s == null)
                    {
                        alListeErrors.Add("Err00002 : The file \"" + nomFichier + "\" is not contained in the ressources file of " + OverallTools.AssemblyActions.AssemblyTitle + ".");
                        OverallTools.ExternFunctions.PrintLogFile("Err00002 : The file \"" + nomFichier + "\" is not contained in the ressources file of " + OverallTools.AssemblyActions.AssemblyTitle + ".");
                        return false;
                    }
                    monLecteur = new System.IO.StreamReader(s);
                }
                else
                {
                    if (!System.IO.File.Exists(nomFichier))
                    {
                        alListeErrors.Add("Err00003 : The file \"" + nomFichier + "\" does not exist.");
                        OverallTools.ExternFunctions.PrintLogFile("Err00003 : The file \"" + nomFichier + "\" does not exist.");
                        return false;
                    }
                    try
                    {
                        monLecteur = new System.IO.StreamReader(nomFichier);
                    }
                    catch (Exception e)
                    {
                        alListeErrors.Add("Err00004 : " + e.Message);
                        OverallTools.ExternFunctions.PrintLogFile("Err00004: LectureFichier throw an exception: " + e.Message);
                        return false;
                    }
                }
                uneLigne = monLecteur.ReadLine();
                if (uneLigne == null)
                {
                    monLecteur.Close();
                    return true;
                }
                result = uneLigne.Split(char.Parse(Separateur)).Select(p => p.Trim()).ToArray();
                //result = uneLigne.Split(new String[]{Separateur},StringSplitOptions.RemoveEmptyEntries);
                if ((columnsName != null) && (table.Columns.Count == 0))
                {
                    for (int i = 0; i < columnsName.Length; i++)
                    {
                        table.Columns.Add(columnsName[i], columnsType[i]);
                    }
                }
                if ((bAllowAddColumns) || (table.Columns.Count != 0))
                {
                    if ((result.Length < table.Columns.Count) ||
                        ((!bAllowAddColumns) && (result.Length > table.Columns.Count)))
                    {
                        monLecteur.Close();
                        alListeErrors.Add("Err00005 : The number of columns in the file \"" + nomFichier + "\" is not valid.");
                        OverallTools.ExternFunctions.PrintLogFile("Err00005 : The number of columns in the file \"" + nomFichier + "\" is not valid.");
                        return false;
                    }
                    for (int i = 0; i < result.Length; i++)
                    {
                        if (i < table.Columns.Count)
                        {
                            if (result[i] != table.Columns[i].ColumnName)
                            {
                                monLecteur.Close();
                                alListeErrors.Add("Err00006 : The column name \"" + result[i] + "\" in the file \"" + nomFichier + "\" is not valid. It must be \"" + table.Columns[i].ColumnName + "\"");
                                OverallTools.ExternFunctions.PrintLogFile("Err00006 : The column name \"" + result[i] + "\" in the file \"" + nomFichier + "\" is not valid. It must be \"" + table.Columns[i].ColumnName + "\"");
                                return false;
                            }
                        }
                        else
                        {
                            if (bAllowAddDoubleColumns)
                            {
                                table.Columns.Add(result[i], typeof(Double));
                            }
                            else if (bAllowAddStringColumns)
                            {
                                table.Columns.Add(result[i], typeof(String));
                            }
                            else if (bAllowAddBoolColumns)
                            {
                                table.Columns.Add(result[i], typeof(Boolean));
                            }
                        }
                    }
                    if (monLecteur.Peek() != -1)
                    {
                        uneLigne = monLecteur.ReadLine();
                        result = uneLigne.Split(char.Parse(Separateur));
                        if (result[0].IndexOf("System") != 0)
                        {
                            monLecteur.Close();
                            if (bRessources)
                            {
                                System.Reflection.Assembly a = System.Reflection.Assembly.GetExecutingAssembly();
                                System.IO.Stream s = a.GetManifestResourceStream(nomFichier);
                                monLecteur = new System.IO.StreamReader(s);
                            }
                            else
                            {
                                monLecteur = new System.IO.StreamReader(nomFichier);
                            }
                            uneLigne = monLecteur.ReadLine();
                        }
                        else
                        {
                            iNbLignesEntete++;
                        }
                    }
                }
                else
                {
                    for (int compteur = 0; compteur < result.Length; compteur++)
                    {
                        uneColonne = new DataColumn(result[compteur]);
                        table.Columns.Add(uneColonne);
                    }
                    if (monLecteur.Peek() != -1)
                    {
                        uneLigne = monLecteur.ReadLine();
                        result = uneLigne.Split(char.Parse(Separateur));
                        if (result[0].IndexOf("System") == 0)
                        {
                            for (int compteur = 0; compteur < result.Length; compteur++)
                            {
                                table.Columns[compteur].DataType = Type.GetType(result[compteur]);
                            }
                        }
                        else
                        {
                            monLecteur.Close();
                            monLecteur = new System.IO.StreamReader(nomFichier);
                            uneLigne = monLecteur.ReadLine();
                        }
                    }
                }
                NbLigne = 0;
                while (monLecteur.Peek() != -1)
                {
                    NbLigne++;
                    uneLigne = monLecteur.ReadLine();
                    result = uneLigne.Split(char.Parse(Separateur)).Select(p => p.Trim()).ToArray();
                    if (result.Length != table.Columns.Count)
                    {

                        if (bIgnored)
                        {
                            alListeErrors.Add("Warn00008 : The number of columns in the line \"" + ((int)NbLigne + iNbLignesEntete).ToString() + "\" in the file \"" + nomFichier + "\" is wrong. Line ignored");
                            OverallTools.ExternFunctions.PrintLogFile("Warn00008 : The number of columns in the line \"" + ((int)NbLigne + iNbLignesEntete).ToString() + "\" in the file \"" + nomFichier + "\" is wrong. Line ignored");
                            continue;
                        }
                        alListeErrors.Add("Err00007 : The number of columns in the line \"" + ((int)NbLigne + iNbLignesEntete).ToString() + "\" in the file \"" + nomFichier + "\" is wrong.");
                        OverallTools.ExternFunctions.PrintLogFile("Err00007 : The number of columns in the line \"" + ((int)NbLigne + iNbLignesEntete).ToString() + "\" in the file \"" + nomFichier + "\" is wrong.");
                        return false;
                    }
                    nouvelleLigne = table.NewRow();
                    for (int i = 0; i < result.Length; i++)
                    {
                        if (table.Columns[i].DataType == System.Type.GetType("System.String"))
                        {
                            nouvelleLigne[i] = result[i];
                        }
                        else if (table.Columns[i].DataType == System.Type.GetType("System.Double"))
                        {
                            Double dValue;
                            if (!Double.TryParse(result[i], out dValue))
                            {
                                if (result[i].ToString() == "")
                                    dValue = 0;
                                else
                                {
                                    alListeErrors.Add("Err00009 : The value in column \"" + (i + 1).ToString() + "\"in the line \"" + ((int)NbLigne + iNbLignesEntete).ToString() + "\" in the file \"" + nomFichier + "\" is not a valid numerical value.");
                                    OverallTools.ExternFunctions.PrintLogFile("Err00009 : The value in column \"" + (i + 1).ToString() + "\"in the line \"" + ((int)NbLigne + iNbLignesEntete).ToString() + "\" in the file \"" + nomFichier + "\" is not a valid numerical value.");
                                    monLecteur.Close();
                                    return false;
                                }
                            }
                            nouvelleLigne[i] = dValue;
                        }
                        else if (table.Columns[i].DataType == System.Type.GetType("System.Int32"))
                        {
                            Int32 iValue;
                            if (!Int32.TryParse(result[i], out iValue))
                                if (result[i].ToString() == "")
                                    iValue = 0;
                                else
                                {
                                    alListeErrors.Add("Err00010 : The value in column \"" + (i + 1).ToString() + "\"in the line \"" + ((int)NbLigne + iNbLignesEntete).ToString() + "\" in the file \"" + nomFichier + "\" is not a valid integer value.");
                                    OverallTools.ExternFunctions.PrintLogFile("Err00010 : The value in column \"" + (i + 1).ToString() + "\"in the line \"" + ((int)NbLigne + iNbLignesEntete).ToString() + "\" in the file \"" + nomFichier + "\" is not a valid integer value.");
                                    monLecteur.Close();
                                    return false;
                                }
                            nouvelleLigne[i] = iValue;
                        }
                        else if (table.Columns[i].DataType == System.Type.GetType("System.DateTime"))
                        {
                            if (result[i] == null || result[i] == "")   // >> Bug #14532 Pax2Sim - data table not shown                                
                                nouvelleLigne[i] = DBNull.Value;
                            else
                            {
                                DateTime dtValue;
                                if (!DateTime.TryParse(result[i], out dtValue))
                                {
                                    alListeErrors.Add("Err00011 : The value in column \"" + (i + 1).ToString() + "\"in the line \"" + ((int)NbLigne + iNbLignesEntete).ToString() + "\" in the file \"" + nomFichier + "\" is not a valid date/time value.");
                                    OverallTools.ExternFunctions.PrintLogFile("Err00011 : The value in column \"" + (i + 1).ToString() + "\"in the line \"" + ((int)NbLigne + iNbLignesEntete).ToString() + "\" in the file \"" + nomFichier + "\" is not a valid date/time value.");
                                    monLecteur.Close();
                                    return false;
                                }
                                nouvelleLigne[i] = result[i];
                            }
                        }
                        else if (/*(table.Columns[i].DataType == typeof(TimeSpanCulture)) ||*/
                           (table.Columns[i].DataType == typeof(TimeSpan)))
                        {
                            if (result[i] == null || result[i] == "")   // >> Bug #14532 Pax2Sim - data table not shown                                
                                nouvelleLigne[i] = DBNull.Value;
                            else
                            {
                                TimeSpan/*Culture*/ tsValue;
                                if (!TimeSpan/*Culture*/.TryParse(result[i], out tsValue))
                                {
                                    alListeErrors.Add("Err00012 : The value in column \"" + (i + 1).ToString() + "\"in the line \"" + ((int)NbLigne + iNbLignesEntete).ToString() + "\" in the file \"" + nomFichier + "\" is not a valid time value.");
                                    OverallTools.ExternFunctions.PrintLogFile("Err00012 : The value in column \"" + (i + 1).ToString() + "\"in the line \"" + ((int)NbLigne + iNbLignesEntete).ToString() + "\" in the file \"" + nomFichier + "\" is not a valid time value.");
                                    monLecteur.Close();
                                    return false;
                                }
                                if (table.Columns[i].DataType == typeof(TimeSpan))
                                    nouvelleLigne[i] = (TimeSpan)tsValue;
                                /*else
                                    nouvelleLigne[i] = (TimeSpanCulture)tsValue;*/
                            }

                        }
                        else if (table.Columns[i].DataType == System.Type.GetType("System.Boolean"))
                        {
                            Boolean bValue = false;
                            if (result[i].Length > 0)
                            {
                                if (!Boolean.TryParse(result[i], out bValue))
                                {
                                    Int32 iValue;
                                    if (!Int32.TryParse(result[i], out iValue))
                                    {
                                        alListeErrors.Add("Err00013 : The value in column \"" + (i + 1).ToString() + "\"in the line \"" + ((int)NbLigne + iNbLignesEntete).ToString() + "\" in the file \"" + nomFichier + "\" is not a valid boolean value.");
                                        OverallTools.ExternFunctions.PrintLogFile("Err00013 : The value in column \"" + (i + 1).ToString() + "\"in the line \"" + ((int)NbLigne + iNbLignesEntete).ToString() + "\" in the file \"" + nomFichier + "\" is not a valid boolean value.");
                                        monLecteur.Close();
                                        return false;
                                    }
                                    if (iValue != 0)
                                        bValue = true;
                                }
                            }
                            nouvelleLigne[i] = bValue;

                        }
                    }

                    try
                    {
                        table.Rows.Add(nouvelleLigne);
                    }
                    catch (Exception e)
                    {
                        //error;
                        if (bIgnored)
                        {
                            alListeErrors.Add("Warn00015 : The line \"" + ((int)NbLigne + iNbLignesEntete).ToString() + "\" in the file \"" + nomFichier + "\" hasn't been added to the table." + e.Message + " Line ignored");
                            OverallTools.ExternFunctions.PrintLogFile("Warn00015: LectureFichier throw an exception: " + e.Message);
                            continue;
                        }
                        alListeErrors.Add("Err00014 : The line \"" + ((int)NbLigne + iNbLignesEntete).ToString() + "\" in the file \"" + nomFichier + "\" hasn't been added to the table." + e.Message);
                        monLecteur.Close();
                        return false;
                    }
                }

                monLecteur.Close();
                return true;
            }

            public static bool LectureFichier(DataTable table, string NomFichier, string Separateur, ArrayList alListeErrors)
            {
                return LectureFichier(table, null, null, NomFichier, Separateur, false, false, false, false, true, alListeErrors);
            }

            internal static bool LectureFichier(DataTable table, string NomFichier, string Separateur, ArrayList alListeErrors, List<ConvertTables.ConvertColumnOutputTables> ltTraceConversion)
            {
                if ((ltTraceConversion == null) || (ltTraceConversion.Count == 0))
                {
                    return LectureFichier(table, NomFichier, Separateur, alListeErrors);
                }
                DataTable dtTmp = new DataTable(table.TableName);
                List<ConvertTables.ConvertColumnOutputTables> lsTmp = new List<ConvertTables.ConvertColumnOutputTables>();
                foreach (DataColumn Column in table.Columns)
                {
                    bool bFound = false;
                    int i = 0;
                    for (i = 0; i < ltTraceConversion.Count; i++)
                    {
                        if (ltTraceConversion[i].ColumnName == Column.ColumnName)
                        {
                            bFound = true;
                            break;
                        }
                    }
                    if (bFound)
                    {
                        dtTmp.Columns.Add(Column.ColumnName, ltTraceConversion[i].ReadingType);
                        lsTmp.Add(ltTraceConversion[i]);
                    }
                    else
                    {
                        dtTmp.Columns.Add(Column.ColumnName, Column.DataType);
                        lsTmp.Add(null);
                    }
                }
                if (!LectureFichier(dtTmp, NomFichier, Separateur, alListeErrors))
                {
                    dtTmp.Dispose();
                    dtTmp = null;
                    return false;
                }
                int iColumnsCount = dtTmp.Columns.Count;
                try
                {
                    foreach (DataRow drRow in dtTmp.Rows)
                    {
                        Object[] objNewRow = new object[iColumnsCount];
                        for (int i = 0; i < iColumnsCount; i++)
                        {
                            if (lsTmp[i] == null)
                            {
                                objNewRow[i] = drRow[i];
                                continue;
                            }
                            objNewRow[i] = lsTmp[i].Convert(drRow[i]);
                        }
                        table.Rows.Add(objNewRow);
                    }
                }
                catch (Exception e)
                {
                    alListeErrors.Add("Err00216 : Unable to convert an Output table to load in the system : " + e.Message);
                    OverallTools.ExternFunctions.PrintLogFile("Err00216: LectureFichier throw an exception: " + e.Message);
                    return false;
                }
                table.AcceptChanges();
                return true;
            }

            public static ArrayList EcritureTable(DataTable table, string Separateur, bool bPrintDataType)
            {
                if (table == null)
                    return null;
                if (table.Columns.Count == 0)
                    return null;
                ArrayList resultat = new ArrayList();
                /// ecriture en-tete
                String uneLigne = "";
                foreach (DataColumn Column in table.Columns)
                {
                    uneLigne += Column.ColumnName.ToString() + Separateur;
                }
                uneLigne = uneLigne.Remove(uneLigne.Length - Separateur.Length);
                resultat.Add(uneLigne);
                if (bPrintDataType)
                {
                    uneLigne = "";
                    foreach (DataColumn Column in table.Columns)
                    {
                        uneLigne += Column.DataType.ToString() + Separateur;
                    }
                    uneLigne = uneLigne.Remove(uneLigne.Length - Separateur.Length);
                    resultat.Add(uneLigne);
                }

                /// ecriture de la table
                foreach (DataRow row in table.Rows)
                {
                    uneLigne = "";
                    foreach (Object Item in row.ItemArray)
                    {
                        if (Item.ToString() == "")
                        {
                            uneLigne += "" + Separateur;
                        }
                        else
                        {
                            uneLigne += Item.ToString() + Separateur;
                        }
                    }
                    uneLigne = uneLigne.Remove(uneLigne.Length - Separateur.Length);
                    resultat.Add(uneLigne);
                }
                return resultat;
            }

            public static void EcritureFichier(DataTable table, string NomFichier, string Separateur, bool bPrintDataType)
            {
                if (table == null)
                    return;
                System.IO.StreamWriter monLecteur = new System.IO.StreamWriter(NomFichier);
                ArrayList resultat = EcritureTable(table, Separateur, bPrintDataType);
                if (resultat != null)
                {
                    foreach (String uneLigne in resultat)
                    {
                        monLecteur.WriteLine(uneLigne);
                    }
                }
                monLecteur.Close();
            }

            // >> Task #14533 Pax2Sim - Export Scenario tables from result tree
            /// <summary>
            /// Returns a list with the file names (not full path) found at the given path.
            /// </summary>
            /// <param name="directoryPath"></param>
            /// <param name="fileTypeFilter">Filters the types of files. Format ex: *.txt</param>
            /// <returns></returns>
            public static List<string> getFileNamesFromDirectory(string directoryPath, string fileTypeFilter)
            {
                List<string> fileNames = new List<string>();
                if (!Directory.Exists(directoryPath))
                {
                    return fileNames;
                }
                string[] filePaths = Directory.GetFiles(directoryPath, fileTypeFilter);
                for (int i = 0; i < filePaths.Length; i++)
                    fileNames.Add(Path.GetFileNameWithoutExtension(filePaths[i]));
                return fileNames;
            }

            public static List<string> getCommonElements(List<string> listA,
                List<string> listB)
            {
                List<string> commonElements = new List<string>();
                if (listA != null && listB != null)
                {
                    for (int i = 0; i < listA.Count; i++)
                    {
                        if (listB.Contains(listA[i]))
                            commonElements.Add(listA[i]);
                    }
                }
                return commonElements;
            }

            public static List<string> getFileNamesFromNodesList(List<TreeNode> nodesList)
            {
                List<string> fileNames = new List<string>();
                if (nodesList != null)
                {
                    for (int i = 0; i < nodesList.Count; i++)
                        fileNames.Add(nodesList[i].Name);
                }
                return fileNames;
            }

            public static List<string> getFileNamesWithScenarioNameFromNodesList(List<TreeNode> nodesList)  // >> Task #17969 PAX2SIM - Reports improvements
            {
                List<string> fileNames = new List<string>();
                if (nodesList != null)
                {
                    for (int i = 0; i < nodesList.Count; i++)
                    {
                        TreeNode node = nodesList[i];
                        if (node.Tag == null || node.Tag.GetType() != typeof(TreeViewTag))
                        {
                            continue;
                        }
                        TreeViewTag tag = (TreeViewTag)node.Tag;
                        fileNames.Add(getDictionaryKeyByTagScenarioNameAndNodeName(tag.ScenarioName, node.Name));
                    }
                }
                return fileNames;
            }

            public static string getDictionaryKeyByTagScenarioNameAndNodeName(string scenarioName, string nodeName)
            {
                return scenarioName + "_" + nodeName;
            }

            public static List<string> getListAExclusiveElements(List<string> listA,
                List<string> listB)
            {
                List<string> listAExclusiveElements = new List<string>();
                if (listA != null && listB != null)
                {
                    for (int i = 0; i < listA.Count; i++)
                    {
                        if (!listB.Contains(listA[i]))
                            listAExclusiveElements.Add(listA[i]);
                    }
                }
                return listAExclusiveElements;
            }
            // << Task #14533 Pax2Sim - Export Scenario tables from result tree
            #endregion

            #region Fonction pour lecture et écriture des fichiers UserData
            public static bool lectureUserData(DataTable Table, String nomFichier)
            {
                if (!System.IO.File.Exists(nomFichier))
                    return false;
                System.IO.StreamReader monLecteur;
                try
                {
                    monLecteur = new System.IO.StreamReader(nomFichier);
                }
                catch (Exception exc)
                {
                    OverallTools.ExternFunctions.PrintLogFile("Except02006: LectureUserData throw an exception: " + exc.Message);
                    return false;
                }
                DataRow newRow;
                String uneLigne;
                char cFirstColumn = 'A';
                bool oneCharNames = true;
                char cSecondColumn = 'a';
                Table.Columns.Add(cFirstColumn.ToString(), typeof(String));
                while (monLecteur.Peek() != -1)
                {
                    uneLigne = monLecteur.ReadLine();
                    if (uneLigne.Length == 0)
                    {
                        newRow = Table.NewRow();
                        Table.Rows.Add(newRow);
                        continue;
                    }
                    String[] Values = uneLigne.Split('\t');
                    while (Values.Length > Table.Columns.Count)
                    {
                        cFirstColumn++;
                        if (cFirstColumn > 'Z')
                        {
                            if (oneCharNames)
                            {//(cSecondColumn == 'a')
                                cSecondColumn = 'A';
                                oneCharNames = false;
                            }
                            else
                                cSecondColumn++;
                            cFirstColumn = 'A';
                        }
                        string columnName = cFirstColumn.ToString();
                        if (!oneCharNames)//(cSecondColumn != 'a')
                            columnName = cSecondColumn + columnName;
                        Table.Columns.Add(columnName, typeof(String));
                    }
                    newRow = Table.NewRow();
                    for (int i = 0; i < Values.Length; i++)
                    {
                        newRow[i] = Values[i];
                    }
                    Table.Rows.Add(newRow);

                }
                monLecteur.Close();
                return true;
            }

            public static bool SaveUserData(DataTable dtTable, String Directory)
            {
                return SaveUserData(dtTable, dtTable.TableName, Directory);
            }
            public static bool SaveUserData(DataTable dtTable, String FileName, String Directory)
            {
                if (dtTable == null)
                    return false;
                if (dtTable.Columns.Count == 0)
                    return false;

                System.IO.StreamWriter monEcrivain = new System.IO.StreamWriter(Directory + "\\" + FileName);

                String uneLigne;
                String uneLigneTmp;
                /// ecriture de la table
                foreach (DataRow row in dtTable.Rows)
                {
                    uneLigne = "";
                    uneLigneTmp = "";
                    for (int i = 0; i < dtTable.Columns.Count; i++)
                    {
                        if (row[i] == null)
                        {
                            uneLigneTmp += "\t";
                        }
                        else
                        {
                            if (uneLigneTmp.Length > 0)
                            {
                            }
                            uneLigne += uneLigneTmp + row.ItemArray[i].ToString() + "\t";
                            uneLigneTmp = "";
                        }
                    }
                    uneLigne = uneLigne.Remove(uneLigne.Length - 1);
                    monEcrivain.WriteLine(uneLigne);
                }
                monEcrivain.Close();
                return true;
            }
            #endregion

            // >> Task #17969 PAX2SIM - Reports improvements            
            /// <summary>
            /// Copies the contents of a folder, including subfolders to an other folder, overwriting existing files
            /// </summary>
            /// <param name="sourceFolder"></param>
            /// <param name="destinationFolder"></param>
            public static bool CopyFolderContents(string sourceFolder, string destinationFolder)
            {
                try
                {
                    if (Directory.Exists(sourceFolder))
                    {
                        // Copy folder structure
                        foreach (string sourceSubFolder in Directory.GetDirectories(sourceFolder, "*", SearchOption.AllDirectories))
                        {
                            Directory.CreateDirectory(sourceSubFolder.Replace(sourceFolder, destinationFolder));
                        }
                        // Copy files
                        foreach (string sourceFile in Directory.GetFiles(sourceFolder, "*", SearchOption.AllDirectories))
                        {
                            string destinationFile = sourceFile.Replace(sourceFolder, destinationFolder);
                            File.Copy(sourceFile, destinationFile, true);
                        }
                    }
                    return true;
                }
                catch (Exception exception)
                {
                    ExternFunctions.PrintLogFile("Failed to copy the folder contents from \"" + sourceFolder + " to \"" + destinationFolder + "."
                        + Environment.NewLine + exception.Message);
                    return false;
                }
            }
            // << Task #17969 PAX2SIM - Reports improvements

            #region Fonctions utilisées pour initialiser certains éléments

            #region Fonctions pour l'initialisation des tables
            /// <summary>
            /// Fonction pour initialiser les noms des colonnes de la table spécifiée.
            /// Si la table possède déjà des colonnes, alors elle n'est pas modifiée.
            /// </summary>
            /// <param name="table">La table à initialiser</param>
            /// <param name="listeEntete">La liste des noms des colonnes pour cette table</param>
            public static void initialiserTable(DataTable table, String[] listeEntete, int[] PrimaryKey)
            {
                if (table.Columns.Count != 0)
                {
                    //Il y a déjà des colonnes dans la table.
                    return;
                }
                foreach (String colonne in listeEntete)
                {
                    table.Columns.Add(colonne);
                }
                if ((PrimaryKey != null) && (PrimaryKey.Length != 0))
                {
                    foreach (int value in PrimaryKey)
                    {
                        if (table.Columns.Count <= value)
                            return;
                    }
                    DataColumn[] PrimaryKeyColumn = new DataColumn[PrimaryKey.Length];
                    for (int i = 0; i < PrimaryKey.Length; i++)
                    {
                        PrimaryKeyColumn[i] = table.Columns[PrimaryKey[i]];
                    }
                    table.PrimaryKey = PrimaryKeyColumn;
                }
            }

            /// <summary>
            /// Fonction pour initialiser les noms des colonnes de la table spécifiée.
            /// Si la table possède déjà des colonnes, alors elle n'est pas modifiée.
            /// </summary>
            /// <param name="table">La table à initialiser</param>
            /// <param name="listeEntete">La liste des noms des colonnes pour cette table</param>
            /// <param name="type">Le type des colonnes à ajouter.</param>
            public static void initialiserTable(DataTable table, String[] listeEntete, Type type)
            {
                if (table.Columns.Count != 0)
                {
                    //Il y a déjà des colonnes dans la table.
                    return;
                }
                foreach (String colonne in listeEntete)
                {
                    table.Columns.Add(colonne, type);
                }
            }
            /// <summary>
            /// Fonction pour initialiser les noms des colonnes de la table spécifiée.
            /// Si la table possède déjà des colonnes, alors elle n'est pas modifiée.
            /// </summary>
            /// <param name="table">La table à initialiser</param>
            /// <param name="listeEntete">La liste des noms des colonnes pour cette table</param>
            /// <param name="listeTypeEntete">La liste des noms des colonnes pour cette table</param>
            public static void initialiserTable(DataTable table, String[] listeEntete, Type[] listeTypeEntete, int[] PrimaryKey)
            {
                if (table.Columns.Count != 0)
                {
                    //Il y a déjà des colonnes dans la table.
                    return;
                }
                if (listeEntete == null)
                    return;
                for (int i = 0; i < listeEntete.Length; i++)
                {
                    table.Columns.Add(new DataColumn(listeEntete[i], listeTypeEntete[i]));
                }
                if ((PrimaryKey != null) && (PrimaryKey.Length != 0))
                {
                    foreach (int value in PrimaryKey)
                    {
                        if (table.Columns.Count <= value)
                            return;
                    }
                    DataColumn[] PrimaryKeyColumn = new DataColumn[PrimaryKey.Length];
                    for (int i = 0; i < PrimaryKey.Length; i++)
                    {
                        PrimaryKeyColumn[i] = table.Columns[PrimaryKey[i]];
                    }
                    table.PrimaryKey = PrimaryKeyColumn;
                }
            }
            /// <summary>
            /// Fonction qui se charge d'initialiser les lignes de la table spécifiée.
            /// Si la table possédait déjà une ligne (ou plusieurs) alors elle n'est pas modifiée.
            /// </summary>
            /// <param name="table">La table à modifier</param>
            /// <param name="listeLignes">Les différentes lignes à ajouter</param>
            public static void initialiserLignesTable(DataTable table, String[] listeLignes)
            {
                if ((table.Rows.Count != 0) || (table.Columns.Count == 0))
                {
                    //Il y a déjà des lignes de présentes dans la table
                    //Ou alors il n'y a aucune colonne dans cette table.
                    return;
                }
                bool bAddValue = false;
                if ((table.Columns.Count == 2) && (table.Columns[1].DataType == typeof(Double)))
                {
                    bAddValue = true;
                }
                foreach (String element in listeLignes)
                {
                    object[] ligne = { element };
                    if (bAddValue)
                        ligne = new object[] { element, 0 };
                    table.Rows.Add(ligne);
                }
            }
            public static void initialiserColumnAdded(DataTable table, Double[] listeValues, VisualisationMode visu, int iColumn)
            {
                if (iColumn >= table.Columns.Count)
                    return;
                int i;
                if (!visu.FirstColumnInHeader)
                {
                    if (table.Rows.Count == 0)
                    {
                        // >> Task #9985 Pax2Sim - BNP development - FLL and MSY project files with the departure schedule
                        if (table.TableName.Contains(GlobalNames.flightSubcategoriesTableName)
                            || table.TableName.Contains(GlobalNames.userAttributesReclaimLogTableName))
                        {
                            List<string> valuesList = new List<string>();
                            if (table.TableName.Contains(GlobalNames.flightSubcategoriesTableName))
                                valuesList = GlobalNames.defaultFlightSubcategoriesList;
                            else if (table.TableName.Contains(GlobalNames.userAttributesReclaimLogTableName))
                                valuesList = GlobalNames.defaultReclaimLogValuesList;

                            for (int k = 0; k < valuesList.Count; k++)
                            {
                                DataRow newFSubCategRow = table.NewRow();
                                for (int colIndex = 0; colIndex < table.Columns.Count; colIndex++)
                                {
                                    if (colIndex == 0)
                                        newFSubCategRow[colIndex] = valuesList[k];
                                    else
                                    {
                                        if (colIndex < table.Columns.Count - 1)
                                            newFSubCategRow[colIndex] = 0;
                                        else
                                            newFSubCategRow[colIndex] = 100;
                                    }
                                }
                                table.Rows.Add(newFSubCategRow);
                            }
                        }
                        // << Task #9985 Pax2Sim - BNP development - FLL and MSY project files with the departure schedule
                        else
                        {
                            DataRow newRow = table.NewRow();
                            for (i = 0; i < table.Columns.Count; i++)
                            {
                                if (i < listeValues.Length)
                                    newRow[i] = listeValues[i];
                                else
                                    newRow[i] = listeValues[listeValues.Length - 1];
                            }
                            table.Rows.Add(newRow);
                        }
                    }
                    else
                    {
                        // >> Task #9985 Pax2Sim - BNP development - FLL and MSY project files with the departure schedule
                        if (table.TableName.Contains(GlobalNames.flightSubcategoriesTableName))
                        {
                            int percentage = 0;
                            if (table.Columns.Count == 2)
                                percentage = 100;

                            for (i = 0; i < table.Rows.Count; i++)
                            {
                                table.Rows[i][iColumn] = percentage;
                            }
                            // << Task #9985 Pax2Sim - BNP development - FLL and MSY project files with the departure schedule
                        }
                        else if (table.TableName == GlobalNames.userAttributesReclaimLogTableName)
                        {
                            double percentage = 0;
                            if (table.Columns.Count == 2)
                                percentage = 100;

                            for (i = 0; i < table.Rows.Count; i++)
                            {
                                if (i == 0)
                                    table.Rows[i][iColumn] = 100;
                                else
                                    table.Rows[i][iColumn] = 0;
                            }
                        }
                        else
                        {
                            table.Rows[0][iColumn] = listeValues[listeValues.Length - 1];
                            for (i = 1; i < table.Rows.Count; i++)
                            {
                                table.Rows[i][iColumn] = 0;
                            }
                        }
                    }
                }
                else
                {
                    if (listeValues.Length != table.Rows.Count)
                        return;
                    for (i = 0; i < listeValues.Length; i++)
                    {
                        table.Rows[i][iColumn] = listeValues[i];
                    }
                }
                table.AcceptChanges();
            }

            #region Fonctions pour l'initialisaton de comboBox
            /// <summary>
            /// Fonction pour initialiser les comboBox
            /// </summary>
            /// <param name="cb">Le comboBox</param>
            /// <param name="laTable">La table contenant les données à insérer dans le comboBox</param>
            /// <param name="index">L'index de la colonne à insérer</param>
            public static void initialiserComboBox(ComboBox cb, DataTable laTable, int index)
            {
                cb.Items.Clear();
                if (laTable == null)
                    return;
                if (laTable.Columns.Count <= index)
                    return;
                foreach (DataRow ligne in laTable.Rows)
                {
                    cb.Items.Add(ligne.ItemArray[index]);
                }
            }

            // >> Bug #11327 Pax2Sim - Flight Plan editor - airport code not loaded from table
            /// <summary>
            /// For check boxes that hold strings
            /// </summary>
            /// <param name="cb"></param>
            /// <param name="laTable"></param>
            /// <param name="index"></param>
            public static void initialiserTextComboBox(ComboBox cb, DataTable laTable, int index)
            {
                cb.Items.Clear();
                if (laTable == null)
                    return;
                if (laTable.Columns.Count <= index)
                    return;
                foreach (DataRow ligne in laTable.Rows)
                {
                    if (ligne.ItemArray[index] != null)
                    {
                        String valueFromTable = ligne.ItemArray[index].ToString();
                        if (valueFromTable != null)
                        {
                            cb.Items.Add(valueFromTable.Trim());
                        }
                    }
                }
            }
            // << Bug #11327 Pax2Sim - Flight Plan editor - airport code not loaded from table

            /// <summary>
            /// Fonction pour initialiser les comboBox
            /// </summary>
            /// <param name="cb">Le comboBox</param>
            /// <param name="valeurs">La liste des différentes valeurs à insérer dans la table </param>
            public static void initialiserComboBox(ComboBox cb, String[] valeurs)
            {
                cb.Items.Clear();
                if (valeurs == null)
                    return;
                for (int i = 0; i < valeurs.Length; i++)
                {
                    cb.Items.Add(valeurs[i]);
                }
            }
            #endregion

            #endregion

            #region fonctions pour simplifier la recherche dans les arbres XML
            /// <summary>
            /// Créer un tag XML contenant du text.
            /// ex: "<Element>value</Element>"
            /// </summary>
            /// <param name="projet"></param>
            /// <param name="Element">Nom du tag</param>
            /// <param name="value">texte du tag</param>
            /// <returns>element créé</returns>
            internal static System.Xml.XmlElement CreateElement(System.Xml.XmlDocument projet, String Element, String value)
            {
                System.Xml.XmlElement tmp = projet.CreateElement(Element);
                tmp.AppendChild(projet.CreateTextNode(value));
                return tmp;
            }


            public static System.Xml.XmlNode getChildWithValue(System.Xml.XmlNode xnParent, String Value)
            {
                if (xnParent == null)
                    return null;
                for (int i = 0; i < xnParent.ChildNodes.Count; i++)
                {
                    if ((xnParent.ChildNodes[i].FirstChild != null) &&
                        (xnParent.ChildNodes[i].FirstChild.Value != null) &&
                        (xnParent.ChildNodes[i].FirstChild.Value == Value))
                    {
                        return xnParent.ChildNodes[i];
                    }
                }
                return null;
            }
            public static System.Xml.XmlAttribute getAttributeWithValue(System.Xml.XmlNode node, String sValue)
            {
                if (node == null)
                    return null;
                if (node.Attributes == null)
                    return null;
                for (int i = 0; i < node.Attributes.Count; i++)
                {
                    if (node.Attributes[i].Value == sValue)
                    {
                        return node.Attributes[i];
                    }
                }
                return null;
            }
            /// <summary>
            /// Fonction qui recherche dans les enfant d'un noeud XML celui nommé Name
            /// </summary>
            /// <param name="node">Le noeud analysé</param>
            /// <param name="Name">Le nom recherché</param>
            /// <returns>Renvoie vrai si le noeud XML contient un enfant nommé Name</returns>
            public static bool hasNamedChild(System.Xml.XmlNode node, String Name)
            {
                if (node == null)
                    return false;
                for (int i = 0; i < node.ChildNodes.Count; i++)
                {
                    if (node.ChildNodes[i].Name == Name)
                    {
                        return true;
                    }
                }
                return false;
            }
            /// <summary>
            /// Fonction qui recherche dans un noeud XML si l'attribut Name existe
            /// </summary>
            /// <param name="node">Le noeud analysé</param>
            /// <param name="Name">Le nom recherché</param>
            /// <returns>Renvoie vrai si le noeud XML contient un attribut nommé Name</returns>
            public static bool hasNamedAttribute(System.Xml.XmlNode node, String Name)
            {
                for (int i = 0; i < node.Attributes.Count; i++)
                {
                    if (node.Attributes[i].Name == Name)
                    {
                        return true;
                    }
                }
                return false;
            }

            public static string getValueChild(System.Xml.XmlNode node, String Name)
            {
                if ((hasNamedChild(node, Name)) && (node[Name].FirstChild != null)
                    && (node[Name].FirstChild.Value != null))
                    return node[Name].FirstChild.Value.ToString();
                return "";
            }
            /// <summary>
            /// ajoute un tag XML
            /// </summary>
            /// <param name="node">noeud auquel ajouter le tag</param>
            /// <param name="xdProject">document xml</param>
            /// <param name="Name">Nom du tag</param>
            /// <param name="sValue">texte à mettre dans le tag</param>
            public static void PrintValueChild(System.Xml.XmlNode node, System.Xml.XmlDocument xdProject, String Name, String sValue)
            {
                if ((sValue == null) || (sValue == ""))
                    return;
                node.AppendChild(OverallTools.FonctionUtiles.CreateElement(xdProject, Name, sValue));
            }
            public static System.Xml.XmlNode ChildExist(System.Xml.XmlNode Structure, String Type, int Index)
            {
                if (Structure == null)
                {
                    return null;
                }
                foreach (System.Xml.XmlNode child in Structure.ChildNodes)
                {
                    if ((!hasNamedAttribute(child, "Type")) || (!hasNamedAttribute(child, "Index")))
                        continue;
                    if ((child.Attributes["Type"].Value == Type) && (child.Attributes["Index"].Value.ToString() == Index.ToString()))
                        return child;
                    if (child.ChildNodes.Count > 0)
                    {
                        System.Xml.XmlNode xnTmp = ChildExist(child, Type, Index);
                        if (xnTmp != null)
                            return xnTmp;
                    }
                }
                return null;
            }
            public static System.Xml.XmlNode ChildExist(System.Xml.XmlNode Structure, String Type, String sObjectDescription)
            {
                if (Structure == null)
                {
                    return null;
                }
                foreach (System.Xml.XmlNode child in Structure.ChildNodes)
                {
                    if ((!hasNamedAttribute(child, "Type")) || (!hasNamedAttribute(child, "Name")))
                        continue;
                    if (child.Attributes["Type"].Value != Type)
                        continue;

                    String sCurrentNodeDescription = GestionDonneesHUB2SIM.extractDescription(child.Attributes["Name"].Value);
                    if (sCurrentNodeDescription.Trim().ToLower() != sObjectDescription.Trim().ToLower())
                        return child;
                    if (child.ChildNodes.Count > 0)
                    {
                        System.Xml.XmlNode xnTmp = ChildExist(child, Type, sObjectDescription);
                        if (xnTmp != null)
                            return xnTmp;
                    }
                }
                return null;
            }
            public static System.Xml.XmlNode LookForChild(System.Xml.XmlNode Structure, String Type, int Index)
            {
                if (Structure == null)
                {
                    return null;
                }
                foreach (System.Xml.XmlNode child in Structure.ChildNodes)
                {
                    if (child.HasChildNodes)
                    {
                        System.Xml.XmlNode xnTmp = LookForChild(child, Type, Index);
                        if (xnTmp != null)
                            return xnTmp;
                    }
                    if (!hasNamedAttribute(child, "Type"))
                        continue;
                    if (!hasNamedAttribute(child, "Index"))
                        continue;
                    if (child.Attributes["Type"].Value != Type)
                        continue;
                    if (child.Attributes["Index"].Value != Index.ToString())
                        continue;
                    return child;
                }
                return null;
            }

            public static System.Xml.XmlNode LookForChild(System.Xml.XmlNode Structure, String Type, String sDescription)
            {
                if (Structure == null)
                {
                    return null;
                }
                foreach (System.Xml.XmlNode child in Structure.ChildNodes)
                {
                    if (child.HasChildNodes)
                    {
                        System.Xml.XmlNode xnTmp = LookForChild(child, Type, sDescription);
                        if (xnTmp != null)
                            return xnTmp;
                    }
                    if (!hasNamedAttribute(child, "Type"))
                        continue;
                    if (!hasNamedAttribute(child, "Name"))
                        continue;
                    if (child.Attributes["Type"].Value != Type)
                        continue;
                    String sCurrentNodeDescription = GestionDonneesHUB2SIM.extractDescription(child.Attributes["Name"].Value);
                    if (sCurrentNodeDescription.Trim().ToLower() != sDescription.Trim().ToLower())
                        continue;
                    return child;
                }
                return null;
            }
            #endregion

            #region Les différentes fonctions sur les chaines de caractères
            /// <summary>
            /// Fonction qui se charge de rechercher le prochain opérateur présent dans la chaien de caratère.
            /// </summary>
            /// <param name="formule">La formule à analyser</param>
            /// <param name="iCaractere">L'index du caractère analysé</param>
            /// <returns>Retourne une chaine de caractère avec le prochain opérateur trouvé dans la chaine.</returns>
            public static String nextOperateur(String formule, ref int iCaractere)
            {
                String operateur = "";
                int debut = iCaractere;
                if ((formule[iCaractere] == '+') || (formule[iCaractere] == '-') || (formule[iCaractere] == '/')
                                                || (formule[iCaractere] == '*'))
                {
                    iCaractere++;
                    return formule[iCaractere - 1].ToString();
                }
                while ((iCaractere < formule.Length) && ((formule[iCaractere] == '<') || (formule[iCaractere] == '>') || (formule[iCaractere] == '=')))
                {
                    operateur += formule[iCaractere];
                    iCaractere++;
                }
                if (debut == iCaractere)
                {
                    while ((iCaractere < formule.Length) && (((formule[iCaractere] >= 'a') && (formule[iCaractere] <= 'z')) ||
                                                    ((formule[iCaractere] >= 'A') && (formule[iCaractere] <= 'Z'))
                                                    ))
                    {
                        operateur += formule[iCaractere];
                        iCaractere++;
                    }
                }
                return operateur;
            }
            /// <summary>
            /// Fonction qui recherche l'index du prochain caratère non blanc de la chaîne de caractère.
            /// </summary>
            /// <param name="formule">La formule à analyser.</param>
            /// <returns>L'index du prochain caratère non blanc.</returns>
            public static int nextCaractere(String formule)
            {
                int i = 0;
                while ((formule.Length > i) && ((formule[i] == '\0') || (formule[i] == ' ') || (formule[i] == '\t') || (formule[i] == '\n') || (formule[i] == '\r')))
                    i++;
                if (i >= formule.Length) return -1; //Nous avons atteint la fin de la chaine.
                return i;
            }
            /// <summary>
            /// Fonction qui se charge de renvoyer la chaine de caractère entre le l'origine et la prochaine
            /// occurence du séparateur.s
            /// </summary>
            /// <param name="formule">La chaine de caratère à traiter</param>
            /// <param name="separateur">Le séparateur rechercher</param>
            /// <returns>La chaine de caractère contenue entre le début de la formule et le séparateur.
            /// Si le séparateur n'a pas été trouvé alors elle renvoie null.</returns>
            public static String extraireDonnees(String formule, char separateur)
            {
                String result = "";
                int i = 0;
                while ((formule.Length > i) && (formule[i] != separateur))
                {
                    result += formule[i];
                    i++;
                }
                if (i == formule.Length)
                    return null;
                if (formule[i] != separateur) return null;
                return result;
            }


            /// <summary>
            /// Fonction qui renvoie la chaine de caratere représentant le double qui est présent dans la chaine de 
            /// caractère
            /// </summary>
            /// <param name="formule">La formule à analyser</param>
            /// <param name="iCaractere">L'index du curseur d'analyse.</param>
            /// <returns></returns>
            public static String nextDoubleDate(String formule, ref int iCaractere)
            {
                String DoubleDate = "";
                while ((iCaractere < formule.Length) && (((formule[iCaractere] >= '0') && (formule[iCaractere] <= '9')) ||
                                                          (formule[iCaractere] == '.')))   //|| (formule[iCaractere] == ','))) Task #15717 PAX2SIM - Create Filter Assistant and Datagrid - new Features
                {
                    DoubleDate += formule[iCaractere];
                    iCaractere++;
                }
                return DoubleDate;
            }

            /// <summary>
            /// Fonction qui renvoie la chaine de caratere représentant l'entier qui est présent dans la chaine de 
            /// caractère
            /// </summary>
            /// <param name="formule">La formule à analyser</param>
            /// <param name="iCaractere">L'index du curseur d'analyse.</param>
            /// <returns></returns>
            public static String nextInt(String formule, ref int iCaractere)
            {
                String entier = "";
                while ((iCaractere < formule.Length) && ((formule[iCaractere] >= '0') && (formule[iCaractere] <= '9')))
                {
                    entier += formule[iCaractere];
                    iCaractere++;
                }
                return entier;
            }

            /// <summary>
            /// Fonction qui retourne le début de la chaine de caractere,jusqu'a l'espace suivant.
            /// </summary>
            /// <param name="text">Le texte en entré</param>
            /// <returns>La chaine de caractere située entre le début de la chaine et l'espace suivant de la chaine</returns>
            public static String Substring(String text)
            {
                return text.Substring(0, text.IndexOf(' '));
            }
            /// <summary>
            /// Fonction qui renvoie le nombre de fois que le caractere a ete rencontre dans la chaine
            /// </summary>
            /// <param name="chaine">La chaine à parcourir</param>
            /// <param name="caracter">Le caractere recherche</param>
            /// <returns>le nombre d'occurence du caractere</returns>
            public static int nombreCaractere(String chaine, Char caracter)
            {
                int retour = 0;
                foreach (Char c in chaine.ToCharArray())
                {
                    if (c == caracter) retour++;
                }
                return retour;
            }


            /// <summary>
            /// Fonction qui renvoie true si la chaine de caractere spécifiée est présente dans la liste.
            /// </summary>
            /// <param name="aiguille">Chaine recherchée</param>
            /// <param name="botte">Table de chaine de caractèrer</param>
            /// <returns>Booléen indiquant si la chaine est présente.</returns>
            public static bool estPresentDansListe(String aiguille, String[] botte)
            {
                for (int i = 0; i < botte.Length; i++)
                {
                    if (aiguille == botte[i])
                    {
                        return true;
                    }
                }
                return false;
            }
            /// <summary>
            /// Fonction pour rechercher dans une liste de chaine de caractere la premiere occurence de la chaine spécifiée
            /// </summary>
            /// <param name="aiguille">Chaine recherchée</param>
            /// <param name="botte">Table de chaine de caractèrer</param>
            /// <returns>index dans la liste</returns>
            public static int indexDansListe(String aiguille, String[] botte)
            {
                for (int i = 0; i < botte.Length; i++)
                {
                    if (aiguille == botte[i])
                    {
                        return i;
                    }
                }
                return -1;
            }
            #endregion

            #region Fonction pour formater la largeur des chaines de caracteres.
            public static String FormatString(String sString, int NbCaract)
            {
                String resultat = "";
                bool findSpace = false;
                for (int i = 0; i < sString.Length; i++)
                {
                    resultat += sString[i];
                    if ((i % NbCaract == 0) && i != 0)
                        findSpace = true;
                    if ((findSpace) && (sString[i] == ' '))
                    {
                        findSpace = false;
                        resultat += '\n';
                    }
                }
                return resultat;
            }
            #endregion

            #region Fonction pour la gestion des distributions

            public static bool CheckDistributionName(String Distrib)
            {
                return (Distrib == "Uniform") || (Distrib == "Normal") || (Distrib == "Gamma") ||
                    (Distrib == "LogNormal") || (Distrib == "Weibull") || (Distrib == "Triangular") ||
                    (Distrib == "Constant") || (Distrib == "Exponential");
            }

            public static void NbParams(String DistributionName, out bool secondParam, out bool thirdParam)
            {
                secondParam = (DistributionName == "Uniform") || (DistributionName == "Normal") || (DistributionName == "Gamma") ||
                    (DistributionName == "LogNormal") || (DistributionName == "Weibull") || (DistributionName == "Triangular");
                thirdParam = (DistributionName == "Triangular");
            }

            public static bool checkParams(string distribution, double param1, double param2, double param3, out String Error)
            {
                Error = "";
                if ((distribution == "Uniform") || (distribution == "Normal") || (distribution == "Triangular"))
                {
                    if (distribution == "Triangular")
                    {
                        if ((param1 > param2) || (param1 > param3) || (param2 > param3))
                        {
                            Error = "The triangular distribution accept 3 parameters ( first < second < third)";
                            return false;
                        }
                    }
                    else
                    {
                        if (param2 > param1)
                        {
                            Error = "The first parameters must be greater than the second.";
                            return false;
                        }
                        /* -- Modification 23.02.09 ==> limitation non nécessaire à priori.
                         * if (distribution == "Normal")
                        {
                            if ((param1 / 5.0) < param2)
                            {
                                Error = "The first parameters must be greater 5 times than the second.";
                                return false;
                            }
                        }*/
                    }

                }
                return true;
            }
            #endregion

            #region Fonction pour la conversion d'objet en double
            public static Double parseDouble(Object obj)
            {
                if ((obj.GetType() == typeof(Int32))
                    || (obj.GetType() == typeof(Int16))
                    || (obj.GetType() == typeof(Int64))
                    || (obj.GetType() == typeof(int)))
                {
                    return (double)((int)obj);
                }
                else if ((obj.GetType() == typeof(Double)) ||
                    (obj.GetType() == typeof(double)))
                {
                    return (Double)obj;
                }
                return 0;
            }
            #endregion

            #region Fonction pour inverser les couleurs.
            public static void InvertColors(Bitmap bmp)
            {
                Color cSource;
                Color cDest;
                for (int y = 0; y < bmp.Height; y++)
                {
                    for (int x = 0; x < bmp.Width; x++)
                    {
                        cSource = bmp.GetPixel(x, y);
                        cDest = cSource;
                        if (cSource.A != 0)
                            cDest = Color.FromArgb(255 - cSource.R, 255 - cSource.G, 255 - cSource.B);
                        bmp.SetPixel(x, y, cDest);

                    }
                }
            }
            #endregion

            #region Fonction pour comparer des chaines de caractère

            public static int CompareString(String sFirstString, String sSecondString)
            {
                return CompareString(sFirstString, sSecondString, false);
            }
            public static int CompareString(String sFirstString, String sSecondString, bool bCompareNumber)
            {
                if (sFirstString == sSecondString)
                    return 0;
                int iLenghtMax = sFirstString.Length;
                if (iLenghtMax > sSecondString.Length)
                    iLenghtMax = sSecondString.Length;
                for (int i = 0; i < iLenghtMax; i++)
                {
                    if (bCompareNumber)
                    {
                        if ((sFirstString[i] >= '0') && (sFirstString[i] <= '9') &&
                            (sSecondString[i] >= '0') && (sSecondString[i] <= '9'))
                        {
                            int iIndexF = i, iIndexS = i;
                            String sFirstValue = OverallTools.FonctionUtiles.nextDoubleDate(sFirstString, ref iIndexF);
                            String sSecondValue = OverallTools.FonctionUtiles.nextDoubleDate(sSecondString, ref iIndexS);
                            if (sFirstValue == sSecondValue)
                                continue;
                            Double dFirstValue, dSecondValue;
                            if ((Double.TryParse(sFirstValue, out dFirstValue)) &&
                               (Double.TryParse(sSecondValue, out dSecondValue)))
                            {
                                if (dFirstValue == dSecondValue)
                                {
                                    bCompareNumber = false;
                                    continue;
                                }
                                if (dFirstValue > dSecondValue)
                                    return 1;
                                return -1;

                            }
                        }
                    }
                    if (sFirstString[i] == sSecondString[i])
                        continue;
                    if (sFirstString[i] > sSecondString[i])
                        return 1;
                    return -1;
                }
                if (sFirstString.Length > sSecondString.Length)
                    return 1;
                return -1;
            }
            #endregion


            #region Fonction pour l'exportation vers Excel
            public static String ExportToExcel(DataTable[] dtTable, VisualisationMode[] vmVisualisation, String sPath, SIM_LoadingForm cht)
            {
                Microsoft.Office.Interop.Excel.ApplicationClass oExcelApp = null;
                Microsoft.Office.Interop.Excel.Workbooks oBooks = null;
                Microsoft.Office.Interop.Excel.Workbook oBook = null;
                Microsoft.Office.Interop.Excel.Worksheet oSheet = null;
                String sResult = "";
                try
                {
                    // Créer l’objet Excel             
                    oExcelApp = new Microsoft.Office.Interop.Excel.ApplicationClass();
                    oExcelApp.Visible = false; // l’afficher  ou pas
                    oExcelApp.ScreenUpdating = false;
                    oExcelApp.Interactive = false;
                    oExcelApp.DisplayAlerts = false;
                    oExcelApp.EnableCancelKey = Microsoft.Office.Interop.Excel.XlEnableCancelKey.xlDisabled;
                    //oExcelApp.Calculation = Microsoft.Office.Interop.Excel.XlCalculation.xlCalculationManual;

                    oBooks = oExcelApp.Workbooks;
                    //Créer un nouveau fichier Excel
                    oBook = oBooks.Add(Missing.Value);
                    // on active la feuille
                    oSheet = (Microsoft.Office.Interop.Excel.Worksheet)oExcelApp.ActiveSheet;
                    // on active la feuille auto
                    while (oExcelApp.Sheets.Count > 1)
                        ((Microsoft.Office.Interop.Excel.Worksheet)oExcelApp.Sheets[1]).Delete();
                    oSheet = (Microsoft.Office.Interop.Excel.Worksheet)oExcelApp.Sheets[1];
                    int iCurrent = 1;
                    for (int i = 0; i < dtTable.Length; i++)
                    {
                        if (dtTable[i] == null)
                            continue;
                        if (iCurrent > oExcelApp.Sheets.Count)
                        {
                            oExcelApp.Sheets.Add(Missing.Value, Missing.Value, Missing.Value, Missing.Value);
                        }
                        oSheet = (Microsoft.Office.Interop.Excel.Worksheet)oExcelApp.Sheets[iCurrent];
                        String sName = dtTable[i].TableName;
                        if (sName.Length > 30)
                            oSheet.Name = sName.Substring(0, 30) + "_";
                        else
                            oSheet.Name = sName;
                        if (cht != null)
                            cht.ChargementFichier(dtTable[i].TableName);
                        ExportTableToExcel(dtTable[i], vmVisualisation[i], oSheet, cht);
                        iCurrent++;
                    }
                }
                catch (Exception e)
                {
                    sResult = e.Message;
                    OverallTools.ExternFunctions.PrintLogFile("Except02007: ExportToExcel throw an exception: " + e.Message);
                }
                try
                {
                    if ((sResult == "") && (oBook != null))
                    {
                        oBook.Close(true, sPath, Missing.Value);
                    }
                    else
                    {
                        oBook.Close(false, Missing.Value, Missing.Value);
                    }
                }
                catch (Exception e)
                {
                    sResult = e.Message;
                    OverallTools.ExternFunctions.PrintLogFile("Except02008: ExportToExcel throw an exception: " + e.Message);
                }
                try
                {

                    if (oSheet != null)
                    {
                        System.Runtime.InteropServices.Marshal.ReleaseComObject(oSheet);
                        oSheet = null;
                    }
                    if (oBook != null)
                    {
                        System.Runtime.InteropServices.Marshal.ReleaseComObject(oBook);
                        oBook = null;
                    }
                    if (oBooks != null)
                    {
                        System.Runtime.InteropServices.Marshal.ReleaseComObject(oBooks);
                        oBooks = null;
                    }
                    if (oExcelApp != null)
                    {
                        oExcelApp.Quit();
                        System.Runtime.InteropServices.Marshal.ReleaseComObject(oExcelApp); oExcelApp = null;
                    }
                }
                catch (Exception e)
                {
                    sResult = e.Message;
                    OverallTools.ExternFunctions.PrintLogFile("Except02013: ExportToExcel throw an exception: " + e.Message);
                }
                GC.Collect();
                return sResult;
            }

            private static void _ExportTableToExcel(DataTable dtTable, VisualisationMode vmVisualisation, Microsoft.Office.Interop.Excel.Worksheet oSheet)
            {
                int i;
                //Microsoft.Office.Interop.Excel.Range rang = oSheet.
                for (i = 0; i < dtTable.Columns.Count; i++)
                {
                    oSheet.Cells[1, i + 1] = dtTable.Columns[i].ColumnName;
                }
                String LastLetter = getLetters(dtTable.Columns.Count);
                Microsoft.Office.Interop.Excel.Range rang = oSheet.get_Range("A1", LastLetter + "1");
                rang.Interior.Color = System.Drawing.ColorTranslator.ToWin32(Color.LightGray);
                bool bVisualisation = ((vmVisualisation != null) && (vmVisualisation.ConditionnalFormatClass != null) && (vmVisualisation.ConditionnalFormatClass[0] != null));
                VisualisationMode.ConditionnalFormat cf = null;
                bool bLine = false;
                if (bVisualisation)
                {
                    cf = vmVisualisation.ConditionnalFormatClass[0];
                    bLine = (cf.GetType() == typeof(ConditionnalFormatLine));
                }
                for (int j = 0; j < dtTable.Rows.Count; j++)
                {
                    for (i = 0; i < dtTable.Columns.Count; i++)
                    {
                        oSheet.Cells[j + 2, i + 1] = dtTable.Rows[j][i].ToString();
                        if (bVisualisation)
                        {
                            String Letter = getLetters(i + 1) + (j + 2).ToString();
                            rang = oSheet.get_Range(Letter, Letter);
                            if (i == 0)
                            {
                                rang.Interior.Color = System.Drawing.ColorTranslator.ToWin32(Color.LightGray);
                            }
                            else if (cf.GetType() == typeof(ConditionnalFormatErrors))
                            {
                                rang.Interior.Color = System.Drawing.ColorTranslator.ToWin32(cf.getColor(i, j));
                            }
                            else if ((cf.GetType() == typeof(ConditionnalFormatCharacter)) ||
                                    (cf.GetType() == typeof(ConditionnalFormatValue)))
                            {
                                rang.Interior.Color = System.Drawing.ColorTranslator.ToWin32(cf.getColor(dtTable.Rows[j][i]));
                            }
                        }
                        //
                    }
                    if (bVisualisation && bLine)
                    {
                        //LastLetter
                        rang = oSheet.get_Range("A" + (j + 2).ToString(), LastLetter + (j + 2).ToString());
                        rang.Interior.Color = System.Drawing.ColorTranslator.ToWin32(cf.getColor(0, j));
                    }
                }
                //rang = oSheet.get_Range("A1", LastLetter + (dtTable.Rows.Count+1).ToString());
                //rang.AutoFit();
                //oSheet.Cells.AutoFit();
            }

            private static void __ExportTableToExcel(DataTable dtTable, VisualisationMode vmVisualisation, Microsoft.Office.Interop.Excel.Worksheet oSheet, SIM_LoadingForm cht)
            {
                int i;
                //Microsoft.Office.Interop.Excel.Range rang = oSheet.
                for (i = 0; i < dtTable.Columns.Count; i++)
                {
                    oSheet.Cells[1, i + 1] = dtTable.Columns[i].ColumnName;
                }
                String LastLetter = getLetters(dtTable.Columns.Count);
                Microsoft.Office.Interop.Excel.Range range = oSheet.get_Range("A1", LastLetter + "1");
                range.Interior.Color = System.Drawing.ColorTranslator.ToWin32(Color.LightGray);
                bool bVisualisation = ((vmVisualisation != null) && (vmVisualisation.ConditionnalFormatClass != null) && (vmVisualisation.ConditionnalFormatClass[0] != null));
                VisualisationMode.ConditionnalFormat cf = null;
                bool bLine = false;
                if (bVisualisation)
                {
                    cf = vmVisualisation.ConditionnalFormatClass[0];
                    bLine = (cf.GetType() == typeof(ConditionnalFormatLine));
                }
                if (cht != null)
                    cht.setFileNumber(dtTable.Rows.Count);
                string[,] source = new string[dtTable.Rows.Count, dtTable.Columns.Count];
                OverallTools.ExternFunctions.PrintLogFile("ExportTableToExcel: source[,] start.");
                for (int j = 0; j < dtTable.Rows.Count; j++)
                {
                    for (i = 0; i < dtTable.Columns.Count; i++)
                    {
                        //oSheet.Cells[j + 2, i + 1] = dtTable.Rows[j][i].ToString();
                        source[j, i] = dtTable.Rows[j][i].ToString();
                        if (bVisualisation)
                        {
                            String Letter = getLetters(i + 1) + (j + 2).ToString();
                            range = oSheet.get_Range(Letter, Letter);
                            if (i == 0)
                            {
                                range.Interior.Color = System.Drawing.ColorTranslator.ToWin32(Color.LightGray);
                            }
                            else if (cf.GetType() == typeof(ConditionnalFormatErrors))
                            {
                                range.Interior.Color = System.Drawing.ColorTranslator.ToWin32(cf.getColor(i, j));
                            }
                            else if ((cf.GetType() == typeof(ConditionnalFormatCharacter)) ||
                                    (cf.GetType() == typeof(ConditionnalFormatValue)))
                            {
                                range.Interior.Color = System.Drawing.ColorTranslator.ToWin32(cf.getColor(dtTable.Rows[j][i]));
                            }
                        }

                    }
                    if (bVisualisation && bLine)
                    {
                        //LastLetter
                        range = oSheet.get_Range("A" + (j + 2).ToString(), LastLetter + (j + 2).ToString());
                        range.Interior.Color = System.Drawing.ColorTranslator.ToWin32(cf.getColor(0, j));
                    }
                    if (cht != null)
                        cht.ChargementFichier("Exporting from " + dtTable.TableName + " Row " + j);
                }
                OverallTools.ExternFunctions.PrintLogFile("ExportTableToExcel: source[,] end.");
                range = oSheet.get_Range("A2", LastLetter + "2");
                range = range.get_Resize(dtTable.Rows.Count, dtTable.Columns.Count);
                OverallTools.ExternFunctions.PrintLogFile("ExportTableToExcel: before range.set_Value(Missing.Value, source);");
                range.set_Value(Missing.Value, source);
                OverallTools.ExternFunctions.PrintLogFile("ExportTableToExcel: after range.set_Value(Missing.Value, source);");
                //rang = oSheet.get_Range("A1", LastLetter + (dtTable.Rows.Count+1).ToString());
                //rang.AutoFit();
                //oSheet.Cells.AutoFit();
            }

            private static void ExportTableToExcel(DataTable dtTable, VisualisationMode vmVisualisation, Microsoft.Office.Interop.Excel.Worksheet oSheet, SIM_LoadingForm cht)
            {
                int i;
                //Microsoft.Office.Interop.Excel.Range rang = oSheet.
                for (i = 0; i < dtTable.Columns.Count; i++)
                {
                    oSheet.Cells[1, i + 1] = dtTable.Columns[i].ColumnName;
                }
                String LastLetter = getLetters(dtTable.Columns.Count);
                Microsoft.Office.Interop.Excel.Range range = oSheet.get_Range("A1", LastLetter + "1");
                range.Interior.Color = System.Drawing.ColorTranslator.ToWin32(Color.LightGray);
                bool bVisualisation = ((vmVisualisation != null) && (vmVisualisation.ConditionnalFormatClass != null) && (vmVisualisation.ConditionnalFormatClass[0] != null));
                VisualisationMode.ConditionnalFormat cf = null;
                bool bLine = false;
                if (bVisualisation)
                {
                    cf = vmVisualisation.ConditionnalFormatClass[0];
                    bLine = (cf.GetType() == typeof(ConditionnalFormatLine));
                }
                if (cht != null)
                    cht.setFileNumber(dtTable.Rows.Count);
                string[,] source = new string[dtTable.Rows.Count, dtTable.Columns.Count];
                //OverallTools.ExternFunctions.PrintLogFile("ExportTableToExcel: source[,] start.");
                for (int j = 0; j < dtTable.Rows.Count; j++)
                {
                    for (i = 0; i < dtTable.Columns.Count; i++)
                    {
                        //oSheet.Cells[j + 2, i + 1] = dtTable.Rows[j][i].ToString();
                        source[j, i] = dtTable.Rows[j][i].ToString();
                        Color cellBackground = Color.White;
                        if (bVisualisation)
                        {
                            if (i == 0)
                            {
                                cellBackground = Color.LightGray;
                            }
                            else if (cf.GetType() == typeof(ConditionnalFormatErrors))
                            {
                                cellBackground = cf.getColor(i, j);
                            }
                            else if ((cf.GetType() == typeof(ConditionnalFormatCharacter)) ||
                                    (cf.GetType() == typeof(ConditionnalFormatValue)))
                            {
                                cellBackground = cf.getColor(dtTable.Rows[j][i]);
                            }
                            if (cellBackground != Color.White)
                            {
                                String Letter = getLetters(i + 1) + (j + 2).ToString();
                                range = oSheet.get_Range(Letter, Letter);
                                range.Interior.Color = ColorTranslator.ToWin32(cellBackground);
                            }
                        }
                    }
                    if (bVisualisation && bLine && cf.getColor(0, j) != Color.White)
                    {
                        //LastLetter
                        range = oSheet.get_Range("A" + (j + 2).ToString(), LastLetter + (j + 2).ToString());
                        range.Interior.Color = System.Drawing.ColorTranslator.ToWin32(cf.getColor(0, j));
                    }
                    if (cht != null)
                        cht.ChargementFichier("Exporting from " + dtTable.TableName + ", Row nb: " + j);
                }
                //OverallTools.ExternFunctions.PrintLogFile("ExportTableToExcel: source[,] end.");
                range = oSheet.get_Range("A2", LastLetter + "2");
                range = range.get_Resize(dtTable.Rows.Count, dtTable.Columns.Count);
                //OverallTools.ExternFunctions.PrintLogFile("ExportTableToExcel: before range.set_Value(Missing.Value, source);");
                range.set_Value(Missing.Value, source);
                //OverallTools.ExternFunctions.PrintLogFile("ExportTableToExcel: after range.set_Value(Missing.Value, source);");
            }

            private static String getLetters(int iValue)
            {
                if (iValue == 0)
                    return null;
                int result = 'A';
                if (iValue < 27)
                    return "" + (char)(result + iValue - 1);
                return getLetters((iValue - 1) / 26) + getLetters((iValue - 1) % 26 + 1);

            }
            #endregion

            #region Focntion pour communiquer avec PowerPoint
            public static void ExportToPowerPoint()
            {
                /*Microsoft.Office.Interop.PowerPoint.ApplicationClass oExcelApp = null;
                Microsoft.Office.Interop.PowerPoint. oBooks = null;
                Microsoft.Office.Interop.PowerPoint.Workbook oBook = null;
                Microsoft.Office.Interop.PowerPoint.Worksheet oSheet = null;

                // Créer l’objet Excel             
                oExcelApp = new Microsoft.Office.Interop.Excel.ApplicationClass();
                oExcelApp.Visible = false; // l’afficher  ou pas
                oExcelApp.ScreenUpdating = false;
                oExcelApp.Interactive = false;
                oExcelApp.DisplayAlerts = false;
                oExcelApp.EnableCancelKey = Microsoft.Office.Interop.Excel.XlEnableCancelKey.xlDisabled;
                //oExcelApp.Calculation = Microsoft.Office.Interop.Excel.XlCalculation.xlCalculationManual;

                oBooks = oExcelApp.Workbooks;
                //Créer un nouveau fichier Excel
                oBook = oBooks.Add(Missing.Value);
                // on active la feuille
                oSheet = (Microsoft.Office.Interop.Excel.Worksheet)oExcelApp.ActiveSheet;
                // on active la feuille auto
                while (oExcelApp.Sheets.Count > 1)
                    ((Microsoft.Office.Interop.Excel.Worksheet)oExcelApp.Sheets[1]).Delete();
                oSheet = (Microsoft.Office.Interop.Excel.Worksheet)oExcelApp.Sheets[1];*/
            }
            #endregion

            #region classe pour le try des listes
            public class ColumnsComparer : IComparer
            {
                public int Compare(Object x, Object y)
                {
                    return FonctionUtiles.CompareString(x.ToString(), y.ToString(), true);
                }
            }
            public class ColumnsComparerList : IComparer<String>
            {/*
                public int Compare(Object x, Object y)
                {
                    return FonctionUtiles.CompareString(x.ToString(), y.ToString(), true);
                }*/
                public int Compare(String x, String y)
                {
                    return FonctionUtiles.CompareString(x, y, true);
                }
            }
            #endregion
            #endregion

            public static bool isPresent(String sLookedText, String sListe, char cSeparator)
            {
                String[] tsTmp = sListe.Split(new char[] { cSeparator }, StringSplitOptions.RemoveEmptyEntries);
                sLookedText = sLookedText.Trim();
                foreach (String sTmp in tsTmp)
                {
                    if (sLookedText == sTmp.Trim())
                        return true;
                }
                return false;
            }

            #region Fonction et utilitaires qui se charge de calculer l'allocation des MakeUp à partir de la feuille de vol.
            #region Allocation pour les Transfer Infeed (pas encore migrée.
            private class MakeUpInformation
            {
                public Double Opening;
                public Double Closing;
                public int NbMakeUp;
                public int iIndexColor;
                public MakeUpInformation(Double Opening_, Double Closing_, int NbMakeUp_, int iIndexColor_)
                {
                    Opening = Opening_;
                    Closing = Closing_;
                    NbMakeUp = NbMakeUp_;
                    iIndexColor = iIndexColor_;
                    /*if (Closing > Opening)
                    {
                        Opening = Closing_;
                        Closing = Opening_;
                    }*/
                }
                public Double Difference
                {
                    get
                    {
                        return Math.Abs(Opening - Closing);
                    }
                }
            }




            public static int CountTerminalParking(DataTable FPTable)
            {
                if (!FPTable.Columns.Contains(GlobalNames.sFPD_A_Column_TerminalParking))
                    return 0;
                int iIndexTerminalParking = FPTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_TerminalParking);
                int iResult = 0;
                int iTmp;
                foreach (DataRow drLine in FPTable.Rows)
                {
                    if (!Int32.TryParse(drLine[iIndexTerminalParking].ToString(), out iTmp))
                        continue;
                    if (iResult < iTmp)
                        iResult = iTmp;
                }
                return iResult;
            }

            public static int CountTerminalGate(DataTable FPTable)
            {
                //<<Statistic tables
                if (FPTable == null)
                    return 0;
                //>>Statistic tables
                if (!FPTable.Columns.Contains(GlobalNames.sFPD_A_Column_TerminalGate))
                    return 0;
                int iIndexTerminalParking = FPTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_TerminalGate);
                int iResult = 0;
                int iTmp;
                foreach (DataRow drLine in FPTable.Rows)
                {
                    if (!Int32.TryParse(drLine[iIndexTerminalParking].ToString(), out iTmp))
                        continue;
                    if (iResult < iTmp)
                        iResult = iTmp;
                }
                return iResult;
            }
            public static int CountParking(DataTable FPTable, int iTerminal)
            {
                if (!FPTable.Columns.Contains(GlobalNames.sFPD_A_Column_Parking))
                    return 0;
                if (!FPTable.Columns.Contains(GlobalNames.sFPD_A_Column_TerminalParking))
                    return 0;
                int iIndexTerminalParking = FPTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_TerminalParking);
                int iIndexParking = FPTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_Parking);
                int iResult = 0;
                int iTerminalValue;
                int iParkingValue;
                foreach (DataRow drLine in FPTable.Rows)
                {
                    if (!Int32.TryParse(drLine[iIndexTerminalParking].ToString(), out iTerminalValue))
                        continue;
                    if (iTerminalValue != iTerminal)
                        continue;
                    if (!Int32.TryParse(drLine[iIndexParking].ToString(), out iParkingValue))
                        continue;
                    if (iResult < iParkingValue)
                        iResult = iParkingValue;
                }
                return iResult;
            }

            public static Point CheckEmptyArea(DataTable dtAllocationTable,
                                               int iOffsetColumns,
                                               int iIndexLigneStart,
                                               int iIndexLigneEnd,
                                               int iAllocatedColumns,
                                               bool bCheckAvailable,
                                               int iMinimumRows,
                                               int iMinimumColumns)
            {
                int i;
                //L'index de recherche se trouve en dehors de la table. Ce n'est pas alloué, on renvoie donc les coordonnées fictives
                //dans la table.
                if (iOffsetColumns >= dtAllocationTable.Columns.Count)
                    return new Point(iOffsetColumns, iOffsetColumns + iAllocatedColumns - 1);

                //On parcours la colonne courante de iMinimumRows en iMinimumRows.
                for (i = iIndexLigneStart; i <= (iIndexLigneEnd + iMinimumRows - 1); i += iMinimumRows)
                {
                    if (i > iIndexLigneEnd)
                        i = iIndexLigneEnd;
                    //L'une des cases de cette colonne n'est pas vide, on avance donc l'index de la colonne.
                    if (dtAllocationTable.Rows[i][iOffsetColumns].ToString().Length > 0)
                    {
                        if (bCheckAvailable)
                            return new Point(-1, iOffsetColumns);
                        return CheckEmptyArea(dtAllocationTable, iOffsetColumns + 1, iIndexLigneStart, iIndexLigneEnd, iAllocatedColumns, false, iMinimumColumns, iMinimumRows);
                    }
                }
                if (iAllocatedColumns == 1)
                    return new Point(iOffsetColumns, iOffsetColumns);
                int iColumnsNumber = iMinimumColumns;
                if (iMinimumColumns > iAllocatedColumns)
                    iColumnsNumber = iAllocatedColumns;

                int iNewAllocatedColumns = iAllocatedColumns - iColumnsNumber + 1;
                int iNewOffset = iOffsetColumns + iColumnsNumber - 1;
                if (iNewAllocatedColumns <= 0)
                    iNewAllocatedColumns = 1;


                //Si l'on est ici, cela indique que la colonne était valide. On va donc tester la colonne n+x.
                Point pResult = CheckEmptyArea(dtAllocationTable, iNewOffset, iIndexLigneStart, iIndexLigneEnd, iNewAllocatedColumns, true, iMinimumColumns, iMinimumRows);
                //Si le composant X du point est négatif, cela veut dire que la zone était invalide. On reprend donc depuis 
                //la colonne suivant l'index qui avait posé problème.
                if (pResult.X == -1)
                {
                    if (bCheckAvailable)
                        return pResult;
                    return CheckEmptyArea(dtAllocationTable, iOffsetColumns + iMinimumColumns + 1, iIndexLigneStart, iIndexLigneEnd, iAllocatedColumns, false, iMinimumColumns, iMinimumRows);
                }
                return new Point(iOffsetColumns, pResult.Y);
            }

            public static void AnalyseTableOccupation(DataTable dtAllocationTable, int iStartColumn, int iUsedColumn, int iNeededColumn, int iFlightNumberColumn)
            {
                if ((iStartColumn == -1) || (iUsedColumn == -1) || (iNeededColumn == -1))
                    return;
                if (iFlightNumberColumn >= dtAllocationTable.Columns.Count)
                    iFlightNumberColumn = -1;
                int iLastColumn = dtAllocationTable.Columns.Count;
                if ((iStartColumn >= iLastColumn) || (iUsedColumn >= iLastColumn) || (iNeededColumn >= iLastColumn))
                    return;
                foreach (DataRow drRow in dtAllocationTable.Rows)
                {
                    int iNumber = 0;
                    int iLastIndex = iStartColumn - 1;
                    List<String> lsFlightName = new List<string>();
                    for (int i = iStartColumn; i < dtAllocationTable.Columns.Count; i++)
                    {
                        if (drRow[i].ToString().Length > 0)
                        {
                            if (iFlightNumberColumn != -1)
                            {
                                String[] lsNames = drRow[i].ToString().Split(',');
                                foreach (String sName in lsNames)
                                {
                                    if (!lsFlightName.Contains(sName))
                                        lsFlightName.Add(sName);
                                }
                            }
                            iNumber++;
                            iLastIndex = i;
                        }
                    }
                    if (iNumber == 0)
                    {
                        iLastIndex = 0;
                    }
                    else
                    {
                        iLastIndex = iLastIndex - iStartColumn + 1;
                    }
                    drRow[iUsedColumn] = iLastIndex;
                    drRow[iNeededColumn] = iNumber;
                    if (iFlightNumberColumn != -1)
                        drRow[iFlightNumberColumn] = lsFlightName.Count;
                }
                dtAllocationTable.AcceptChanges();
            }

            public static bool CheckRowIsEmpty(DataTable dtAllocationTable, int iIndexColumn, int iIndexLigneStart, int iIndexLigneEnd)
            {
                int j;
                if (dtAllocationTable.Rows[iIndexLigneStart][iIndexColumn].ToString().Length > 0)
                    return false;
                if (dtAllocationTable.Rows[iIndexLigneEnd][iIndexColumn].ToString().Length > 0)
                    return false;
                for (j = iIndexLigneStart + 1; j < iIndexLigneEnd; j++)
                {
                    if (dtAllocationTable.Rows[j][iIndexColumn].ToString().Length > 0)
                        break;
                }
                if (j < iIndexLigneEnd)
                    return false;
                return true;
            }

            public static bool CheckColumnIsEmpty(DataTable dtAllocationTable, int iIndexColumn, int iIndexLigneStart, int iIndexLigneEnd, int iTolerance, String sCurrentFC, String[][] sAllocateFC)
            {
                int j;
                if ((sAllocateFC[iIndexLigneStart][iIndexColumn - 5] != null)
                    && (sAllocateFC[iIndexLigneStart][iIndexColumn - 5] != sCurrentFC))
                    return false;
                String sTmp = dtAllocationTable.Rows[iIndexLigneStart][iIndexColumn].ToString();
                if ((sTmp.Length > 0) && (sTmp.Split(',').Length > (iTolerance - 1)))
                    return false;

                if ((sAllocateFC[iIndexLigneEnd][iIndexColumn - 5] != null)
                    && (sAllocateFC[iIndexLigneEnd][iIndexColumn - 5] != sCurrentFC))
                    return false;
                sTmp = dtAllocationTable.Rows[iIndexLigneEnd][iIndexColumn].ToString();
                if ((sTmp.Length > 0) && (sTmp.Split(',').Length > (iTolerance - 1)))
                    return false;
                for (j = iIndexLigneStart + 1; j < iIndexLigneEnd; j++)
                {

                    if ((sAllocateFC[j][iIndexColumn - 5] != null)
                        && (sAllocateFC[j][iIndexColumn - 5] != sCurrentFC))
                        return false;
                    sTmp = dtAllocationTable.Rows[j][iIndexColumn].ToString();
                    if ((sTmp.Length > 0) && (sTmp.Split(',').Length > (iTolerance - 1)))
                        break;
                }
                if (j < iIndexLigneEnd)
                    return false;
                return true;
            }
            #endregion

            public static DataTable[] AllocateTransferInfeed(String NomTable,
                                                   DataTable dtFPA,
                                                   DataTable dtOCTTransfer,
                                                   DateTime dtBegin,
                                                   DateTime dtEnd,
                                                   Double dStep,
                                                   Double dTimeBetweenFlight,
                                                   int iNbTransfer,
                                                   int iTerminal,
                                                   bool bAllocateFlightPlan,
                                                   bool bColorByFC,
                                                   out VisualisationMode[] vmAllocationVisualisation,
                                                   Prompt.SIM_LoadingForm cht,
                                                   ArrayList alErrors)
            {
                vmAllocationVisualisation = null;
                if ((dtFPA == null) || (dtFPA.Rows.Count == 0))
                {
                    alErrors.Add("Err00720 : The flight plan table is empty.");
                    return null;
                }
                if ((dtOCTTransfer == null) || (dtOCTTransfer.Rows.Count == 0) || (dtOCTTransfer.Columns.Count == 0))
                {
                    alErrors.Add("Err00721 : The table for the rules to allocate the transfer infeed is empty.");
                    return null;
                }
                int iNbParking = CountParking(dtFPA, iTerminal);
                if (iNbParking == 0)
                {
                    alErrors.Add("Err00722 : The flight plan table does not contain any information about the parking.");
                    return null;
                }
                int i, k;
                DataTable[] dtAllocationTable = new DataTable[iNbParking];
                if (bColorByFC)
                    vmAllocationVisualisation = new VisualisationMode[iNbParking];
                for (k = 1; k <= iNbParking; k++)
                {
                    dtAllocationTable[k - 1] = new DataTable(NomTable + "_" + k.ToString());
                    dtAllocationTable[k - 1].Columns.Add("Time", typeof(DateTime));
                    dtAllocationTable[k - 1].Columns.Add("Transfer Infeed Occupied", typeof(int));
                    dtAllocationTable[k - 1].Columns.Add("Transfer Infeed Need", typeof(int));
                    if (bColorByFC)
                    {
                        vmAllocationVisualisation[k - 1] = new VisualisationMode(false, false, false, null, new int[] { 0 });
                        vmAllocationVisualisation[k - 1].ShowRowHeader = true;
                        vmAllocationVisualisation[k - 1].FirstColumnInHeader = true;
                        ConditionnalFormatErrors cfeErrors = new ConditionnalFormatErrors();
                        vmAllocationVisualisation[k - 1].ConditionnalFormatClass = new VisualisationMode.ConditionnalFormat[] { cfeErrors };
                    }
                    for (i = 1; i <= iNbTransfer; i++)
                    {
                        dtAllocationTable[k - 1].Columns.Add("Transfer Infeed" + i.ToString(), typeof(String));
                    }

                    DataFunctions.initialiserLignes(dtAllocationTable[k - 1], dtBegin, dtEnd, dStep);
                    for (i = 0; i < dtAllocationTable[k - 1].Rows.Count; i++)
                    {
                        dtAllocationTable[k - 1].Rows[i][1] = 0;
                        dtAllocationTable[k - 1].Rows[i][2] = 0;
                        if (bColorByFC)
                            ((ConditionnalFormatErrors)vmAllocationVisualisation[k - 1].ConditionnalFormatClass[0]).setCondition(2, i, Color.LightBlue);

                    }
                }
                if (dTimeBetweenFlight != 0)
                {
                    dTimeBetweenFlight = dTimeBetweenFlight / dStep;
                    if ((Double)dTimeBetweenFlight > (int)dTimeBetweenFlight)
                        dTimeBetweenFlight = ((int)dTimeBetweenFlight) + 1;
                }

                Hashtable htOCTMakeUp = new Hashtable();
                int iOpening = OverallTools.DataFunctions.indexLigne(dtOCTTransfer, 0, "Tranfer Opening Time (Min after STA)");
                int iClosing = OverallTools.DataFunctions.indexLigne(dtOCTTransfer, 0, "Transfer Closing Time (Min after STA)");
                int iIndexAllocationNbTransfer = OverallTools.DataFunctions.indexLigne(dtOCTTransfer, 0, "Number of allocated Transfer Infeed per flight");
                int iMinNbMakeUp = -1;
                Double dMinOpeningTime = -1;
                if ((iOpening == -1) || (iClosing == -1) || (iNbTransfer == -1))
                {
                    alErrors.Add("Err00723 : The table for the rules to allocate the transfer infeed does not have a good format. The lines have wrong names");
                    return null;
                }
                try
                {
                    for (i = 1; i < dtOCTTransfer.Columns.Count; i++)
                    {
                        MakeUpInformation newObject = new MakeUpInformation((Double)dtOCTTransfer.Rows[iOpening][i], (Double)dtOCTTransfer.Rows[iClosing][i], (Int32)((Double)dtOCTTransfer.Rows[iIndexAllocationNbTransfer][i]), i);
                        htOCTMakeUp.Add(dtOCTTransfer.Columns[i].ColumnName, newObject);
                        if ((iMinNbMakeUp == -1) || newObject.NbMakeUp < iMinNbMakeUp)
                            iMinNbMakeUp = newObject.NbMakeUp;
                        if ((dMinOpeningTime == -1) || newObject.Difference < dMinOpeningTime)
                            dMinOpeningTime = newObject.Difference;
                    }
                    dMinOpeningTime = dMinOpeningTime / dStep;
                }
                catch (Exception e)
                {
                    alErrors.Add("Err00724 : A problem appears : " + e.Message);
                    OverallTools.ExternFunctions.PrintLogFile("Err00724: AllocateTransferInfeed throw an exception: " + e.Message);
                    return null;
                }
                int iIndexFC = dtFPA.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightCategory);
                int iIndexAirline = dtFPA.Columns.IndexOf(GlobalNames.sFPD_A_Column_AirlineCode);

                int iIndexDate = dtFPA.Columns.IndexOf(GlobalNames.sFPD_A_Column_DATE);
                int iIndexSTA = dtFPA.Columns.IndexOf(GlobalNames.sFPA_Column_STA);
                int iIndexTerminalParking = dtFPA.Columns.IndexOf(GlobalNames.sFPD_A_Column_TerminalParking);
                int iIndexParking = dtFPA.Columns.IndexOf(GlobalNames.sFPD_A_Column_Parking);
                int iIndexTerminalTransfer = dtFPA.Columns.IndexOf(GlobalNames.sFPA_Column_TerminalInfeedObject);
                int iIndexTransfer = dtFPA.Columns.IndexOf(GlobalNames.sFPA_Column_TransferInfeedObject);



                if ((iIndexFC == -1) ||
                    (iIndexDate == -1) ||
                    (iIndexSTA == -1) ||
                    (iIndexTerminalParking == -1) ||
                    (iIndexParking == -1) ||
                    (iIndexTerminalTransfer == -1) ||
                    (iIndexTransfer == -1) ||
                    (iIndexAirline == -1))
                {
                    alErrors.Add("Err00725 : The flight plan table has a wrong format. Some columns are missing in the table.");
                    return null;
                }
                DateTime dateDepart, dateDebutAlloc, dateFinAlloc;
                Double dTimeDebutAlloc, dTimeFinAlloc;
                int iPosDebutAlloc, iPosFinAlloc;
                int iPosDebutLibre, iPosFinLibre;
                MakeUpInformation muiMakeUpInformation;
                int iTerminalTmp;

                while (htOCTMakeUp.Keys.Count > 0)
                {
                    String sCurrentFC = "";
                    Double dAllocTime = -1;
                    iNbTransfer = -1;
                    foreach (String keys in htOCTMakeUp.Keys)
                    {
                        if (((MakeUpInformation)htOCTMakeUp[keys]).Difference >= dAllocTime)
                        {
                            if (((MakeUpInformation)htOCTMakeUp[keys]).NbMakeUp > iNbTransfer)
                            {
                                sCurrentFC = keys;
                                iNbTransfer = ((MakeUpInformation)htOCTMakeUp[keys]).NbMakeUp;
                                dAllocTime = ((MakeUpInformation)htOCTMakeUp[keys]).Difference;
                            }
                        }
                    }
                    if (sCurrentFC == "")
                    {
                        alErrors.Add("Err00726 : The values in the Transfer Infeed allocation rules table are wrong.");
                        return null;
                    }
                    muiMakeUpInformation = (MakeUpInformation)htOCTMakeUp[sCurrentFC];
                    Color cCurrentColor = FonctionUtiles.getColor(muiMakeUpInformation.iIndexColor);
                    //vmAllocationVisualisation[k - 1].ConditionnalFormatClass
                    htOCTMakeUp.Remove(sCurrentFC);
                    foreach (DataRow Line in dtFPA.Rows)
                    {
                        if (Line[iIndexFC].ToString() != sCurrentFC)
                            continue;

                        dateDepart = DataFunctions.toDateTime(Line[iIndexDate], Line[iIndexSTA]);
                        if ((dateDepart < dtBegin))
                            continue;
                        if (!Int32.TryParse(Line[iIndexTerminalParking].ToString(), out iTerminalTmp))
                            continue;
                        if (iTerminal != iTerminalTmp)
                            continue;
                        int iParking;// = (int)Line[iIndexParking] - 1;;
                        if (!Int32.TryParse(Line[iIndexParking].ToString(), out iParking))
                            continue;
                        iParking--;
                        String sId = Line[GlobalNames.sFPD_A_Column_FlightN].ToString().Trim();
                        //MakeUpInformation
                        //On trouve désormais dans la table, la position de la nouvelle allocation.
                        dateDebutAlloc = dateDepart.AddMinutes(muiMakeUpInformation.Opening);
                        dateFinAlloc = dateDepart.AddMinutes(muiMakeUpInformation.Closing);
                        dTimeDebutAlloc = DataFunctions.MinuteDifference(dtBegin, dateDebutAlloc);
                        dTimeFinAlloc = DataFunctions.MinuteDifference(dtBegin, dateFinAlloc);
                        iPosDebutAlloc = (int)(dTimeDebutAlloc / dStep);
                        iPosFinAlloc = (int)(dTimeFinAlloc / dStep);
                        if (((Double)iPosFinAlloc) == dTimeFinAlloc / dStep)
                            iPosFinAlloc--;
                        if (iPosFinAlloc < 0)
                            continue;
                        //Il faut maintenant entouré le vol de 2
                        iPosDebutLibre = iPosDebutAlloc - (int)dTimeBetweenFlight;
                        iPosFinLibre = iPosFinAlloc + (int)dTimeBetweenFlight;
                        if (iPosDebutAlloc <= 0)
                        {
                            iPosDebutAlloc = 0;
                            iPosDebutLibre = 0;
                        }
                        if (iPosFinLibre >= dtAllocationTable[iParking].Rows.Count)
                            iPosFinLibre = dtAllocationTable[iParking].Rows.Count - 1;
                        if (iPosFinAlloc >= dtAllocationTable[iParking].Rows.Count)
                            iPosFinAlloc = dtAllocationTable[iParking].Rows.Count - 1;
                        bool bAllocation = false;
                        bool bValid = true;
                        int iLastTested = 0;
                        for (i = 3; i < dtAllocationTable[iParking].Columns.Count; i++)
                        {
                            /*if (!CheckRowIsEmpty(dtAllocationTable, i, iPosDebutLibre, iPosFinLibre))
                                continue;*/
                            iLastTested = 0;
                            while (bValid = CheckRowIsEmpty(dtAllocationTable[iParking], i + iLastTested, iPosDebutLibre, iPosFinLibre))
                            {

                                if (iLastTested == (muiMakeUpInformation.NbMakeUp - 1))
                                    break;
                                if ((iLastTested + iMinNbMakeUp) >= muiMakeUpInformation.NbMakeUp)
                                    iLastTested = muiMakeUpInformation.NbMakeUp - 1;
                                else
                                    iLastTested += iMinNbMakeUp;
                                if (i + iLastTested >= dtAllocationTable[iParking].Columns.Count)
                                    break;
                            }
                            if (i + iLastTested >= dtAllocationTable[iParking].Columns.Count)
                            {
                                break;
                            }

                            if (bValid)
                            //if (iLastTested == (muiMakeUpInformation.NbMakeUp - 1))
                            {
                                bAllocation = true;
                                break;
                            }
                            i += iLastTested;

                        }
                        if (!bAllocation)
                        {
                            alErrors.Add("Warn00727 : Unable to allocate Transfer infeed for flight number :\"" + sId + "\". No space found to allocate this flight.");
                            continue;
                        }
                        if (bAllocateFlightPlan)
                        {
                            Line[iIndexTerminalTransfer] = iTerminal;
                            Line[iIndexTransfer] = i - 2;
                            //Line[iIndexLastMakeUp] = i + iLastTested - 2;
                        }
                        //If we are here, that means that we have find the good allocation.
                        //The first column is i and the last is i + iLastTested
                        String sValue;
                        iLastTested = i + iLastTested;
                        for (; i <= iLastTested; i++)
                        {
                            for (int j = iPosDebutAlloc; j <= iPosFinAlloc; j++)
                            {
                                sValue = dtAllocationTable[iParking].Rows[j][i].ToString() + sId;
                                dtAllocationTable[iParking].Rows[j][i] = sValue;
                                dtAllocationTable[iParking].Rows[j][1] = ((int)dtAllocationTable[iParking].Rows[j][1]) + 1;
                                if (bColorByFC)
                                    ((ConditionnalFormatErrors)vmAllocationVisualisation[iParking].ConditionnalFormatClass[0]).setCondition(i, j, cCurrentColor);
                                if ((i == iLastTested) && (iLastTested - 2 > (int)dtAllocationTable[iParking].Rows[j][2]))
                                {
                                    dtAllocationTable[iParking].Rows[j][2] = iLastTested - 2;
                                }
                            }
                        }
                    }
                }
                dtFPA.AcceptChanges();
                foreach (DataTable dtTable in dtAllocationTable)
                    dtTable.AcceptChanges();
                return dtAllocationTable;
            }
            #endregion

            // >> Task #10440 Pax2Sim - Pax analysis - missing KPIs part 1
            public static double getAverageValueFromListOfNumbers(ArrayList valuesList)
            {
                double average = 0;

                if (valuesList == null || valuesList.Count == 0)
                    return average;

                double sum = 0;
                for (int i = 0; i < valuesList.Count; i++)
                {
                    double value = 0;
                    if (Double.TryParse(valuesList[i].ToString(), out value))
                    {
                        sum += value;
                    }
                }
                average = sum / valuesList.Count;

                return average;
            }
            // << Task #10440 Pax2Sim - Pax analysis - missing KPIs part 1

            // >> Task #15288 Pax2Sim - Admin mode - pdf not shown
            public static bool currentAppIsRunningAsAdmin()
            {
                return (new WindowsPrincipal(WindowsIdentity.GetCurrent()))
                        .IsInRole(WindowsBuiltInRole.Administrator);
            }
            // << Task #15288 Pax2Sim - Admin mode - pdf not shown
        }
        #endregion

        #region La classe ExternFunctions
        public class ExternFunctions
        {
            internal static bool CopyDirectory(String sOriginDirectory, String sDestinationDirectory, Prompt.SIM_LoadingForm slf_Form)
            {
                if (!CheckCreateDirectory(sDestinationDirectory))
                    return false;
                if (slf_Form != null)
                    slf_Form.ChargementFichier("Copying directory : " + sDestinationDirectory);
                String[] Directories = System.IO.Directory.GetDirectories(sOriginDirectory);
                if (slf_Form != null)
                    slf_Form.setFileNumber(slf_Form.getFileNumber() + Directories.Length);
                foreach (string sName in Directories)
                {
                    String ShortName = sName.Substring(sName.LastIndexOf("\\") + 1);
                    if (!CopyDirectory(sName, sDestinationDirectory + "\\" + ShortName, slf_Form))
                        return false;
                }

                String[] Files = System.IO.Directory.GetFiles(sOriginDirectory);
                if (slf_Form != null)
                    slf_Form.setFileNumber(slf_Form.getFileNumber() + Files.Length);
                foreach (string sName in Files)
                {
                    String ShortName = sName.Substring(sName.LastIndexOf("\\") + 1);
                    if (slf_Form != null)
                        slf_Form.ChargementFichier(ShortName);
                    System.IO.File.Copy(sName, sDestinationDirectory + "\\" + ShortName);
                }
                return true;
            }
            internal static bool MoveFile(String sDestinationPath, String sOriginPath, String sFileName, String ErrorMessage, ArrayList alErrors, Prompt.SIM_LoadingForm slf_Form)
            {
                try
                {
                    if (!System.IO.File.Exists(sDestinationPath + sFileName))
                    {
                        if (slf_Form != null)
                            slf_Form.ChargementFichier(sDestinationPath + sFileName);
                        System.IO.File.Move(sOriginPath + sFileName, sDestinationPath + sFileName);
                        if (!System.IO.File.Exists(sDestinationPath + sFileName))
                        {
                            if ((alErrors != null) && (ErrorMessage != null) && (ErrorMessage != ""))
                                alErrors.Add(ErrorMessage);
                            return false;
                        }
                    }
                }
                catch (Exception e)
                {
                    if ((alErrors != null) && (ErrorMessage != null) && (ErrorMessage != ""))
                    {
                        alErrors.Add(ErrorMessage);
                        OverallTools.ExternFunctions.PrintLogFile("Except02014: MoveFile throw an exception: " + e.Message);
                    }
                    else if ((alErrors != null))
                    {
                        alErrors.Add("Err00211 : Exception while trying to move a file : " + e.Message);
                        OverallTools.ExternFunctions.PrintLogFile("Err00211: MoveFile throw an exception: " + e.Message);
                    }
                    return false;
                }
                return true;
            }

            internal static bool CopyFile(String sDestinationPath, String sOriginPath, String sFileName, String ErrorMessage, ArrayList alErrors, Prompt.SIM_LoadingForm slf_Form)
            {
                try
                {
                    String sOrigin = sOriginPath;
                    if (!System.IO.File.Exists(sOrigin))
                        sOrigin += sFileName;
                    if ((!System.IO.File.Exists(sOrigin))
                         || (!CompareModificationTimeFiles(sDestinationPath + sFileName, sOrigin)))
                    {
                        if (slf_Form != null)
                            slf_Form.ChargementFichier(sDestinationPath + sFileName);

                        System.IO.File.Copy(sOrigin, sDestinationPath + sFileName, true);
                        if (!System.IO.File.Exists(sDestinationPath + sFileName))
                        {
                            if ((alErrors != null) && (ErrorMessage != null) && (ErrorMessage != ""))
                                alErrors.Add(ErrorMessage);
                            return false;
                        }
                    }
                }
                catch (Exception e)
                {
                    if ((alErrors != null) && (ErrorMessage != null) && (ErrorMessage != ""))
                    {
                        alErrors.Add(ErrorMessage);
                        OverallTools.ExternFunctions.PrintLogFile("Except02015: CopyFile throw an exception: " + e.Message);
                    }
                    else if ((alErrors != null))
                    {
                        alErrors.Add("Err00210 : Exception while trying to copy a file : " + e.Message);
                        OverallTools.ExternFunctions.PrintLogFile("Err00210: CopyFile throw an exception: " + e.Message);
                    }
                    else
                    {
                        OverallTools.ExternFunctions.PrintLogFile("Except02072: CopyFile throw an exception: " + e.Message);
                    }
                    return false;
                }
                return true;
            }

            internal static bool DeleteFile(String sFileName)
            {
                if (!File.Exists(sFileName))
                    return true;
                try
                {
                    File.Delete(sFileName);
                }
                catch (Exception exc)
                {
                    OverallTools.ExternFunctions.PrintLogFile("Except02016: DeleteFile throw an exception: " + exc.Message);
                    return false;
                }
                return true;
            }
            /// <summary>
            /// Function which compare 2 file and give a boolean which indicate if the 2 file are the same or not.
            /// </summary>
            /// <param name="sFirstFile"></param>
            /// <param name="sSecondFile"></param>
            /// <returns></returns>
            internal static bool CompareModificationTimeFiles(String sFirstFile, String sSecondFile)
            {
                if (!System.IO.File.Exists(sFirstFile))
                    return false;
                if (!System.IO.File.Exists(sSecondFile))
                    return false;
                FileInfo sFirstInfo = new FileInfo(sFirstFile);
                FileInfo sSecondInfo = new FileInfo(sSecondFile);
                if (sFirstInfo.LastWriteTimeUtc != sSecondInfo.LastWriteTimeUtc)
                    return false;
                return true;
            }

            /// <summary>
            /// Function which check for the presence of the directory and create it if it does not exist.
            /// </summary>
            /// <param name="name">The directory path</param>
            /// <returns>A boolean which indicate if the directory have be made correctly</returns>
            internal static bool CheckCreateDirectory(String name)
            {
                if (!System.IO.Directory.Exists(name))
                {
                    System.IO.Directory.CreateDirectory(name);
                }
                if (!System.IO.Directory.Exists(name))
                    return false;
                return true;
            }
            internal static String getTempDirectory()
            {
                return "C:\\Temp\\";
            }

            /// <summary>
            /// Function that returns the Directory of the application Data directory for the user.
            /// </summary>
            /// <returns></returns>
            internal static String getUserDirectory()
            {
                return Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\";
            }

            /// <summary>
            /// Function that returns the directory of the application data for Pax2sim.
            /// </summary>
            /// <returns></returns>
            internal static String getUserDirectoryForPax2sim()
            {
                String sDirectory = getUserDirectory() + "HubPerformance Software\\" + AssemblyActions.AssemblyTitle + "\\";//"Simcore Software\\"+AssemblyActions.AssemblyTitle+"\\";
                if (!Directory.Exists(sDirectory))
                {
                    try
                    {
                        if (!OverallTools.ExternFunctions.CheckCreateDirectory(sDirectory))
                            return "";
                    }
                    catch (Exception exc)
                    {
                        OverallTools.ExternFunctions.PrintLogFile("Except02017: getUserDirectoryForPax2Sim throw an exception: " + exc.Message);
                        return "";
                    }
                }
                return sDirectory;
            }

            internal static String getPax2simDirectory()
            {
                return Application.StartupPath + "\\";
            }

            /// <summary>
            /// Function that returns the temp directory of the application data for Pax2sim.
            /// </summary>
            /// <returns></returns>
            internal static String getTempDirectoryForPax2sim()
            {
                String sDirectory = getUserDirectoryForPax2sim() + AssemblyActions.getId.ToString() + "\\";
                if (!Directory.Exists(sDirectory))
                {
                    try
                    {
                        if (!OverallTools.ExternFunctions.CheckCreateDirectory(sDirectory))
                            return "";
                    }
                    catch (Exception exc)
                    {
                        OverallTools.ExternFunctions.PrintLogFile("Except02018: getTempDirectoryFoxPax2sim throw an exception: " + exc.Message);
                        return "";
                    }
                }
                return sDirectory;
            }
            /// <summary>
            /// Fonction qui supprime le dossier temporaire ainsi que les eventuels autres dossiers oublié lors d'execution précédante. 
            /// </summary>
            internal static void DeleteTempDirectory()
            {
                String tempFolder = getUserDirectoryForPax2sim();

                // Recherche des autres instance de Pax2Sim
                Process[] processlist = Process.GetProcesses();
                String thisName = Process.GetCurrentProcess().ProcessName;
                List<String> P2S_ProcessList = new List<String>();
                foreach (Process theprocess in processlist)
                    if (theprocess.MainWindowTitle.StartsWith(AssemblyActions.AssemblyTitle))
                        P2S_ProcessList.Add(theprocess.Id.ToString());

                // Suppression des dossiers inutiles
                String[] dirs = System.IO.Directory.GetDirectories(tempFolder);
                foreach (String dir in dirs)
                {
                    String name = System.IO.Path.GetFileName(dir);
                    if (!P2S_ProcessList.Contains(name))
                    {
                        try
                        {
                            Int16 i = new Int16();
                            if (Int16.TryParse(name, out i) && name.Length == 4)
                                DeleteDirectory(dir);
                        }
                        catch
                        { }
                    }
                }

                // Supression du dossier de l'instance courante
                OverallTools.ExternFunctions.DeleteDirectory(OverallTools.ExternFunctions.getTempDirectoryForPax2sim());
            }
            internal static bool DeleteDirectory(String sDirectory)
            {
                if (!Directory.Exists(sDirectory))
                    return true;
                try
                {
                    System.IO.Directory.Delete(sDirectory, true);
                }
                catch (Exception e)
                {
                    PrintLogFile("Err00336 : Unable to delete directory : \"" + sDirectory + "\": \t\r" + e.Message);
                    OverallTools.ExternFunctions.PrintLogFile("Err00336: DeleteDirectory throw an exception: " + e.Message);
                    return false;
                }
                return true;
            }

            /// <summary>
            /// Function that copy a file from the application Resource to
            /// the specified Destination Directory.
            /// </summary>
            /// <param name="ResourceName">Name of the file.</param>
            /// <param name="DestinationDirectory">Name of the file that will be created.</param>
            internal static void copyResourceFile(String ResourceName, String FullDestinationPath)
            {
                //The file stream to be saved.
                Stream fileStream = null;
                //The destination file opened in binary mode (to be able to save image too)
                BinaryWriter bw = null;
                try
                {
                    //We try to get the current assembly.
                    System.Reflection.Assembly asm =
                        System.Reflection.Assembly.GetExecutingAssembly();
                    //In the assembly we try to get the ressource

                    fileStream = asm.GetManifestResourceStream("SIMCORE_TOOL.Resources." + ResourceName);
                    //If the ressource does not exist in the assembly, then we stop the function.
                    if (fileStream == null)
                        return;
                    //We create the new binaryWriter that will receive the data.
                    bw = new BinaryWriter(File.Open(FullDestinationPath, FileMode.Create));

                    //The buffer size
                    int count = 256;
                    //The offset in the file (always 0)
                    int iSize = 0;
                    //The tempory buffer.
                    byte[] buffer = new Byte[count];
                    //The first read in the file.
                    int iTmp = fileStream.Read(buffer, iSize, count);

                    //While the number of bits readed is not null.
                    while (iTmp > 0)
                    {
                        //We save the buffer size
                        bw.Write(buffer, 0, iTmp);
                        //We read again in the file.
                        iTmp = fileStream.Read(buffer, iSize, count);
                    }
                }
                catch (Exception exc)
                {
                    OverallTools.ExternFunctions.PrintLogFile("Except02019: copyResourceFile throw an exception: " + exc.Message);
                }
                //We close the 2 files.
                if (fileStream != null)
                    fileStream.Close();
                if (bw != null)
                    bw.Close();
            }

            internal static string getPax2SimLogFilePath()
            {
                return getPax2simDirectory() + "Log.txt";
            }

            static StreamWriter twTmp = null;
            // << Task #8604 Pax2Sim - Log File - accessible while running the application                        
            /// <summary>
            /// Function that permits to write in a Log file (when problems appears).
            /// </summary>
            /// <param name="sMessage">The message to write in the Log File</param>
            internal static void PrintLogFile(String sMessage)
            {
                try
                {
                    String sLogFile = getPax2SimLogFilePath();

                    if (File.Exists(sLogFile))
                    {
                        System.IO.FileInfo fi = new FileInfo(sLogFile);

                        if (sMessage.Equals(GlobalNames.NEW_APPLICATION_INSTANCE))
                        {
                            try
                            {
                                File.Delete(sLogFile);
                            }
                            catch (Exception exc)
                            {
                                //do nothing - will not write a log for the 2nd instance. possible solution - change the log name by adding an unique id(appId)
                                return;
                                //OverallTools.ExternFunctions.PrintLogFile("Except02016: DeleteFile throw an exception: " + exc.Message);

                            }
                        }
                    }
                    twTmp = new StreamWriter(File.Open(sLogFile, FileMode.Append, FileAccess.Write));
                    if (twTmp == null)
                        return;

                    twTmp.Write(DateTime.Now.ToString() + " ==> " + sMessage);
                    twTmp.Write(System.Environment.NewLine);
                    twTmp.Flush();
                    twTmp.Close();
                }
                catch (Exception exc)
                {
                    if (sMessage.Contains("Except02020"))
                    {
                        if (twTmp != null)
                            twTmp.Close();
                        return;
                    }
                    OverallTools.ExternFunctions.PrintLogFile("Except02020: PrintLogFile throw an exception: " + exc.Message);
                    return;
                }
            }
            // >> Task #8604 Pax2Sim - Log File - accessible while running the application

            /// <summary>
            /// Function to test if the file is older than 'Seconds' seconds.
            /// </summary>
            /// <param name="FilePath"></param>
            /// <param name="Seconds"></param>
            /// <returns></returns>
            internal static bool IsOlderThan(String FilePath, int Seconds)
            {
                if (!File.Exists(FilePath))
                    return true;
                DateTime createDate = File.GetCreationTime(FilePath).AddSeconds(Seconds);
                DateTime now = DateTime.Now;
                int comp = createDate.CompareTo(now);
                if (createDate.CompareTo(now) == -1)  // return -1 if 'createDate' is older than 'now'
                    return true;
                return false;
            }

            internal static void MoveCurrentDirectory()
            {
                try
                {
                    String sRoot = System.IO.Path.GetPathRoot(Application.StartupPath);
                    System.IO.Directory.SetCurrentDirectory(sRoot);
                }
                catch (Exception e)
                {
                    PrintLogFile("Err00331 : a problem appears during the saving of the project : \t\r" + e.Message);
                    OverallTools.ExternFunctions.PrintLogFile("Err00331: MoveCurrentDirectory throw an exception: " + e.Message);
                }
            }
        }
        #endregion

        #region La classe FormFunctions
        public class FormFunctions
        {
            internal static void FillControl(Control cbMother, DataTable dtTable, int iIndexRecherche, int iIndexValue)
            {
                if (iIndexValue > dtTable.Columns.Count)
                    return;
                if (iIndexRecherche > dtTable.Columns.Count)
                    return;

                foreach (Control cChild in cbMother.Controls)
                {

                    if (cChild.Controls.Count != 0)
                        FillControl(cChild, dtTable, iIndexRecherche, iIndexValue);
                    if ((cChild.Tag == null) || (cChild.Tag.GetType() != typeof(String)))
                        continue;
                    int iIndexLigne = OverallTools.DataFunctions.indexLigne(dtTable, iIndexRecherche, cChild.Tag.ToString());
                    if (iIndexLigne == -1)
                        continue;
                    String sValue = dtTable.Rows[iIndexLigne][iIndexValue].ToString();
                    if (sValue == "")
                        sValue = "0";
                    if (cChild.GetType() == typeof(TextBox))
                        ((TextBox)cChild).Text = sValue;

                    if (cChild.GetType() == typeof(CheckBox))
                        ((CheckBox)cChild).Checked = (sValue == "1");
                }
            }
            internal static void SaveControl(Control cbMother, DataTable dtTable, int iIndexRecherche, int iIndexValue)
            {
                if (iIndexValue > dtTable.Rows.Count)
                    return;
                if (iIndexRecherche > dtTable.Rows.Count)
                    return;

                foreach (Control cChild in cbMother.Controls)
                {

                    if (cChild.Controls.Count != 0)
                        SaveControl(cChild, dtTable, iIndexRecherche, iIndexValue);
                    if ((cChild.Tag == null) || (cChild.Tag.GetType() != typeof(String)))
                        continue;
                    int iIndexLigne = OverallTools.DataFunctions.indexLigne(dtTable, iIndexRecherche, cChild.Tag.ToString());
                    if (iIndexLigne == -1)
                        continue;

                    String sValue = "0";
                    if (cChild.GetType() == typeof(TextBox))
                        sValue = ((TextBox)cChild).Text;
                    if ((cChild.GetType() == typeof(CheckBox))
                         && ((CheckBox)cChild).Checked)
                        sValue = "1";

                    dtTable.Rows[iIndexLigne][iIndexValue] = FonctionsType.getType(sValue, dtTable.Columns[iIndexValue].DataType);
                }
            }


            internal static void CheckInteger(object sender, EventArgs e)
            {
                if (sender.GetType() != typeof(TextBox))
                    return;
                int iTmp;
                if ((!Int32.TryParse(((TextBox)sender).Text, out iTmp)) || (iTmp <= 0))
                    ((TextBox)sender).BackColor = Color.Red;
                else
                    ((TextBox)sender).BackColor = Color.White;
            }
            internal static void CheckDouble(object sender, EventArgs e)
            {
                if (sender.GetType() != typeof(TextBox))
                    return;
                String sValue = ((TextBox)sender).Text.Trim();
                Double iTmp;
                if ((!Double.TryParse(((TextBox)sender).Text, out iTmp)) || (iTmp < 0))
                    ((TextBox)sender).BackColor = Color.Red;
                else
                    ((TextBox)sender).BackColor = Color.White;
            }
            internal static bool VerifData(Control cMotherObject)
            {
                foreach (Control cObject in cMotherObject.Controls)
                {
                    if ((cObject.GetType() == typeof(TextBox)) && (cObject.BackColor.ToArgb() != Color.White.ToArgb()) &&
                        (cObject.Enabled) && (cObject.Visible))
                    {
                        return false;
                    }
                    if ((cObject.Controls.Count > 0) && (!VerifData(cObject)))
                        return false;
                }
                return true;
            }
            internal static int FindIndexDansCombo(ComboBox cbCombo, Double dValue)
            {
                for (int i = 0; i < cbCombo.Items.Count; i++)
                {
                    if ((cbCombo.Items[i] == null) || (cbCombo.Items[i].ToString() == ""))
                        continue;
                    String sValue = cbCombo.Items[i].ToString();
                    Double dValueCombo;
                    if (!Double.TryParse(sValue, out dValueCombo))
                        continue;
                    if (dValue == dValueCombo)
                        return i;
                }
                return -1;
            }

            internal static void SortComboBox(ComboBox cbCombo)
            {
                String sOldValue = cbCombo.Text;
                ArrayList alList = new ArrayList();
                foreach (String sItem in cbCombo.Items)
                    alList.Add(sItem);
                alList.Sort(new FonctionUtiles.ColumnsComparer());
                cbCombo.Items.Clear();
                cbCombo.Text = "";
                cbCombo.Items.AddRange(alList.ToArray());
                cbCombo.Text = sOldValue;
            }

            internal static void afficherElement(ComboBox cb, String sValeur, bool bUseAlpha)
            {

                int iValeur = 0;
                if ((!bUseAlpha) && (!Int32.TryParse(sValeur, out iValeur)))
                    return;
                int i2Valeur;
                foreach (String text in cb.Items)
                {
                    String sDescription = GestionDonneesHUB2SIM.ConvertName(text, bUseAlpha);
                    if ((bUseAlpha) && (sValeur.Trim().ToLower() == sDescription.Trim().ToLower()))
                    {
                        cb.SelectedItem = text;
                        return;
                    }

                    if ((!bUseAlpha) && (Int32.TryParse(sDescription, out i2Valeur) && (i2Valeur == iValeur)))
                    {
                        cb.SelectedItem = text;
                        return;
                    }
                }
            }

            internal class ManageUserData
            {
                private bool bCheckBox;
                private Control ctrlControl;
                private Point pLocation;

                private List<System.Windows.Forms.CheckBox> cb_UD_Name;
                private List<System.Windows.Forms.Label> lbl_UD_Name;
                private List<System.Windows.Forms.ComboBox> cb_UD_Selected;

                internal ManageUserData(bool CheckBox, Control ctrl, Point LocationFirst)
                {
                    bCheckBox = CheckBox;
                    ctrlControl = ctrl;
                    pLocation = LocationFirst;
                    cb_UD_Name = new List<CheckBox>();
                    lbl_UD_Name = new List<Label>();
                    cb_UD_Selected = new List<ComboBox>();
                }

                internal void AddUserData(String sName, List<String> lsValues)
                {
                    AddUserData(true, sName, lsValues, null);
                }

                internal void AddUserData(bool bChecked, String sName, List<String> lsValues, String sSelected)
                {
                    CheckBox cbCheckBox = new CheckBox();
                    Label blbLabel = new Label();
                    ComboBox cbComboBox = new ComboBox();

                    int iIndex = cb_UD_Name.Count;
                    //ctrlControl
                    //    cb_UD_Name[
                    //lbl_UD_Name[iIndexUserData] = new System.Windows.Forms.Label();
                    //cb_UD_Selected[iIndexUserData] = new System.Windows.Forms.ComboBox();

                    cbCheckBox.Visible = bCheckBox;
                    cbCheckBox.Location = new System.Drawing.Point(pLocation.X, iIndex * 25 + pLocation.Y + 2);
                    cbCheckBox.TabIndex = iIndex * 3;
                    cbCheckBox.Name = "cb_UD_Name_" + iIndex.ToString();
                    cbCheckBox.CheckedChanged += new EventHandler(cbCheckBox_CheckedChanged);
                    cbCheckBox.Tag = cbComboBox;
                    cbCheckBox.Checked = bChecked || (!bCheckBox);
                    cbCheckBox.Text = sName;

                    // 
                    // lbl_UD_Name
                    // 
                    blbLabel.AutoSize = true;
                    blbLabel.Visible = !bCheckBox;
                    blbLabel.Location = new System.Drawing.Point(pLocation.X + 18, iIndex * 25 + pLocation.Y + 2);
                    blbLabel.Name = "lbl_UD_Name_" + iIndex.ToString();
                    blbLabel.Size = new System.Drawing.Size(216, 13);
                    blbLabel.TabIndex = iIndex * 3 + 1;
                    blbLabel.Text = sName;

                    // 
                    // cb_UD_Selected
                    // 
                    cbComboBox.Location = new System.Drawing.Point(pLocation.X + 238, iIndex * 25 + pLocation.Y);
                    cbComboBox.Name = "cb_UD_Selected_" + iIndex.ToString();
                    cbComboBox.Size = new System.Drawing.Size(250, 20);
                    cbComboBox.TabIndex = iIndex * 3 + 2;
                    cbComboBox.DropDownStyle = ComboBoxStyle.DropDownList;
                    cbComboBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
                                | System.Windows.Forms.AnchorStyles.Right)));
                    if (lsValues == null)
                    {
                        cbComboBox.Items.Add(sName);
                        cbComboBox.SelectedIndex = 0;
                    }
                    else
                    {
                        cbComboBox.Items.AddRange(lsValues.ToArray());
                        int iSelected = 0;
                        if (sSelected != null)
                        {
                            iSelected = cbComboBox.Items.IndexOf(sSelected);
                            if (iSelected == -1)
                                iSelected = 0;
                        }
                        if (lsValues.Count != 0)
                            cbComboBox.SelectedIndex = iSelected;

                    }
                    ctrlControl.Controls.Add(cbCheckBox);
                    cb_UD_Name.Add(cbCheckBox);
                    ctrlControl.Controls.Add(blbLabel);
                    lbl_UD_Name.Add(blbLabel);
                    ctrlControl.Controls.Add(cbComboBox);
                    cb_UD_Selected.Add(cbComboBox);
                }

                void cbCheckBox_CheckedChanged(object sender, EventArgs e)
                {
                    if (sender.GetType() != typeof(CheckBox))
                        return;
                    if ((((CheckBox)sender).Tag == null) || (((CheckBox)sender).Tag.GetType() != typeof(ComboBox)))
                        return;
                    ((ComboBox)((CheckBox)sender).Tag).Enabled = ((CheckBox)sender).Checked;
                }

                internal void SetUserData(String sName, bool bChecked, String sValue)
                {
                    for (int i = 0; i < lbl_UD_Name.Count; i++)
                    {
                        if (lbl_UD_Name[i].Text == sName)
                        {
                            if (cb_UD_Name[i].Checked != bChecked)
                                cb_UD_Name[i].Checked = bChecked;
                            if (bChecked)
                            {
                                if (cb_UD_Selected[i].Items.Contains(sValue))
                                    cb_UD_Selected[i].SelectedIndex = cb_UD_Selected[i].Items.IndexOf(sValue);
                                else
                                    cb_UD_Selected[i].SelectedIndex = 0;
                            }
                        }
                    }
                }

                internal void ReinitializeToDefault()
                {
                    for (int i = 0; i < lbl_UD_Name.Count; i++)
                    {
                        cb_UD_Name[i].Checked = true;
                        if (cb_UD_Selected[i].Items.Count > 0)
                            cb_UD_Selected[i].Text = cb_UD_Selected[i].Items[0].ToString();
                    }
                }

                internal Classes.ParamUserData getParamUserData()
                {
                    return getParamUserData(Classes.ParamUserData.CONSTUserData);
                }
                internal Classes.ParamUserData getParamUserData(String UserDataType)
                {
                    if (cb_UD_Name == null)
                        return null;
                    if (cb_UD_Name.Count == 0)
                        return null;
                    Classes.ParamUserData pudResult = new Classes.ParamUserData(UserDataType, new Dictionary<String, String>());
                    for (int i = 0; i < cb_UD_Name.Count; i++)
                    {
                        if (((bCheckBox) && (cb_UD_Name[i].Checked)) || (!bCheckBox))
                            pudResult.setUserData(cb_UD_Name[i].Text, cb_UD_Selected[i].Text);
                    }
                    return pudResult;
                }


                internal static ManageUserData InitializeForm(bool CheckBox, Control ctrl, Point Location, List<String> Names, List<List<String>> Values)
                {
                    if (Names == null)
                        return null;
                    if (Values == null)
                        return null;
                    ManageUserData mudResult = new ManageUserData(CheckBox, ctrl, Location);
                    for (int i = 0; i < Names.Count; i++)
                    {
                        mudResult.AddUserData(Names[i], Values[i]);
                    }
                    return mudResult;
                }

                internal void setParamUserData(Classes.ParamUserData pudParams)
                {
                    if ((pudParams == null) || (lbl_UD_Name == null) || (lbl_UD_Name.Count == 0))
                    {
                        if (((lbl_UD_Name == null) || (lbl_UD_Name.Count == 0)) || (!bCheckBox))
                            return;
                        foreach (CheckBox cb in cb_UD_Name)
                        {
                            cb.Checked = false;
                        }
                        return;
                    }
                    for (int i = 0; i < lbl_UD_Name.Count; i++)
                    {
                        String sSelected = pudParams.getUserData(lbl_UD_Name[i].Text);
                        int iSelected = -1;
                        if (sSelected != null)
                        {
                            iSelected = cb_UD_Selected[i].Items.IndexOf(sSelected);
                        }
                        else
                        {
                            if (bCheckBox)
                            {
                                cb_UD_Name[i].Checked = false;
                                continue;
                            }
                        }
                        if (iSelected == -1)
                            iSelected = 0;
                        if (!cb_UD_Name[i].Checked)
                            cb_UD_Name[i].Checked = true;
                        cb_UD_Selected[i].SelectedIndex = iSelected;
                    }
                }



                /*internal void setParamUserData(Prompt.SIM_Scenarios_Assistant.ParamUserData pud_Data)
                {
                    for (int i = 0; i < cb_UD_Name.Count; i++)
                    {
                        String sValue = pud_Data.getUserData(lbl_UD_Name[i].Text);
                        if ((sValue == null) && (bCheckBox) && (cb_UD_Name[i].Checked))
                            cb_UD_Name[i].Checked = false;
                        else if (!cb_UD_Name[i].Checked)
                            cb_UD_Name[i].Checked = true;

                        if (!cb_UD_Selected[i].Items.Contains(sValue))
                        {
                            cb_UD_Selected[i].Text = sValue;
                        }
                        else
                        {
                            if (cb_UD_Selected[i].Items.Count > 0)
                                cb_UD_Selected[i].SelectedIndex = 0;
                            else
                                cb_UD_Selected[i].Text = "";
                        }
                    }
                }*/
            }

            #region Impression écran des controles contenus dans un formulaire

            public static void DrawControl(Control control, Bitmap bitmap)
            {
                DrawControl(control, bitmap, new Point(0, 0));
            }
            public static void DrawControl(Control control, Bitmap bitmap, Point ptDecalage)
            {
                if (!typeof(Panel).IsInstanceOfType(control))
                    control.DrawToBitmap(bitmap, new Rectangle(control.Bounds.X + ptDecalage.X, control.Bounds.Y + ptDecalage.Y, control.Bounds.Width, control.Bounds.Height));

                if (typeof(GroupBox).IsInstanceOfType(control))
                    return;
                foreach (Control childControl in control.Controls)
                {
                    DrawControl(childControl, bitmap, new Point(ptDecalage.X + control.Location.X, ptDecalage.Y + control.Location.Y));
                }
            }

            internal static Image SaveImage(Control control)
            {
                //graphic.CopyFromScreen(this.Location, Point.Empty, this.Size);
                DockStyle ds = DockStyle.None;
                if (typeof(Panel).IsInstanceOfType(control))
                {
                    ds = ((Panel)control).Dock;
                    ((Panel)control).Dock = DockStyle.None;
                }
                Image bitmap = OverallTools.FonctionUtiles.dessinerFondEcran(control.Width, control.Height, PAX2SIM.Couleur1, PAX2SIM.Couleur2, PAX2SIM.Angle);

                DrawControl(control, (Bitmap)bitmap);

                if (typeof(Panel).IsInstanceOfType(control))
                {
                    ((Panel)control).Dock = ds;
                }
                return bitmap;
            }
            #endregion
        }
        #endregion

        #region La classe DataFunctions
        public class DataFunctions
        {

            #region Fonction qui effectue la somme des noms des colonnes passées en paramêtres.
            /// <summary>
            /// Fonction qui ajoute la colonne \ref sNewColumnName à la table, et ensuite, pour chaque
            /// ligne de la table, elle remplie la nouvelle colonne avec la somme des valeurs des colonnes
            /// contenues dans \ref tsColumnNames_. La fonction renvoie Faux, si elle n'a pas pu faire le
            /// calcul.
            /// 
            /// </summary>
            /// <param name="Table_">The table</param>
            /// <param name="tsColumnNames_">The columns to sum.</param>
            /// <param name="sNewColumnName">The column where to store the sum.</param>
            /// <returns>return false if a problem appears</returns>
            public static bool SumColumns(DataTable Table_, String[] tsColumnNames_, String sNewColumnName)
            {
                if (tsColumnNames_.Length == 0)
                    return false;
                int iColumnsIndex = 0;
                foreach (String sName in tsColumnNames_)
                {
                    iColumnsIndex = Table_.Columns.IndexOf(sName);
                    if (iColumnsIndex == -1)
                        return false;
                    if ((Table_.Columns[iColumnsIndex].DataType != typeof(Double)) &&
                        (Table_.Columns[iColumnsIndex].DataType != typeof(double)) &&
                        (Table_.Columns[iColumnsIndex].DataType != typeof(int)) &&
                        (Table_.Columns[iColumnsIndex].DataType != typeof(Int16)) &&
                        (Table_.Columns[iColumnsIndex].DataType != typeof(Int32)) &&
                        (Table_.Columns[iColumnsIndex].DataType != typeof(Int64)))
                        return false;
                }
                int iIndexNewColumn = Table_.Columns.IndexOf(sNewColumnName);
                if (iIndexNewColumn == -1)
                {
                    Table_.Columns.Add(sNewColumnName, typeof(Double));
                    iIndexNewColumn = Table_.Columns.Count - 1;
                }
                else
                {
                    if ((Table_.Columns[iIndexNewColumn].DataType != typeof(Double)) &&
                        (Table_.Columns[iIndexNewColumn].DataType != typeof(double)))
                        return false;
                }
                /*
                foreach (DataRow lignes in Table_.Rows)
                {
                    lignes[iIndexNewColumn] = 0;
                }*/
                int[] iIndexColumns = new Int32[tsColumnNames_.Length];
                Type[] tTypeColumns = new Type[tsColumnNames_.Length];
                for (int i = 0; i < tsColumnNames_.Length; i++)
                {
                    iIndexColumns[i] = Table_.Columns.IndexOf(tsColumnNames_[i]);
                    tTypeColumns[i] = Table_.Columns[iIndexColumns[i]].DataType;
                }
                Double dResult;
                foreach (DataRow lignes in Table_.Rows)
                {
                    dResult = 0;
                    for (int j = 0; j < iIndexColumns.Length; j++)
                    {
                        // >> Task #10764 Pax2Sim - new User attributes for Groups
                        if (lignes[iIndexColumns[j]] == null)
                        {
                            //OverallTools.ExternFunctions.PrintLogFile("Error while analysing passengers results. "
                            //                + "The table " + Table_.TableName + " has invalid data on column " + j + " row " + iIndexColumns[j] + ".");   // >> Pax trace analysis - Sum and BagPlan_2.txt
                            continue;
                        }
                        if ((tTypeColumns[j] == typeof(Double)) || (tTypeColumns[j] == typeof(double)))
                        {
                            double d = -1;
                            if (!Double.TryParse(lignes[iIndexColumns[j]].ToString(), out d))
                            {
                                //OverallTools.ExternFunctions.PrintLogFile("Error while analysing passengers results. "
                                //           + "The table " + Table_.TableName + " has invalid data on column " + j + " row " + iIndexColumns[j] + ".");    // >> Pax trace analysis - Sum and BagPlan_2.txt
                                continue;
                            }
                            dResult += (Double)lignes[iIndexColumns[j]];
                        }
                        else
                        {
                            int integer = -1;
                            if (!Int32.TryParse(lignes[iIndexColumns[j]].ToString(), out integer))
                            {
                                //OverallTools.ExternFunctions.PrintLogFile("Error while analysing passengers results. "
                                //            + "The table " + Table_.TableName + " has invalid data on column " + j + " row " + iIndexColumns[j] + ".");   // >> Pax trace analysis - Sum and BagPlan_2.txt
                                continue;
                            }
                            dResult += (int)lignes[iIndexColumns[j]];
                        }
                        // << Task #10764 Pax2Sim - new User attributes for Groups
                    }
                    lignes[iIndexNewColumn] = dResult;
                }
                return true;
            }

            /// <summary>
            /// Function which create a new table with the sum of the columns of the two tables passed in parameters.
            /// </summary>
            /// <param name="sNewTableName">The name of the new table.</param>
            /// <param name="TableD_">The first table</param>
            /// <param name="tsColumnNamesD_">The names of the columns of the first table to copy</param>
            /// <param name="TableA_">The second table</param>
            /// <param name="tsColumnNamesA_">The names of the columns of the second table to add to the columns of the first table</param>
            /// <param name="iNbKeyColumns">The number of columns of the first table to copy in the new table</param>
            /// <returns>null if a problem appear, in other case it's the new table.</returns>
            public static DataTable SumColumns(String sNewTableName, DataTable TableD_, String[] tsColumnNamesD_, DataTable TableA_, String[] tsColumnNamesA_, int iNbKeyColumns)
            {
                if (tsColumnNamesD_.Length == 0)
                    return null;
                if (tsColumnNamesA_.Length != tsColumnNamesD_.Length)
                    return null;
                if (iNbKeyColumns > TableD_.Columns.Count)
                    return null;
                int iColumnsIndex = 0;
                foreach (String sName in tsColumnNamesD_)
                {
                    iColumnsIndex = TableD_.Columns.IndexOf(sName);
                    if (iColumnsIndex == -1)
                        return null;
                    if ((TableD_.Columns[iColumnsIndex].DataType != typeof(Double)) &&
                        (TableD_.Columns[iColumnsIndex].DataType != typeof(double)) &&
                        (TableD_.Columns[iColumnsIndex].DataType != typeof(int)) &&
                        (TableD_.Columns[iColumnsIndex].DataType != typeof(Int16)) &&
                        (TableD_.Columns[iColumnsIndex].DataType != typeof(Int32)) &&
                        (TableD_.Columns[iColumnsIndex].DataType != typeof(Int64)))
                        return null;
                }
                foreach (String sName in tsColumnNamesA_)
                {
                    iColumnsIndex = TableA_.Columns.IndexOf(sName);
                    if (iColumnsIndex == -1)
                        return null;
                    if ((TableA_.Columns[iColumnsIndex].DataType != typeof(Double)) &&
                        (TableA_.Columns[iColumnsIndex].DataType != typeof(double)) &&
                        (TableA_.Columns[iColumnsIndex].DataType != typeof(int)) &&
                        (TableA_.Columns[iColumnsIndex].DataType != typeof(Int16)) &&
                        (TableA_.Columns[iColumnsIndex].DataType != typeof(Int32)) &&
                        (TableA_.Columns[iColumnsIndex].DataType != typeof(Int64)))
                        return null;
                }
                DataTable Result = new DataTable(sNewTableName);
                int i;
                for (i = 0; i < iNbKeyColumns; i++)
                {
                    Result.Columns.Add(TableD_.Columns[i].ColumnName, TableD_.Columns[i].DataType);
                }

                foreach (String sName in tsColumnNamesD_)
                {
                    Result.Columns.Add(sName, typeof(Double));
                }
                foreach (DataRow lignes in TableD_.Rows)
                {
                    DataRow newRow = Result.NewRow();
                    for (i = 0; i < iNbKeyColumns; i++)
                    {
                        newRow[i] = lignes[i];
                    }
                    foreach (String sName in tsColumnNamesD_)
                    {
                        i = TableD_.Columns.IndexOf(sName);
                        newRow[i] = lignes[i];
                    }
                    Result.Rows.Add(newRow);
                }

                for (int j = 0; j < TableA_.Rows.Count; j++)
                {
                    if (j >= Result.Rows.Count)
                    {
                        DataRow newRow = Result.NewRow();
                        for (i = 0; i < iNbKeyColumns; i++)
                        {
                            newRow[i] = TableA_.Rows[j][i];
                        }
                        for (i = 0; i < tsColumnNamesA_.Length; i++)
                        {
                            int iTemp = TableA_.Columns.IndexOf(tsColumnNamesA_[i]);
                            newRow[tsColumnNamesD_[i]] = TableA_.Rows[j][iTemp];
                        }
                        Result.Rows.Add(newRow);
                    }
                    else
                    {
                        for (i = 0; i < tsColumnNamesD_.Length; i++)
                        {
                            int iColumn = Result.Columns.IndexOf(tsColumnNamesD_[i]);
                            int iColumnA = TableA_.Columns.IndexOf(tsColumnNamesA_[i]);
                            if ((Result.Columns[iColumn].DataType == typeof(Double)) ||
                               (Result.Columns[iColumn].DataType == typeof(double)))
                            {
                                if ((TableA_.Columns[iColumnA].DataType == typeof(Double)) ||
                                    (TableA_.Columns[iColumnA].DataType == typeof(double)))
                                {
                                    Result.Rows[j][iColumn] = ((Double)Result.Rows[j][iColumn]) + ((Double)TableA_.Rows[j][iColumnA]);
                                }
                                else
                                {
                                    Result.Rows[j][iColumn] = ((Double)Result.Rows[j][iColumn]) + ((int)TableA_.Rows[j][iColumnA]);
                                }
                            }
                            else
                            {
                                if ((TableA_.Columns[iColumnA].DataType == typeof(Double)) ||
                                    (TableA_.Columns[iColumnA].DataType == typeof(double)))
                                {
                                    Result.Rows[j][iColumn] = (int)(((int)Result.Rows[j][iColumn]) + ((Double)TableA_.Rows[j][iColumnA]));
                                }
                                else
                                {
                                    Result.Rows[j][iColumn] = (int)(((int)Result.Rows[j][iColumn]) + ((int)TableA_.Rows[j][iColumnA]));
                                }
                            }
                        }
                    }
                }
                Result.AcceptChanges();
                return Result;
            }
            //<<Statistic tables  
            public static Double SumColumn(DataTable dtTable, String sColumn)
            {
                return SumColumn(dtTable, sColumn, -1, -1);
            }
            //>>Statistic tables
            /// <summary>
            /// Function which return the sum of the named column.
            /// </summary>
            /// <param name="dtTable">The table to analyze</param>
            /// <param name="sColumn">The column to sum.</param>
            /// <returns>The sum of the content of the column. 0 if the table is empty of if the type of the column is wrong.</returns>
            public static Double SumColumn(DataTable dtTable, String sColumn, int startRow, int endRow)
            {
                if ((!dtTable.Columns.Contains(sColumn)) ||
                   ((dtTable.Columns[sColumn].DataType != typeof(int)) &&
                   (dtTable.Columns[sColumn].DataType != typeof(Int32)) &&
                   (dtTable.Columns[sColumn].DataType != typeof(Int64)) &&
                   (dtTable.Columns[sColumn].DataType != typeof(Int16)) &&
                   (dtTable.Columns[sColumn].DataType != typeof(Double)) &&
                   (dtTable.Columns[sColumn].DataType != typeof(double))))
                    return 0;
                bool bDouble = ((dtTable.Columns[sColumn].DataType == typeof(Double)) ||
                              (dtTable.Columns[sColumn].DataType == typeof(double)));
                Double dResult = 0;
                if (startRow == -1 && endRow == -1)     //<<Statistic tables
                {
                    for (int i = 0; i < dtTable.Rows.Count; i++)
                    {
                        String currentValue = "0";
                        // >> Task #10764 Pax2Sim - new User attributes for Groups                        
                        if (dtTable.Rows[i][sColumn] == null
                            || dtTable.Rows[i][sColumn].ToString() == "")
                        {
                            //OverallTools.ExternFunctions.PrintLogFile("Error while analysing passengers results. "
                            //                + "The table " + dtTable.TableName + " has invalid data on column " + sColumn + " row " + i + "." );  // >> Pax trace analysis - Sum and BagPlan_2.txt
                            continue;
                        }

                        currentValue = dtTable.Rows[i][sColumn].ToString();
                        if (bDouble)
                        {
                            double v = -1;
                            if (!Double.TryParse(currentValue, out v))
                            {
                                //OverallTools.ExternFunctions.PrintLogFile("Error while analysing passengers results. "
                                //            + "The table " + dtTable.TableName + " has invalid data on column " + sColumn + " row " + i + ".");   // >> Pax trace analysis - Sum and BagPlan_2.txt
                                continue;
                            }
                            else
                            {
                                dResult += (Double)dtTable.Rows[i][sColumn];
                            }
                        }
                        else
                        {
                            int integer = -1;
                            if (!Int32.TryParse(currentValue, out integer))
                            {
                                //OverallTools.ExternFunctions.PrintLogFile("Error while analysing passengers results. "
                                //           + "The table " + dtTable.TableName + " has invalid data on column " + sColumn + " row " + i + ".");   // >> Pax trace analysis - Sum and BagPlan_2.txt
                                continue;
                            }
                            else
                            {
                                dResult += (Int32)dtTable.Rows[i][sColumn];
                            }
                        }
                        // << Task #10764 Pax2Sim - new User attributes for Groups
                    }
                }
                else
                {
                    for (int i = startRow; i <= endRow; i++)
                    {
                        // >> Task #10764 Pax2Sim - new User attributes for Groups                        
                        if (dtTable.Rows[i][sColumn] == null
                            || dtTable.Rows[i][sColumn].ToString() == "")
                        {
                            //OverallTools.ExternFunctions.PrintLogFile("Error while analysing passengers results. "
                            //               + "The table " + dtTable.TableName + " has invalid data on column " + sColumn + " row " + i + ".");   // >> Pax trace analysis - Sum and BagPlan_2.txt
                            continue;
                        }
                        String currentValue = dtTable.Rows[i][sColumn].ToString();
                        if (bDouble)
                        {
                            double v = -1;
                            if (!Double.TryParse(currentValue, out v))
                            {
                                //OverallTools.ExternFunctions.PrintLogFile("Error while analysing passengers results. "
                                //            + "The table " + dtTable.TableName + " has invalid data on column " + sColumn + " row " + i + ".");   // >> Pax trace analysis - Sum and BagPlan_2.txt
                                continue;
                            }
                            else
                            {
                                dResult += (Double)dtTable.Rows[i][sColumn];
                            }
                        }
                        else
                        {
                            int integer = -1;
                            if (!Int32.TryParse(currentValue, out integer))
                            {
                                //OverallTools.ExternFunctions.PrintLogFile("Error while analysing passengers results. "
                                //            + "The table " + dtTable.TableName + " has invalid data on column " + sColumn + " row " + i + ".");   // >> Pax trace analysis - Sum and BagPlan_2.txt
                                continue;
                            }
                            else
                            {
                                dResult += (Int32)dtTable.Rows[i][sColumn];
                            }
                        }
                        // << Task #10764 Pax2Sim - new User attributes for Groups
                    }
                }                                        //>>Statistic tables
                return dResult;
            }
            #endregion

            #region Fonction pour analyser le nom d'un groupe et renvoyer sa valeur sous forme d'entiers
            /// <summary>
            /// Function that will return 4 integer that will represent the actual group or desk given as parameter
            /// First position : Terminal (should never be 0)
            /// Second position : Level (Could be 0, then it represents a Level (T2L5)
            /// Third position : The groupe information (integer from 1 to \ref GestionDonneesHUB2SIM.LastGroupIndex * 2 that will represent a group or desk of given objet (\ref GestionDonneesHUB2SIM.CheckInGroup))
            /// Fourth position : The index of the given desk / group.
            /// </summary>
            /// <param name="name">The name we want to convert (T1L2_Check In 1/ T2L5 / T3L4_Arrival Gate Group 5 / T5)</param>
            /// <returns>null or a table with 4 values.</returns>
            public static int[] AnalyzeGroupName(String name)
            {
                if (name.Length < 2)
                    return null;
                int iCurseur = 1;
                if (name[0] != 'T')
                    return null;
                int[] resultat = new int[4];
                String tmp = OverallTools.FonctionUtiles.nextInt(name, ref iCurseur);
                if (tmp == "")
                    return null;
                resultat[0] = FonctionsType.getInt(tmp, tmp.GetType());
                if (iCurseur == name.Length)
                {
                    resultat[1] = 0;
                    resultat[2] = 0;
                    resultat[3] = 0;
                    return resultat;
                }
                iCurseur++;
                tmp = OverallTools.FonctionUtiles.nextInt(name, ref iCurseur);
                if (tmp == "")
                    return null;
                resultat[1] = FonctionsType.getInt(tmp, tmp.GetType());
                if (name.Length == iCurseur)
                {
                    resultat[2] = 0;
                    resultat[3] = 0;
                    return resultat;
                }
                int iIndexFin, iIndexTmp;
                iIndexFin = name.Length - 1;
                iIndexTmp = iIndexFin;
                while ((tmp = OverallTools.FonctionUtiles.nextInt(name, ref iIndexFin)) != "")
                {
                    iIndexTmp--;
                    iIndexFin = iIndexTmp;
                    resultat[3] = FonctionsType.getInt(tmp, tmp.GetType());
                }
                iCurseur++;
                String nom = name.Substring(iCurseur, iIndexFin - iCurseur + 1);
                nom = nom.TrimEnd(' ');
                resultat[2] = AnalyzeName(nom);
                return resultat;
            }
            /// <summary>
            /// Function that will return 3 integer that will represent the actual group given as parameter
            /// First position : Terminal (should never be 0)
            /// Second position : The groupe information (integer from 1 to xx that will represent a group of given objet (\ref GestionDonneesHUB2SIM.BHS_CONST_BaggageClaimGroup))
            /// Third position : The index of the given desk / group.
            /// </summary>
            /// <param name="name">The name we want to convert (T1_Check In Group 1/  T3_Arrival Gate Group 5 / T5)</param>
            /// <returns>null or a table with 3 values.</returns>
            public static int[] AnalyzeGroupNameBHS(String name)
            {
                if (name.Length < 2)
                    return null;
                int iCurseur = 1;
                if (name[0] != 'T')
                    return null;
                int[] resultat = new int[3];
                String tmp = OverallTools.FonctionUtiles.nextInt(name, ref iCurseur);
                if (tmp == "")
                    return null;
                resultat[0] = FonctionsType.getInt(tmp, tmp.GetType());
                if (name[iCurseur] == 'L')
                {
                    iCurseur++;
                    tmp = OverallTools.FonctionUtiles.nextDoubleDate(name, ref iCurseur);
                }
                if (iCurseur == name.Length)
                {
                    resultat[1] = 0;
                    resultat[2] = 0;
                    return resultat;
                }
                int iIndexFin, iIndexTmp;
                iIndexFin = name.Length - 1;
                iIndexTmp = iIndexFin;
                while ((tmp = OverallTools.FonctionUtiles.nextDoubleDate(name, ref iIndexFin)) != "")
                {
                    iIndexTmp--;
                    iIndexFin = iIndexTmp;
                    resultat[2] = FonctionsType.getInt(tmp, tmp.GetType());
                }
                iCurseur++;
                String nom = name.Substring(iCurseur, iIndexFin - iCurseur + 1);
                nom = nom.TrimEnd(' ');
                resultat[1] = AnalyzeNameBHS(nom);
                return resultat;
            }

            /// <summary>
            /// Function that will return an integer that represents the given group / desk name.
            /// The groupe information (integer from 1 to \ref GestionDonneesHUB2SIM.LastGroupIndex * 2 that will represent a group or desk of given objet (\ref GestionDonneesHUB2SIM.CheckInGroup))
            /// </summary>
            /// <param name="name"></param>
            /// <returns>-1 if the group is not known.</returns>
            public static int AnalyzeName(String name)
            {
                switch (name)
                {
                    case PAX2SIM.sCheckInGroup:
                        return GestionDonneesHUB2SIM.CheckInGroup;
                    case "Passport Check Group":
                        return GestionDonneesHUB2SIM.PassportCheckGroup;
                    case "Security Check Group":
                        return GestionDonneesHUB2SIM.SecurityCheckGroup;
                    case "Arrival Gate Group":
                        return GestionDonneesHUB2SIM.ArrivalGateGroup;
                    case "Baggage Claim Group":
                        return GestionDonneesHUB2SIM.BaggageClaimGroup;
                    case "Transfer Group":
                        return GestionDonneesHUB2SIM.TransferGroup;
                    case PAX2SIM.sUserProcessGroup:/*"ShuttleS Group":*/      // << Task #7570 new Desk and extra information for Pax -Phase I B
                        return GestionDonneesHUB2SIM.ShuttleGroup;
                    case "Boarding Gate Group":
                        return GestionDonneesHUB2SIM.BoardingGateGroup;
                    /*The desks.*/
                    case "Check In":
                        return GestionDonneesHUB2SIM.CheckIn;
                    case "Passport Check":
                        return GestionDonneesHUB2SIM.PassportCheck;
                    case "Security Check":
                        return GestionDonneesHUB2SIM.SecurityCheck;
                    case "Arrival Gate":
                        return GestionDonneesHUB2SIM.ArrivalGate;
                    case "Baggage Claim":
                        return GestionDonneesHUB2SIM.BaggageClaim;
                    case "Transfer":
                        return GestionDonneesHUB2SIM.Transfer;
                    case PAX2SIM.sUserProcessObject:/*"ShuttleS":*/    // << Task #7570 new Desk and extra information for Pax -Phase I B
                        return GestionDonneesHUB2SIM.Shuttle;
                    case "Boarding Gate":
                        return GestionDonneesHUB2SIM.BoardingGate;

                    case PAX2SIM.sModelIn:
                        return GestionDonneesHUB2SIM.ModelIn;
                    case PAX2SIM.sModelOut:
                        return GestionDonneesHUB2SIM.ModelOut;
                    case PAX2SIM.sModelInGroup:
                        return GestionDonneesHUB2SIM.ModelInGroup;
                    case PAX2SIM.sModelOutGroup:
                        return GestionDonneesHUB2SIM.ModelOutGroup;

                    case PAX2SIM.sShoppingAreaGroup:
                        return GestionDonneesHUB2SIM.ShoppingAreaGroup;
                    case PAX2SIM.sShoppingArea:
                        return GestionDonneesHUB2SIM.ShoppingArea;
                    default:
                        return -1;
                }
            }

            /// <summary>
            /// Function that will give the desk integer representation for a given group integer representation.
            /// </summary>
            /// <param name="iNum"></param>
            /// <returns></returns>
            public static int GetGroupId(int iNum)
            {

                switch (iNum)
                {
                    case GestionDonneesHUB2SIM.CheckInGroup:
                        return GestionDonneesHUB2SIM.CheckIn;
                    case GestionDonneesHUB2SIM.PassportCheckGroup:
                        return GestionDonneesHUB2SIM.PassportCheck;
                    case GestionDonneesHUB2SIM.SecurityCheckGroup:
                        return GestionDonneesHUB2SIM.SecurityCheck;
                    case GestionDonneesHUB2SIM.ArrivalGateGroup:
                        return GestionDonneesHUB2SIM.ArrivalGate;
                    case GestionDonneesHUB2SIM.BaggageClaimGroup:
                        return GestionDonneesHUB2SIM.BaggageClaim;
                    case GestionDonneesHUB2SIM.TransferGroup:
                        return GestionDonneesHUB2SIM.Transfer;
                    case GestionDonneesHUB2SIM.ShuttleGroup:
                        return GestionDonneesHUB2SIM.Shuttle;
                    case GestionDonneesHUB2SIM.BoardingGateGroup:
                        return GestionDonneesHUB2SIM.BoardingGate;
                    case GestionDonneesHUB2SIM.ModelInGroup:
                        return GestionDonneesHUB2SIM.ModelIn;
                    case GestionDonneesHUB2SIM.ModelOutGroup:
                        return GestionDonneesHUB2SIM.ModelOut;
                    case GestionDonneesHUB2SIM.ShoppingAreaGroup:
                        return GestionDonneesHUB2SIM.ShoppingArea;
                    default:
                        break;
                }
                return 0;
            }

            /// <summary>
            /// Function that will return the real name for the objet represented by the given parameter. (integer from 1 to \ref GestionDonneesHUB2SIM.LastGroupIndex * 2)
            /// </summary>
            /// <param name="iNum"></param>
            /// <returns></returns>
            public static String AnalyzeName(int iNum)
            {
                switch (iNum)
                {
                    case GestionDonneesHUB2SIM.CheckInGroup:
                        return PAX2SIM.sCheckInGroup;
                    case GestionDonneesHUB2SIM.PassportCheckGroup:
                        return "Passport Check Group";
                    case GestionDonneesHUB2SIM.SecurityCheckGroup:
                        return "Security Check Group";
                    case GestionDonneesHUB2SIM.ArrivalGateGroup:
                        return "Arrival Gate Group";
                    case GestionDonneesHUB2SIM.BaggageClaimGroup:
                        return "Baggage Claim Group";
                    case GestionDonneesHUB2SIM.TransferGroup:
                        return "Transfer Group";
                    case GestionDonneesHUB2SIM.ShuttleGroup:
                        return PAX2SIM.sUserProcessGroup;/*"ShuttleS Group";*/        // << Task #7570 new Desk and extra information for Pax -Phase I B
                    case GestionDonneesHUB2SIM.BoardingGateGroup:
                        return "Boarding Gate Group";
                    case GestionDonneesHUB2SIM.ModelOutGroup:
                        return PAX2SIM.sModelOutGroup;
                    case GestionDonneesHUB2SIM.ModelInGroup:
                        return PAX2SIM.sModelInGroup;
                    //The desks.

                    case GestionDonneesHUB2SIM.CheckIn:
                        return "Check In";
                    case GestionDonneesHUB2SIM.PassportCheck:
                        return "Passport Check";
                    case GestionDonneesHUB2SIM.SecurityCheck:
                        return "Security Check";
                    case GestionDonneesHUB2SIM.ArrivalGate:
                        /*SGE - 05/01/2012 ajout "Arrival " pour que le nom reprenne le bon format.*/
                        return "Arrival Gate";
                    case GestionDonneesHUB2SIM.BaggageClaim:
                        return "Baggage Claim";
                    case GestionDonneesHUB2SIM.Transfer:
                        return "Transfer";
                    case GestionDonneesHUB2SIM.Shuttle:
                        return PAX2SIM.sUserProcessObject;/*"ShuttleS";*/          // << Task #7570 new Desk and extra information for Pax -Phase I B
                    case GestionDonneesHUB2SIM.BoardingGate:
                        return "Boarding Gate";
                    case GestionDonneesHUB2SIM.ModelIn:
                        return PAX2SIM.sModelIn;
                    case GestionDonneesHUB2SIM.ModelOut:
                        return PAX2SIM.sModelOut;
                    case GestionDonneesHUB2SIM.ShoppingAreaGroup:
                        return PAX2SIM.sShoppingAreaGroup;
                    case GestionDonneesHUB2SIM.ShoppingArea:
                        return PAX2SIM.sShoppingArea;
                    default:
                        return null;
                }
            }

            /// <summary>
            /// Function that will return an integer that represents the given group / desk name.
            /// The groupe information (integer from 1 to \ref GestionDonneesHUB2SIM.BHS_CONST_ArrHBSGroup that will represent a group or desk of given objet (\ref GestionDonneesHUB2SIM.BHS_CONST_ArrHBSGroup))
            /// </summary>
            /// <param name="name"></param>
            /// <returns>-1 if the group is not known.</returns>
            public static int AnalyzeNameBHS(String name)
            {
                switch (name)
                {
                    case GestionDonneesHUB2SIM.BHS_String_ArrivalInfeedGroup:
                        return GestionDonneesHUB2SIM.BHS_CONST_ArrivalInfeedGroup;
                    case GestionDonneesHUB2SIM.BHS_String_TransferInfeedGroup:
                        return GestionDonneesHUB2SIM.BHS_CONST_TransferInfeedGroup;

                    case "Arrival HBS Group":
                        return GestionDonneesHUB2SIM.BHS_CONST_ArrHBSGroup;
                    case "Baggage Claim Group":
                        return GestionDonneesHUB2SIM.BHS_CONST_BaggageClaimGroup;
                    case "Custom Group":
                        return GestionDonneesHUB2SIM.BHS_CONST_CustomGroup;
                    case PAX2SIM.sCheckInGroup:
                        return GestionDonneesHUB2SIM.BHS_CONST_CheckInGroup;
                    case "HBS Lev1 Group":
                        return GestionDonneesHUB2SIM.BHS_CONST_HBS1Group;
                    case "HBS Lev2 Group":
                        return GestionDonneesHUB2SIM.BHS_CONST_HBS2Group;
                    case "HBS Lev3 Group":
                        return GestionDonneesHUB2SIM.BHS_CONST_HBS3Group;
                    case "HBS Lev4 Group":
                        return GestionDonneesHUB2SIM.BHS_CONST_HBS4Group;
                    case "HBS Lev5 Group":
                        return GestionDonneesHUB2SIM.BHS_CONST_HBS5Group;
                    case "MES Group":
                        return GestionDonneesHUB2SIM.BHS_CONST_MESGroup;
                    case "EBS Group":
                        return GestionDonneesHUB2SIM.BHS_CONST_EBSGroup;
                    case "Make-Up Group":
                        return GestionDonneesHUB2SIM.BHS_CONST_MakeUpGroup;
                    case "Check In Collector Group":
                        return GestionDonneesHUB2SIM.BHS_CONST_CheckInCollectorGroup;
                    // << Task #7570 new Desk and extra information for Pax -Phase I B
                    case PAX2SIM.sUserProcessGroup:
                        return GestionDonneesHUB2SIM.BHS_CONST_UserProcessGroup;
                    case PAX2SIM.sUserProcessObject:
                        return GestionDonneesHUB2SIM.BHS_CONST_UserProcessObject;
                    // >> Task #7570 new Desk and extra information for Pax -Phase I B
                    default:
                        return -1;
                }
            }

            /// <summary>
            /// Function that will return the real name for the objet represented by the given parameter. (integer from 1 to \ref GestionDonneesHUB2SIM.BHS_CONST_ArrHBSGroup)
            /// </summary>
            /// <param name="iNum"></param>
            /// <returns></returns>
            public static String AnalyzeNameBHS(int iNum)
            {
                switch (iNum)
                {
                    case GestionDonneesHUB2SIM.BHS_CONST_ArrivalInfeedGroup:
                        return GestionDonneesHUB2SIM.BHS_String_ArrivalInfeedGroup;
                    case GestionDonneesHUB2SIM.BHS_CONST_TransferInfeedGroup:
                        return GestionDonneesHUB2SIM.BHS_String_TransferInfeedGroup;

                    case GestionDonneesHUB2SIM.BHS_CONST_ArrHBSGroup:
                        return "Arrival HBS Group";
                    case GestionDonneesHUB2SIM.BHS_CONST_BaggageClaimGroup:
                        return "Baggage Claim Group";
                    case GestionDonneesHUB2SIM.BHS_CONST_CustomGroup:
                        return "Custom Group";
                    case GestionDonneesHUB2SIM.BHS_CONST_CheckInGroup:
                        return PAX2SIM.sCheckInGroup;
                    case GestionDonneesHUB2SIM.BHS_CONST_HBS1Group:
                        return "HBS Lev1 Group";
                    case GestionDonneesHUB2SIM.BHS_CONST_HBS2Group:
                        return "HBS Lev2 Group";
                    case GestionDonneesHUB2SIM.BHS_CONST_HBS3Group:
                        return "HBS Lev3 Group";
                    case GestionDonneesHUB2SIM.BHS_CONST_HBS4Group:
                        return "HBS Lev4 Group";
                    case GestionDonneesHUB2SIM.BHS_CONST_HBS5Group:
                        return "HBS Lev5 Group";

                    case GestionDonneesHUB2SIM.BHS_CONST_MESGroup:
                        return "MES Group";
                    case GestionDonneesHUB2SIM.BHS_CONST_EBSGroup:
                        return "EBS Group";
                    case GestionDonneesHUB2SIM.BHS_CONST_MakeUpGroup:
                        return "Make-Up Group";
                    case GestionDonneesHUB2SIM.BHS_CONST_CheckInCollectorGroup:
                        return "Check In Collector Group";
                    // << Task #7570 new Desk and extra information for Pax -Phase I B
                    case GestionDonneesHUB2SIM.BHS_CONST_UserProcessGroup:
                        return PAX2SIM.sUserProcessGroup;
                    case GestionDonneesHUB2SIM.BHS_CONST_UserProcessObject:
                        return PAX2SIM.sUserProcessObject;
                    // >> Task #7570 new Desk and extra information for Pax -Phase I B
                    default:
                        return null;
                }
            }
            #endregion

            #region Fonction pour ranger les tables
            /// <summary>
            /// Function to sort the table.
            /// </summary>
            /// <param name="OriginTable">The table to short</param>
            /// <param name="Column">The column to analyse (with information about how to sort (DESC or nothing))</param>
            /// <returns></returns>
            public static DataTable sortTable(DataTable OriginTable, String Column)
            {
                String tmp = Column;
                if (Column.Contains(" DESC"))
                {
                    tmp = Column.Replace(" DESC", "");
                }

                if ((OriginTable.Columns.IndexOf(Column) == -1) && (OriginTable.Columns.IndexOf(tmp) == -1))
                {
                    return null;
                }
                DataView dgSort = new DataView(OriginTable, "", Column, DataViewRowState.CurrentRows);

                return dgSort.ToTable();
            }
            #endregion

            #region Fonction pour déterminer les valeurs extrèmes pour une étude à partir de la table des plans de vol et de la table OCT

            /// <summary>
            /// Fonction pour déterminer les intervals minimum et maximum des tables d'allocations.
            /// </summary>
            /// <param name="flightPlans">La table contenant les plans de vols à analyser</param>
            /// <param name="OCT">La table contenant les lois d'ouvertures des postes.</param>
            /// <param name="bArrivalFlight">Booléen indiquant s'il s'agit de plans de vol arrivé ou départ (ajout ou soustraction des lois d'ouverture)</param>
            /// <param name="DateColumn">Nom de la colonne représentant la date.</param>
            /// <param name="TimeColumn">Nom de la colonne représentant l'heure.</param>
            /// <param name="FCColumn">Nom de la colonne représentant la catégorie de vol.</param>
            /// <param name="dateDepart">Paramètre de sortie pour l'heure de début des allocations.</param>
            /// <param name="dateFin">Paramètre de sortie pour l'heure de fin des allocations.</param>
            public static bool SearchDates(DataTable flightPlans,
                                    DataTable OCT,
                                    bool bArrivalFlight,
                                    String DateColumn,
                                    String TimeColumn,
                                    String FCColumn,
                                    out DateTime dateDepart,
                                    out DateTime dateFin,
                                    ArrayList ListErrors)
            {
                dateDepart = DateTime.MaxValue;
                dateFin = DateTime.MinValue;
                if ((!flightPlans.Columns.Contains(DateColumn)) ||
                    (!flightPlans.Columns.Contains(TimeColumn)) ||
                    (!flightPlans.Columns.Contains(FCColumn)))
                {
                    ListErrors.Add("Err00500 : The flight plan table does not have a valid format for this operation.A column is missing for the date or the flight category.");
                    return false;
                }
                DateTime tmp;
                String FC;
                foreach (DataRow ligne in flightPlans.Rows)
                {
                    tmp = OverallTools.DataFunctions.toDateTime(ligne[DateColumn], ligne[TimeColumn]);
                    FC = ligne[FCColumn].ToString();
                    if (!OCT.Columns.Contains(FC))
                    {
                        ListErrors.Add("Err00501 : The flight categorie \"" + FC + "\" does not appear in the opening closing times table \"" + OCT.TableName + "\".");
                        return false;
                    }
                    int oct_val1, oct_val2;
                    if ((!Int32.TryParse(OCT.Rows[0][FC].ToString(), out oct_val1)) || (!Int32.TryParse(OCT.Rows[1][FC].ToString(), out oct_val2)))
                    {
                        ListErrors.Add("Err00502 : The values in the opening closing times table \"" + OCT.TableName + "\" does not have a good format for the column \"" + FC + "\".");
                        return false;
                    }
                    DateTime tmpDepart, tmpFin;
                    if (bArrivalFlight)
                    {
                        tmpDepart = tmp.AddMinutes(oct_val1);
                        tmpFin = tmp.AddMinutes(oct_val2);
                    }
                    else
                    {
                        tmpDepart = tmp.AddMinutes(-oct_val1);
                        tmpFin = tmp.AddMinutes(-oct_val2);
                    }
                    if (tmpDepart > tmpFin)
                    {
                        tmp = tmpFin;
                        tmpFin = tmpDepart;
                        tmpDepart = tmp;
                    }
                    if (tmpDepart < dateDepart)
                        dateDepart = tmpDepart;
                    if (tmpFin > dateFin)
                        dateFin = tmpFin;
                }
                if (dateDepart.Minute > 0)
                    dateDepart = dateDepart.AddMinutes(-dateDepart.Minute);
                if (dateFin.Minute > 0)
                    dateFin = dateFin.AddMinutes(60 - dateFin.Minute);
                return true;
            }

            /// <summary>
            /// Fonction pour déterminer les intervals minimum et maximum des tables d'allocations.
            /// </summary>
            /// <param name="flightPlans">La table contenant les plans de vols à analyser</param>
            /// <param name="OCT">La table contenant les lois d'ouvertures des postes.</param>
            /// <param name="bArrivalFlight">Booléen indiquant s'il s'agit de plans de vol arrivé ou départ (ajout ou soustraction des lois d'ouverture)</param>
            /// <param name="DateColumn">Nom de la colonne représentant la date.</param>
            /// <param name="TimeColumn">Nom de la colonne représentant l'heure.</param>
            /// <param name="FCColumn">Nom de la colonne représentant la catégorie de vol.</param>
            /// <param name="dateDepart">Paramètre de sortie pour l'heure de début des allocations.</param>
            /// <param name="dateFin">Paramètre de sortie pour l'heure de fin des allocations.</param>
            internal static bool SearchDates(DataTable flightPlans,
                                    DataManagement.ExceptionTable OCT,
                                    bool bArrivalFlight,
                                    String DateColumn,
                                    String TimeColumn,
                                    String FCColumn,
                                    String IDColumn,
                                    String AirlineColumn,
                                    String sLineOpening,
                                    String sLineClosing,
                                    out DateTime dateDepart,
                                    out DateTime dateFin,
                                    ArrayList ListErrors)
            {
                dateDepart = DateTime.MaxValue;
                dateFin = DateTime.MinValue;
                String sPrefixe = "A_";
                if (!bArrivalFlight)
                    sPrefixe = "D_";
                if ((!flightPlans.Columns.Contains(DateColumn)) ||
                    (!flightPlans.Columns.Contains(TimeColumn)) ||
                    (!flightPlans.Columns.Contains(FCColumn)) ||
                    (!flightPlans.Columns.Contains(IDColumn)) ||
                    (!flightPlans.Columns.Contains(AirlineColumn)))
                {
                    ListErrors.Add("Err00500 : The flight plan table does not have a valid format for this operation.A column is missing for the date or the flight category.");
                    return false;
                }
                DateTime tmp;
                String FC, ID, Airline;
                foreach (DataRow ligne in flightPlans.Rows)
                {
                    tmp = OverallTools.DataFunctions.toDateTime(ligne[DateColumn], ligne[TimeColumn]);
                    FC = ligne[FCColumn].ToString();
                    ID = ligne[IDColumn].ToString();
                    Airline = ligne[AirlineColumn].ToString();

                    for (int i = 0; i <= 1; i++)
                    {

                        Dictionary<String, String> dssOCT_CI = OCT.GetInformationsColumns(i, sPrefixe + ID, Airline, FC);
                        if ((dssOCT_CI == null) || (!dssOCT_CI.ContainsKey(sLineOpening)) || (!dssOCT_CI.ContainsKey(sLineClosing)))
                            return false;

                        /*if (!OCT.Columns.Contains(FC))
                        {
                            ListErrors.Add("Err00501 : The flight categorie \"" + FC + "\" does not appear in the opening closing times table \"" + OCT.TableName + "\".");
                            return false;
                        }*/
                        int oct_val1, oct_val2;
                        if ((!Int32.TryParse(dssOCT_CI[sLineOpening], out oct_val1)) || (!Int32.TryParse(dssOCT_CI[sLineClosing], out oct_val2)))
                        {
                            ListErrors.Add("Err00502 : The values in the opening closing times table \"" + OCT.Name + "\" does not have a good format for the column \"" + FC + "\".");
                            return false;
                        }
                        DateTime tmpDepart, tmpFin;
                        if (bArrivalFlight)
                        {
                            tmpDepart = tmp.AddMinutes(oct_val1);
                            tmpFin = tmp.AddMinutes(oct_val2);
                        }
                        else
                        {
                            tmpDepart = tmp.AddMinutes(-oct_val1);
                            tmpFin = tmp.AddMinutes(-oct_val2);
                        }
                        if (tmpDepart > tmpFin)
                        {
                            tmp = tmpFin;
                            tmpFin = tmpDepart;
                            tmpDepart = tmp;
                        }
                        if (tmpDepart < dateDepart)
                            dateDepart = tmpDepart;
                        if (tmpFin > dateFin)
                            dateFin = tmpFin;
                    }
                }
                if (dateDepart.Minute > 0)
                    dateDepart = dateDepart.AddMinutes(-dateDepart.Minute);
                if (dateFin.Minute > 0)
                    dateFin = dateFin.AddMinutes(60 - dateFin.Minute);
                return true;
            }
            #endregion

            #region Fonction pour analyser le contenu de la table et renvoyer une liste avec que des valeurs différentes pour le champ.
            public static String[] obtenirListeDifferents(DataTable table, int indexColonne)
            {
                if ((indexColonne < 0) || (indexColonne > table.Columns.Count))
                {
                    return null;
                }
                ArrayList listeTrouve = new ArrayList();
                int i;
                bool trouve = false;
                foreach (DataRow ligne in table.Rows)
                {
                    trouve = false;
                    if (ligne.ItemArray[indexColonne] == null)
                        continue;
                    for (i = 0; i < listeTrouve.Count; i++)
                    {

                        if (ligne.ItemArray[indexColonne].ToString() == listeTrouve[i].ToString())
                        {
                            trouve = true;
                            continue;
                        }
                    }
                    if (trouve)
                        continue;
                    listeTrouve.Add(ligne.ItemArray[indexColonne]);
                }
                if (listeTrouve.Count == 0)
                {
                    return null;
                }
                String[] resultats = new String[listeTrouve.Count];
                for (i = 0; i < listeTrouve.Count; i++)
                {
                    resultats[i] = listeTrouve[i].ToString();
                }
                return resultats;
            }

            public static String[] obtenirListeDifferents_2(DataTable table, int indexColonne, int indexColumn2, out Dictionary<string, string> dictionary) // >> Task #16654 Reclaim - import and allocation for Narita
            {
                dictionary = new Dictionary<string, string>();
                if ((indexColonne < 0) || (indexColonne > table.Columns.Count))
                {
                    return null;
                }
                ArrayList listeTrouve = new ArrayList();
                int i;
                bool trouve = false;
                foreach (DataRow ligne in table.Rows)
                {
                    trouve = false;
                    if (ligne.ItemArray[indexColonne] == null)
                        continue;
                    for (i = 0; i < listeTrouve.Count; i++)
                    {

                        if (ligne.ItemArray[indexColonne].ToString() == listeTrouve[i].ToString())
                        {
                            trouve = true;
                            continue;
                        }
                    }
                    if (trouve)
                        continue;
                    listeTrouve.Add(ligne.ItemArray[indexColonne]);
                    dictionary.Add(ligne.ItemArray[indexColonne].ToString(), ligne.ItemArray[indexColumn2].ToString());
                }
                if (listeTrouve.Count == 0)
                {
                    return null;
                }
                String[] resultats = new String[listeTrouve.Count];
                for (i = 0; i < listeTrouve.Count; i++)
                {
                    resultats[i] = listeTrouve[i].ToString();
                }
                return resultats;
            }
            #endregion

            #region Fonctions pour effectuer des différences entre deux dates.
            public static long HourDifference(DateTime firstDate, DateTime secondDate)
            {
                return (secondDate.Ticks - firstDate.Ticks) / 36000000000;
            }

            /// <summary>
            /// Function which returns the difference in minutes. Makes  secondDate - firstDate
            /// </summary>
            /// <param name="firstDate"></param>
            /// <param name="secondDate"></param>
            /// <returns></returns>
            public static Double MinuteDifference(DateTime firstDate, DateTime secondDate)
            {
                return (secondDate.Ticks - firstDate.Ticks) / 600000000.0;
            }

            public static TimeSpan EraseSeconds(TimeSpan tsTemporaryTime)
            {
                TimeSpan Seconds = new TimeSpan(0, 0, 0, tsTemporaryTime.Seconds, tsTemporaryTime.Milliseconds);
                return tsTemporaryTime.Add(-Seconds);
            }
            public static DateTime EraseSeconds(DateTime dtTemporaryTime)
            {
                TimeSpan Seconds = new TimeSpan(0, 0, 0, dtTemporaryTime.Second, dtTemporaryTime.Millisecond);
                return dtTemporaryTime.Add(-Seconds);
            }
            public static long SecondDifference(DateTime firstDate, DateTime secondDate)
            {
                return (secondDate.Ticks - firstDate.Ticks) / 10000000;
            }
            #endregion

            #region Fonction permettant des interrogations de tables sur des heures.
            /// <summary>
            /// Fonction qui renvoie l'index de l'heure s'approchant le plus de l'heure donnée en paramêtre.
            /// </summary>
            /// <param name="laTable">Table contenant les valeurs possibles pour l'heure désirée.</param>
            /// <param name="heureRecherchee">Heure recherchée dans la table.</param>
            /// <returns>Renvoi l'index de l'heure apporchant, et -1 si erreur.</returns>
            public static int heureDebut(DataTable laTable, DateTime heureRecherchee)
            {
                return heureDebut(laTable, heureRecherchee, 0);
            }
            /// <summary>
            /// Fonction qui renvoie l'index de l'heure s'approchant le plus de l'heure donnée en paramêtre.
            /// </summary>
            /// <param name="laTable">Table contenant les valeurs possibles pour l'heure désirée.</param>
            /// <param name="heureRecherchee">Heure recherchée dans la table.</param>
            /// <param name="indexColonne">Colonne dans laquelle rechercher l'heure.</param>
            /// <returns>Renvoi l'index de l'heure apporchant, et -1 si erreur.</returns>
            public static int heureDebut(DataTable laTable, DateTime heureRecherchee, int indexColonne)
            {
                if (laTable.Columns[indexColonne].DataType != typeof(DateTime))
                    return -1;

                for (int i = 0; i < laTable.Rows.Count; i++)
                {
                    if ((FonctionsType.getDate(laTable.Rows[i].ItemArray[indexColonne])) > heureRecherchee)
                        return i - 1;
                }
                if (laTable.Rows.Count < 2)
                    return -1;
                Double dStep = OverallTools.DataFunctions.MinuteDifference(FonctionsType.getDate(laTable.Rows[0][indexColonne]),
                    FonctionsType.getDate(laTable.Rows[1][indexColonne]));
                if (FonctionsType.getDate(laTable.Rows[laTable.Rows.Count - 1].ItemArray[indexColonne]).AddMinutes(dStep) > heureRecherchee)
                    return laTable.Rows.Count - 1;
                return -1;
            }
            /// <summary>
            /// Fonction qui permet de calculé le taux cumulé à l'ouverture des check in. Il ajoute les valeurs 
            /// situées avant l'ouverture du check in
            /// </summary>
            /// <param name="Table">La table sur laquelle effectué le calcul du cumul.</param>
            /// <param name="NomColonne">Le nom de la colonne à cumuler.</param>
            /// <param name="HeureOuverture">L'heure d'ouverture des check in.</param>
            /// <param name="heureDepart">L'heure du départ du vol étudié.</param>
            /// <returns>Renvoie le cumul de la colonne spécifiée avant l'ouverture du check in.</returns>
            public static float TauxCumuleHeureOuverture(DataTable Table, String NomColonne, int HeureOuverture, int heureDepart)
            {
                float TauxCumule = 0.0f;
                int indexColonne = Table.Columns.IndexOf(NomColonne);
                foreach (DataRow ligne in Table.Rows)
                {
                    if ((heureDepart - FonctionsType.getInt(ligne.ItemArray[1])) <= HeureOuverture)
                    {
                        TauxCumule += (float)FonctionsType.getDouble(ligne.ItemArray[indexColonne], ligne.ItemArray[indexColonne].GetType());
                    }
                }
                return TauxCumule;
            }
            /// <summary>
            /// Récupère dans la table spécifiée, le taux de chargement pour le créneau horaire donné.
            /// </summary>
            /// <param name="Table">La table contenant la courbe de présentation des passagers</param>
            /// <param name="NomColonne">Le nom de la colonne contenant les données qui nous intéresse</param>
            /// <param name="Creneau">Le nombre de minutes restant avant le déart du vol analysé.</param>
            /// <returns>Renvoie la valeur pour le créneau et la colonne désignée</returns>
            public static float TauxChargementCreneauHoraire(DataTable Table, string NomColonne, int Creneau, Double dPas)
            {
                foreach (DataRow ligne in Table.Rows)
                {
                    if ((Creneau >= FonctionsType.getInt(ligne.ItemArray[1])) &&
                       ((Creneau - dPas) < FonctionsType.getInt(ligne.ItemArray[1])))
                    {
                        return (float)FonctionsType.getDouble(ligne.ItemArray[Table.Columns.IndexOf(NomColonne)], ligne.ItemArray[Table.Columns.IndexOf(NomColonne)].GetType());
                    }
                }
                return 0.0f;
            }
            #endregion

            #region Fonctions pour recherché dans une table l'index de lignes correspondants aux critères de recherche.
            /// <summary>
            /// Fonction qui renvoie l'index de la ligne où la colonne spécifiée est égale à la valeur donnée.
            /// </summary>
            /// <param name="Table">Table à analyser</param>
            /// <param name="NomColonne">Colonne observée</param>
            /// <param name="Value">Valeur recherchée</param>
            /// <returns>Renvoie l'index de la ligne ou -1 en cas d'échec.</returns>
            public static int indexLigne(DataTable Table, String NomColonne, string Value)
            {
                int indexColonne = Table.Columns.IndexOf(NomColonne);
                return indexLigne(Table, indexColonne, Value);
            }
            /// <summary>
            /// Fonction qui renvoie l'index de la ligne où la colonne spécifiée est égale à la valeur donnée.
            /// </summary>
            /// <param name="Table">Table à analyser</param>
            /// <param name="indexColonne">Colonne observée</param>
            /// <param name="Value">Valeur recherchée</param>
            /// <returns>Renvoie l'index de la ligne ou -1 en cas d'échec.</returns>
            public static int indexLigne(DataTable Table, int indexColonne, string Value)
            {
                if (indexColonne == -1)
                    return -1;
                if (Table == null)
                    return -1;
                int i = 0;
                foreach (DataRow ligne in Table.Rows)
                {
                    String st = ligne.ItemArray[indexColonne].ToString();
                    if (st == Value)
                    {
                        return i;
                    }
                    i++;
                }
                return -1;
            }

            /// <summary>
            /// Fonction qui renvoie les index des lignes où la colonne spécifiée est égale à la valeur donnée.
            /// </summary>
            /// <param name="Table">Table à analyser</param>
            /// <param name="NomColonne">Colonne observée</param>
            /// <param name="Value">Valeur recherchée</param>
            /// <returns>Renvoie l'index de la ligne ou null en cas d'échec.</returns>
            public static int[] indexLignes(DataTable Table, String NomColonne, string Value)
            {
                int indexColonne = Table.Columns.IndexOf(NomColonne);
                return indexLignes(Table, indexColonne, Value);
            }
            /// <summary>
            /// Fonction qui renvoie les index des lignes où la colonne spécifiée est égale à la valeur donnée.
            /// </summary>
            /// <param name="Table">Table à analyser</param>
            /// <param name="indexColonne">Colonne observée</param>
            /// <param name="Value">Valeur recherchée</param>
            /// <returns>Renvoie les index de la ligne ou null en cas d'échec.</returns>
            public static int[] indexLignes(DataTable Table, int indexColonne, string Value)
            {
                if (indexColonne == -1)
                    return null;
                int i = 0;
                ArrayList resultats = new ArrayList();
                foreach (DataRow ligne in Table.Rows)
                {
                    if (ligne.ItemArray[indexColonne].ToString() == Value)
                    {
                        resultats.Add(i);
                    }
                    i++;
                }
                if (resultats.Count == 0) return null;
                int[] iResultats = new int[resultats.Count];
                for (i = 0; i < resultats.Count; i++)
                    iResultats[i] = (int)resultats[i];
                return iResultats;
            }
            #endregion

            #region Fonctions permettant de recherché dans la colonne (ou ligne) d'une table la valeur maximale (ou minimale).
            /// <summary>
            /// Fonction qui renvoi la valeur maximale contenue dans la colonne spécifiée.
            /// Elle traite uniquement les entiers.
            /// </summary>
            /// <param name="Table">La table analysée</param>
            /// <param name="indexColonne">Le nom de la colonne qui contient les données auxqu'elles on s'intéresse.</param>
            /// <returns>La valeur maximale trouvée dans la table.</returns>
            public static int valeurMaximaleDansColonne(DataTable Table, int indexColonne)
            {
                if (Table.Rows.Count == 0)
                    return -1;
                if (indexColonne >= Table.Columns.Count)
                    return -1;
                int valeurMax = FonctionsType.getInt(Table.Rows[0].ItemArray[indexColonne]);
                for (int i = 1; i < Table.Rows.Count; i++)
                {
                    int value = FonctionsType.getInt(Table.Rows[i].ItemArray[indexColonne]);
                    if (value > valeurMax)
                        valeurMax = value;
                }
                return valeurMax;
            }
            /// <summary>
            /// Fonction qui renvoi la valeur maximale contenue dans la colonne spécifiée.
            /// Elle traite uniquement les réels.
            /// </summary>
            /// <param name="Table">La table analysée</param>
            /// <param name="indexColonne">Le nom de la colonne qui contient les données auxqu'elles on s'intéresse.</param>
            /// <returns>La valeur maximale trouvée dans la table.</returns>
            public static Double valeurMaximaleDansColonne2(DataTable Table, int indexColonne)
            {
                if (Table.Rows.Count == 0)
                    return -1;
                if (indexColonne >= Table.Rows.Count)
                    return 0;
                double valeurMax = (Double)Table.Rows[0][indexColonne];
                for (int i = 1; i < Table.Rows.Count; i++)
                {
                    if ((Double)Table.Rows[i][indexColonne] > valeurMax)
                        valeurMax = (Double)Table.Rows[i][indexColonne];
                }
                return valeurMax;
            }
            /// <summary>
            /// Fonction qui renvoi la valeur maximale contenue dans la colonne spécifiée.
            /// Elle traite uniquement les dates.
            /// </summary>
            /// <param name="Table">La table analysée</param>
            /// <param name="indexColonneDate">L'index de la colonne des dates.</param>
            /// <param name="indexColonneHeures">L'index de la colonne des heures.</param>
            /// <returns>La valeur maximale trouvée dans la table.</returns>
            public static DateTime valeurMaximaleDansColonne(DataTable Table, int indexColonneDate, int indexColonneHeures)
            {
                if ((indexColonneDate >= Table.Columns.Count) || (indexColonneHeures >= Table.Columns.Count))
                    return DateTime.MinValue;
                if (Table.Rows.Count == 0)
                    return DateTime.MinValue;
                DateTime resultat, nouvelleValeur;
                resultat = toDateTime(Table.Rows[0].ItemArray[indexColonneDate], Table.Rows[0].ItemArray[indexColonneHeures]);
                foreach (DataRow ligne in Table.Rows)
                {
                    nouvelleValeur = toDateTime(ligne.ItemArray[indexColonneDate], ligne.ItemArray[indexColonneHeures]);

                    if (nouvelleValeur == (DateTime.MinValue))
                    {
                        return DateTime.MinValue;
                    }
                    if (nouvelleValeur > resultat)
                    {
                        resultat = nouvelleValeur;
                    }
                }
                return resultat;
            }
            /// <summary>
            /// Retourne la valeur minimale que l'on peut trouvé dans la colonne spécifiée.
            /// </summary>
            /// <param name="Table">La table à analyser</param>
            /// <param name="indexColonneDate">l'index de la colonne des dates</param>
            /// <param name="indexColonneHeures">L'index de la colonne des heures</param>
            /// <returns>Renvoie la structure DateTime contenant la valeur minimale trouvée.</returns>
            public static DateTime valeurMinimaleDansColonne(DataTable Table, int indexColonneDate, int indexColonneHeures)
            {
                if ((indexColonneDate >= Table.Columns.Count) || (indexColonneHeures >= Table.Columns.Count))
                    return DateTime.Now;
                if (Table.Rows.Count == 0)
                    return DateTime.MinValue;
                DateTime resultat, nouvelleValeur;
                resultat = toDateTime(Table.Rows[0].ItemArray[indexColonneDate], Table.Rows[0].ItemArray[indexColonneHeures]);
                if (resultat == (DateTime.MinValue))
                {
                    return DateTime.Now;
                }
                foreach (DataRow ligne in Table.Rows)
                {
                    nouvelleValeur = toDateTime(ligne.ItemArray[indexColonneDate], ligne.ItemArray[indexColonneHeures]);
                    if (nouvelleValeur == (DateTime.MinValue))
                    {
                        return DateTime.Now;
                    }
                    if (nouvelleValeur < resultat)
                    {
                        resultat = nouvelleValeur;
                    }
                }
                return resultat;
            }
            /// <summary>
            /// Retourne la valeur minimale que l'on peut trouvé dans la colonne spécifiée.
            /// </summary>
            /// <param name="Table">La table à analyser</param>
            /// <param name="indexColonne">l'index de la colonne </param>
            /// <returns>Renvoie la valeur minimale trouvée dans la colonne.</returns>
            public static Double valeurMinimaleDansColonne(DataTable Table, int indexColonne)
            {
                if ((indexColonne >= Table.Columns.Count))
                    return 0;
                Double resultat, nouvelleValeur;
                if (!Double.TryParse(Table.Rows[0].ItemArray[indexColonne].ToString(), out resultat))
                {
                    return 0;
                }
                foreach (DataRow ligne in Table.Rows)
                {
                    if (!Double.TryParse(ligne.ItemArray[indexColonne].ToString(), out nouvelleValeur))
                    {
                        return 0;
                    }
                    if (nouvelleValeur < resultat)
                    {
                        resultat = nouvelleValeur;
                    }
                }
                return resultat;
            }
            /// <summary>
            /// Retourne la valeur maximale que l'on peut trouvé dans la ligne spécifiée.
            /// </summary>
            /// <param name="table">La table à analyser</param>
            /// <param name="indexLigne">La ligne que l'on souhaite analyser</param>
            /// <param name="indexColonneDepart">La première colonne qu'il faut analyser (les autres sont ignorées)</param>
            /// <returns>Renvoie la valeur maximale trouvée</returns>
            public static int valeurMaximaleDansLigne(DataTable table, int indexLigne, int indexColonneDepart)
            {
                if (indexLigne >= table.Rows.Count)
                    return -1;
                if (indexColonneDepart >= table.Columns.Count)
                    return -1;
                int resultat, nouvelle;
                if (!Int32.TryParse(table.Rows[indexLigne].ItemArray[indexColonneDepart].ToString(), out resultat))
                {
                    return -1;
                }
                for (int i = indexColonneDepart; i < table.Columns.Count; i++)
                {
                    if (!Int32.TryParse(table.Rows[indexLigne].ItemArray[i].ToString(), out nouvelle))
                    {
                        return -1;
                    }
                    if (nouvelle > resultat)
                    {
                        resultat = nouvelle;
                    }
                }
                return resultat;
            }
            #endregion

            #region Fonctions permettant la mise à jour des tables suivant les paramètres choisis.
            /// <summary>
            /// Fonction qui initialise la table passée en paramètres avec des dates allant de \ref dtTimeBegin à \ref dtTimeEnd et
            /// avec un pas de \ref dStep minutes. Attention elle supprimer toutes les anciennes lignes présentes dans la table.
            /// La colonne initialisée est la première.
            /// </summary>
            /// <param name="dtTable">La table à initialiser</param>
            /// <param name="dtTimeBegin">La date de début.</param>
            /// <param name="dtTimeEnd">La date de fin</param>
            /// <param name="dStep">Le pas d'initialisation.</param>
            public static void initialiserLignes(DataTable dtTable, DateTime dtTimeBegin, DateTime dtTimeEnd, Double dStep)
            {
                initialiserLignes(dtTable, dtTimeBegin, dtTimeEnd, dStep, 0);
            }

            /// <summary>
            /// Fonction qui initialise la table passée en paramètres avec des dates allant de \ref dtTimeBegin à \ref dtTimeEnd et
            /// avec un pas de dStep minutes. Attention elle supprimer toutes les anciennes lignes présentes dans la table.
            /// La colonne initialisée est iIndexColonne">.
            /// </summary>
            /// <param name="dtTable">La table à initialiser</param>
            /// <param name="dtTimeBegin">La date de début.</param>
            /// <param name="dtTimeEnd">La date de fin</param>
            /// <param name="dStep">Le pas d'initialisation.</param>
            /// <param name="iIndexColonne">La colonne à initialiser.</param>
            public static void initialiserLignes(DataTable dtTable, DateTime dtTimeBegin, DateTime dtTimeEnd, Double dStep, int iIndexColonne)
            {
                DateTime begin = dtTimeBegin;
                if (dtTable.Rows.Count > 0)
                    dtTable.Rows.Clear();
                while (begin < dtTimeEnd)
                {
                    DataRow newLine = dtTable.NewRow();
                    newLine[iIndexColonne] = begin;
                    dtTable.Rows.Add(newLine);
                    begin = begin.AddMinutes(dStep);
                }
            }
            public static void initialiserColumn(DataTable dtTable, DateTime dtTimeBegin, DateTime dtTimeEnd, Double dStep, Type tNewColumnType)
            {
                DateTime begin = dtTimeBegin;
                try
                {
                    while (begin < dtTimeEnd)
                    {
                        dtTable.Columns.Add(begin.ToString(), tNewColumnType);
                        begin = begin.AddMinutes(dStep);
                    }
                }
                catch
                {
                }
            }
            #endregion

            #region Fonction pour le calcul du nombre de passagers sur un vol
            /// <summary>
            /// fonction qui calcule le nombre de passagers qui vont se présenter pour un vol donné.
            /// </summary>
            /// <param name="line">La ligne du vol à analyser</param>
            /// <param name="AircraftType">La table des types d'avions</param>
            /// <param name="FlightCategories">La table des catégories de vol</param>
            /// <param name="LoadFactors">La table des facteurs de chargement</param>
            /// <returns>Renvoie le nombre de passagers que l'on peut espérer pour ce vol.</returns>
            internal static Double numberOfPassengers(DataRow line,
                DataManagement.ExceptionTable AircraftType,
                DataTable FlightCategories,
                DataManagement.ExceptionTable LoadFactors,
                List<String> ListeErreurs)
            {
                ArrayList alList = new ArrayList();
                Double dresult = numberOfPassengers(line, AircraftType, FlightCategories, LoadFactors, alList);
                if (alList.Count != 0)
                {
                    foreach (String sError in alList)
                        ListeErreurs.Add(sError);
                }
                return dresult;
            }

            /// <summary>
            /// fonction qui calcule le nombre de passagers qui vont se présenter pour un vol donné.
            /// </summary>
            /// <param name="line">La ligne du vol à analyser</param>
            /// <param name="AircraftType">La table des types d'avions</param>
            /// <param name="FlightCategories">La table des catégories de vol</param>
            /// <param name="LoadFactors">La table des facteurs de chargement</param>
            /// <returns>Renvoie le nombre de passagers que l'on peut espérer pour ce vol.</returns>
            internal static Double numberOfPassengers(DataRow line,
                DataManagement.ExceptionTable AircraftType,
                DataTable FlightCategories,
                DataManagement.ExceptionTable LoadFactors,
                ArrayList ListeErreurs)
            {
                String NBPax = getValue(line, GlobalNames.sFPD_A_Column_NbSeats);
                if (NBPax == null)
                {
                    ListeErreurs.Add("Err00412 : Unable to find column NB PAX.");
                    return -1;
                }
                int iNbPax;
                if (!Int32.TryParse(NBPax, out iNbPax))
                {
                    iNbPax = 0;
                    //return (Double)iNbPax;
                }
                String Aircraft = getValue(line, GlobalNames.sFPD_A_Column_AircraftType);
                if (Aircraft == null)
                {
                    ListeErreurs.Add("Err00413 : Unable to find column " + GlobalNames.sFPD_A_Column_AircraftType);
                    return -1;
                }
                String Airline = getValue(line, GlobalNames.sFPD_A_Column_AirlineCode);
                if (Airline == null)
                {
                    ListeErreurs.Add("Err00424 : Unable to find column " + GlobalNames.sFPD_A_Column_AirlineCode);
                    return -1;
                }
                String ID = getValue(line, GlobalNames.sFPD_A_Column_ID);
                if (ID == null)
                {
                    ListeErreurs.Add("Err00423 : Unable to find column " + GlobalNames.sFPD_A_Column_ID);
                    return -1;
                }

                String flightCategory = getValue(line, GlobalNames.sFPD_A_Column_FlightCategory);
                if (flightCategory == null)
                {
                    ListeErreurs.Add("Err00416 : Unable to find column FLIGHT CATEGORY");
                    return -1;
                }

                String sPrefixe = "A_";
                if (line.Table.Columns.Contains(GlobalNames.sFPD_Column_STD))
                    sPrefixe = "D_";
                DataRow drRow = AircraftType.GetInformationsRow(0, sPrefixe + ID, Airline, flightCategory, Aircraft);
                if (drRow == null)
                {
                    ListeErreurs.Add("Err00425 : Unable to find the capacity for the aircraft " + Aircraft);
                    return -1;
                }
                int iCapacityColumn = drRow.Table.Columns.IndexOf(GlobalNames.sFPAircraft_NumberSeats);
                if (iCapacityColumn == -1)
                {
                    ListeErreurs.Add("Err00426 : Unable to find the capacity for the aircraft " + Aircraft);
                    return -1;
                }

                String sCapacity = drRow[iCapacityColumn].ToString();
                if (sCapacity == null)
                {
                    ListeErreurs.Add("Err00414 : Aircraft type unknow : " + Aircraft);
                    return -1;
                }
                int iCapacity;
                if (!Int32.TryParse(sCapacity, out iCapacity))
                {
                    ListeErreurs.Add("Err00415 : The aircraft capacity is not valid");
                    return -1;
                }
                if (FlightCategories != null)
                {
                    if (getValue(FlightCategories, flightCategory, 0, 1) == null)
                    {
                        ListeErreurs.Add("Err00417 : The flight category \"" + flightCategory + "\" does not exist in the table \"" + FlightCategories.TableName + "\".");
                        return -1;
                    }
                }

                Dictionary<String, String> dssResults = LoadFactors.GetInformationsColumns(0, sPrefixe + ID, Airline, flightCategory);

                String sLoadFactor = dssResults[GlobalNames.sLFD_A_Line_Full];// getValue(LoadFactors, GlobalNames.sLFD_A_Line_Full, 0, LoadFactors.Columns.IndexOf(flightCategory));
                if (sLoadFactor == null)
                {
                    ListeErreurs.Add("Err00418 : The load factor table have problems");
                    return -1;
                }
                Double dLoadFactor;
                if (!Double.TryParse(sLoadFactor, out dLoadFactor))
                {
                    ListeErreurs.Add("Err00419 : The load factor value is not valid");
                    return -1;
                }
                if (iNbPax != 0)
                    return (iNbPax * dLoadFactor) / 100.0f;
                return (dLoadFactor * iCapacity) / 100.0f;
            }

            internal static double getNbPaxForFlight(DataRow line, ExceptionTable AircraftType, DataTable FlightCategories, ExceptionTable LoadFactors, // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                FlightAttribute.ARR_OR_DEP_FLIGHT_TAG arrOrDepFlight, int flightId, List<FlightConfiguration> flightConfigurations, ArrayList ListeErreurs)
            {
                double paxNumber = -1;
                FlightConfiguration flightConfiguration = Tools.FlightPlanParametersTools
                    .getFlightConfigurationByArrOrDepAndFlightId(arrOrDepFlight, flightId, flightConfigurations);
                if (flightConfiguration != null)
                {
                    if (arrOrDepFlight == FlightAttribute.ARR_OR_DEP_FLIGHT_TAG.A)
                    {
                        paxNumber = flightConfiguration.flightParameter.nbTermEcoPax + flightConfiguration.flightParameter.nbTermFbPax
                            + flightConfiguration.flightParameter.nbTransferEcoPax + flightConfiguration.flightParameter.nbTransferFbPax;
                    }
                    else if (arrOrDepFlight == FlightAttribute.ARR_OR_DEP_FLIGHT_TAG.D)
                    {
                        paxNumber = flightConfiguration.flightParameter.nbOrigEcoPax + flightConfiguration.flightParameter.nbOrigFbPax
                            + flightConfiguration.flightParameter.nbTransferEcoPax + flightConfiguration.flightParameter.nbTransferFbPax;
                    }
                }
                else
                {
                    paxNumber = OverallTools.DataFunctions.numberOfPassengers(line, AircraftType, FlightCategories, LoadFactors, ListeErreurs);
                }
                return paxNumber;
            }
            #endregion

            #region Fonctions pour recherché une valeur particulière dans une table.

            public static String getValue(DataTable Table, String ValeurComparaison, int colonneComparaison, int colonneValeur)
            {
                if ((Table.Columns.Count <= colonneComparaison) || (Table.Columns.Count <= colonneValeur) ||
                    (0 > colonneComparaison) || (0 > colonneValeur))
                    return null;
                foreach (DataRow ligne in Table.Rows)
                {
                    if (ligne.ItemArray[colonneComparaison].ToString() == ValeurComparaison)
                    {
                        return ligne.ItemArray[colonneValeur].ToString();
                    }
                }
                return null;
            }
            public static String getValue(DataRow line, String nomColonne)
            {
                int indexColonne = line.Table.Columns.IndexOf(nomColonne);
                if (indexColonne == -1)
                    return null;
                return line.ItemArray[indexColonne].ToString();
            }

            public static DateTime getMaxDate(DataTable table, int iColonne)
            {
                if (table.Columns.Count <= iColonne)
                    return DateTime.MinValue;
                if (table.Rows.Count == 0)
                    return DateTime.MinValue;
                DateTime tmp = (DateTime)table.Rows[0][iColonne];
                for (int i = 1; i < table.Rows.Count; i++)
                {
                    if ((DateTime)table.Rows[i][iColonne] > tmp)
                    {
                        tmp = (DateTime)table.Rows[i][iColonne];
                    }
                }
                return tmp;
            }
            public static DateTime getMinDate(DataTable table, int iColonne)
            {
                if (table.Columns.Count <= iColonne)
                    return DateTime.MinValue;
                if (table.Rows.Count == 0)
                    return DateTime.MinValue;
                DateTime tmp = (DateTime)table.Rows[0][iColonne];
                for (int i = 1; i < table.Rows.Count; i++)
                {
                    if ((DateTime)table.Rows[i][iColonne] < tmp)
                    {
                        tmp = (DateTime)table.Rows[i][iColonne];
                    }
                }
                return tmp;
            }
            public static double getMaxValue(DataTable table, int iColonne)
            {
                if (table.Columns.Count <= iColonne)
                    return 0;
                if (table.Rows.Count == 0)
                    return 0;
                Double resultat;
                Double.TryParse(table.Rows[0].ItemArray[iColonne].ToString(), out resultat);
                Double temp;
                foreach (DataRow ligne in table.Rows)
                {
                    Double.TryParse(ligne[iColonne].ToString(), out temp);
                    if (resultat < temp)
                    {
                        resultat = temp;
                    }
                }
                return resultat;
            }
            public static double getMinValue(DataTable table, int iColonne)
            {
                if (table.Columns.Count <= iColonne)
                    return 0;
                if (table.Rows.Count == 0)
                    return 0;
                Double resultat;
                Double.TryParse(table.Rows[0].ItemArray[iColonne].ToString(), out resultat);
                Double temp;
                foreach (DataRow ligne in table.Rows)
                {
                    Double.TryParse(ligne[iColonne].ToString(), out temp);
                    if (resultat > temp)
                    {
                        resultat = temp;
                    }
                }
                return resultat;
            }

            // >> Task #10156 Pax2Sim - Statistic dev - Target            
            public static double getAvgValue(DataTable table, int columnIndex)
            {
                Double average = 0;
                Double sum = 0;
                Double currentValue = 0;

                if (table == null || table.Columns.Count <= columnIndex
                    || table.Rows.Count == 0)
                {
                    return average;
                }

                foreach (DataRow row in table.Rows)
                {
                    if (Double.TryParse(row[columnIndex].ToString(), out currentValue))
                        sum += currentValue;
                }

                average = sum / table.Rows.Count;

                return Math.Round(average, 3);
            }
            // << Task #10156 Pax2Sim - Statistic dev - Target   

            public static double getSumByTableColumn(DataTable table, int columnIndex)
            {
                Double sum = 0;
                Double currentValue = 0;
                if (table == null || table.Columns.Count <= columnIndex
                    || table.Rows.Count == 0)
                {
                    return sum;
                }
                foreach (DataRow row in table.Rows)
                {
                    if (Double.TryParse(row[columnIndex].ToString(), out currentValue))
                    {
                        sum += currentValue;
                    }
                }
                return Math.Round(sum, 2);
            }

            internal static DateTime Min(DateTime dtTmp1, DateTime dtTmp2)
            {
                if (dtTmp1 > dtTmp2)
                    return dtTmp2;
                return dtTmp1;
            }

            internal static DateTime Max(DateTime dtTmp1, DateTime dtTmp2)
            {
                if (dtTmp1 < dtTmp2)
                    return dtTmp2;
                return dtTmp1;
            }

            internal static DataRow getRow(DataTable dtTable, Dictionary<String, String> dssParameters)
            {
                List<DataRow> drResult = getRows(dtTable, dssParameters);
                if ((drResult == null) || (drResult.Count == 0))
                    return null;
                return drResult[0];
            }
            internal static List<DataRow> getRows(DataTable dtTable, Dictionary<String, String> dssParameters)
            {
                if ((dssParameters == null) || (dssParameters.Count == 0))
                    return null;

                if (dtTable == null)
                    return null;
                if (dtTable.Rows.Count == 0)
                    return null;

                DataRow[] drTmp = new DataRow[dtTable.Rows.Count];
                dtTable.Rows.CopyTo(drTmp, 0);
                List<DataRow> drResult = new List<DataRow>(drTmp);
                foreach (String sKey in dssParameters.Keys)
                {
                    drResult = getRows(dtTable, drResult, sKey, dssParameters[sKey]);
                    if (drResult == null)
                        return null;
                }
                return drResult;
            }
            internal static List<DataRow> getRows(DataTable dtTable, String sColumnName, String sValue)
            {
                if (dtTable == null)
                    return null;
                if (!dtTable.Columns.Contains(sColumnName))
                    return null;
                DataRow[] drTmp = new DataRow[dtTable.Rows.Count];
                dtTable.Rows.CopyTo(drTmp, 0);
                return getRows(dtTable, new List<DataRow>(drTmp), sColumnName, sValue);
            }
            private static List<DataRow> getRows(DataTable dtTable, List<DataRow> dtRows, String sColumnName, String sValue)
            {
                if (dtRows == null)
                    return null;
                if (dtTable == null)
                    return null;
                if (dtRows.Count == 0)
                    return null;
                if (!dtTable.Columns.Contains(sColumnName))
                    return null;
                List<DataRow> drResults = new List<DataRow>();
                int iIndexColumn = dtTable.Columns.IndexOf(sColumnName);
                foreach (DataRow drRow in dtRows)
                {
                    if (drRow[iIndexColumn].ToString() == sValue)
                        drResults.Add(drRow);
                }
                return drResults;
            }
            #endregion

            #region Fonction pour créer un format date à partir des informations données par l'utilisateur
            public static DateTime toDateTime(Object date, Object Time)
            {
                if (date == null)
                    return DateTime.MinValue;
                DateTime dtResult;
                if (date.GetType() == typeof(DateTime))
                {
                    dtResult = (DateTime)date;
                }
                else if (date.GetType() == typeof(String))
                {
                    String sResult = (String)date;
                    if (!DateTime.TryParse(sResult, out dtResult))
                    {
                        return DateTime.MinValue;
                    }
                }
                else
                {
                    return DateTime.MinValue;
                }
                if (Time != null)
                {
                    //2010.02.11 ==> TimeSpan
                    /*TimeSpanCulture tsc;
                    if (!TimeSpanCulture.TryParse(Time.ToString(), out tsc))
                        return DateTime.MinValue;*/

                    TimeSpan tsResult;

                    if (Time.GetType() == typeof(TimeSpan))
                    {
                        tsResult = (TimeSpan)Time;
                    }
                    else if (Time.GetType() == typeof(String))
                    {
                        String sResult = (String)Time;
                        if (!TimeSpan.TryParse(sResult, out tsResult))
                        {
                            return DateTime.MinValue;
                        }
                    }
                    else
                    {
                        return DateTime.MinValue;
                    }
                    dtResult = dtResult.Add(tsResult);

                }
                return dtResult;
            }
            #endregion

            #region Fonction pour retransformer la table des allocations

            /// <summary>
            /// Fonction qui convertit une table d'allocation (Security /Passport ...) en une table simplifiée
            /// permettant l'utilsation de l'assistant d'allocation.
            /// </summary>
            /// <param name="AllocationTable"></param>
            /// <param name="passport"></param>
            /// <param name="Security"></param>
            /// <param name="tColumnType"></param>
            /// <returns></returns>
            public static DataTable convertToAllocTable(DataTable AllocationTable, bool passport, bool Security, Type tColumnType)
            {
                DataTable Resultats = new DataTable(AllocationTable.TableName);
                Resultats.Columns.Add("Group", System.Type.GetType("System.String"));
                Resultats.Columns.Add("Time", System.Type.GetType("System.DateTime"));
                if ((passport) || (Security))
                {
                    Resultats.Columns.Add("TypeDesk", System.Type.GetType("System.Int32"));
                }
                Resultats.Columns.Add("NumberOpen", tColumnType);
                int iIndexDebut = 0;
                int iIndexFin = AllocationTable.Rows.Count;
                if (iIndexFin <= iIndexDebut)
                    return Resultats;
                int i;
                DataRow newLine;
                DateTime dateTestee;
                int iEntierTeste = 0;
                bool bProcessAllocation = (tColumnType == typeof(String));
                for (int iIndexColumn = 1; iIndexColumn < AllocationTable.Columns.Count; iIndexColumn++)
                {
                    newLine = Resultats.NewRow();
                    String sValue = AllocationTable.Rows[iIndexDebut].ItemArray[iIndexColumn].ToString();
                    DateTime.TryParse(AllocationTable.Rows[iIndexDebut].ItemArray[0].ToString(), out dateTestee);
                    int iPassportType = 0;
                    if ((passport) || (Security))
                    {
                        int j = 0;
                        String sTmp = OverallTools.FonctionUtiles.nextInt(sValue, ref j);
                        if (sTmp == "")
                        {
                            iPassportType = 0;
                            sValue = "0";
                        }
                        else
                        {
                            iPassportType = FonctionsType.getInt(sTmp, sTmp.GetType());
                            //Int32.TryParse(sTmp,out iPassportType);
                            sValue = sValue.Substring(j + 1);
                        }
                    }
                    if (!bProcessAllocation)
                    {
                        if (!Int32.TryParse(sValue, out iEntierTeste))
                        {
                            iEntierTeste = 0;
                        }
                        if ((passport) || (Security))
                        {
                            newLine[2] = iPassportType;
                            newLine[3] = iEntierTeste;
                        }
                        else
                        {
                            newLine[2] = iEntierTeste;
                        }
                    }
                    else
                    {
                        newLine[2] = sValue;
                    }
                    newLine[0] = AllocationTable.Columns[iIndexColumn].ColumnName;
                    newLine[1] = dateTestee;

                    Resultats.Rows.Add(newLine);
                    String sOldTable = sValue;
                    int Value = iEntierTeste;
                    int iPassportTypeAncien = iPassportType;
                    for (i = iIndexDebut + 1; i < iIndexFin; i++)
                    {
                        sValue = AllocationTable.Rows[i].ItemArray[iIndexColumn].ToString();
                        if ((passport) || (Security))
                        {
                            int j = 0;
                            String sTmp = OverallTools.FonctionUtiles.nextInt(sValue, ref j);
                            if (sTmp == "")
                            {
                                iPassportType = 0;
                                sValue = "0";
                            }
                            else
                            {
                                iPassportType = FonctionsType.getInt(sTmp, sTmp.GetType());
                                sValue = sValue.Substring(j + 1);
                            }
                        }
                        if (bProcessAllocation)
                        {
                            if (sValue != sOldTable)
                            {
                                DateTime.TryParse(AllocationTable.Rows[i].ItemArray[0].ToString(), out dateTestee);
                                newLine = Resultats.NewRow();
                                newLine[0] = AllocationTable.Columns[iIndexColumn].ColumnName;
                                newLine[1] = dateTestee;

                                newLine[2] = sValue;
                                Resultats.Rows.Add(newLine);
                                sOldTable = sValue;
                            }
                        }
                        else
                        {
                            if (!Int32.TryParse(sValue, out iEntierTeste))
                            {
                                iEntierTeste = 0;
                            }
                            if ((iEntierTeste != Value) || (((passport) || (Security)) && (iPassportTypeAncien != iPassportType)))
                            {
                                DateTime.TryParse(AllocationTable.Rows[i].ItemArray[0].ToString(), out dateTestee);
                                newLine = Resultats.NewRow();
                                newLine[0] = AllocationTable.Columns[iIndexColumn].ColumnName;
                                newLine[1] = dateTestee;

                                if ((passport) || (Security))
                                {
                                    newLine[2] = iPassportType;
                                    newLine[3] = iEntierTeste;
                                }
                                else
                                {
                                    newLine[2] = iEntierTeste;
                                }
                                Resultats.Rows.Add(newLine);
                                Value = iEntierTeste;
                            }
                        }
                    }
                }
                return Resultats;
            }

            /// <summary>
            /// Fonction qui convertit une table d'allocation (Security /Passport ...) en une table simplifiée
            /// permettant l'utilsation de l'assistant d'allocation.
            /// </summary>
            /// <param name="AllocationTable"></param>
            /// <returns></returns>
            public static DataTable convertToAllocTable(DataTable AllocationTable,
                                                        bool bPassport,
                                                        //<< Task #7405 - new Desk and extra information for Pax            
                                                        GestionDonneesHUB2SIM donneesEnCours
                                                        //>> Task #7405 - new Desk and extra information for Pax
                                                        )
            {
                DataTable Resultats = new DataTable(AllocationTable.TableName);
                Resultats.Columns.Add("GroupName", System.Type.GetType("System.String"));
                Resultats.Columns.Add("BeginDate", System.Type.GetType("System.DateTime"));
                Resultats.Columns.Add("endDate", System.Type.GetType("System.DateTime"));
                Resultats.Columns.Add("StationsOpen", System.Type.GetType("System.Int32"));
                Resultats.Columns.Add("TimeType", System.Type.GetType("System.String"));
                Resultats.Columns.Add("PassportType", System.Type.GetType("System.String"));
                Resultats.Columns.Add("ClassType", System.Type.GetType("System.String"));
                Resultats.Columns.Add("FlightCategory", System.Type.GetType("System.String"));
                Resultats.Columns.Add("Airlines", System.Type.GetType("System.String"));
                Resultats.Columns.Add("FlightIdentification", System.Type.GetType("System.String"));
                //<< Task #7405 - new Desk and extra information for Pax
                //add user attrib columns
                DataManagement.NormalTable userAttributesTable = donneesEnCours.GetTable("Input", GlobalNames.sUserAttributesTableName);
                int nbOfUserAttribRows = 0;
                // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                int nbOfNonUserAttributesRows = 0;
                // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                if (userAttributesTable != null)
                {
                    foreach (DataRow dr in userAttributesTable.Table.Rows)
                    {
                        String distribTableName = dr[GlobalNames.sUserAttributes_ColumnName].ToString();
                        // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                        if (GlobalNames.nonUserAttributesExceptionsList.Contains(distribTableName))
                        {
                            nbOfNonUserAttributesRows++;
                            continue;
                        }
                        // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                        Resultats.Columns.Add(distribTableName, System.Type.GetType("System.String"));
                    }
                    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant                    
                    nbOfUserAttribRows = userAttributesTable.Table.Rows.Count - nbOfNonUserAttributesRows;
                    //nbOfUserAttribRows = userAttributesTable.Table.Rows.Count;
                    // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                }
                //>> Task #7405 - new Desk and extra information for Pax                
                int iIndexDebut = 0;
                int iIndexFin = AllocationTable.Rows.Count;
                if (iIndexFin <= iIndexDebut)
                    return Resultats;
                DataRow newLine;
                DataRow previousLine;
                DateTime DateDebut;
                DateTime DateFin;
                String[] valueList;
                for (int iIndexColumn = 1; iIndexColumn < AllocationTable.Columns.Count; iIndexColumn++)
                {
                    previousLine = null;
                    for (int iIndexRow = 0; iIndexRow < AllocationTable.Rows.Count; iIndexRow++)
                    {
                        newLine = Resultats.NewRow();
                        String sValue = AllocationTable.Rows[iIndexRow].ItemArray[iIndexColumn].ToString();
                        DateTime.TryParse(AllocationTable.Rows[iIndexRow].ItemArray[0].ToString(), out DateDebut);
                        if (iIndexRow == AllocationTable.Rows.Count - 1)
                            DateTime.TryParse(AllocationTable.Rows[iIndexRow].ItemArray[0].ToString(), out DateFin);
                        else
                            DateTime.TryParse(AllocationTable.Rows[iIndexRow + 1].ItemArray[0].ToString(), out DateFin);
                        valueList = sValue.Split(';');
                        if (valueList.Length != 7 && valueList.Length != 7 + nbOfUserAttribRows) //<< Task #7405 - new Desk and extra information for Pax
                        {
                            newLine[0] = AllocationTable.Columns[iIndexColumn].ColumnName.ToString();
                            newLine[1] = DateDebut;
                            newLine[2] = DateFin;
                            newLine[3] = 0;
                            newLine[4] = GlobalNames.sAllocation_NotApplicable;
                            newLine[5] = "All";
                            newLine[6] = "All";
                            newLine[7] = "All";
                            newLine[8] = "All";
                            newLine[9] = "All";
                            if (valueList.Length == 1)
                            {
                                valueList = valueList[0].Split(',');
                                if (valueList.Length == 1)
                                {
                                    #region Pour les postes transfer
                                    newLine[3] = FonctionsType.getInt(valueList[0]);
                                    #endregion
                                }
                                else if (valueList.Length == 2)
                                {
                                    #region Pour les postes security ou Passport
                                    newLine[3] = FonctionsType.getInt(valueList[1]);
                                    if (bPassport)
                                    {
                                        int iType = FonctionsType.getInt(valueList[0]);
                                        if (iType == 1)
                                            newLine[5] = "Local";
                                        else if (iType == 2)
                                            newLine[5] = "Not Local";
                                        else
                                            newLine[5] = "All";
                                    }
                                    else
                                    {
                                        int iType = FonctionsType.getInt(valueList[0]);
                                        if (iType == 1)
                                            newLine[6] = "F&B";
                                        else if (iType == 2)
                                            newLine[6] = "Eco";
                                        else
                                            newLine[6] = "All";
                                    }
                                    #endregion
                                }
                                else
                                {
                                    #region Pour les autres ? Problèmes
                                    if (previousLine != null)
                                        newLine = previousLine;
                                    #endregion
                                }

                            }
                        }
                        else
                        {
                            newLine[0] = AllocationTable.Columns[iIndexColumn].ToString();
                            newLine[1] = DateDebut;
                            newLine[2] = DateFin;

                            if (valueList[0] == "")
                                newLine[3] = 0;
                            else
                                newLine[3] = FonctionsType.getInt(valueList[0], valueList[0].GetType());

                            if (valueList[1] == "")
                                newLine[4] = GlobalNames.sAllocation_NotApplicable;
                            else
                                newLine[4] = FonctionsType.getString(valueList[1]);

                            if (valueList[2] == "")
                                newLine[5] = "All";
                            else
                                newLine[5] = FonctionsType.getString(valueList[2]);

                            if (valueList[3] == "")
                                newLine[6] = "All";
                            else
                                newLine[6] = FonctionsType.getString(valueList[3]);

                            if (valueList[4] == "")
                                newLine[7] = "All";
                            else
                                newLine[7] = FonctionsType.getString(valueList[4]);

                            if (valueList[5] == "")
                                newLine[8] = "All";
                            else
                                newLine[8] = FonctionsType.getString(valueList[5], valueList[5].GetType());

                            if (valueList[6] == "")
                                newLine[9] = "All";
                            else
                                newLine[9] = FonctionsType.getString(valueList[6]);
                            //<< Task #7405 - new Desk and extra information for Pax 
                            int index = 6;
                            if (valueList.Length == 7 + nbOfUserAttribRows)
                            {
                                for (int i = 1; i <= nbOfUserAttribRows; i++)
                                {
                                    index = index + 1;
                                    if (valueList[index] == null || valueList[index] == "")
                                        newLine[index + 3] = "All";
                                    else
                                        newLine[index + 3] = FonctionsType.getString(valueList[index]);
                                }
                            }
                            else if (nbOfUserAttribRows > 0)
                            {
                                for (int i = 1; i <= nbOfUserAttribRows; i++)
                                {
                                    index = index + 1;
                                    newLine[index + 3] = "All";
                                }
                            }
                            //>> Task #7405 - new Desk and extra information for Pax
                        }
                        if (previousLine == null)
                            previousLine = newLine;
                        /*    
                        else if (newLine[3].ToString() != previousLine[3].ToString() || newLine[4].ToString() != previousLine[4].ToString() ||
                            newLine[5].ToString() != previousLine[5].ToString() || newLine[6].ToString() != previousLine[6].ToString() ||
                            newLine[7].ToString() != previousLine[7].ToString() || newLine[8].ToString() != previousLine[8].ToString() || 
                            newLine[9].ToString() != previousLine[9].ToString())
                        {
                            Resultats.Rows.Add(previousLine);
                            previousLine = newLine;
                        }
                           */
                        //<< Task #7405 - new Desk and extra information for Pax                        
                        else if (diffrentData(newLine, previousLine, nbOfUserAttribRows))
                        {
                            Resultats.Rows.Add(previousLine);
                            previousLine = newLine;
                        }
                        //>> Task #7405 - new Desk and extra information for Pax
                        else
                            previousLine[2] = DateFin;
                    }
                    Resultats.Rows.Add(previousLine);
                }

                return Resultats;
            }
            //<< Task #7405 - new Desk and extra information for Pax            
            private static bool diffrentData(DataRow newLine, DataRow previousLine, int nbExtraCollumns)
            {
                for (int i = 3; i < newLine.ItemArray.Length; i++)
                    if (newLine[i].ToString() != previousLine[i].ToString())
                        return true;
                return false;
            }
            //>> Task #7405 - new Desk and extra information for Pax
            #endregion

            #region Fonction pour modifier le contenu d'une colonne par une autre valeur.
            public static void ReplaceValue(DataTable laTable, String ColumnName, String oldValue, String newValue)
            {
                int iIndexColumn = laTable.Columns.IndexOf(ColumnName);
                if (iIndexColumn == -1)
                    return;

                int[] values = DataFunctions.indexLignes(laTable, iIndexColumn, oldValue);
                if ((values == null) || (values.Length == 0))
                    return;
                foreach (int value in values)
                {
                    //Table
                    laTable.Rows[value].BeginEdit();
                    laTable.Rows[value][iIndexColumn] = newValue;
                }
                laTable.AcceptChanges();
            }
            #endregion

            #region Fonction pour renommer le nom d'une colonne
            public static void renameColumn(DataTable laTable, String oldValue, String newValue)
            {
                if (laTable.Columns.Contains(oldValue))
                {
                    laTable.Columns[oldValue].ColumnName = newValue;
                }
            }
            #endregion

            #region Fonction pour vérifier le contenu d'une case de la table passportCheck.
            public static bool checkPassportValue(String value)
            {
                if (OverallTools.FonctionUtiles.nombreCaractere(value, ',') != 1)
                {
                    if (value == "")
                        return true;
                    return false;
                }
                String[] eValues = value.Split(',');
                int iTypePassport;
                int iNombreDesks;
                if (!Int32.TryParse(eValues[0], out iTypePassport))
                {
                    return false;
                }
                if (!Int32.TryParse(eValues[1], out iNombreDesks))
                {
                    return false;
                }
                if ((iTypePassport > 0) && (iTypePassport <= 3))
                    return true;
                return false;
            }

            public static bool checkPassportNewFormat(String value, int iExtraColumns)
            {
                //<< Task #7405 - new Desk and extra information for Pax                
                if (OverallTools.FonctionUtiles.nombreCaractere(value, ';') != 6 + iExtraColumns)
                {
                    if (value == "")
                        return true;
                    return false;
                }
                //>> Task #7405 - new Desk and extra information for Pax
                String[] eValues = value.Split(';');
                if (FonctionsType.getInt(eValues[0]) < 0)
                    return false;
                if ((eValues[1] != GlobalNames.sAllocation_NotApplicable) && (FonctionsType.getInt(eValues[1]) < 0))
                    return false;
                if ((eValues[2] != GlobalNames.sAllocation_NotLocal) && (eValues[2] != GlobalNames.sAllocation_Local) && (eValues[2] != GlobalNames.sAllocation_All))
                    return false;

                if ((eValues[3] != GlobalNames.sAllocation_FB) && (eValues[3] != GlobalNames.sAllocation_Eco) && (eValues[3] != GlobalNames.sAllocation_All))
                    return false;
                return true;
            }
            #endregion

            #region Fonction pour calcul les informations de min et de max dans une table passée en parametres
            /// <summary>
            /// Fonction which permit to obtain the min, max, Average values of a column.
            /// </summary>
            /// <param name="dtTable">The dataTable</param>
            /// <param name="iNumColumn">The column to look at(must be double or int)</param>
            /// <returns>Min, max and Average of the selected column</returns>
            public static Double[] GetStatColumn(DataTable dtTable, int iNumColumn)
            {
                if (dtTable == null)
                    return null;
                if (iNumColumn >= dtTable.Columns.Count)
                    return null;
                if (iNumColumn < 0)
                    return null;
                Type type = dtTable.Columns[iNumColumn].DataType;
                if ((type != typeof(Double)) &&
                    (type != typeof(double)) &&
                    (type != typeof(int)) &&
                    (type != typeof(Int32)) &&
                    (type != typeof(Int16)) &&
                    (type != typeof(Int64)))
                {
                    return null;
                }
                bool bDouble = ((type == typeof(Double)) ||
                                (type == typeof(double)));
                Double[] Result = new Double[3] { -1, 0, 0 };
                if (dtTable.Rows.Count == 0)
                {
                    Result[0] = 0;
                }
                else
                {
                    foreach (DataRow line in dtTable.Rows)
                    {
                        Double dValue = 0;
                        if (bDouble)
                        {
                            if (line[iNumColumn].ToString() == "")
                                dValue = 0;
                            else
                                dValue = (Double)line[iNumColumn];
                        }
                        else
                        {
                            if (line[iNumColumn].ToString() == "")
                                dValue = 0;
                            else
                                dValue = (Int32)line[iNumColumn];
                        }
                        if (dValue > Result[1])
                            Result[1] = dValue;
                        if ((Result[0] == -1) || (dValue < Result[0]))
                            Result[0] = dValue;
                        Result[2] += dValue;
                    }
                    Result[2] = Result[2] / dtTable.Rows.Count;
                }
                return Result;
            }

            // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
            /// <summary>
            /// Fonction which permit to obtain the min, max, Average values of a column, when needing
            /// only the data > 0.
            /// </summary>
            /// <param name="dtTable">The dataTable</param>
            /// <param name="iNumColumn">The column to look at(must be double or int)</param>
            /// <returns>Min, max and Average of the selected column</returns>
            public static Double[] GetStatColumnIgnoreZeros(DataTable dtTable, int iNumColumn, int referenceColumnIndexForIgnoringZeros)
            {
                if (dtTable == null)
                    return null;
                if (iNumColumn >= dtTable.Columns.Count)
                    return null;
                if (iNumColumn < 0)
                    return null;
                Type type = dtTable.Columns[iNumColumn].DataType;
                if ((type != typeof(Double)) &&
                    (type != typeof(double)) &&
                    (type != typeof(int)) &&
                    (type != typeof(Int32)) &&
                    (type != typeof(Int16)) &&
                    (type != typeof(Int64)))
                {
                    return null;
                }

                // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                if (referenceColumnIndexForIgnoringZeros < 0
                    || referenceColumnIndexForIgnoringZeros > dtTable.Columns.Count)
                {
                    return null;
                }
                Type referenceForIgnoringZerosType
                    = dtTable.Columns[referenceColumnIndexForIgnoringZeros].DataType;
                if ((referenceForIgnoringZerosType != typeof(Double)) &&
                    (referenceForIgnoringZerosType != typeof(double)) &&
                    (referenceForIgnoringZerosType != typeof(int)) &&
                    (referenceForIgnoringZerosType != typeof(Int32)) &&
                    (referenceForIgnoringZerosType != typeof(Int16)) &&
                    (referenceForIgnoringZerosType != typeof(Int64)))
                {
                    return null;
                }
                // << Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard

                bool bDouble = ((type == typeof(Double)) ||
                                (type == typeof(double)));
                Double[] Result = new Double[3] { -1, 0, 0 };
                if (dtTable.Rows.Count == 0)
                {
                    Result[0] = 0;
                }
                else
                {
                    int nbOfRelevantLines = 0;
                    foreach (DataRow line in dtTable.Rows)
                    {

                        // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                        double referenceValueForIgnoringZeros = 0;
                        if (!Double.TryParse(line[referenceColumnIndexForIgnoringZeros].ToString(), out referenceValueForIgnoringZeros)
                            || referenceValueForIgnoringZeros == 0)
                        {
                            continue;
                        }
                        // << Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard

                        Double dValue = 0;
                        if (bDouble)
                        {
                            if (line[iNumColumn].ToString() == "")
                                dValue = 0;
                            else
                                dValue = (Double)line[iNumColumn];
                        }
                        else
                        {
                            if (line[iNumColumn].ToString() == "")
                                dValue = 0;
                            else
                                dValue = (Int32)line[iNumColumn];
                        }

                        //if (dValue == 0) //ignore the lines with 0.
                        //    continue;     not the value (min, avg or max) but the nb of bags must be 0 to ignore the line

                        nbOfRelevantLines++;

                        if (dValue > Result[1])
                            Result[1] = dValue;
                        if ((Result[0] == -1) || (dValue < Result[0]))
                            Result[0] = dValue;
                        Result[2] += dValue;
                    }
                    if (nbOfRelevantLines == 0)
                    {
                        Result[0] = 0;
                        Result[1] = 0;
                        Result[2] = 0;
                    }
                    else
                    {
                        Result[2] = Result[2] / nbOfRelevantLines;
                    }
                }
                return Result;
            }
            // << Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent

            public static Double[] GetStatColumn(DataTable dtTable, String sColumn)
            {
                if (dtTable == null)
                    return null;
                if (!dtTable.Columns.Contains(sColumn))
                    return null;
                return GetStatColumn(dtTable, dtTable.Columns.IndexOf(sColumn));
            }

            public static void GetStatTable(DataTable dtStatTable, DataTable dtTable, int[] tiColumns)
            {
                if ((dtStatTable == null) || (dtStatTable.Columns.Count < 4))
                    return;
                if (dtTable == null)
                    return;
                if (tiColumns == null)
                    return;
                int iIndexData = dtStatTable.Columns.IndexOf("Data");
                int iIndexMin = dtStatTable.Columns.IndexOf("Min");
                int iIndexMean = dtStatTable.Columns.IndexOf("Average");
                int iIndexMax = dtStatTable.Columns.IndexOf("Max");
                int iIndexSum = dtStatTable.Columns.IndexOf("Sum");
                if ((iIndexData == -1) || (iIndexMin == -1) || (iIndexMean == -1) || (iIndexMax == -1))
                    return;
                for (int i = 0; i < tiColumns.Length; i++)
                {
                    Double[] tdValues = GetStatColumn(dtTable, tiColumns[i]);
                    if (tdValues == null)
                        continue;
                    DataRow drRow = dtStatTable.NewRow();
                    drRow[iIndexData] = dtTable.TableName + "_" + dtTable.Columns[tiColumns[i]].ColumnName;
                    drRow[iIndexMin] = Math.Round(tdValues[0], 2);
                    drRow[iIndexMean] = Math.Round(tdValues[2], 2);
                    drRow[iIndexMax] = Math.Round(tdValues[1], 2);
                    if (iIndexSum != -1)
                    {
                        Double dSum = 0;
                        for (int j = 0; j < dtTable.Rows.Count; j++)
                        {
                            dSum += FonctionsType.getDouble(dtTable.Rows[j][tiColumns[i]], dtTable.Columns[tiColumns[i]].DataType);
                        }
                        drRow[iIndexSum] = Math.Round(dSum, 2);
                    }
                    dtStatTable.Rows.Add(drRow);
                }
                dtStatTable.AcceptChanges();
            }

            public static string STATS_TABLE_DATA_COLUMN_NAME = "Data";
            public static string STATS_TABLE_MIN_COLUMN_NAME = "Min";
            public static string STATS_TABLE_AVG_COLUMN_NAME = "Average";
            public static string STATS_TABLE_MAX_COLUMN_NAME = "Max";
            public static string STATS_TABLE_SUM_COLUMN_NAME = "Sum";
            public static string STATS_TABLE_DETAILS_COLUMN_NAME = "Details";   // >> Task #10254 Pax2Sim - View statistics option C#19
            public static DataTable GetStatTable(DataTable dtTable, int[] tiColumns)
            {
                DataTable Result = new DataTable();
                Result.Columns.Add("Data", typeof(String));
                Result.Columns.Add("Min", typeof(Double));
                Result.Columns.Add("Average", typeof(Double));
                Result.Columns.Add("Max", typeof(Double));
                Result.Columns.Add("Sum", typeof(Double));
                GetStatTable(Result, dtTable, tiColumns);
                return Result;
            }

            // >> Task #10254 Pax2Sim - View statistics option C#14
            public static DataTable generateViewStatisticsTable(DataTable sourceTable, List<int> sourceColumnIndexes, double[] percentiles)
            {
                DataTable statTable = new DataTable();
                statTable.Columns.Add(STATS_TABLE_DATA_COLUMN_NAME, typeof(String));
                statTable.Columns.Add(STATS_TABLE_MIN_COLUMN_NAME, typeof(Double));
                statTable.Columns.Add(STATS_TABLE_AVG_COLUMN_NAME, typeof(Double));
                statTable.Columns.Add(STATS_TABLE_MAX_COLUMN_NAME, typeof(Double));
                statTable.Columns.Add(STATS_TABLE_SUM_COLUMN_NAME, typeof(Double));
                statTable.Columns.Add(percentiles[0] + " %", typeof(Double));
                statTable.Columns.Add(percentiles[1] + " %", typeof(Double));
                statTable.Columns.Add(percentiles[2] + " %", typeof(Double));
                statTable.Columns.Add(STATS_TABLE_DETAILS_COLUMN_NAME, typeof(String));
                fillViewStatisticsTable(statTable, sourceTable, sourceColumnIndexes, percentiles);
                return statTable;
            }

            public static void fillViewStatisticsTable(DataTable statTable, DataTable dtTable, List<int> sourceColumnIndexes, double[] percentiles)
            {
                if (statTable == null || statTable.Columns.Count < 4)
                    return;
                if (dtTable == null || sourceColumnIndexes == null)
                    return;
                int dataIndex = statTable.Columns.IndexOf(STATS_TABLE_DATA_COLUMN_NAME);
                int minIndex = statTable.Columns.IndexOf(STATS_TABLE_MIN_COLUMN_NAME);
                int avgIndex = statTable.Columns.IndexOf(STATS_TABLE_AVG_COLUMN_NAME);
                int maxIndex = statTable.Columns.IndexOf(STATS_TABLE_MAX_COLUMN_NAME);
                int sumIndex = statTable.Columns.IndexOf(STATS_TABLE_SUM_COLUMN_NAME);
                int detailsIndex = statTable.Columns.IndexOf(STATS_TABLE_DETAILS_COLUMN_NAME);

                int firstPercentileIndex = statTable.Columns.IndexOf(percentiles[0] + " %");
                int secondPercentileIndex = statTable.Columns.IndexOf(percentiles[1] + " %");
                int thirdPercentileIndex = statTable.Columns.IndexOf(percentiles[2] + " %");
                if (dataIndex == -1 || minIndex == -1 || avgIndex == -1 || maxIndex == -1 || detailsIndex == -1
                    || firstPercentileIndex == -1 || secondPercentileIndex == -1 || thirdPercentileIndex == -1)
                {
                    return;
                }
                for (int i = 0; i < sourceColumnIndexes.Count; i++)
                {
                    List<double> numericValuesByColumn = getNumericValuesFromColumn(dtTable, sourceColumnIndexes[i]);

                    DataRow statTableRow = statTable.NewRow();
                    statTableRow[dataIndex] = dtTable.TableName + "_" + dtTable.Columns[sourceColumnIndexes[i]].ColumnName;
                    statTableRow[detailsIndex] = numericValuesByColumn.Count + " out of " + dtTable.Rows.Count + " rows had valid data.";
                    statTable.Rows.Add(statTableRow);

                    if (numericValuesByColumn.Count == 0)
                    {
                        continue;
                    }
                    double sum = 0;
                    double min = double.MaxValue;
                    double max = double.MinValue;
                    foreach (double value in numericValuesByColumn)
                    {
                        sum += value;
                        if (min > value)
                        {
                            min = value;
                        }
                        if (max < value)
                        {
                            max = value;
                        }
                    }
                    statTableRow[minIndex] = Math.Round(min, 2);
                    statTableRow[avgIndex] = Math.Round(sum / numericValuesByColumn.Count, 2);
                    statTableRow[maxIndex] = Math.Round(max, 2);
                    statTableRow[sumIndex] = Math.Round(sum, 2);
                    numericValuesByColumn.Sort();
                    statTableRow[firstPercentileIndex] = OverallTools.ResultFunctions.getLevelValue(numericValuesByColumn, percentiles[0]);
                    statTableRow[secondPercentileIndex] = OverallTools.ResultFunctions.getLevelValue(numericValuesByColumn, percentiles[1]);
                    statTableRow[thirdPercentileIndex] = OverallTools.ResultFunctions.getLevelValue(numericValuesByColumn, percentiles[2]);

                }
                statTable.AcceptChanges();
            }

            public static List<double> getNumericValuesFromColumn(DataTable sourceTable, int columnIndex)
            {
                List<double> numericValues = new List<double>();
                if (sourceTable == null || columnIndex < 0 || columnIndex >= sourceTable.Columns.Count
                    || sourceTable.Rows.Count == 0)
                {
                    return numericValues;
                }
                foreach (DataRow row in sourceTable.Rows)
                {
                    double columnValue = 0;
                    if (row[columnIndex] == null || row[columnIndex].ToString() == ""
                        || !Double.TryParse(row[columnIndex].ToString(), out columnValue))
                    {
                        continue;
                    }
                    numericValues.Add(columnValue);
                }
                return numericValues;
            }
            // << Task #10254 Pax2Sim - View statistics option C#14

            // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
            public static DataTable getStatisticTable(DataTable sourceTable,
                int[] targetedColumnIndexesList, double[] distributionLevelsList)
            {
                DataTable statisticTable = new DataTable();

                if (distributionLevelsList == null || distributionLevelsList.Length < 3)
                {
                    return statisticTable;
                }

                statisticTable.Columns.Add(GlobalNames.SUMMARY_TABLE_KPI_ID_COLUMN_NAME, typeof(Int32));
                statisticTable.Columns.Add(GlobalNames.SUMMARY_TABLE_DATA_COLUMN_NAME, typeof(String));
                statisticTable.Columns.Add(GlobalNames.SUMMARY_TABLE_VALUE_COLUMN_NAME, typeof(Double));
                statisticTable.Columns.Add(GlobalNames.SUMMARY_TABLE_MIN_VALUE_COLUMN_NAME, typeof(Double));
                statisticTable.Columns.Add(GlobalNames.SUMMARY_TABLE_AVG_VALUE_COLUMN_NAME, typeof(Double));
                statisticTable.Columns.Add(GlobalNames.SUMMARY_TABLE_MAX_VALUE_COLUMN_NAME, typeof(Double));
                for (int i = 0; i < distributionLevelsList.Length; i++)
                {
                    String maxValueForLevelColumnName = distributionLevelsList[i]
                        + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX;
                    statisticTable.Columns.Add(maxValueForLevelColumnName, typeof(Double));
                }

                addNewStatisticsToStatisticTable(statisticTable, sourceTable,
                    targetedColumnIndexesList, distributionLevelsList);

                return statisticTable;

            }

            public static void addNewStatisticsToStatisticTable(DataTable statisticTable,
                DataTable sourceTable, int[] targetedColumnIndexesList, double[] distributionLevelsList)
            {
                if (statisticTable == null)
                {
                    return;
                }
                if (sourceTable == null)
                {
                    return;
                }
                if (targetedColumnIndexesList == null)
                {
                    return;
                }
                if (distributionLevelsList == null
                    || distributionLevelsList.Length < 3)
                {
                    return;
                }

                int kpiIdColumnIndex = statisticTable.Columns.IndexOf(GlobalNames.SUMMARY_TABLE_KPI_ID_COLUMN_NAME);
                int dataColumnIndex = statisticTable.Columns.IndexOf(GlobalNames.SUMMARY_TABLE_DATA_COLUMN_NAME);
                int totalValueColumnIndex = statisticTable.Columns.IndexOf(GlobalNames.SUMMARY_TABLE_VALUE_COLUMN_NAME);
                int minValueColumnIndex = statisticTable.Columns.IndexOf(GlobalNames.SUMMARY_TABLE_MIN_VALUE_COLUMN_NAME);
                int avgValueColumnIndex = statisticTable.Columns.IndexOf(GlobalNames.SUMMARY_TABLE_AVG_VALUE_COLUMN_NAME);
                int maxValueColumnIndex = statisticTable.Columns.IndexOf(GlobalNames.SUMMARY_TABLE_MAX_VALUE_COLUMN_NAME);
                int level1ValueColumnIndex = statisticTable.Columns.IndexOf(distributionLevelsList[0] + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX);
                int level2ValueColumnIndex = statisticTable.Columns.IndexOf(distributionLevelsList[1] + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX);
                int level3ValueColumnIndex = statisticTable.Columns.IndexOf(distributionLevelsList[2] + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX);

                if (kpiIdColumnIndex == -1 || dataColumnIndex == -1 || totalValueColumnIndex == -1
                    || minValueColumnIndex == -1 || avgValueColumnIndex == -1 || maxValueColumnIndex == -1
                    || level1ValueColumnIndex == -1 || level2ValueColumnIndex == -1 || level3ValueColumnIndex == -1)
                {
                    return;
                }

                double firstDistributionLevel = distributionLevelsList[0];
                double secondDistributionLevel = distributionLevelsList[1];
                double thirdDistributionLevel = distributionLevelsList[2];

                for (int i = 0; i < targetedColumnIndexesList.Length; i++)
                {
                    Double[] tdValues = GetStatColumn(sourceTable, targetedColumnIndexesList[i]);
                    if (tdValues == null)
                        continue;

                    DataRow drRow = statisticTable.NewRow();

                    int kpiId = statisticTable.Rows.Count + 1;
                    String kpiName = sourceTable.TableName + "_" + sourceTable.Columns[targetedColumnIndexesList[i]].ColumnName;
                    double minValue = Math.Round(tdValues[0], 2);
                    double avgValue = Math.Round(tdValues[2], 2);
                    double maxValue = Math.Round(tdValues[1], 2);

                    drRow[kpiIdColumnIndex] = kpiId;
                    drRow[dataColumnIndex] = kpiName;
                    drRow[minValueColumnIndex] = minValue;
                    drRow[avgValueColumnIndex] = avgValue;
                    drRow[maxValueColumnIndex] = maxValue;

                    if (targetedColumnIndexesList[i] < sourceTable.Columns.Count
                        && targetedColumnIndexesList[i] >= 0)
                    {
                        Double sum = 0;
                        for (int j = 0; j < sourceTable.Rows.Count; j++)
                        {
                            sum += FonctionsType.getDouble(sourceTable.Rows[j][targetedColumnIndexesList[i]],
                                                    sourceTable.Columns[targetedColumnIndexesList[i]].DataType);
                        }
                        drRow[totalValueColumnIndex] = Math.Round(sum, 2);
                    }

                    //drRow[level1ValueColumnIndex] = "";
                    //drRow[level2ValueColumnIndex] = "";
                    //drRow[level3ValueColumnIndex] = "";

                    statisticTable.Rows.Add(drRow);
                }
                statisticTable.AcceptChanges();
            }
            // << Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
            #endregion

            #region Fonction qui initialize la table avec des données neutres.

            public static void InitializeValues(DataTable table)
            {
                InitializeValues(table, null);
            }
            /// <summary>
            /// Permet de mettre à jour la table pour éviter que certaines colonnes n'aient des valeurs à NULL 
            /// Les types primaires (int / double / datetime) ne peuvent avoir ce genre de valeur.
            /// </summary>
            /// <param name="table"></param>
            public static void InitializeValues(DataTable table, Object objValue)
            {
                if (table == null)
                    return;
                Object[] DefaultOject = new Object[table.Columns.Count];
                bool[] Initialize = new bool[table.Columns.Count];
                int i;
                for (i = 0; i < table.Columns.Count; i++)
                {
                    // >> Task #13880 Various UI improvements and fixes                    
                    if (GlobalNames.planningTableNamesList.Contains(table.TableName)
                        && i == 0)
                    {
                        continue;
                    }
                    // << Task #13880 Various UI improvements and fixes

                    Type type = table.Columns[i].DataType;
                    if ((type == typeof(String)) ||
                       (type == typeof(string)))
                    {
                        if (objValue != null)
                            DefaultOject[i] = objValue.ToString();
                        else
                            DefaultOject[i] = "";
                        Initialize[i] = true;
                        continue;
                    }
                    else if ((type == typeof(int)) ||
                       (type == typeof(Int32)) ||
                       (type == typeof(Int64)) ||
                       (type == typeof(Int16)))
                    {
                        if (objValue != null)
                            DefaultOject[i] = FonctionsType.getInt(objValue);
                        else
                            DefaultOject[i] = 0;
                        Initialize[i] = true;
                        continue;
                    }
                    else if ((type == typeof(float)) ||
                             (type == typeof(Double)) ||
                             (type == typeof(double)))
                    {
                        if (objValue != null)
                            DefaultOject[i] = FonctionsType.getDouble(objValue);
                        else
                            DefaultOject[i] = 0.0;
                        Initialize[i] = true;
                        continue;
                    }
                    else if ((type == typeof(DateTime)))
                    {
                        if (objValue != null)
                            DefaultOject[i] = FonctionsType.getDate(objValue);
                        else
                            DefaultOject[i] = DateTime.Now;
                        Initialize[i] = true;
                        continue;
                    }
                    else if ((type == typeof(TimeSpan)))
                    {
                        if (objValue != null)
                            DefaultOject[i] = FonctionsType.getTime(objValue);
                        else
                            DefaultOject[i] = DateTime.Now.TimeOfDay;
                        Initialize[i] = true;
                        continue;
                    }
                    /*else if ((type == typeof(TimeSpanCulture)))
                    {
                        DefaultOject[i] = new TimeSpanCulture(DateTime.Now.TimeOfDay);
                        Initialize[i] = true;
                        continue;
                    }*/
                    if ((type == typeof(bool)) ||
                       (type == typeof(Boolean)))
                    {
                        if (objValue != null)
                            DefaultOject[i] = FonctionsType.getBoolean(objValue);
                        else
                            DefaultOject[i] = false;
                        Initialize[i] = true;
                        continue;
                    }
                    Initialize[i] = false;
                }
                for (i = 0; i < table.Rows.Count; i++)
                {
                    for (int j = 0; j < table.Columns.Count; j++)
                    {

                        if ((table.Rows[i][j].ToString() == "") && Initialize[j])
                        {
                            table.Rows[i][j] = DefaultOject[j];
                        }
                    }
                }
                table.AcceptChanges();
            }
            #endregion

            #region Fonctions pour la gestion des distributions.

            /// <summary>
            /// Permet de récupérer les noms des différentes probability profile présentes dans la table passée en paramètre.
            /// </summary>
            /// <param name="dtTable"></param>
            /// <returns></returns>
            public static ArrayList getDistributions(DataTable dtTable)
            {
                ArrayList list = new ArrayList();
                for (int i = 0; i < dtTable.Columns.Count; i++)
                {
                    String ColumnName = ((DataColumn)dtTable.Columns[i]).ColumnName;
                    if (ColumnName.LastIndexOf("Value") == (ColumnName.Length - 5))
                        continue;
                    if (ColumnName.LastIndexOf("Frequency") == -1)
                        continue;
                    String DistributionName = ColumnName.Substring(0, ColumnName.LastIndexOf("Frequency") - 1);
                    list.Add(DistributionName);
                }
                return list;
            }
            #endregion

            /// <summary>
            /// Faire en sorte que la table trolley ait sa première colonne (NBBags) valide par rapport à la
            /// table NBBags (si l'utilisateur à ajouter ou supprimer des lignes dans NBBags, il faut modifier
            /// la table trolley).
            /// </summary>
            /// <param name="dtNbBagTable"></param>
            /// <param name="dtTrolleyTable"></param>
            public static void UpdateTrolleyTable(DataTable dtNbBagTable, DataTable dtTrolleyTable)
            {
                if ((dtNbBagTable == null) || (dtTrolleyTable == null))
                    return;
                int[] iNbBagValue = new int[dtNbBagTable.Rows.Count];
                try
                {
                    for (int i = 0; i < dtNbBagTable.Rows.Count; i++)
                        iNbBagValue[i] = (int)dtNbBagTable.Rows[i][0];
                }
                catch (Exception exc)
                {
                    OverallTools.ExternFunctions.PrintLogFile("Except02021: UpdateTrolleyTable throw an exception: " + exc.Message);
                    return;
                }
                int j;
                for (int i = 0; i < iNbBagValue.Length; i++)
                {
                    int[] iIndex = OverallTools.DataFunctions.indexLignes(dtTrolleyTable, 0, i.ToString());

                    //Dans le cas où l'on doit remettre à jour le nombre de 
                    //ligne contenue dans la table trolley

                    //-----Première chose on supprime les lignes qui ne cadrent pas avec le contenu de cette table.

                    if (iIndex != null)
                    {
                        ArrayList alLigneSuppr = new ArrayList();
                        for (j = 0; j < iIndex.Length; j++)
                        {
                            int iNbTrolley = (int)dtTrolleyTable.Rows[iIndex[j]][1];
                            if ((iNbTrolley < 0) || (iNbTrolley > 2))
                                alLigneSuppr.Add(iIndex[j]);
                        }
                        if (alLigneSuppr.Count > 0)
                        {
                            for (j = 0; j < alLigneSuppr.Count; j++)
                            {
                                dtTrolleyTable.Rows.RemoveAt(((int)alLigneSuppr[j]) - j);
                            }
                        }
                    }

                    iIndex = OverallTools.DataFunctions.indexLignes(dtTrolleyTable, 0, i.ToString());

                    bool[] bVerif = new bool[] { false, false, false };
                    if (iIndex != null)
                    {
                        for (j = 0; j < 3; j++)
                        {
                            if (j >= iIndex.Length)
                                break;
                            int iNbTrolley = (int)dtTrolleyTable.Rows[iIndex[j]][1];
                            if ((iNbTrolley < 0) || (iNbTrolley > 2))
                                break;
                            if (bVerif[iNbTrolley])
                                break;
                            bVerif[iNbTrolley] = true;
                        }
                        if (j == 3)
                        {
                            for (j = 2; j < dtTrolleyTable.Columns.Count; j++)
                            {
                                Double dSum = 0;
                                for (int k = 0; k < 3; k++)
                                {
                                    if (dtTrolleyTable.Rows[iIndex[k]][j].ToString().Length == 0)
                                        dtTrolleyTable.Rows[iIndex[k]][j] = 0;
                                    dSum += FonctionsType.getDouble(dtTrolleyTable.Rows[iIndex[k]][j]);

                                }
                                if (dSum != 100)
                                {
                                    dtTrolleyTable.Rows[iIndex[0]][j] = 100;
                                }
                                /*for (int k = 0; k < 3; k++)
                                {
                                    if (dtTrolleyTable.Rows[iIndex[k]][j].ToString().Length == 0)
                                        if (iIndex[k] == 0)
                                            dtTrolleyTable.Rows[iIndex[k]][j] = 100;
                                        else
                                            dtTrolleyTable.Rows[iIndex[k]][j] = 0;
                                }*/
                            }
                            continue;
                        }
                    }
                    if (iIndex == null)
                    {
                        DataRow newRow = dtTrolleyTable.NewRow();
                        newRow[0] = i;
                        newRow[1] = 0;
                        for (int k = 2; k < dtTrolleyTable.Columns.Count; k++)
                            newRow[k] = 100;
                        dtTrolleyTable.Rows.Add(newRow);
                        bVerif[0] = true;
                    }
                    for (j = 0; j < 3; j++)
                    {
                        if (bVerif[j])
                            continue;
                        DataRow newRow = dtTrolleyTable.NewRow();
                        newRow[0] = i;
                        newRow[1] = j;
                        for (int k = 2; k < dtTrolleyTable.Columns.Count; k++)
                            newRow[k] = 0;
                        dtTrolleyTable.Rows.Add(newRow);
                    }
                }
                DataView dgSort = new DataView(dtTrolleyTable, "", dtTrolleyTable.Columns[0].ColumnName + "," + dtTrolleyTable.Columns[1].ColumnName,
                                    DataViewRowState.CurrentRows);
                DataTable dtTmp = dgSort.ToTable();
                dtTrolleyTable.Rows.Clear();
                foreach (DataRow ligne in dtTmp.Rows)
                {
                    dtTrolleyTable.Rows.Add(ligne.ItemArray);
                }
            }

            /// <summary>
            /// Fonction pour initialiser une table de type transfer distribution.
            /// </summary>
            /// <param name="Table"></param>
            public static void InitTranfertDistri(DataTable Table)
            {
                for (int i = 0; i < Table.Rows.Count; i++)
                {
                    DataRow row = Table.Rows[i];

                    // On fait la somme des elements de la ligne
                    double sum = 0;
                    for (int j = 1; j < Table.Columns.Count; j++)
                    {
                        sum += FonctionsType.getDouble(Table.Rows[i][j], Table.Rows[i][j].GetType());
                    }

                    // Si la somme fait 0, on initialise à 100
                    if (sum == 0)
                    {
                        int line = OverallTools.DataFunctions.indexLigne(Table, 0, row[0].ToString());
                        if (line == -1)
                            continue;
                        Table.Rows[line][row[0].ToString()] = 100;
                    }

                }

            }

            #region Fonction pour la mise à jour de la table CI opening.
            /// <summary>
            /// Fonction qui permet de recalculer le contenu de la table CI opening à partir de la 
            /// table générée automatiquement pour l'allocation.
            /// </summary>
            /// <param name="Alloc_CITable">La table d'allocation.</param>
            /// <param name="Opening_CITable">La table que l'on veut mettre à jour.</param>
            public static void OpeningCIAllocation(DataTable Alloc_CITable, DataTable Opening_CITable)
            {
                if (Alloc_CITable.Columns.Count != Opening_CITable.Columns.Count)
                    return;
                if (Alloc_CITable.Rows.Count == 0)
                {
                    Opening_CITable.Rows.Clear();
                    return;
                }
                DateTime dtStartAlloc = (DateTime)Alloc_CITable.Rows[0][0];
                DateTime dtEndAlloc = (DateTime)Alloc_CITable.Rows[Alloc_CITable.Rows.Count - 1][0];
                DateTime dtStartOpening = DateTime.MaxValue;
                DateTime dtEndOpening = DateTime.MinValue;
                if (Opening_CITable.Rows.Count != 0)
                {
                    Opening_CITable.Rows.Clear();
                }
                int i;
                for (i = 0; i < Opening_CITable.Rows.Count; i++)
                {
                    //Suppression des parties qui ne doivent plus apparaitre dans la table
                    if ((((DateTime)Opening_CITable.Rows[i][0]) < dtStartAlloc) ||
                        (((DateTime)Opening_CITable.Rows[i][0]) > dtEndAlloc))
                    {
                        Opening_CITable.Rows.RemoveAt(i);
                        i--;
                    }
                }
                if (Alloc_CITable.Rows.Count == Opening_CITable.Rows.Count)
                    return;
                DateTime newTime;
                int[] tiIndex = new int[Alloc_CITable.Columns.Count - 1];
                for (i = 1; i < Opening_CITable.Columns.Count; i++)
                {
                    tiIndex[i - 1] = Alloc_CITable.Columns.IndexOf(Opening_CITable.Columns[i].ColumnName);
                }
                for (i = 0; i < Alloc_CITable.Rows.Count; i++)
                {
                    newTime = (DateTime)Alloc_CITable.Rows[i][0];
                    if ((newTime < dtStartOpening) || (newTime > dtEndOpening))
                    {
                        DataRow newLine = Opening_CITable.NewRow();
                        newLine[0] = newTime;
                        for (int j = 1; j < Opening_CITable.Columns.Count; j++)
                        {
                            if (Alloc_CITable.Rows[i][tiIndex[j - 1]].ToString().Length > 0)
                            {
                                newLine[j] = true;
                            }
                            else
                            {
                                newLine[j] = false;
                            }

                        }
                        Opening_CITable.Rows.Add(newLine);
                    }
                }
            }
            #endregion

            #region Fonction pour concaténer les colonnes d'une table à une seconde table.
            public static bool ConcateneTable(DataTable dtTarget, DataTable dtContent, String[] tsColumns, String sEntete)
            {
                int[] tiIndexColumns = new int[tsColumns.Length];
                if ((dtTarget == null) || (dtContent == null))
                    return false;
                if ((dtTarget.Rows.Count != dtContent.Rows.Count) && (dtTarget.Rows.Count != 0))
                    return false;
                for (int i = 0; i < tsColumns.Length; i++)
                {
                    String sTmp = tsColumns[i];
                    if (!dtContent.Columns.Contains(sTmp))
                        return false;
                    if (dtTarget.Columns.Contains(sEntete + sTmp))
                        return false;
                    tiIndexColumns[i] = dtContent.Columns.IndexOf(sTmp);
                }
                return ConcateneTable(dtTarget, dtContent, tiIndexColumns, sEntete);
            }
            public static bool ConcateneTable(DataTable dtTarget, DataTable dtContent, int[] tiIndexColumns, String sEntete)
            {
                if ((dtTarget == null) || (dtContent == null))
                    return false;
                if ((dtTarget.Rows.Count != dtContent.Rows.Count) && (dtTarget.Rows.Count != 0))
                    return false;
                for (int i = 0; i < tiIndexColumns.Length; i++)
                {
                    if (tiIndexColumns[i] > dtContent.Columns.Count)
                        return false;
                    if (dtTarget.Columns.Contains(sEntete + dtContent.Columns[i].ColumnName))
                        return false;
                }
                try
                {
                    bool bAddValue = (dtTarget.Rows.Count == 0);
                    for (int i = 0; i < tiIndexColumns.Length; i++)
                    {
                        dtTarget.Columns.Add(sEntete + dtContent.Columns[tiIndexColumns[i]].ColumnName, dtContent.Columns[tiIndexColumns[i]].DataType);

                        int iIndex = dtTarget.Columns.Count - 1;
                        for (int j = 0; j < dtContent.Rows.Count; j++)
                        {
                            if (bAddValue)
                                dtTarget.Rows.Add(new Object[] { dtContent.Rows[j][tiIndexColumns[i]] });
                            else
                                dtTarget.Rows[j][iIndex] = dtContent.Rows[j][tiIndexColumns[i]];
                        }
                        bAddValue = false;
                    }
                }
                catch (Exception exc)
                {
                    OverallTools.ExternFunctions.PrintLogFile("Except02022: ConcateneTable throw an exception: " + exc.Message);
                    return false;
                }
                return true;
            }
            #endregion

            #region Fonction pour trier les colonnes d'une table.


            public static bool SortColumns(DataTable dtTable, int iNbIgnoredColumns)
            {
                if (dtTable.Columns.Count == 0)
                    return false;
                if (dtTable.Columns.Count < iNbIgnoredColumns)
                    return false;
                String[] tsNewOrder = new string[dtTable.Columns.Count];
                ArrayList alNewOrder = new ArrayList();
                int i;
                for (i = 0; i < dtTable.Columns.Count; i++)
                {
                    if (i < iNbIgnoredColumns)
                        tsNewOrder[i] = dtTable.Columns[i].ColumnName;
                    else
                        alNewOrder.Add(dtTable.Columns[i].ColumnName);
                }

                alNewOrder.Sort(new FonctionUtiles.ColumnsComparer());
                for (i = iNbIgnoredColumns; i < dtTable.Columns.Count; i++)
                    tsNewOrder[i] = (String)alNewOrder[i - iNbIgnoredColumns];
                return SortColumns(dtTable, tsNewOrder);
            }
            public static bool SortColumns(DataTable dtTable, String[] tsNewOrder)
            {
                if (dtTable.Columns.Count != tsNewOrder.Length)
                    return false;
                Type[] ttTypes = new Type[tsNewOrder.Length];
                int[] tiIndex = new int[tsNewOrder.Length];
                int i;
                for (i = 0; i < tsNewOrder.Length; i++)
                {
                    if (!dtTable.Columns.Contains(tsNewOrder[i]))
                        return false;
                    ttTypes[i] = dtTable.Columns[tsNewOrder[i]].DataType;
                    tiIndex[i] = dtTable.Columns.IndexOf(tsNewOrder[i]);
                }
                DataTable dtTmp = dtTable.Copy();
                String[] PrimaryKey = new string[dtTable.PrimaryKey.Length];
                for (i = 0; i < PrimaryKey.Length; i++)
                {
                    PrimaryKey[i] = dtTable.PrimaryKey[i].ColumnName;
                }
                dtTable.PrimaryKey = null;
                dtTable.Columns.Clear();
                dtTable.Rows.Clear();
                for (i = 0; i < tsNewOrder.Length; i++)
                {
                    dtTable.Columns.Add(tsNewOrder[i], ttTypes[i]);
                }
                DataColumn[] PrimaryKeyColumn = new DataColumn[PrimaryKey.Length];
                for (i = 0; i < PrimaryKey.Length; i++)
                {
                    PrimaryKeyColumn[i] = dtTable.Columns[PrimaryKey[i]];
                }
                dtTable.PrimaryKey = PrimaryKeyColumn;
                for (int j = 0; j < dtTmp.Rows.Count; j++)
                {
                    DataRow drNewLine = dtTable.NewRow();
                    for (i = 0; i < tsNewOrder.Length; i++)
                    {
                        drNewLine[i] = dtTmp.Rows[j][tiIndex[i]];
                    }
                    dtTable.Rows.Add(drNewLine);
                }
                dtTable.AcceptChanges();
                return true;
            }


            private static bool SortColumns(DataTable dtFlightCategorie, DataTable dtTable)
            {
                String[] Columns = new String[dtFlightCategorie.Rows.Count + 1];
                Columns[0] = GestionDonneesHUB2SIM.ListeEntete_FP_FlightCategoriesTable[0];
                for (int i = 0; i < dtFlightCategorie.Rows.Count; i++)
                {
                    Columns[i + 1] = dtFlightCategorie.Rows[i][0].ToString();
                    if (!dtTable.Columns.Contains(Columns[i + 1]))
                        return false;
                }
                return SortColumns(dtTable, Columns);
            }
            #endregion

            #region static DataTable TransposeTable(DataTable dtTable) Effectue le calcul de la transposée.
            public static DataTable TransposeTable(DataTable dtTable)
            {
                DataTable dtResult = new DataTable(dtTable.TableName);
                dtResult.Columns.Add(dtTable.Columns[0].ColumnName, typeof(String));
                int i;
                for (i = 1; i < dtTable.Columns.Count; i++)
                {
                    dtResult.Rows.Add(new Object[] { dtTable.Columns[i].ColumnName });
                }
                foreach (DataRow drRow in dtTable.Columns)
                {
                    dtResult.Columns.Add(drRow[0].ToString(), typeof(String));
                    int iIndexColumn = dtResult.Columns.Count - 1;
                    for (i = 1; i < dtTable.Columns.Count; i++)
                    {
                        dtResult.Rows[i - 1][iIndexColumn] = drRow[i];
                    }
                }
                return dtResult;
            }
            #endregion

            internal static List<String> getOrder(DataTable dtTable, String sColumn)
            {
                if (dtTable == null)
                    return null;
                if (!dtTable.Columns.Contains(sColumn))
                    return null;
                return getOrder(dtTable, dtTable.Columns.IndexOf(sColumn));
            }
            internal static List<String> getOrder(DataTable dtTable, int iColumn)
            {
                if (dtTable == null)
                    return null;
                if (dtTable.Rows.Count < iColumn)
                    return null;
                List<String> lsOrder = new List<string>();
                foreach (DataRow drRow in dtTable.Rows)
                {
                    String sValue = drRow[iColumn].ToString();
                    if (lsOrder.Contains(sValue))
                        continue;
                    lsOrder.Add(sValue);
                }
                return lsOrder;
            }

            /// <summary>
            /// Fonction pour ajouter une ligne dans les tables Airline Code, Airport et Flight Category.
            /// (La fonction ne fait qu'ajouter une ligne dans la table, attention à bien remettre jour les 
            /// tables qui en dependent)
            /// </summary>
            internal static void AddLine_FP(DataTable laTable, String clef, String description, String val2, bool edit)
            {
                if (!edit)
                {
                    DataRow ligne = laTable.NewRow();
                    ligne[0] = clef;
                    ligne[1] = description;
                    if (laTable.Columns.Count == 3)
                        ligne[2] = val2;
                    laTable.Rows.Add(ligne);
                }
                else // on cherche la ligne et on l'édit
                {
                    foreach (DataRow ligne in laTable.Rows)
                    {
                        if (clef == ligne.ItemArray[0].ToString())
                        {
                            ligne.BeginEdit();
                            ligne[1] = description;
                            if (laTable.Columns.Count == 3)
                                ligne[2] = val2;
                        }
                    }
                }
                laTable.AcceptChanges();
            }

            /// <summary>
            /// Fonction pour ajouter une ligne dans la table Aircraft type
            /// </summary>
            internal static void AddLine_FP_Aircraft(DataTable laTable, String clef, String val1, String val2, String val3, String val4, String val5, bool edit)
            {
                // Si la colonne 2 est de type int on parse la variable
                int value = 0;
                bool isInt = false;
                if ((laTable.Columns[1].DataType == typeof(Int32)) ||
                        (laTable.Columns[1].DataType == typeof(Int16)) ||
                        (laTable.Columns[1].DataType == typeof(Int64)) ||
                        (laTable.Columns[1].DataType == typeof(int)))
                {
                    isInt = true;
                    if (val1 != null && val1 != "")
                        Int32.TryParse(val1, out value);
                    else
                        value = 0;
                }

                if (!edit)
                {
                    DataRow ligne = laTable.NewRow();
                    ligne[0] = clef;
                    if (isInt)
                        ligne[1] = value;
                    else
                        ligne[1] = val1;
                    ligne[2] = val2;
                    ligne[3] = val3;
                    ligne[4] = val4;
                    ligne[5] = val5;

                    laTable.Rows.Add(ligne);
                }
                else
                {
                    foreach (DataRow ligne in laTable.Rows)
                    {
                        if (clef == ligne.ItemArray[0].ToString())
                        {
                            ligne.BeginEdit();
                            if (isInt)
                                ligne[1] = value;
                            else
                                ligne[1] = val1;
                            ligne[2] = val2;
                            ligne[3] = val3;
                            ligne[4] = val4;
                            ligne[5] = val5;
                        }
                    }
                }
                laTable.AcceptChanges();
            }

            // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent

            /// <summary>
            /// The function takes an ArrayList of objects and returns a list of double. 
            /// It succeeds only if every object from the source list can be parsed into a Double.
            /// </summary>
            /// <param name="sourceList"></param>
            /// <param name="resultList"></param>
            /// <returns></returns>
            internal static bool fromArrayListToListOfDouble(ArrayList sourceList, out List<double> resultList)
            {
                resultList = new List<double>();

                if (sourceList == null)
                    return false;

                for (int i = 0; i < sourceList.Count; i++)
                {
                    double value = 0;
                    if (Double.TryParse(sourceList[i].ToString(), out value))
                    {
                        resultList.Add(value);
                    }
                    else
                    {
                        return false;
                    }
                }
                return true;
            }

            /// <summary>
            /// The function returns a list of double formed from the values found in the given table's column.
            /// It succeeds only if every value from the column could be parsed into a double.
            /// </summary>
            /// <param name="sourceTable"></param>
            /// <param name="columnName"></param>
            /// <param name="resultList"></param>
            /// <returns></returns>
            internal static bool fromTableColumnToListOfDouble(DataTable sourceTable, String columnName,
                out List<double> resultList)
            {
                resultList = new List<double>();

                if (sourceTable == null)
                    return false;

                int sourceColumnIndex = sourceTable.Columns.IndexOf(columnName);
                if (sourceColumnIndex == -1)
                    return false;

                foreach (DataRow row in sourceTable.Rows)
                {
                    double value = 0;
                    if (Double.TryParse(row[sourceColumnIndex].ToString(), out value))
                    {
                        resultList.Add(value);
                    }
                    /*else  // >> Pax trace analysis - Sum and BagPlan_2.txt
                    {
                        return false;
                    }*/
                }
                return true;
            }

            /// <summary>
            /// Sums the table's columns indicated by name and places the result from each row into a list of doubles.
            /// It succeeds only if all the values can be parsed into a double.
            /// </summary>
            /// <param name="sourceTable"></param>
            /// <param name="columnNameList"></param>
            /// <param name="resultList"></param>
            /// <returns></returns>
            internal static bool getSumOfTableColumnsAsListOfDouble(DataTable sourceTable,
                List<String> columnNameList, out List<double> resultList)
            {
                resultList = new List<double>();

                if (sourceTable == null)
                    return false;

                List<int> columnIndexes = new List<int>();

                for (int i = 0; i < columnNameList.Count; i++)
                {
                    String columnName = columnNameList[i].ToString();
                    int columnIndex = sourceTable.Columns.IndexOf(columnName);
                    if (columnIndex == -1)
                        return false;
                    else
                        columnIndexes.Add(columnIndex);
                }

                foreach (DataRow row in sourceTable.Rows)
                {
                    double value = 0;
                    double rowSum = 0;

                    for (int i = 0; i < columnIndexes.Count; i++)
                    {
                        int index = (int)columnIndexes[i];
                        if (Double.TryParse(row[index].ToString(), out value))
                        {
                            rowSum += value;
                        }
                        else
                        {
                            return false;
                        }
                    }
                    resultList.Add(rowSum);
                }

                return true;
            }
            // << Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent

            // >> Departure_Statistics, Arrival_Statistics segregate by Airline, Flight category            
            internal static List<string> getUniqueValuesFromColumn(DataTable sourceTable, string columnName)
            {
                List<string> values = new List<string>();
                if (sourceTable == null || sourceTable.Columns == null)
                {
                    return values;
                }
                int sourceColumnIndex = sourceTable.Columns.IndexOf(columnName);
                if (sourceColumnIndex == -1)
                {
                    return values;
                }
                foreach (DataRow row in sourceTable.Rows)
                {
                    if (row[sourceColumnIndex] == null)
                    {
                        continue;
                    }
                    string rowValue = row[sourceColumnIndex].ToString();
                    if (!values.Contains(rowValue))
                    {
                        values.Add(rowValue);
                    }
                }
                return values;
            }
            // << Departure_Statistics, Arrival_Statistics segregate by Airline, Flight category
        }
        #endregion

        #region La classe ImageFunctions
        public class ImageFunctions
        {
            /// <summary>
            /// Permet de calculer les positions des points de départ et d'arrivée pour les fleches en fonction de la position des images
            /// qui sont reliées.
            /// </summary>
            /// <param name="pic1"></param>
            /// <param name="pic2"></param>
            /// <param name="start"></param>
            /// <param name="end"></param>
            public static void PointToPoint(PictureBox pic1, PictureBox pic2, out Point start, out Point end)
            {
                Point center1 = new Point(pic1.Location.X + pic1.Size.Width / 2, pic1.Location.Y + pic1.Size.Height / 2);
                Point center2 = new Point(pic2.Location.X + pic2.Size.Width / 2, pic2.Location.Y + pic2.Size.Height / 2);
                Point spt1, spt2, ept1, ept2;

                Point pt1_1 = new Point(pic1.Location.X + pic1.Size.Width / 2, pic1.Location.Y);
                Point pt2_1 = new Point(pic1.Location.X + pic1.Size.Width, pic1.Location.Y + pic1.Size.Height / 2);
                Point pt3_1 = new Point(pt1_1.X, pic1.Location.Y + pic1.Size.Height);
                Point pt4_1 = new Point(pic1.Location.X, pt2_1.Y);

                Point pt1_2 = new Point(pic2.Location.X + pic2.Size.Width / 2, pic2.Location.Y);
                Point pt2_2 = new Point(pic2.Location.X + pic2.Size.Width, pic2.Location.Y + pic2.Size.Height / 2);
                Point pt3_2 = new Point(pt1_2.X, pic2.Location.Y + pic2.Size.Height);
                Point pt4_2 = new Point(pic2.Location.X, pt2_2.Y);
                if (center1.X > center2.X)
                {
                    if (center1.Y > center2.Y)
                    {
                        spt1 = pt1_1;
                        spt2 = pt4_1;
                        ept1 = pt2_2;
                        ept2 = pt3_2;
                    }
                    else
                    {
                        spt1 = pt3_1;
                        spt2 = pt4_1;
                        ept1 = pt1_2;
                        ept2 = pt2_2;
                    }
                }
                else
                {
                    if (center1.Y > center2.Y)
                    {
                        spt1 = pt1_1;
                        spt2 = pt2_1;
                        ept1 = pt3_2;
                        ept2 = pt4_2;
                    }
                    else
                    {
                        spt1 = pt3_1;
                        spt2 = pt2_1;
                        ept1 = pt1_2;
                        ept2 = pt4_2;
                    }
                }

                Double dist1 = Distance(spt1, ept1);
                Double dist2 = Distance(spt1, ept2);
                Double dist3 = Distance(spt2, ept1);
                Double dist4 = Distance(spt2, ept2);
                Double min = Math.Min(Math.Min(dist1, dist2), Math.Min(dist3, dist4));
                if (min == dist1)
                {
                    start = spt1;
                    end = ept1;
                }
                else if (min == dist2)
                {
                    start = spt1;
                    end = ept2;
                }
                else if (min == dist3)
                {
                    start = spt2;
                    end = ept1;
                }
                else if (min == dist4)
                {
                    start = spt2;
                    end = ept2;
                }
                else
                {
                    start = new Point(0, 0);
                    end = new Point(0, 0);
                }
            }

            /// <summary>
            /// Calcul la distance enter 2 points. (utilisation du théorème de Pythagore.)
            /// </summary>
            /// <param name="pt1"></param>
            /// <param name="pt2"></param>
            /// <returns></returns>
            public static double Distance(Point pt1, Point pt2)
            {
                Double X = Math.Pow(pt1.X - pt2.X, 2.0);
                Double Y = Math.Pow(pt1.Y - pt2.Y, 2.0);
                return Math.Pow(X + Y, 0.5);
            }

            public enum EnumIcons { Exclamation, Asterisk, Error, Information, Question, Warning };

            public static void SetIconPicture(PictureBox pb, EnumIcons icon, double scale)
            {
                Icon ico;
                switch (icon)
                {
                    case EnumIcons.Asterisk: ico = SystemIcons.Asterisk; break;
                    case EnumIcons.Exclamation: ico = SystemIcons.Exclamation; break;
                    case EnumIcons.Error: ico = SystemIcons.Error; break;
                    case EnumIcons.Information: ico = SystemIcons.Information; break;
                    case EnumIcons.Question: ico = SystemIcons.Question; break;
                    case EnumIcons.Warning: ico = SystemIcons.Warning; break;
                    default: return;
                }
                pb.Image = ico.ToBitmap();
                pb.SizeMode = PictureBoxSizeMode.StretchImage;
                pb.Size = new System.Drawing.Size((int)(pb.Size.Width * scale), (int)(pb.Size.Height * scale * 2)); //Scale(0.3f);
            }
        }
        #endregion

        #region La classe TableCheck
        public class TableCheck
        {

            /// <summary>
            /// Enum that contains specific analyse to be done on a table.
            /// </summary>
            public enum eTypeAnalyze
            {
                None, LoadFactorArrival,
                LoadFactorDeparture,
                CapacityOfQueue,
                PassportAllocation,
                SecurityAllocation,
                TransferAllocation,
                ProcessTable,
                AnimatedQueues,
                FPLinksTable,
                TransfertDistribution,
                SaturationTable     // << Task #9412 Pax2Sim - Scenario parameters files - Settings and OpeningOnSaturation
            };

            #region Les variables de la classe.

            /// <summary>
            /// Name of the table that should be checked by the class.
            /// </summary>
            private string sTable_;
            /// <summary>
            /// The list of columns that should contains date time informations.
            /// </summary>
            private String[] tsDateColumns_;
            /// <summary>
            /// The 3 foloowing variables are used to linked columns between the content of the table and the content of another table.
            /// tsTableLinkedColumns_ will contains the names of the columns in the table to check.
            /// \ref tsTableLinkedTable_ will contain the names of the tables were the values should coming from.
            /// </summary>
            private String[] tsTableLinkedColumns_;
            /// <summary>
            /// See \ref tsTableLinkedColumns_
            /// </summary>
            private String[] tsTableLinkedTable_;
            /// <summary>
            /// See \ref tsTableLinkedColumns_
            /// </summary>
            private bool[] tbTableLinkedWarn_ = null;

            /// <summary>
            /// The list of columns that should contains integer (or Double) that should always be positive.
            /// </summary>
            private String[] tsPositiveDataColumns_;

            /// <summary>
            /// The different columns that contains distribution. The sum of these columns should be 100.
            /// </summary>
            private String[] tsDistribColumns_;


            /// <summary>
            /// Les 3 variables suivantes permettent de gérer les colonnes qui contiennent des informations sur la structure de
            /// l'aéroport. La première dimension de chacune des variables doit être la même.
            /// Cette variable \ref tsObjectType_ est à 2 dimensions, mais ne devrait pas l'être (pas utile).
            /// </summary>
            private String[][] tsObjectType_;
            /// <summary>
            /// Informations pour indiquer si les colonnes de l'information considérée peuvent ne pas être renseigné.
            /// </summary>
            private Boolean[] bCanBeNull;
            /// <summary>
            /// Premère dimension : tableau 
            /// Deuxième dimentsion : La liste des colonnes qui doivent contenir des informations de l'aéroport. (4 dimensions : Terminal , Level =""Plus utilisé , Begin(, End))
            /// </summary>
            private String[][] tsObjectColumns_;

            /// <summary>
            /// Name of the probability profile table.
            /// </summary>
            private String sOneOfTable_;
            /// <summary>
            /// Boolean that indicates if we need to check the sum of columns / rows.
            /// </summary>
            private bool bCheckSum_;

            /// <summary>
            /// Number of columns that should not be used to check the sum of a row.
            /// </summary>
            private int iCheckSumIgnoredColumns_;
            /// <summary>
            /// Pour la table de trolley, la somme doit être égale à 100 pour chaque regroupement pas nombre de bagages.
            /// </summary>
            private String sCheckSumGroupBy_;

            /// <summary>
            /// Boolean that indicates if the current table is an open /close table.
            /// </summary>
            private bool bOCT_Table_;
            /// <summary>
            /// Boolean that indicates if the current table is the departure flight plan
            /// </summary>
            private bool bOCT_Departure_;
            /// <summary>
            /// Boolean that indicates if the current table is the arrival flight plan
            /// </summary>
            private bool bOCT_Arrival_;

            //>> Task #7405 - new Desk and extra information for Pax
            /// <summary>
            /// 
            /// </summary>
            internal String UserAttributeTableName { get; private set; }


            /// <summary>
            /// Variable to know what type of analyse should be done on the table.
            /// </summary>
            private eTypeAnalyze etaTypeAnalysis_;
            #endregion

            #region Les accesseurs

            /// <summary>
            /// Le nom de la table qui est vérifiée par cette instance de \ref TableCheck.
            /// </summary>
            public String Table
            {
                get
                {
                    return sTable_;
                }
                set
                {
                    sTable_ = value;
                }
            }
            /// <summary>
            /// La liste des noms des colonnes qui contiennent des informations au format \ref DateTime. Cette liste peut
            /// être null. La vérification des dates consiste à vérifier que le contenu de la colonne n'est pas null.
            /// </summary>
            public String[] DateColumns
            {
                get
                {
                    return tsDateColumns_;
                }
                set
                {
                    tsDateColumns_ = value;
                }
            }
            /// <summary>
            /// La liste des noms des colonnes qui sont liées à d'autres tables. Cette liste est intimement liées à \ref TableLinkedTable.
            /// Le contenu de la colonne \ref TableLinkedColumns [x] doit être présent dans la table \ref TableLinkedTable [x].
            /// </summary>
            public String[] TableLinkedColumns
            {
                get
                {
                    return tsTableLinkedColumns_;
                }
                set
                {
                    tsTableLinkedColumns_ = value;
                }
            }
            /// <summary>
            /// La liste des noms des tables qui va avec la variable \ref TableLinkedColumns
            /// </summary>
            public String[] TableLinkedTable
            {
                get
                {
                    return tsTableLinkedTable_;
                }
                set
                {
                    tsTableLinkedTable_ = value;
                }
            }
            public bool[] TableLinkedWarn
            {
                get { return tbTableLinkedWarn_; }
                set { tbTableLinkedWarn_ = value; }
            }

            /// <summary>
            /// La liste des colonnes qui doivent contenir des valeurs numérique non négatives.
            /// </summary>
            public String[] PositiveDataColumns
            {
                get
                {
                    return tsPositiveDataColumns_;
                }
                set
                {
                    tsPositiveDataColumns_ = value;
                }
            }

            /// <summary>
            /// La liste des colonnes de la table analysée qui doivent contenir des distributions. Une distribution est
            /// soit une de celles fournie par Automod, ou alors une de celle présente dans la table ProbabilityProfile 
            /// passée en paramètre. \ref OneOfTable contient le nom de la table ProbabilityProfile qui set de référence.
            /// </summary>
            public String[] DistribColumns
            {
                get
                {
                    return tsDistribColumns_;
                }
                set
                {
                    tsDistribColumns_ = value;
                }
            }

            /// <summary>
            /// Nom de la table ProbabilityProfile à utiliser pour vérifier les distributions.
            /// </summary>
            public String OneOfTable
            {
                get
                {
                    return sOneOfTable_;
                }
                set
                {
                    sOneOfTable_ = value;
                }
            }
            /// <summary>
            /// Le nombre de colonnes au début de la table qui ne doivent pas être vérifiées pour les informations de somme.
            /// Ces informations de somme concernent principalement les tables de distributions (ShowUp, ICT, Bags Distribution).
            /// La somme de chacune de ces colonnes doit être égale à 100 %.
            /// </summary>
            public int CheckSumIgnoredColumns
            {
                get
                {
                    return iCheckSumIgnoredColumns_;
                }
                set
                {
                    iCheckSumIgnoredColumns_ = value;
                    bCheckSum_ = true;
                }
            }
            /// <summary>
            /// Information indiquant si les informations doivent être regroupées par information ou non. (Dans le cas de la 
            /// table Trolley, la première colonne sert à regrouper les lignes.
            /// </summary>
            public String CheckSumGroupBy
            {
                get
                {
                    return sCheckSumGroupBy_;
                }
                set
                {
                    sCheckSumGroupBy_ = value;
                    bCheckSum_ = true;
                }
            }
            /// <summary>
            /// Booléen permettant de savoir s'il la table courant est une table OCT. Si oui, alors les booléens \ref OCT_Departure
            /// et \ref OCT_Arrival permettront de savoir quel type de vérification effectué. (première ligne > seconde ou seconde > 
            /// première ou indifférent).
            /// </summary>
            public bool OCT_Table
            {
                get
                {
                    return bOCT_Table_;
                }
                set
                {
                    bOCT_Table_ = value;
                }
            }
            /// <summary>
            /// Cf: \ref OCT_Table
            /// </summary>
            public bool OCT_Departure
            {
                get
                {
                    return bOCT_Departure_;
                }
                set
                {
                    bOCT_Departure_ = value;
                }
            }
            /// <summary>
            /// Cf: \ref OCT_Table
            /// </summary>
            public bool OCT_Arrival
            {
                get
                {
                    return bOCT_Arrival_;
                }
                set
                {
                    bOCT_Arrival_ = value;
                }
            }
            /// <summary>
            /// Type énuméré permettant de définir des analyses plus spécifiques sur les tables.
            /// </summary>
            public eTypeAnalyze TypeAnalysis
            {
                get
                {
                    return etaTypeAnalysis_;
                }
                set
                {
                    etaTypeAnalysis_ = value;
                }
            }

            /// <summary>
            /// Liste des types d'élément de l'aéroport qui doivent être présent dans la table vérifiée par
            /// l'instance courante. Elle fonctionne avec les variables \ref CanBeNull et \ref ObjectColumns.
            /// Exemple d'utilisation : 
            /// Pour la table FPDTable, les colonnes permettant de définir les check In alloués à un vol doivent
            /// être valide par rapport au contenu de la structure de l'aéroport. Pour vérifier cela, il faut 
            /// paramétrer de la sorte : 
            ///     - \ref ObjectType = {{"Check-In"}} //le nom de l'objet à rechercher dans la structure de l'aéroport.
            ///     - \ref CanBeNull = {false}         //Booléen indiquant si les informations peuvent être omises (pas 
            /// présentes dans la table.)
            ///     - \ref ObjectColumns = {{"CI Terminal", "", "Eco. Class CI start", "Eco. Class CI end" } } // Liste 
            /// des colonnes de la tables qui sont liées (Terminal / Level / Start (/End))
            /// </summary>
            public String[][] ObjectType
            {
                get
                {
                    return tsObjectType_;
                }
                set
                {
                    tsObjectType_ = value;
                }
            }
            /// <summary>
            /// cf \ref ObjectType
            /// </summary>
            public Boolean[] CanBeNull
            {
                get
                {
                    return bCanBeNull;
                }
                set
                {
                    bCanBeNull = value;
                }
            }
            /// <summary>
            /// cf \ref ObjectType
            /// </summary>
            public String[][] ObjectColumns
            {
                get
                {
                    return tsObjectColumns_;
                }
                set
                {
                    tsObjectColumns_ = value;
                }
            }
            #endregion

            #region Fonction pour initialiser la classe.
            private void Initialize(String sTable,
                                    String[] tsDateColumns,
                                    String[] tsTableLinkedColumns,
                                    String[] tsTableLinkedTable,
                                    String[] tsPositiveDataColumns,
                                    String[] tsDistribColumns,
                                    String sOneOfTable,
                                    int iCheckSumIgnoredColumns,
                                    String sCheckSumGroupBy,
                                    eTypeAnalyze etaTypeAnalysis)
            {
                sTable_ = sTable;
                tsDateColumns_ = tsDateColumns;
                tsTableLinkedColumns_ = tsTableLinkedColumns;
                tsTableLinkedTable_ = tsTableLinkedTable;
                tsPositiveDataColumns_ = tsPositiveDataColumns;
                tsDistribColumns_ = tsDistribColumns;
                sOneOfTable_ = sOneOfTable;
                bCheckSum_ = (iCheckSumIgnoredColumns != -1);
                iCheckSumIgnoredColumns_ = iCheckSumIgnoredColumns;
                sCheckSumGroupBy_ = sCheckSumGroupBy;
                bOCT_Table_ = false;
                bOCT_Departure_ = false;
                bOCT_Arrival_ = false;
                etaTypeAnalysis_ = etaTypeAnalysis;
            }
            #endregion

            #region Constructeurs
            /// <summary>
            /// Contructeur global
            /// </summary>
            /// <param name="dtTable">La table à vérifier</param>
            /// <param name="tsDateColumns">La liste des colonnes qui doivent avoir une structure date
            /// avec une amplitude ne dépassant pas 7 jours.</param>
            /// <param name="tsTableLinkedColumns">Les colonnes qui servent de lien avec d'autres tables</param>
            /// <param name="tdtTableLinkedTable">Les tables lièes à cette table.</param>
            /// <param name="tsPositiveDataColumns">Les colonnes qui doivent avoir des valeurs positives.</param>
            public TableCheck(String sTable,
                              String[] tsDateColumns,
                              String[] tsTableLinkedColumns,
                              String[] tsTableLinkedTable,
                              String[] tsPositiveDataColumns)
            {
                Initialize(sTable, tsDateColumns, tsTableLinkedColumns, tsTableLinkedTable, tsPositiveDataColumns, null, null, -1, null, eTypeAnalyze.None);
            }

            /// <summary>
            /// Contructeur global
            /// </summary>
            /// <param name="dtTable">La table à vérifier</param>
            /// <param name="tsDateColumns">La liste des colonnes qui doivent avoir une structure date
            /// avec une amplitude ne dépassant pas 7 jours.</param>
            /// <param name="tsTableLinkedColumns">Les colonnes qui servent de lien avec d'autres tables</param>
            /// <param name="tdtTableLinkedTable">Les tables lièes à cette table.</param>
            /// <param name="tsPositiveDataColumns">Les colonnes qui doivent avoir des valeurs positives.</param>
            /// <param name="tsDistribColumns">Les colonnes qui contiennent des distributions. (On teste ensuite les 3 colonnes suivant celle renseignée)</param>
            public TableCheck(String sTable,
                              String[] tsDateColumns,
                              String[] tsTableLinkedColumns,
                              String[] tsTableLinkedTable,
                              String[] tsPositiveDataColumns,
                              String[] tsDistribColumns,
                              String sOneOfTable)
            {
                Initialize(sTable, tsDateColumns, tsTableLinkedColumns, tsTableLinkedTable, tsPositiveDataColumns, tsDistribColumns, sOneOfTable, -1, null, eTypeAnalyze.None);
            }
            /// <summary>
            /// Contructeur global
            /// </summary>
            /// <param name="dtTable">La table à vérifier</param>
            /// <param name="tsDateColumns">La liste des colonnes qui doivent avoir une structure date
            /// avec une amplitude ne dépassant pas 7 jours.</param>
            /// <param name="tsTableLinkedColumns">Les colonnes qui servent de lien avec d'autres tables</param>
            /// <param name="tdtTableLinkedTable">Les tables lièes à cette table.</param>
            /// <param name="tsPositiveDataColumns">Les colonnes qui doivent avoir des valeurs positives.</param>
            /// <param name="tsDistribColumns">Les colonnes qui contiennent des distributions. (On teste ensuite les 3 colonnes suivant celle renseignée)</param>
            /// <param name="bCheckSum">Booleen pour savoir si l'on doit vérifier la distribution des colonnes.</param>
            /// <param name="iCheckSumIgnoredColumns">Le nombre de colonnes au début à ignorer.</param>
            /// <param name="sCheckSumGroupBy">La colonne qui doit servir de groupBy (Peut être null).</param>
            public TableCheck(String sTable,
                              String[] tsDateColumns,
                              String[] tsTableLinkedColumns,
                              String[] tsTableLinkedTable,
                              String[] tsPositiveDataColumns,
                              String[] tsDistribColumns,
                              String sOneOfTable,
                              int iCheckSumIgnoredColumns,
                              String sCheckSumGroupBy,
                              eTypeAnalyze etaTypeAnalysis)
            {
                Initialize(sTable, tsDateColumns, tsTableLinkedColumns, tsTableLinkedTable, tsPositiveDataColumns, tsDistribColumns, sOneOfTable, iCheckSumIgnoredColumns, sCheckSumGroupBy, etaTypeAnalysis);
            }
            /// <summary>
            /// Constructeur pour les tables oct.
            /// </summary>
            /// <param name="sTable">Le nom de la table</param>
            /// <param name="OCT_Departure">Le sens de l'analyse</param>
            /// <param name="OCT_Arrival">Pour déterminer le sens de l'analyse</param>
            public TableCheck(String sTable,
                              bool bOCT_Departure,
                              bool bOCT_Arrival)
            {
                Initialize(sTable, null, null, null, null, null, null, -1, null, eTypeAnalyze.None);

                bOCT_Table_ = true;
                bOCT_Departure_ = bOCT_Departure;
                bOCT_Arrival_ = bOCT_Arrival;
            }
            /// <summary>
            /// Constructeur pour les load factors.
            /// </summary>
            /// <param name="sTable">Le nom de la table</param>
            /// <param name="bLoadFactorDeparture">Type de load factors</param>
            public TableCheck(String sTable,
                              eTypeAnalyze etaTypeAnalysis)
            {
                Initialize(sTable, null, null, null, null, null, null, -1, null, etaTypeAnalysis);
            }
            //<< Task #7405 - new Desk and extra information for Pax            
            /// <summary>
            /// Constructor that allow to check the allocation tables for security, transfert and passport check 5plus User Process
            /// </summary>
            /// <param name="sTable">Le nom de la table</param>
            /// <param name="bLoadFactorDeparture">Type de load factors</param>
            public TableCheck(String sTable,
                String UserAttributeTable,
                              eTypeAnalyze etaTypeAnalysis)
            {
                UserAttributeTableName = UserAttributeTable;
                Initialize(sTable, null, null, null, null, null, null, -1, null, etaTypeAnalysis);
            }
            //>> Task #7405 - new Desk and extra information for Pax
            #endregion

            #region Vérification des informations contenues dans les plans de vol.

            #region Fonction pour vérifier que la table contient bien les colonnes spécifiées.
            private static bool CheckColumnsExist(DataTable dtTable, String[] tsColumns, Type tColumnsType)
            {
                if (dtTable == null)
                    return false;
                foreach (String sName in tsColumns)
                {
                    if ((sName == null) || (sName.Length == 0))
                        return false;
                    if (!dtTable.Columns.Contains(sName))
                        return false;
                    if (tColumnsType != null)
                        if (dtTable.Columns[sName].DataType != tColumnsType)
                            return false;
                }
                return true;
            }
            #endregion

            /// <summary>
            /// Fonction générique qui vérifie le contenu de la table.
            /// Elle vérifie suivant les informations passées dans les différents paramètres
            /// renseignés.
            /// </summary>
            /// <param name="ErrorList">La liste des erreurs qui seront retournées.</param>
            /// <param name="cfeErrors">La structure de stockage des erreurs de la table.</param>
            /// <returns>Return a booleen which indicates if the table is valid or not</returns>
            internal bool CheckTable(Dictionary<String, DataTable> htTable,
                                   String sSortedColumn,
                                   System.Xml.XmlNode xnStructure,
                                   ArrayList ErrorList,
                                   ArrayList WarningList,
                                   ConditionnalFormatErrors cfeErrors,
                                   bool bAlphaNumerical,
                                   bool bCheckPaxSimulation,
                                   bool bCheckBagSimulation)
            {
                if (!htTable.ContainsKey(sTable_))
                    return false;
                DataTable dtTable_ = htTable[sTable_];
                if (sSortedColumn != null)
                    dtTable_ = OverallTools.DataFunctions.sortTable(dtTable_, sSortedColumn);
                if (dtTable_ == null)
                    return false;
                bool bResult = true;
                if (xnStructure != null)
                {
                    bResult = CheckStructure(dtTable_, xnStructure, tsObjectType_, tsObjectColumns_, bCanBeNull, ErrorList, WarningList, cfeErrors, bAlphaNumerical, bCheckPaxSimulation, bCheckBagSimulation) && bResult;
                }

                if (etaTypeAnalysis_ != eTypeAnalyze.None)
                {
                    switch (etaTypeAnalysis_)
                    {
                        case eTypeAnalyze.LoadFactorArrival:
                            return CheckArrivalLoadFactors(dtTable_, ErrorList, cfeErrors);
                        case eTypeAnalyze.LoadFactorDeparture:
                            return CheckDepartureLoadFactors(dtTable_, ErrorList, cfeErrors);
                        case eTypeAnalyze.CapacityOfQueue:
                            return CheckCapacityTable(dtTable_, ErrorList, cfeErrors);

#if(NEWALLOCATIONSECU)
                        case eTypeAnalyze.PassportAllocation:
                        case eTypeAnalyze.SecurityAllocation:
                        case eTypeAnalyze.TransferAllocation:
                            //<< Task #7405 - new Desk and extra information for Pax                            
                            if (htTable.ContainsKey(GlobalNames.sUserAttributesTableName))
                                return CheckAllocationTables(dtTable_, htTable[GlobalNames.sUserAttributesTableName], ErrorList, cfeErrors);
                            return CheckAllocationTables(dtTable_, null, ErrorList, cfeErrors);
                        //>> Task #7405 - new Desk and extra information for Pax
#else
                        case eTypeAnalyze.PassportAllocation:
                        case eTypeAnalyze.SecurityAllocation:
                            return CheckAllocationTables(dtTable_, true, ErrorList, cfeErrors);
                        case eTypeAnalyze.TransferAllocation:
                            return CheckAllocationTables(dtTable_, false, ErrorList, cfeErrors);
#endif
                        case eTypeAnalyze.ProcessTable:
                            if (!htTable.ContainsKey(sOneOfTable_))
                                return false;
                            DataTable OneOf = (DataTable)htTable[sOneOfTable_];
                            return CheckProcessTable(dtTable_, OneOf, ErrorList, cfeErrors);
                        case eTypeAnalyze.AnimatedQueues:
                            break;
                        case eTypeAnalyze.FPLinksTable:
                            return CheckAircraftLinkTable(htTable[GlobalNames.FPDTableName], htTable[GlobalNames.FPATableName], dtTable_, ErrorList, cfeErrors);
                        case eTypeAnalyze.TransfertDistribution:
                            return CheckTransfertDistributionTable(dtTable_, ErrorList, cfeErrors);
                        case eTypeAnalyze.SaturationTable:          // << Task #9412 Pax2Sim - Scenario parameters files - Settings and OpeningOnSaturation
                            return CheckSaturationTable(dtTable_, ErrorList, cfeErrors);
                        default: break;
                    }
                }
                if ((tsDateColumns_ != null) && (tsDateColumns_.Length != 0))
                {
                    if (!CheckColumnsExist(dtTable_, tsDateColumns_, typeof(DateTime)))
                        return false;
                    for (int i = 0; i < tsDateColumns_.Length; i++)
                        bResult = CheckDates(dtTable_, tsDateColumns_[i], ErrorList, WarningList, cfeErrors) && bResult;
                }

                if ((tsTableLinkedColumns_ != null) && (tsTableLinkedColumns_.Length != 0))
                {
                    DataTable[] tdtTableLinkedTable_ = new DataTable[tsTableLinkedColumns_.Length];
                    for (int i = 0; i < tsTableLinkedTable_.Length; i++)
                    {
                        if (!htTable.ContainsKey((String)tsTableLinkedTable_[i]))
                            return false;
                        tdtTableLinkedTable_[i] = (DataTable)htTable[(String)tsTableLinkedTable_[i]];
                    }
                    if (!CheckColumnsExist(dtTable_, tsTableLinkedColumns_, null))
                        return false;
                    for (int i = 0; i < tsTableLinkedColumns_.Length; i++)
                    {
                        if (tbTableLinkedWarn_ == null)
                            bResult = CheckTable(dtTable_, tdtTableLinkedTable_[i], tsTableLinkedColumns_[i], null, ErrorList, WarningList, cfeErrors, false) && bResult;
                        else
                            bResult = CheckTable(dtTable_, tdtTableLinkedTable_[i], tsTableLinkedColumns_[i], null, ErrorList, WarningList, cfeErrors, tbTableLinkedWarn_[i]) && bResult;
                    }
                }

                if ((tsPositiveDataColumns_ != null) && (tsPositiveDataColumns_.Length != 0))
                {
                    if (!CheckColumnsExist(dtTable_, tsPositiveDataColumns_, null))
                        return false;

                    for (int i = 0; i < tsPositiveDataColumns_.Length; i++)
                    {
                        bResult = CheckPositiveValues(dtTable_, tsPositiveDataColumns_[i], ErrorList, cfeErrors) && bResult;
                    }
                }
                if ((tsDistribColumns_ != null) && (tsDistribColumns_.Length != 0))
                {
                    if (!CheckColumnsExist(dtTable_, tsDistribColumns_, null))
                        return false;
                    if (!htTable.ContainsKey(sOneOfTable_))
                        return false;
                    DataTable dtOneOfTable_ = (DataTable)htTable[sOneOfTable_];
                    if (dtOneOfTable_ == null)
                        return false;
                    foreach (String sDistribName in tsDistribColumns_)
                    {
                        bResult = CheckDistribution(dtTable_, sDistribName, dtOneOfTable_, ErrorList, cfeErrors) & bResult;
                    }
                }
                if (bCheckSum_)
                {
                    if ((sCheckSumGroupBy_ != null) && (!dtTable_.Columns.Contains(sCheckSumGroupBy_)))
                        return false;
                    bResult = CheckSum(dtTable_, iCheckSumIgnoredColumns_, sCheckSumGroupBy_, ErrorList, cfeErrors) && bResult;
                }
                if (bOCT_Table_)
                {
                    int iSensAnalyze = 0;
                    if (OCT_Arrival && OCT_Departure)
                    {
                        iSensAnalyze = 2;
                    }
                    else if (OCT_Arrival)
                    {
                        iSensAnalyze = 1;
                    }
                    bResult = CheckOCTTables(dtTable_, iSensAnalyze, ErrorList, cfeErrors) && bResult;
                }
                return bResult;
            }


            #endregion

            #region Fonction pour la vérification des dates
            private static bool CheckDates(DataTable dtTable,
                                           String sDateColumns,
                                           ArrayList ErrorList,
                                           ArrayList WarningList,
                                           ConditionnalFormatErrors cfeErrors)
            {
                DateTime dtMinimumDate = DateTime.MaxValue, dtMaximumDate = DateTime.MinValue;
                DateTime dtTemp;
                bool Result = true;
                if (dtTable == null)
                    return false;
                if (dtTable.Rows.Count == 0)
                    return true;

                // >> Task #13366 Error message correction
                //foreach (DataRow line in dtTable.Rows)
                //{
                //    dtTemp = (DateTime)line[sDateColumns];
                //    if (dtTemp < dtMinimumDate)
                //        dtMinimumDate = dtTemp;
                //    if (dtTemp > dtMaximumDate)
                //        dtMaximumDate = dtTemp;
                //}

                //if (dtMinimumDate.AddDays(7) < dtMaximumDate)
                //{
                //    WarningList.Add("Warn01431 : The dates range contained in the flight plan are too large. The difference can't be greater than 7 days.");
                //    Result = false;
                //    int iIndexDate;
                //    int i;
                //    iIndexDate = dtTable.Columns.IndexOf(sDateColumns);

                //    for (i = 0; i < dtTable.Rows.Count; i++)
                //    {
                //        cfeErrors.setCondition(iIndexDate, i, "", (String)WarningList[WarningList.Count - 1]);
                //    }
                //}
                // << Task #13366 Error message correction
                return Result;
            }
            #endregion

            #region Fonction qui vérifie les liens entre les tables.
            /// <summary>
            /// Fonction qui vérifie que tout les elements d'une colonne sont bien référencé dans une autre.
            /// </summary>
            /// <param name="dtTable">Table à vérifier</param>
            /// <param name="dtAnnexeTable">Table de référence</param>
            /// <param name="nomColumn">Colonne à vérifier</param>
            /// <param name="nomColumnAnnexe">Colonne de référence</param>
            /// <param name="ErrorList">Liste où ajouter les erreurs</param>
            /// <param name="WarningList">Liste où ajouter les warnings</param>
            /// <param name="cfeErrors"></param>
            /// <param name="warning">Détermine si les conflis doivent être ajoutées 
            /// en tan qu'erreur ou warning</param>
            /// <returns></returns>
            private static bool CheckTable(DataTable dtTable,
                                          DataTable dtAnnexeTable,
                                          String nomColumn,
                                          String nomColumnAnnexe,
                                          ArrayList ErrorList,
                                          ArrayList WarningList,
                                          ConditionnalFormatErrors cfeErrors,
                                          bool warning)
            {
                int iIndexColumn = dtTable.Columns.IndexOf(nomColumn);
                if (iIndexColumn == -1)
                {
                    ErrorList.Add("Err01389 : The column \"" + nomColumn + "\" does not exist in the table \""
                        + DataManagement.DataManagerInput.ConvertToFullName(dtTable.TableName) + "\".");
                    return false;
                }
                if ((dtAnnexeTable == null) || (dtAnnexeTable.Columns.Count == 0))
                {
                    return false;
                }
                int iIndexColumnAnnexe = 0;
                if ((nomColumnAnnexe != null) && (dtAnnexeTable.Columns.Contains(nomColumnAnnexe)))
                    iIndexColumnAnnexe = dtAnnexeTable.Columns.IndexOf(nomColumnAnnexe);

                bool Result = true;
                for (int i = 0; i < dtTable.Rows.Count; i++)
                {
                    String sValue = dtTable.Rows[i].ItemArray[iIndexColumn].ToString().Trim();
                    String sValueTrouvee = OverallTools.DataFunctions.getValue(dtAnnexeTable, sValue, iIndexColumnAnnexe, iIndexColumnAnnexe);
                    if (sValue != sValueTrouvee)
                    {
                        String msg = "Ligne " + (i + 1).ToString() + " : \"" + dtTable.Rows[i].ItemArray[0].ToString() + "\" from the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(dtTable.TableName) + "\" have a mistake in the column \"" + nomColumn + "\" : The name does not appear in the table \"" + dtAnnexeTable.TableName + "\".";
                        if (warning)
                        {
                            WarningList.Add("warn01392 : " + msg);
                            cfeErrors.setCondition(iIndexColumn, i, null, (String)WarningList[WarningList.Count - 1]);
                        }
                        else
                        {
                            ErrorList.Add("Err01392 : " + msg);
                            cfeErrors.setCondition(iIndexColumn, i, (String)ErrorList[ErrorList.Count - 1]);
                        }
                        Result = false;
                    }
                }
                return Result;
            }
            #endregion

            #region la fonction qui vérifie les valeurs numériques dans la table.
            private static bool CheckPositiveValues(DataTable dtTable,
                                                    String sColumn,
                                                    ArrayList ErrorList,
                                                    ConditionnalFormatErrors cfeErrors)
            {
                bool bResult = true;
                bool bInt = false;
                bool bDouble = false;
                if (!dtTable.Columns.Contains(sColumn))
                {
                    ErrorList.Add("Err01388 : The column \"" + sColumn + "\" does not exist in the table \"" + dtTable.TableName + "\".");
                    return false;
                }
                bInt = ((dtTable.Columns[sColumn].DataType == typeof(int)) ||
                        (dtTable.Columns[sColumn].DataType == typeof(Int32)) ||
                        (dtTable.Columns[sColumn].DataType == typeof(Int64)) ||
                        (dtTable.Columns[sColumn].DataType == typeof(Int16)));
                bDouble = ((dtTable.Columns[sColumn].DataType == typeof(Double)) ||
                        (dtTable.Columns[sColumn].DataType == typeof(double)));
                if ((!bDouble) && (!bInt))
                {
                    ErrorList.Add("Err01390 : The column \"" + sColumn + "\" in the table \"" +
                        DataManagement.DataManagerInput.ConvertToFullName(dtTable.TableName) + "\" does not have a good format it must be a number column.");
                    return false;
                }
                int iIndexColumn = dtTable.Columns.IndexOf(sColumn);
                for (int i = 0; i < dtTable.Rows.Count; i++)
                {


                    if (dtTable.Rows[i][iIndexColumn] == null)
                    {
                        ErrorList.Add("Err01393 : Ligne " + (i + 1).ToString() + " : \"" + dtTable.Rows[i].ItemArray[0].ToString() + "\" from the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(dtTable.TableName) + "\" have a mistake in the column \"" + sColumn + "\" : The value can't be null.");
                        cfeErrors.setCondition(iIndexColumn, i, (String)ErrorList[ErrorList.Count - 1]);
                        bResult = false;
                    }
                    else if (dtTable.Rows[i][iIndexColumn].ToString() == "")
                    {
                        ;
                    }
                    else if (bInt && ((int)(dtTable.Rows[i][iIndexColumn]) < 0))
                    {
                        ErrorList.Add("Err01398 : Ligne " + (i + 1).ToString() + " : \"" + dtTable.Rows[i].ItemArray[0].ToString() + "\" from the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(dtTable.TableName) + "\" have a mistake in the column \"" + sColumn + "\" : The value must be positive.");
                        cfeErrors.setCondition(iIndexColumn, i, (String)ErrorList[ErrorList.Count - 1]);
                        bResult = false;
                    }
                    else if (bDouble && ((Double)(dtTable.Rows[i][iIndexColumn]) < 0))
                    {
                        ErrorList.Add("Err01399 : Ligne " + (i + 1).ToString() + " : \"" + dtTable.Rows[i].ItemArray[0].ToString() + "\" from the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(dtTable.TableName) + "\" have a mistake in the column \"" + sColumn + "\" : The value must be positive.");
                        cfeErrors.setCondition(iIndexColumn, i, (String)ErrorList[ErrorList.Count - 1]);
                        bResult = false;
                    }
                }
                return bResult;
            }
            #endregion

            #region Fonction qui vérifie les distributions de la table.
            private static bool CheckDistribution(DataTable dtTable,
                                                  String sColumnName,
                                                  DataTable dtOneofTable,
                                                  ArrayList ErrorList,
                                                  ConditionnalFormatErrors cfeErrors)
            {
                bool bResult = true;
                if (!dtTable.Columns.Contains(sColumnName))
                {
                    ErrorList.Add("Err01387 : The column \"" + sColumnName + "\" does not exist in the table \"" +
                        DataManagement.DataManagerInput.ConvertToFullName(dtTable.TableName) + "\".");
                    return false;
                }
                int iIndexColumn = dtTable.Columns.IndexOf(sColumnName);
                if (iIndexColumn + 3 >= dtTable.Columns.Count)
                {
                    ErrorList.Add("Err01391 : The table \"" +
                        DataManagement.DataManagerInput.ConvertToFullName(dtTable.TableName) + "\" does not have a good format for the analysis of the distribution.");
                    return false;
                }
                int i;
                for (i = 1; i <= 3; i++)
                {
                    if ((dtTable.Columns[iIndexColumn + 1].DataType != typeof(Double)) &&
                        (dtTable.Columns[iIndexColumn + 1].DataType != typeof(double)))
                    {
                        ErrorList.Add("Err01386 : The table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(dtTable.TableName) + "\" does not have a good format for the analysis of the distribution. (Columns \"" + dtTable.Columns[iIndexColumn + 1].ColumnName + "\" must be of type double.");
                        bResult = false;
                    }
                }
                if (!bResult)
                    return false;

                ArrayList DistributionList = OverallTools.DataFunctions.getDistributions(dtOneofTable);
                for (i = 0; i < dtTable.Rows.Count; i++)
                {
                    if (dtTable.Rows[i][iIndexColumn].ToString().Length == 0)
                    {
                        bResult = false;
                        ErrorList.Add("Err01430 : Ligne " + (i + 1).ToString() + " from the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(dtTable.TableName) + "\" have a mistake in the distribution name : The name must be defined.");
                        cfeErrors.setCondition(iIndexColumn, i, (String)ErrorList[ErrorList.Count - 1]);
                        continue;
                    }
                    String DistributionName = dtTable.Rows[i][iIndexColumn].ToString();
                    if (!OverallTools.FonctionUtiles.CheckDistributionName(DistributionName))
                    {
                        if (!DistributionList.Contains(DistributionName))
                        {
                            bResult = false;
                            ErrorList.Add("Err01435 : Ligne " + (i + 1).ToString() + " from the table \"" +
                                DataManagement.DataManagerInput.ConvertToFullName(dtTable.TableName) + "\" have a mistake in the origin column : The distribution name does not exist.");
                            cfeErrors.setCondition(iIndexColumn, i, (String)ErrorList[ErrorList.Count - 1]);
                            continue;
                        }
                    }
                    else
                    {

                        bool bSecondParam, bThirdParam;
                        Double dFirst, dSecond = 0, dThird = 0;
                        FonctionUtiles.NbParams(dtTable.Rows[i][3].ToString(), out bSecondParam, out bThirdParam);
                        if ((dtTable.Rows[i][iIndexColumn + 1].ToString().Length == 0) ||
                            (!Double.TryParse(dtTable.Rows[i][iIndexColumn + 1].ToString(), out dFirst)))
                        {
                            ErrorList.Add("Err01436 : Ligne " + (i + 1).ToString() + " from the table \"" +
                                DataManagement.DataManagerInput.ConvertToFullName(dtTable.TableName) + "\" have a mistake in the distribution values : The first value must be defined.");
                            cfeErrors.setCondition(iIndexColumn + 1, i, (String)ErrorList[ErrorList.Count - 1]);
                            bResult = false;
                            continue;
                        }
                        if (bSecondParam)
                        {
                            if ((dtTable.Rows[i][iIndexColumn + 2].ToString().Length == 0) ||
                                (!Double.TryParse(dtTable.Rows[i][iIndexColumn + 2].ToString(), out dSecond)))
                            {
                                ErrorList.Add("Err01437 : Ligne " + (i + 1).ToString() + " from the table \"" +
                                    DataManagement.DataManagerInput.ConvertToFullName(dtTable.TableName) + "\" have a mistake in the distribution values : The second value must be defined.");
                                cfeErrors.setCondition(iIndexColumn + 2, i, (String)ErrorList[ErrorList.Count - 1]);
                                bResult = false;
                                continue;
                            }
                            if (bThirdParam)
                            {
                                if ((dtTable.Rows[i][iIndexColumn + 3].ToString().Length == 0) ||
                                    (!Double.TryParse(dtTable.Rows[i][iIndexColumn + 3].ToString(), out dThird)))
                                {
                                    ErrorList.Add("Err01438 : Ligne " + (i + 1).ToString() + " from the table \"" +
                                        DataManagement.DataManagerInput.ConvertToFullName(dtTable.TableName) + "\" have a mistake in the distribution values : The third value must be defined.");
                                    cfeErrors.setCondition(iIndexColumn + 3, i, (String)ErrorList[ErrorList.Count - 1]);
                                    bResult = false;
                                    continue;
                                }
                            }
                        }
                        String sError;
                        if (!FonctionUtiles.checkParams(dtTable.Rows[i][3].ToString(), dFirst, dSecond, dThird, out sError))
                        {
                            ErrorList.Add("Err01439 : Ligne " + (i + 1).ToString() + " from the table \"" +
                                DataManagement.DataManagerInput.ConvertToFullName(dtTable.TableName) + "\" have a mistake : The params are not valids.");
                            cfeErrors.setCondition(iIndexColumn, i, (String)ErrorList[ErrorList.Count - 1]);
                            cfeErrors.setCondition(iIndexColumn + 1, i, (String)ErrorList[ErrorList.Count - 1]);
                            cfeErrors.setCondition(iIndexColumn + 2, i, (String)ErrorList[ErrorList.Count - 1]);
                            cfeErrors.setCondition(iIndexColumn + 3, i, (String)ErrorList[ErrorList.Count - 1]);
                            bResult = false;
                        }
                    }
                }

                return bResult;
            }
            #endregion

            #region Fonction qui vérifie les somme des colonnes qui doivent être égale à 100.
            private static bool CheckSum(DataTable dtTable,
                                         int iIgnoredColumns,
                                         String sGroupBy,
                                         ArrayList ErrorList,
                                         ConditionnalFormatErrors cfeErrors)
            {

                // >> Task #10069 Pax2Sim - no BNP development

                // >> Task #9915 Pax2Sim - BNP development - Peak Flows - USA Standard directory
                if (PAX2SIM.usaMode)
                {
                    if (dtTable.TableName.Equals(GlobalNames.flightSubcategoriesTableName))
                        return true;
                }
                // << Task #9915 Pax2Sim - BNP development - Peak Flows - USA Standard directory


                if (dtTable.Columns.Count <= iIgnoredColumns)
                    return true;
                bool bResult = true;
                bool bInt = false;
                bool bDouble = false;
                int iGroupBy = -1;
                if (sGroupBy != null)
                {
                    if (!dtTable.Columns.Contains(sGroupBy))
                    {
                        ErrorList.Add("Err01395 : The column \"" + sGroupBy + "\" does not appear on the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(dtTable.TableName) + "\".");
                        return false;
                    }
                    iGroupBy = dtTable.Columns.IndexOf(sGroupBy);
                }
                String sValueGroupBy;
                for (int i = iIgnoredColumns; i < dtTable.Columns.Count; i++)
                {

                    bInt = ((dtTable.Columns[i].DataType == typeof(int)) ||
                            (dtTable.Columns[i].DataType == typeof(Int32)) ||
                            (dtTable.Columns[i].DataType == typeof(Int64)) ||
                            (dtTable.Columns[i].DataType == typeof(Int16)));
                    bDouble = ((dtTable.Columns[i].DataType == typeof(Double)) ||
                            (dtTable.Columns[i].DataType == typeof(double)));
                    if ((!bInt) && (!bDouble))
                    {
                        ErrorList.Add("Err01442 : Column \"" + dtTable.Columns[i].ColumnName + "\" from the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(dtTable.TableName) + "\" have a mistake : The colonne have to be a numeric column.");
                        bResult = false;
                        continue;
                    }
                    Hashtable htResults = new Hashtable();
                    for (int j = 0; j < dtTable.Rows.Count; j++)
                    {
                        if (iGroupBy != -1)
                        {
                            if (dtTable.Rows[j][iGroupBy] != null)
                                sValueGroupBy = dtTable.Rows[j][iGroupBy].ToString();
                            else
                            {
                                ErrorList.Add("Err01396 : Line " + (i + 1).ToString() + " : \"" + dtTable.Rows[i].ItemArray[0].ToString() + "\" from the table \"" +
                                    DataManagement.DataManagerInput.ConvertToFullName(dtTable.TableName) + "\" have a mistake in the column \"" + dtTable.Columns[i].ColumnName + "\" : The value can't be null.");
                                cfeErrors.setCondition(i, j, (String)ErrorList[ErrorList.Count - 1]);
                                return false;
                            }
                        }
                        else
                        {
                            sValueGroupBy = "Total";
                        }
                        if (!htResults.Contains(sValueGroupBy))
                            htResults.Add(sValueGroupBy, (Double)0);
                        Double dValue;
                        int iValue;
                        if (bDouble)
                        {
                            if (Double.TryParse(dtTable.Rows[j][i].ToString(), out dValue))
                            {
                                htResults[sValueGroupBy] = (Double)htResults[sValueGroupBy] + dValue;
                            }
                        }
                        else if (bInt)
                        {
                            if (Int32.TryParse(dtTable.Rows[j][i].ToString(), out iValue))
                            {
                                htResults[sValueGroupBy] = (Double)htResults[sValueGroupBy] + iValue;
                            }
                        }
                    }
                    //Vérification de cette colonne.
                    Hashtable htListErrors = new Hashtable();
                    if (htResults.Count == 0)
                        continue;
                    foreach (String sKeys in htResults.Keys)
                    {
                        if (Math.Round((Double)htResults[sKeys], 2) != 100.00f)
                        {
                            ErrorList.Add("Err01397 : The sum for " + sKeys + " bag" + (sKeys != "0" && sKeys != "1" ? "s" : "") + " in the column " + dtTable.Columns[i].ColumnName + " for the table " +
                                DataManagement.DataManagerInput.ConvertToFullName(dtTable.TableName) + " must be 100.");
                            htListErrors.Add(sKeys, ErrorList.Count - 1);
                            bResult = false;
                        }
                    }
                    if (htListErrors.Count > 0)
                    {
                        for (int j = 0; j < dtTable.Rows.Count; j++)
                        {
                            if (sGroupBy == null)
                            {
                                cfeErrors.setCondition(i, j, ErrorList[(int)htListErrors["Total"]].ToString());
                            }
                            else
                            {
                                if (htListErrors.ContainsKey(dtTable.Rows[j][iGroupBy].ToString()))
                                {
                                    cfeErrors.setCondition(i, j, ErrorList[(int)htListErrors[dtTable.Rows[j][iGroupBy].ToString()]].ToString());
                                }
                            }
                        }
                    }
                }

                return bResult;
            }
            #endregion

            #region Fonction pour vérifier les tables OCT.
            /// <summary>
            /// Fonction qui se charge d'analyser le conetnu de la table OCT et de renvoyer un booleen 
            /// indiquant si elle est valide ou non.
            /// </summary>
            /// <param name="table">La table OCT à analyser</param>
            /// <param name="iSensAnalyse">Le sens des dépendances (0 : Premiere ligne > Seconde
            /// 1:Seconde ligne > première
            /// 2:Indifférent</param>
            /// <param name="ErrorList">La structure pour retourner les erreurs.</param>
            /// <param name="TableErrors">La structure pour enregistrer les positions des erreurs.</param>
            /// <returns></returns>
            private static Boolean CheckOCTTables(DataTable table,
                                          Int32 iSensAnalyze,
                                          ArrayList ErrorList,
                                          ConditionnalFormatErrors cfeErrors)
            {
                if (table.Columns.Count == 1)
                    return true;
                bool bValid = true;
                for (int i = 1; i < table.Columns.Count; i++)
                {
                    if ((table.Rows[0][i].ToString().Length == 0) ||
                        (table.Rows[0][i].ToString().Length == 0))
                    {
                        bValid = false;
                        ErrorList.Add("Err01440 : Column " + (i + 1).ToString() + " from the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(table.TableName) + "\" have a mistake : Values can't be null.");
                        cfeErrors.setCondition(i, 0, (String)ErrorList[ErrorList.Count - 1]);
                        cfeErrors.setCondition(i, 1, (String)ErrorList[ErrorList.Count - 1]);
                        continue;
                    }
                    Double fValue = (Double)table.Rows[0][i];
                    Double sValue = (Double)table.Rows[1][i];
                    if (fValue == sValue)
                    {
                        bValid = false;
                        ErrorList.Add("Err01443 : Column " + (i + 1).ToString() + " from the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(table.TableName) + "\" have a mistake : Values must be different.");
                        cfeErrors.setCondition(i, 0, (String)ErrorList[ErrorList.Count - 1]);
                        cfeErrors.setCondition(i, 1, (String)ErrorList[ErrorList.Count - 1]);
                        continue;
                    }
                    if (fValue < 0)
                    {
                        bValid = false;
                        ErrorList.Add("Err01444 : Column " + (i + 1).ToString() + " from the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(table.TableName) + "\" have a mistake : Value must be positive.");
                        cfeErrors.setCondition(i, 0, (String)ErrorList[ErrorList.Count - 1]);
                        continue;
                    }
                    if (sValue < 0)
                    {
                        bValid = false;
                        ErrorList.Add("Err01445 : Column " + (i + 1).ToString() + " from the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(table.TableName) + "\" have a mistake : Value must be positive.");
                        cfeErrors.setCondition(i, 1, (String)ErrorList[ErrorList.Count - 1]);
                        continue;
                    }
                    if (iSensAnalyze == 2)
                        continue;
                    if (iSensAnalyze == 1)
                    {
                        Double temp = fValue;
                        fValue = sValue;
                        sValue = temp;
                    }
                    if (sValue > fValue)
                    {
                        bValid = false;
                        if (iSensAnalyze == 1)
                            ErrorList.Add("Err01446 : Column " + (i + 1).ToString() + " from the table \"" +
                                DataManagement.DataManagerInput.ConvertToFullName(table.TableName) + "\" have a mistake : The second value must be bigger than the first.");
                        else
                            ErrorList.Add("Err01447 : Column " + (i + 1).ToString() + " from the table \"" +
                                DataManagement.DataManagerInput.ConvertToFullName(table.TableName) + "\" have a mistake : The first value must be bigger than the second.");
                        cfeErrors.setCondition(i, 0, (String)ErrorList[ErrorList.Count - 1]);
                        cfeErrors.setCondition(i, 1, (String)ErrorList[ErrorList.Count - 1]);
                        continue;
                    }
                }
                return bValid;
            }
            #endregion

            #region Vérification des facteurs de chargement


            private static Boolean CheckArrivalLoadFactors(DataTable dtLoadFactorsArrivalTable,
                                                           ArrayList ErrorList,
                                                           ConditionnalFormatErrors cfeErrors)
            {
                if (dtLoadFactorsArrivalTable.Columns.Count == 1)
                    return true;
                if (dtLoadFactorsArrivalTable.Rows.Count == 0)
                    return false;
                int i;
                bool bAValid = true;
                for (i = 1; i < dtLoadFactorsArrivalTable.Columns.Count; i++)
                {
                    bAValid = CheckArrivalLoadFactors((Double)dtLoadFactorsArrivalTable.Rows[0][i],
                        (Double)dtLoadFactorsArrivalTable.Rows[1][i],
                        (Double)dtLoadFactorsArrivalTable.Rows[2][i],
                        (Double)dtLoadFactorsArrivalTable.Rows[3][i],
                        (Double)dtLoadFactorsArrivalTable.Rows[4][i],
                        (Double)dtLoadFactorsArrivalTable.Rows[5][i],
                        (Double)dtLoadFactorsArrivalTable.Rows[6][i],
                        (Double)dtLoadFactorsArrivalTable.Rows[7][i],
                        (Double)dtLoadFactorsArrivalTable.Rows[8][i],
                        (Double)dtLoadFactorsArrivalTable.Rows[11][i],  // AndreiZaharia / Mulhouse project
                        i,
                        dtLoadFactorsArrivalTable.TableName,
                        dtLoadFactorsArrivalTable.Columns[i].ColumnName,
                        ErrorList,
                        cfeErrors) && bAValid;
                }
                return bAValid;
            }
            private static Boolean CheckDepartureLoadFactors(DataTable dtLoadFactorsDepartureTable,
                                                           ArrayList ErrorList,
                                                           ConditionnalFormatErrors cfeErrors)
            {
                if (dtLoadFactorsDepartureTable.Columns.Count == 1)
                    return true;
                if (dtLoadFactorsDepartureTable.Rows.Count == 0)
                    return false;
                int i;
                bool bDValid = true;
                for (i = 1; i < dtLoadFactorsDepartureTable.Columns.Count; i++)
                {

                    bDValid = CheckDepartureLoadFactors((Double)dtLoadFactorsDepartureTable.Rows[0][i],
                        (Double)dtLoadFactorsDepartureTable.Rows[1][i],
                        (Double)dtLoadFactorsDepartureTable.Rows[2][i],
                        (Double)dtLoadFactorsDepartureTable.Rows[3][i],
                        (Double)dtLoadFactorsDepartureTable.Rows[4][i],
                        (Double)dtLoadFactorsDepartureTable.Rows[5][i],
                        (Double)dtLoadFactorsDepartureTable.Rows[6][i],
                        (Double)dtLoadFactorsDepartureTable.Rows[7][i],
                        (Double)dtLoadFactorsDepartureTable.Rows[8][i],
                        (Double)dtLoadFactorsDepartureTable.Rows[9][i],
                        (Double)dtLoadFactorsDepartureTable.Rows[12][i],    // AndreiZaharia / Mulhouse project
                        i,
                        dtLoadFactorsDepartureTable.TableName,
                        dtLoadFactorsDepartureTable.Columns[i].ColumnName,
                        ErrorList,
                        cfeErrors) && bDValid;
                }
                return bDValid;
            }
            #region Fonction pour vérifier les load facteurs en arrivée
            internal static Boolean CheckArrivalLoadFactors(Double dFull,
                                                          Double dFirst,
                                                          Double dSecond,
                                                          Double dLocal,
                                                          Double dNotLocal,
                                                          Double dTerminating,
                                                          Double dTransferring,
                                                          Double dReCheck,
                                                          Double dTransferDesk,
                                                          Double dPaxPerCar,    // AndreiZaharia / Mulhouse project
                                                          Int32 iColumn,
                                                          String sTableName,
                                                          String sColumnName,
                                                          ArrayList ErrorList,
                                                          ConditionnalFormatErrors ErrorsPosition)
            {
                Boolean bValid = true;

                //%Full
                if ((dFull < 0))
                {
                    bValid = false;
                    if (ErrorList != null)
                    {
                        ErrorList.Add("Err01403 : Ligne 1 (%Full) from the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(sTableName) + "\" have a mistake in the column \"" + sColumnName + "\" : The value is not valid.");
                        ErrorsPosition.setCondition(iColumn, 0, (String)ErrorList[ErrorList.Count - 1]);
                    }
                }
                //%C == %Y
                if ((dFirst < 0) || (dFirst > 100) || (dSecond < 0) || ((dFirst + dSecond) != 100))
                {
                    bValid = false;
                    if (ErrorList != null)
                    {
                        ErrorList.Add("Err01404 : Ligne 2 et 3 (%Y %C) from the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(sTableName) + "\" have a mistake in the column \"" + sColumnName + "\" : The values are not valid.");
                        ErrorsPosition.setCondition(iColumn, 1, (String)ErrorList[ErrorList.Count - 1]);
                        ErrorsPosition.setCondition(iColumn, 2, (String)ErrorList[ErrorList.Count - 1]);
                    }
                }
                //%Local == %Not Local
                if ((dLocal < 0) || (dLocal > 100) || (dNotLocal < 0) || ((dLocal + dNotLocal) != 100))
                {
                    bValid = false;
                    if (ErrorList != null)
                    {
                        ErrorList.Add("Err01405 : Ligne 4 et 5 (%Local %Not local) from the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(sTableName) + "\" have a mistake in the column \"" + sColumnName + "\" : The values are not valid.");
                        ErrorsPosition.setCondition(iColumn, 3, (String)ErrorList[ErrorList.Count - 1]);
                        ErrorsPosition.setCondition(iColumn, 4, (String)ErrorList[ErrorList.Count - 1]);
                    }
                }
                //%Terminating == %Transferring
                if ((dTerminating < 0) || (dTerminating > 100) || (dTransferring < 0) || ((dTerminating + dTransferring) != 100))
                {
                    bValid = false;
                    if (ErrorList != null)
                    {
                        ErrorList.Add("Err01406 : Ligne 6 et 7 (%Terminating %Transferring) from the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(sTableName) + "\" have a mistake in the column \"" + sColumnName + "\" : The values are not valid.");
                        ErrorsPosition.setCondition(iColumn, 5, (String)ErrorList[ErrorList.Count - 1]);
                        ErrorsPosition.setCondition(iColumn, 6, (String)ErrorList[ErrorList.Count - 1]);
                    }
                }
                //%Re-Check
                if ((dReCheck < 0) || (dReCheck > 100))
                {
                    bValid = false;
                    if (ErrorList != null)
                    {
                        ErrorList.Add("Err01407 : Ligne 8 (%Re-Check) from the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(sTableName) + "\" have a mistake in the column \"" + sColumnName + "\" : The value is not valid.");
                        ErrorsPosition.setCondition(iColumn, 7, (String)ErrorList[ErrorList.Count - 1]);
                    }
                }
                //%Transfer Desk
                if ((dTransferDesk < 0) || (dTransferDesk > 100))
                {
                    bValid = false;
                    if (ErrorList != null)
                    {
                        ErrorList.Add("Err01408 : Ligne 9 (%Transfer-desk) from the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(sTableName) + "\" have a mistake in the column \"" + sColumnName + "\" : The value is not valid.");
                        ErrorsPosition.setCondition(iColumn, 8, (String)ErrorList[ErrorList.Count - 1]);
                    }
                }

                //>> AndreiZaharia / Mulhouse project
                //Number of passenger per car
                if (dPaxPerCar < 1)
                {
                    bValid = false;
                    if (ErrorList != null)
                    {
                        ErrorList.Add("Err01409 : Ligne 12 (Number of passenger per car) from the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(sTableName) + "\" have a mistake in the column \"" + sColumnName + "\" : The value is not valid.");
                        ErrorsPosition.setCondition(iColumn, 11, (String)ErrorList[ErrorList.Count - 1]);
                    }
                }
                //<< AndreiZaharia / Mulhouse project

                return bValid;
            }
            #endregion

            #region Fonction pour vérifier les load facteurs en départ
            internal static Boolean CheckDepartureLoadFactors(Double dFull,
                                                          Double dFirst,
                                                          Double dSecond,
                                                          Double dLocal,
                                                          Double dNotLocal,
                                                          Double dOnlineCheckIn,
                                                          Double dOriginating,
                                                          Double dTransferring,
                                                          Double dReCheck,
                                                          Double dTransferDesk,
                                                          Double dPaxPerCar,    // AndreiZaharia / Mulhouse project
                                                          Int32 iColumn,
                                                          String sTableName,
                                                          String sColumnName,
                                                          ArrayList ErrorList,
                                                          ConditionnalFormatErrors ErrorsPosition)
            {
                Boolean bValid = true;

                //%Full
                if ((dFull < 0))
                {
                    bValid = false;
                    if (ErrorList != null)
                    {
                        ErrorList.Add("Err01409 : Ligne 1 (%Full) from the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(sTableName) + "\" have a mistake in the column \"" + sColumnName + "\" : The value is not valid.");
                        ErrorsPosition.setCondition(iColumn, 0, (String)ErrorList[ErrorList.Count - 1]);
                    }
                }
                //%C == %Y
                if ((dFirst < 0) || (dFirst > 100) || (dSecond < 0) || ((dFirst + dSecond) != 100))
                {
                    bValid = false;
                    if (ErrorList != null)
                    {
                        ErrorList.Add("Err01410 : Ligne 2 et 3 (%Y %C) from the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(sTableName) + "\" have a mistake in the column \"" + sColumnName + "\" : The values are not valid.");
                        ErrorsPosition.setCondition(iColumn, 1, (String)ErrorList[ErrorList.Count - 1]);
                        ErrorsPosition.setCondition(iColumn, 2, (String)ErrorList[ErrorList.Count - 1]);
                    }
                }
                //%Local == %NotLocal
                if ((dLocal < 0) || (dLocal > 100) || (dNotLocal < 0) || ((dLocal + dNotLocal) != 100))
                {
                    bValid = false;
                    if (ErrorList != null)
                    {
                        ErrorList.Add("Err01429 : Ligne 4 et 5 (%Local %Not local) from the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(sTableName) + "\" have a mistake in the column \"" + sColumnName + "\" : The values are not valid.");
                        ErrorsPosition.setCondition(iColumn, 3, (String)ErrorList[ErrorList.Count - 1]);
                        ErrorsPosition.setCondition(iColumn, 4, (String)ErrorList[ErrorList.Count - 1]);
                    }
                }
                //%Online Check In
                if ((dOnlineCheckIn < 0) || (dOnlineCheckIn > 100))
                {
                    bValid = false;
                    if (ErrorList != null)
                    {
                        ErrorList.Add("Err01411 : Ligne 6 (%Online Check In) from the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(sTableName) + "\" have a mistake in the column \"" + sColumnName + "\" : The value is not valid.");
                        ErrorsPosition.setCondition(iColumn, 5, (String)ErrorList[ErrorList.Count - 1]);
                    }
                }
                //%Terminating == %Transferring
                if ((dOriginating < 0) || (dOriginating > 100) || (dTransferring < 0) || ((dOriginating + dTransferring) != 100))
                {
                    bValid = false;
                    if (ErrorList != null)
                    {
                        ErrorList.Add("Err01412 : Ligne 7 et 8 (%Originating %Transferring) from the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(sTableName) + "\" have a mistake in the column \"" + sColumnName + "\" : The values are not valid.");
                        ErrorsPosition.setCondition(iColumn, 6, (String)ErrorList[ErrorList.Count - 1]);
                        ErrorsPosition.setCondition(iColumn, 7, (String)ErrorList[ErrorList.Count - 1]);
                    }
                }
                //%Re-Check
                if ((dReCheck < 0) || (dReCheck > 100))
                {
                    bValid = false;
                    if (ErrorList != null)
                    {
                        ErrorList.Add("Err01413 : Ligne 9 (%Re-Check) from the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(sTableName) + "\" have a mistake in the column \"" + sColumnName + "\" : The value is not valid.");
                        ErrorsPosition.setCondition(iColumn, 8, (String)ErrorList[ErrorList.Count - 1]);
                    }
                }
                //%Transfer Desk
                if ((dTransferDesk < 0) || (dTransferDesk > 100))
                {
                    bValid = false;
                    if (ErrorList != null)
                    {
                        ErrorList.Add("Err01414 : Ligne 10 (%Transfer-desk) from the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(sTableName) + "\" have a mistake in the column \"" + sColumnName + "\" : The value is not valid.");
                        ErrorsPosition.setCondition(iColumn, 9, (String)ErrorList[ErrorList.Count - 1]);
                    }
                }

                //>> AndreiZaharia / Mulhouse project
                //Number of passenger per car
                if (dPaxPerCar < 1)
                {
                    bValid = false;
                    if (ErrorList != null)
                    {
                        ErrorList.Add("Err01415 : Ligne 13 (Number of passenger per car) from the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(sTableName) + "\" have a mistake in the column \"" + sColumnName + "\" : The value is not valid.");
                        ErrorsPosition.setCondition(iColumn, 12, (String)ErrorList[ErrorList.Count - 1]);
                    }
                }
                //<< AndreiZaharia / Mulhouse project

                return bValid;
            }
            #endregion
            #endregion

            #region Fonction pour vérifier la table des capacités des queues
            private static Boolean CheckCapacityTable(DataTable table,
                                                     ArrayList ErrorList,
                                                     ConditionnalFormatErrors cfeErrors)
            {
                if (table.Rows.Count == 0)
                    return true;
                bool bValid = true;
                for (int i = 0; i < table.Rows.Count; i++)
                {
                    if (table.Rows[i][1].ToString().Length == 0)
                    {
                        bValid = false;
                        ErrorList.Add("Err01450 : The line " + (i + 1).ToString() + " the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(table.TableName) + "\" have a mistake : The value must be defined.");
                        cfeErrors.setCondition(1, i, (String)ErrorList[ErrorList.Count - 1]);
                        continue;
                    }
                    Int32 iValue = (Int32)table.Rows[i][1];
                    if ((iValue < -1) || (iValue == 0))
                    {
                        bValid = false;
                        ErrorList.Add("Err01451 : The line " + (i + 1).ToString() + " the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(table.TableName) + "\" have a mistake : The value must be -1 (for infinite) or bigger than 0.");
                        cfeErrors.setCondition(1, i, (String)ErrorList[ErrorList.Count - 1]);
                    }
                }
                return bValid;
            }
            #endregion

            // << Task #9412 Pax2Sim - Scenario parameters files - Settings and OpeningOnSaturation
            #region check Saturation Parameters table
            private static Boolean CheckSaturationTable(DataTable table,
                                                        ArrayList ErrorList,
                                                        ConditionnalFormatErrors cfeErrors)
            {
                int iIndex_Filling = table.Columns.IndexOf(GlobalNames.sSaturation_Filling);

                if (iIndex_Filling == -1)
                    return false;

                if (table.Rows.Count == 0)
                    return true;

                bool bValid = true;

                int rowNb = 0;
                foreach (DataRow drRow in table.Rows)
                {
                    String localFillingType = FonctionsType.getString(drRow[iIndex_Filling]);

                    if (!GlobalNames.ALLOWED_FILLIG_TYPES_LIST.Contains(localFillingType))
                    {
                        bValid = false;
                        ErrorList.Add("Error: The table \"" + DataManagement.DataManagerInput.ConvertToFullName(table.TableName)
                            + "\" has a mistake : The Filling Type must have one of the values: "
                            + GlobalNames.FIRST_STATION_FILLING_TYPE + ", " + GlobalNames.SATURATE_STATION_FILLING_TYPE + ", "
                            + GlobalNames.RANDOM_STATION_FILLING_TYPE + ".");
                        cfeErrors.setCondition(iIndex_Filling, rowNb, (String)ErrorList[ErrorList.Count - 1]);

                        rowNb++;
                        continue;
                    }
                    rowNb++;
                }
                return bValid;
            }
            #endregion
            // >> Task #9412 Pax2Sim - Scenario parameters files - Settings and OpeningOnSaturation

            #region Fonction pour vérifier les tables Passport, Security et Transfer
            private static Boolean CheckAllocationTables(DataTable table,
#if(!NEWALLOCATIONSECU)
                                                        bool bPassportTable,
#endif
 DataTable UserAttributesTable,      //>> Task #7405 - new Desk and extra information for Pax
 ArrayList ErrorList,
                                                        ConditionnalFormatErrors TableErrors)
            {
                if (table.Columns.Count == 1)
                    return true;
                if (table.Rows.Count == 0)
                    return true;
                //<< Task #7405 - new Desk and extra information for Pax                
                int iExtraColumns = 0;
                // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                int nbOfNonUserAttributesColumns = 0;
                // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                if (UserAttributesTable != null)
                {
                    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    foreach (DataRow dr in UserAttributesTable.Rows)
                    {
                        String userAttribute = dr[GlobalNames.sUserAttributes_ColumnName].ToString();
                        if (GlobalNames.nonUserAttributesExceptionsList.Contains(userAttribute))
                            nbOfNonUserAttributesColumns++;
                    }
                    iExtraColumns = UserAttributesTable.Rows.Count - nbOfNonUserAttributesColumns;
                    //iExtraColumns = UserAttributesTable.Rows.Count;
                    // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                }
                //>> Task #7405 - new Desk and extra information for Pax
                bool bValid = true;
                for (int i = 0; i < table.Rows.Count; i++)
                {
                    for (int j = 1; j < table.Columns.Count; j++)
                    {
#if(!NEWALLOCATIONSECU)
                        if (bPassportTable)
                        {
                            if (!OverallTools.DataFunctions.checkPassportValue(table.Rows[i][j].ToString()))
#else
                        if (!OverallTools.DataFunctions.checkPassportNewFormat(table.Rows[i][j].ToString(), iExtraColumns))
#endif
                        {
                            bValid = false;
                            ErrorList.Add("Err01448 : In the table \"" +
                                DataManagement.DataManagerInput.ConvertToFullName(table.TableName) + "\" The cell (" + i.ToString() + "," + j.ToString() + ") have a mistake : Values haven't a good format.");
                            TableErrors.setCondition(j, i, (String)ErrorList[ErrorList.Count - 1]);
                            continue;
                        }

#if(!NEWALLOCATIONSECU)
                        }
                        else
                        {
                            if ((table.Rows[i][j].ToString().Length == 0) ||
                                (((Double)(table.Rows[i][j]) < 0)))
                            {
                                bValid = false;
                                ErrorList.Add("Err01449 : In the table \"" + 
                                    DataManagement.DataManagerInput.ConvertToFullName(table.TableName) + "\" The cell (" + i.ToString() + "," + j.ToString() + ") have a mistake : Values haven't a good format.");
                                TableErrors.setCondition(j, i, (String)ErrorList[ErrorList.Count - 1]);
                                continue;
                            }
                        }                  
#endif
                    }
                }
                return bValid;
            }
            #endregion

            #region Fonction pour vérifier la structure de l'aéroport.


            private static bool CheckStructure(DataTable dtTable,
                                               System.Xml.XmlNode Structure,
                                               String[][] tsObjectType,
                                               String[][] tsPosition,
                                               Boolean[] CanBeNull,
                                               ArrayList ErrorList,
                                               ArrayList WarningList,
                                               ConditionnalFormatErrors cfeErrors,
                                               bool bAlphaNumerical,
                                               bool bCheckPaxSimulation,
                                               bool bCheckBagSimulation)
            {
                if (tsObjectType == null)
                    return true;
                bool bResult = true;
                for (int i = 0; i < tsObjectType.Length; i++)
                {
                    /**/
                    if (!bCheckPaxSimulation)
                    {
                        if (tsPosition[i][0] == GlobalNames.sFPD_A_Column_TerminalGate)
                            continue;
                    }
                    if (!bCheckBagSimulation)
                    {
                        if (tsPosition[i][0] == GlobalNames.sFPD_Column_TerminalMup)
                            continue;
                    }
                    bResult = CheckStructure(dtTable, Structure, tsObjectType[i], tsPosition[i], CanBeNull[i], ErrorList, WarningList, cfeErrors, bAlphaNumerical) && bResult;
                }
                return bResult;
            }

            private static System.Xml.XmlNode getParent(System.Xml.XmlNode Structure,
                                                        int iTerminal,
                                                        int iLevel,
                                                        int iIndexDesk,
                                                        String ObjectType)
            {
                System.Xml.XmlNode xnRacine = Structure;
                if ((iTerminal != -1) && (iLevel == -1))
                {
                    xnRacine = GestionDonneesHUB2SIM.getTerminal(Structure, iTerminal);
                }
                else if (iTerminal != -1)
                {
                    xnRacine = GestionDonneesHUB2SIM.getLevel(Structure, iTerminal, iLevel);
                }
                xnRacine = OverallTools.FonctionUtiles.LookForChild(xnRacine, ObjectType, iIndexDesk);
                if (xnRacine != null)
                    return xnRacine.ParentNode;
                return null;
            }

            private static System.Xml.XmlNode getParent(System.Xml.XmlNode Structure,
                                                        String sTerminal,
                                                        String sDesk,
                                                        String ObjectType)
            {
                System.Xml.XmlNode xnRacine = Structure;
                if ((sTerminal != ""))
                {
                    xnRacine = GestionDonneesHUB2SIM.getTerminalByDescription(Structure, sTerminal);
                }
                xnRacine = OverallTools.FonctionUtiles.LookForChild(xnRacine, ObjectType, sDesk);
                if (xnRacine != null)
                    return xnRacine.ParentNode;
                return null;
            }
            private static bool CheckStructure(DataTable dtTable,
                                                 System.Xml.XmlNode Structure,
                                                 String[] tsObjectType,
                                                 String[] tsPosition,
                                                 Boolean bCanBeNull,
                                                 ArrayList ErrorList,
                                                 ArrayList WarningList,
                                                 ConditionnalFormatErrors cfeErrors,
                                                 bool bAlphaNumerical)
            {
                dtTable.AcceptChanges();
                if (Structure == null)
                    return true;
                if (dtTable.Rows.Count == 0)
                    return true;
                if ((tsPosition == null) || (tsPosition.Length < 3) || (tsObjectType == null) || (tsObjectType.Length == 0))
                    return true;
                #region Partie pour les noms des objets
                String sGroupName = "";
                String sObjectName = "";
                if (tsObjectType.Length == 1)
                {
                    sObjectName = tsObjectType[0];
                }
                else
                {
                    sGroupName = tsObjectType[0];
                    sObjectName = tsObjectType[1];
                }
                #endregion
                #region Partie pour les noms des colonnes.
                String sTerminalObject = tsPosition[0];
                String sLevelObject = tsPosition[1];
                String sIndexBeginObject = tsPosition[2];
                String sIndexEndObject = "";
                if (tsPosition.Length == 4)
                    sIndexEndObject = tsPosition[3];
                if (sTerminalObject != "")
                {
                    if (
                        (dtTable.Columns[sTerminalObject].DataType != typeof(String)) &&
                        (dtTable.Columns[sTerminalObject].DataType != typeof(string)))
                    {
                        ErrorList.Add("Err01434 : The column for the terminal does not have the right type in the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(dtTable.TableName) + "\".");
                        return false;
                    }
                }
                if (sLevelObject != "")
                {
                    if ((dtTable.Columns[sLevelObject].DataType != typeof(String)) &&
                        (dtTable.Columns[sLevelObject].DataType != typeof(string)))
                    {
                        ErrorList.Add("Err01433 : The column for the level does not have the right type in the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(dtTable.TableName) + "\".");
                        return false;
                    }
                }
                if (sIndexBeginObject != "")
                {
                    if ((dtTable.Columns[sIndexBeginObject].DataType != typeof(String)) &&
                        (dtTable.Columns[sIndexBeginObject].DataType != typeof(string)))
                    {
                        ErrorList.Add("Err01432 : The column \"" + sIndexBeginObject + "\" does not have the right type in the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(dtTable.TableName) + "\".");
                        return false;
                    }
                }
                if (sIndexEndObject != "")
                {
                    if ((dtTable.Columns[sIndexEndObject].DataType != typeof(String)) &&
                        (dtTable.Columns[sIndexEndObject].DataType != typeof(string)))
                    {
                        ErrorList.Add("Err01441 : The column \"" + sIndexEndObject + "\" does not have the right type in the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(dtTable.TableName) + "\".");
                        return false;
                    }
                }
                #endregion

                int iTerminal = dtTable.Columns.IndexOf(sTerminalObject);
                int iLevel = dtTable.Columns.IndexOf(sLevelObject);
                int iBeginObject = dtTable.Columns.IndexOf(sIndexBeginObject);
                int iEndObject = dtTable.Columns.IndexOf(sIndexEndObject);

                bool Result = true;

                for (int i = 0; i < dtTable.Rows.Count; i++)
                {
                    DataRow ligne = dtTable.Rows[i];
                    int iTerminalValue = iTerminal;
                    int iLevelValue = iLevel;
                    int iBeginObjectValue = iBeginObject;
                    int iEndObjectValue = iEndObject;
                    String sTerminalValue = "";
                    String sLevelValue = "";
                    String sBeginObjectValue = "";
                    String sEndObjectValue = "";
                    System.Xml.XmlNode Group = null;
                    if (iTerminalValue != -1)
                        sTerminalValue = ligne.ItemArray[iTerminal].ToString();
                    if (iLevelValue != -1)
                        sLevelValue = ligne.ItemArray[iLevel].ToString();
                    if (iBeginObjectValue != -1)
                        sBeginObjectValue = ligne.ItemArray[iBeginObject].ToString();
                    if (iEndObjectValue != -1)
                        sEndObjectValue = ligne.ItemArray[iEndObject].ToString();
                    if (bAlphaNumerical)
                    {
                        Group = getParent(Structure, sTerminalValue, sBeginObjectValue, sObjectName);
                    }
                    else
                    {
                        if (!Int32.TryParse(sTerminalValue, out iTerminalValue))
                            iTerminalValue = -1;
                        if (!Int32.TryParse(sLevelValue, out iLevelValue))
                            iLevelValue = -1;
                        if (!Int32.TryParse(sBeginObjectValue, out iBeginObjectValue))
                            iBeginObjectValue = -1;//iBeginObject = -1; // >> Bug #14888 Pax Capacity launcher blocking Simulation for dummy reason
                        if (!Int32.TryParse(sEndObjectValue, out iEndObjectValue))
                            iEndObjectValue = -1; //iEndObject = -1;    // >> Bug #14888 Pax Capacity launcher blocking Simulation for dummy reason
                        Group = getParent(Structure, iTerminalValue, iLevelValue, iBeginObjectValue, sObjectName);
                    }

                    if ((Group == null) && (bCanBeNull) && (((iBeginObjectValue < 1) && (iEndObjectValue < 1)) ||
                                                            ((sBeginObjectValue == "") && (sEndObjectValue == ""))))
                        continue;
                    if (Group == null)
                    {
                        String Error = "Err01394 : Ligne " + (i + 1).ToString() + "  from the table \"" + dtTable.TableName + "\" has a mistake. The airport does not have an object";
                        Error += " of type " + sObjectName;
                        if (bAlphaNumerical)
                        {
                            if (sTerminalValue != "")
                                Error += " in Terminal " + sTerminalValue;
                            if (sLevelValue != "")
                                Error += " and level " + sLevelValue;
                            Error += " with the index " + sBeginObjectValue;
                        }
                        else
                        {
                            if (iTerminalValue != -1)
                                Error += " in Terminal " + iTerminalValue.ToString();
                            if (iLevelValue != -1)
                                Error += " and level " + iLevelValue.ToString();
                            Error += " with the index " + iBeginObjectValue.ToString();
                        }
                        if (sObjectName == GlobalNames.AIRCRAFT_PARKING_STAND_OBJECT_NAME)    // >> Bug #14888 Pax Capacity launcher blocking Simulation for dummy reason
                        {
                            Error = Error.Replace("Err01394", "Warn01394");
                            WarningList.Add(Error);
                            cfeErrors.setCondition(iBeginObject, i, "", Error);
                        }
                        else
                        {
                            ErrorList.Add(Error);
                            cfeErrors.setCondition(iBeginObject, i, Error);
                        }

                        Result = false;
                    }
                    else
                    {
                        if ((bAlphaNumerical) && (sEndObjectValue != "") && (OverallTools.FonctionUtiles.ChildExist(Group, sObjectName, sEndObjectValue) == null))
                        {
                            Group = getParent(Structure, sTerminalValue, sEndObjectValue, sObjectName);
                            String Error;
                            if (Group != null)
                            {
                                Error = "Warn1395 : Ligne " + (i + 1).ToString() + "  from the table \"" +
                                    DataManagement.DataManagerInput.ConvertToFullName(dtTable.TableName) + "\" may has a mistake. The group does not contain";
                                Error += " the " + sObjectName + " with index " + sEndObjectValue.ToString();
                                WarningList.Add(Error);
                                cfeErrors.setCondition(iEndObject, i, "", Error);
                            }
                            else
                            {
                                Error = "Err1395b : Ligne " + (i + 1).ToString() + "  from the table \"" +
                                    DataManagement.DataManagerInput.ConvertToFullName(dtTable.TableName) + "\" has a mistake. The airport does not have an object";
                                Error += " of type " + sObjectName;
                                if (sTerminalValue != "")
                                    Error += " in Terminal " + sTerminalValue.ToString();
                                if (sLevelValue != "")
                                    Error += " and level " + sLevelValue.ToString();
                                Error += " with the index " + sEndObjectValue.ToString();
                                if (sObjectName == GlobalNames.AIRCRAFT_PARKING_STAND_OBJECT_NAME)    // >> Bug #14888 Pax Capacity launcher blocking Simulation for dummy reason
                                {
                                    Error = Error.Replace("Err1395", "Warn1395");
                                    WarningList.Add(Error);
                                    cfeErrors.setCondition(iEndObject, i, "", Error);
                                }
                                else
                                {
                                    ErrorList.Add(Error);
                                    cfeErrors.setCondition(iEndObject, i, Error);
                                }
                            }
                            Result = false;
                        }
                        else if ((!bAlphaNumerical) && (iEndObjectValue > 0) && (OverallTools.FonctionUtiles.ChildExist(Group, sObjectName, iEndObjectValue) == null))
                        {
                            Group = getParent(Structure, iTerminalValue, iLevelValue, iEndObjectValue, sObjectName);
                            String Error;
                            if (Group != null)
                            {
                                Error = "Warn1395 : Ligne " + (i + 1).ToString() + "  from the table \"" + dtTable.TableName + "\" has a mistake. The group does not contain";
                                Error += " the " + sObjectName + " with index " + iEndObjectValue.ToString();
                                WarningList.Add(Error);
                                cfeErrors.setCondition(iEndObject, i, "", Error);
                            }
                            else
                            {
                                Error = "Err1395b : Ligne " + (i + 1).ToString() + "  from the table \"" +
                                    DataManagement.DataManagerInput.ConvertToFullName(dtTable.TableName) + "\" has a mistake. The airport does not have an object";
                                Error += " of type " + sObjectName;
                                if (iTerminalValue != -1)
                                    Error += " in Terminal " + iTerminalValue.ToString();
                                if (iLevelValue != -1)
                                    Error += " and level " + iLevelValue.ToString();
                                Error += " with the index " + iEndObjectValue.ToString();

                                if (sObjectName == GlobalNames.AIRCRAFT_PARKING_STAND_OBJECT_NAME)    // >> Bug #14888 Pax Capacity launcher blocking Simulation for dummy reason
                                {
                                    Error = Error.Replace("Err1395", "Warn1395");
                                    WarningList.Add(Error);
                                    cfeErrors.setCondition(iEndObject, i, "", Error);
                                }
                                else
                                {
                                    ErrorList.Add(Error);
                                    cfeErrors.setCondition(iEndObject, i, Error);
                                }
                            }
                            Result = false;
                        }
                        if ((iEndObject > 0) && (iEndObjectValue < iBeginObjectValue))
                        {
                            String Error = "Err01396 : Ligne " + (i + 1).ToString() + "  from the table \"" + dtTable.TableName + "\" has a mistake. The allocation range ";
                            Error += "is not good, the value in the column \"" + dtTable.Columns[iEndObject].ColumnName + "\" must be greater than the value in the column \"" + dtTable.Columns[iBeginObject].ColumnName + "\".";
                            WarningList.Add(Error);
                            cfeErrors.setCondition(iEndObject, i, Error);
                            Result = false;
                        }
                    }
                }
                return Result;
            }
            #endregion

            #region Vérification des informations contenues dans la table ProcessTable

            internal static Boolean CheckProcessTable(DataTable table,
                                       DataTable OneOfTable,
                                       ArrayList ErrorList,
                                       ConditionnalFormatErrors TableErrors)
            {
                if (table.Rows.Count == 0)
                    return true;
                Boolean bValid = true;
                int iIndexNomDistribution = table.Columns.IndexOf("Distrib_1");
                int iIndexParam1 = table.Columns.IndexOf("Param1_1");
                int iIndexParam2 = table.Columns.IndexOf("Param2_1");
                int iIndexParam3 = table.Columns.IndexOf("Param3_1");

                int iIndexNomDistribution2 = table.Columns.IndexOf("Distrib_2");
                int iIndexParam1_2 = table.Columns.IndexOf("Param1_2");
                int iIndexParam2_2 = table.Columns.IndexOf("Param2_2");
                int iIndexParam3_2 = table.Columns.IndexOf("Param3_2");

                // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                int iIndexNomDistribution3 = table.Columns.IndexOf(GlobalNames.sProcessTable_Distrib_3);
                int iIndexParam1_3 = table.Columns.IndexOf(GlobalNames.sProcessTable_Param1_3);
                int iIndexParam2_3 = table.Columns.IndexOf(GlobalNames.sProcessTable_Param2_3);
                int iIndexParam3_3 = table.Columns.IndexOf(GlobalNames.sProcessTable_Param3_3);
                // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)

                if ((iIndexNomDistribution < 0) ||
                    (iIndexParam1 < 0) ||
                    (iIndexParam2 < 0) ||
                    (iIndexParam3 < 0) ||
                    (iIndexNomDistribution2 < 0) ||
                    (iIndexParam1_2 < 0) ||
                    (iIndexParam2_2 < 0) ||
                    (iIndexParam3_2 < 0)
                    // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                    || iIndexNomDistribution3 < 0
                    || iIndexParam1_3 < 0 || iIndexParam2_3 < 0 || iIndexParam3_3 < 0
                    // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                    )
                {
                    ErrorList.Add("Err01417 : The table Proccess table does not have a good format");
                    return false;
                }
                ArrayList DistributionList = OverallTools.DataFunctions.getDistributions(OneOfTable);
                for (int i = 0; i < table.Rows.Count; i++)
                {
                    DataRow Ligne = table.Rows[i];
                    int[] SelectedGroup = OverallTools.DataFunctions.AnalyzeGroupName((String)Ligne[0]);
                    if (SelectedGroup == null)
                        continue;
                    bool bSecondDistribution = (SelectedGroup[2] == GestionDonneesHUB2SIM.BaggageClaimGroup) ||
                        (SelectedGroup[2] == GestionDonneesHUB2SIM.CheckInGroup) ||
                        (SelectedGroup[2] == GestionDonneesHUB2SIM.PassportCheckGroup);
                    String sDistribution = "";
                    if (Ligne[iIndexNomDistribution].ToString().Length != 0)
                    {
                        sDistribution = Ligne[iIndexNomDistribution].ToString();
                        //if (!FonctionUtiles.CheckDistributionName(sDistribution))
                        unsafe
                        {

#if!(UNIKEY_PROTECTION)
                            if (!FonctionUtiles.o(sDistribution))
#else
                            if(!OverallTools.Unikey.Distributions(sDistribution))
#endif
                            {
                                if (!DistributionList.Contains(sDistribution))
                                {
                                    bValid = false;
                                    ErrorList.Add("Err01418 : Ligne " + (i + 1).ToString() + " from the table \"" +
                                        DataManagement.DataManagerInput.ConvertToFullName(table.TableName) + "\" have a mistake in the distribution column : The distribution name is not valid.");
                                    TableErrors.setCondition(iIndexNomDistribution, i, (String)ErrorList[ErrorList.Count - 1]);
                                }
                            }
                            else
                            {
                                Double FirstParam = 0;
                                Double SecondParam = 0;
                                Double ThirdParam = 0;
                                if (Ligne[iIndexParam1].ToString().Length != 0)
                                    FirstParam = (Double)Ligne[iIndexParam1];

                                if (Ligne[iIndexParam2].ToString().Length != 0)
                                    SecondParam = (Double)Ligne[iIndexParam2];

                                if (Ligne[iIndexParam3].ToString().Length != 0)
                                    ThirdParam = (Double)Ligne[iIndexParam3];
                                bool bSecondParameter;
                                bool bThirdParameter;
                                String sMessage;
                                FonctionUtiles.NbParams(sDistribution, out bSecondParameter, out bThirdParameter);
                                if ((!bThirdParameter) && (ThirdParam != 0))
                                {
                                    bValid = false;
                                    ErrorList.Add("Err01419 : Ligne " + (i + 1).ToString() + " from the table \"" +
                                        DataManagement.DataManagerInput.ConvertToFullName(table.TableName) + "\" have a mistake : The param is not used and must be null.");
                                    TableErrors.setCondition(iIndexParam3, i, (String)ErrorList[ErrorList.Count - 1]);
                                }
                                else if ((!bSecondParameter) && (SecondParam != 0))
                                {
                                    bValid = false;
                                    ErrorList.Add("Err01420 : Ligne " + (i + 1).ToString() + " from the table \"" +
                                        DataManagement.DataManagerInput.ConvertToFullName(table.TableName) + "\" have a mistake : The param is not used and must be null.");
                                    TableErrors.setCondition(iIndexParam2, i, (String)ErrorList[ErrorList.Count - 1]);
                                }
                                else if (!FonctionUtiles.checkParams(sDistribution, FirstParam, SecondParam, ThirdParam, out sMessage))
                                {
                                    bValid = false;
                                    ErrorList.Add("Err01421 : Ligne " + (i + 1).ToString() + " from the table \"" +
                                        DataManagement.DataManagerInput.ConvertToFullName(table.TableName) + "\" have a mistake :" + sMessage);
                                    TableErrors.setCondition(iIndexNomDistribution, i, (String)ErrorList[ErrorList.Count - 1]);
                                    TableErrors.setCondition(iIndexParam1, i, (String)ErrorList[ErrorList.Count - 1]);
                                    TableErrors.setCondition(iIndexParam2, i, (String)ErrorList[ErrorList.Count - 1]);
                                    TableErrors.setCondition(iIndexParam3, i, (String)ErrorList[ErrorList.Count - 1]);
                                }
                            }
                        }
                    }
                    else
                    {
                        bValid = false;
                        ErrorList.Add("Err01422 : Ligne " + (i + 1).ToString() + " from the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(table.TableName) + "\" have a mistake in the distribution column : The value must be defined.");
                        TableErrors.setCondition(iIndexNomDistribution, i, (String)ErrorList[ErrorList.Count - 1]);
                    }

                    // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                    //Every Group has the 3rd Distribution, which is related to the Delay time after which the passenger can begin queuing
                    if (Ligne[iIndexNomDistribution3].ToString().Length != 0)
                    {
                        sDistribution = Ligne[iIndexNomDistribution3].ToString();

#if!(UNIKEY_PROTECTION)
                        if (!FonctionUtiles.o(sDistribution))
#else
                        if (!OverallTools.Unikey.Distributions(sDistribution))
#endif
                        {

                            if (!DistributionList.Contains(sDistribution))
                            {
                                bValid = false;
                                ErrorList.Add("Err01424 : Ligne " + (i + 1).ToString() + " from the table \"" +
                                    DataManagement.DataManagerInput.ConvertToFullName(table.TableName) + "\" have a mistake in the distribution column : The distribution name is not valid.");
                                TableErrors.setCondition(iIndexNomDistribution3, i, (String)ErrorList[ErrorList.Count - 1]);
                            }
                        }
                        else
                        {
                            Double FirstParam = 0;
                            Double SecondParam = 0;
                            Double ThirdParam = 0;
                            if (Ligne[iIndexParam1_3].ToString().Length != 0)
                                FirstParam = (Double)Ligne[iIndexParam1_3];

                            if (Ligne[iIndexParam2_3].ToString().Length != 0)
                                SecondParam = (Double)Ligne[iIndexParam2_3];

                            if (Ligne[iIndexParam3_3].ToString().Length != 0)
                                ThirdParam = (Double)Ligne[iIndexParam3_3];
                            bool bSecondParameter;
                            bool bThirdParameter;
                            String sMessage;
                            FonctionUtiles.NbParams(sDistribution, out bSecondParameter, out bThirdParameter);
                            if ((!bThirdParameter) && (ThirdParam != 0))
                            {
                                bValid = false;
                                ErrorList.Add("Err01425 : Ligne " + (i + 1).ToString() + " from the table \"" +
                                    DataManagement.DataManagerInput.ConvertToFullName(table.TableName) + "\" have a mistake : The param is not used and must be null.");
                                TableErrors.setCondition(iIndexParam3_3, i, (String)ErrorList[ErrorList.Count - 1]);
                            }
                            else if ((!bSecondParameter) && (SecondParam != 0))
                            {
                                bValid = false;
                                ErrorList.Add("Err01426 : Ligne " + (i + 1).ToString() + " from the table \"" +
                                    DataManagement.DataManagerInput.ConvertToFullName(table.TableName) + "\" have a mistake : The param is not used and must be null.");
                                TableErrors.setCondition(iIndexParam2_3, i, (String)ErrorList[ErrorList.Count - 1]);
                            }
                            else if (!FonctionUtiles.checkParams(sDistribution, FirstParam, SecondParam, ThirdParam, out sMessage))
                            {
                                bValid = false;
                                ErrorList.Add("Err01427 : Ligne " + (i + 1).ToString() + " from the table \"" +
                                    DataManagement.DataManagerInput.ConvertToFullName(table.TableName) + "\" have a mistake :" + sMessage);
                                TableErrors.setCondition(iIndexNomDistribution3, i, (String)ErrorList[ErrorList.Count - 1]);
                                TableErrors.setCondition(iIndexParam1_3, i, (String)ErrorList[ErrorList.Count - 1]);
                                TableErrors.setCondition(iIndexParam2_3, i, (String)ErrorList[ErrorList.Count - 1]);
                                TableErrors.setCondition(iIndexParam3_3, i, (String)ErrorList[ErrorList.Count - 1]);
                            }
                        }
                    }
                    else
                    {
                        bValid = false;
                        ErrorList.Add("Err01428 : Ligne " + (i + 1).ToString() + " from the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(table.TableName) + "\" have a mistake in the distribution column : The value must be defined.");
                        TableErrors.setCondition(iIndexNomDistribution3, i, (String)ErrorList[ErrorList.Count - 1]);
                    }
                    // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)

                    if (!bSecondDistribution)
                    {
                        if (((Ligne[iIndexParam1_2].ToString().Length != 0) && ((Double)(Ligne[iIndexParam1_2]) != 0)) ||
                            ((Ligne[iIndexParam2_2].ToString().Length != 0) && ((Double)(Ligne[iIndexParam2_2]) != 0)) ||
                            ((Ligne[iIndexParam3_2].ToString().Length != 0) && ((Double)(Ligne[iIndexParam3_2]) != 0)) ||
                            (Ligne[iIndexNomDistribution2].ToString().Length != 0))
                        {
                            bValid = false;
                            ErrorList.Add("Err01423 : Ligne " + (i + 1).ToString() + " from the table \"" +
                                DataManagement.DataManagerInput.ConvertToFullName(table.TableName) + "\" have a mistake : The second distribution mustn't be defined.");
                            TableErrors.setCondition(iIndexNomDistribution2, i, (String)ErrorList[ErrorList.Count - 1]);
                            TableErrors.setCondition(iIndexParam1_2, i, (String)ErrorList[ErrorList.Count - 1]);
                            TableErrors.setCondition(iIndexParam2_2, i, (String)ErrorList[ErrorList.Count - 1]);
                            TableErrors.setCondition(iIndexParam3_2, i, (String)ErrorList[ErrorList.Count - 1]);
                        }
                        continue;
                    }

                    if (Ligne[iIndexNomDistribution2].ToString().Length != 0)
                    {
                        sDistribution = Ligne[iIndexNomDistribution2].ToString();

#if!(UNIKEY_PROTECTION)
                        if (!FonctionUtiles.o(sDistribution))
#else
                        if (!OverallTools.Unikey.Distributions(sDistribution))
#endif
                        {

                            if (!DistributionList.Contains(sDistribution))
                            {
                                bValid = false;
                                ErrorList.Add("Err01424 : Ligne " + (i + 1).ToString() + " from the table \"" +
                                    DataManagement.DataManagerInput.ConvertToFullName(table.TableName) + "\" have a mistake in the distribution column : The distribution name is not valid.");
                                TableErrors.setCondition(iIndexNomDistribution2, i, (String)ErrorList[ErrorList.Count - 1]);
                            }
                        }
                        else
                        {
                            Double FirstParam = 0;
                            Double SecondParam = 0;
                            Double ThirdParam = 0;
                            if (Ligne[iIndexParam1_2].ToString().Length != 0)
                                FirstParam = (Double)Ligne[iIndexParam1_2];

                            if (Ligne[iIndexParam2_2].ToString().Length != 0)
                                SecondParam = (Double)Ligne[iIndexParam2_2];

                            if (Ligne[iIndexParam3_2].ToString().Length != 0)
                                ThirdParam = (Double)Ligne[iIndexParam3_2];
                            bool bSecondParameter;
                            bool bThirdParameter;
                            String sMessage;
                            FonctionUtiles.NbParams(sDistribution, out bSecondParameter, out bThirdParameter);
                            if ((!bThirdParameter) && (ThirdParam != 0))
                            {
                                bValid = false;
                                ErrorList.Add("Err01425 : Ligne " + (i + 1).ToString() + " from the table \"" +
                                    DataManagement.DataManagerInput.ConvertToFullName(table.TableName) + "\" have a mistake : The param is not used and must be null.");
                                TableErrors.setCondition(iIndexParam3_2, i, (String)ErrorList[ErrorList.Count - 1]);
                            }
                            else if ((!bSecondParameter) && (SecondParam != 0))
                            {
                                bValid = false;
                                ErrorList.Add("Err01426 : Ligne " + (i + 1).ToString() + " from the table \"" +
                                    DataManagement.DataManagerInput.ConvertToFullName(table.TableName) + "\" have a mistake : The param is not used and must be null.");
                                TableErrors.setCondition(iIndexParam2_2, i, (String)ErrorList[ErrorList.Count - 1]);
                            }
                            else if (!FonctionUtiles.checkParams(sDistribution, FirstParam, SecondParam, ThirdParam, out sMessage))
                            {
                                bValid = false;
                                ErrorList.Add("Err01427 : Ligne " + (i + 1).ToString() + " from the table \"" +
                                    DataManagement.DataManagerInput.ConvertToFullName(table.TableName) + "\" have a mistake :" + sMessage);
                                TableErrors.setCondition(iIndexNomDistribution2, i, (String)ErrorList[ErrorList.Count - 1]);
                                TableErrors.setCondition(iIndexParam1_2, i, (String)ErrorList[ErrorList.Count - 1]);
                                TableErrors.setCondition(iIndexParam2_2, i, (String)ErrorList[ErrorList.Count - 1]);
                                TableErrors.setCondition(iIndexParam3_2, i, (String)ErrorList[ErrorList.Count - 1]);
                            }
                        }
                    }
                    else
                    {
                        bValid = false;
                        ErrorList.Add("Err01428 : Ligne " + (i + 1).ToString() + " from the table \"" +
                            DataManagement.DataManagerInput.ConvertToFullName(table.TableName) + "\" have a mistake in the distribution column : The value must be defined.");
                        TableErrors.setCondition(iIndexNomDistribution2, i, (String)ErrorList[ErrorList.Count - 1]);
                    }
                }
                return bValid;
            }
            #endregion

            #region Vérification de la table pour les liens entre vols (Aircraft links table)
            private bool CheckAircraftLinkTable(DataTable dtFPDTable,
                                       DataTable dtFPATable,
                                       DataTable dtAircraftLinkTable,
                                       ArrayList ErrorList,
                                       ConditionnalFormatErrors TableErrors)
            {
                if (dtAircraftLinkTable == null)
                    return true;
                if (dtFPDTable == null)
                    return true;
                if (dtFPATable == null)
                    return true;
                Dictionary<Int32, TableInformations.FlightInformation> FPA = TableInformations.getFlightsInformation(dtFPATable);
                if (FPA == null)
                    return true;
                Dictionary<Int32, TableInformations.FlightInformation> FPD = TableInformations.getFlightsInformation(dtFPDTable);
                if (FPD == null)
                    return true;

                int iIndexFPA = dtAircraftLinkTable.Columns.IndexOf(GlobalNames.sFPLinks_Column_FPAID);
                int iIndexFPD = dtAircraftLinkTable.Columns.IndexOf(GlobalNames.sFPLinks_Column_FPDID);
                if ((iIndexFPA == -1) || (iIndexFPD == -1))
                {
                    return false;
                }
                foreach (DataRow drLine in dtAircraftLinkTable.Rows)
                {
                    String sFPDID = drLine[iIndexFPD].ToString();
                    if (sFPDID == "")
                        continue;
                    int iFPAID = (int)drLine[iIndexFPA];

                    if (!FPA.ContainsKey(iFPAID))
                        return false;
                    int iFPDID;
                    if (!Int32.TryParse(sFPDID, out iFPDID))
                        return false;
                    if (!FPD.ContainsKey(iFPDID))
                        return false;
                    if (FPA[iFPAID].Time > FPD[iFPDID].Time)
                        return false;
                }
                return true;
            }
            #endregion

            #region Vérification des table de type Transfert Distribution (Transfert Termial Distribution et Transfert Flight Category Distribution)
            private bool CheckTransfertDistributionTable(DataTable dtTDTable,
                                       ArrayList ErrorList,
                                       ConditionnalFormatErrors TableErrors)
            {
                bool bResult = true;
                if (dtTDTable == null)
                    return true;
                int sum = 0;
                for (int i = 0; i < dtTDTable.Rows.Count; i++)
                {
                    sum = 0;
                    DataRow dr = dtTDTable.Rows[i];
                    foreach (Object cell in dr.ItemArray)
                    {
                        int item;
                        if (Int32.TryParse(cell.ToString(), out item))
                            sum += item;
                    }
                    if (sum != 100)
                    {
                        ErrorList.Add("Err00772 : The sum of the line " + (i + 1).ToString() + " for the table " +
                            DataManagement.DataManagerInput.ConvertToFullName(dtTDTable.TableName) + " must be 100.");
                        for (int j = 0; j < dtTDTable.Columns.Count; j++)
                            TableErrors.setCondition(j, i, (String)ErrorList[ErrorList.Count - 1]);
                        bResult = false;
                    }
                }
                return bResult;
            }
            #endregion
        }
        #endregion

        #region La classe StaticAnalysis

        /*The modification made by Sebastien Geffroy on week from 26/03/2012 to 30/03/2012 will be marked by :
         //SGE-26/03/2012-Begin
         //SGE-26/03/2012-End
         These modificatons are meant to add information in the paxplan and creating a PRKPLan to calculate
         the use of the parkings for car in an airport.
         */
        /*The modifications linked to the EBS informations would be marked with the informations : 
         //SGE-03/04/2012-Begin
         //SGE-03/04/2012-End
         These modifications are to calculate the EBS needs for the given airport linked to the number of bags that will go in the EBS
         for every departure flights.
         */
        public class StaticAnalysis
        {
            //Err00400==> Err00422
            #region Functions to calculate the static occupation of the airport for departure flights.

            #region nouvelle fonction pour le calcul de l'analyse statique.
            /// <summary>
            /// This function generate all the tables for the static analysis for 
            /// the departure flights.
            /// </summary>
            /// <param name="dtFlightPlans">The departure flight plan to analyse</param>
            /// <param name="dtLoadFactors">The departure load factor (Exception table)</param>
            /// <param name="dtAircraftType">The aircraft type to calculate the number of seats. (Exception table)</param>
            /// <param name="dtShowUpProfile">The Check In show up profile to calculate the profile of passengers for CheckIn ShowUp statistics.(Exception table)</param>
            /// <param name="dtOCTCheckIn">The opening and closing times for the Check In. (Exception table)</param>
            /// <param name="dtNbBags">The number of baggages per passengers. (Exception table)</param>
            /// <param name="dtNbVisitors">The number of visitors per passengers. (Exception table)</param>
            /// <param name="dtNbTrolley">The number of trolley linked to the number of Baggages. (Exception table)</param>
            /// <param name="dtFlightCategories">The table of flight categories</param>
            /// <param name="dtBegin">The starting date for the analysis.</param>
            /// <param name="dtEnd">The ending date for the analysis.</param>
            /// <param name="dStepAnalysis">This step should be smaller or equal to 60min and should be bigger than \ref dStepCumul.</param>
            /// <param name="dStepCumul">For the instantaneours calculation, this is the number of slot (in minutes) that should be considered for the calculation.</param>
            /// <param name="bUseStatisticStep">[Not used]</param>
            /// <param name="dStatisticStep">[Not used]</param>
            /// <param name="sStatisticMode">[Not used]</param>
            /// <param name="ListeErreurs">The array list that would contains all errors if any.</param>
            /// <returns>Return an hastable which contains all the calculated tables.</returns>
            internal static ArrayList CalcStaticAnalysis2(DataTable dtFlightPlans,
                DataManagement.NormalTable dtLoadFactors,
                DataManagement.NormalTable dtAircraftType,
                DataManagement.NormalTable dtShowUpProfile,
                DataManagement.NormalTable dtOCTCheckIn,
                DataManagement.NormalTable dtNbBags,
                DataManagement.NormalTable dtNbVisitors,
                DataManagement.NormalTable dtNbTrolley,
                DataTable dtFlightCategories,
                DateTime dtBegin,
                DateTime dtEnd,
                Double samplingStep,
                Double analysisRange,
                bool bUseStatisticStep,
                Double dStatisticStep,
                String sStatisticMode,
                ArrayList ListeErreurs,
                // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                bool bUseDefinedNbPax,
                DataTable dtNumberOfPassengers,
                bool bUseDefinedNbBags,
                DataTable dtNumberOfBaggages
                // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                , double[] distributionLevels,   // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                NormalTable interConnectingTimesTable,   // >> Bug #11860 Pax2Sim - Static analysis - EBS calculation FB exception 2
                List<FlightConfiguration> userDefineFlightConfigurations    // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                )
            {
                int i, j;
                #region We check for empty tables and wrong parameters
                if (dtFlightPlans.Rows.Count == 0)
                {
                    ListeErreurs.Add("Err00400 : Unable to calc the static results. The flight plan table for departures must contain a row.");
                    return null;
                }
                if (dtFlightCategories.Rows.Count == 0)
                {
                    ListeErreurs.Add("Err00402 : Unable to calc the static results. There is no defined flight categories.");
                    return null;
                }

                // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                if (dtBegin >= dtEnd)
                {
                    ListeErreurs.Add("Unable to calculate the static results. Please review the time interval set for the simultation.(Begin and End dates)");
                    return null;
                }
                // >> Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns

                DataManagement.ExceptionTable etLoadFactors;
                if (dtLoadFactors is DataManagement.ExceptionTable)
                    etLoadFactors = (DataManagement.ExceptionTable)dtLoadFactors;
                else
                    return null;

                DataManagement.ExceptionTable etAircraftType;
                if (dtAircraftType is DataManagement.ExceptionTable)
                    etAircraftType = (DataManagement.ExceptionTable)dtAircraftType;
                else
                    return null;

                DataManagement.ExceptionTable etShowUpProfile;
                if (dtShowUpProfile is DataManagement.ExceptionTable)
                    etShowUpProfile = (DataManagement.ExceptionTable)dtShowUpProfile;
                else
                    return null;

                DataManagement.ExceptionTable etOCTCheckIn;
                if (dtOCTCheckIn is DataManagement.ExceptionTable)
                    etOCTCheckIn = (DataManagement.ExceptionTable)dtOCTCheckIn;
                else
                    return null;

                DataManagement.ExceptionTable etNbBags;
                if (dtNbBags is DataManagement.ExceptionTable)
                    etNbBags = (DataManagement.ExceptionTable)dtNbBags;
                else
                    return null;

                DataManagement.ExceptionTable etNbVisitors;
                if (dtNbVisitors is DataManagement.ExceptionTable)
                    etNbVisitors = (DataManagement.ExceptionTable)dtNbVisitors;
                else
                    return null;

                DataManagement.ExceptionTable etNbTrolley;
                if (dtNbTrolley is DataManagement.ExceptionTable)
                    etNbTrolley = (DataManagement.ExceptionTable)dtNbTrolley;
                else
                    return null;

                DataManagement.ExceptionTable etICTTable;
                if (interConnectingTimesTable is DataManagement.ExceptionTable)
                    etICTTable = (DataManagement.ExceptionTable)interConnectingTimesTable;
                else
                    return null;

                if ((dtBegin > dtEnd) /*|| (dtBegin.AddDays(7)<dtEnd)*/)
                {
                    ListeErreurs.Add("Err00406 : Unable to calc the static results. The dates are not valids.");
                    return null;
                }
                if ((samplingStep < 1) || (samplingStep > 60))
                {
                    ListeErreurs.Add("Err00407 : Unable to calc the static results. The analysis step is not valid.");
                    return null;
                }
                if ((analysisRange < 1) || (analysisRange > 60))
                {
                    ListeErreurs.Add("Err00408 : Unable to calc the static results. The analysis step is not valid.");
                    return null;
                }
                int iIndexID = dtFlightPlans.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID);
                int iIndexAirline = dtFlightPlans.Columns.IndexOf(GlobalNames.sFPD_A_Column_AirlineCode);
                int iIndexFC = dtFlightPlans.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightCategory);
                int iIndexDate = dtFlightPlans.Columns.IndexOf(GlobalNames.sFPD_A_Column_DATE);
                int iIndexTime = dtFlightPlans.Columns.IndexOf(GlobalNames.sFPD_Column_STD);
                if ((iIndexID == -1) ||
                    (iIndexAirline == -1) ||
                    (iIndexFC == -1) ||
                    (iIndexDate == -1) ||
                    (iIndexTime == -1))
                {
                    return null;
                }

                // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                int departureOriginatingPaxDefinedNbColumnIndex = -1;
                int departureTransferringPaxDefinedNbColumnIndex = -1;
                int arrivalTerminatingPaxDefinedNbColumnIndex = -1;
                int arrivalTransferringPaxDefinedNbColumnIndex = -1;

                if (bUseDefinedNbPax)
                {
                    if (dtNumberOfPassengers == null)
                    {
                        ListeErreurs.Add("Error: The Number of Passengers table is missing.");
                        return null;
                    }
                    departureOriginatingPaxDefinedNbColumnIndex = dtNumberOfPassengers.Columns
                                                                        .IndexOf(GlobalNames.originatingPaxDepartureColumnName);
                    departureTransferringPaxDefinedNbColumnIndex = dtNumberOfPassengers.Columns
                                                                        .IndexOf(GlobalNames.transferringPaxDepartureColumnName);
                    arrivalTerminatingPaxDefinedNbColumnIndex = dtNumberOfPassengers.Columns
                                                                        .IndexOf(GlobalNames.terminatingPaxArrivalColumnName);
                    arrivalTransferringPaxDefinedNbColumnIndex = dtNumberOfPassengers.Columns
                                                                        .IndexOf(GlobalNames.transferringPaxArrivalColumnName);

                    if (departureOriginatingPaxDefinedNbColumnIndex == -1 || departureTransferringPaxDefinedNbColumnIndex == -1)
                    //|| arrivalTerminatingPaxDefinedNbColumnIndex == -1 || arrivalTransferringPaxDefinedNbColumnIndex == -1)
                    {
                        ListeErreurs.Add("Error: The Number of Passengers table is missing one or more columns.");
                        return null;
                    }
                }

                int departureOriginatingBagsDefinedNbColumnIndex = -1;
                int departureTransferringBagsDefinedNbColumnIndex = -1;
                int arrivalTerminatingBagsDefinedNbColumnIndex = -1;
                int arrivalTransferringBagsDefinedNbColumnIndex = -1;

                if (bUseDefinedNbBags)
                {
                    if (dtNumberOfBaggages == null)
                    {
                        ListeErreurs.Add("Error: The Number of Bags table is missing");
                        return null;
                    }
                    departureOriginatingBagsDefinedNbColumnIndex = dtNumberOfBaggages.Columns
                                                                        .IndexOf(GlobalNames.originatingBagDepartureColumnName);
                    departureTransferringBagsDefinedNbColumnIndex = dtNumberOfBaggages.Columns
                                                                        .IndexOf(GlobalNames.transferringBagDepartureColumnName);
                    arrivalTerminatingBagsDefinedNbColumnIndex = dtNumberOfBaggages.Columns
                                                                        .IndexOf(GlobalNames.terminatingBagArrivalColumnName);
                    arrivalTransferringBagsDefinedNbColumnIndex = dtNumberOfBaggages.Columns
                                                                        .IndexOf(GlobalNames.transferringBagArrivalColumnName);

                    if (departureOriginatingBagsDefinedNbColumnIndex == -1 || departureTransferringBagsDefinedNbColumnIndex == -1)
                    //|| arrivalTerminatingBagsDefinedNbColumnIndex == -1 || arrivalTransferringBagsDefinedNbColumnIndex == -1)
                    {
                        ListeErreurs.Add("Error: The Number of Bags table is missing one or more columns.");
                        return null;
                    }
                }
                // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                #endregion

                #region The results table for the analysis
                DataTable dtAircraftMovementsSmoothed = new DataTable("FPD_AircraftMovementsRolling");
                DataTable dtAircraftMovementsInstantaneous = null;

                DataTable dtPaxGateSmoothed = new DataTable("FPD_OutBoundRolling");
                DataTable dtPaxGateInstantaneous = null;

                DataTable dtCIFlowSmoothed = new DataTable("FPD_CheckInShowUpRolling");
                DataTable dtCIFlowInstantaneous = null;

                // >> Bug #11860 Pax2Sim - Static analysis - EBS calculation FB exception 2                
                DataTable dtTransferICTSmoothed = new DataTable(GlobalNames.FPD_TRANSFER_ICT_ROLLING);
                DataTable dtTransferICTInstantaneous = null;
                // << Bug #11860 Pax2Sim - Static analysis - EBS calculation FB exception 2

                /*their differents columns*/
                // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns                
                dtCIFlowSmoothed.Columns.Add("Time", System.Type.GetType("System.DateTime"));
                dtCIFlowSmoothed.Columns.Add("Passengers", System.Type.GetType("System.Double"));
                dtCIFlowSmoothed.Columns.Add("Passengers / h", System.Type.GetType("System.Double"));
                dtCIFlowSmoothed.Columns.Add("Baggage", System.Type.GetType("System.Double"));
                dtCIFlowSmoothed.Columns.Add("Baggage / h", System.Type.GetType("System.Double"));
                dtCIFlowSmoothed.Columns.Add("Visitors", System.Type.GetType("System.Double"));
                dtCIFlowSmoothed.Columns.Add("Visitors / h", System.Type.GetType("System.Double"));
                dtCIFlowSmoothed.Columns.Add("Trolleys", System.Type.GetType("System.Double"));
                dtCIFlowSmoothed.Columns.Add("Trolleys / h", System.Type.GetType("System.Double"));
                // >> Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                dtAircraftMovementsSmoothed.Columns.Add("Time", System.Type.GetType("System.DateTime"));
                dtAircraftMovementsSmoothed.Columns.Add("Nb Flights", System.Type.GetType("System.Double"));
                dtAircraftMovementsSmoothed.Columns.Add("Nb Flights / h", System.Type.GetType("System.Double"));

                // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns                
                dtPaxGateSmoothed.Columns.Add("Time", System.Type.GetType("System.DateTime"));
                dtPaxGateSmoothed.Columns.Add("Total PAX", System.Type.GetType("System.Double"));
                dtPaxGateSmoothed.Columns.Add("Total PAX / h", System.Type.GetType("System.Double"));
                dtPaxGateSmoothed.Columns.Add("Originating PAX", System.Type.GetType("System.Double"));
                dtPaxGateSmoothed.Columns.Add("Originating PAX / h", System.Type.GetType("System.Double"));
                dtPaxGateSmoothed.Columns.Add("Transferring PAX", System.Type.GetType("System.Double"));
                dtPaxGateSmoothed.Columns.Add("Transferring PAX / h", System.Type.GetType("System.Double"));
                dtPaxGateSmoothed.Columns.Add("Total Bags", System.Type.GetType("System.Double"));
                dtPaxGateSmoothed.Columns.Add("Total Bags / h", System.Type.GetType("System.Double"));
                dtPaxGateSmoothed.Columns.Add("Originating Bags", System.Type.GetType("System.Double"));
                dtPaxGateSmoothed.Columns.Add("Originating Bags / h", System.Type.GetType("System.Double"));
                dtPaxGateSmoothed.Columns.Add("Transferring Bags", System.Type.GetType("System.Double"));
                dtPaxGateSmoothed.Columns.Add("Transferring Bags / h", System.Type.GetType("System.Double"));
                // >> Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                // >> Bug #11860 Pax2Sim - Static analysis - EBS calculation FB exception 2                
                dtTransferICTSmoothed.Columns.Add("Time", System.Type.GetType("System.DateTime"));
                dtTransferICTSmoothed.Columns.Add("Nb Pax", System.Type.GetType("System.Double"));
                dtTransferICTSmoothed.Columns.Add("Nb Pax / h", System.Type.GetType("System.Double"));
                dtTransferICTSmoothed.Columns.Add("Nb Bags", System.Type.GetType("System.Double"));
                dtTransferICTSmoothed.Columns.Add("Nb Bags / h", System.Type.GetType("System.Double"));
                // << Bug #11860 Pax2Sim - Static analysis - EBS calculation FB exception 2
                #endregion

                #region Initialize the tables
                OverallTools.DataFunctions.initialiserLignes(dtCIFlowSmoothed, dtBegin, dtEnd, samplingStep);
                OverallTools.DataFunctions.initialiserLignes(dtAircraftMovementsSmoothed, dtBegin, dtEnd, samplingStep);
                OverallTools.DataFunctions.initialiserLignes(dtPaxGateSmoothed, dtBegin, dtEnd, samplingStep);
                OverallTools.DataFunctions.initialiserLignes(dtTransferICTSmoothed, dtBegin, dtEnd, samplingStep);

                for (j = 0; j < dtCIFlowSmoothed.Rows.Count; j++)
                {
                    for (i = 1; i < dtCIFlowSmoothed.Columns.Count; i++)
                        dtCIFlowSmoothed.Rows[j][i] = 0.0d;
                    for (i = 1; i < dtAircraftMovementsSmoothed.Columns.Count; i++)
                        dtAircraftMovementsSmoothed.Rows[j][i] = 0.0d;
                    for (i = 1; i < dtPaxGateSmoothed.Columns.Count; i++)
                        dtPaxGateSmoothed.Rows[j][i] = 0.0d;
                }

                for (j = 0; j < dtTransferICTSmoothed.Rows.Count; j++)
                    for (i = 1; i < dtTransferICTSmoothed.Columns.Count; i++)
                        dtTransferICTSmoothed.Rows[j][i] = 0.0d;

                #endregion

                #region Pour la répartition suivant les parkings.

                int iIndexTerminalParking = dtFlightPlans.Columns.IndexOf(GlobalNames.sFPD_A_Column_TerminalParking);
                int iIndexParking = dtFlightPlans.Columns.IndexOf(GlobalNames.sFPD_A_Column_Parking);
                int iNbTerminal = FonctionUtiles.CountTerminalParking(dtFlightPlans);
                if ((iIndexParking == -1) || (iIndexTerminalParking == -1) || (iIndexAirline == -1))
                    iNbTerminal = 0;

                ///That variable will contain the number of flights leaving by airline and by parking.
                /// First dimension : Parking terminal index
                /// Second dimension : Parking index
                /// Third dimension : Airline name
                /// Double : Number of flights
                Dictionary<Int32, Dictionary<String, Double>[]> htFlightPerParking = null;
                if (iNbTerminal != 0)
                {
                    htFlightPerParking = new Dictionary<Int32, Dictionary<String, Double>[]>();
                    for (i = 1; i <= iNbTerminal; i++)
                    {
                        int iNbParking = FonctionUtiles.CountParking(dtFlightPlans, i);
                        if (iNbParking == 0)
                            continue;
                        htFlightPerParking.Add(i, new Dictionary<String, Double>[iNbParking]);
                        for (j = 0; j < iNbParking; j++)
                        {
                            htFlightPerParking[i][j] = new Dictionary<String, Double>();
                        }
                    }
                }
                #endregion

                #region Les différentes ArrayList qui permettront de gérer les distributions and the order of the flight categories
                ArrayList alPaxPerFlight = new ArrayList();
                Hashtable htFlightPerFC = new Hashtable();
                Hashtable htPaxPerFC = new Hashtable();
                Hashtable htBagsPerFC = new Hashtable();

                String[] tsFlightCategoriesOrder = new String[dtFlightCategories.Rows.Count];
                DataTable dtTmp = dtOCTCheckIn.Table;
                for (i = 1; i < dtTmp.Columns.Count; i++)
                {
                    String sColumnName = dtTmp.Columns[i].ColumnName;
                    htFlightPerFC.Add(sColumnName, (Double)0.0);
                    htPaxPerFC.Add(sColumnName, (Double)0.0);
                    htBagsPerFC.Add(sColumnName, (Double)0.0);
                    tsFlightCategoriesOrder[i - 1] = sColumnName;
                }
                #endregion



                /*<Stephane>*/
                bool bDoublons = PAX2SIM.bAircraftMovementPerFlight;
                bool bIgnoreFlightForAircraftMovements = false;
                Hashtable _htDoublonsFlightNumber = new Hashtable();
                int iIndexFlightNumber = dtFlightPlans.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightN);
                /*</Stephane>*/
                /**/

                foreach (DataRow ligne in dtFlightPlans.Rows)
                {
                    //On récupère l'identifiant du vol.
                    String iIdentifiantVol = ligne.ItemArray[iIndexID].ToString();
                    //Heure de départ du vol.
                    DateTime dateDepart = DataFunctions.toDateTime(ligne.ItemArray[iIndexDate], ligne.ItemArray[iIndexTime]);
                    if (dateDepart < dtBegin)
                    {
                        ListeErreurs.Add("Warn00408 : Line ignored \"" + iIdentifiantVol + "\" doesn't match the range");
                        continue;
                    }
                    String FlightCateg = ligne[iIndexFC].ToString();
                    String sAirlineCode = ligne[iIndexAirline].ToString();

                    //sarfraz
                    Dictionary<String, String> dssOCT_CI = etOCTCheckIn.GetInformationsColumns(0, "D_" + iIdentifiantVol, sAirlineCode, FlightCateg);
                    // << Task#A2XQ-T12 - Added 
                    Dictionary<String, String> dssOCT_CI_FB = etOCTCheckIn.GetInformationsColumns(1, "D_" + iIdentifiantVol, sAirlineCode, FlightCateg);
                    // >> Task#A2XQ-T12 - Added 
                    if (dssOCT_CI == null)
                        continue;

                    String sOpening = dssOCT_CI[GlobalNames.sOCT_CI_Line_Opening];
                    String sClosing = dssOCT_CI[GlobalNames.sOCT_CI_Line_Closing];
                    Double dOuvertureCI;// = ((Double[])htOCT[FlightCateg])[0];
                    Double dFermetureCI;// = ((Double[])htOCT[FlightCateg])[1];
                    if (!Double.TryParse(sOpening, out dOuvertureCI))
                    {
                        continue;
                    }
                    if (!Double.TryParse(sClosing, out dFermetureCI))
                    {
                        continue;
                    }
                    // << Task#A2XQ-T12 - Added 
                    String sOpening_FB = dssOCT_CI_FB[GlobalNames.sOCT_CI_Line_Opening];
                    String sClosing_FB = dssOCT_CI_FB[GlobalNames.sOCT_CI_Line_Closing];
                    Double dOuvertureCI_FB;
                    Double dFermetureCI_FB;
                    if (!Double.TryParse(sOpening_FB, out dOuvertureCI_FB))
                    {
                        continue;
                    }
                    if (!Double.TryParse(sClosing_FB, out dFermetureCI_FB))
                    {
                        continue;
                    }
                    // >> Task#A2XQ-T12 - Added 
                    int iIndexColumnEco;
                    int iIndexColumnFB;
                    //int iIndexColumnFirst;
                    //Sarfraz
                    DataTable dtShowUpEco = etShowUpProfile.GetInformationsColumns(0, "D_" + iIdentifiantVol, sAirlineCode, FlightCateg, out iIndexColumnEco);
                    // << Task#A2XQ-T12 - Added 
                    DataTable dtShowUpFB = etShowUpProfile.GetInformationsColumns(1, "D_" + iIdentifiantVol, sAirlineCode, FlightCateg, out iIndexColumnFB);
                    // >> Task#A2XQ-T12 - Added 

                    // << Task#A2XQ-T12 - Added - (|| (iIndexColumnFB == -1))
                    if ((iIndexColumnEco == -1) || (iIndexColumnFB == -1))
                    // >> Task#A2XQ-T12 - Added 
                    {
                        ListeErreurs.Add("Err00410 : Flight category does not exist in the Show up table. Please check your tables for mistakes.");
                        continue;
                    }


                    /*<Stephane>*/
                    if (bDoublons)
                    {
                        bIgnoreFlightForAircraftMovements = false;
                        if (!_htDoublonsFlightNumber.ContainsKey(dateDepart))
                        {
                            _htDoublonsFlightNumber.Add(dateDepart, new ArrayList());
                        }
                        if (((ArrayList)_htDoublonsFlightNumber[dateDepart]).Contains(ligne[iIndexFlightNumber].ToString()))
                            bIgnoreFlightForAircraftMovements = true;
                        else
                            ((ArrayList)_htDoublonsFlightNumber[dateDepart]).Add(ligne[iIndexFlightNumber].ToString());

                    }
                    /*</Stephane>*/
                    int iIndexFirst, iIndexLast, iIndexFirst_FB, iIndexLast_FB;
                    GetFirstAndLastValuesRow(dtShowUpEco, iIndexColumnEco, out iIndexFirst, out iIndexLast);
                    GetFirstAndLastValuesRow(dtShowUpFB, iIndexColumnFB, out iIndexFirst_FB, out iIndexLast_FB);
                    if ((iIndexFirst == -1) || (iIndexFirst_FB == -1))
                        continue;
                    Double dFirstPassengerTime = (int)dtShowUpEco.Rows[iIndexLast][1];
                    Double dLastPassengerTime = (int)dtShowUpEco.Rows[iIndexFirst][0];

                    DateTime heureOuvertureCI = dateDepart.AddMinutes(-dOuvertureCI);
                    DateTime heureFermetureCI = dateDepart.AddMinutes(-dFermetureCI);

                    // << Task#A2XQ-T12 - Added
                    Double dFirstPassengerTime_FB = (int)dtShowUpEco.Rows[iIndexLast_FB][1];
                    Double dLastPassengerTime_FB = (int)dtShowUpEco.Rows[iIndexFirst_FB][0];
                    DateTime heureOuvertureCI_FB = dateDepart.AddMinutes(-dOuvertureCI_FB);
                    DateTime heureFermetureCI_FB = dateDepart.AddMinutes(-dFermetureCI_FB);
                    // >> Task#A2XQ-T12 - Added

                    if ((heureOuvertureCI > dtEnd) || (heureOuvertureCI_FB > dtEnd))
                    {
                        ListeErreurs.Add("Warn00411 : Line ignored \"" + iIdentifiantVol + "\" (in FPD or FPA) doesn't match the scenario time range");
                        continue;
                    }

                    // >> Bug #11860 Pax2Sim - Static analysis - EBS calculation FB exception 2                    
                    int ICTEcoColumnIndex = -1;
                    DataTable dtICTEco = etICTTable.GetInformationsColumns(0, "A_" + iIdentifiantVol, sAirlineCode, FlightCateg, out ICTEcoColumnIndex);
                    if (ICTEcoColumnIndex == -1)
                        continue;

                    int firstRowIndex, lastRowIndex;
                    GetFirstAndLastValuesRow(dtICTEco, ICTEcoColumnIndex, out firstRowIndex, out lastRowIndex);
                    if (firstRowIndex == -1)
                        continue;

                    Double dLastICTPassengerTime = (int)dtICTEco.Rows[firstRowIndex][0];
                    Double dFirstICTPassengerTime = (int)dtICTEco.Rows[lastRowIndex][1];
                    // << Bug #11860 Pax2Sim - Static analysis - EBS calculation FB exception 2


                    #region We determine the number of passengers for that flight
                    // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                    //double dTotalNumberOfPassengers = OverallTools.DataFunctions.numberOfPassengers(ligne, etAircraftType, dtFlightCategories, etLoadFactors, ListeErreurs);
                    double dTotalNumberOfPassengers = OverallTools.DataFunctions.getNbPaxForFlight(ligne, etAircraftType, dtFlightCategories, etLoadFactors,
                        FlightAttribute.ARR_OR_DEP_FLIGHT_TAG.D, Convert.ToInt32(iIdentifiantVol), userDefineFlightConfigurations, ListeErreurs);
                    if (dTotalNumberOfPassengers == -1)
                    {
                        ListeErreurs.Add("Warn00411 : Line ignored \"" + iIdentifiantVol + "\". The number of passenger for that fligt is not valid.");
                        continue;
                    }
                    //We have to ignore the transferred passengers
                    Dictionary<String, String> dssLoadFactors = etLoadFactors.GetInformationsColumns(0, "D_" + iIdentifiantVol, sAirlineCode, FlightCateg);

                    String sOriginating = dssLoadFactors[GlobalNames.sLFD_Line_Originating]; //DataFunctions.getValue(dtLoadFactors, GlobalNames.sLFD_Line_Originating, 0, dtLoadFactors.Columns.IndexOf(FlightCateg));
                    String sOriginatingFB = dssLoadFactors[GlobalNames.sLFD_A_Line_C];
                    String sOriginatingEcho = dssLoadFactors[GlobalNames.sLFD_A_Line_Y];
                    if ((sOriginating == null) || (sOriginatingFB == null) || (sOriginatingEcho == null))
                    {
                        ListeErreurs.Add("Err00420 : The load factor table have problems.");
                        return null;
                    }
                    Double dOriginating;
                    if (!Double.TryParse(sOriginating, out dOriginating))
                    {
                        ListeErreurs.Add("Err00421 : The load factor value  for the originating passengers is not valid.");
                        return null;
                    }
                    Double dOriginatingFBPercent;
                    if (!Double.TryParse(sOriginatingFB, out dOriginatingFBPercent))
                    {
                        ListeErreurs.Add("Err00421 : The load factor value  for the F&B class originating passengers is not valid.");
                        return null;
                    }
                    Double dOriginatingEchoPercent;
                    if (!Double.TryParse(sOriginatingEcho, out dOriginatingEchoPercent))
                    {
                        ListeErreurs.Add("Err00421 : The load factor value  for the Echo originating passengers is not valid.");
                        return null;
                    }
                    // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                    double dTransferPassengers = -1;
                    double dOriginatingPassengers = -1;
                    FlightConfiguration flightConfiguration = Tools.FlightPlanParametersTools.getFlightConfigurationByArrOrDepAndFlightId(FlightAttribute.ARR_OR_DEP_FLIGHT_TAG.D,
                        Convert.ToInt32(iIdentifiantVol), userDefineFlightConfigurations);
                    if (flightConfiguration != null)
                    {
                        dTransferPassengers = flightConfiguration.flightParameter.nbTransferEcoPax + flightConfiguration.flightParameter.nbTransferFbPax;
                        dOriginatingPassengers = flightConfiguration.flightParameter.nbOrigEcoPax + flightConfiguration.flightParameter.nbOrigFbPax;
                    }
                    else
                    {
                        dTransferPassengers = (dTotalNumberOfPassengers * (100 - dOriginating)) / 100.0f;
                        dOriginatingPassengers = (dTotalNumberOfPassengers * dOriginating) / 100.0f;
                    }

                    // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                    if (bUseDefinedNbPax)
                    {
                        Double definedTransferPaxNb = -1;
                        Double definedOriginatingPaxNb = -1;

                        if (Double.TryParse(dtNumberOfPassengers.Rows[0][departureTransferringPaxDefinedNbColumnIndex].ToString(), out definedTransferPaxNb)
                            && Double.TryParse(dtNumberOfPassengers.Rows[0][departureOriginatingPaxDefinedNbColumnIndex].ToString(), out definedOriginatingPaxNb))
                        {
                            dTransferPassengers = definedTransferPaxNb;
                            dOriginatingPassengers = definedOriginatingPaxNb;
                            dTotalNumberOfPassengers = definedOriginatingPaxNb + definedTransferPaxNb;
                        }
                    }
                    // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)

                    #endregion

                    //Calcul de la courbe de présentation des passagers.
                    //Il faut dans un premier temps limité l'interval à calculer.
                    //Double dOpening = (int)dtShowUpEco.Rows[((int[])htShowUp[FlightCateg])[1]][1];
                    int iHeureDebut, iHeureDebut_FB;
                    if (dFirstPassengerTime < dOuvertureCI)
                        iHeureDebut = DataFunctions.heureDebut(dtCIFlowSmoothed, dateDepart.AddMinutes(-dFirstPassengerTime));
                    else
                        iHeureDebut = DataFunctions.heureDebut(dtCIFlowSmoothed, heureOuvertureCI);
                    if (dFirstPassengerTime_FB < dOuvertureCI_FB)
                        iHeureDebut_FB = DataFunctions.heureDebut(dtCIFlowSmoothed, dateDepart.AddMinutes(-dFirstPassengerTime_FB));
                    else
                        iHeureDebut_FB = DataFunctions.heureDebut(dtCIFlowSmoothed, heureOuvertureCI_FB);
                    Double dOpening = dFirstPassengerTime;
                    Double dOpening_FB = dFirstPassengerTime_FB;
                    if (iHeureDebut == -1)
                    {
                        if ((((DateTime)dtCIFlowSmoothed.Rows[0][0]) > heureOuvertureCI) && (((DateTime)dtCIFlowSmoothed.Rows[0][0]) < heureFermetureCI))
                        {
                            dOpening = DataFunctions.MinuteDifference(((DateTime)dtCIFlowSmoothed.Rows[0][0]), dateDepart);
                            iHeureDebut = 0;
                        }
                        if (iHeureDebut == -1)
                        {
                            ListeErreurs.Add("Warn00422 : Departing flight \"" + iIdentifiantVol.ToString() + "\" ignored. The STD doesn't match the range.");
                            continue;
                        }
                    }
                    if (iHeureDebut_FB == -1)
                    {
                        if ((((DateTime)dtCIFlowSmoothed.Rows[0][0]) > heureOuvertureCI_FB) && (((DateTime)dtCIFlowSmoothed.Rows[0][0]) < heureFermetureCI_FB))
                        {
                            dOpening_FB = dOpening;
                            iHeureDebut_FB = 0;
                        }
                        if (iHeureDebut_FB == -1)
                        {
                            ListeErreurs.Add("Warn00422 : Departing flight \"" + iIdentifiantVol.ToString() + "\" ignored. The STD doesn't match the range.");
                            continue;
                        }
                    }
                    if (iNbTerminal > 0)
                    {
                        int iTerminalParking;
                        if (!Int32.TryParse(ligne[iIndexTerminalParking].ToString(), out iTerminalParking))
                            iTerminalParking = 0;
                        if (htFlightPerParking.ContainsKey(iTerminalParking))
                        {
                            int iParking;
                            if (!Int32.TryParse(ligne[iIndexParking].ToString(), out iParking))
                                iParking = 0;
                            if ((iParking != 0) && (htFlightPerParking[iTerminalParking].Length >= iParking))
                            {
                                String sAirLine = ligne[iIndexAirline].ToString();
                                if (!htFlightPerParking[iTerminalParking][iParking - 1].ContainsKey(sAirLine))
                                    htFlightPerParking[iTerminalParking][iParking - 1].Add(sAirLine, (Double)0);
                                htFlightPerParking[iTerminalParking][iParking - 1][sAirLine] = (Double)htFlightPerParking[iTerminalParking][iParking - 1][sAirLine] + 1;
                            }
                        }
                    }

                    DateTime heureAnalisee = (DateTime)dtCIFlowSmoothed.Rows[iHeureDebut][0];
                    DateTime heureAnaliseeFB = (DateTime)dtCIFlowSmoothed.Rows[iHeureDebut_FB][0];
                    Double dPercent;
                    Double dTotalPax = 0;
                    int iColumn, iColumnTrolley;

                    DataTable dtTable = etNbVisitors.GetInformationsColumns(0, "D_" + iIdentifiantVol, sAirlineCode, FlightCateg, out iColumn);
                    if (dtTable == null)
                        continue;
                    Double dMeanVisitors = CalculCoefficientMultiplicateur(dtTable, iColumn);

                    dtTable = etNbBags.GetInformationsColumns(0, "D_" + iIdentifiantVol, sAirlineCode, FlightCateg, out iColumn);
                    if (dtTable == null)
                        continue;
                    // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                    //Double dMeanBaggage = CalculCoefficientMultiplicateur(dtTable, iColumn);
                    Double dMeanBaggage = -1;
                    double dMeanOrigBaggage = -1;
                    double dMeanTransferBaggage = -1;
                    double dMeanTotalBaggage = -1;
                    if (flightConfiguration != null)
                    {
                        double totalNbOrigPax = flightConfiguration.flightParameter.nbOrigEcoPax + flightConfiguration.flightParameter.nbOrigFbPax;
                        double totalNbOrigBags = flightConfiguration.flightParameter.nbOrigEcoBags + flightConfiguration.flightParameter.nbOrigFbBags;

                        double totalNbTransferPax = flightConfiguration.flightParameter.nbTransferEcoPax + flightConfiguration.flightParameter.nbTransferFbPax;
                        double totalNbTransferBags = flightConfiguration.flightParameter.nbTransferEcoBags + flightConfiguration.flightParameter.nbTransferFbBags;

                        if (dTotalNumberOfPassengers == 0)
                        {
                            dMeanTotalBaggage = 0;
                        }
                        else
                        {
                            dMeanTotalBaggage = (totalNbOrigBags + totalNbTransferBags) / dTotalNumberOfPassengers;
                        }
                        if (totalNbOrigPax == 0)
                        {
                            dMeanOrigBaggage = 0;
                        }
                        else
                        {
                            dMeanOrigBaggage = totalNbOrigBags / totalNbOrigPax;
                        }
                        if (totalNbTransferPax == 0)
                        {
                            dMeanTransferBaggage = 0;
                        }
                        else
                        {
                            dMeanTransferBaggage = totalNbTransferBags / totalNbTransferPax;
                        }
                    }
                    else
                    {
                        dMeanBaggage = CalculCoefficientMultiplicateur(dtTable, iColumn);
                    }

                    DataTable dtTableTrolley = etNbTrolley.GetInformationsColumns(0, "D_" + iIdentifiantVol, sAirlineCode, FlightCateg, out iColumnTrolley);
                    if (dtTable == null)
                        continue;
                    Double dMeanTrolley = CalculCoefficientMultiplicateurTrolley(dtTableTrolley, dtTable, iColumnTrolley, iColumn);

                    // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                    Double definedOriginatingNbBags = -1;
                    Double definedTransferringNbBags = -1;

                    if (bUseDefinedNbBags)
                    {
                        Double.TryParse(dtNumberOfBaggages.Rows[0][departureOriginatingBagsDefinedNbColumnIndex].ToString(), out definedOriginatingNbBags);
                        Double.TryParse(dtNumberOfBaggages.Rows[0][departureTransferringBagsDefinedNbColumnIndex].ToString(), out definedTransferringNbBags);
                    }
                    // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)

                    // << PAX Calculation for only Echo Class
                    while ((heureAnalisee < heureFermetureCI) && (iHeureDebut < dtCIFlowSmoothed.Rows.Count))
                    {
                        heureAnalisee = heureAnalisee.AddMinutes(samplingStep);
                        if (heureAnalisee > heureFermetureCI)
                        {
                            heureAnalisee = heureFermetureCI;
                        }
                        Double dClosing = DataFunctions.MinuteDifference(heureAnalisee, dateDepart);

                        dPercent = getDistribution((int)dOpening, (int)dClosing, dtShowUpEco/*dtShowUpProfile*/, iIndexColumnEco);
                        if (dPercent > 0)
                        {
                            //Double PAX = dPercent * dOriginatingPassengers;
                            Double PAX = dPercent * dOriginatingPassengers * dOriginatingEchoPercent / 100;
                            dTotalPax += PAX;

                            // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                            if (bUseDefinedNbBags)
                            {
                                Double definedMeanBag = definedOriginatingNbBags / dOriginatingPassengers;

                                dtCIFlowSmoothed.Rows[iHeureDebut][1] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][1] + PAX;
                                dtCIFlowSmoothed.Rows[iHeureDebut][2] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][2] + PAX;
                                dtCIFlowSmoothed.Rows[iHeureDebut][3] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][3] + PAX * definedMeanBag;
                                dtCIFlowSmoothed.Rows[iHeureDebut][4] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][4] + PAX * definedMeanBag;
                                dtCIFlowSmoothed.Rows[iHeureDebut][5] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][5] + PAX * dMeanVisitors;
                                dtCIFlowSmoothed.Rows[iHeureDebut][6] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][6] + PAX * dMeanVisitors;
                                dtCIFlowSmoothed.Rows[iHeureDebut][7] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][7] + PAX * dMeanTrolley;
                                dtCIFlowSmoothed.Rows[iHeureDebut][8] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][8] + PAX * dMeanTrolley;
                            }
                            else
                            {
                                // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns                            
                                dtCIFlowSmoothed.Rows[iHeureDebut][1] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][1] + PAX;
                                dtCIFlowSmoothed.Rows[iHeureDebut][2] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][2] + PAX;
                                if (dMeanBaggage != -1)
                                {
                                    dtCIFlowSmoothed.Rows[iHeureDebut][3] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][3] + PAX * dMeanBaggage;
                                    dtCIFlowSmoothed.Rows[iHeureDebut][4] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][4] + PAX * dMeanBaggage;
                                }
                                else if (dMeanOrigBaggage != -1)
                                {
                                    dtCIFlowSmoothed.Rows[iHeureDebut][3] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][3] + PAX * dMeanOrigBaggage;
                                    dtCIFlowSmoothed.Rows[iHeureDebut][4] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][4] + PAX * dMeanOrigBaggage;
                                }
                                dtCIFlowSmoothed.Rows[iHeureDebut][5] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][5] + PAX * dMeanVisitors;
                                dtCIFlowSmoothed.Rows[iHeureDebut][6] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][6] + PAX * dMeanVisitors;
                                dtCIFlowSmoothed.Rows[iHeureDebut][7] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][7] + PAX * dMeanTrolley;
                                dtCIFlowSmoothed.Rows[iHeureDebut][8] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][8] + PAX * dMeanTrolley;
                                // >> Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                            }
                            // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                        }
                        iHeureDebut++;
                        dOpening = dClosing;
                    }
                    // >> PAX Calculation for only Echo Class

                    // << PAX Calculation for only First & Bussiness Class
                    iHeureDebut = iHeureDebut_FB;
                    dOpening = dOpening_FB;
                    bool isAllFirstClassPax = dOriginatingFBPercent == 100 ? false : true;
                    while ((heureAnaliseeFB < heureFermetureCI_FB) && (iHeureDebut < dtCIFlowSmoothed.Rows.Count))
                    {
                        heureAnaliseeFB = heureAnaliseeFB.AddMinutes(samplingStep);
                        if (heureAnaliseeFB > heureFermetureCI_FB)
                        {
                            heureAnaliseeFB = heureFermetureCI_FB;
                        }
                        Double dClosing = DataFunctions.MinuteDifference(heureAnaliseeFB, dateDepart);

                        dPercent = getDistribution((int)dOpening, (int)dClosing, dtShowUpFB, iIndexColumnFB);
                        if (dPercent > 0)
                        {
                            Double PAX = dPercent * dOriginatingPassengers * dOriginatingFBPercent / 100;
                            dTotalPax += PAX;
                            if (bUseDefinedNbBags)
                            {
                                Double definedMeanBag = definedOriginatingNbBags / dOriginatingPassengers;

                                dtCIFlowSmoothed.Rows[iHeureDebut][1] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][1] + PAX;
                                dtCIFlowSmoothed.Rows[iHeureDebut][2] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][2] + PAX;
                                dtCIFlowSmoothed.Rows[iHeureDebut][3] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][3] + PAX * (isAllFirstClassPax ? definedMeanBag : 1);
                                dtCIFlowSmoothed.Rows[iHeureDebut][4] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][4] + PAX * (isAllFirstClassPax ? definedMeanBag : 1);
                                dtCIFlowSmoothed.Rows[iHeureDebut][5] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][5] + PAX * (isAllFirstClassPax ? dMeanVisitors : 1);
                                dtCIFlowSmoothed.Rows[iHeureDebut][6] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][6] + PAX * (isAllFirstClassPax ? dMeanVisitors : 1);
                                dtCIFlowSmoothed.Rows[iHeureDebut][7] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][7] + PAX * (isAllFirstClassPax ? dMeanTrolley : 1);
                                dtCIFlowSmoothed.Rows[iHeureDebut][8] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][8] + PAX * (isAllFirstClassPax ? dMeanTrolley : 1);
                            }
                            else
                            {
                                dtCIFlowSmoothed.Rows[iHeureDebut][1] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][1] + PAX;
                                dtCIFlowSmoothed.Rows[iHeureDebut][2] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][2] + PAX;
                                if (dMeanBaggage != -1)
                                {
                                    dtCIFlowSmoothed.Rows[iHeureDebut][3] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][3] + PAX * (isAllFirstClassPax ? dMeanBaggage : 1);
                                    dtCIFlowSmoothed.Rows[iHeureDebut][4] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][4] + PAX * (isAllFirstClassPax ? dMeanBaggage : 1);
                                }
                                else if (dMeanOrigBaggage != -1)
                                {
                                    dtCIFlowSmoothed.Rows[iHeureDebut][3] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][3] + PAX * (isAllFirstClassPax ? dMeanOrigBaggage : 1);
                                    dtCIFlowSmoothed.Rows[iHeureDebut][4] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][4] + PAX * (isAllFirstClassPax ? dMeanOrigBaggage : 1);
                                }
                                dtCIFlowSmoothed.Rows[iHeureDebut][5] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][5] + PAX * (isAllFirstClassPax ? dMeanVisitors : 1);
                                dtCIFlowSmoothed.Rows[iHeureDebut][6] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][6] + PAX * (isAllFirstClassPax ? dMeanVisitors : 1);
                                dtCIFlowSmoothed.Rows[iHeureDebut][7] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][7] + PAX * (isAllFirstClassPax ? dMeanTrolley : 1);
                                dtCIFlowSmoothed.Rows[iHeureDebut][8] = (Double)dtCIFlowSmoothed.Rows[iHeureDebut][8] + PAX * (isAllFirstClassPax ? dMeanTrolley : 1);
                            }
                        }
                        iHeureDebut++;
                        dOpening = dClosing;
                    }
                    // >> PAX Calculation for only First & Bussiness Class

                    alPaxPerFlight.Add(dTotalNumberOfPassengers);
                    htPaxPerFC[FlightCateg] = ((Double)htPaxPerFC[FlightCateg]) + dTotalNumberOfPassengers;
                    htFlightPerFC[FlightCateg] = ((Double)htFlightPerFC[FlightCateg]) + 1;


                    // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                    //htBagsPerFC[FlightCateg] = ((Double)htBagsPerFC[FlightCateg]) + dTotalNumberOfPassengers * dMeanBaggage;
                    if (bUseDefinedNbBags && definedOriginatingNbBags >= 0 && definedTransferringNbBags >= 0)
                    {
                        Double definedTotalNbBags = definedOriginatingNbBags + definedTransferringNbBags;
                        htBagsPerFC[FlightCateg] = ((Double)htBagsPerFC[FlightCateg]) + definedTotalNbBags;
                    }
                    else
                    {
                        if (dMeanBaggage != -1)
                        {
                            htBagsPerFC[FlightCateg] = ((Double)htBagsPerFC[FlightCateg]) + dTotalNumberOfPassengers * dMeanBaggage;
                        }
                        else if (dMeanTotalBaggage != -1)
                        {
                            htBagsPerFC[FlightCateg] = ((Double)htBagsPerFC[FlightCateg]) + dTotalNumberOfPassengers * dMeanTotalBaggage;
                        }
                    }
                    // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)

                    iHeureDebut = DataFunctions.heureDebut(dtPaxGateSmoothed, dateDepart);
                    if (iHeureDebut != -1)
                    {
                        // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns                        
                        dtPaxGateSmoothed.Rows[iHeureDebut][1] = (Double)dtPaxGateSmoothed.Rows[iHeureDebut][1] + dOriginatingPassengers + dTransferPassengers;
                        dtPaxGateSmoothed.Rows[iHeureDebut][2] = (Double)dtPaxGateSmoothed.Rows[iHeureDebut][2] + dOriginatingPassengers + dTransferPassengers;
                        dtPaxGateSmoothed.Rows[iHeureDebut][3] = (Double)dtPaxGateSmoothed.Rows[iHeureDebut][3] + dOriginatingPassengers;
                        dtPaxGateSmoothed.Rows[iHeureDebut][4] = (Double)dtPaxGateSmoothed.Rows[iHeureDebut][4] + dOriginatingPassengers;
                        dtPaxGateSmoothed.Rows[iHeureDebut][5] = (Double)dtPaxGateSmoothed.Rows[iHeureDebut][5] + dTransferPassengers;
                        dtPaxGateSmoothed.Rows[iHeureDebut][6] = (Double)dtPaxGateSmoothed.Rows[iHeureDebut][6] + dTransferPassengers;

                        // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                        if (bUseDefinedNbBags && definedOriginatingNbBags >= 0 && definedTransferringNbBags >= 0)
                        {
                            dtPaxGateSmoothed.Rows[iHeureDebut][7] = (Double)dtPaxGateSmoothed.Rows[iHeureDebut][7] + definedOriginatingNbBags + definedTransferringNbBags;
                            dtPaxGateSmoothed.Rows[iHeureDebut][8] = (Double)dtPaxGateSmoothed.Rows[iHeureDebut][8] + definedOriginatingNbBags + definedTransferringNbBags;
                            dtPaxGateSmoothed.Rows[iHeureDebut][9] = (Double)dtPaxGateSmoothed.Rows[iHeureDebut][9] + definedOriginatingNbBags;
                            dtPaxGateSmoothed.Rows[iHeureDebut][10] = (Double)dtPaxGateSmoothed.Rows[iHeureDebut][10] + definedOriginatingNbBags;
                            dtPaxGateSmoothed.Rows[iHeureDebut][11] = (Double)dtPaxGateSmoothed.Rows[iHeureDebut][11] + definedTransferringNbBags;
                            dtPaxGateSmoothed.Rows[iHeureDebut][12] = (Double)dtPaxGateSmoothed.Rows[iHeureDebut][12] + definedTransferringNbBags;
                        }
                        else
                        {
                            if (dMeanBaggage != -1)
                            {
                                dtPaxGateSmoothed.Rows[iHeureDebut][7] = (Double)dtPaxGateSmoothed.Rows[iHeureDebut][7] + (dOriginatingPassengers + dTransferPassengers) * dMeanBaggage;
                                dtPaxGateSmoothed.Rows[iHeureDebut][8] = (Double)dtPaxGateSmoothed.Rows[iHeureDebut][8] + (dOriginatingPassengers + dTransferPassengers) * dMeanBaggage;
                                dtPaxGateSmoothed.Rows[iHeureDebut][9] = (Double)dtPaxGateSmoothed.Rows[iHeureDebut][9] + dOriginatingPassengers * dMeanBaggage;
                                dtPaxGateSmoothed.Rows[iHeureDebut][10] = (Double)dtPaxGateSmoothed.Rows[iHeureDebut][10] + dOriginatingPassengers * dMeanBaggage;
                                dtPaxGateSmoothed.Rows[iHeureDebut][11] = (Double)dtPaxGateSmoothed.Rows[iHeureDebut][11] + dTransferPassengers * dMeanBaggage;
                                dtPaxGateSmoothed.Rows[iHeureDebut][12] = (Double)dtPaxGateSmoothed.Rows[iHeureDebut][12] + dTransferPassengers * dMeanBaggage;
                            }
                            else if (dMeanTotalBaggage != -1 && dMeanOrigBaggage != -1 && dMeanTransferBaggage != -1)
                            {
                                dtPaxGateSmoothed.Rows[iHeureDebut][7] = (Double)dtPaxGateSmoothed.Rows[iHeureDebut][7]
                                    + (dOriginatingPassengers + dTransferPassengers) * dMeanTotalBaggage;
                                dtPaxGateSmoothed.Rows[iHeureDebut][8] = (Double)dtPaxGateSmoothed.Rows[iHeureDebut][8]
                                    + (dOriginatingPassengers + dTransferPassengers) * dMeanTotalBaggage;
                                dtPaxGateSmoothed.Rows[iHeureDebut][9] = (Double)dtPaxGateSmoothed.Rows[iHeureDebut][9] + dOriginatingPassengers * dMeanOrigBaggage;
                                dtPaxGateSmoothed.Rows[iHeureDebut][10] = (Double)dtPaxGateSmoothed.Rows[iHeureDebut][10] + dOriginatingPassengers * dMeanOrigBaggage;
                                dtPaxGateSmoothed.Rows[iHeureDebut][11] = (Double)dtPaxGateSmoothed.Rows[iHeureDebut][11] + dTransferPassengers * dMeanTransferBaggage;
                                dtPaxGateSmoothed.Rows[iHeureDebut][12] = (Double)dtPaxGateSmoothed.Rows[iHeureDebut][12] + dTransferPassengers * dMeanTransferBaggage;
                            }
                        }
                        // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                        // >> Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                        if (!bIgnoreFlightForAircraftMovements)
                            dtAircraftMovementsSmoothed.Rows[iHeureDebut][1] = (Double)dtAircraftMovementsSmoothed.Rows[iHeureDebut][1] + 1;
                    }

                    #region Transfer ICT flows
                    heureAnalisee = dateDepart.AddMinutes(-dFirstICTPassengerTime);
                    DateTime heureClose = dateDepart.AddMinutes(-dLastICTPassengerTime);

                    iHeureDebut = DataFunctions.heureDebut(dtTransferICTSmoothed, heureAnalisee);
                    if (iHeureDebut == -1)
                        iHeureDebut = 0;

                    double startMinute = dFirstICTPassengerTime;
                    double endMinute = 0;
                    if (dtTransferICTSmoothed.Rows.Count != 0)
                    {
                        heureAnalisee = (DateTime)dtTransferICTSmoothed.Rows[iHeureDebut][0];
                        while (heureAnalisee < heureClose)
                        {
                            heureAnalisee = heureAnalisee.AddMinutes(samplingStep);
                            endMinute = DataFunctions.MinuteDifference(heureAnalisee, dateDepart);
                            dPercent = getDistribution((int)startMinute, (int)endMinute, dtICTEco, ICTEcoColumnIndex);
                            if (dPercent > 0)
                            {
                                Double PAX = dPercent * dTransferPassengers;
                                dtTransferICTSmoothed.Rows[iHeureDebut][1] = (Double)dtTransferICTSmoothed.Rows[iHeureDebut][1] + PAX;
                                if (dMeanBaggage != -1)
                                {
                                    dtTransferICTSmoothed.Rows[iHeureDebut][3] = (Double)dtTransferICTSmoothed.Rows[iHeureDebut][3] + PAX * dMeanBaggage;
                                }
                                else if (dMeanTransferBaggage != -1)
                                {
                                    dtTransferICTSmoothed.Rows[iHeureDebut][3] = (Double)dtTransferICTSmoothed.Rows[iHeureDebut][3] + PAX * dMeanTransferBaggage;
                                }
                            }
                            iHeureDebut++;
                            startMinute = endMinute;
                            if (iHeureDebut >= dtTransferICTSmoothed.Rows.Count)
                                break;
                        }
                    }
                    #endregion
                }
                //On calcul maintenant les valeurs cumulés sur l'interval demandé
                /*if (60 > dStepAnalysis)
                {*/
                #region dtCIFlowSmoothed
                dtCIFlowInstantaneous = dtCIFlowSmoothed.Copy();
                dtCIFlowInstantaneous.TableName = "FPD_CheckInShowUpInstantaneous";

                // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns                
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtCIFlowSmoothed, 2, 2, samplingStep, analysisRange);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtCIFlowSmoothed, 4, 4, samplingStep, analysisRange);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtCIFlowSmoothed, 6, 6, samplingStep, analysisRange);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtCIFlowSmoothed, 8, 8, samplingStep, analysisRange);

                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtCIFlowInstantaneous, 2, 2, samplingStep, samplingStep);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtCIFlowInstantaneous, 4, 4, samplingStep, samplingStep);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtCIFlowInstantaneous, 6, 6, samplingStep, samplingStep);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtCIFlowInstantaneous, 8, 8, samplingStep, samplingStep);
                // >> Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                #endregion

                #region dtPaxGateSmoothed
                dtPaxGateInstantaneous = dtPaxGateSmoothed.Copy();
                dtPaxGateInstantaneous.TableName = "FPD_OutBoundInstantaneous";

                // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns                
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtPaxGateSmoothed, 2, 2, samplingStep, analysisRange);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtPaxGateSmoothed, 4, 4, samplingStep, analysisRange);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtPaxGateSmoothed, 6, 6, samplingStep, analysisRange);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtPaxGateSmoothed, 8, 8, samplingStep, analysisRange);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtPaxGateSmoothed, 10, 10, samplingStep, analysisRange);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtPaxGateSmoothed, 12, 12, samplingStep, analysisRange);

                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtPaxGateInstantaneous, 2, 2, samplingStep, samplingStep);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtPaxGateInstantaneous, 4, 4, samplingStep, samplingStep);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtPaxGateInstantaneous, 6, 6, samplingStep, samplingStep);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtPaxGateInstantaneous, 8, 8, samplingStep, samplingStep);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtPaxGateInstantaneous, 10, 10, samplingStep, samplingStep);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtPaxGateInstantaneous, 12, 12, samplingStep, samplingStep);
                // >> Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                #endregion

                #region dtAircraftMovementsSmoothed
                dtAircraftMovementsInstantaneous = dtAircraftMovementsSmoothed.Copy();
                dtAircraftMovementsInstantaneous.TableName = "FPD_AircraftMovementsInstantaneous";

                // >> Task #13761 Pax2Sim - Static Analysis - Instant and Smoothed calculations
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtAircraftMovementsSmoothed, 1, 2, samplingStep, analysisRange);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtAircraftMovementsInstantaneous, 1, 2, samplingStep, samplingStep);
                //ResultFunctions.AnalyzePeak_SlidingHourDouble(dtAircraftMovementsSmoothed, 1, 2, samplingStep, 60);
                //ResultFunctions.AnalyzePeak_SlidingHourDouble(dtAircraftMovementsInstantaneous, 1, 2, samplingStep, analysisRange);
                // << Task #13761 Pax2Sim - Static Analysis - Instant and Smoothed calculations                
                #endregion

                #region dtTransferICTFlow
                dtTransferICTInstantaneous = dtTransferICTSmoothed.Copy();
                dtTransferICTInstantaneous.TableName = GlobalNames.FPD_TRANSFER_ICT_INSTANTANEOUS;

                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtTransferICTSmoothed, 1, 2, samplingStep, analysisRange);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtTransferICTSmoothed, 3, 4, samplingStep, analysisRange);

                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtTransferICTInstantaneous, 1, 2, samplingStep, samplingStep);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtTransferICTInstantaneous, 3, 4, samplingStep, samplingStep);
                #endregion

                //}

                #region Gestion des distributions
                DataTable dtPaxPerFlight = ResultFunctions.GenerateDistribution("FPD_PAXFlightDistribution", alPaxPerFlight, 25, 20, 0, "Passengers", new String[] { "Nb Flights" }, null, null);
                DataTable dtFCDistribution = getDistribution(new Hashtable[] { htFlightPerFC, htPaxPerFC, htBagsPerFC },
                                                             "FPD_FlightCategoriesDistribution", new String[] { "Flight category", "Nb Flight", "Nb PAX", "Nb Bags" }, tsFlightCategoriesOrder);

                #region Gestion des Parking
                DataTable[] dtParking = null;
                if (iNbTerminal > 0)
                {
                    dtParking = new DataTable[htFlightPerParking.Count];
                    i = 0;
                    foreach (int iKey in htFlightPerParking.Keys)
                    {
                        String[] tsName = new String[htFlightPerParking[iKey].Length + 1];
                        tsName[0] = "Airline Code";
                        for (j = 1; j < tsName.Length; j++)
                            tsName[j] = "ParkingStand_" + j;
                        dtParking[i] = getDistribution(htFlightPerParking[iKey], "FPD_ParkingForTerminal_" + iKey.ToString(),
                            tsName, null);
                        dtParking[i] = OverallTools.DataFunctions.sortTable(dtParking[i], "Airline Code");
                        i++;
                    }
                }
                #endregion
                #endregion
                #region On arrondi les résultats.
                // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns                
                OverallTools.DataFunctions.SumColumns(dtCIFlowSmoothed, new String[] { "Passengers", "Visitors" }, "Pax+Visitors");
                OverallTools.DataFunctions.SumColumns(dtCIFlowSmoothed, new String[] { "Passengers / h", "Visitors / h" }, "Pax+Visitors / h");
                OverallTools.DataFunctions.SumColumns(dtCIFlowInstantaneous, new String[] { "Passengers", "Visitors" }, "Pax+Visitors");
                OverallTools.DataFunctions.SumColumns(dtCIFlowInstantaneous, new String[] { "Passengers / h", "Visitors / h" }, "Pax+Visitors / h");
                // >> Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                foreach (DataRow Ligne in dtCIFlowSmoothed.Rows)
                {
                    if (Ligne[0].ToString().Length == 0) continue;
                    for (i = 1; i < dtCIFlowSmoothed.Columns.Count; i++)
                        Ligne[i] = Math.Round((Double)Ligne[i], 1);
                }
                foreach (DataRow Ligne in dtCIFlowInstantaneous.Rows)
                {
                    if (Ligne[0].ToString().Length == 0) continue;
                    for (i = 1; i < dtCIFlowSmoothed.Columns.Count; i++)
                        Ligne[i] = Math.Round((Double)Ligne[i], 1);
                }
                foreach (DataRow Ligne in dtPaxGateSmoothed.Rows)
                {
                    if (Ligne[0].ToString().Length == 0) continue;
                    for (i = 1; i < dtPaxGateSmoothed.Columns.Count; i++)
                        Ligne[i] = Math.Round((Double)Ligne[i], 1);
                }
                foreach (DataRow Ligne in dtPaxGateInstantaneous.Rows)
                {
                    if (Ligne[0].ToString().Length == 0) continue;
                    for (i = 1; i < dtPaxGateSmoothed.Columns.Count; i++)
                        Ligne[i] = Math.Round((Double)Ligne[i], 1);
                }
                foreach (DataRow Ligne in dtAircraftMovementsSmoothed.Rows)
                {
                    if (Ligne[0].ToString().Length == 0) continue;
                    for (i = 1; i < dtAircraftMovementsSmoothed.Columns.Count; i++)
                        Ligne[i] = Math.Round((Double)Ligne[i], 1);
                }
                foreach (DataRow Ligne in dtAircraftMovementsInstantaneous.Rows)
                {
                    if (Ligne[0].ToString().Length == 0) continue;
                    for (i = 1; i < dtAircraftMovementsSmoothed.Columns.Count; i++)
                        Ligne[i] = Math.Round((Double)Ligne[i], 1);
                }
                foreach (DataRow Ligne in dtTransferICTSmoothed.Rows)
                {
                    if (Ligne[0].ToString().Length == 0)
                        continue;
                    for (i = 1; i < dtTransferICTSmoothed.Columns.Count; i++)
                        Ligne[i] = Math.Round((Double)Ligne[i], 1);
                }
                foreach (DataRow Ligne in dtTransferICTInstantaneous.Rows)
                {
                    if (Ligne[0].ToString().Length == 0)
                        continue;
                    for (i = 1; i < dtTransferICTInstantaneous.Columns.Count; i++)
                        Ligne[i] = Math.Round((Double)Ligne[i], 1);
                }

                // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                /*
                                DataTable Stats = OverallTools.DataFunctions.GetStatTable(dtCIFlowSmoothed, new int[10] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }); // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns                
                                Stats.TableName = "FPD_Peak_Stats";
                                //OverallTools.DataFunctions.GetStatTable(Stats, dtCIFlowSmoothed, new int[5] { 1, 2, 3, 4, 5 });
                                OverallTools.DataFunctions.GetStatTable(Stats, dtCIFlowInstantaneous, new int[10] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 });       // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                                OverallTools.DataFunctions.GetStatTable(Stats, dtAircraftMovementsSmoothed, new int[] { 2 });
                                OverallTools.DataFunctions.GetStatTable(Stats, dtAircraftMovementsInstantaneous, new int[] { 2 });
                                // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns                
                                OverallTools.DataFunctions.GetStatTable(Stats, dtPaxGateSmoothed, new int[12] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 });
                                OverallTools.DataFunctions.GetStatTable(Stats, dtPaxGateInstantaneous, new int[12] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 });
                                // >> Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                */
                DataTable Stats = OverallTools.DataFunctions.getStatisticTable(dtCIFlowSmoothed, new int[10] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }, distributionLevels);
                Stats.TableName = "FPD_Peak_Stats";
                //OverallTools.DataFunctions.addNewStatisticsToStatisticTable(Stats, dtCIFlowInstantaneous, new int[10] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }, distributionLevels);
                OverallTools.DataFunctions.addNewStatisticsToStatisticTable(Stats, dtAircraftMovementsSmoothed, new int[] { 2 }, distributionLevels);
                //OverallTools.DataFunctions.addNewStatisticsToStatisticTable(Stats, dtAircraftMovementsInstantaneous, new int[] { 2 }, distributionLevels);
                OverallTools.DataFunctions.addNewStatisticsToStatisticTable(Stats, dtPaxGateSmoothed, new int[12] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 }, distributionLevels);
                //OverallTools.DataFunctions.addNewStatisticsToStatisticTable(Stats, dtPaxGateInstantaneous, new int[12] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 }, distributionLevels);
                // << Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                OverallTools.DataFunctions.addNewStatisticsToStatisticTable(Stats, dtTransferICTSmoothed, new int[] { 2, 4 }, distributionLevels);
                #endregion

                dtCIFlowSmoothed.AcceptChanges();
                dtCIFlowInstantaneous.AcceptChanges();
                dtPaxGateSmoothed.AcceptChanges();
                dtPaxGateInstantaneous.AcceptChanges();
                dtAircraftMovementsSmoothed.AcceptChanges();
                dtAircraftMovementsInstantaneous.AcceptChanges();
                dtTransferICTSmoothed.AcceptChanges();
                dtTransferICTInstantaneous.AcceptChanges();

                #region The results ArrayList
                ArrayList alResults = new ArrayList();
                alResults.Add(dtAircraftMovementsSmoothed);
                alResults.Add(dtAircraftMovementsInstantaneous);
                alResults.Add(dtPaxGateSmoothed);
                alResults.Add(dtPaxGateInstantaneous);
                alResults.Add(dtCIFlowSmoothed);
                alResults.Add(dtCIFlowInstantaneous);
                alResults.Add(Stats);
                alResults.Add(dtPaxPerFlight);
                alResults.Add(dtFCDistribution);
                alResults.Add(dtTransferICTSmoothed);
                alResults.Add(dtTransferICTInstantaneous);
                if (iNbTerminal > 0)
                {
                    for (j = 0; j < dtParking.Length; j++)
                        alResults.Add(dtParking[j]);
                }
                #endregion

                return alResults;
            }
            #endregion

            #region Function used for the airline calculation
            internal static ArrayList CalcStaticAnalysisPerAirline(DataTable dtFlightPlans,
                 DataManagement.NormalTable dtLoadFactors,
                 DataManagement.NormalTable dtAircraftType,
                 DataManagement.NormalTable dtShowUpProfile,
                 DataManagement.NormalTable dtOCTCheckIn,
                 DataManagement.NormalTable dtNbBags,
                 DataManagement.NormalTable dtNbVisitors,
                 DataManagement.NormalTable dtNbTrolley,
                DataTable dtFlightCategories,
                DateTime dtBegin,
                DateTime dtEnd,
                Double dStepAnalysis,
                Double dStepCumul,
                bool bUseStatisticStep,
                Double dStatisticStep,
                String sStatisticMode,
                ArrayList ListeErreurs,
                // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                bool bUseDefinedNbPax,
                DataTable dtNumberOfPassengers,
                bool bUseDefinedNbBags,
                DataTable dtNumberOfBaggages
                // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                , double[] distributionLevels,   // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                NormalTable interConnectingTimeTable,
                List<FlightConfiguration> userDefineFlightConfigurations    // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                )
            {
                ArrayList alResult = CalcStaticAnalysis2(dtFlightPlans, dtLoadFactors, dtAircraftType, dtShowUpProfile,
                    dtOCTCheckIn, dtNbBags, dtNbVisitors, dtNbTrolley, dtFlightCategories, dtBegin, dtEnd, dStepAnalysis,
                    dStepCumul, bUseStatisticStep, dStatisticStep, sStatisticMode, ListeErreurs,
                    bUseDefinedNbPax, dtNumberOfPassengers, bUseDefinedNbBags, dtNumberOfBaggages // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                    , distributionLevels, interConnectingTimeTable, userDefineFlightConfigurations    // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                    );
                if (alResult == null)
                    return null;
                if (dtFlightPlans.Rows.Count != 0)
                {
                    ArrayList alAirline = new ArrayList();
                    int iIndexAirline = dtFlightPlans.Columns.IndexOf(GlobalNames.sFPD_A_Column_AirlineCode);
                    if (iIndexAirline == -1)
                        return alResult;
                    int i;
                    for (i = 0; i < dtFlightPlans.Rows.Count; i++)
                    {
                        if (!alAirline.Contains(dtFlightPlans.Rows[i][iIndexAirline].ToString()))
                            alAirline.Add(dtFlightPlans.Rows[i][iIndexAirline].ToString());
                    }
                    alAirline.Sort(new FonctionUtiles.ColumnsComparer());
                    DataTable dtTmp = dtFlightPlans.Clone();
                    DataTable FPD_AircraftMovementsAirline = null;
                    DataTable FPD_CheckInShowUpSmoothed = null;
                    DataTable FPD_CheckInShowUpInstantaneous = null;
                    DataTable FPD_OutBoundSmoothed = null;
                    DataTable FPD_OutBoundInstantaneous = null;

                    DataTable FPD_CheckInShowUpBagSmoothed = null;
                    DataTable FPD_CheckInShowUpBagInstantaneous = null;
                    DataTable FPD_OutBoundBagSmoothed = null;
                    DataTable FPD_OutBoundBagInstantaneous = null;

                    // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                    DataTable FPD_OutBoundSmoothedPAXOriginatingAirline = null;
                    DataTable FPD_OutBoundInstantaneousPAXOriginatingAirline = null;

                    DataTable FPD_OutBoundSmoothedPAXTransferringAirline = null;
                    DataTable FPD_OutBoundInstantaneousPAXTransferringAirline = null;

                    DataTable FPD_OutBoundSmoothedBagOriginatingAirline = null;
                    DataTable FPD_OutBoundInstantaneousBagOriginatingAirline = null;

                    DataTable FPD_OutBoundSmoothedBagTransferringAirline = null;
                    DataTable FPD_OutBoundInstantaneousBagTransferringAirline = null;
                    // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

                    // >> Bug #11860 Pax2Sim - Static analysis - EBS calculation FB exception 2                    
                    DataTable FPD_TransferICTSmoothedAirline = null;
                    DataTable FPD_TransferICTInstantaneousAirline = null;
                    DataTable FPD_TransferICTBagSmoothedAirline = null;
                    DataTable FPD_TransferICTBagInstantaneousAirline = null;
                    // << Bug #11860 Pax2Sim - Static analysis - EBS calculation FB exception 2

                    for (i = 0; i < alAirline.Count; i++)
                    {
                        String sAirline = alAirline[i].ToString();
                        dtTmp.Rows.Clear();
                        foreach (DataRow drTmp in dtFlightPlans.Rows)
                        {
                            if (drTmp[iIndexAirline].ToString() == sAirline)
                                dtTmp.Rows.Add(drTmp.ItemArray);
                        }
                        ArrayList alTmp = CalcStaticAnalysis2(dtTmp, dtLoadFactors, dtAircraftType, dtShowUpProfile, dtOCTCheckIn,
                            dtNbBags, dtNbVisitors, dtNbTrolley, dtFlightCategories, dtBegin, dtEnd, dStepAnalysis, dStepCumul,
                            bUseStatisticStep, dStatisticStep, sStatisticMode, ListeErreurs,
                            bUseDefinedNbPax, dtNumberOfPassengers, bUseDefinedNbBags, dtNumberOfBaggages // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                            , distributionLevels, interConnectingTimeTable    // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                            , userDefineFlightConfigurations);
                        if (alTmp == null)
                            continue;
                        DataTable dtAircraftMovement = null;
                        DataTable dtAirlineSmoothed = null;
                        DataTable dtAirlineInstantaneous = null;
                        DataTable dtOutBoundSmoothed = null;
                        DataTable dtOutBoundInstantaneous = null;
                        DataTable transferICTSmoothedAirlineTable = null;
                        DataTable transferICTInstantaneousAirlineTable = null;

                        foreach (DataTable dtTmp2 in alTmp)
                        {

                            if (dtTmp2.TableName == "FPD_AircraftMovementsRolling")
                                dtAircraftMovement = dtTmp2;

                            if (dtTmp2.TableName == "FPD_CheckInShowUpRolling")
                                dtAirlineSmoothed = dtTmp2;

                            if (dtTmp2.TableName == "FPD_CheckInShowUpInstantaneous")
                                dtAirlineInstantaneous = dtTmp2;

                            if (dtTmp2.TableName == "FPD_OutBoundRolling")
                                dtOutBoundSmoothed = dtTmp2;

                            if (dtTmp2.TableName == "FPD_OutBoundInstantaneous")
                                dtOutBoundInstantaneous = dtTmp2;

                            if (dtTmp2.TableName == GlobalNames.FPD_TRANSFER_ICT_ROLLING)
                                transferICTSmoothedAirlineTable = dtTmp2;

                            if (dtTmp2.TableName == GlobalNames.FPD_TRANSFER_ICT_INSTANTANEOUS)
                                transferICTInstantaneousAirlineTable = dtTmp2;

                        }
                        if ((dtAircraftMovement == null) || (dtAirlineSmoothed == null) || (dtAirlineInstantaneous == null) || (dtOutBoundSmoothed == null) || (dtOutBoundInstantaneous == null))
                            continue;
                        if (transferICTSmoothedAirlineTable == null || transferICTInstantaneousAirlineTable == null)
                            continue;

                        if (FPD_CheckInShowUpSmoothed == null)
                        {
                            FPD_CheckInShowUpSmoothed = dtAirlineSmoothed.Copy();
                            FPD_CheckInShowUpSmoothed.TableName = FPD_CheckInShowUpSmoothed.TableName + "_Airline";
                            while (FPD_CheckInShowUpSmoothed.Columns.Count > 1)
                                FPD_CheckInShowUpSmoothed.Columns.RemoveAt(1);
                            FPD_CheckInShowUpBagSmoothed = FPD_CheckInShowUpSmoothed.Copy();
                            FPD_CheckInShowUpBagSmoothed.TableName = dtAirlineSmoothed.TableName + "_Bag_Airline";
                        }
                        if (FPD_CheckInShowUpInstantaneous == null)
                        {
                            FPD_CheckInShowUpInstantaneous = dtAirlineInstantaneous.Copy();
                            FPD_CheckInShowUpInstantaneous.TableName = FPD_CheckInShowUpInstantaneous.TableName + "_Airline";
                            while (FPD_CheckInShowUpInstantaneous.Columns.Count > 1)
                                FPD_CheckInShowUpInstantaneous.Columns.RemoveAt(1);
                            FPD_CheckInShowUpBagInstantaneous = FPD_CheckInShowUpInstantaneous.Copy();
                            FPD_CheckInShowUpBagInstantaneous.TableName = dtAirlineInstantaneous.TableName + "_Bag_Airline";
                        }
                        if (FPD_OutBoundSmoothed == null)
                        {
                            FPD_OutBoundSmoothed = dtOutBoundSmoothed.Copy();
                            FPD_OutBoundSmoothed.TableName = FPD_OutBoundSmoothed.TableName + "_Airline";
                            while (FPD_OutBoundSmoothed.Columns.Count > 1)
                                FPD_OutBoundSmoothed.Columns.RemoveAt(1);
                            FPD_OutBoundBagSmoothed = FPD_CheckInShowUpInstantaneous.Copy();
                            FPD_OutBoundBagSmoothed.TableName = dtOutBoundSmoothed.TableName + "_Bag_Airline";
                        }
                        if (FPD_OutBoundInstantaneous == null)
                        {
                            FPD_OutBoundInstantaneous = dtOutBoundInstantaneous.Copy();
                            FPD_OutBoundInstantaneous.TableName = FPD_OutBoundInstantaneous.TableName + "_Airline";
                            while (FPD_OutBoundInstantaneous.Columns.Count > 1)
                                FPD_OutBoundInstantaneous.Columns.RemoveAt(1);
                            FPD_OutBoundBagInstantaneous = FPD_OutBoundInstantaneous.Copy();
                            FPD_OutBoundBagInstantaneous.TableName = dtOutBoundInstantaneous.TableName + "_Bag_Airline";
                        }
                        if (FPD_AircraftMovementsAirline == null)
                        {
                            FPD_AircraftMovementsAirline = dtAircraftMovement.Copy();
                            FPD_AircraftMovementsAirline.TableName = "FPD_AircraftMovements_Airline";
                            while (FPD_AircraftMovementsAirline.Columns.Count > 1)
                                FPD_AircraftMovementsAirline.Columns.RemoveAt(1);
                        }

                        // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                        if (FPD_OutBoundSmoothedPAXOriginatingAirline == null)
                        {
                            FPD_OutBoundSmoothedPAXOriginatingAirline = dtOutBoundSmoothed.Copy();
                            FPD_OutBoundSmoothedPAXOriginatingAirline.TableName = GlobalNames.fpdOutboundSmoothedPAXOriginating_Airline;
                            while (FPD_OutBoundSmoothedPAXOriginatingAirline.Columns.Count > 1)
                                FPD_OutBoundSmoothedPAXOriginatingAirline.Columns.RemoveAt(1);
                            FPD_OutBoundSmoothedBagOriginatingAirline = FPD_OutBoundSmoothedPAXOriginatingAirline.Copy();
                            FPD_OutBoundSmoothedBagOriginatingAirline.TableName = GlobalNames.fpdOutboundSmoothedBagOriginating_Airline;
                        }
                        if (FPD_OutBoundInstantaneousPAXOriginatingAirline == null)
                        {
                            FPD_OutBoundInstantaneousPAXOriginatingAirline = dtOutBoundInstantaneous.Copy();
                            FPD_OutBoundInstantaneousPAXOriginatingAirline.TableName = GlobalNames.fpdOutboundInstantaneousPAXOriginating_Airline;
                            while (FPD_OutBoundInstantaneousPAXOriginatingAirline.Columns.Count > 1)
                                FPD_OutBoundInstantaneousPAXOriginatingAirline.Columns.RemoveAt(1);
                            FPD_OutBoundInstantaneousBagOriginatingAirline = FPD_OutBoundInstantaneousPAXOriginatingAirline.Copy();
                            FPD_OutBoundInstantaneousBagOriginatingAirline.TableName = GlobalNames.fpdOutboundInstantaneousBagOriginating_Airline;
                        }

                        if (FPD_OutBoundSmoothedPAXTransferringAirline == null)
                        {
                            FPD_OutBoundSmoothedPAXTransferringAirline = dtOutBoundSmoothed.Copy();
                            FPD_OutBoundSmoothedPAXTransferringAirline.TableName = GlobalNames.fpdOutboundSmoothedPAXTransferring_Airline;
                            while (FPD_OutBoundSmoothedPAXTransferringAirline.Columns.Count > 1)
                                FPD_OutBoundSmoothedPAXTransferringAirline.Columns.RemoveAt(1);
                            FPD_OutBoundSmoothedBagTransferringAirline = FPD_OutBoundSmoothedPAXTransferringAirline.Copy();
                            FPD_OutBoundSmoothedBagTransferringAirline.TableName = GlobalNames.fpdOutboundSmoothedBagTransferring_Airline;
                        }
                        if (FPD_OutBoundInstantaneousPAXTransferringAirline == null)
                        {
                            FPD_OutBoundInstantaneousPAXTransferringAirline = dtOutBoundInstantaneous.Copy();
                            FPD_OutBoundInstantaneousPAXTransferringAirline.TableName = GlobalNames.fpdOutboundInstantaneousPAXTransferring_Airline;
                            while (FPD_OutBoundInstantaneousPAXTransferringAirline.Columns.Count > 1)
                                FPD_OutBoundInstantaneousPAXTransferringAirline.Columns.RemoveAt(1);
                            FPD_OutBoundInstantaneousBagTransferringAirline = FPD_OutBoundInstantaneousPAXTransferringAirline.Copy();
                            FPD_OutBoundInstantaneousBagTransferringAirline.TableName = GlobalNames.fpdOutboundInstantaneousBagTransferring_Airline;
                        }
                        // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

                        if (FPD_TransferICTSmoothedAirline == null)
                        {
                            FPD_TransferICTSmoothedAirline = transferICTSmoothedAirlineTable.Copy();
                            FPD_TransferICTSmoothedAirline.TableName = transferICTSmoothedAirlineTable.TableName + "_Airline";
                            while (FPD_TransferICTSmoothedAirline.Columns.Count > 1)
                                FPD_TransferICTSmoothedAirline.Columns.RemoveAt(1);
                            FPD_TransferICTBagSmoothedAirline = FPD_TransferICTSmoothedAirline.Copy();
                            FPD_TransferICTBagSmoothedAirline.TableName = transferICTSmoothedAirlineTable.TableName + "_Bag_Airline";
                        }
                        if (FPD_TransferICTInstantaneousAirline == null)
                        {
                            FPD_TransferICTInstantaneousAirline = transferICTInstantaneousAirlineTable.Copy();
                            FPD_TransferICTInstantaneousAirline.TableName = FPD_TransferICTInstantaneousAirline.TableName + "_Airline";
                            while (FPD_TransferICTInstantaneousAirline.Columns.Count > 1)
                                FPD_TransferICTInstantaneousAirline.Columns.RemoveAt(1);
                            FPD_TransferICTBagInstantaneousAirline = FPD_TransferICTInstantaneousAirline.Copy();
                            FPD_TransferICTBagInstantaneousAirline.TableName = transferICTInstantaneousAirlineTable.TableName + "_Bag_Airline";
                        }

                        // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns                        
                        OverallTools.DataFunctions.ConcateneTable(FPD_CheckInShowUpSmoothed, dtAirlineSmoothed, new int[] { 2 }, sAirline + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPD_CheckInShowUpInstantaneous, dtAirlineInstantaneous, new int[] { 2 }, sAirline + "_");

                        OverallTools.DataFunctions.ConcateneTable(FPD_OutBoundSmoothed, dtOutBoundSmoothed, new int[] { 2 }, sAirline + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPD_OutBoundInstantaneous, dtOutBoundInstantaneous, new int[] { 2 }, sAirline + "_");

                        OverallTools.DataFunctions.ConcateneTable(FPD_CheckInShowUpBagSmoothed, dtAirlineSmoothed, new int[] { 4 }, sAirline + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPD_CheckInShowUpBagInstantaneous, dtAirlineInstantaneous, new int[] { 4 }, sAirline + "_");

                        OverallTools.DataFunctions.ConcateneTable(FPD_OutBoundBagSmoothed, dtOutBoundSmoothed, new int[] { 8 }, sAirline + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPD_OutBoundBagInstantaneous, dtOutBoundInstantaneous, new int[] { 8 }, sAirline + "_");
                        // >> Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                        OverallTools.DataFunctions.ConcateneTable(FPD_AircraftMovementsAirline, dtAircraftMovement, new int[] { 1 }, sAirline + "_");

                        // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_OutBoundSmoothedPAXOriginatingAirline, dtOutBoundSmoothed, new int[] { 4 }, sAirline + "_");
                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_OutBoundInstantaneousPAXOriginatingAirline, dtOutBoundInstantaneous, new int[] { 4 }, sAirline + "_");

                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_OutBoundSmoothedPAXTransferringAirline, dtOutBoundSmoothed, new int[] { 6 }, sAirline + "_");
                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_OutBoundInstantaneousPAXTransferringAirline, dtOutBoundInstantaneous, new int[] { 6 }, sAirline + "_");

                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_OutBoundSmoothedBagOriginatingAirline, dtOutBoundSmoothed, new int[] { 10 }, sAirline + "_");
                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_OutBoundInstantaneousBagOriginatingAirline, dtOutBoundInstantaneous, new int[] { 10 }, sAirline + "_");

                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_OutBoundSmoothedBagTransferringAirline, dtOutBoundSmoothed, new int[] { 12 }, sAirline + "_");
                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_OutBoundInstantaneousBagTransferringAirline, dtOutBoundInstantaneous, new int[] { 12 }, sAirline + "_");
                        // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_TransferICTSmoothedAirline, transferICTSmoothedAirlineTable, new int[] { 2 }, sAirline + "_");
                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_TransferICTInstantaneousAirline, transferICTInstantaneousAirlineTable, new int[] { 2 }, sAirline + "_");

                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_TransferICTBagSmoothedAirline, transferICTSmoothedAirlineTable, new int[] { 4 }, sAirline + "_");
                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_TransferICTBagInstantaneousAirline, transferICTInstantaneousAirlineTable, new int[] { 4 }, sAirline + "_");
                    }
                    if (FPD_CheckInShowUpSmoothed != null)
                    {
                        DataTable dtStats = new DataTable("FPD_Airline_Stats");
                        dtStats.Columns.Add("Airline", typeof(String));

                        dtStats.Columns.Add("CI_Smoothed_Pax_Max", typeof(Double));
                        dtStats.Columns.Add("CI_Instantaneous_Pax_Max", typeof(Double));
                        dtStats.Columns.Add("OutBound_Smoothed_Pax_Max", typeof(Double));
                        dtStats.Columns.Add("OutBound_Instantaneous_Pax_Max", typeof(Double));

                        dtStats.Columns.Add("CI_Smoothed_Bag_Max", typeof(Double));
                        dtStats.Columns.Add("CI_Instantaneous_Bag_Max", typeof(Double));
                        dtStats.Columns.Add("OutBound_Smoothed_Bag_Max", typeof(Double));
                        dtStats.Columns.Add("OutBound_Instantaneous_Bag_Max", typeof(Double));

                        for (i = 1; i < FPD_CheckInShowUpSmoothed.Columns.Count; i++)
                        {
                            if (alAirline.Count > i - 1)
                            {
                                DataRow drNewRow = dtStats.NewRow();
                                drNewRow[0] = alAirline[i - 1].ToString();
                                drNewRow[1] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_CheckInShowUpSmoothed, i);
                                drNewRow[2] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_CheckInShowUpInstantaneous, i);
                                drNewRow[3] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_OutBoundSmoothed, i);
                                drNewRow[4] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_OutBoundInstantaneous, i);
                                drNewRow[5] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_CheckInShowUpBagSmoothed, i);
                                drNewRow[6] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_CheckInShowUpBagInstantaneous, i);
                                drNewRow[7] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_OutBoundBagSmoothed, i);
                                drNewRow[8] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_OutBoundBagInstantaneous, i);
                                dtStats.Rows.Add(drNewRow);
                            }
                        }

                        alResult.Add(dtStats);
                        alResult.Add(FPD_CheckInShowUpSmoothed);
                        alResult.Add(FPD_CheckInShowUpInstantaneous);
                        alResult.Add(FPD_OutBoundSmoothed);
                        alResult.Add(FPD_OutBoundInstantaneous);

                        alResult.Add(FPD_CheckInShowUpBagSmoothed);
                        alResult.Add(FPD_CheckInShowUpBagInstantaneous);
                        alResult.Add(FPD_OutBoundBagSmoothed);
                        alResult.Add(FPD_OutBoundBagInstantaneous);
                        alResult.Add(FPD_AircraftMovementsAirline);

                        // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                        alResult.Add(FPD_OutBoundSmoothedPAXOriginatingAirline);
                        alResult.Add(FPD_OutBoundInstantaneousPAXOriginatingAirline);

                        alResult.Add(FPD_OutBoundSmoothedPAXTransferringAirline);
                        alResult.Add(FPD_OutBoundInstantaneousPAXTransferringAirline);

                        alResult.Add(FPD_OutBoundSmoothedBagOriginatingAirline);
                        alResult.Add(FPD_OutBoundInstantaneousBagOriginatingAirline);

                        alResult.Add(FPD_OutBoundSmoothedBagTransferringAirline);
                        alResult.Add(FPD_OutBoundInstantaneousBagTransferringAirline);
                        // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                        alResult.Add(FPD_TransferICTSmoothedAirline);
                        alResult.Add(FPD_TransferICTInstantaneousAirline);

                        alResult.Add(FPD_TransferICTBagSmoothedAirline);
                        alResult.Add(FPD_TransferICTBagInstantaneousAirline);
                    }
                }
                return alResult;
            }
            #endregion

            #region Function used for the terminal calculation
            internal static ArrayList CalcStaticAnalysisPerTerminal(DataTable dtFlightPlans,
                 DataManagement.NormalTable dtLoadFactors,
                 DataManagement.NormalTable dtAircraftType,
                 DataManagement.NormalTable dtShowUpProfile,
                 DataManagement.NormalTable dtOCTCheckIn,
                 DataManagement.NormalTable dtNbBags,
                 DataManagement.NormalTable dtNbVisitors,
                 DataManagement.NormalTable dtNbTrolley,
                DataTable dtFlightCategories,
                DateTime dtBegin,
                DateTime dtEnd,
                Double dStepAnalysis,
                Double dStepCumul,
                bool bUseStatisticStep,
                Double dStatisticStep,
                String sStatisticMode,
                ArrayList ListeErreurs,
                // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                bool bUseDefinedNbPax,
                DataTable dtNumberOfPassengers,
                bool bUseDefinedNbBags,
                DataTable dtNumberOfBaggages
                // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                , double[] distributionLevels   // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                , NormalTable interConnectingTimeTable,
                List<FlightConfiguration> userDefineFlightConfigurations    // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                )
            {
                ArrayList alResult = CalcStaticAnalysis2(dtFlightPlans, dtLoadFactors, dtAircraftType, dtShowUpProfile,
                    dtOCTCheckIn, dtNbBags, dtNbVisitors, dtNbTrolley, dtFlightCategories, dtBegin, dtEnd, dStepAnalysis,
                    dStepCumul, bUseStatisticStep, dStatisticStep, sStatisticMode, ListeErreurs,
                    bUseDefinedNbPax, dtNumberOfPassengers, bUseDefinedNbBags, dtNumberOfBaggages // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                    , distributionLevels, interConnectingTimeTable, userDefineFlightConfigurations    // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                    );
                if (alResult == null)
                    return null;
                if (dtFlightPlans.Rows.Count != 0)
                {
                    ArrayList alTerminal = new ArrayList();
                    int iIndexAirline = dtFlightPlans.Columns.IndexOf(GlobalNames.sFPD_Column_TerminalCI);
                    if (iIndexAirline == -1)
                        return alResult;
                    int i;
                    for (i = 0; i < dtFlightPlans.Rows.Count; i++)
                    {
                        if (!alTerminal.Contains(dtFlightPlans.Rows[i][iIndexAirline].ToString()))
                            alTerminal.Add(dtFlightPlans.Rows[i][iIndexAirline].ToString());
                    }
                    alTerminal.Sort(new FonctionUtiles.ColumnsComparer());
                    DataTable FPD_AircraftMovementsTerminal = null;
                    DataTable dtTmp = dtFlightPlans.Clone();
                    DataTable FPD_CheckInShowUpSmoothed = null;
                    DataTable FPD_CheckInShowUpInstantaneous = null;
                    DataTable FPD_OutBoundSmoothed = null;
                    DataTable FPD_OutBoundInstantaneous = null;

                    DataTable FPD_CheckInShowUpBagSmoothed = null;
                    DataTable FPD_CheckInShowUpBagInstantaneous = null;
                    DataTable FPD_OutBoundBagSmoothed = null;
                    DataTable FPD_OutBoundBagInstantaneous = null;

                    // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                    DataTable FPD_OutBoundSmoothedPAXOriginatingTerminal = null;
                    DataTable FPD_OutBoundInstantaneousPAXOriginatingTerminal = null;

                    DataTable FPD_OutBoundSmoothedPAXTransferringTerminal = null;
                    DataTable FPD_OutBoundInstantaneousPAXTransferringTerminal = null;

                    DataTable FPD_OutBOundSmoothedBagOriginatingTerminal = null;
                    DataTable FPD_OutBoundInstantaneousBagOriginatingTerminal = null;

                    DataTable FPD_OutBoundSmoothedBagTransferringTerminal = null;
                    DataTable FPD_OutBoundInstantaneousBagTransferringTerminal = null;
                    // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

                    // >> Bug #11860 Pax2Sim - Static analysis - EBS calculation FB exception 2                    
                    DataTable FPD_TransferICTSmoothedTerminal = null;
                    DataTable FPD_TransferICTInstantaneousTerminal = null;

                    DataTable FPD_TransferICTBagSmoothedTerminal = null;
                    DataTable FPD_TransferICTBagInstantaneousTerminal = null;
                    // << Bug #11860 Pax2Sim - Static analysis - EBS calculation FB exception 2

                    for (i = 0; i < alTerminal.Count; i++)
                    {
                        String sAirline = alTerminal[i].ToString();
                        String sAirlineName = "Terminal " + alTerminal[i].ToString();
                        dtTmp.Rows.Clear();
                        foreach (DataRow drTmp in dtFlightPlans.Rows)
                        {
                            if (drTmp[iIndexAirline].ToString() == sAirline)
                                dtTmp.Rows.Add(drTmp.ItemArray);
                        }
                        ArrayList alTmp = CalcStaticAnalysis2(dtTmp, dtLoadFactors, dtAircraftType, dtShowUpProfile, dtOCTCheckIn,
                            dtNbBags, dtNbVisitors, dtNbTrolley, dtFlightCategories, dtBegin, dtEnd, dStepAnalysis, dStepCumul,
                            bUseStatisticStep, dStatisticStep, sStatisticMode, ListeErreurs,
                            bUseDefinedNbPax, dtNumberOfPassengers, bUseDefinedNbBags, dtNumberOfBaggages // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                            , distributionLevels, interConnectingTimeTable, userDefineFlightConfigurations    // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                            );
                        if (alTmp == null)
                            continue;
                        DataTable dtAircraftMovement = null;
                        DataTable dtAirlineSmoothed = null;
                        DataTable dtAirlineInstantaneous = null;
                        DataTable dtOutBoundSmoothed = null;
                        DataTable dtOutBoundInstantaneous = null;
                        DataTable transferICTSmoothedTerminalTable = null;
                        DataTable transferICTInstantaneousTerminalTable = null;

                        foreach (DataTable dtTmp2 in alTmp)
                        {

                            if (dtTmp2.TableName == "FPD_AircraftMovementsRolling")
                                dtAircraftMovement = dtTmp2;

                            if (dtTmp2.TableName == "FPD_CheckInShowUpRolling")
                                dtAirlineSmoothed = dtTmp2;

                            if (dtTmp2.TableName == "FPD_CheckInShowUpInstantaneous")
                                dtAirlineInstantaneous = dtTmp2;

                            if (dtTmp2.TableName == "FPD_OutBoundRolling")
                                dtOutBoundSmoothed = dtTmp2;

                            if (dtTmp2.TableName == "FPD_OutBoundInstantaneous")
                                dtOutBoundInstantaneous = dtTmp2;

                            if (dtTmp2.TableName == GlobalNames.FPD_TRANSFER_ICT_ROLLING)
                                transferICTSmoothedTerminalTable = dtTmp2;

                            if (dtTmp2.TableName == GlobalNames.FPD_TRANSFER_ICT_INSTANTANEOUS)
                                transferICTInstantaneousTerminalTable = dtTmp2;

                        }
                        if ((dtAirlineSmoothed == null) || (dtAirlineInstantaneous == null) || (dtOutBoundSmoothed == null) || (dtOutBoundInstantaneous == null))
                            continue;
                        if (transferICTInstantaneousTerminalTable == null || transferICTSmoothedTerminalTable == null)
                            continue;

                        if (FPD_CheckInShowUpSmoothed == null)
                        {
                            FPD_CheckInShowUpSmoothed = dtAirlineSmoothed.Copy();
                            FPD_CheckInShowUpSmoothed.TableName = FPD_CheckInShowUpSmoothed.TableName + "_Terminal";
                            while (FPD_CheckInShowUpSmoothed.Columns.Count > 1)
                                FPD_CheckInShowUpSmoothed.Columns.RemoveAt(1);
                            FPD_CheckInShowUpBagSmoothed = FPD_CheckInShowUpSmoothed.Copy();
                            FPD_CheckInShowUpBagSmoothed.TableName = dtAirlineSmoothed.TableName + "_Bag_Terminal";
                        }
                        if (FPD_CheckInShowUpInstantaneous == null)
                        {
                            FPD_CheckInShowUpInstantaneous = dtAirlineInstantaneous.Copy();
                            FPD_CheckInShowUpInstantaneous.TableName = FPD_CheckInShowUpInstantaneous.TableName + "_Terminal";
                            while (FPD_CheckInShowUpInstantaneous.Columns.Count > 1)
                                FPD_CheckInShowUpInstantaneous.Columns.RemoveAt(1);
                            FPD_CheckInShowUpBagInstantaneous = FPD_CheckInShowUpInstantaneous.Copy();
                            FPD_CheckInShowUpBagInstantaneous.TableName = dtAirlineInstantaneous.TableName + "_Bag_Terminal";
                        }
                        if (FPD_OutBoundSmoothed == null)
                        {
                            FPD_OutBoundSmoothed = dtOutBoundSmoothed.Copy();
                            FPD_OutBoundSmoothed.TableName = FPD_OutBoundSmoothed.TableName + "_Terminal";
                            while (FPD_OutBoundSmoothed.Columns.Count > 1)
                                FPD_OutBoundSmoothed.Columns.RemoveAt(1);
                            FPD_OutBoundBagSmoothed = FPD_CheckInShowUpInstantaneous.Copy();
                            FPD_OutBoundBagSmoothed.TableName = dtOutBoundSmoothed.TableName + "_Bag_Terminal";
                        }
                        if (FPD_OutBoundInstantaneous == null)
                        {
                            FPD_OutBoundInstantaneous = dtOutBoundInstantaneous.Copy();
                            FPD_OutBoundInstantaneous.TableName = FPD_OutBoundInstantaneous.TableName + "_Terminal";
                            while (FPD_OutBoundInstantaneous.Columns.Count > 1)
                                FPD_OutBoundInstantaneous.Columns.RemoveAt(1);
                            FPD_OutBoundBagInstantaneous = FPD_OutBoundInstantaneous.Copy();
                            FPD_OutBoundBagInstantaneous.TableName = dtOutBoundInstantaneous.TableName + "_Bag_Terminal";
                        }
                        if (FPD_AircraftMovementsTerminal == null)
                        {
                            FPD_AircraftMovementsTerminal = dtAircraftMovement.Copy();
                            FPD_AircraftMovementsTerminal.TableName = "FPD_AircraftMovements_Terminal";
                            while (FPD_AircraftMovementsTerminal.Columns.Count > 1)
                                FPD_AircraftMovementsTerminal.Columns.RemoveAt(1);
                        }

                        // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                        if (FPD_OutBoundSmoothedPAXOriginatingTerminal == null)
                        {
                            FPD_OutBoundSmoothedPAXOriginatingTerminal = dtOutBoundSmoothed.Copy();
                            FPD_OutBoundSmoothedPAXOriginatingTerminal.TableName = GlobalNames.fpdOutboundSmoothedPAXOriginating_Terminal;
                            while (FPD_OutBoundSmoothedPAXOriginatingTerminal.Columns.Count > 1)
                                FPD_OutBoundSmoothedPAXOriginatingTerminal.Columns.RemoveAt(1);
                            FPD_OutBOundSmoothedBagOriginatingTerminal = FPD_OutBoundSmoothedPAXOriginatingTerminal.Copy();
                            FPD_OutBOundSmoothedBagOriginatingTerminal.TableName = GlobalNames.fpdOutboundSmoothedBagOriginating_Terminal;
                        }
                        if (FPD_OutBoundInstantaneousPAXOriginatingTerminal == null)
                        {
                            FPD_OutBoundInstantaneousPAXOriginatingTerminal = dtOutBoundInstantaneous.Copy();
                            FPD_OutBoundInstantaneousPAXOriginatingTerminal.TableName = GlobalNames.fpdOutboundInstantaneousPAXOriginating_Terminal;
                            while (FPD_OutBoundInstantaneousPAXOriginatingTerminal.Columns.Count > 1)
                                FPD_OutBoundInstantaneousPAXOriginatingTerminal.Columns.RemoveAt(1);
                            FPD_OutBoundInstantaneousBagOriginatingTerminal = FPD_OutBoundInstantaneousPAXOriginatingTerminal.Copy();
                            FPD_OutBoundInstantaneousBagOriginatingTerminal.TableName = GlobalNames.fpdOutboundInstantaneousBagOriginating_Terminal;
                        }

                        if (FPD_OutBoundSmoothedPAXTransferringTerminal == null)
                        {
                            FPD_OutBoundSmoothedPAXTransferringTerminal = dtOutBoundSmoothed.Copy();
                            FPD_OutBoundSmoothedPAXTransferringTerminal.TableName = GlobalNames.fpdOutboundSmoothedPAXTransferring_Terminal;
                            while (FPD_OutBoundSmoothedPAXTransferringTerminal.Columns.Count > 1)
                                FPD_OutBoundSmoothedPAXTransferringTerminal.Columns.RemoveAt(1);
                            FPD_OutBoundSmoothedBagTransferringTerminal = FPD_OutBoundSmoothedPAXTransferringTerminal.Copy();
                            FPD_OutBoundSmoothedBagTransferringTerminal.TableName = GlobalNames.fpdOutboundSmoothedBagTransferring_Terminal;
                        }
                        if (FPD_OutBoundInstantaneousPAXTransferringTerminal == null)
                        {
                            FPD_OutBoundInstantaneousPAXTransferringTerminal = dtOutBoundInstantaneous.Copy();
                            FPD_OutBoundInstantaneousPAXTransferringTerminal.TableName = GlobalNames.fpdOutboundInstantaneousPAXTransferring_Terminal;
                            while (FPD_OutBoundInstantaneousPAXTransferringTerminal.Columns.Count > 1)
                                FPD_OutBoundInstantaneousPAXTransferringTerminal.Columns.RemoveAt(1);
                            FPD_OutBoundInstantaneousBagTransferringTerminal = FPD_OutBoundInstantaneousPAXTransferringTerminal.Copy();
                            FPD_OutBoundInstantaneousBagTransferringTerminal.TableName = GlobalNames.fpdOutboundInstantaneousBagTransferring_Terminal;
                        }
                        // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

                        if (FPD_TransferICTSmoothedTerminal == null)
                        {
                            FPD_TransferICTSmoothedTerminal = transferICTSmoothedTerminalTable.Copy();
                            FPD_TransferICTSmoothedTerminal.TableName = transferICTSmoothedTerminalTable.TableName + "_Terminal";
                            while (FPD_TransferICTSmoothedTerminal.Columns.Count > 1)
                                FPD_TransferICTSmoothedTerminal.Columns.RemoveAt(1);
                            FPD_TransferICTBagSmoothedTerminal = FPD_TransferICTSmoothedTerminal.Copy();
                            FPD_TransferICTBagSmoothedTerminal.TableName = transferICTSmoothedTerminalTable.TableName + "_Bag_Terminal";
                        }
                        if (FPD_TransferICTInstantaneousTerminal == null)
                        {
                            FPD_TransferICTInstantaneousTerminal = transferICTInstantaneousTerminalTable.Copy();
                            FPD_TransferICTInstantaneousTerminal.TableName = FPD_TransferICTInstantaneousTerminal.TableName + "_Terminal";
                            while (FPD_TransferICTInstantaneousTerminal.Columns.Count > 1)
                                FPD_TransferICTInstantaneousTerminal.Columns.RemoveAt(1);
                            FPD_TransferICTBagInstantaneousTerminal = FPD_TransferICTInstantaneousTerminal.Copy();
                            FPD_TransferICTBagInstantaneousTerminal.TableName = transferICTInstantaneousTerminalTable.TableName + "_Bag_Terminal";
                        }

                        // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns                        
                        OverallTools.DataFunctions.ConcateneTable(FPD_CheckInShowUpSmoothed, dtAirlineSmoothed, new int[] { 2 }, sAirlineName + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPD_CheckInShowUpInstantaneous, dtAirlineInstantaneous, new int[] { 2 }, sAirlineName + "_");

                        OverallTools.DataFunctions.ConcateneTable(FPD_OutBoundSmoothed, dtOutBoundSmoothed, new int[] { 2 }, sAirlineName + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPD_OutBoundInstantaneous, dtOutBoundInstantaneous, new int[] { 2 }, sAirlineName + "_");

                        OverallTools.DataFunctions.ConcateneTable(FPD_CheckInShowUpBagSmoothed, dtAirlineSmoothed, new int[] { 4 }, sAirlineName + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPD_CheckInShowUpBagInstantaneous, dtAirlineInstantaneous, new int[] { 4 }, sAirlineName + "_");

                        OverallTools.DataFunctions.ConcateneTable(FPD_OutBoundBagSmoothed, dtOutBoundSmoothed, new int[] { 8 }, sAirlineName + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPD_OutBoundBagInstantaneous, dtOutBoundInstantaneous, new int[] { 8 }, sAirlineName + "_");
                        // >> Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                        // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_OutBoundSmoothedPAXOriginatingTerminal, dtOutBoundSmoothed, new int[] { 4 }, sAirline + "_");
                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_OutBoundInstantaneousPAXOriginatingTerminal, dtOutBoundInstantaneous, new int[] { 4 }, sAirline + "_");

                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_OutBoundSmoothedPAXTransferringTerminal, dtOutBoundSmoothed, new int[] { 6 }, sAirline + "_");
                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_OutBoundInstantaneousPAXTransferringTerminal, dtOutBoundInstantaneous, new int[] { 6 }, sAirline + "_");

                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_OutBOundSmoothedBagOriginatingTerminal, dtOutBoundSmoothed, new int[] { 10 }, sAirline + "_");
                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_OutBoundInstantaneousBagOriginatingTerminal, dtOutBoundInstantaneous, new int[] { 10 }, sAirline + "_");

                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_OutBoundSmoothedBagTransferringTerminal, dtOutBoundSmoothed, new int[] { 12 }, sAirline + "_");
                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_OutBoundInstantaneousBagTransferringTerminal, dtOutBoundInstantaneous, new int[] { 12 }, sAirline + "_");
                        // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_TransferICTSmoothedTerminal, transferICTSmoothedTerminalTable, new int[] { 2 }, sAirlineName + "_");
                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_TransferICTInstantaneousTerminal, transferICTInstantaneousTerminalTable, new int[] { 2 }, sAirlineName + "_");

                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_TransferICTBagSmoothedTerminal, transferICTSmoothedTerminalTable, new int[] { 4 }, sAirlineName + "_");
                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_TransferICTBagInstantaneousTerminal, transferICTInstantaneousTerminalTable, new int[] { 4 }, sAirlineName + "_");

                        OverallTools.DataFunctions.ConcateneTable(FPD_AircraftMovementsTerminal, dtAircraftMovement, new int[] { 1 }, sAirlineName + "_");
                    }
                    if (FPD_CheckInShowUpSmoothed != null)
                    {
                        DataTable dtStats = new DataTable("FPD_Terminal_Stats");
                        dtStats.Columns.Add("Terminal", typeof(String));

                        dtStats.Columns.Add("CI_Smoothed_Pax_Max", typeof(Double));
                        dtStats.Columns.Add("CI_Instantaneous_Pax_Max", typeof(Double));
                        dtStats.Columns.Add("OutBound_Smoothed_Pax_Max", typeof(Double));
                        dtStats.Columns.Add("OutBound_Instantaneous_Pax_Max", typeof(Double));

                        dtStats.Columns.Add("CI_Smoothed_Bag_Max", typeof(Double));
                        dtStats.Columns.Add("CI_Instantaneous_Bag_Max", typeof(Double));
                        dtStats.Columns.Add("OutBound_Smoothed_Bag_Max", typeof(Double));
                        dtStats.Columns.Add("OutBound_Instantaneous_Bag_Max", typeof(Double));

                        for (i = 1; i < FPD_CheckInShowUpSmoothed.Columns.Count; i++)
                        {
                            if (alTerminal.Count > i - 1)
                            {
                                DataRow drNewRow = dtStats.NewRow();
                                drNewRow[0] = alTerminal[i - 1].ToString();
                                drNewRow[1] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_CheckInShowUpSmoothed, i);
                                drNewRow[2] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_CheckInShowUpInstantaneous, i);
                                drNewRow[3] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_OutBoundSmoothed, i);
                                drNewRow[4] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_OutBoundInstantaneous, i);
                                drNewRow[5] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_CheckInShowUpBagSmoothed, i);
                                drNewRow[6] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_CheckInShowUpBagInstantaneous, i);
                                drNewRow[7] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_OutBoundBagSmoothed, i);
                                drNewRow[8] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_OutBoundBagInstantaneous, i);
                                dtStats.Rows.Add(drNewRow);
                            }
                        }

                        alResult.Add(dtStats);
                        alResult.Add(FPD_CheckInShowUpSmoothed);
                        alResult.Add(FPD_CheckInShowUpInstantaneous);
                        alResult.Add(FPD_OutBoundSmoothed);
                        alResult.Add(FPD_OutBoundInstantaneous);

                        alResult.Add(FPD_CheckInShowUpBagSmoothed);
                        alResult.Add(FPD_CheckInShowUpBagInstantaneous);
                        alResult.Add(FPD_OutBoundBagSmoothed);
                        alResult.Add(FPD_OutBoundBagInstantaneous);

                        // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                        alResult.Add(FPD_OutBoundSmoothedPAXOriginatingTerminal);
                        alResult.Add(FPD_OutBoundInstantaneousPAXOriginatingTerminal);

                        alResult.Add(FPD_OutBoundSmoothedPAXTransferringTerminal);
                        alResult.Add(FPD_OutBoundInstantaneousPAXTransferringTerminal);

                        alResult.Add(FPD_OutBOundSmoothedBagOriginatingTerminal);
                        alResult.Add(FPD_OutBoundInstantaneousBagOriginatingTerminal);

                        alResult.Add(FPD_OutBoundSmoothedBagTransferringTerminal);
                        alResult.Add(FPD_OutBoundInstantaneousBagTransferringTerminal);
                        // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                        alResult.Add(FPD_TransferICTInstantaneousTerminal);
                        alResult.Add(FPD_TransferICTSmoothedTerminal);
                        alResult.Add(FPD_TransferICTBagInstantaneousTerminal);
                        alResult.Add(FPD_TransferICTBagSmoothedTerminal);

                        alResult.Add(FPD_AircraftMovementsTerminal);
                    }
                }
                return alResult;
            }
            #endregion

            #region Function used for the flight category calculation
            internal static ArrayList CalcStaticAnalysisPerFlightCategory(DataTable dtFlightPlans,
                 DataManagement.NormalTable dtLoadFactors,
                 DataManagement.NormalTable dtAircraftType,
                 DataManagement.NormalTable dtShowUpProfile,
                 DataManagement.NormalTable dtOCTCheckIn,
                 DataManagement.NormalTable dtNbBags,
                 DataManagement.NormalTable dtNbVisitors,
                 DataManagement.NormalTable dtNbTrolley,
                DataTable dtFlightCategories,
                DateTime dtBegin,
                DateTime dtEnd,
                Double dStepAnalysis,
                Double dStepCumul,
                bool bUseStatisticStep,
                Double dStatisticStep,
                String sStatisticMode,
                ArrayList ListeErreurs,
                // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                bool bUseDefinedNbPax,
                DataTable dtNumberOfPassengers,
                bool bUseDefinedNbBags,
                DataTable dtNumberOfBaggages
                // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                , double[] distributionLevels,   // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                NormalTable interConnectingTimeTable,
                List<FlightConfiguration> userDefineFlightConfigurations    // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                )
            {
                ArrayList alResult = CalcStaticAnalysis2(dtFlightPlans, dtLoadFactors, dtAircraftType, dtShowUpProfile,
                    dtOCTCheckIn, dtNbBags, dtNbVisitors, dtNbTrolley, dtFlightCategories, dtBegin, dtEnd, dStepAnalysis,
                    dStepCumul, bUseStatisticStep, dStatisticStep, sStatisticMode, ListeErreurs,
                    bUseDefinedNbPax, dtNumberOfPassengers, bUseDefinedNbBags, dtNumberOfBaggages // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                    , distributionLevels, interConnectingTimeTable, userDefineFlightConfigurations    // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                    );
                if (alResult == null)
                    return null;
                if (dtFlightPlans.Rows.Count != 0)
                {
                    ArrayList alFlightCategory = new ArrayList();
                    int iIndexFlightCategory = dtFlightPlans.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightCategory);
                    if (iIndexFlightCategory == -1)
                        return alResult;
                    int i;
                    for (i = 0; i < dtFlightPlans.Rows.Count; i++)
                    {
                        if (!alFlightCategory.Contains(dtFlightPlans.Rows[i][iIndexFlightCategory].ToString()))
                            alFlightCategory.Add(dtFlightPlans.Rows[i][iIndexFlightCategory].ToString());
                    }
                    alFlightCategory.Sort(new FonctionUtiles.ColumnsComparer());
                    DataTable FPD_AircraftMovementsTerminal = null;
                    DataTable dtTmp = dtFlightPlans.Clone();
                    DataTable FPD_CheckInShowUpSmoothed = null;
                    DataTable FPD_CheckInShowUpInstantaneous = null;
                    DataTable FPD_OutBoundSmoothed = null;
                    DataTable FPD_OutBoundInstantaneous = null;

                    DataTable FPD_CheckInShowUpBagSmoothed = null;
                    DataTable FPD_CheckInShowUpBagInstantaneous = null;
                    DataTable FPD_OutBoundBagSmoothed = null;
                    DataTable FPD_OutBoundBagInstantaneous = null;
                    // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                    DataTable FPD_OutBoundSmoothedPAXOriginatingFC = null;
                    DataTable FPD_OutBoundInstantaneousPAXOriginatingFC = null;

                    DataTable FPD_OutBoundSmoothedPAXTransferringFC = null;
                    DataTable FPD_OutBoundInstantaneousPAXTransferringFC = null;

                    DataTable FPD_OutBoundSmoothedBagOriginatingFC = null;
                    DataTable FPD_OutBoundInstantaneousBagOriginatingFC = null;

                    DataTable FPD_OutBoundSmoothedBagTransferringFC = null;
                    DataTable FPD_OutBoundInstantaneousBagTransferringFC = null;
                    // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

                    // >> Bug #11860 Pax2Sim - Static analysis - EBS calculation FB exception 2                    
                    DataTable FPD_TransferICTSmoothedFC = null;
                    DataTable FPD_TransferICTInstantaneousFC = null;

                    DataTable FPD_TransferICTBagSmoothedFC = null;
                    DataTable FPD_TransferICTBagInstantaneousFC = null;
                    // << Bug #11860 Pax2Sim - Static analysis - EBS calculation FB exception 2

                    for (i = 0; i < alFlightCategory.Count; i++)
                    {
                        String sAirline = alFlightCategory[i].ToString();
                        dtTmp.Rows.Clear();
                        foreach (DataRow drTmp in dtFlightPlans.Rows)
                        {
                            if (drTmp[iIndexFlightCategory].ToString() == sAirline)
                                dtTmp.Rows.Add(drTmp.ItemArray);
                        }
                        ArrayList alTmp = CalcStaticAnalysis2(dtTmp, dtLoadFactors, dtAircraftType, dtShowUpProfile,
                            dtOCTCheckIn, dtNbBags, dtNbVisitors, dtNbTrolley, dtFlightCategories, dtBegin, dtEnd, dStepAnalysis,
                            dStepCumul, bUseStatisticStep, dStatisticStep, sStatisticMode, ListeErreurs,
                            bUseDefinedNbPax, dtNumberOfPassengers, bUseDefinedNbBags, dtNumberOfBaggages // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                            , distributionLevels, interConnectingTimeTable, userDefineFlightConfigurations    // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                            );
                        if (alTmp == null)
                            continue;
                        DataTable dtAircraftMovement = null;
                        DataTable dtAirlineSmoothed = null;
                        DataTable dtAirlineInstantaneous = null;
                        DataTable dtOutBoundSmoothed = null;
                        DataTable dtOutBoundInstantaneous = null;
                        DataTable transferICTSmoothedFCTable = null;
                        DataTable transferICTInstantaneousFCTable = null;

                        foreach (DataTable dtTmp2 in alTmp)
                        {

                            if (dtTmp2.TableName == "FPD_AircraftMovementsRolling")
                                dtAircraftMovement = dtTmp2;

                            if (dtTmp2.TableName == "FPD_CheckInShowUpRolling")
                                dtAirlineSmoothed = dtTmp2;

                            if (dtTmp2.TableName == "FPD_CheckInShowUpInstantaneous")
                                dtAirlineInstantaneous = dtTmp2;

                            if (dtTmp2.TableName == "FPD_OutBoundRolling")
                                dtOutBoundSmoothed = dtTmp2;

                            if (dtTmp2.TableName == "FPD_OutBoundInstantaneous")
                                dtOutBoundInstantaneous = dtTmp2;

                            if (dtTmp2.TableName == GlobalNames.FPD_TRANSFER_ICT_ROLLING)
                                transferICTSmoothedFCTable = dtTmp2;

                            if (dtTmp2.TableName == GlobalNames.FPD_TRANSFER_ICT_INSTANTANEOUS)
                                transferICTInstantaneousFCTable = dtTmp2;

                        }
                        if ((dtAirlineSmoothed == null) || (dtAirlineInstantaneous == null) || (dtOutBoundSmoothed == null) || (dtOutBoundInstantaneous == null))
                            continue;
                        if (transferICTInstantaneousFCTable == null || transferICTSmoothedFCTable == null)
                            continue;

                        if (FPD_CheckInShowUpSmoothed == null)
                        {
                            FPD_CheckInShowUpSmoothed = dtAirlineSmoothed.Copy();
                            FPD_CheckInShowUpSmoothed.TableName = FPD_CheckInShowUpSmoothed.TableName + "_FC";
                            while (FPD_CheckInShowUpSmoothed.Columns.Count > 1)
                                FPD_CheckInShowUpSmoothed.Columns.RemoveAt(1);
                            FPD_CheckInShowUpBagSmoothed = FPD_CheckInShowUpSmoothed.Copy();
                            FPD_CheckInShowUpBagSmoothed.TableName = dtAirlineSmoothed.TableName + "_Bag_FC";
                        }
                        if (FPD_CheckInShowUpInstantaneous == null)
                        {
                            FPD_CheckInShowUpInstantaneous = dtAirlineInstantaneous.Copy();
                            FPD_CheckInShowUpInstantaneous.TableName = FPD_CheckInShowUpInstantaneous.TableName + "_FC";
                            while (FPD_CheckInShowUpInstantaneous.Columns.Count > 1)
                                FPD_CheckInShowUpInstantaneous.Columns.RemoveAt(1);
                            FPD_CheckInShowUpBagInstantaneous = FPD_CheckInShowUpInstantaneous.Copy();
                            FPD_CheckInShowUpBagInstantaneous.TableName = dtAirlineInstantaneous.TableName + "_Bag_FC";
                        }
                        if (FPD_OutBoundSmoothed == null)
                        {
                            FPD_OutBoundSmoothed = dtOutBoundSmoothed.Copy();
                            FPD_OutBoundSmoothed.TableName = FPD_OutBoundSmoothed.TableName + "_FC";
                            while (FPD_OutBoundSmoothed.Columns.Count > 1)
                                FPD_OutBoundSmoothed.Columns.RemoveAt(1);
                            FPD_OutBoundBagSmoothed = FPD_CheckInShowUpInstantaneous.Copy();
                            FPD_OutBoundBagSmoothed.TableName = dtOutBoundSmoothed.TableName + "_Bag_FC";
                        }
                        if (FPD_OutBoundInstantaneous == null)
                        {
                            FPD_OutBoundInstantaneous = dtOutBoundInstantaneous.Copy();
                            FPD_OutBoundInstantaneous.TableName = FPD_OutBoundInstantaneous.TableName + "_FC";
                            while (FPD_OutBoundInstantaneous.Columns.Count > 1)
                                FPD_OutBoundInstantaneous.Columns.RemoveAt(1);
                            FPD_OutBoundBagInstantaneous = FPD_OutBoundInstantaneous.Copy();
                            FPD_OutBoundBagInstantaneous.TableName = dtOutBoundInstantaneous.TableName + "_Bag_FC";
                        }

                        // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                        if (FPD_OutBoundSmoothedPAXOriginatingFC == null)
                        {
                            FPD_OutBoundSmoothedPAXOriginatingFC = dtOutBoundSmoothed.Copy();
                            FPD_OutBoundSmoothedPAXOriginatingFC.TableName = GlobalNames.fpdOutBoundSmoothedPAXOriginating_FC;
                            while (FPD_OutBoundSmoothedPAXOriginatingFC.Columns.Count > 1)
                                FPD_OutBoundSmoothedPAXOriginatingFC.Columns.RemoveAt(1);
                            FPD_OutBoundSmoothedBagOriginatingFC = FPD_OutBoundSmoothedPAXOriginatingFC.Copy();
                            FPD_OutBoundSmoothedBagOriginatingFC.TableName = GlobalNames.fpdOutBoundSmoothedBagOriginating_FC;
                        }
                        if (FPD_OutBoundInstantaneousPAXOriginatingFC == null)
                        {
                            FPD_OutBoundInstantaneousPAXOriginatingFC = dtOutBoundInstantaneous.Copy();
                            FPD_OutBoundInstantaneousPAXOriginatingFC.TableName = GlobalNames.fpdOutBoundInstantaneousPAXOriginating_FC;
                            while (FPD_OutBoundInstantaneousPAXOriginatingFC.Columns.Count > 1)
                                FPD_OutBoundInstantaneousPAXOriginatingFC.Columns.RemoveAt(1);
                            FPD_OutBoundInstantaneousBagOriginatingFC = FPD_OutBoundInstantaneousPAXOriginatingFC.Copy();
                            FPD_OutBoundInstantaneousBagOriginatingFC.TableName = GlobalNames.fpdOutBoundInstantaneousBagOriginating_FC;
                        }

                        if (FPD_OutBoundSmoothedPAXTransferringFC == null)
                        {
                            FPD_OutBoundSmoothedPAXTransferringFC = dtOutBoundSmoothed.Copy();
                            FPD_OutBoundSmoothedPAXTransferringFC.TableName = GlobalNames.fpdOutBoundSmoothedPAXTransfering_FC;
                            while (FPD_OutBoundSmoothedPAXTransferringFC.Columns.Count > 1)
                                FPD_OutBoundSmoothedPAXTransferringFC.Columns.RemoveAt(1);
                            FPD_OutBoundSmoothedBagTransferringFC = FPD_OutBoundSmoothedPAXTransferringFC.Copy();
                            FPD_OutBoundSmoothedBagTransferringFC.TableName = GlobalNames.fpdOutBoundSmoothedBagTransfering_FC;
                        }
                        if (FPD_OutBoundInstantaneousPAXTransferringFC == null)
                        {
                            FPD_OutBoundInstantaneousPAXTransferringFC = dtOutBoundInstantaneous.Copy();
                            FPD_OutBoundInstantaneousPAXTransferringFC.TableName = GlobalNames.fpdOutBoundInstantaneousPAXTransfering_FC;
                            while (FPD_OutBoundInstantaneousPAXTransferringFC.Columns.Count > 1)
                                FPD_OutBoundInstantaneousPAXTransferringFC.Columns.RemoveAt(1);
                            FPD_OutBoundInstantaneousBagTransferringFC = FPD_OutBoundInstantaneousPAXTransferringFC.Copy();
                            FPD_OutBoundInstantaneousBagTransferringFC.TableName = GlobalNames.fpdOutBoundInstantaneousBagTransfering_FC;
                        }
                        // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

                        if (FPD_TransferICTSmoothedFC == null)
                        {
                            FPD_TransferICTSmoothedFC = transferICTSmoothedFCTable.Copy();
                            FPD_TransferICTSmoothedFC.TableName = transferICTSmoothedFCTable.TableName + "_FC";
                            while (FPD_TransferICTSmoothedFC.Columns.Count > 1)
                                FPD_TransferICTSmoothedFC.Columns.RemoveAt(1);
                            FPD_TransferICTBagSmoothedFC = FPD_TransferICTSmoothedFC.Copy();
                            FPD_TransferICTBagSmoothedFC.TableName = transferICTSmoothedFCTable.TableName + "_Bag_FC";
                        }
                        if (FPD_TransferICTInstantaneousFC == null)
                        {
                            FPD_TransferICTInstantaneousFC = transferICTInstantaneousFCTable.Copy();
                            FPD_TransferICTInstantaneousFC.TableName = FPD_TransferICTInstantaneousFC.TableName + "_FC";
                            while (FPD_TransferICTInstantaneousFC.Columns.Count > 1)
                                FPD_TransferICTInstantaneousFC.Columns.RemoveAt(1);
                            FPD_TransferICTBagInstantaneousFC = FPD_TransferICTInstantaneousFC.Copy();
                            FPD_TransferICTBagInstantaneousFC.TableName = transferICTInstantaneousFCTable.TableName + "_Bag_FC";
                        }

                        if (FPD_AircraftMovementsTerminal == null)
                        {
                            FPD_AircraftMovementsTerminal = dtAircraftMovement.Copy();
                            FPD_AircraftMovementsTerminal.TableName = "FPD_AircraftMovements_FC";
                            while (FPD_AircraftMovementsTerminal.Columns.Count > 1)
                                FPD_AircraftMovementsTerminal.Columns.RemoveAt(1);
                        }
                        // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns                        
                        OverallTools.DataFunctions.ConcateneTable(FPD_CheckInShowUpSmoothed, dtAirlineSmoothed, new int[] { 2 }, sAirline + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPD_CheckInShowUpInstantaneous, dtAirlineInstantaneous, new int[] { 2 }, sAirline + "_");

                        OverallTools.DataFunctions.ConcateneTable(FPD_OutBoundSmoothed, dtOutBoundSmoothed, new int[] { 2 }, sAirline + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPD_OutBoundInstantaneous, dtOutBoundInstantaneous, new int[] { 2 }, sAirline + "_");

                        OverallTools.DataFunctions.ConcateneTable(FPD_CheckInShowUpBagSmoothed, dtAirlineSmoothed, new int[] { 4 }, sAirline + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPD_CheckInShowUpBagInstantaneous, dtAirlineInstantaneous, new int[] { 4 }, sAirline + "_");

                        OverallTools.DataFunctions.ConcateneTable(FPD_OutBoundBagSmoothed, dtOutBoundSmoothed, new int[] { 8 }, sAirline + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPD_OutBoundBagInstantaneous, dtOutBoundInstantaneous, new int[] { 8 }, sAirline + "_");
                        // >> Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                        // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_OutBoundSmoothedPAXOriginatingFC, dtOutBoundSmoothed, new int[] { 4 }, sAirline + "_");
                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_OutBoundInstantaneousPAXOriginatingFC, dtOutBoundInstantaneous, new int[] { 4 }, sAirline + "_");

                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_OutBoundSmoothedPAXTransferringFC, dtOutBoundSmoothed, new int[] { 6 }, sAirline + "_");
                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_OutBoundInstantaneousPAXTransferringFC, dtOutBoundInstantaneous, new int[] { 6 }, sAirline + "_");

                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_OutBoundSmoothedBagOriginatingFC, dtOutBoundSmoothed, new int[] { 10 }, sAirline + "_");
                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_OutBoundInstantaneousBagOriginatingFC, dtOutBoundInstantaneous, new int[] { 10 }, sAirline + "_");

                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_OutBoundSmoothedBagTransferringFC, dtOutBoundSmoothed, new int[] { 12 }, sAirline + "_");
                        OverallTools.DataFunctions
                            .ConcateneTable(FPD_OutBoundInstantaneousBagTransferringFC, dtOutBoundInstantaneous, new int[] { 12 }, sAirline + "_");
                        // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

                        OverallTools.DataFunctions.ConcateneTable(FPD_TransferICTSmoothedFC, transferICTSmoothedFCTable, new int[] { 2 }, sAirline + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPD_TransferICTInstantaneousFC, transferICTInstantaneousFCTable, new int[] { 2 }, sAirline + "_");

                        OverallTools.DataFunctions.ConcateneTable(FPD_TransferICTBagSmoothedFC, transferICTSmoothedFCTable, new int[] { 4 }, sAirline + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPD_TransferICTBagInstantaneousFC, transferICTInstantaneousFCTable, new int[] { 4 }, sAirline + "_");

                        OverallTools.DataFunctions.ConcateneTable(FPD_AircraftMovementsTerminal, dtAircraftMovement, new int[] { 1 }, sAirline + "_");
                    }
                    if (FPD_CheckInShowUpSmoothed != null)
                    {
                        DataTable dtStats = new DataTable("FPD_FC_Stats");
                        dtStats.Columns.Add("FlightCategory", typeof(String));

                        dtStats.Columns.Add("CI_Smoothed_Pax_Max", typeof(Double));
                        dtStats.Columns.Add("CI_Instantaneous_Pax_Max", typeof(Double));
                        dtStats.Columns.Add("OutBound_Smoothed_Pax_Max", typeof(Double));
                        dtStats.Columns.Add("OutBound_Instantaneous_Pax_Max", typeof(Double));

                        dtStats.Columns.Add("CI_Smoothed_Bag_Max", typeof(Double));
                        dtStats.Columns.Add("CI_Instantaneous_Bag_Max", typeof(Double));
                        dtStats.Columns.Add("OutBound_Smoothed_Bag_Max", typeof(Double));
                        dtStats.Columns.Add("OutBound_Instantaneous_Bag_Max", typeof(Double));

                        for (i = 1; i < FPD_CheckInShowUpSmoothed.Columns.Count; i++)
                        {
                            if (alFlightCategory.Count > i - 1)
                            {
                                DataRow drNewRow = dtStats.NewRow();
                                drNewRow[0] = alFlightCategory[i - 1].ToString();
                                drNewRow[1] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_CheckInShowUpSmoothed, i);
                                drNewRow[2] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_CheckInShowUpInstantaneous, i);
                                drNewRow[3] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_OutBoundSmoothed, i);
                                drNewRow[4] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_OutBoundInstantaneous, i);
                                drNewRow[5] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_CheckInShowUpBagSmoothed, i);
                                drNewRow[6] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_CheckInShowUpBagInstantaneous, i);
                                drNewRow[7] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_OutBoundBagSmoothed, i);
                                drNewRow[8] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_OutBoundBagInstantaneous, i);
                                dtStats.Rows.Add(drNewRow);
                            }
                        }

                        alResult.Add(dtStats);
                        alResult.Add(FPD_CheckInShowUpSmoothed);
                        alResult.Add(FPD_CheckInShowUpInstantaneous);
                        alResult.Add(FPD_OutBoundSmoothed);
                        alResult.Add(FPD_OutBoundInstantaneous);

                        alResult.Add(FPD_CheckInShowUpBagSmoothed);
                        alResult.Add(FPD_CheckInShowUpBagInstantaneous);
                        alResult.Add(FPD_OutBoundBagSmoothed);
                        alResult.Add(FPD_OutBoundBagInstantaneous);

                        // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                        alResult.Add(FPD_OutBoundSmoothedPAXOriginatingFC);
                        alResult.Add(FPD_OutBoundInstantaneousPAXOriginatingFC);

                        alResult.Add(FPD_OutBoundSmoothedPAXTransferringFC);
                        alResult.Add(FPD_OutBoundInstantaneousPAXTransferringFC);

                        alResult.Add(FPD_OutBoundSmoothedBagOriginatingFC);
                        alResult.Add(FPD_OutBoundInstantaneousBagOriginatingFC);

                        alResult.Add(FPD_OutBoundSmoothedBagTransferringFC);
                        alResult.Add(FPD_OutBoundInstantaneousBagTransferringFC);
                        // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                        alResult.Add(FPD_TransferICTSmoothedFC);
                        alResult.Add(FPD_TransferICTInstantaneousFC);
                        alResult.Add(FPD_TransferICTBagSmoothedFC);
                        alResult.Add(FPD_TransferICTBagInstantaneousFC);

                        alResult.Add(FPD_AircraftMovementsTerminal);
                    }
                }
                return alResult;
            }
            #endregion

            // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
            #region Function used for the Flight Subcategory segregation calculation

            internal class FlightInformation
            {
                private int _flightId;
                private string _flightNumber;
                private string _flightCategory;
                private string _flightSubCategory;

                public FlightInformation(int pFlightId, string pFlightNumber, string pFlightCategory, string pFlightSubCategory)
                {
                    _flightId = pFlightId;
                    _flightNumber = pFlightNumber;
                    _flightCategory = pFlightCategory;
                    _flightSubCategory = pFlightSubCategory;
                }

                public int flightId
                {
                    get { return _flightId; }
                    set { _flightId = value; }
                }

                public String flightNumber
                {
                    get { return _flightNumber; }
                    set { _flightNumber = value; }
                }

                public String flightCategory
                {
                    get { return _flightCategory; }
                    set { _flightCategory = value; }
                }

                public String flightSubCategory
                {
                    get { return _flightSubCategory; }
                    set { _flightSubCategory = value; }
                }
            }

            internal static ArrayList CalcStaticAnalysisPerFlightSubcategory(
                DataTable dtFlightPlans, DataManagement.NormalTable dtLoadFactors, DataManagement.NormalTable dtAircraftType,
                DataManagement.NormalTable dtShowUpProfile, DataManagement.NormalTable dtOCTCheckIn,
                DataManagement.NormalTable dtNbBags, DataManagement.NormalTable dtNbVisitors, DataManagement.NormalTable dtNbTrolley,
                DataTable dtFlightCategories, DataTable flightSubcategoriesTable,
                DateTime dtBegin, DateTime dtEnd,
                Double dStepAnalysis, Double dStepCumul,
                bool bUseStatisticStep, Double dStatisticStep,
                String sStatisticMode, ArrayList ListeErreurs,
                // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                bool bUseDefinedNbPax,
                DataTable dtNumberOfPassengers,
                bool bUseDefinedNbBags,
                DataTable dtNumberOfBaggages
                // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                , double[] distributionLevels,   // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                NormalTable interConnectingTimeTable,
                List<FlightConfiguration> userDefineFlightConfigurations    // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                )
            {
                ArrayList resultsList = new ArrayList();

                if (dtFlightPlans.Rows.Count > 0)
                {
                    //K: flightCategory, V: nb of flights for the FC
                    Dictionary<String, int> nbFlightsByFlightCategoryDictionary =
                        countNbOfFlightsByFlightCategories(dtFlightPlans);

                    // >> Task #9915 Pax2Sim - BNP development - Peak Flows - USA Standard directory
                    /*                                        
                                        //K: Flight subcategory, V: corresponding Flight Category
                                        Dictionary<String, String> flightSubcategoriesLinkDictionary =
                                            getLinkBetweenFlightSubcatAndFlightCat(flightSubcategoriesTable, nbFlightsByFlightCategoryDictionary);

                                        //K: Flight subcategory, V: nb of flights for the subcategory
                                        Dictionary<String, int> nbFlightsByFlightSubcategoriesDictionary =
                                            countNbOfFLightsByFlightSubcategory(flightSubcategoriesTable, nbFlightsByFlightCategoryDictionary,
                                                                                    flightSubcategoriesLinkDictionary);
                                        //K: FlightId, V: flight subcategory
                                        Dictionary<FlightInformation, String> flightsDictionary =
                                            assignFlightSubcategoryToFlight(dtFlightPlans, nbFlightsByFlightSubcategoriesDictionary, 
                                                                                flightSubcategoriesLinkDictionary);
                    */
                    //K:FlightSubcategory, V:Dict<FlightCategory, nb of flights for the FlightSUBcategory
                    Dictionary<String, Dictionary<String, int>> flightSubcategoriesAndFlightCategoriesWithNbFlightsPerFSCDictionary
                        = getLinkBetweenFlightSubcatAnd_FCwithNbFlightsForFSC(flightSubcategoriesTable, nbFlightsByFlightCategoryDictionary, dtFlightPlans.Rows.Count);

                    Dictionary<FlightInformation, String> flightsDictionary = assignFlightSubcategoryToFlight(dtFlightPlans,
                        flightSubcategoriesAndFlightCategoriesWithNbFlightsPerFSCDictionary);
                    // << Task #9915 Pax2Sim - BNP development - Peak Flows - USA Standard directory

                    DataTable FPD_flightInformationTable = createFlightInformationTable(flightsDictionary,
                                                                                            GlobalNames.FPD_table_preffix);
                    if (FPD_flightInformationTable != null)
                        resultsList.Add(FPD_flightInformationTable);

                    #region create the tables needed for the segregation
                    DataTable FPD_AircraftMovementsTerminal = null;
                    DataTable FPD_CheckInShowUpSmoothed = null;
                    DataTable FPD_CheckInShowUpInstantaneous = null;
                    DataTable FPD_OutBoundSmoothed = null;
                    DataTable FPD_OutBoundInstantaneous = null;

                    DataTable FPD_OutBoundSmoothedPAXOriginatingFSC = null;
                    DataTable FPD_OutBoundInstantaneousPAXOriginatingFSC = null;
                    DataTable FPD_OutBoundSmoothedPAXTransferringFSC = null;
                    DataTable FPD_OutBoundInstantaneousPAXTransferringFSC = null;

                    DataTable FPD_OutBoundSmoothedBagOriginatingFSC = null;
                    DataTable FPD_OutBoundInstantaneousBagOriginatingFSC = null;
                    DataTable FPD_OutBoundSmoothedBagTransferringFSC = null;
                    DataTable FPD_OutBoundInstantaneousBagTransferringFSC = null;

                    DataTable FPD_CheckInShowUpBagSmoothed = null;
                    DataTable FPD_CheckInShowUpBagInstantaneous = null;
                    DataTable FPD_OutBoundBagSmoothed = null;
                    DataTable FPD_OutBoundBagInstantaneous = null;

                    // >> Bug #11860 Pax2Sim - Static analysis - EBS calculation FB exception 2                    
                    DataTable FPD_TransferICTSmoothedFSC = null;
                    DataTable FPD_TransferICTInstantaneousFSC = null;
                    DataTable FPD_TransferICTBagSmoothedFSC = null;
                    DataTable FPD_TransferICTBagInstantaneousFSC = null;
                    // << Bug #11860 Pax2Sim - Static analysis - EBS calculation FB exception 2

                    foreach (String flightSubcategory in flightSubcategoriesAndFlightCategoriesWithNbFlightsPerFSCDictionary.Keys)
                    {
                        DataTable tempFlightPlan = filterFlightPlanByFlightSubcategory(dtFlightPlans, flightSubcategory,
                                                                                        flightsDictionary);
                        if (tempFlightPlan != null && tempFlightPlan.Columns.Count > 0
                            && tempFlightPlan.Rows.Count > 0)
                        {
                            //call a function that creates the tables needed for the segregation
                            ArrayList staticAnalysisTablesList = CalcStaticAnalysis2(tempFlightPlan, dtLoadFactors,
                                dtAircraftType, dtShowUpProfile, dtOCTCheckIn, dtNbBags, dtNbVisitors, dtNbTrolley,
                                dtFlightCategories, dtBegin, dtEnd, dStepAnalysis, dStepCumul, bUseStatisticStep,
                                dStatisticStep, sStatisticMode, ListeErreurs,
                                bUseDefinedNbPax, dtNumberOfPassengers, bUseDefinedNbBags, dtNumberOfBaggages // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                                , distributionLevels, interConnectingTimeTable, userDefineFlightConfigurations    // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                                );

                            if (staticAnalysisTablesList == null)
                                continue;

                            DataTable dtAircraftMovement = null;
                            DataTable dtAirlineSmoothed = null;
                            DataTable dtAirlineInstantaneous = null;
                            DataTable dtOutBoundSmoothed = null;
                            DataTable dtOutBoundInstantaneous = null;
                            DataTable transferICTSmoothed = null;
                            DataTable transferICTInstantaneous = null;

                            foreach (DataTable dtTmp2 in staticAnalysisTablesList)
                            {

                                if (dtTmp2.TableName == "FPD_AircraftMovementsRolling")
                                    dtAircraftMovement = dtTmp2;

                                if (dtTmp2.TableName == "FPD_CheckInShowUpRolling")
                                    dtAirlineSmoothed = dtTmp2;

                                if (dtTmp2.TableName == "FPD_CheckInShowUpInstantaneous")
                                    dtAirlineInstantaneous = dtTmp2;

                                if (dtTmp2.TableName == "FPD_OutBoundRolling")
                                    dtOutBoundSmoothed = dtTmp2;

                                if (dtTmp2.TableName == "FPD_OutBoundInstantaneous")
                                    dtOutBoundInstantaneous = dtTmp2;

                                if (dtTmp2.TableName == GlobalNames.FPD_TRANSFER_ICT_ROLLING)
                                    transferICTSmoothed = dtTmp2;

                                if (dtTmp2.TableName == GlobalNames.FPD_TRANSFER_ICT_INSTANTANEOUS)
                                    transferICTInstantaneous = dtTmp2;
                            }
                            if ((dtAirlineSmoothed == null) || (dtAirlineInstantaneous == null) || (dtOutBoundSmoothed == null) || (dtOutBoundInstantaneous == null))
                                continue;
                            if (transferICTInstantaneous == null || transferICTSmoothed == null)
                                continue;

                            if (FPD_CheckInShowUpSmoothed == null)
                            {
                                FPD_CheckInShowUpSmoothed = dtAirlineSmoothed.Copy();
                                FPD_CheckInShowUpSmoothed.TableName = FPD_CheckInShowUpSmoothed.TableName + "_FSC";
                                while (FPD_CheckInShowUpSmoothed.Columns.Count > 1)
                                    FPD_CheckInShowUpSmoothed.Columns.RemoveAt(1);
                                FPD_CheckInShowUpBagSmoothed = FPD_CheckInShowUpSmoothed.Copy();
                                FPD_CheckInShowUpBagSmoothed.TableName = dtAirlineSmoothed.TableName + "_Bag_FSC";
                            }
                            if (FPD_CheckInShowUpInstantaneous == null)
                            {
                                FPD_CheckInShowUpInstantaneous = dtAirlineInstantaneous.Copy();
                                FPD_CheckInShowUpInstantaneous.TableName = FPD_CheckInShowUpInstantaneous.TableName + "_FSC";
                                while (FPD_CheckInShowUpInstantaneous.Columns.Count > 1)
                                    FPD_CheckInShowUpInstantaneous.Columns.RemoveAt(1);
                                FPD_CheckInShowUpBagInstantaneous = FPD_CheckInShowUpInstantaneous.Copy();
                                FPD_CheckInShowUpBagInstantaneous.TableName = dtAirlineInstantaneous.TableName + "_Bag_FSC";
                            }
                            if (FPD_OutBoundSmoothed == null)
                            {
                                FPD_OutBoundSmoothed = dtOutBoundSmoothed.Copy();
                                FPD_OutBoundSmoothed.TableName = FPD_OutBoundSmoothed.TableName + "_FSC";
                                while (FPD_OutBoundSmoothed.Columns.Count > 1)
                                    FPD_OutBoundSmoothed.Columns.RemoveAt(1);
                                FPD_OutBoundBagSmoothed = FPD_CheckInShowUpInstantaneous.Copy();
                                FPD_OutBoundBagSmoothed.TableName = dtOutBoundSmoothed.TableName + "_Bag_FSC";
                            }
                            if (FPD_OutBoundInstantaneous == null)
                            {
                                FPD_OutBoundInstantaneous = dtOutBoundInstantaneous.Copy();
                                FPD_OutBoundInstantaneous.TableName = FPD_OutBoundInstantaneous.TableName + "_FSC";
                                while (FPD_OutBoundInstantaneous.Columns.Count > 1)
                                    FPD_OutBoundInstantaneous.Columns.RemoveAt(1);
                                FPD_OutBoundBagInstantaneous = FPD_OutBoundInstantaneous.Copy();
                                FPD_OutBoundBagInstantaneous.TableName = dtOutBoundInstantaneous.TableName + "_Bag_FSC";
                            }

                            if (FPD_OutBoundSmoothedPAXOriginatingFSC == null)
                            {
                                FPD_OutBoundSmoothedPAXOriginatingFSC = dtOutBoundSmoothed.Copy();
                                FPD_OutBoundSmoothedPAXOriginatingFSC.TableName = GlobalNames.fpdOutBoundSmoothedPAXOriginating_FSC;
                                while (FPD_OutBoundSmoothedPAXOriginatingFSC.Columns.Count > 1)
                                    FPD_OutBoundSmoothedPAXOriginatingFSC.Columns.RemoveAt(1);
                                FPD_OutBoundSmoothedBagOriginatingFSC = FPD_OutBoundSmoothedPAXOriginatingFSC.Copy();
                                FPD_OutBoundSmoothedBagOriginatingFSC.TableName = GlobalNames.fpdOutBoundSmoothedBagOriginating_FSC;
                            }
                            if (FPD_OutBoundInstantaneousPAXOriginatingFSC == null)
                            {
                                FPD_OutBoundInstantaneousPAXOriginatingFSC = dtOutBoundInstantaneous.Copy();
                                FPD_OutBoundInstantaneousPAXOriginatingFSC.TableName = GlobalNames.fpdOutBoundInstantaneousPAXOriginating_FSC;
                                while (FPD_OutBoundInstantaneousPAXOriginatingFSC.Columns.Count > 1)
                                    FPD_OutBoundInstantaneousPAXOriginatingFSC.Columns.RemoveAt(1);
                                FPD_OutBoundInstantaneousBagOriginatingFSC = FPD_OutBoundInstantaneousPAXOriginatingFSC.Copy();
                                FPD_OutBoundInstantaneousBagOriginatingFSC.TableName = GlobalNames.fpdOutBoundInstantaneousBagOriginating_FSC;
                            }

                            if (FPD_OutBoundSmoothedPAXTransferringFSC == null)
                            {
                                FPD_OutBoundSmoothedPAXTransferringFSC = dtOutBoundSmoothed.Copy();
                                FPD_OutBoundSmoothedPAXTransferringFSC.TableName = GlobalNames.fpdOutBoundSmoothedPAXTransfering_FSC;
                                while (FPD_OutBoundSmoothedPAXTransferringFSC.Columns.Count > 1)
                                    FPD_OutBoundSmoothedPAXTransferringFSC.Columns.RemoveAt(1);
                                FPD_OutBoundSmoothedBagTransferringFSC = FPD_OutBoundSmoothedPAXTransferringFSC.Copy();
                                FPD_OutBoundSmoothedBagTransferringFSC.TableName = GlobalNames.fpdOutBoundSmoothedBagTransfering_FSC;
                            }
                            if (FPD_OutBoundInstantaneousPAXTransferringFSC == null)
                            {
                                FPD_OutBoundInstantaneousPAXTransferringFSC = dtOutBoundInstantaneous.Copy();
                                FPD_OutBoundInstantaneousPAXTransferringFSC.TableName = GlobalNames.fpdOutBoundInstantaneousPAXTransfering_FSC;
                                while (FPD_OutBoundInstantaneousPAXTransferringFSC.Columns.Count > 1)
                                    FPD_OutBoundInstantaneousPAXTransferringFSC.Columns.RemoveAt(1);
                                FPD_OutBoundInstantaneousBagTransferringFSC = FPD_OutBoundInstantaneousPAXTransferringFSC.Copy();
                                FPD_OutBoundInstantaneousBagTransferringFSC.TableName = GlobalNames.fpdOutBoundInstantaneousBagTransfering_FSC;
                            }
                            if (FPD_TransferICTSmoothedFSC == null)
                            {
                                FPD_TransferICTSmoothedFSC = transferICTSmoothed.Copy();
                                FPD_TransferICTSmoothedFSC.TableName = FPD_TransferICTSmoothedFSC + "_FSC";
                                while (FPD_TransferICTSmoothedFSC.Columns.Count > 1)
                                    FPD_TransferICTSmoothedFSC.Columns.RemoveAt(1);
                                FPD_TransferICTBagSmoothedFSC = FPD_TransferICTSmoothedFSC.Copy();
                                FPD_TransferICTBagSmoothedFSC.TableName = transferICTSmoothed.TableName + "_Bag_FSC";
                            }
                            if (FPD_TransferICTInstantaneousFSC == null)
                            {
                                FPD_TransferICTInstantaneousFSC = transferICTInstantaneous.Copy();
                                FPD_TransferICTInstantaneousFSC.TableName = FPD_TransferICTInstantaneousFSC + "_FSC";
                                while (FPD_TransferICTInstantaneousFSC.Columns.Count > 1)
                                    FPD_TransferICTInstantaneousFSC.Columns.RemoveAt(1);
                                FPD_TransferICTBagInstantaneousFSC = FPD_TransferICTInstantaneousFSC.Copy();
                                FPD_TransferICTBagInstantaneousFSC.TableName = transferICTInstantaneous.TableName + "_Bag_FSC";
                            }

                            if (FPD_AircraftMovementsTerminal == null)
                            {
                                FPD_AircraftMovementsTerminal = dtAircraftMovement.Copy();
                                FPD_AircraftMovementsTerminal.TableName = "FPD_AircraftMovements_FSC";
                                while (FPD_AircraftMovementsTerminal.Columns.Count > 1)
                                    FPD_AircraftMovementsTerminal.Columns.RemoveAt(1);
                            }
                            // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns                        
                            OverallTools.DataFunctions.ConcateneTable(FPD_CheckInShowUpSmoothed, dtAirlineSmoothed, new int[] { 2 }, flightSubcategory + "_");
                            OverallTools.DataFunctions.ConcateneTable(FPD_CheckInShowUpInstantaneous, dtAirlineInstantaneous, new int[] { 2 }, flightSubcategory + "_");

                            OverallTools.DataFunctions.ConcateneTable(FPD_OutBoundSmoothed, dtOutBoundSmoothed, new int[] { 2 }, flightSubcategory + "_");
                            OverallTools.DataFunctions.ConcateneTable(FPD_OutBoundInstantaneous, dtOutBoundInstantaneous, new int[] { 2 }, flightSubcategory + "_");

                            OverallTools.DataFunctions.ConcateneTable(FPD_OutBoundSmoothedPAXOriginatingFSC, dtOutBoundSmoothed, new int[] { 4 }, flightSubcategory + "_");
                            OverallTools.DataFunctions.ConcateneTable(FPD_OutBoundInstantaneousPAXOriginatingFSC, dtOutBoundInstantaneous, new int[] { 4 }, flightSubcategory + "_");

                            OverallTools.DataFunctions.ConcateneTable(FPD_OutBoundSmoothedPAXTransferringFSC, dtOutBoundSmoothed, new int[] { 6 }, flightSubcategory + "_");
                            OverallTools.DataFunctions.ConcateneTable(FPD_OutBoundInstantaneousPAXTransferringFSC, dtOutBoundInstantaneous, new int[] { 6 }, flightSubcategory + "_");

                            OverallTools.DataFunctions.ConcateneTable(FPD_CheckInShowUpBagSmoothed, dtAirlineSmoothed, new int[] { 4 }, flightSubcategory + "_");
                            OverallTools.DataFunctions.ConcateneTable(FPD_CheckInShowUpBagInstantaneous, dtAirlineInstantaneous, new int[] { 4 }, flightSubcategory + "_");

                            OverallTools.DataFunctions.ConcateneTable(FPD_OutBoundBagSmoothed, dtOutBoundSmoothed, new int[] { 8 }, flightSubcategory + "_");
                            OverallTools.DataFunctions.ConcateneTable(FPD_OutBoundBagInstantaneous, dtOutBoundInstantaneous, new int[] { 8 }, flightSubcategory + "_");

                            OverallTools.DataFunctions.ConcateneTable(FPD_OutBoundSmoothedBagOriginatingFSC, dtOutBoundSmoothed, new int[] { 10 }, flightSubcategory + "_");
                            OverallTools.DataFunctions.ConcateneTable(FPD_OutBoundInstantaneousBagOriginatingFSC, dtOutBoundInstantaneous, new int[] { 10 }, flightSubcategory + "_");

                            OverallTools.DataFunctions.ConcateneTable(FPD_OutBoundSmoothedBagTransferringFSC, dtOutBoundSmoothed, new int[] { 12 }, flightSubcategory + "_");
                            OverallTools.DataFunctions.ConcateneTable(FPD_OutBoundInstantaneousBagTransferringFSC, dtOutBoundInstantaneous, new int[] { 12 }, flightSubcategory + "_");
                            // >> Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                            OverallTools.DataFunctions
                                .ConcateneTable(FPD_TransferICTSmoothedFSC, transferICTSmoothed, new int[] { 2 }, flightSubcategory + "_");
                            OverallTools.DataFunctions
                                .ConcateneTable(FPD_TransferICTInstantaneousFSC, transferICTInstantaneous, new int[] { 2 }, flightSubcategory + "_");

                            OverallTools.DataFunctions
                                .ConcateneTable(FPD_TransferICTBagSmoothedFSC, transferICTSmoothed, new int[] { 4 }, flightSubcategory + "_");
                            OverallTools.DataFunctions
                                .ConcateneTable(FPD_TransferICTBagInstantaneousFSC, transferICTInstantaneous, new int[] { 4 }, flightSubcategory + "_");


                            OverallTools.DataFunctions.ConcateneTable(FPD_AircraftMovementsTerminal, dtAircraftMovement, new int[] { 1 }, flightSubcategory + "_");
                        }
                    }
                    if (FPD_CheckInShowUpSmoothed != null)
                    {
                        DataTable dtStats = new DataTable("FPD_FSC_Stats");
                        dtStats.Columns.Add("FlightSubCategory", typeof(String));

                        dtStats.Columns.Add("CI_Smoothed_Pax_Max", typeof(Double));
                        dtStats.Columns.Add("CI_Instantaneous_Pax_Max", typeof(Double));
                        dtStats.Columns.Add("OutBound_Smoothed_Pax_Max", typeof(Double));
                        dtStats.Columns.Add("OutBound_Instantaneous_Pax_Max", typeof(Double));

                        dtStats.Columns.Add("CI_Smoothed_Bag_Max", typeof(Double));
                        dtStats.Columns.Add("CI_Instantaneous_Bag_Max", typeof(Double));
                        dtStats.Columns.Add("OutBound_Smoothed_Bag_Max", typeof(Double));
                        dtStats.Columns.Add("OutBound_Instantaneous_Bag_Max", typeof(Double));

                        ArrayList flightSubcategoriesList = new ArrayList();
                        foreach (String flightSubcategory in flightSubcategoriesAndFlightCategoriesWithNbFlightsPerFSCDictionary.Keys)
                            flightSubcategoriesList.Add(flightSubcategory);

                        for (int i = 1; i < FPD_CheckInShowUpSmoothed.Columns.Count; i++)
                        {
                            if (flightSubcategoriesList.Count > i - 1)
                            {
                                DataRow drNewRow = dtStats.NewRow();
                                drNewRow[0] = flightSubcategoriesList[i - 1].ToString();
                                drNewRow[1] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_CheckInShowUpSmoothed, i);
                                drNewRow[2] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_CheckInShowUpInstantaneous, i);
                                drNewRow[3] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_OutBoundSmoothed, i);
                                drNewRow[4] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_OutBoundInstantaneous, i);
                                drNewRow[5] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_CheckInShowUpBagSmoothed, i);
                                drNewRow[6] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_CheckInShowUpBagInstantaneous, i);
                                drNewRow[7] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_OutBoundBagSmoothed, i);
                                drNewRow[8] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPD_OutBoundBagInstantaneous, i);
                                dtStats.Rows.Add(drNewRow);
                            }
                        }

                        resultsList.Add(dtStats);
                        resultsList.Add(FPD_CheckInShowUpSmoothed);
                        resultsList.Add(FPD_CheckInShowUpInstantaneous);

                        resultsList.Add(FPD_OutBoundSmoothed);
                        resultsList.Add(FPD_OutBoundInstantaneous);

                        resultsList.Add(FPD_OutBoundSmoothedPAXOriginatingFSC);
                        resultsList.Add(FPD_OutBoundInstantaneousPAXOriginatingFSC);

                        resultsList.Add(FPD_OutBoundSmoothedPAXTransferringFSC);
                        resultsList.Add(FPD_OutBoundInstantaneousPAXTransferringFSC);

                        resultsList.Add(FPD_CheckInShowUpBagSmoothed);
                        resultsList.Add(FPD_CheckInShowUpBagInstantaneous);

                        resultsList.Add(FPD_OutBoundBagSmoothed);
                        resultsList.Add(FPD_OutBoundBagInstantaneous);

                        resultsList.Add(FPD_OutBoundSmoothedBagOriginatingFSC);
                        resultsList.Add(FPD_OutBoundInstantaneousBagOriginatingFSC);

                        resultsList.Add(FPD_OutBoundSmoothedBagTransferringFSC);
                        resultsList.Add(FPD_OutBoundInstantaneousBagTransferringFSC);

                        resultsList.Add(FPD_TransferICTSmoothedFSC);
                        resultsList.Add(FPD_TransferICTInstantaneousFSC);
                        resultsList.Add(FPD_TransferICTBagSmoothedFSC);
                        resultsList.Add(FPD_TransferICTBagInstantaneousFSC);

                        resultsList.Add(FPD_AircraftMovementsTerminal);
                    }
                    #endregion
                }
                return resultsList;
            }

            internal static Dictionary<String, int> countNbOfFlightsByFlightCategories(DataTable flightPlans)
            {
                Dictionary<String, int> nbFlightsByFlightCategoryDictionary = new Dictionary<String, int>();

                if (flightPlans != null && flightPlans.Rows.Count > 0)
                {
                    int indexFlightCategoryColumn = flightPlans.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightCategory);
                    int indexFlightIdColumn = flightPlans.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID);

                    if (indexFlightIdColumn != -1 && indexFlightCategoryColumn != -1)
                    {
                        foreach (DataRow row in flightPlans.Rows)
                        {
                            String flightCategory = row[indexFlightCategoryColumn].ToString();
                            int flightId = -1;

                            if (Int32.TryParse(row[indexFlightIdColumn].ToString(), out flightId))
                            {
                                if (!nbFlightsByFlightCategoryDictionary.ContainsKey(flightCategory))
                                {
                                    nbFlightsByFlightCategoryDictionary.Add(flightCategory, 1);
                                }
                                else
                                {
                                    nbFlightsByFlightCategoryDictionary[flightCategory]
                                        = nbFlightsByFlightCategoryDictionary[flightCategory] + 1;
                                }
                            }
                        }
                    }
                }
                return nbFlightsByFlightCategoryDictionary;
            }

            //K:FlightSubcategory, V:FlightCategory
            internal static Dictionary<String, String> getLinkBetweenFlightSubcatAndFlightCat(DataTable flightSubcategoriesTable,
                Dictionary<String, int> flightCategoriesDictionary)
            {
                Dictionary<String, String> flightSubcategoriesLinkDictionary = new Dictionary<String, String>();

                if (flightSubcategoriesTable != null && flightSubcategoriesTable.Rows.Count > 0)
                {
                    int indexFlightSubcategoryColumn = flightSubcategoriesTable.Columns.IndexOf(GlobalNames.flightSubcategoryColumnName);

                    if (indexFlightSubcategoryColumn != -1)
                    {
                        foreach (String flightCategory in flightCategoriesDictionary.Keys)
                        {
                            foreach (DataRow row in flightSubcategoriesTable.Rows)
                            {
                                String flightSubcategory = row[indexFlightSubcategoryColumn].ToString();

                                if (flightSubcategoriesTable.Columns.IndexOf(flightCategory) != -1)
                                {
                                    double percentage = 0;
                                    if (Double.TryParse(row[flightCategory].ToString(), out percentage)
                                        && percentage > 0 && !flightSubcategoriesLinkDictionary.ContainsKey(flightSubcategory))
                                    {
                                        flightSubcategoriesLinkDictionary.Add(flightSubcategory, flightCategory);
                                    }
                                }
                            }
                        }
                    }
                }
                return flightSubcategoriesLinkDictionary;
            }

            //K: flight subcategory, V: nb of flights with this subcategory
            internal static Dictionary<String, int> countNbOfFLightsByFlightSubcategory(DataTable flightSubcategoriesTable,
                Dictionary<String, int> nbFlightsByFlightCategoryDictionary,
                Dictionary<String, String> flightSubcategoriesLinkDictionary)
            {
                Dictionary<String, int> nbFlightsBFflightSubcategoriesDictionary = new Dictionary<String, int>();

                foreach (String flightSubcategory in flightSubcategoriesLinkDictionary.Keys)
                {
                    String correspondingFlightCategory = flightSubcategoriesLinkDictionary[flightSubcategory];
                    int indexColumnFlightCategory = flightSubcategoriesTable.Columns.IndexOf(correspondingFlightCategory);
                    int indexMainColumn = flightSubcategoriesTable.Columns.IndexOf(GlobalNames.flightSubcategoryColumnName);
                    double percentage = 0;

                    if (indexColumnFlightCategory != -1 && indexMainColumn != -1)
                    {
                        int indexRowFlightSubcategory = -1;
                        foreach (DataRow row in flightSubcategoriesTable.Rows)
                        {
                            if (row[indexMainColumn].ToString().Equals(flightSubcategory))
                                indexRowFlightSubcategory = flightSubcategoriesTable.Rows.IndexOf(row);
                        }

                        if (indexRowFlightSubcategory != -1 && Double.TryParse(flightSubcategoriesTable
                            .Rows[indexRowFlightSubcategory][indexColumnFlightCategory].ToString(), out percentage))
                        {
                            int nbFlightsPerFlightCategory = nbFlightsByFlightCategoryDictionary[correspondingFlightCategory];
                            int nbFlightsPerFlightSubCategory = (int)(nbFlightsPerFlightCategory * percentage / 100);

                            if (!nbFlightsBFflightSubcategoriesDictionary.ContainsKey(flightSubcategory))
                                nbFlightsBFflightSubcategoriesDictionary.Add(flightSubcategory, nbFlightsPerFlightSubCategory);
                        }
                    }
                }
                checkNbOfFlightsConsistency(nbFlightsBFflightSubcategoriesDictionary, nbFlightsByFlightCategoryDictionary,
                    flightSubcategoriesLinkDictionary);

                return nbFlightsBFflightSubcategoriesDictionary;
            }

            internal static void checkNbOfFlightsConsistency(Dictionary<String, int> nbFlightsBFflightSubcategoriesDictionary,
                Dictionary<String, int> nbFlightsByFlightCategoryDictionary, Dictionary<String, String> flightSubcategoriesLinkDictionary)
            {
                foreach (String flightCategory in nbFlightsByFlightCategoryDictionary.Keys)
                {
                    int nbFlightsPerCategory = nbFlightsByFlightCategoryDictionary[flightCategory];

                    int nbFlights = 0;
                    String lastFlightSubcategory = "";
                    foreach (String flightSubCategory in nbFlightsBFflightSubcategoriesDictionary.Keys)
                    {
                        if (flightSubcategoriesLinkDictionary.ContainsKey(flightSubCategory)
                            && flightSubcategoriesLinkDictionary[flightSubCategory].Equals(flightCategory))
                        {
                            nbFlights += nbFlightsBFflightSubcategoriesDictionary[flightSubCategory];
                            lastFlightSubcategory = flightSubCategory;
                        }
                    }
                    int difference = nbFlightsPerCategory - nbFlights;
                    if (difference > 0 && nbFlightsBFflightSubcategoriesDictionary.ContainsKey(lastFlightSubcategory))
                    {
                        nbFlightsBFflightSubcategoriesDictionary[lastFlightSubcategory] =
                            nbFlightsBFflightSubcategoriesDictionary[lastFlightSubcategory] + difference;
                    }
                }
            }

            //K: flightId, V: flight subcategory assigned
            internal static Dictionary<FlightInformation, String> assignFlightSubcategoryToFlight(DataTable flightPlan,
                Dictionary<String, int> nbFlightsByFlightSubCategoryDictionary,
                Dictionary<String, String> flightSubcategoriesLinkDictionary)
            {
                Dictionary<FlightInformation, String> flightsDictionary = new Dictionary<FlightInformation, String>();
                int indexFlightIdColumn = flightPlan.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID);
                int indexFlightCategoryColumn = flightPlan.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightCategory);
                int indexFlightNumberColumn = flightPlan.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightN);

                if (indexFlightIdColumn != -1 && indexFlightNumberColumn != -1 && indexFlightCategoryColumn != -1)
                {
                    foreach (DataRow fpRow in flightPlan.Rows)
                    {
                        int flightId = (int)(fpRow[indexFlightIdColumn]);
                        String flightNumber = fpRow[indexFlightNumberColumn].ToString();
                        String flightCategory = fpRow[indexFlightCategoryColumn].ToString();

                        foreach (String subcategory in flightSubcategoriesLinkDictionary.Keys)
                        {
                            if (flightSubcategoriesLinkDictionary[subcategory].Equals(flightCategory)
                                && nbFlightsByFlightSubCategoryDictionary.ContainsKey(subcategory)
                                && nbFlightsByFlightSubCategoryDictionary[subcategory] > 0)
                            {
                                FlightInformation flight = new FlightInformation(flightId, flightNumber,
                                                                                    flightCategory, subcategory);
                                flightsDictionary.Add(flight, subcategory);
                                nbFlightsByFlightSubCategoryDictionary[subcategory] =
                                    nbFlightsByFlightSubCategoryDictionary[subcategory] - 1;
                                break;
                            }
                        }

                    }
                }

                return flightsDictionary;
            }


            // >> Task #9915 Pax2Sim - BNP development - Peak Flows - USA Standard directory
            //K:FlightSubcategory, V:Dict<FlightCategory, nb of flights for the FlightSUBcategory
            internal static Dictionary<String, Dictionary<String, int>> getLinkBetweenFlightSubcatAnd_FCwithNbFlightsForFSC(DataTable flightSubcategoriesTable,
                Dictionary<String, int> flightCategoriesDictionary, int pNbTotalFlightsFromFP)
            {
                Dictionary<String, Dictionary<String, int>> flightSubcategoriesAndFlightCategoriesWithNbFlightsPerFSCDictionary = new Dictionary<string, Dictionary<string, int>>();

                if (flightSubcategoriesTable != null && flightSubcategoriesTable.Rows.Count > 0)
                {
                    int indexFlightSubcategoryColumn = flightSubcategoriesTable.Columns.IndexOf(GlobalNames.flightSubcategoryColumnName);

                    if (indexFlightSubcategoryColumn != -1)
                    {

                        Dictionary<String, int> nbUpdatedFlightsPerFlightCategoryDic = new Dictionary<string, int>();

                        foreach (DataRow dr in flightSubcategoriesTable.Rows)
                        {
                            // K: Flight Category | V: number of flights for the corresponfing Flight SUBcategory(form the upper dictionary)
                            Dictionary<String, int> flightCategoriesAndNbOfFlightsForFSCDictionary = new Dictionary<string, int>();
                            String flightSubcategory = dr[indexFlightSubcategoryColumn].ToString();

                            for (int i = 1; i < flightSubcategoriesTable.Columns.Count; i++)
                            {
                                DataColumn flightCategColumn = flightSubcategoriesTable.Columns[i];
                                String flightCategory = flightCategColumn.ColumnName;
                                double percentage = 0;

                                if (Double.TryParse(dr[flightCategColumn].ToString(), out percentage)
                                    && flightCategoriesDictionary.ContainsKey(flightCategory))
                                {
                                    int nbTotalFlightsPerFlightCateg = 0;
                                    if (flightCategoriesDictionary.TryGetValue(flightCategory, out nbTotalFlightsPerFlightCateg))
                                    {
                                        int nbFlightsPerFlightCatForFlightSubCateg = (int)Math.Ceiling(((double)nbTotalFlightsPerFlightCateg * percentage / 100.0));

                                        //check syncronization
                                        if (nbUpdatedFlightsPerFlightCategoryDic.ContainsKey(flightCategory))
                                        {
                                            int nbUpdatedFlights = 0;
                                            if (nbUpdatedFlightsPerFlightCategoryDic.TryGetValue(flightCategory, out nbUpdatedFlights))
                                            {
                                                nbUpdatedFlights = nbUpdatedFlights + nbFlightsPerFlightCatForFlightSubCateg;
                                                nbUpdatedFlightsPerFlightCategoryDic.Remove(flightCategory);
                                                nbUpdatedFlightsPerFlightCategoryDic.Add(flightCategory, nbUpdatedFlights);
                                            }
                                        }
                                        else
                                        {
                                            nbUpdatedFlightsPerFlightCategoryDic.Add(flightCategory, nbFlightsPerFlightCatForFlightSubCateg);
                                        }
                                        int difference = checkIfFlightCategoryHasAnymoreFlightsToUpdate(flightCategory, nbUpdatedFlightsPerFlightCategoryDic, nbTotalFlightsPerFlightCateg);

                                        if (difference > 0)
                                        {
                                            nbFlightsPerFlightCatForFlightSubCateg = nbFlightsPerFlightCatForFlightSubCateg - difference;
                                        }

                                        if (!flightSubcategoriesAndFlightCategoriesWithNbFlightsPerFSCDictionary.ContainsKey(flightSubcategory))
                                        {
                                            Dictionary<String, int> flightCategWithNbOfFlightsDictionary = new Dictionary<string, int>();
                                            flightCategWithNbOfFlightsDictionary.Add(flightCategory, nbFlightsPerFlightCatForFlightSubCateg);
                                            flightSubcategoriesAndFlightCategoriesWithNbFlightsPerFSCDictionary.Add(flightSubcategory, flightCategWithNbOfFlightsDictionary);
                                        }
                                        else
                                        {
                                            Dictionary<String, int> flightCategWithNbOfFlightsDictionary =
                                                flightSubcategoriesAndFlightCategoriesWithNbFlightsPerFSCDictionary[flightSubcategory];
                                            flightSubcategoriesAndFlightCategoriesWithNbFlightsPerFSCDictionary.Remove(flightSubcategory);
                                            if (!flightCategWithNbOfFlightsDictionary.ContainsKey(flightCategory))
                                                flightCategWithNbOfFlightsDictionary.Add(flightCategory, nbFlightsPerFlightCatForFlightSubCateg);

                                            flightSubcategoriesAndFlightCategoriesWithNbFlightsPerFSCDictionary.Add(flightSubcategory, flightCategWithNbOfFlightsDictionary);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                return flightSubcategoriesAndFlightCategoriesWithNbFlightsPerFSCDictionary;
            }
            internal static int checkIfFlightCategoryHasAnymoreFlightsToUpdate(String flightCategory,
                Dictionary<String, int> nbUpdatedFlightsPerFlightCategoryDic, int nbTotalFlightsPerFlightCateg)
            {
                int difference = 0;

                int nbUpdatedFlights = 0;
                if (nbUpdatedFlightsPerFlightCategoryDic.TryGetValue(flightCategory, out nbUpdatedFlights))
                {
                    if (nbUpdatedFlights > nbTotalFlightsPerFlightCateg)
                        difference = nbUpdatedFlights - nbTotalFlightsPerFlightCateg;
                }
                return difference;
            }

            //K: flightId, V: flight subcategory assigned
            internal static Dictionary<FlightInformation, String> assignFlightSubcategoryToFlight(DataTable flightPlan,
                Dictionary<String, Dictionary<String, int>> flightSubcategoriesAndFlightCategoriesWithNbFlightsPerFSCDictionary)
            {
                Dictionary<FlightInformation, String> flightsDictionary = new Dictionary<FlightInformation, String>();
                int indexFlightIdColumn = flightPlan.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID);
                int indexFlightCategoryColumn = flightPlan.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightCategory);
                int indexFlightNumberColumn = flightPlan.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightN);

                if (indexFlightIdColumn != -1 && indexFlightNumberColumn != -1 && indexFlightCategoryColumn != -1)
                {
                    foreach (DataRow fpRow in flightPlan.Rows)
                    {
                        int flightId = (int)(fpRow[indexFlightIdColumn]);
                        String flightNumber = fpRow[indexFlightNumberColumn].ToString();
                        String flightCategory = fpRow[indexFlightCategoryColumn].ToString();

                        foreach (String subcategory in flightSubcategoriesAndFlightCategoriesWithNbFlightsPerFSCDictionary.Keys)
                        {
                            Dictionary<String, int> flightCategoriesAndNbOfFlightsForFSCDictionary
                                = flightSubcategoriesAndFlightCategoriesWithNbFlightsPerFSCDictionary[subcategory];

                            bool found = false;
                            foreach (String flightCategoryFromDict in flightCategoriesAndNbOfFlightsForFSCDictionary.Keys)
                            {
                                int nbFlightsRemaining = 0;
                                if (flightCategoryFromDict.Equals(flightCategory)
                                    && flightCategoriesAndNbOfFlightsForFSCDictionary.TryGetValue(flightCategoryFromDict, out nbFlightsRemaining)
                                    && nbFlightsRemaining > 0)
                                {
                                    FlightInformation flight = new FlightInformation(flightId, flightNumber,
                                                                                    flightCategory, subcategory);
                                    flightsDictionary.Add(flight, subcategory);
                                    flightCategoriesAndNbOfFlightsForFSCDictionary[flightCategoryFromDict] =
                                        flightCategoriesAndNbOfFlightsForFSCDictionary[flightCategoryFromDict] - 1;
                                    found = true;
                                    break;
                                }
                            }
                            if (found)
                                break;
                        }
                    }
                }

                return flightsDictionary;
            }
            // << Task #9915 Pax2Sim - BNP development - Peak Flows - USA Standard directory

            internal static DataTable createFlightInformationTable(Dictionary<FlightInformation, String> flightsDictionary,
                String tablePreffix)
            {
                String tableName = "";
                if (tablePreffix.Equals(GlobalNames.FPD_table_preffix))
                    tableName = GlobalNames.FPD_flightInformationTableName;
                else if (tablePreffix.Equals(GlobalNames.FPA_table_preffix))
                    tableName = GlobalNames.FPA_flightInformationTableName;

                DataTable flightInformationTable = new DataTable(tableName);

                int indexFlightIdColumn = flightInformationTable.Columns.Count;
                flightInformationTable.Columns.Add(GlobalNames.flightInformationFlightIdColumnName, typeof(Int32));

                int indexFlightNumberColumn = flightInformationTable.Columns.Count;
                flightInformationTable.Columns.Add(GlobalNames.flightInformationFlightNumberColumnName, typeof(String));

                int indexFlightCategoryColumn = flightInformationTable.Columns.Count;
                flightInformationTable.Columns.Add(GlobalNames.flightInformationFlightCategoryColumnName, typeof(String));

                int indexFlightSubcategoryColumn = flightInformationTable.Columns.Count;
                flightInformationTable.Columns.Add(GlobalNames.flightInformationFlightSubcategoryColumnName, typeof(String));

                foreach (KeyValuePair<FlightInformation, String> pair in flightsDictionary)
                {
                    DataRow newRow = flightInformationTable.NewRow();
                    newRow[indexFlightIdColumn] = pair.Key.flightId;
                    newRow[indexFlightNumberColumn] = pair.Key.flightNumber;
                    newRow[indexFlightCategoryColumn] = pair.Key.flightCategory;
                    newRow[indexFlightSubcategoryColumn] = pair.Value;
                    flightInformationTable.Rows.Add(newRow);
                }
                flightInformationTable.AcceptChanges();

                return flightInformationTable;
            }

            internal static DataTable filterFlightPlanByFlightSubcategory(DataTable flightPlan, String flightSubcategory,
                Dictionary<FlightInformation, String> flightsDictionary)
            {
                DataTable tempFlightPlan = new DataTable();
                List<int> flightIdsList = new List<int>();
                int indexFlightIdColumn = -1;

                if (flightPlan != null)
                    indexFlightIdColumn = flightPlan.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID);

                if (indexFlightIdColumn != -1)
                {
                    tempFlightPlan = flightPlan.Clone();
                    tempFlightPlan.Rows.Clear();

                    foreach (KeyValuePair<FlightInformation, String> pair in flightsDictionary)
                    {
                        if (pair.Value.Equals(flightSubcategory))
                            flightIdsList.Add(pair.Key.flightId);

                    }

                    foreach (DataRow row in flightPlan.Rows)
                    {
                        int flightId = -1;
                        if (Int32.TryParse(row[indexFlightIdColumn].ToString(), out flightId)
                            && flightIdsList.Contains(flightId))
                        {
                            tempFlightPlan.Rows.Add(row.ItemArray);
                        }
                    }
                }
                return tempFlightPlan;
            }

            public static List<String> getFlightSubcategoriesFromFlightInformationTable(DataTable FPA_flightInformationTable,
                DataTable FPD_flightInformationTable)
            {
                List<String> flightSubcategories = new List<String>();

                if (FPA_flightInformationTable != null && FPD_flightInformationTable != null)
                {
                    int indexFPAFlightSubcategoryColumn = FPA_flightInformationTable.Columns
                        .IndexOf(GlobalNames.flightInformationFlightSubcategoryColumnName);
                    int indexFPDFlightSubcategoryColumn = FPD_flightInformationTable.Columns
                        .IndexOf(GlobalNames.flightInformationFlightSubcategoryColumnName);
                    if (indexFPAFlightSubcategoryColumn != -1 && indexFPDFlightSubcategoryColumn != -1)
                    {
                        foreach (DataRow fpdRow in FPD_flightInformationTable.Rows)
                        {
                            String flightSubcategory = fpdRow[indexFPDFlightSubcategoryColumn].ToString();
                            if (!flightSubcategories.Contains(flightSubcategory))
                                flightSubcategories.Add(flightSubcategory);
                        }
                        foreach (DataRow fpaRow in FPA_flightInformationTable.Rows)
                        {
                            String flightSubcategory = fpaRow[indexFPAFlightSubcategoryColumn].ToString();
                            if (!flightSubcategories.Contains(flightSubcategory))
                                flightSubcategories.Add(flightSubcategory);
                        }
                    }
                }
                return flightSubcategories;
            }
            #endregion
            // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

            // << Task #9125 Pax2Sim - Static Analysis -Segregation by Ground handler            
            #region Function used for the Ground Handler segregation
            /*
            internal static ArrayList calcDepartureStaticAnalysisPerGroundHandler(
                DataTable departureFlightPlans,
                DataManagement.NormalTable departureLoadFactorsTable,
                DataManagement.NormalTable aircraftTypeTable, 
                DataManagement.NormalTable showUpProfile, 
                DataManagement.NormalTable octChechIn, 
                DataManagement.NormalTable nbBagsTable, 
                DataManagement.NormalTable nbVisitorsTable,
                DataManagement.NormalTable nbTroleysTable, 
                DataTable flightCategoriesTable, 
                DateTime beginDate, 
                DateTime endDate,
                Double stepAnalysis, 
                Double stepCumul, 
                bool useStatisticStep, 
                Double statisticStep, 
                String statisticMode,
                ArrayList errorList)
            {

            }
             */
            #endregion
            // >> Task #9125 Pax2Sim - Static Analysis -Segregation by Ground handler

            // >> Task #9915 Pax2Sim - BNP development - Peak Flows - USA Standard directory
            #region USA Standard calculation
            internal static ArrayList calculateUSAStandardStaticAnalysisTables(ArrayList staticAnalysisTablesList, ParamScenario parameters,
                DataTable departureFlightPlanTable, NormalTable departureLoadFactorsNT, NormalTable aircraftTypeNT, NormalTable nbBagsNT,   // >> Task #10035 Pax2Sim - BNP development - Data Input tables
                DataTable flightCategoriesTable, DataTable flightSubcategoriesTable, DataTable usaStandardParametersTable, ArrayList errorsList,
                GestionDonneesHUB2SIM donnees)   // >> Task #10346 Pax2Sim - EBS review
            {
                ArrayList usaStandardStaticAnalysisTables = new ArrayList();

                ArrayList edsRequirementsTables = calculateEDSRequirementsStaticAnalysisTables(staticAnalysisTablesList, parameters.SamplingStep,
                    flightCategoriesTable, flightSubcategoriesTable, usaStandardParametersTable, errorsList);
                ArrayList ebsRequirementsTables = calculateEBSRequirementsStaticAnalysisTables(staticAnalysisTablesList);

                // >> Task #10346 Pax2Sim - EBS review                
                DataTable standardParametersTable = createInputStandardParametersTable(usaStandardParametersTable);     //usaStandardParametersTable.TableName = GlobalNames.USA_STANDARD_PARAMETERS_TABLE_GENERIC_NAME_FOR_SCENARIOS;    // >> Task #10035 Pax2Sim - BNP development - Data Input tables
                usaStandardStaticAnalysisTables.Add(standardParametersTable);
                // << Task #10346 Pax2Sim - EBS review

                DataTable flightPlanInformationTable = createFlightPlanInformationTable(departureFlightPlanTable, departureLoadFactorsNT, aircraftTypeNT, nbBagsNT);    // >> Task #10035 Pax2Sim - BNP development - Data Input tables
                usaStandardStaticAnalysisTables.Add(flightPlanInformationTable);

                // >> Task #10346 Pax2Sim - EBS review
                ArrayList otherInputTables = getInputTables(departureLoadFactorsNT.Table.Copy(), nbBagsNT.Table.Copy(), parameters, donnees);
                usaStandardStaticAnalysisTables.AddRange(otherInputTables);
                // << Task #10346 Pax2Sim - EBS review

                usaStandardStaticAnalysisTables.AddRange(edsRequirementsTables);
                usaStandardStaticAnalysisTables.AddRange(ebsRequirementsTables);

                return usaStandardStaticAnalysisTables;
            }

            // >> Task #10346 Pax2Sim - EBS review
            internal static DataTable createInputStandardParametersTable(DataTable usaStandardParametersTable)
            {
                DataTable standardParametersTable = new DataTable(GlobalNames.USA_STANDARD_PARAMETERS_TABLE_GENERIC_NAME_FOR_SCENARIOS);

                if (usaStandardParametersTable != null && usaStandardParametersTable.Rows.Count == 1)
                {
                    int standardParamsDataColumnIndex = standardParametersTable.Columns.Count;
                    standardParametersTable.Columns.Add(GlobalNames.USA_PARAMETERS_GENERIC_TABLE_DATA_COLUMN_NAME, typeof(String));
                    int standardParamsValueColumnIndex = standardParametersTable.Columns.Count;
                    standardParametersTable.Columns.Add(GlobalNames.USA_PARAMETERS_GENERIC_TABLE_VALUE_COLUMN_NAME, typeof(String));

                    int usaStandardCurrentColumnIndex = 0;
                    foreach (DataColumn col in usaStandardParametersTable.Columns)
                    {
                        if (usaStandardParametersTable.Columns.Count > usaStandardCurrentColumnIndex)
                        {
                            DataRow standardParamRow = standardParametersTable.NewRow();

                            standardParamRow[standardParamsDataColumnIndex] = col.ColumnName;
                            standardParamRow[standardParamsValueColumnIndex] = usaStandardParametersTable.Rows[0][usaStandardCurrentColumnIndex];

                            standardParametersTable.Rows.Add(standardParamRow);

                            usaStandardCurrentColumnIndex++;
                        }
                    }

                }

                return standardParametersTable;
            }

            internal static ArrayList getInputTables(DataTable loadFactorsTable, DataTable nbBagsTable, ParamScenario parameters,
                GestionDonneesHUB2SIM donnees)
            {
                ArrayList inputTables = new ArrayList();

                if (loadFactorsTable != null)
                {
                    loadFactorsTable.TableName = GlobalNames.DEPARTURE_LOAD_FACTORS_GENERIC_NAME_FOR_SCENARIOS;
                    inputTables.Add(loadFactorsTable);
                }
                if (nbBagsTable != null)
                {
                    nbBagsTable.TableName = GlobalNames.NB_BAGS_GENERIC_NAME_FOR_SCENARIOS;
                    inputTables.Add(nbBagsTable);
                }
                DataTable ciShowUpTable = donnees.getTable("Input", parameters.CI_ShowUpTable);
                if (ciShowUpTable != null)
                {
                    DataTable ci_shup_copy = ciShowUpTable.Copy();
                    ci_shup_copy.TableName = GlobalNames.CI_SHOWUP_PROFILE_GENERIC_NAME_FOR_SCENARIOS;
                    inputTables.Add(ci_shup_copy);
                }
                DataTable octCITable = donnees.getTable("Input", parameters.OCT_CI_Table);
                if (octCITable != null)
                {
                    DataTable oct_ci_copy = octCITable.Copy();
                    oct_ci_copy.TableName = GlobalNames.OCT_CI_GENERIC_NAME_FOR_SCENARIOS;
                    inputTables.Add(oct_ci_copy);
                }
                DataTable octMUPTable = donnees.getTable("Input", parameters.OCT_MakeUp);
                if (octMUPTable != null)
                {
                    DataTable oct_mup_copy = octMUPTable.Copy();
                    oct_mup_copy.TableName = GlobalNames.OCT_MUP_GENERIC_NAME_FOR_SCENARIOS;
                    inputTables.Add(oct_mup_copy);
                }
                DataTable ebsInputRatesTable = donnees.getTable("Input", parameters.ebsInputRateTableName);
                if (ebsInputRatesTable != null)
                {
                    DataTable ebsInputRates_copy = ebsInputRatesTable.Copy();
                    ebsInputRates_copy.TableName = GlobalNames.EBS_INPUT_RATE_GENERIC_NAME_FOR_SCENARIOS;
                    inputTables.Add(ebsInputRates_copy);
                }
                DataTable ebsOutputRatesTable = donnees.getTable("Input", parameters.ebsOutputRateTableName);
                if (ebsOutputRatesTable != null)
                {
                    DataTable ebsOutputRates_copy = ebsOutputRatesTable.Copy();
                    ebsOutputRates_copy.TableName = GlobalNames.EBS_OUTPUT_RATE_GENERIC_NAME_FOR_SCENARIOS;
                    inputTables.Add(ebsOutputRates_copy);
                }
                return inputTables;
            }
            // << Task #10346 Pax2Sim - EBS review

            internal static ArrayList calculateEDSRequirementsStaticAnalysisTables(ArrayList staticAnalysisTablesList, Double samplingStep,
                DataTable flightCategoriesTable, DataTable flightSubcategoriesTable, DataTable usaStandardParametersTable, ArrayList errorsList)
            {
                ArrayList edsRequirementsStaticAnalysisTables = new ArrayList();
                DataTable numberOfETDTable = null;
                DataTable sortationRateTable = null;
                DataTable fpd_checkInShowUpInstantaneous_fc = null;

                foreach (DataTable staticAnalysisTable in staticAnalysisTablesList)
                {
                    if (staticAnalysisTable.TableName.Equals("FPD_CheckInShowUpInstantaneous"))
                    {
                        numberOfETDTable = staticAnalysisTable.Copy();
                        sortationRateTable = staticAnalysisTable.Copy();
                    }
                    if (staticAnalysisTable.TableName.Equals("FPD_CheckInShowUpInstantaneous_FC"))
                        fpd_checkInShowUpInstantaneous_fc = staticAnalysisTable.Copy();
                }

                #region USA Standard Parameters
                // >> Task #9967 Pax2Sim - BNP development - Peak Flows - USA Standard parameters table
                Double oogPercent = 0;
                Double osPercent = 0;
                Double edsScreenRatePerMinute = 0;
                Double edsScreenRatePerHour = 0;
                Double falseAlarmEdsDom = 0;
                Double falseAlarmEdsInt = 0;
                Double osrProcessingRateBph = 0;
                Double clearRate = 0;
                Double etdScreenRateDomWithImg = 0;
                Double etdScreenRateDomNoImg = 0;
                Double etdScreenRateIntWithImg = 0;
                Double etdScreenRateIntNoImg = 0;
                Double lostTrackOS = 0;
                Double lostTrackOOG = 0;
                Double etdScreenRateOSBags = 0;

                if (!getUsaStandardParameters(usaStandardParametersTable, out oogPercent, out osPercent, out edsScreenRatePerMinute, out edsScreenRatePerHour,
                        out falseAlarmEdsDom, out falseAlarmEdsInt, out osrProcessingRateBph, out clearRate, out etdScreenRateDomWithImg, out etdScreenRateDomNoImg,
                        out etdScreenRateIntWithImg, out etdScreenRateIntNoImg, out lostTrackOS, out lostTrackOOG, out etdScreenRateOSBags))
                {
                    errorsList.Add("Error while getting the USA Standard parameters from the table. The EDS requirements were not calculated.");
                    return edsRequirementsStaticAnalysisTables;
                }

                // << Task #9967 Pax2Sim - BNP development - Peak Flows - USA Standard parameters table
                #endregion

                if (numberOfETDTable != null && fpd_checkInShowUpInstantaneous_fc != null)
                {
                    numberOfETDTable.TableName = GlobalNames.usaStandard_NumberOfETD_tableName;
                    numberOfETDTable = removeNonTimeAndPassengersAndBaggageColumns(numberOfETDTable);

                    List<String> flightCategoriesList = getFlightCategoriesListByFlightSubCategory(flightSubcategoriesTable, GlobalNames.defaultFlightSubcateg_DOM_USA);
                    Dictionary<int, Double> domesticContributionDictionary = calculateDomesticContribution(fpd_checkInShowUpInstantaneous_fc, flightCategoriesList);

                    #region Number of ETD table new columns and indexes
                    int baggageColumnIndex = numberOfETDTable.Columns.IndexOf("Baggage");
                    numberOfETDTable.Columns.Add(new DataColumn(GlobalNames.numberOfETD_SurgeFactor_columnName, typeof(Double)));
                    int surgeFactorColumnIndex = numberOfETDTable.Columns.Count - 1;
                    numberOfETDTable.Columns.Add(new DataColumn(GlobalNames.numberOfETD_SurgeFactorReal_columnName, typeof(Double)));
                    int surgeFactorRealColumnIndex = numberOfETDTable.Columns.Count - 1;
                    numberOfETDTable.Columns.Add(new DataColumn(GlobalNames.numberOfETD_BagsPerMin_columnName, typeof(Double)));
                    int bagsPerMinColumnIndex = numberOfETDTable.Columns.Count - 1;
                    numberOfETDTable.Columns.Add(new DataColumn(GlobalNames.numberOfETD_SFRealPerMin_columnName, typeof(Double)));
                    int sfRealPerMinColumnIndex = numberOfETDTable.Columns.Count - 1;
                    numberOfETDTable.Columns.Add(new DataColumn(GlobalNames.numberOfETD_OSRate_columnName, typeof(Double)));
                    int osRateColumnIndex = numberOfETDTable.Columns.Count - 1;
                    numberOfETDTable.Columns.Add(new DataColumn(GlobalNames.numberOfETD_OOGRate_columnName, typeof(Double)));
                    int oogRateColumnIndex = numberOfETDTable.Columns.Count - 1;
                    numberOfETDTable.Columns.Add(new DataColumn(GlobalNames.numberOfETD_OSOOGRate_columnName, typeof(Double)));
                    int osOOGRateColumnIndex = numberOfETDTable.Columns.Count - 1;
                    numberOfETDTable.Columns.Add(new DataColumn(GlobalNames.numberOfETD_ScreenRate_columnName, typeof(Double)));
                    int screenRateColumnIndex = numberOfETDTable.Columns.Count - 1;
                    numberOfETDTable.Columns.Add(new DataColumn(GlobalNames.numberOfETD_EDSRequirements_columnName, typeof(Double)));
                    int edsRequirementsColumnIndex = numberOfETDTable.Columns.Count - 1;
                    numberOfETDTable.Columns.Add(new DataColumn(GlobalNames.numberOfETD_NumberOfEDS_columnName, typeof(Double)));
                    int nbOfEDSColumnIndex = numberOfETDTable.Columns.Count - 1;
                    numberOfETDTable.Columns.Add(new DataColumn(GlobalNames.numberOfETD_NumberOfOSR_columnName, typeof(Double)));
                    int nbOfOSRColumnIndex = numberOfETDTable.Columns.Count - 1;
                    numberOfETDTable.Columns.Add(new DataColumn(GlobalNames.numberOfETD_Level1Alarmed_columnName, typeof(Double)));
                    int level1AlarmedColumnIndex = numberOfETDTable.Columns.Count - 1;
                    numberOfETDTable.Columns.Add(new DataColumn(GlobalNames.numberOfETD_Level2Alarmed_columnName, typeof(Double)));
                    int level2AlarmedColumnIndex = numberOfETDTable.Columns.Count - 1;
                    numberOfETDTable.Columns.Add(new DataColumn(GlobalNames.numberOfETD_DomesticContribution_columnName, typeof(Double)));
                    int domesticContributionColumnIndex = numberOfETDTable.Columns.Count - 1;
                    numberOfETDTable.Columns.Add(new DataColumn(GlobalNames.numberOfETD_ETD_columnName, typeof(Double)));
                    int etdColumnIndex = numberOfETDTable.Columns.Count - 1;
                    numberOfETDTable.Columns.Add(new DataColumn(GlobalNames.numberOfETD_ETDScreenLIT_columnName, typeof(Double)));
                    int etdScreenLITColumnIndex = numberOfETDTable.Columns.Count - 1;
                    numberOfETDTable.Columns.Add(new DataColumn(GlobalNames.numberOfETD_ETDOOG_columnName, typeof(Double)));
                    int etdOOGColumnIndex = numberOfETDTable.Columns.Count - 1;
                    numberOfETDTable.Columns.Add(new DataColumn(GlobalNames.numberOfETD_ETDforDOM_columnName, typeof(Double)));
                    int etdForDOMColumnIndex = numberOfETDTable.Columns.Count - 1;
                    numberOfETDTable.Columns.Add(new DataColumn(GlobalNames.numberOfETD_ETDSegPercDOMINT_columnName, typeof(Double)));
                    int etdSegPercDOMINTColumnIndex = numberOfETDTable.Columns.Count - 1;
                    numberOfETDTable.Columns.Add(new DataColumn(GlobalNames.numberOfETD_RequirementsForOverSize_columnName, typeof(Double)));
                    int requirementsForOSColumnIndex = numberOfETDTable.Columns.Count - 1;
                    #endregion

                    int rowIndex = 0;
                    foreach (DataRow dr in numberOfETDTable.Rows)
                    {
                        double domesticContribution = 0;
                        if (domesticContributionDictionary.TryGetValue(rowIndex, out domesticContribution))
                        {

                            double nbOfBags = -1;
                            if (Double.TryParse(dr[baggageColumnIndex].ToString(), out nbOfBags))
                            {
                                double surgeFactor = nbOfBags + 2 * Math.Sqrt(nbOfBags);
                                dr[surgeFactorColumnIndex] = Math.Round(surgeFactor, 3);

                                double surgeFactorReal = surgeFactor - nbOfBags;
                                dr[surgeFactorRealColumnIndex] = Math.Round(surgeFactorReal, 3);

                                double bagsPerMin = nbOfBags / samplingStep;
                                dr[bagsPerMinColumnIndex] = Math.Round(bagsPerMin, 3);

                                double bagsSFRealPerMin = surgeFactor / samplingStep;
                                dr[sfRealPerMinColumnIndex] = Math.Round(bagsSFRealPerMin, 3);

                                //double OSRate = Math.Round(bagsSFRealPerMin * 0.02, 3);
                                //double OSRate = Math.Round(bagsSFRealPerMin * GlobalNames.OS_PERCENT, 3);
                                double OSRate = Math.Round(bagsSFRealPerMin * osPercent, 3);
                                dr[osRateColumnIndex] = Math.Round(OSRate, 3);

                                //double OOGRate = Math.Round(bagsSFRealPerMin * 0.04, 3);
                                //double OOGRate = Math.Round(bagsSFRealPerMin * GlobalNames.OOG_PERCENT, 3);
                                double OOGRate = Math.Round(bagsSFRealPerMin * oogPercent, 3);
                                dr[oogRateColumnIndex] = OOGRate;

                                double OSRatePlusOOGRate = OSRate + OOGRate;
                                dr[osOOGRateColumnIndex] = Math.Round(OSRatePlusOOGRate, 3);

                                double screeningBagRate = bagsSFRealPerMin - OSRatePlusOOGRate;
                                dr[screenRateColumnIndex] = Math.Round(screeningBagRate, 3);

                                //double edsRequirements = screeningRate / 8.42;
                                //double edsRequirements = screeningBagRate / GlobalNames.EDS_SCREENING_RATE_PER_MINUTE;
                                double edsRequirements = screeningBagRate / edsScreenRatePerMinute;
                                dr[edsRequirementsColumnIndex] = Math.Round(edsRequirements, 3);

                                int nbOfEDS = 0;
                                if (edsRequirements > 0)
                                    nbOfEDS = (int)edsRequirements + 1;
                                dr[nbOfEDSColumnIndex] = nbOfEDS;

                                /*
                                double nbOSROperatorsNeeded = nbOfEDS * GlobalNames.EDS_SCREENING_RATE_PER_HOUR
                                    * GlobalNames.FALSE_ALARM_EDS_DOM / GlobalNames.OSR_PROCESSING_RATE_BPH;*/
                                double nbOSROperatorsNeeded = nbOfEDS * edsScreenRatePerHour * falseAlarmEdsDom / osrProcessingRateBph;
                                dr[nbOfOSRColumnIndex] = Math.Ceiling(nbOSROperatorsNeeded);

                                double level1Alarmed = screeningBagRate * 0.2;
                                dr[level1AlarmedColumnIndex] = Math.Round(level1Alarmed, 3);

                                double level2Alarmed = level1Alarmed * 0.5;
                                dr[level2AlarmedColumnIndex] = Math.Round(level2Alarmed, 3);

                                dr[domesticContributionColumnIndex] = Math.Round(domesticContribution, 3);

                                //double ETD = (0.2 * 0.5 / 18.85 + (0.01 + 0.04) / 26.67) * nbOfEDS * 505;
                                /*
                                double ETD = nbOfEDS * GlobalNames.EDS_SCREENING_RATE_PER_HOUR *
                                    (GlobalNames.FALSE_ALARM_EDS_DOM * (1 - GlobalNames.CLEAR_RATE) / GlobalNames.ETD_SCREENING_RATE_DOM_WITH_IMAGE
                                    + (GlobalNames.RLIT_1 + GlobalNames.RLIT_2) / GlobalNames.ETD_SCREENING_RATE_DOM_NO_IMAGE);*/
                                double ETD = nbOfEDS * edsScreenRatePerHour *
                                    (falseAlarmEdsDom * (1 - clearRate) / etdScreenRateDomWithImg + (lostTrackOS + oogPercent) / etdScreenRateDomNoImg);
                                dr[etdColumnIndex] = Math.Round(ETD, 3);

                                /*
                                double ETDscreenLIT = (domesticContribution * (0.2 * 0.5 / 18.85 + 0.01 / 26.67) + (1 - domesticContribution)
                                    * (0.2 * 0.5 / 13.9 + 0.01 / 19.78)) * nbOfEDS * 505;*/
                                /*
                                double ETDscreenLIT = nbOfEDS * GlobalNames.EDS_SCREENING_RATE_PER_HOUR *
                                    (domesticContribution
                                        * (GlobalNames.FALSE_ALARM_EDS_DOM * (1 - GlobalNames.CLEAR_RATE) / GlobalNames.ETD_SCREENING_RATE_DOM_WITH_IMAGE + GlobalNames.RLIT_1 / GlobalNames.ETD_SCREENING_RATE_DOM_NO_IMAGE)
                                    + (1 - domesticContribution)
                                        * (GlobalNames.FALSE_ALARM_EDS_INT * (1 - GlobalNames.CLEAR_RATE) / GlobalNames.ETD_SCREENING_RATE_INT_WITH_IMAGE + GlobalNames.RLIT_1 / GlobalNames.ETD_SCREENING_RATE_INT_NO_IMAGE));
                                */
                                double ETDscreenLIT = nbOfEDS * edsScreenRatePerHour *
                                    (domesticContribution * (falseAlarmEdsDom * (1 - clearRate) / etdScreenRateDomWithImg + lostTrackOS / etdScreenRateDomNoImg)
                                     + (1 - domesticContribution) * (falseAlarmEdsInt * (1 - clearRate) / etdScreenRateIntWithImg + lostTrackOS / etdScreenRateIntNoImg));
                                dr[etdScreenLITColumnIndex] = Math.Round(ETDscreenLIT, 3);

                                //double ETDOOG = (domesticContribution * (0.04 / 26.67) + (1 - domesticContribution) * (0.04 / 19.78)) * nbOfEDS * 505;
                                /*
                                double ETDOOG = nbOfEDS * GlobalNames.EDS_SCREENING_RATE_PER_HOUR *
                                    (domesticContribution * (GlobalNames.RLIT_2 / GlobalNames.ETD_SCREENING_RATE_DOM_NO_IMAGE)
                                        + (1 - domesticContribution) * (GlobalNames.RLIT_2 / GlobalNames.ETD_SCREENING_RATE_INT_NO_IMAGE));
                                 * RLIT_2 = OOG Percent !!!
                                 */
                                double ETDOOG = nbOfEDS * edsScreenRatePerHour *
                                    (domesticContribution * (oogPercent / etdScreenRateDomNoImg)
                                       + (1 - domesticContribution) * (oogPercent / etdScreenRateIntNoImg));
                                dr[etdOOGColumnIndex] = Math.Round(ETDOOG, 3);

                                int ETDforDOM = 0;
                                if (ETD > 0)
                                    ETDforDOM = (int)ETD + 1;
                                dr[etdForDOMColumnIndex] = ETDforDOM;

                                int ETDSegPercDomInt = 0;
                                if (ETDOOG + ETDscreenLIT > 0)
                                    ETDSegPercDomInt = (int)(ETDOOG + ETDscreenLIT) + 1;
                                dr[etdSegPercDOMINTColumnIndex] = ETDSegPercDomInt;

                                //double nbETDForOS = bagsSFRealPerMin * GlobalNames.OS_PERCENT * 60 / GlobalNames.ETD_SCREENING_RATE_OS_BAGS_BPH;
                                double nbETDForOS = bagsSFRealPerMin * osPercent * 60 / etdScreenRateOSBags;
                                dr[requirementsForOSColumnIndex] = Math.Ceiling(nbETDForOS);
                            }
                        }
                        rowIndex++;
                    }

                    // >> Task #10346 Pax2Sim - EBS review
                    ArrayList unwantedColumnNamesList = new ArrayList {"Passengers", "Baggage", GlobalNames.numberOfETD_SurgeFactor_columnName,
                    GlobalNames.numberOfETD_SurgeFactorReal_columnName, GlobalNames.numberOfETD_BagsPerMin_columnName, GlobalNames.numberOfETD_SFRealPerMin_columnName,
                    GlobalNames.numberOfETD_OSRate_columnName, GlobalNames.numberOfETD_OOGRate_columnName, GlobalNames.numberOfETD_OSOOGRate_columnName,
                    GlobalNames.numberOfETD_ScreenRate_columnName, GlobalNames.numberOfETD_EDSRequirements_columnName, GlobalNames.numberOfETD_Level1Alarmed_columnName,
                    GlobalNames.numberOfETD_Level2Alarmed_columnName, GlobalNames.numberOfETD_DomesticContribution_columnName};

                    DataTable nbOfETDShortTable = numberOfETDTable.Copy();
                    nbOfETDShortTable.TableName = GlobalNames.usaStandard_NumberOfETD_short_tableName;
                    if (nbOfETDShortTable != null)
                    {
                        foreach (String unwantedColumnName in unwantedColumnNamesList)
                        {
                            if (nbOfETDShortTable.Columns.IndexOf(unwantedColumnName) != -1)
                                nbOfETDShortTable.Columns.Remove(unwantedColumnName);
                        }
                    }
                    edsRequirementsStaticAnalysisTables.Add(nbOfETDShortTable);
                    // << Task #10346 Pax2Sim - EBS review

                    edsRequirementsStaticAnalysisTables.Add(numberOfETDTable);
                }

                if (sortationRateTable != null)
                {
                    sortationRateTable.TableName = GlobalNames.usaStandard_SortationRate_tableName;
                    sortationRateTable = removeNonTimeAndPassengersAndBaggageColumns(sortationRateTable);

                    #region Sortation Rate table new columns and indexes
                    int baggageColumnIndex = sortationRateTable.Columns.IndexOf("Baggage");
                    sortationRateTable.Columns.Add(new DataColumn(GlobalNames.numberOfETD_SurgeFactor_columnName, typeof(Double)));
                    int surgeFactorColumnIndex = sortationRateTable.Columns.Count - 1;
                    sortationRateTable.Columns.Add(new DataColumn(GlobalNames.numberOfETD_SurgeFactorReal_columnName, typeof(Double)));
                    int surgeFactorRealColumnIndex = sortationRateTable.Columns.Count - 1;
                    sortationRateTable.Columns.Add(new DataColumn(GlobalNames.numberOfETD_BagsPerMin_columnName, typeof(Double)));
                    int bagsPerMinColumnIndex = sortationRateTable.Columns.Count - 1;
                    sortationRateTable.Columns.Add(new DataColumn(GlobalNames.numberOfETD_SFRealPerMin_columnName, typeof(Double)));
                    int sfRealPerMinColumnIndex = sortationRateTable.Columns.Count - 1;
                    sortationRateTable.Columns.Add(new DataColumn(GlobalNames.numberOfETD_OSRate_columnName, typeof(Double)));
                    int osRateColumnIndex = sortationRateTable.Columns.Count - 1;
                    sortationRateTable.Columns.Add(new DataColumn(GlobalNames.numberOfETD_OOGRate_columnName, typeof(Double)));
                    int oogRateColumnIndex = sortationRateTable.Columns.Count - 1;
                    sortationRateTable.Columns.Add(new DataColumn(GlobalNames.numberOfETD_OSOOGRate_columnName, typeof(Double)));
                    int osOOGRateColumnIndex = sortationRateTable.Columns.Count - 1;
                    sortationRateTable.Columns.Add(new DataColumn(GlobalNames.numberOfETD_ScreenRate_columnName, typeof(Double)));
                    int screenRateColumnIndex = sortationRateTable.Columns.Count - 1;
                    sortationRateTable.Columns.Add(new DataColumn(GlobalNames.numberOfETD_EDSRequirements_columnName, typeof(Double)));
                    int edsRequirementsColumnIndex = sortationRateTable.Columns.Count - 1;
                    sortationRateTable.Columns.Add(new DataColumn(GlobalNames.sortationRateTable_SortationRate_columnName, typeof(Double)));
                    int sortationRateColumnIndex = sortationRateTable.Columns.Count - 1;
                    #endregion

                    foreach (DataRow dr in sortationRateTable.Rows)
                    {
                        double nbOfBags = -1;
                        if (Double.TryParse(dr[baggageColumnIndex].ToString(), out nbOfBags))
                        {
                            double surgeFactor = nbOfBags + 2 * Math.Sqrt(nbOfBags);
                            dr[surgeFactorColumnIndex] = Math.Round(surgeFactor, 3);

                            double surgeFactorReal = surgeFactor - nbOfBags;
                            dr[surgeFactorRealColumnIndex] = Math.Round(surgeFactorReal, 3);

                            double bagsPerMin = nbOfBags / samplingStep;
                            dr[bagsPerMinColumnIndex] = Math.Round(bagsPerMin, 3);

                            double bagsSFRealPerMin = surgeFactor / samplingStep;
                            dr[sfRealPerMinColumnIndex] = Math.Round(bagsSFRealPerMin, 3);

                            //double OSRate = Math.Round(bagsSFRealPerMin * 0.02, 3);
                            //double OSRate = Math.Round(bagsSFRealPerMin * GlobalNames.OS_PERCENT, 3);
                            double OSRate = Math.Round(bagsSFRealPerMin * osPercent, 3);
                            dr[osRateColumnIndex] = Math.Round(OSRate, 3);

                            //double OOGRate = Math.Round(bagsSFRealPerMin * 0.04, 3);
                            //double OOGRate = Math.Round(bagsSFRealPerMin * GlobalNames.OOG_PERCENT, 3);
                            double OOGRate = Math.Round(bagsSFRealPerMin * oogPercent, 3);
                            dr[oogRateColumnIndex] = OOGRate;

                            double OSRatePlusOOGRate = OSRate + OOGRate;
                            dr[osOOGRateColumnIndex] = Math.Round(OSRatePlusOOGRate, 3);

                            double screeningRate = bagsSFRealPerMin - OSRatePlusOOGRate;
                            dr[screenRateColumnIndex] = Math.Round(screeningRate, 3);

                            //double edsRequirements = screeningRate / GlobalNames.EDS_SCREENING_RATE_PER_MINUTE;
                            double edsRequirements = screeningRate / edsScreenRatePerMinute;
                            dr[edsRequirementsColumnIndex] = Math.Round(edsRequirements, 3);

                            double sortationRate = bagsSFRealPerMin - OSRate;
                            dr[sortationRateColumnIndex] = Math.Round(sortationRate, 3);
                        }
                    }

                    edsRequirementsStaticAnalysisTables.Add(sortationRateTable);
                }

                if (numberOfETDTable != null && sortationRateTable != null)
                {
                    DataTable dataStatsTable = numberOfETDTable.Copy();
                    dataStatsTable.Columns.Add(new DataColumn(GlobalNames.sortationRateTable_SortationRate_columnName, typeof(Double)));
                    if (dataStatsTable.Rows.Count == sortationRateTable.Rows.Count)
                    {
                        for (int i = 0; i < sortationRateTable.Rows.Count; i++)
                        {
                            Double sortationRate = 0;
                            if (Double.TryParse(sortationRateTable.Rows[i][GlobalNames.sortationRateTable_SortationRate_columnName].ToString(), out sortationRate))
                            {
                                dataStatsTable.Rows[i][GlobalNames.sortationRateTable_SortationRate_columnName] = sortationRate;
                            }
                        }
                    }

                    dataStatsTable.TableName = GlobalNames.EDS_STATS_TABLE_NAME;
                    DataTable Stats = OverallTools.DataFunctions.GetStatTable(dataStatsTable, new int[23] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
                    11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23});
                    Stats.TableName = GlobalNames.EDS_STATS_TABLE_NAME;
                    edsRequirementsStaticAnalysisTables.Add(Stats);
                }

                return edsRequirementsStaticAnalysisTables;
            }

            internal static DataTable removeNonTimeAndPassengersAndBaggageColumns(DataTable table)
            {
                ArrayList removeColumns = new ArrayList();
                foreach (DataColumn column in table.Columns)
                {
                    if (column.ColumnName != "Baggage" && column.ColumnName != "Time"
                        && column.ColumnName != "Passengers")
                    {
                        removeColumns.Add(column);
                    }
                }
                foreach (DataColumn removeColumn in removeColumns)
                {
                    if (table.Columns.Contains(removeColumn.ColumnName))
                        table.Columns.Remove(removeColumn);
                }
                return table;
            }

            /// <summary>
            /// The function returns the Flight Categories that correspond to a flight subcategory.
            /// (This case is particular for BNP because here we consider flight subcategories to be flight categories and reverse)
            /// </summary>
            /// <param name="flightSubcategoriesTable"></param>
            /// <param name="flightCategory"></param>
            /// <returns></returns>
            internal static List<String> getFlightCategoriesListByFlightSubCategory(DataTable flightSubcategoriesTable, String flightSubCategory)
            {
                List<String> flightCategoriesList = new List<String>();
                int flightSubcategoryNameColumnIndex = flightSubcategoriesTable.Columns.IndexOf(GlobalNames.flightSubcategoryColumnName);

                if (flightSubcategoryNameColumnIndex == -1)
                    return flightCategoriesList;

                foreach (DataRow dr in flightSubcategoriesTable.Rows)
                {
                    // we look for the row corresponding to the DOM_USA flight subcategory(in this case F.categ are F.subcateg and reverse)
                    if (!dr[flightSubcategoryNameColumnIndex].ToString().Equals(flightSubCategory))
                        continue;

                    for (int i = 1; i < flightSubcategoriesTable.Columns.Count; i++)
                    {
                        DataColumn col = flightSubcategoriesTable.Columns[i];
                        String percentageValue = dr[col].ToString();
                        int flightSubcategoryPercentage = -1;

                        if (Int32.TryParse(percentageValue, out flightSubcategoryPercentage)
                            && flightSubcategoryPercentage > 0)
                        {
                            flightCategoriesList.Add(col.ColumnName);
                        }
                    }
                }
                return flightCategoriesList;
            }

            internal static Double _calculateDomesticContribution(DataTable fpd_checkInShowUpInstantaneous_fc,
                List<String> flighCategoriesList)
            {
                double domesticContribution = 0;
                int rowIndexForMaxTotalHours = -1;
                double maxTotalHours = -1;
                int currentRowIndex = -1;

                foreach (DataRow dr in fpd_checkInShowUpInstantaneous_fc.Rows)
                {
                    currentRowIndex++;
                    double totalHours = 0;
                    foreach (DataColumn column in fpd_checkInShowUpInstantaneous_fc.Columns)
                    {
                        if (!column.ColumnName.Equals("Time"))
                        {
                            double hours = 0;
                            try
                            {
                                if (Double.TryParse(dr[column].ToString(), out hours))
                                    totalHours = totalHours + hours;
                            }
                            catch (Exception e)
                            {
                                OverallTools.ExternFunctions.PrintLogFile("Error occured while calculating the EDS Requirements." + e.Message);
                                continue;
                            }
                        }
                    }
                    if (totalHours > maxTotalHours)
                    {
                        maxTotalHours = totalHours;
                        rowIndexForMaxTotalHours = currentRowIndex;
                    }
                }

                if (rowIndexForMaxTotalHours != -1)
                {
                    double domTotalHours = 0;
                    double allFCTotalHours = 0;

                    foreach (DataColumn column in fpd_checkInShowUpInstantaneous_fc.Columns)
                    {
                        if (column.ColumnName.Equals("Time"))
                            continue;

                        double currentHours = 0;

                        try
                        {
                            if (Double.TryParse(fpd_checkInShowUpInstantaneous_fc.Rows[rowIndexForMaxTotalHours][column].ToString(), out currentHours))
                            {
                                allFCTotalHours = allFCTotalHours + currentHours;
                                if (column.ColumnName.Contains("DOM"))//check with the columnNameContainsFlightSubcategoryFromList function//use the ..._FSC table
                                    domTotalHours = domTotalHours + currentHours;
                            }
                        }
                        catch (Exception e)
                        {
                            OverallTools.ExternFunctions.PrintLogFile("Error occured while calculating the EDS Requirements." + e.Message);
                            continue;
                        }
                    }
                    if (allFCTotalHours > 0)
                        domesticContribution = domTotalHours / allFCTotalHours;
                }
                return domesticContribution;
            }

            // K: row index that identifies the time slot | V: domestic contribution
            internal static Dictionary<int, Double> calculateDomesticContribution(DataTable fpd_checkInShowUpInstantaneous_fc,
                List<String> flighCategoriesList)
            {
                Dictionary<int, Double> timeSlotIndexAndDomesticContributionDictionary = new Dictionary<int, double>();

                int rowIndex = 0;
                foreach (DataRow dr in fpd_checkInShowUpInstantaneous_fc.Rows)
                {
                    double totalHours = 0;
                    double domTotalHours = 0;
                    foreach (DataColumn column in fpd_checkInShowUpInstantaneous_fc.Columns)
                    {
                        if (column.ColumnName.Equals("Time"))
                            continue;

                        double currentHours = 0;

                        try
                        {
                            if (Double.TryParse(fpd_checkInShowUpInstantaneous_fc.Rows[rowIndex][column].ToString(), out currentHours))
                            {
                                totalHours = totalHours + currentHours;
                                if (columnNameContainsFlightCategoryFromList(column.ColumnName, flighCategoriesList))
                                    domTotalHours = domTotalHours + currentHours;
                            }
                        }
                        catch (Exception e)
                        {
                            OverallTools.ExternFunctions.PrintLogFile("Error occured while calculating the EDS Requirements." + e.Message);
                            continue;
                        }
                    }

                    double domesticContribution = 0;
                    if (totalHours > 0)
                        domesticContribution = domTotalHours / totalHours;

                    timeSlotIndexAndDomesticContributionDictionary.Add(rowIndex, domesticContribution);
                    rowIndex++;
                }

                return timeSlotIndexAndDomesticContributionDictionary;
            }

            internal static bool columnNameContainsFlightCategoryFromList(String columnName, List<String> flightCategoriesList)
            {
                foreach (String flightCategory in flightCategoriesList)
                {
                    if (columnName.Contains(flightCategory))
                        return true;
                }
                return false;
            }

            // >> Task #9967 Pax2Sim - BNP development - Peak Flows - USA Standard parameters table
            internal static bool getUsaStandardParameters(DataTable usaStandardParametersTable, out Double oogPercent,
                out Double osPercent, out Double edsScreenRatePerMinute, out Double edsScreenRatePerHour, out Double falseAlarmEdsDom, out Double falseAlarmEdsInt,
                out Double osrProcessingRateBph, out Double clearRate, out Double etdScreenRateDomWithImg, out Double etdScreenRateDomNoImg,
                out Double etdScreenRateIntWithImg, out Double etdScreenRateIntNoImg, out Double lostTrackOS, out Double lostTrackOOG, out Double etdScreenRateOSBags)
            {
                oogPercent = 0;
                osPercent = 0;
                edsScreenRatePerMinute = 0;
                edsScreenRatePerHour = 0;
                falseAlarmEdsDom = 0;
                falseAlarmEdsInt = 0;
                osrProcessingRateBph = 0;
                clearRate = 0;
                etdScreenRateDomWithImg = 0;
                etdScreenRateDomNoImg = 0;
                etdScreenRateIntWithImg = 0;
                etdScreenRateIntNoImg = 0;
                lostTrackOS = 0;
                lostTrackOOG = 0;
                etdScreenRateOSBags = 0;

                if (usaStandardParametersTable != null && usaStandardParametersTable.Rows.Count == 1)
                {
                    #region column indexes
                    int oogPercentColumnIndex = usaStandardParametersTable.Columns.IndexOf(GlobalNames.USA_STANDARD_OOG_PERCENT_PARAM_NAME);
                    int osPercentColumnIndex = usaStandardParametersTable.Columns.IndexOf(GlobalNames.USA_STANDARD_OS_PERCENT_PARAM_NAME);
                    int edsScreenRatePerMinColumnIndex = usaStandardParametersTable.Columns.IndexOf(GlobalNames.USA_STANDARD_EDS_SCREENING_RATE_PER_MINUTE_PARAM_NAME);
                    int edsScreenRatePerHourColumnIndex = usaStandardParametersTable.Columns.IndexOf(GlobalNames.USA_STANDARD_EDS_SCREENING_RATE_PER_HOUR_PARAM_NAME);
                    int falseAlarmEdsDomColumnIndex = usaStandardParametersTable.Columns.IndexOf(GlobalNames.USA_STANDARD_FALSE_ALARM_EDS_DOM_PARAM_NAME);
                    int falseAlarmEdsIntColumnIndex = usaStandardParametersTable.Columns.IndexOf(GlobalNames.USA_STANDARD_FALSE_ALARM_EDS_INT_PARAM_NAME);
                    int osrProcessingRatePerHourColumnIndex = usaStandardParametersTable.Columns.IndexOf(GlobalNames.USA_STANDARD_OSR_PROCESSING_RATE_BPH_PARAM_NAME);
                    int clearRateColumnIndex = usaStandardParametersTable.Columns.IndexOf(GlobalNames.USA_STANDARD_CLEAR_RATE_PARAM_NAME);
                    int etdScreenRateDomWithImageColumnIndex = usaStandardParametersTable.Columns.IndexOf(GlobalNames.USA_STANDARD_ETD_SCREENING_RATE_DOM_WITH_IMAGE_PARAM_NAME);
                    int etdScreenRateDomNoImageColumnIndex = usaStandardParametersTable.Columns.IndexOf(GlobalNames.USA_STANDARD_ETD_SCREENING_RATE_DOM_NO_IMAGE_PARAM_NAME);
                    int etdScreenRateIntWithImageColumnIndex = usaStandardParametersTable.Columns.IndexOf(GlobalNames.USA_STANDARD_ETD_SCREENING_RATE_INT_WITH_IMAGE_PARAM_NAME);
                    int etdScreenRateIntNoImageColumnIndex = usaStandardParametersTable.Columns.IndexOf(GlobalNames.USA_STANDARD_ETD_SCREENING_RATE_INT_NO_IMAGE_PARAM_NAME);
                    int lostTrackOSColumnIndex = usaStandardParametersTable.Columns.IndexOf(GlobalNames.USA_STANDARD_RATE_LOST_TRACK_OS_PARAM_NAME);
                    //int lostTrackOOGColumnIndex = usaStandardParametersTable.Columns.IndexOf(GlobalNames.USA_STANDARD_RATE_LOST_TRACK_OOG_PARAM_NAME);
                    int etdScreenRateOSBagsPerHourColumnIndex = usaStandardParametersTable.Columns.IndexOf(GlobalNames.USA_STANDARD_ETD_SCREENING_RATE_OS_BAGS_BPH_PARAM_NAME);
                    #endregion

                    if (oogPercentColumnIndex == -1 || osPercentColumnIndex == -1 || edsScreenRatePerMinColumnIndex == -1 || edsScreenRatePerHourColumnIndex == -1
                        || falseAlarmEdsDomColumnIndex == -1 || falseAlarmEdsIntColumnIndex == -1 || osrProcessingRatePerHourColumnIndex == -1 || clearRateColumnIndex == -1
                        || etdScreenRateDomWithImageColumnIndex == -1 || etdScreenRateDomNoImageColumnIndex == -1 || etdScreenRateIntWithImageColumnIndex == -1
                        || etdScreenRateIntNoImageColumnIndex == -1 || lostTrackOSColumnIndex == -1
                        //|| lostTrackOOGColumnIndex == -1 
                        || etdScreenRateOSBagsPerHourColumnIndex == -1)
                    {
                        return false;
                    }

                    DataRow row = usaStandardParametersTable.Rows[0];

                    if (Double.TryParse(row[oogPercentColumnIndex].ToString(), out oogPercent)
                        && Double.TryParse(row[osPercentColumnIndex].ToString(), out osPercent)
                        && Double.TryParse(row[edsScreenRatePerMinColumnIndex].ToString(), out edsScreenRatePerMinute)
                        && Double.TryParse(row[edsScreenRatePerHourColumnIndex].ToString(), out edsScreenRatePerHour)
                        && Double.TryParse(row[falseAlarmEdsDomColumnIndex].ToString(), out falseAlarmEdsDom)
                        && Double.TryParse(row[falseAlarmEdsIntColumnIndex].ToString(), out falseAlarmEdsInt)
                        && Double.TryParse(row[osrProcessingRatePerHourColumnIndex].ToString(), out osrProcessingRateBph)
                        && Double.TryParse(row[clearRateColumnIndex].ToString(), out clearRate)
                        && Double.TryParse(row[etdScreenRateDomWithImageColumnIndex].ToString(), out etdScreenRateDomWithImg)
                        && Double.TryParse(row[etdScreenRateDomNoImageColumnIndex].ToString(), out etdScreenRateDomNoImg)
                        && Double.TryParse(row[etdScreenRateIntWithImageColumnIndex].ToString(), out etdScreenRateIntWithImg)
                        && Double.TryParse(row[etdScreenRateIntNoImageColumnIndex].ToString(), out etdScreenRateIntNoImg)
                        //&& Double.TryParse(row[lostTrackOOGColumnIndex].ToString(), out  lostTrackOOG)
                        && Double.TryParse(row[lostTrackOSColumnIndex].ToString(), out lostTrackOS)
                        && Double.TryParse(row[etdScreenRateOSBagsPerHourColumnIndex].ToString(), out etdScreenRateOSBags))
                    {
                        return true;
                    }
                }
                return false;
            }
            // << Task #9967 Pax2Sim - BNP development - Peak Flows - USA Standard parameters table

            internal static ArrayList calculateEBSRequirementsStaticAnalysisTables(ArrayList staticAnalysisTablesList)
            {
                ArrayList ebsRequirementsStaticAnalysisTables = new ArrayList();
                DataTable duplicatedFPD_EBS = null;

                foreach (DataTable staticAnalysisTable in staticAnalysisTablesList)
                {
                    if (staticAnalysisTable.TableName.Equals(GlobalNames.FPD_EBS_ROLLING_TABLE_NAME))
                        duplicatedFPD_EBS = staticAnalysisTable.Copy();
                }

                if (duplicatedFPD_EBS != null)
                {
                    duplicatedFPD_EBS.TableName = GlobalNames.usaStandard_EBSRequirements_tableName;
                    ebsRequirementsStaticAnalysisTables.Add(duplicatedFPD_EBS);

                    DataTable dataStatsTable = duplicatedFPD_EBS.Copy();
                    dataStatsTable.TableName = GlobalNames.EBS_STATS_TABLE_NAME;
                    DataTable Stats = OverallTools.DataFunctions.GetStatTable(dataStatsTable, new int[5] { 1, 2, 3, 4, 5 });
                    Stats.TableName = GlobalNames.EBS_STATS_TABLE_NAME;
                    ebsRequirementsStaticAnalysisTables.Add(Stats);
                }

                return ebsRequirementsStaticAnalysisTables;
            }

            // >> Task #10035 Pax2Sim - BNP development - Data Input tables
            internal static DataTable createFlightPlanInformationTable(DataTable departureFlightPlanTable, NormalTable departureLoadFactorsNT,
                NormalTable aircraftTypeNT, NormalTable nbBagsNT)
            {
                DataTable flightPlanInformation = createFlightPlanInformationTableStructure();

                #region Column Indexes for Flight Plan Information table
                int indexColumnID_FPInfo = flightPlanInformation.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID);
                int indexColumnDate_FPInfo = flightPlanInformation.Columns.IndexOf(GlobalNames.sFPD_A_Column_DATE);
                int indexColumnSTD_FPInfo = flightPlanInformation.Columns.IndexOf(GlobalNames.sFPD_Column_STD);
                int indexColumnAirlineCode_FPInfo = flightPlanInformation.Columns.IndexOf(GlobalNames.sFPD_A_Column_AirlineCode);
                int indexColumnFlightNb_FPInfo = flightPlanInformation.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightN);
                int indexColumnAirportCode_FPInfo = flightPlanInformation.Columns.IndexOf(GlobalNames.sFPD_A_Column_AirportCode);
                int indexColumnFlightCategory_FPInfo = flightPlanInformation.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightCategory);
                int indexColumnAircraftType_FPInfo = flightPlanInformation.Columns.IndexOf(GlobalNames.sFPD_A_Column_AircraftType);
                int indexColumnTSA_FPInfo = flightPlanInformation.Columns.IndexOf(GlobalNames.sFPD_Column_TSA);
                int indexColumnNbSeats_FPInfo = flightPlanInformation.Columns.IndexOf(GlobalNames.sFPD_A_Column_NbSeats);
                int indexColumnLoadFactor_FPInfo = flightPlanInformation.Columns.IndexOf(GlobalNames.LOAD_FACTOR_COLUMN_NAME);
                int indexColumnNbPassengers_FPInfo = flightPlanInformation.Columns.IndexOf(GlobalNames.FPI_Column_Nb_Passengers);
                int indexColumnNbBags_FPInfo = flightPlanInformation.Columns.IndexOf(GlobalNames.FPI_Column_Nb_Bags);
                int indexColumnUser1_FPInfo = flightPlanInformation.Columns.IndexOf(GlobalNames.sFPD_A_Column_User1);
                int indexColumnUser2_FPInfo = flightPlanInformation.Columns.IndexOf(GlobalNames.sFPD_A_Column_User2);
                int indexColumnUser3_FPInfo = flightPlanInformation.Columns.IndexOf(GlobalNames.sFPD_A_Column_User3);
                int indexColumnUser4_FPInfo = flightPlanInformation.Columns.IndexOf(GlobalNames.sFPD_A_Column_User4);
                int indexColumnUser5_FPInfo = flightPlanInformation.Columns.IndexOf(GlobalNames.sFPD_A_Column_User5);
                #endregion

                #region Column Indexes for the Departure Flight Plan table
                int indexColumnID_FPD = departureFlightPlanTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID);
                int indexColumnDate_FPD = departureFlightPlanTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_DATE);
                int indexColumnSTD_FPD = departureFlightPlanTable.Columns.IndexOf(GlobalNames.sFPD_Column_STD);
                int indexColumnAirlineCode_FPD = departureFlightPlanTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_AirlineCode);
                int indexColumnFlightNb_FPD = departureFlightPlanTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightN);
                int indexColumnAirportCode_FPD = departureFlightPlanTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_AirportCode);
                int indexColumnFlightCategory_FPD = departureFlightPlanTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightCategory);
                int indexColumnAircraftType_FPD = departureFlightPlanTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_AircraftType);
                int indexColumnTSA_FPD = departureFlightPlanTable.Columns.IndexOf(GlobalNames.sFPD_Column_TSA);
                int indexColumnNbSeats_FPD = departureFlightPlanTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_NbSeats);
                int indexColumnUser1_FPD = departureFlightPlanTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_User1);
                int indexColumnUser2_FPD = departureFlightPlanTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_User2);
                int indexColumnUser3_FPD = departureFlightPlanTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_User3);
                int indexColumnUser4_FPD = departureFlightPlanTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_User4);
                int indexColumnUser5_FPD = departureFlightPlanTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_User5);
                #endregion

                #region Exception tables
                DataManagement.ExceptionTable departureLoadFactorsET = null;
                DataManagement.ExceptionTable aircraftTypeET = null;
                DataManagement.ExceptionTable nbBagsET = null;

                if (departureLoadFactorsNT is DataManagement.ExceptionTable)
                    departureLoadFactorsET = (DataManagement.ExceptionTable)departureLoadFactorsNT;

                if (aircraftTypeNT is DataManagement.ExceptionTable)
                    aircraftTypeET = (DataManagement.ExceptionTable)aircraftTypeNT;

                if (nbBagsNT is DataManagement.ExceptionTable)
                    nbBagsET = (DataManagement.ExceptionTable)nbBagsNT;
                #endregion

                #region check data integrity
                if (indexColumnID_FPD == -1 || indexColumnDate_FPD == -1 || indexColumnSTD_FPD == -1 || indexColumnAirlineCode_FPD == -1
                    || indexColumnFlightNb_FPD == -1 || indexColumnAirportCode_FPD == -1 || indexColumnFlightCategory_FPD == -1
                    || indexColumnAircraftType_FPD == -1 || indexColumnTSA_FPD == -1 || indexColumnNbSeats_FPD == -1
                    || indexColumnUser1_FPD == -1 || indexColumnUser2_FPD == -1 || indexColumnUser3_FPD == -1 || indexColumnUser4_FPD == -1 || indexColumnUser5_FPD == -1
                    || departureLoadFactorsET == null || aircraftTypeET == null || nbBagsET == null)
                {
                    OverallTools.ExternFunctions.PrintLogFile("There was a problem while creating the Flight Plan Information table for the USA Standard. Some "
                        + "data is missing from the Flight Plan, Load Factors, Aircraft Type and(or) Number of Bags tables.");
                    return flightPlanInformation;
                }
                #endregion

                foreach (DataRow fpdRow in departureFlightPlanTable.Rows)
                {
                    DataRow fpInfoRow = flightPlanInformation.NewRow();

                    #region Obtain the values for the flight (current row from FPD)
                    int flightId = -1;
                    DateTime date = new DateTime();
                    TimeSpan std = new TimeSpan();
                    String airlineCode = "";
                    String flightNb = "";
                    String airportCode = "";
                    String flightCategory = "";
                    String aircraftType = "";
                    Boolean TSA = false;
                    int nbSeats = -1;
                    String user1 = "";
                    String user2 = "";
                    String user3 = "";
                    String user4 = "";
                    String user5 = "";

                    if (indexColumnID_FPD != -1)
                        flightId = int.Parse(fpdRow[indexColumnID_FPD].ToString());
                    if (indexColumnDate_FPD != -1)
                        date = DateTime.Parse(fpdRow[indexColumnDate_FPD].ToString());
                    if (indexColumnSTD_FPD != -1)
                        std = TimeSpan.Parse(fpdRow[indexColumnSTD_FPD].ToString());
                    if (indexColumnAirlineCode_FPD != -1)
                        airlineCode = fpdRow[indexColumnAirlineCode_FPD].ToString();
                    if (indexColumnFlightNb_FPD != -1)
                        flightNb = fpdRow[indexColumnFlightNb_FPD].ToString();
                    if (indexColumnAirportCode_FPD != -1)
                        airportCode = fpdRow[indexColumnAirportCode_FPD].ToString();
                    if (indexColumnFlightCategory_FPD != -1)
                        flightCategory = fpdRow[indexColumnFlightCategory_FPD].ToString();
                    if (indexColumnAircraftType_FPD != -1)
                        aircraftType = fpdRow[indexColumnAircraftType_FPD].ToString();
                    if (indexColumnTSA_FPD != -1)
                        TSA = bool.Parse(fpdRow[indexColumnTSA_FPD].ToString());
                    if (indexColumnNbSeats_FPD != -1)
                        nbSeats = int.Parse(fpdRow[indexColumnNbSeats_FPD].ToString());
                    if (indexColumnUser1_FPD != -1)
                        user1 = fpdRow[indexColumnUser1_FPD].ToString();
                    if (indexColumnUser1_FPD != -1)
                        user2 = fpdRow[indexColumnUser2_FPD].ToString();
                    if (indexColumnUser1_FPD != -1)
                        user3 = fpdRow[indexColumnUser3_FPD].ToString();
                    if (indexColumnUser1_FPD != -1)
                        user4 = fpdRow[indexColumnUser4_FPD].ToString();
                    if (indexColumnUser1_FPD != -1)
                        user5 = fpdRow[indexColumnUser5_FPD].ToString();
                    #endregion

                    fpInfoRow[indexColumnID_FPInfo] = flightId.ToString();
                    fpInfoRow[indexColumnDate_FPInfo] = date;
                    fpInfoRow[indexColumnSTD_FPInfo] = std;
                    fpInfoRow[indexColumnAirlineCode_FPInfo] = airlineCode;
                    fpInfoRow[indexColumnFlightNb_FPInfo] = flightNb;
                    fpInfoRow[indexColumnAirportCode_FPInfo] = airportCode;
                    fpInfoRow[indexColumnFlightCategory_FPInfo] = flightCategory;
                    fpInfoRow[indexColumnAircraftType_FPInfo] = aircraftType;
                    fpInfoRow[indexColumnTSA_FPInfo] = TSA;
                    fpInfoRow[indexColumnNbSeats_FPInfo] = nbSeats;
                    fpInfoRow[indexColumnUser1_FPInfo] = user1;
                    fpInfoRow[indexColumnUser2_FPInfo] = user2;
                    fpInfoRow[indexColumnUser3_FPInfo] = user3;
                    fpInfoRow[indexColumnUser4_FPInfo] = user4;
                    fpInfoRow[indexColumnUser5_FPInfo] = user5;

                    #region calculate nb of pax, bags
                    String sLoadFactor = null;
                    Double dTotalNumberOfPassengers = -1;
                    Double dTotalNumberOfBags = -1;

                    if ((aircraftTypeET != null)
                        && (departureLoadFactorsET != null) && (nbBagsET != null))
                    {
                        List<string> alErrors_ = new List<string>();
                        int iColumn;
                        DataTable dtTableBags = nbBagsET.GetInformationsColumns(0, "D_" + flightId.ToString(), airlineCode, flightCategory, out iColumn);

                        if (dtTableBags != null)
                        {
                            Double dMeanBaggage = OverallTools.StaticAnalysis.CalculCoefficientMultiplicateur(dtTableBags, iColumn);
                            if (dMeanBaggage != -1)
                            {
                                dTotalNumberOfPassengers = OverallTools.DataFunctions.numberOfPassengers(fpdRow, aircraftTypeET, null, departureLoadFactorsET, alErrors_);

                                if (dTotalNumberOfPassengers == -1)
                                {
                                    OverallTools.ExternFunctions.PrintLogFile("Err00681 : Flight ignored : \"" + flightId + "\". The number of passenger for that flight is not valid.");
                                    continue;
                                }
                                dTotalNumberOfBags = Math.Round(dTotalNumberOfPassengers * dMeanBaggage, 2);
                            }
                        }
                        String sPrefixe = "D_";
                        Dictionary<String, String> dssResults = departureLoadFactorsET.GetInformationsColumns(0, sPrefixe + flightId, airlineCode, flightCategory);
                        sLoadFactor = dssResults[GlobalNames.sLFD_A_Line_Full];
                    }
                    #endregion

                    if (sLoadFactor != null)
                        fpInfoRow[indexColumnLoadFactor_FPInfo] = sLoadFactor;
                    if (dTotalNumberOfPassengers != -1)
                        fpInfoRow[indexColumnNbPassengers_FPInfo] = Math.Round(dTotalNumberOfPassengers, 3);
                    if (dTotalNumberOfBags != -1)
                        fpInfoRow[indexColumnNbBags_FPInfo] = Math.Round(dTotalNumberOfBags, 3);

                    flightPlanInformation.Rows.Add(fpInfoRow);
                }
                return flightPlanInformation;
            }

            private static DataTable createFlightPlanInformationTableStructure()
            {
                DataTable flightPlanInformation = new DataTable(GlobalNames.FLIGHT_PLAN_TABLE_GENERIC_NAME_FOR_SCENARIO);

                flightPlanInformation.Columns.Add(GlobalNames.sFPD_A_Column_ID, typeof(String));
                flightPlanInformation.Columns.Add(GlobalNames.sFPD_A_Column_DATE, typeof(DateTime));
                flightPlanInformation.Columns.Add(GlobalNames.sFPD_Column_STD, typeof(TimeSpan));
                flightPlanInformation.Columns.Add(GlobalNames.sFPD_A_Column_AirlineCode, typeof(String));
                flightPlanInformation.Columns.Add(GlobalNames.sFPD_A_Column_FlightN, typeof(String));
                flightPlanInformation.Columns.Add(GlobalNames.sFPD_A_Column_AirportCode, typeof(String));
                flightPlanInformation.Columns.Add(GlobalNames.sFPD_A_Column_FlightCategory, typeof(String));
                flightPlanInformation.Columns.Add(GlobalNames.sFPD_A_Column_AircraftType, typeof(String));
                flightPlanInformation.Columns.Add(GlobalNames.sFPD_Column_TSA, typeof(Boolean));
                flightPlanInformation.Columns.Add(GlobalNames.sFPD_A_Column_NbSeats, typeof(int));
                flightPlanInformation.Columns.Add(GlobalNames.LOAD_FACTOR_COLUMN_NAME, typeof(String));
                flightPlanInformation.Columns.Add(GlobalNames.FPI_Column_Nb_Passengers, typeof(double));
                flightPlanInformation.Columns.Add(GlobalNames.FPI_Column_Nb_Bags, typeof(double));
                flightPlanInformation.Columns.Add(GlobalNames.sFPD_A_Column_User1, typeof(String));
                flightPlanInformation.Columns.Add(GlobalNames.sFPD_A_Column_User2, typeof(String));
                flightPlanInformation.Columns.Add(GlobalNames.sFPD_A_Column_User3, typeof(String));
                flightPlanInformation.Columns.Add(GlobalNames.sFPD_A_Column_User4, typeof(String));
                flightPlanInformation.Columns.Add(GlobalNames.sFPD_A_Column_User5, typeof(String));

                return flightPlanInformation;
            }

            // << Task #10035 Pax2Sim - BNP development - Data Input tables

            #endregion
            // << Task #9915 Pax2Sim - BNP development - Peak Flows - USA Standard directory
            #endregion

            #region private static Double getDistribution(Int32 iOpening, Int32 iClosing, DataTable dtDistrib, String sFlightCateg)
            /// <summary>
            /// Function which permits to determine the passenger distribution for the observed period..
            /// </summary>
            /// <param name="iOpening">Start of the period.</param>
            /// <param name="iClosing">End of the period</param>
            /// <param name="dtDistrib">Table which contains the distribution</param>
            /// <param name="sFlightCateg">Flight category observed.</param>
            /// <returns></returns>
            private static Double getDistribution(Int32 iOpening, Int32 iClosing, DataTable dtDistrib, String sFlightCateg)
            {
                if (!dtDistrib.Columns.Contains(sFlightCateg))
                    return -1;
                int iIndexFC = dtDistrib.Columns.IndexOf(sFlightCateg);
                return getDistribution(iOpening, iClosing, dtDistrib, iIndexFC);
            }
            private static Double getDistribution(Int32 iOpening, Int32 iClosing, DataTable dtDistrib, int iIndexColumn)
            {
                if (iOpening < iClosing)
                {
                    int iTmp = iOpening;
                    iOpening = iClosing;
                    iClosing = iTmp;
                }
                int iPas = (Int32)dtDistrib.Rows[0][1] - (Int32)dtDistrib.Rows[0][0];
                Double dResult = 0;
                foreach (DataRow drLine in dtDistrib.Rows)
                {
                    int iBegin = (Int32)drLine[0];
                    int iEnd = (Int32)drLine[1];
                    int iSup = iEnd - iOpening;
                    int iInf = iBegin - iClosing;
                    if (((iSup < -iPas) && (iInf < -iPas)) || ((iSup >= iPas) && (iInf > iPas)))
                        continue;
                    if ((iSup > 0) && (iInf < 0))
                    {
                        dResult += (((Double)iPas - iSup + iInf) / iPas) * (Double)drLine[iIndexColumn] / 100.0;
                    }
                    else if ((iSup > 0) && (iSup <= iPas))
                    {
                        dResult += (((Double)iPas - iSup) / iPas) * (Double)drLine[iIndexColumn] / 100.0;
                    }
                    else if ((iInf >= -iPas) && (iInf <= 0))
                    {
                        dResult += (((Double)iPas + iInf) / iPas) * (Double)drLine[iIndexColumn] / 100.0;
                    }
                    else if ((iInf >= 0) && (iSup <= 0))
                    {
                        dResult += (Double)drLine[iIndexColumn] / 100.0;
                    }
                }
                return dResult;
            }
            #endregion
            //Err00450==> Err00461
            #region Fonction pour l'analyse des passagers en arrivée

            private static ArrayList CalcStaticArrivalAnalysis2(DataTable FPATable,
                DataManagement.NormalTable dtLoadFactors,
                DataManagement.NormalTable TypeAvions,
                DataManagement.NormalTable dtNbBags,
                DataManagement.NormalTable dtNbVisitors,
                DataManagement.NormalTable dtNbTrolley,
                DataManagement.NormalTable dtICTTable,
                // << Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay
                DataManagement.NormalTable dtBaggageLoadingRateTable,
                DataManagement.NormalTable dtBaggageLoadingDelayTable,
                // >> Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay
                DataTable dtFlightCategories,
                DateTime dtBegin,
                DateTime dtEnd,
                Double samplingStep,
                Double analysisRange,
                ArrayList ListeErreurs,
                GestionDonneesHUB2SIM donnees,  // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                                // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                bool bUseDefinedNbPax,
                DataTable dtNumberOfPassengers,
                bool bUseDefinedNbBags,
                DataTable dtNumberOfBaggages
                // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                , double[] distributionLevels   // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                , List<FlightConfiguration> userDefinedFlightConfigurations
                )
            {
                int j, i;

                // << Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay                
                #region Load BHS loading rate and loading delay tables
                NormalTable bagLoadingRateNormalTable = dtBaggageLoadingRateTable;  //donnees.GetTable("Input", GlobalNames.sUserAttributesBaggLoadingRateTableName);
                NormalTable bagLoadingDelayNormalTable = dtBaggageLoadingDelayTable; //donnees.GetTable("Input", GlobalNames.sUserAttributesBaggLoadingDelayTableName);
                #endregion
                // >> Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay

                #region We check for empty tables and wrong parameters
                if (FPATable.Rows.Count == 0)
                {
                    ListeErreurs.Add("Err00450 : Unable to calc the static results. The flight plan table for arrivals must contain a row.");
                    return null;
                }

                if (dtFlightCategories.Rows.Count == 0)
                {
                    ListeErreurs.Add("Err00452 : Unable to calc the static results. There is no defined flight categories.");
                    return null;
                }

                // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                if (dtBegin >= dtEnd)
                {
                    ListeErreurs.Add("Unable to calculate the static results. Please review the time interval set for the simultation.(Begin and End dates)");
                    return null;
                }
                // >> Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns

                DataManagement.ExceptionTable etLoadFactors;
                if (dtLoadFactors is DataManagement.ExceptionTable)
                    etLoadFactors = (DataManagement.ExceptionTable)dtLoadFactors;
                else
                    return null;

                DataManagement.ExceptionTable etAircraftType;
                if (TypeAvions is DataManagement.ExceptionTable)
                    etAircraftType = (DataManagement.ExceptionTable)TypeAvions;
                else
                    return null;

                DataManagement.ExceptionTable etICTTable;
                if (dtICTTable is DataManagement.ExceptionTable)
                    etICTTable = (DataManagement.ExceptionTable)dtICTTable;
                else
                    return null;

                DataManagement.ExceptionTable etNbBags;
                if (dtNbBags is DataManagement.ExceptionTable)
                    etNbBags = (DataManagement.ExceptionTable)dtNbBags;
                else
                    return null;

                DataManagement.ExceptionTable etNbVisitors;
                if (dtNbVisitors is DataManagement.ExceptionTable)
                    etNbVisitors = (DataManagement.ExceptionTable)dtNbVisitors;
                else
                    return null;

                DataManagement.ExceptionTable etNbTrolley;
                if (dtNbTrolley is DataManagement.ExceptionTable)
                    etNbTrolley = (DataManagement.ExceptionTable)dtNbTrolley;
                else
                    return null;
                if ((dtBegin > dtEnd) /*|| (dtBegin.AddDays(7) < dtEnd)*/)
                {
                    ListeErreurs.Add("Err00456 : Unable to calc the static results. The dates are not valids.");
                    return null;
                }
                if ((samplingStep < 1) || (samplingStep > 60))
                {
                    ListeErreurs.Add("Err00457 : Unable to calc the static results. The analysis step is not valid.");
                    return null;
                }

                int iIndexID = FPATable.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID);
                int iIndexAirline = FPATable.Columns.IndexOf(GlobalNames.sFPD_A_Column_AirlineCode);
                int iIndexFC = FPATable.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightCategory);
                int iIndexDate = FPATable.Columns.IndexOf(GlobalNames.sFPD_A_Column_DATE);
                int iIndexTime = FPATable.Columns.IndexOf(GlobalNames.sFPA_Column_STA);
                if ((iIndexID == -1) ||
                    (iIndexAirline == -1) ||
                    (iIndexFC == -1) ||
                    (iIndexDate == -1) ||
                    (iIndexTime == -1))
                {
                    return null;
                }

                // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                DataManagement.ExceptionTable bagLoadingRateExceptionTable = null;
                if (bagLoadingRateNormalTable != null && bagLoadingRateNormalTable is DataManagement.ExceptionTable)
                    bagLoadingRateExceptionTable = (DataManagement.ExceptionTable)bagLoadingRateNormalTable;

                DataManagement.ExceptionTable bagLoadingDelayExceptionTable = null;
                if (bagLoadingDelayNormalTable != null && bagLoadingDelayNormalTable is DataManagement.ExceptionTable)
                    bagLoadingDelayExceptionTable = (DataManagement.ExceptionTable)bagLoadingDelayNormalTable;
                // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                int departureOriginatingPaxDefinedNbColumnIndex = -1;
                int departureTransferringPaxDefinedNbColumnIndex = -1;
                int arrivalTerminatingPaxDefinedNbColumnIndex = -1;
                int arrivalTransferringPaxDefinedNbColumnIndex = -1;

                if (bUseDefinedNbPax)
                {
                    if (dtNumberOfPassengers == null)
                    {
                        ListeErreurs.Add("Error: The Number of Passengers table is missing.");
                        return null;
                    }
                    departureOriginatingPaxDefinedNbColumnIndex = dtNumberOfPassengers.Columns
                                                                        .IndexOf(GlobalNames.originatingPaxDepartureColumnName);
                    departureTransferringPaxDefinedNbColumnIndex = dtNumberOfPassengers.Columns
                                                                        .IndexOf(GlobalNames.transferringPaxDepartureColumnName);
                    arrivalTerminatingPaxDefinedNbColumnIndex = dtNumberOfPassengers.Columns
                                                                        .IndexOf(GlobalNames.terminatingPaxArrivalColumnName);
                    arrivalTransferringPaxDefinedNbColumnIndex = dtNumberOfPassengers.Columns
                                                                        .IndexOf(GlobalNames.transferringPaxArrivalColumnName);

                    if (arrivalTerminatingPaxDefinedNbColumnIndex == -1 || arrivalTransferringPaxDefinedNbColumnIndex == -1)
                    {
                        ListeErreurs.Add("Error: The Number of Passengers table is missing one or more columns.");
                        return null;
                    }
                }

                int departureOriginatingBagsDefinedNbColumnIndex = -1;
                int departureTransferringBagsDefinedNbColumnIndex = -1;
                int arrivalTerminatingBagsDefinedNbColumnIndex = -1;
                int arrivalTransferringBagsDefinedNbColumnIndex = -1;

                if (bUseDefinedNbBags)
                {
                    if (dtNumberOfBaggages == null)
                    {
                        ListeErreurs.Add("Error: The Number of Bags table is missing");
                        return null;
                    }
                    departureOriginatingBagsDefinedNbColumnIndex = dtNumberOfBaggages.Columns
                                                                        .IndexOf(GlobalNames.originatingBagDepartureColumnName);
                    departureTransferringBagsDefinedNbColumnIndex = dtNumberOfBaggages.Columns
                                                                        .IndexOf(GlobalNames.transferringBagDepartureColumnName);
                    arrivalTerminatingBagsDefinedNbColumnIndex = dtNumberOfBaggages.Columns
                                                                        .IndexOf(GlobalNames.terminatingBagArrivalColumnName);
                    arrivalTransferringBagsDefinedNbColumnIndex = dtNumberOfBaggages.Columns
                                                                        .IndexOf(GlobalNames.transferringBagArrivalColumnName);

                    if (arrivalTerminatingBagsDefinedNbColumnIndex == -1 || arrivalTransferringBagsDefinedNbColumnIndex == -1)
                    {
                        ListeErreurs.Add("Error: The Number of Bags table is missing one or more columns.");
                        return null;
                    }
                }

                Double definedTerminatingNbBags = -1;
                Double definedTransferringNbBags = -1;

                if (bUseDefinedNbBags)
                {
                    Double.TryParse(dtNumberOfBaggages.Rows[0][arrivalTerminatingBagsDefinedNbColumnIndex].ToString(), out definedTerminatingNbBags);
                    Double.TryParse(dtNumberOfBaggages.Rows[0][arrivalTransferringBagsDefinedNbColumnIndex].ToString(), out definedTransferringNbBags);
                }
                // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                #endregion
                //Création de la table qui va récupéré les informations.
                ArrayList alResults = new ArrayList();
                DataTable dtPaxGateSmoothed = new DataTable("FPA_InBoundRolling");
                DataTable dtPaxGateInstantaneous = null;

                // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                DataTable paxGateSmoothedBHS = new DataTable(GlobalNames.paxGateSmoothedBHSTableName);
                DataTable paxGateInstantaneousBHS = null;
                // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                DataTable dtAircraftMovementsSmoothed = new DataTable("FPA_AircraftMovementsRolling");
                DataTable dtAircraftMovementsInstantaneous = null;

                DataTable dtTransferICTSmoothed = new DataTable("FPA_TransferICTRolling");
                DataTable dtTransferICTInstantaneous = null;

                //Initialisation de la table de résultats.
                dtPaxGateSmoothed.Columns.Add("Time", System.Type.GetType("System.DateTime"));
                // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns                
                dtPaxGateSmoothed.Columns.Add("Total PAX", System.Type.GetType("System.Double"));
                dtPaxGateSmoothed.Columns.Add("Total PAX / h", System.Type.GetType("System.Double"));
                dtPaxGateSmoothed.Columns.Add("Terminating PAX", System.Type.GetType("System.Double"));
                dtPaxGateSmoothed.Columns.Add("Terminating PAX / h", System.Type.GetType("System.Double"));
                dtPaxGateSmoothed.Columns.Add("Transferring PAX", System.Type.GetType("System.Double"));
                dtPaxGateSmoothed.Columns.Add("Transferring PAX / h", System.Type.GetType("System.Double"));
                dtPaxGateSmoothed.Columns.Add("Total Bags", System.Type.GetType("System.Double"));
                dtPaxGateSmoothed.Columns.Add("Total Bags / h", System.Type.GetType("System.Double"));
                dtPaxGateSmoothed.Columns.Add("Terminating Bags", System.Type.GetType("System.Double"));
                dtPaxGateSmoothed.Columns.Add("Terminating Bags / h", System.Type.GetType("System.Double"));
                dtPaxGateSmoothed.Columns.Add("Transferring Bags", System.Type.GetType("System.Double"));
                dtPaxGateSmoothed.Columns.Add("Transferring Bags / h", System.Type.GetType("System.Double"));
                dtPaxGateSmoothed.Columns.Add("Visitors", System.Type.GetType("System.Double"));
                dtPaxGateSmoothed.Columns.Add("Visitors / h", System.Type.GetType("System.Double"));
                dtPaxGateSmoothed.Columns.Add("Trolleys", System.Type.GetType("System.Double"));
                dtPaxGateSmoothed.Columns.Add("Trolleys / h", System.Type.GetType("System.Double"));
                // >> Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                # region paxGateSmoothedBHS table columns and indexes
                int paxGateSmoothedBHS_indexColumn_Time = paxGateSmoothedBHS.Columns.Count;
                paxGateSmoothedBHS.Columns.Add("Time", System.Type.GetType("System.DateTime"));
                int paxGateSmoothedBHS_indexColumn_TotalBags = paxGateSmoothedBHS.Columns.Count;
                paxGateSmoothedBHS.Columns.Add("Total Bags", System.Type.GetType("System.Double"));
                int paxGateSmoothedBHS_indexColumn_TotalBagsPerHour = paxGateSmoothedBHS.Columns.Count;
                paxGateSmoothedBHS.Columns.Add("Total Bags / h", System.Type.GetType("System.Double"));
                int paxGateSmoothedBHS_indexColumn_TerminatingBags = paxGateSmoothedBHS.Columns.Count;
                paxGateSmoothedBHS.Columns.Add("Terminating Bags", System.Type.GetType("System.Double"));
                int paxGateSmoothedBHS_indexColumn_TerminatingBagsPerHour = paxGateSmoothedBHS.Columns.Count;
                paxGateSmoothedBHS.Columns.Add("Terminating Bags / h", System.Type.GetType("System.Double"));
                int paxGateSmoothedBHS_indexColumn_TransferingBags = paxGateSmoothedBHS.Columns.Count;
                paxGateSmoothedBHS.Columns.Add("Transferring Bags", System.Type.GetType("System.Double"));
                int paxGateSmoothedBHS_indexColumn_TransferingBagsPerHour = paxGateSmoothedBHS.Columns.Count;
                paxGateSmoothedBHS.Columns.Add("Transferring Bags / h", System.Type.GetType("System.Double"));
                int paxGateSmoothedBHS_indexColumn_TotalBHSBags = paxGateSmoothedBHS.Columns.Count;
                paxGateSmoothedBHS.Columns.Add("Total BHS Bags", System.Type.GetType("System.Double"));
                int paxGateSmoothedBHS_indexColumn_TotalBHSBagsPerHour = paxGateSmoothedBHS.Columns.Count;
                paxGateSmoothedBHS.Columns.Add("Total BHS Bags / h", System.Type.GetType("System.Double"));
                int paxGateSmoothedBHS_indexColumn_TerminatingBHSBags = paxGateSmoothedBHS.Columns.Count;
                paxGateSmoothedBHS.Columns.Add("Terminating BHS Bags", System.Type.GetType("System.Double"));
                int paxGateSmoothedBHS_indexColumn_TerminatingBHSBagsPerHour = paxGateSmoothedBHS.Columns.Count;
                paxGateSmoothedBHS.Columns.Add("Terminating BHS Bags / h", System.Type.GetType("System.Double"));
                int paxGateSmoothedBHS_indexColumn_TransferingBHSBags = paxGateSmoothedBHS.Columns.Count;
                paxGateSmoothedBHS.Columns.Add("Transferring BHS Bags", System.Type.GetType("System.Double"));
                int paxGateSmoothedBHS_indexColumn_TransferingBHSBagsPerHour = paxGateSmoothedBHS.Columns.Count;
                paxGateSmoothedBHS.Columns.Add("Transferring BHS Bags / h", System.Type.GetType("System.Double"));
                #endregion
                // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                dtAircraftMovementsSmoothed.Columns.Add("Time", System.Type.GetType("System.DateTime"));
                dtAircraftMovementsSmoothed.Columns.Add("Nb Flights", System.Type.GetType("System.Double"));
                dtAircraftMovementsSmoothed.Columns.Add("Nb Flights / h", System.Type.GetType("System.Double"));

                dtTransferICTSmoothed.Columns.Add("Time", System.Type.GetType("System.DateTime"));
                dtTransferICTSmoothed.Columns.Add("Nb Pax", System.Type.GetType("System.Double"));
                dtTransferICTSmoothed.Columns.Add("Nb Pax / h", System.Type.GetType("System.Double"));
                dtTransferICTSmoothed.Columns.Add("Nb Bags", System.Type.GetType("System.Double"));
                dtTransferICTSmoothed.Columns.Add("Nb Bags / h", System.Type.GetType("System.Double"));


                #region Pour la répartition suivant les parkings.
                int iIndexTerminalParking = FPATable.Columns.IndexOf(GlobalNames.sFPD_A_Column_TerminalParking);
                int iIndexParking = FPATable.Columns.IndexOf(GlobalNames.sFPD_A_Column_Parking);
                int iNbTerminal = FonctionUtiles.CountTerminalParking(FPATable);
                if ((iIndexParking == -1) || (iIndexTerminalParking == -1) || (iIndexAirline == -1))
                    iNbTerminal = 0;
                Dictionary<Int32, Dictionary<String, Double>[]> htFlightPerParking = null;
                //Hashtable htFlightPerParking = null;
                if (iNbTerminal != 0)
                {
                    htFlightPerParking = new Dictionary<Int32, Dictionary<String, Double>[]>();
                    for (i = 1; i <= iNbTerminal; i++)
                    {
                        int iNbParking = FonctionUtiles.CountParking(FPATable, i);
                        if (iNbParking == 0)
                            continue;
                        htFlightPerParking.Add(i, new Dictionary<String, Double>[iNbParking]);
                        for (j = 0; j < iNbParking; j++)
                        {
                            htFlightPerParking[i][j] = new Dictionary<String, Double>();
                        }
                    }
                }
                #endregion


                OverallTools.DataFunctions.initialiserLignes(dtPaxGateSmoothed, dtBegin, dtEnd, samplingStep);
                OverallTools.DataFunctions.initialiserLignes(paxGateSmoothedBHS, dtBegin, dtEnd, samplingStep); // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                OverallTools.DataFunctions.initialiserLignes(dtAircraftMovementsSmoothed, dtBegin, dtEnd, samplingStep);
                OverallTools.DataFunctions.initialiserLignes(dtTransferICTSmoothed, dtBegin, dtEnd, samplingStep);

                for (j = 0; j < dtPaxGateSmoothed.Rows.Count; j++)
                {
                    for (i = 1; i < dtPaxGateSmoothed.Columns.Count; i++)
                        dtPaxGateSmoothed.Rows[j][i] = 0.0d;
                    for (i = 1; i < dtAircraftMovementsSmoothed.Columns.Count; i++)
                        dtAircraftMovementsSmoothed.Rows[j][i] = 0.0d;
                    for (i = 1; i < dtTransferICTSmoothed.Columns.Count; i++)
                        dtTransferICTSmoothed.Rows[j][i] = 0.0d;
                }
                // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                for (j = 0; j < paxGateSmoothedBHS.Rows.Count; j++)
                {
                    for (i = 1; i < paxGateSmoothedBHS.Columns.Count; i++)
                        paxGateSmoothedBHS.Rows[j][i] = 0.0d;
                }
                // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                #region Les différentes ArrayList qui permettront de gérer les distributions.
                ArrayList alPaxPerFlight = new ArrayList();
                Hashtable htFlightPerFC = new Hashtable();
                Hashtable htPaxPerFC = new Hashtable();
                Hashtable htBagsPerFC = new Hashtable();

                String[] tsFlightCategoriesOrder = new String[dtFlightCategories.Rows.Count];
                #endregion

                #region Initialize the tables for the distribution.

                DataTable dtTmp = dtNbBags.Table;
                for (i = 1; i < dtTmp.Columns.Count; i++)
                {
                    String sColumnName = dtTmp.Columns[i].ColumnName;
                    htFlightPerFC.Add(sColumnName, (Double)0.0);
                    htPaxPerFC.Add(sColumnName, (Double)0.0);
                    htBagsPerFC.Add(sColumnName, (Double)0.0);

                    tsFlightCategoriesOrder[i - 1] = sColumnName;
                }
                #endregion

                /*<Stephane>*/
                bool bDoublons = PAX2SIM.bAircraftMovementPerFlight;
                bool bIgnoreFlightForAircraftMovements = false;
                Hashtable _htDoublonsFlightNumber = new Hashtable();
                int iIndexFlightNumber = FPATable.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightN);
                /*</Stephane>*/

                foreach (DataRow ligne in FPATable.Rows)
                {
                    //On récupère l'identifiant du vol.
                    String iIdentifiantVol = ligne.ItemArray[iIndexID].ToString();
                    ///On regarde le nombre de passagers pour le vol.

                    // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                    //double nombrePassagers = OverallTools.DataFunctions.numberOfPassengers(ligne, etAircraftType, dtFlightCategories, etLoadFactors, ListeErreurs);
                    double nombrePassagers = OverallTools.DataFunctions.getNbPaxForFlight(ligne, etAircraftType, dtFlightCategories, etLoadFactors,
                        FlightAttribute.ARR_OR_DEP_FLIGHT_TAG.A, Convert.ToInt32(iIdentifiantVol), userDefinedFlightConfigurations, ListeErreurs);

                    if (nombrePassagers == -1)
                    {
                        ListeErreurs.Add("Warn00458 : Line ignored \"" + iIdentifiantVol + "\". The number of passenger for that fligt is not valid.");
                        continue;
                    }
                    String FlightCateg = ligne.ItemArray[iIndexFC].ToString();
                    String sAirline = ligne.ItemArray[iIndexAirline].ToString();

                    DateTime dateArrivee = DataFunctions.toDateTime(ligne.ItemArray[iIndexDate], ligne.ItemArray[iIndexTime]);


                    int iIndexICTColumnEco;
                    //int iIndexColumnFirst;
                    DataTable dtICTEco = etICTTable.GetInformationsColumns(0, "A_" + iIdentifiantVol, sAirline, FlightCateg, out iIndexICTColumnEco);

                    if (/*(iIndexColumnFirst == -1) ||*/ (iIndexICTColumnEco == -1))
                    //if (!htShowUp.ContainsKey(FlightCateg))
                    {
                        continue;
                    }
                    int iIndexFirst, iIndexLast;
                    GetFirstAndLastValuesRow(dtICTEco, iIndexICTColumnEco, out iIndexFirst, out iIndexLast);
                    if (iIndexFirst == -1)
                        continue;

                    Double dFirstPassengerTime = (int)dtICTEco.Rows[iIndexFirst][0];
                    Double dLastPassengerTime = (int)dtICTEco.Rows[iIndexLast][1];


                    if ((dateArrivee > dtEnd) || (dateArrivee.AddMinutes(dFirstPassengerTime) < dtBegin))
                    {
                        ListeErreurs.Add("Warn00459 : Line ignored \"" + iIdentifiantVol + "\". The arriving time don't match the range.");
                        continue;
                    }
                    /*<Stephane>*/
                    if (bDoublons)
                    {
                        bIgnoreFlightForAircraftMovements = false;
                        if (!_htDoublonsFlightNumber.ContainsKey(dateArrivee))
                        {
                            _htDoublonsFlightNumber.Add(dateArrivee, new ArrayList());
                        }
                        if (((ArrayList)_htDoublonsFlightNumber[dateArrivee]).Contains(ligne[iIndexFlightNumber].ToString()))
                            bIgnoreFlightForAircraftMovements = true;
                        else
                            ((ArrayList)_htDoublonsFlightNumber[dateArrivee]).Add(ligne[iIndexFlightNumber].ToString());

                    }
                    /*</Stephane>*/
                    #region We determine the number of passengers for that flight
                    Dictionary<String, String> dssLoadFactors = etLoadFactors.GetInformationsColumns(0, "A_" + iIdentifiantVol, sAirline, FlightCateg);


                    String sTransferring = dssLoadFactors[GlobalNames.sLFD_A_Line_Transferring];//DataFunctions.getValue(dtLoadFactors, GlobalNames.sLFD_A_Line_Transferring, 0, dtLoadFactors.Columns.IndexOf(FlightCateg));
                    if (sTransferring == null)
                    {
                        ListeErreurs.Add("Err00460 : The arrival load factor table have problems");
                        return null;
                    }
                    Double dTransferring;
                    if (!Double.TryParse(sTransferring, out dTransferring))
                    {
                        ListeErreurs.Add("Err00461 : The arrival load factor value is not valid for the flight category :\"" + FlightCateg + "\".");
                        return null;
                    }

                    // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                    //Double dTransferPassenger = (nombrePassagers * dTransferring) / 100.0f;
                    double dTransferPassenger = -1;
                    double dTerminatingPassengers = -1;
                    FlightConfiguration flightConfiguration = Tools.FlightPlanParametersTools.getFlightConfigurationByArrOrDepAndFlightId(FlightAttribute.ARR_OR_DEP_FLIGHT_TAG.A,
                        Convert.ToInt32(iIdentifiantVol), userDefinedFlightConfigurations);
                    if (flightConfiguration != null)
                    {
                        dTransferPassenger = flightConfiguration.flightParameter.nbTransferEcoPax + flightConfiguration.flightParameter.nbTransferFbPax;
                        dTerminatingPassengers = flightConfiguration.flightParameter.nbTermEcoPax + flightConfiguration.flightParameter.nbTermFbPax;
                    }
                    else
                    {
                        dTransferPassenger = dTransferPassenger = (nombrePassagers * dTransferring) / 100.0f;
                    }


                    // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                    if (bUseDefinedNbPax)
                    {
                        Double definedTransferPaxNb = -1;
                        Double definedTerminatingPaxNb = -1;

                        if (Double.TryParse(dtNumberOfPassengers.Rows[0][arrivalTransferringPaxDefinedNbColumnIndex].ToString(), out definedTransferPaxNb)
                            && Double.TryParse(dtNumberOfPassengers.Rows[0][arrivalTerminatingPaxDefinedNbColumnIndex].ToString(), out definedTerminatingPaxNb))
                        {
                            dTransferPassenger = definedTransferPaxNb;
                            nombrePassagers = definedTerminatingPaxNb + definedTransferPaxNb;
                        }
                    }
                    // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                    #endregion

                    if (iNbTerminal > 0)
                    {
                        int iTerminalParking;
                        if (Int32.TryParse(ligne[iIndexTerminalParking].ToString(), out iTerminalParking))
                            iTerminalParking = 0;
                        if (htFlightPerParking.ContainsKey(iTerminalParking))
                        {
                            int iParking;
                            if (Int32.TryParse(ligne[iIndexParking].ToString(), out iParking))
                                iParking = 0;
                            if ((iParking != 0) && (htFlightPerParking[iTerminalParking].Length >= iParking))
                            {
                                String sAirLine = ligne[iIndexAirline].ToString();
                                if (!htFlightPerParking[iTerminalParking][iParking - 1].ContainsKey(sAirLine))
                                    htFlightPerParking[iTerminalParking][iParking - 1].Add(sAirLine, (Double)0);
                                htFlightPerParking[iTerminalParking][iParking - 1][sAirLine] = (Double)htFlightPerParking[iTerminalParking][iParking - 1][sAirLine] + 1;
                            }
                        }
                    }

                    int iColumn, iColumnTrolley;

                    DataTable dtTable = etNbVisitors.GetInformationsColumns(0, "A_" + iIdentifiantVol, sAirline, FlightCateg, out iColumn);
                    if (dtTable == null)
                        continue;
                    Double dMeanVisitors = CalculCoefficientMultiplicateur(dtTable, iColumn);

                    dtTable = etNbBags.GetInformationsColumns(0, "A_" + iIdentifiantVol, sAirline, FlightCateg, out iColumn);
                    if (dtTable == null)
                        continue;



                    // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                    //Double dMeanBaggage = CalculCoefficientMultiplicateur(dtTable, iColumn);
                    Double dMeanBaggage = -1;
                    double dMeanTerminatingBaggage = -1;
                    double dMeanTransferringBaggage = -1;
                    double dMeanTotalBaggage = -1;
                    if (flightConfiguration != null)
                    {
                        double totalNbTermPax = flightConfiguration.flightParameter.nbTermEcoPax + flightConfiguration.flightParameter.nbTermFbPax;
                        double totalNbTermBags = flightConfiguration.flightParameter.nbTermEcoBags + flightConfiguration.flightParameter.nbTermFbBags;

                        double totalNbTransferPax = flightConfiguration.flightParameter.nbTransferEcoPax + flightConfiguration.flightParameter.nbTransferFbPax;
                        double totalNbTransferBags = flightConfiguration.flightParameter.nbTransferEcoBags + flightConfiguration.flightParameter.nbTransferFbBags;

                        if (nombrePassagers == 0)
                        {
                            dMeanTotalBaggage = 0;
                        }
                        else
                        {
                            dMeanTotalBaggage = (totalNbTermBags + totalNbTransferBags) / nombrePassagers;
                        }
                        if (totalNbTermPax == 0)
                        {
                            dMeanTerminatingBaggage = 0;
                        }
                        else
                        {
                            dMeanTerminatingBaggage = totalNbTermBags / totalNbTermPax;
                        }
                        if (totalNbTransferPax == 0)
                        {
                            dMeanTransferringBaggage = 0;
                        }
                        else
                        {
                            dMeanTransferringBaggage = totalNbTransferBags / totalNbTransferPax;
                        }
                    }
                    else
                    {
                        dMeanBaggage = CalculCoefficientMultiplicateur(dtTable, iColumn);
                    }

                    // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)                    
                    if (bUseDefinedNbBags)
                    {
                        if (dTransferPassenger == 0)
                            dMeanTransferringBaggage = 0;
                        else
                            dMeanTransferringBaggage = definedTransferringNbBags / dTransferPassenger;

                        if (nombrePassagers - dTransferPassenger == 0)
                            dMeanTerminatingBaggage = 0;
                        else
                            dMeanTerminatingBaggage = definedTerminatingNbBags / (nombrePassagers - dTransferPassenger);

                        if (nombrePassagers == 0)
                            dMeanTotalBaggage = 0;
                        else
                            dMeanTotalBaggage = (definedTerminatingNbBags + definedTransferringNbBags) / nombrePassagers;
                    }
                    // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)

                    DataTable dtTableTrolley = etNbTrolley.GetInformationsColumns(0, "A_" + iIdentifiantVol, sAirline, FlightCateg, out iColumnTrolley);
                    if (dtTable == null)
                        continue;
                    Double dMeanTrolley = CalculCoefficientMultiplicateurTrolley(dtTableTrolley, dtTable, iColumnTrolley, iColumn);



                    htPaxPerFC[FlightCateg] = (Double)htPaxPerFC[FlightCateg] + nombrePassagers;
                    // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                    if (bUseDefinedNbBags)
                        htBagsPerFC[FlightCateg] = (Double)htBagsPerFC[FlightCateg] + nombrePassagers * dMeanTotalBaggage;
                    else
                    {
                        if (dMeanBaggage != -1)
                        {
                            htBagsPerFC[FlightCateg] = (Double)htBagsPerFC[FlightCateg] + nombrePassagers * dMeanBaggage;
                        }
                        else if (dMeanTotalBaggage != -1)
                        {
                            htBagsPerFC[FlightCateg] = (Double)htBagsPerFC[FlightCateg] + nombrePassagers * dMeanTotalBaggage;
                        }
                    }
                    // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)                    

                    alPaxPerFlight.Add(nombrePassagers);

                    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    int loadingRatePerMinute = -1;//12;
                    int loadingDelay = -1;//20;


                    if (bagLoadingRateExceptionTable != null)
                    {
                        int exceptionColumn;
                        DataTable table = bagLoadingRateExceptionTable
                                            .GetInformationsColumns(0, "A_" + iIdentifiantVol, sAirline, FlightCateg, out exceptionColumn);
                        if (table != null)
                        {
                            Double resultedValue = CalculCoefficientMultiplicateur(table, exceptionColumn);
                            loadingRatePerMinute = (int)resultedValue;
                        }
                    }

                    if (bagLoadingDelayExceptionTable != null)
                    {
                        int exceptionColumn;
                        DataTable table = bagLoadingDelayExceptionTable
                                            .GetInformationsColumns(0, "A_" + iIdentifiantVol, sAirline, FlightCateg, out exceptionColumn);
                        if (table != null)
                        {
                            Double resultedValue = CalculCoefficientMultiplicateur(table, exceptionColumn);
                            loadingDelay = (int)resultedValue;
                        }
                    }

                    int nbBagsLoadedPerSampleStep = loadingRatePerMinute * (int)samplingStep;
                    int nbOfTotalIntervalsAffectedByBaggLoading = 1;
                    int nbOfTerminatingIntervalsAffectedByBaggLoading = 1;
                    int nbOfTransferingIntervalsAffectedByBaggLoading = 1;
                    if (nbBagsLoadedPerSampleStep > 0)
                    {
                        if (bUseDefinedNbBags)      // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                            nbOfTotalIntervalsAffectedByBaggLoading = (int)((nombrePassagers * dMeanTotalBaggage) / nbBagsLoadedPerSampleStep);
                        else
                        {
                            if (dMeanBaggage != -1)
                            {
                                nbOfTotalIntervalsAffectedByBaggLoading = (int)((nombrePassagers * dMeanBaggage) / nbBagsLoadedPerSampleStep);
                            }
                            else if (dMeanTotalBaggage != -1)
                            {
                                nbOfTotalIntervalsAffectedByBaggLoading = (int)((nombrePassagers * dMeanTotalBaggage) / nbBagsLoadedPerSampleStep);
                            }
                        }

                        if (bUseDefinedNbBags)      // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                            nbOfTerminatingIntervalsAffectedByBaggLoading = (int)(((nombrePassagers - dTransferPassenger) * dMeanTerminatingBaggage) / nbBagsLoadedPerSampleStep);
                        else
                        {
                            if (dMeanBaggage != -1)
                            {
                                nbOfTerminatingIntervalsAffectedByBaggLoading = (int)(((nombrePassagers - dTransferPassenger) * dMeanBaggage) / nbBagsLoadedPerSampleStep);
                            }
                            else if (dMeanTerminatingBaggage != -1 && dTerminatingPassengers != -1)
                            {
                                nbOfTerminatingIntervalsAffectedByBaggLoading = (int)((dTerminatingPassengers * dMeanTerminatingBaggage) / nbBagsLoadedPerSampleStep);
                            }
                        }

                        if (bUseDefinedNbBags)      // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                            nbOfTransferingIntervalsAffectedByBaggLoading = (int)((dTransferPassenger * dMeanTransferringBaggage) / nbBagsLoadedPerSampleStep);
                        else
                        {
                            if (dMeanBaggage != -1)
                            {
                                nbOfTransferingIntervalsAffectedByBaggLoading = (int)((dTransferPassenger * dMeanBaggage) / nbBagsLoadedPerSampleStep);
                            }
                            else if (dMeanTransferringBaggage != -1 && dTransferPassenger != -1)
                            {
                                nbOfTransferingIntervalsAffectedByBaggLoading = (int)((dTransferPassenger * dMeanTransferringBaggage) / nbBagsLoadedPerSampleStep);
                            }
                        }
                    }
                    double nbOfTotalBagsLoadedForLastInterval = 0;
                    double nbOfTerminatingBagsLoadedForLastInterval = 0;
                    double nbOfTransferingBagsLoadedForLastInterval = 0;
                    if (nbBagsLoadedPerSampleStep > 0)
                    {
                        if (bUseDefinedNbBags)      // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                            nbOfTotalBagsLoadedForLastInterval = (nombrePassagers * dMeanTotalBaggage) % nbBagsLoadedPerSampleStep;
                        else
                        {
                            if (dMeanBaggage != -1)
                            {
                                nbOfTotalBagsLoadedForLastInterval = (nombrePassagers * dMeanBaggage) % nbBagsLoadedPerSampleStep;
                            }
                            else if (dMeanTotalBaggage != -1)
                            {
                                nbOfTotalBagsLoadedForLastInterval = (nombrePassagers * dMeanTotalBaggage) % nbBagsLoadedPerSampleStep;
                            }
                        }

                        if (bUseDefinedNbBags)      // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                            nbOfTerminatingBagsLoadedForLastInterval = ((nombrePassagers - dTransferPassenger) * dMeanTerminatingBaggage) % nbBagsLoadedPerSampleStep;
                        else
                        {
                            if (dMeanBaggage != -1)
                            {
                                nbOfTerminatingBagsLoadedForLastInterval = ((nombrePassagers - dTransferPassenger) * dMeanBaggage) % nbBagsLoadedPerSampleStep;
                            }
                            else if (dMeanTerminatingBaggage != -1 && dTerminatingPassengers != -1)
                            {
                                nbOfTerminatingBagsLoadedForLastInterval = (dTerminatingPassengers * dMeanTerminatingBaggage) % nbBagsLoadedPerSampleStep;
                            }
                        }

                        if (bUseDefinedNbBags)      // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                            nbOfTransferingBagsLoadedForLastInterval = (dTransferPassenger * dMeanTransferringBaggage) % nbBagsLoadedPerSampleStep;
                        else
                        {
                            if (dMeanBaggage != -1)
                            {
                                nbOfTransferingBagsLoadedForLastInterval = (dTransferPassenger * dMeanBaggage) % nbBagsLoadedPerSampleStep;
                            }
                            else if (dMeanTransferringBaggage != -1 && dTransferPassenger != -1)
                            {
                                nbOfTransferingBagsLoadedForLastInterval = (dTransferPassenger * dMeanTransferringBaggage) % nbBagsLoadedPerSampleStep;
                            }
                        }
                    }
                    //add the last interval if we have remaining bags
                    if (nbOfTotalBagsLoadedForLastInterval > 0)
                        nbOfTotalIntervalsAffectedByBaggLoading++;
                    if (nbOfTerminatingBagsLoadedForLastInterval > 0)
                        nbOfTerminatingIntervalsAffectedByBaggLoading++;
                    if (nbOfTransferingBagsLoadedForLastInterval > 0)
                        nbOfTransferingIntervalsAffectedByBaggLoading++;
                    // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                    //Calcul de la courbe de présentation des passagers.
                    //Il faut dans un premier temps limité l'interval à calculer.

                    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant          
                    //int iHeureDebut = DataFunctions.heureDebut(dtPaxGateSmoothed, dateArrivee.AddMinutes(loadingDelay));                    
                    // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    int iHeureDebut = DataFunctions.heureDebut(dtPaxGateSmoothed, dateArrivee);
                    if (iHeureDebut != -1)
                    {
                        //================================>dTransferPassengers
                        htFlightPerFC[FlightCateg] = (Double)htFlightPerFC[FlightCateg] + 1;
                        // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant 

                        // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns                        
                        dtPaxGateSmoothed.Rows[iHeureDebut][1] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][1]) + nombrePassagers;
                        dtPaxGateSmoothed.Rows[iHeureDebut][2] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][2]) + nombrePassagers;
                        if (dTerminatingPassengers != -1)
                        {
                            dtPaxGateSmoothed.Rows[iHeureDebut][3] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][3]) + dTerminatingPassengers;
                            dtPaxGateSmoothed.Rows[iHeureDebut][4] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][4]) + dTerminatingPassengers;
                        }
                        else
                        {
                            dtPaxGateSmoothed.Rows[iHeureDebut][3] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][3]) + nombrePassagers - dTransferPassenger;
                            dtPaxGateSmoothed.Rows[iHeureDebut][4] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][4]) + nombrePassagers - dTransferPassenger;
                        }
                        dtPaxGateSmoothed.Rows[iHeureDebut][5] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][5]) + dTransferPassenger;
                        dtPaxGateSmoothed.Rows[iHeureDebut][6] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][6]) + dTransferPassenger;

                        if (bUseDefinedNbBags)  // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                        {
                            dtPaxGateSmoothed.Rows[iHeureDebut][7] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][7]) + nombrePassagers * dMeanTotalBaggage;
                            dtPaxGateSmoothed.Rows[iHeureDebut][8] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][8]) + nombrePassagers * dMeanTotalBaggage;
                            dtPaxGateSmoothed.Rows[iHeureDebut][9] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][9]) + (nombrePassagers - dTransferPassenger) * dMeanTerminatingBaggage;
                            dtPaxGateSmoothed.Rows[iHeureDebut][10] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][10]) + (nombrePassagers - dTransferPassenger) * dMeanTerminatingBaggage;
                            dtPaxGateSmoothed.Rows[iHeureDebut][11] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][11]) + dTransferPassenger * dMeanTransferringBaggage;
                            dtPaxGateSmoothed.Rows[iHeureDebut][12] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][12]) + dTransferPassenger * dMeanTransferringBaggage;
                        }
                        else
                        {
                            if (dMeanBaggage != -1)
                            {
                                dtPaxGateSmoothed.Rows[iHeureDebut][7] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][7]) + nombrePassagers * dMeanBaggage;
                                dtPaxGateSmoothed.Rows[iHeureDebut][8] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][8]) + nombrePassagers * dMeanBaggage;
                                dtPaxGateSmoothed.Rows[iHeureDebut][9] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][9]) + (nombrePassagers - dTransferPassenger) * dMeanBaggage;
                                dtPaxGateSmoothed.Rows[iHeureDebut][10] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][10]) + (nombrePassagers - dTransferPassenger) * dMeanBaggage;
                                dtPaxGateSmoothed.Rows[iHeureDebut][11] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][11]) + dTransferPassenger * dMeanBaggage;
                                dtPaxGateSmoothed.Rows[iHeureDebut][12] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][12]) + dTransferPassenger * dMeanBaggage;
                            }
                            else if (dMeanTotalBaggage != -1 && dMeanTerminatingBaggage != -1 && dMeanTransferringBaggage != -1 && dTerminatingPassengers != -1)
                            {
                                dtPaxGateSmoothed.Rows[iHeureDebut][7] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][7]) + nombrePassagers * dMeanTotalBaggage;
                                dtPaxGateSmoothed.Rows[iHeureDebut][8] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][8]) + nombrePassagers * dMeanTotalBaggage;
                                dtPaxGateSmoothed.Rows[iHeureDebut][9] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][9]) + dTerminatingPassengers * dMeanTerminatingBaggage;
                                dtPaxGateSmoothed.Rows[iHeureDebut][10] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][10]) + dTerminatingPassengers * dMeanTerminatingBaggage;
                                dtPaxGateSmoothed.Rows[iHeureDebut][11] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][11]) + dTransferPassenger * dMeanTransferringBaggage;
                                dtPaxGateSmoothed.Rows[iHeureDebut][12] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][12]) + dTransferPassenger * dMeanTransferringBaggage;
                            }
                        }
                        if (dTerminatingPassengers != -1)
                        {
                            dtPaxGateSmoothed.Rows[iHeureDebut][13] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][13]) + dTerminatingPassengers * dMeanVisitors;
                            dtPaxGateSmoothed.Rows[iHeureDebut][14] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][14]) + dTerminatingPassengers * dMeanVisitors;
                            dtPaxGateSmoothed.Rows[iHeureDebut][15] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][15]) + dTerminatingPassengers * dMeanTrolley;
                            dtPaxGateSmoothed.Rows[iHeureDebut][16] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][16]) + dTerminatingPassengers * dMeanTrolley;
                        }
                        else
                        {
                            dtPaxGateSmoothed.Rows[iHeureDebut][13] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][13]) + (nombrePassagers - dTransferPassenger) * dMeanVisitors;
                            dtPaxGateSmoothed.Rows[iHeureDebut][14] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][14]) + (nombrePassagers - dTransferPassenger) * dMeanVisitors;
                            dtPaxGateSmoothed.Rows[iHeureDebut][15] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][15]) + (nombrePassagers - dTransferPassenger) * dMeanTrolley;
                            dtPaxGateSmoothed.Rows[iHeureDebut][16] = ((Double)dtPaxGateSmoothed.Rows[iHeureDebut][16]) + (nombrePassagers - dTransferPassenger) * dMeanTrolley;
                        }
                        // >> Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                        // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                        if (!bIgnoreFlightForAircraftMovements)
                            dtAircraftMovementsSmoothed.Rows[iHeureDebut][1] = ((Double)dtAircraftMovementsSmoothed.Rows[iHeureDebut][1]) + 1;
                    }

                    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant                    
                    #region Generate paxGateSmoothedBHS table
                    /* This is the actual nb of bags that will be loaded in the last interval:
                     *  if we have an exact division (nbOfTotalBagsLoadedForLastInterval = 0) than the last interval has a full load
                     *  otherwise we will load what's left (nbOfTotalBagsLoadedForLastInterval that is > 0)
                     *  ex: 20 bags / 5 intervals => 5bags per interval and a remaining of 0. */
                    double realNbBagsForLastInterval = 0;

                    int startTimeForBags = iHeureDebut;
                    if (loadingDelay != -1 && iHeureDebut != -1)
                        startTimeForBags = DataFunctions.heureDebut(dtPaxGateSmoothed, dateArrivee.AddMinutes(loadingDelay));

                    if (iHeureDebut != -1 && startTimeForBags != -1)
                    {
                        if (bUseDefinedNbBags)
                        {
                            paxGateSmoothedBHS.Rows[iHeureDebut][1] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][1]) + nombrePassagers * dMeanTotalBaggage;
                            paxGateSmoothedBHS.Rows[iHeureDebut][2] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][2]) + nombrePassagers * dMeanTotalBaggage;
                            paxGateSmoothedBHS.Rows[iHeureDebut][3] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][3]) + (nombrePassagers - dTransferPassenger) * dMeanTerminatingBaggage;
                            paxGateSmoothedBHS.Rows[iHeureDebut][4] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][4]) + (nombrePassagers - dTransferPassenger) * dMeanTerminatingBaggage;
                            paxGateSmoothedBHS.Rows[iHeureDebut][5] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][5]) + dTransferPassenger * dMeanTransferringBaggage;
                            paxGateSmoothedBHS.Rows[iHeureDebut][6] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][6]) + dTransferPassenger * dMeanTransferringBaggage;
                        }
                        else
                        {
                            if (dMeanBaggage != -1)
                            {
                                paxGateSmoothedBHS.Rows[iHeureDebut][1] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][1]) + nombrePassagers * dMeanBaggage;
                                paxGateSmoothedBHS.Rows[iHeureDebut][2] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][2]) + nombrePassagers * dMeanBaggage;
                                paxGateSmoothedBHS.Rows[iHeureDebut][3] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][3]) + (nombrePassagers - dTransferPassenger) * dMeanBaggage;
                                paxGateSmoothedBHS.Rows[iHeureDebut][4] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][4]) + (nombrePassagers - dTransferPassenger) * dMeanBaggage;
                                paxGateSmoothedBHS.Rows[iHeureDebut][5] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][5]) + dTransferPassenger * dMeanBaggage;
                                paxGateSmoothedBHS.Rows[iHeureDebut][6] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][6]) + dTransferPassenger * dMeanBaggage;
                            }
                            else if (dMeanTotalBaggage != -1 && dMeanTerminatingBaggage != -1 && dMeanTransferringBaggage != -1 && dTerminatingPassengers != -1)
                            {
                                paxGateSmoothedBHS.Rows[iHeureDebut][1] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][1]) + nombrePassagers * dMeanTotalBaggage;
                                paxGateSmoothedBHS.Rows[iHeureDebut][2] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][2]) + nombrePassagers * dMeanTotalBaggage;
                                paxGateSmoothedBHS.Rows[iHeureDebut][3] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][3]) + dTerminatingPassengers * dMeanTerminatingBaggage;
                                paxGateSmoothedBHS.Rows[iHeureDebut][4] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][4]) + dTerminatingPassengers * dMeanTerminatingBaggage;
                                paxGateSmoothedBHS.Rows[iHeureDebut][5] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][5]) + dTransferPassenger * dMeanTransferringBaggage;
                                paxGateSmoothedBHS.Rows[iHeureDebut][6] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][6]) + dTransferPassenger * dMeanTransferringBaggage;
                            }
                        }

                        if (loadingDelay != -1 && loadingRatePerMinute != -1)
                        {
                            for (int k = 0; k < nbOfTotalIntervalsAffectedByBaggLoading; k++)
                            {
                                if (k < nbOfTotalIntervalsAffectedByBaggLoading - 1)
                                {
                                    if (startTimeForBags + k < paxGateSmoothedBHS.Rows.Count)
                                    {
                                        paxGateSmoothedBHS.Rows[startTimeForBags + k][7] = ((Double)paxGateSmoothedBHS.Rows[startTimeForBags + k][7]) + nbBagsLoadedPerSampleStep;//nombrePassagers * dMeanBaggage;
                                        paxGateSmoothedBHS.Rows[startTimeForBags + k][8] = ((Double)paxGateSmoothedBHS.Rows[startTimeForBags + k][8]) + nbBagsLoadedPerSampleStep;//nombrePassagers * dMeanBaggage;
                                    }
                                    else
                                    {
                                        paxGateSmoothedBHS.Rows[startTimeForBags + (k - 1)][7] = ((Double)paxGateSmoothedBHS.Rows[startTimeForBags + (k - 1)][7])
                                                                                        + (nbOfTotalIntervalsAffectedByBaggLoading - k) * nbBagsLoadedPerSampleStep + nbOfTotalBagsLoadedForLastInterval;//nombrePassagers * dMeanBaggage;
                                        paxGateSmoothedBHS.Rows[startTimeForBags + (k - 1)][8] = ((Double)paxGateSmoothedBHS.Rows[startTimeForBags + (k - 1)][8])
                                                                                        + (nbOfTotalIntervalsAffectedByBaggLoading - k) * nbBagsLoadedPerSampleStep + nbOfTotalBagsLoadedForLastInterval;//nombrePassagers * dMeanBaggage;
                                        break;
                                    }
                                }
                                else if (k == nbOfTotalIntervalsAffectedByBaggLoading - 1) //we are in the last interval
                                {
                                    /*this is the actual nb of bags that will be loaded in the last interval:
                                     *  if we have an exact division (nbOfTotalBagsLoadedForLastInterval = 0) than the last interval has a full load
                                     *  otherwise we will load what's left (nbOfTotalBagsLoadedForLastInterval that is > 0)
                                     *  ex: 20 bags / 5 intervals => 5bags per interval and a remaining of 0.
                                     */
                                    if (nbOfTotalBagsLoadedForLastInterval == 0)
                                        realNbBagsForLastInterval = nbBagsLoadedPerSampleStep;
                                    else
                                        realNbBagsForLastInterval = nbOfTotalBagsLoadedForLastInterval;

                                    if (startTimeForBags + k < paxGateSmoothedBHS.Rows.Count)
                                    {
                                        paxGateSmoothedBHS.Rows[startTimeForBags + k][7] = ((Double)paxGateSmoothedBHS.Rows[startTimeForBags + k][7]) + realNbBagsForLastInterval;//nombrePassagers * dMeanBaggage;
                                        paxGateSmoothedBHS.Rows[startTimeForBags + k][8] = ((Double)paxGateSmoothedBHS.Rows[startTimeForBags + k][8]) + realNbBagsForLastInterval;//nombrePassagers * dMeanBaggage;
                                    }
                                    else
                                    {
                                        paxGateSmoothedBHS.Rows[startTimeForBags + (k - 1)][7] = ((Double)paxGateSmoothedBHS.Rows[startTimeForBags + (k - 1)][7])
                                            + realNbBagsForLastInterval;//nombrePassagers * dMeanBaggage;
                                        paxGateSmoothedBHS.Rows[startTimeForBags + (k - 1)][8] = ((Double)paxGateSmoothedBHS.Rows[startTimeForBags + (k - 1)][8])
                                            + realNbBagsForLastInterval;//nombrePassagers * dMeanBaggage;                                
                                    }
                                }
                            }
                            for (int k = 0; k < nbOfTerminatingIntervalsAffectedByBaggLoading; k++)
                            {

                                if (k < nbOfTerminatingIntervalsAffectedByBaggLoading - 1)
                                {
                                    if (startTimeForBags + k < paxGateSmoothedBHS.Rows.Count)
                                    {
                                        paxGateSmoothedBHS.Rows[startTimeForBags + k][9] = ((Double)paxGateSmoothedBHS.Rows[startTimeForBags + k][9]) + nbBagsLoadedPerSampleStep;//(nombrePassagers - dTransferPassengers) * dMeanBaggage;
                                        paxGateSmoothedBHS.Rows[startTimeForBags + k][10] = ((Double)paxGateSmoothedBHS.Rows[startTimeForBags + k][10]) + nbBagsLoadedPerSampleStep;//(nombrePassagers - dTransferPassengers) * dMeanBaggage;
                                    }
                                    else
                                    {
                                        paxGateSmoothedBHS.Rows[startTimeForBags + (k - 1)][9] = ((Double)paxGateSmoothedBHS.Rows[startTimeForBags + (k - 1)][9])
                                                                                        + (nbOfTerminatingIntervalsAffectedByBaggLoading - k) * nbBagsLoadedPerSampleStep + nbOfTerminatingBagsLoadedForLastInterval;//nombrePassagers * dMeanBaggage;
                                        paxGateSmoothedBHS.Rows[startTimeForBags + (k - 1)][10] = ((Double)paxGateSmoothedBHS.Rows[startTimeForBags + (k - 1)][10])
                                                                                        + (nbOfTerminatingIntervalsAffectedByBaggLoading - k) * nbBagsLoadedPerSampleStep + nbOfTerminatingBagsLoadedForLastInterval;//nombrePassagers * dMeanBaggage;
                                        break;
                                    }
                                }
                                else if (k == nbOfTerminatingIntervalsAffectedByBaggLoading - 1)  //we are in the last interval
                                {
                                    /*this is the actual nb of bags that will be loaded in the last interval:
                                     *  if we have an exact division (nbOfTotalBagsLoadedForLastInterval = 0) than the last interval has a full load
                                     *  otherwise we will load what's left (nbOfTotalBagsLoadedForLastInterval that is > 0)
                                     *  ex: 20 bags / 5 intervals => 5bags per interval and a remaining of 0.
                                     */
                                    if (nbOfTerminatingBagsLoadedForLastInterval == 0)
                                        realNbBagsForLastInterval = nbBagsLoadedPerSampleStep;
                                    else
                                        realNbBagsForLastInterval = nbOfTerminatingBagsLoadedForLastInterval;

                                    if (startTimeForBags + k < paxGateSmoothedBHS.Rows.Count)
                                    {
                                        paxGateSmoothedBHS.Rows[startTimeForBags + k][9] = ((Double)paxGateSmoothedBHS.Rows[startTimeForBags + k][9]) + realNbBagsForLastInterval;//(nombrePassagers - dTransferPassengers) * dMeanBaggage;
                                        paxGateSmoothedBHS.Rows[startTimeForBags + k][10] = ((Double)paxGateSmoothedBHS.Rows[startTimeForBags + k][10]) + realNbBagsForLastInterval;//(nombrePassagers - dTransferPassengers) * dMeanBaggage;
                                    }
                                    else
                                    {
                                        paxGateSmoothedBHS.Rows[startTimeForBags + (k - 1)][10] = ((Double)paxGateSmoothedBHS.Rows[startTimeForBags + (k - 1)][10])
                                            + realNbBagsForLastInterval;
                                        paxGateSmoothedBHS.Rows[startTimeForBags + (k - 1)][10] = ((Double)paxGateSmoothedBHS.Rows[startTimeForBags + (k - 1)][10])
                                            + realNbBagsForLastInterval;
                                    }
                                }
                            }
                            for (int k = 0; k < nbOfTransferingIntervalsAffectedByBaggLoading; k++)
                            {
                                if (k < nbOfTransferingIntervalsAffectedByBaggLoading - 1)
                                {
                                    if (startTimeForBags + k < paxGateSmoothedBHS.Rows.Count)
                                    {
                                        paxGateSmoothedBHS.Rows[startTimeForBags + k][11] = ((Double)paxGateSmoothedBHS.Rows[startTimeForBags + k][11]) + nbBagsLoadedPerSampleStep;//dTransferPassengers * dMeanBaggage;
                                        paxGateSmoothedBHS.Rows[startTimeForBags + k][12] = ((Double)paxGateSmoothedBHS.Rows[startTimeForBags + k][12]) + nbBagsLoadedPerSampleStep;//dTransferPassengers * dMeanBaggage;
                                    }
                                    else
                                    {
                                        paxGateSmoothedBHS.Rows[startTimeForBags + (k - 1)][11] = ((Double)paxGateSmoothedBHS.Rows[startTimeForBags + (k - 1)][11])
                                                                                        + (nbOfTransferingIntervalsAffectedByBaggLoading - k) * nbBagsLoadedPerSampleStep + nbOfTransferingBagsLoadedForLastInterval;//nombrePassagers * dMeanBaggage;
                                        paxGateSmoothedBHS.Rows[startTimeForBags + (k - 1)][12] = ((Double)paxGateSmoothedBHS.Rows[startTimeForBags + (k - 1)][12])
                                                                                        + (nbOfTransferingIntervalsAffectedByBaggLoading - k) * nbBagsLoadedPerSampleStep + nbOfTransferingBagsLoadedForLastInterval;//nombrePassagers * dMeanBaggage;
                                        break;
                                    }

                                }
                                else if (k == nbOfTransferingIntervalsAffectedByBaggLoading - 1) //we are in the last interval
                                {
                                    /*this is the actual nb of bags that will be loaded in the last interval:
                                     *  if we have an exact division (nbOfTotalBagsLoadedForLastInterval = 0) than the last interval has a full load
                                     *  otherwise we will load what's left (nbOfTotalBagsLoadedForLastInterval that is > 0)
                                     *  ex: 20 bags / 5 intervals => 5bags per interval and a remaining of 0.
                                     */
                                    if (nbOfTransferingBagsLoadedForLastInterval == 0)
                                        realNbBagsForLastInterval = nbBagsLoadedPerSampleStep;
                                    else
                                        realNbBagsForLastInterval = nbOfTransferingBagsLoadedForLastInterval;

                                    if (startTimeForBags + k < paxGateSmoothedBHS.Rows.Count)
                                    {
                                        paxGateSmoothedBHS.Rows[startTimeForBags + k][11] = ((Double)paxGateSmoothedBHS.Rows[startTimeForBags + k][11]) + realNbBagsForLastInterval;//dTransferPassengers * dMeanBaggage;
                                        paxGateSmoothedBHS.Rows[startTimeForBags + k][12] = ((Double)paxGateSmoothedBHS.Rows[startTimeForBags + k][12]) + realNbBagsForLastInterval;//dTransferPassengers * dMeanBaggage;
                                    }
                                    else
                                    {
                                        paxGateSmoothedBHS.Rows[startTimeForBags + (k - 1)][11] = ((Double)paxGateSmoothedBHS.Rows[startTimeForBags + (k - 1)][11])
                                                                                            + realNbBagsForLastInterval;
                                        paxGateSmoothedBHS.Rows[startTimeForBags + (k - 1)][12] = ((Double)paxGateSmoothedBHS.Rows[startTimeForBags + (k - 1)][12])
                                                                                            + realNbBagsForLastInterval;
                                    }
                                }
                            }
                        }
                        else
                        {
                            //if we can't calculate loading rate or delay time we get the normal statistics
                            if (bUseDefinedNbBags)  // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                            {
                                paxGateSmoothedBHS.Rows[iHeureDebut][7] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][7]) + nombrePassagers * dMeanTotalBaggage;
                                paxGateSmoothedBHS.Rows[iHeureDebut][8] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][8]) + nombrePassagers * dMeanTotalBaggage;
                                paxGateSmoothedBHS.Rows[iHeureDebut][9] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][9]) + (nombrePassagers - dTransferPassenger) * dMeanTerminatingBaggage;
                                paxGateSmoothedBHS.Rows[iHeureDebut][10] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][10]) + (nombrePassagers - dTransferPassenger) * dMeanTerminatingBaggage;
                                paxGateSmoothedBHS.Rows[iHeureDebut][11] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][11]) + dTransferPassenger * dMeanTransferringBaggage;
                                paxGateSmoothedBHS.Rows[iHeureDebut][12] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][12]) + dTransferPassenger * dMeanTransferringBaggage;
                            }
                            else
                            {
                                if (dMeanBaggage != -1)
                                {
                                    paxGateSmoothedBHS.Rows[iHeureDebut][7] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][7]) + nombrePassagers * dMeanBaggage;
                                    paxGateSmoothedBHS.Rows[iHeureDebut][8] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][8]) + nombrePassagers * dMeanBaggage;
                                    paxGateSmoothedBHS.Rows[iHeureDebut][9] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][9]) + (nombrePassagers - dTransferPassenger) * dMeanBaggage;
                                    paxGateSmoothedBHS.Rows[iHeureDebut][10] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][10]) + (nombrePassagers - dTransferPassenger) * dMeanBaggage;
                                    paxGateSmoothedBHS.Rows[iHeureDebut][11] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][11]) + dTransferPassenger * dMeanBaggage;
                                    paxGateSmoothedBHS.Rows[iHeureDebut][12] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][12]) + dTransferPassenger * dMeanBaggage;
                                }
                                else if (dMeanTotalBaggage != -1 && dMeanTerminatingBaggage != -1 && dMeanTransferringBaggage != -1 && dTerminatingPassengers != -1)
                                {
                                    paxGateSmoothedBHS.Rows[iHeureDebut][7] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][7]) + nombrePassagers * dMeanTotalBaggage;
                                    paxGateSmoothedBHS.Rows[iHeureDebut][8] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][8]) + nombrePassagers * dMeanTotalBaggage;
                                    paxGateSmoothedBHS.Rows[iHeureDebut][9] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][9]) + dTerminatingPassengers * dMeanTerminatingBaggage;
                                    paxGateSmoothedBHS.Rows[iHeureDebut][10] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][10]) + dTerminatingPassengers * dMeanTerminatingBaggage;
                                    paxGateSmoothedBHS.Rows[iHeureDebut][11] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][11]) + dTransferPassenger * dMeanTransferringBaggage;
                                    paxGateSmoothedBHS.Rows[iHeureDebut][12] = ((Double)paxGateSmoothedBHS.Rows[iHeureDebut][12]) + dTransferPassenger * dMeanTransferringBaggage;
                                }
                            }
                        }
                    }
                    #endregion
                    // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                    #region Génération de la table OCT Flow                    
                    Double dOpening = dFirstPassengerTime;
                    DateTime heureAnalisee = dateArrivee.AddMinutes(dOpening);
                    DateTime heureClose = dateArrivee.AddMinutes(dLastPassengerTime);

                    iHeureDebut = DataFunctions.heureDebut(dtTransferICTSmoothed, heureAnalisee);
                    if (iHeureDebut == -1)
                    {
                        iHeureDebut = 0;
                    }
                    if (dtTransferICTSmoothed.Rows.Count != 0)
                    {
                        heureAnalisee = (DateTime)dtTransferICTSmoothed.Rows[iHeureDebut][0];
                        Double dPercent;
                        while (heureAnalisee < heureClose)
                        {
                            heureAnalisee = heureAnalisee.AddMinutes(samplingStep);
                            Double dClosing = DataFunctions.MinuteDifference(dateArrivee, heureAnalisee);
                            dPercent = getDistribution((int)dOpening, (int)dClosing, dtICTEco/*dtShowUpProfile*/, iIndexICTColumnEco);
                            //dPercent = getDistribution((int)dOpening, (int)dClosing, dtICT, FlightCateg);
                            if (dPercent > 0)
                            {
                                Double PAX = dPercent * dTransferPassenger;
                                dtTransferICTSmoothed.Rows[iHeureDebut][1] = (Double)dtTransferICTSmoothed.Rows[iHeureDebut][1] + PAX;

                                if (bUseDefinedNbBags)  // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                                    dtTransferICTSmoothed.Rows[iHeureDebut][3] = (Double)dtTransferICTSmoothed.Rows[iHeureDebut][3] + PAX * dMeanTransferringBaggage;
                                else
                                {
                                    if (dMeanBaggage != -1)
                                    {
                                        dtTransferICTSmoothed.Rows[iHeureDebut][3] = (Double)dtTransferICTSmoothed.Rows[iHeureDebut][3] + PAX * dMeanBaggage;
                                    }
                                    else if (dMeanTransferringBaggage != -1)
                                    {
                                        dtTransferICTSmoothed.Rows[iHeureDebut][3] = (Double)dtTransferICTSmoothed.Rows[iHeureDebut][3] + PAX * dMeanTransferringBaggage;
                                    }
                                }
                            }
                            iHeureDebut++;
                            dOpening = dClosing;
                            if (iHeureDebut >= dtTransferICTSmoothed.Rows.Count)
                                break;
                        }
                    }
                    #endregion
                }

                //On calcul maintenant les valeurs cumulés sur l'interval demandé
                /*if (60 > dStepAnalysis)
                {*/
                #region dtPaxGateSmoothed
                dtPaxGateInstantaneous = dtPaxGateSmoothed.Copy();
                dtPaxGateInstantaneous.TableName = "FPA_InBoundInstantaneous";

                // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant  

                // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns                
                //Smoothed should use the Sample Step and Analysis Range given by the user - only the per hour columns
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtPaxGateSmoothed, 2, 2, samplingStep, analysisRange);  // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtPaxGateSmoothed, 4, 4, samplingStep, analysisRange);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtPaxGateSmoothed, 6, 6, samplingStep, analysisRange);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtPaxGateSmoothed, 8, 8, samplingStep, analysisRange);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtPaxGateSmoothed, 10, 10, samplingStep, analysisRange);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtPaxGateSmoothed, 12, 12, samplingStep, analysisRange);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtPaxGateSmoothed, 14, 14, samplingStep, analysisRange);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtPaxGateSmoothed, 16, 16, samplingStep, analysisRange);

                //Instantaneous should be created with the same values for step and cumulative step (will use SampleStep for both) - only per hour columns
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtPaxGateInstantaneous, 2, 2, samplingStep, samplingStep);  // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtPaxGateInstantaneous, 4, 4, samplingStep, samplingStep);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtPaxGateInstantaneous, 6, 6, samplingStep, samplingStep);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtPaxGateInstantaneous, 8, 8, samplingStep, samplingStep);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtPaxGateInstantaneous, 10, 10, samplingStep, samplingStep);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtPaxGateInstantaneous, 12, 12, samplingStep, samplingStep);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtPaxGateInstantaneous, 14, 14, samplingStep, samplingStep);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtPaxGateInstantaneous, 16, 16, samplingStep, samplingStep);
                // >> Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                #endregion

                // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                #region paxGateSmoothedBHS
                paxGateInstantaneousBHS = paxGateSmoothedBHS.Copy();
                paxGateInstantaneousBHS.TableName = GlobalNames.paxGateInstantaneousBHSTableName;

                //Smoothed should use the Sample Step and Analysis Range given by the user - only the per hour columns
                ResultFunctions.AnalyzePeak_SlidingHourDouble(paxGateSmoothedBHS, 2, 2, samplingStep, analysisRange);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(paxGateSmoothedBHS, 4, 4, samplingStep, analysisRange);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(paxGateSmoothedBHS, 6, 6, samplingStep, analysisRange);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(paxGateSmoothedBHS, 8, 8, samplingStep, analysisRange);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(paxGateSmoothedBHS, 10, 10, samplingStep, analysisRange);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(paxGateSmoothedBHS, 12, 12, samplingStep, analysisRange);

                //Instantaneous should be created with the same values for step and cumulative step (will use SampleStep for both) - only per hour columns
                ResultFunctions.AnalyzePeak_SlidingHourDouble(paxGateInstantaneousBHS, 2, 2, samplingStep, samplingStep);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(paxGateInstantaneousBHS, 4, 4, samplingStep, samplingStep);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(paxGateInstantaneousBHS, 6, 6, samplingStep, samplingStep);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(paxGateInstantaneousBHS, 8, 8, samplingStep, samplingStep);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(paxGateInstantaneousBHS, 10, 10, samplingStep, samplingStep);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(paxGateInstantaneousBHS, 12, 12, samplingStep, samplingStep);
                #endregion
                // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                #region dtTransferICTFlow
                dtTransferICTInstantaneous = dtTransferICTSmoothed.Copy();
                dtTransferICTInstantaneous.TableName = "FPA_TransferICTInstantaneous";

                // >> Task #13761 Pax2Sim - Static Analysis - Instant and Smoothed calculations
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtTransferICTSmoothed, 1, 2, samplingStep, analysisRange);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtTransferICTSmoothed, 3, 4, samplingStep, analysisRange);

                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtTransferICTInstantaneous, 1, 2, samplingStep, samplingStep);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtTransferICTInstantaneous, 3, 4, samplingStep, samplingStep);

                // << Task #13761 Pax2Sim - Static Analysis - Instant and Smoothed calculations
                #endregion

                #region dtAircraftMovements
                dtAircraftMovementsInstantaneous = dtAircraftMovementsSmoothed.Copy();
                dtAircraftMovementsInstantaneous.TableName = "FPA_AircraftMovementsInstantaneous";

                // >> Task #13761 Pax2Sim - Static Analysis - Instant and Smoothed calculations
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtAircraftMovementsSmoothed, 1, 2, samplingStep, analysisRange);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtAircraftMovementsInstantaneous, 1, 2, samplingStep, samplingStep);

                //ResultFunctions.AnalyzePeak_SlidingHourDouble(dtAircraftMovementsSmoothed, 1, 2, dStepAnalysis, 60);
                //ResultFunctions.AnalyzePeak_SlidingHourDouble(dtAircraftMovementsInstantaneous, 1, 2, dStepAnalysis, dStepCumul);
                // << Task #13761 Pax2Sim - Static Analysis - Instant and Smoothed calculations
                #endregion
                /*
                }*/
                #region Gestion des distributions
                DataTable dtPaxPerFlight = ResultFunctions.GenerateDistribution("FPA_PAXFlightDistribution", alPaxPerFlight, 25, 20, 0, "Passengers", new String[] { "Nb Flights" }, null, null);
                DataTable dtFCDistribution = getDistribution(new Hashtable[] { htFlightPerFC, htPaxPerFC, htBagsPerFC },
                                                             "FPA_FlightCategoriesDistribution", new String[] { "Flight category", "Nb Flights", "Nb PAX", "Nb Bags" }, tsFlightCategoriesOrder);

                #region Gestion des Parking
                DataTable[] dtParking = null;
                if (iNbTerminal > 0)
                {
                    dtParking = new DataTable[htFlightPerParking.Count];
                    i = 0;
                    foreach (int iKey in htFlightPerParking.Keys)
                    {
                        //((Hashtable[])htFlightPerParking[i])[j]
                        String[] tsName = new String[htFlightPerParking[iKey].Length + 1];
                        tsName[0] = "Airline Code";
                        for (j = 1; j < tsName.Length; j++)
                            tsName[j] = "ParkingStand_" + j;
                        dtParking[i] = getDistribution(htFlightPerParking[iKey], "FPA_ParkingForTerminal_" + iKey.ToString(),
                            tsName, null);
                        dtParking[i] = OverallTools.DataFunctions.sortTable(dtParking[i], "Airline Code");
                        i++;
                    }
                }
                #endregion
                #endregion
                #region On arrondi les résultats.
                // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns                
                OverallTools.DataFunctions.SumColumns(dtPaxGateSmoothed, new String[] { "Total PAX", "Visitors" }, "Pax+Visitors");
                OverallTools.DataFunctions.SumColumns(dtPaxGateSmoothed, new String[] { "Total PAX / h", "Visitors / h" }, "Pax+Visitors / h");
                OverallTools.DataFunctions.SumColumns(dtPaxGateInstantaneous, new String[] { "Total PAX", "Visitors" }, "Pax+Visitors");
                OverallTools.DataFunctions.SumColumns(dtPaxGateInstantaneous, new String[] { "Total PAX / h", "Visitors / h" }, "Pax+Visitors / h");
                // >> Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                foreach (DataRow Ligne in dtPaxGateSmoothed.Rows)
                {
                    if (Ligne[0].ToString().Length == 0) continue;
                    for (i = 1; i < dtPaxGateSmoothed.Columns.Count; i++)
                        Ligne[i] = Math.Round((Double)Ligne[i], 1);
                }
                foreach (DataRow Ligne in dtPaxGateInstantaneous.Rows)
                {
                    if (Ligne[0].ToString().Length == 0) continue;
                    for (i = 1; i < dtPaxGateSmoothed.Columns.Count; i++)
                        Ligne[i] = Math.Round((Double)Ligne[i], 1);
                }
                // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns                
                //OverallTools.DataFunctions.SumColumns(paxGateSmoothedBHS, new String[] { "Passengers", "Visitors" }, "Pax+Visitors");
                //OverallTools.DataFunctions.SumColumns(paxGateInstantaneousBHS, new String[] { "Passengers", "Visitors" }, "Pax+Visitors");
                // >> Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                foreach (DataRow Ligne in paxGateSmoothedBHS.Rows)
                {
                    if (Ligne[0].ToString().Length == 0)
                        continue;
                    for (i = 1; i < paxGateSmoothedBHS.Columns.Count; i++)
                        Ligne[i] = Math.Round((Double)Ligne[i], 1);
                }
                foreach (DataRow Ligne in paxGateInstantaneousBHS.Rows)
                {
                    if (Ligne[0].ToString().Length == 0)
                        continue;
                    for (i = 1; i < paxGateInstantaneousBHS.Columns.Count; i++)
                        Ligne[i] = Math.Round((Double)Ligne[i], 1);
                }
                // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                foreach (DataRow Ligne in dtAircraftMovementsSmoothed.Rows)
                {
                    if (Ligne[0].ToString().Length == 0) continue;
                    for (i = 1; i < dtAircraftMovementsSmoothed.Columns.Count; i++)
                        Ligne[i] = Math.Round((Double)Ligne[i], 1);
                }
                foreach (DataRow Ligne in dtAircraftMovementsInstantaneous.Rows)
                {
                    if (Ligne[0].ToString().Length == 0) continue;
                    for (i = 1; i < dtAircraftMovementsSmoothed.Columns.Count; i++)
                        Ligne[i] = Math.Round((Double)Ligne[i], 1);
                }
                foreach (DataRow Ligne in dtTransferICTSmoothed.Rows)
                {
                    if (Ligne[0].ToString().Length == 0) continue;
                    for (i = 1; i < dtTransferICTSmoothed.Columns.Count; i++)
                        Ligne[i] = Math.Round((Double)Ligne[i], 1);
                }
                foreach (DataRow Ligne in dtTransferICTInstantaneous.Rows)
                {
                    if (Ligne[0].ToString().Length == 0) continue;
                    for (i = 1; i < dtTransferICTSmoothed.Columns.Count; i++)
                        Ligne[i] = Math.Round((Double)Ligne[i], 1);
                }
                #endregion
                dtPaxGateSmoothed.AcceptChanges();
                dtPaxGateInstantaneous.AcceptChanges();
                // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                paxGateSmoothedBHS.AcceptChanges();
                paxGateInstantaneousBHS.AcceptChanges();
                // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                dtAircraftMovementsSmoothed.AcceptChanges();
                dtAircraftMovementsInstantaneous.AcceptChanges();
                dtTransferICTSmoothed.AcceptChanges();
                dtTransferICTInstantaneous.AcceptChanges();

                // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics                
                /*
                                // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns                
                                DataTable Stats = OverallTools.DataFunctions.GetStatTable(dtPaxGateSmoothed, new int[18] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18 });  // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                OverallTools.DataFunctions.GetStatTable(Stats, dtPaxGateInstantaneous, new int[18] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18 });        // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                // >> Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                                Stats.TableName = "FPA_Peak_Stats";
                                OverallTools.DataFunctions.GetStatTable(Stats, dtAircraftMovementsSmoothed, new int[] { 2 });
                                OverallTools.DataFunctions.GetStatTable(Stats, dtAircraftMovementsInstantaneous, new int[] { 2 });
                                OverallTools.DataFunctions.GetStatTable(Stats, dtTransferICTSmoothed, new int[] { 2, 4 });
                                OverallTools.DataFunctions.GetStatTable(Stats, dtTransferICTInstantaneous, new int[] { 2, 4 });

                                // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                DataTable statsBHS = OverallTools.DataFunctions
                                                            .GetStatTable(paxGateSmoothedBHS, new int[12] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 });
                                OverallTools.DataFunctions.GetStatTable(statsBHS, paxGateInstantaneousBHS, new int[12] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 });
                                statsBHS.TableName = GlobalNames.fpaPeakStatsBHSTableName;
                                // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                */
                DataTable Stats = OverallTools.DataFunctions.getStatisticTable(dtPaxGateSmoothed, new int[18] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18 }, distributionLevels);
                //OverallTools.DataFunctions.addNewStatisticsToStatisticTable(Stats, dtPaxGateInstantaneous, new int[18] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18 }, distributionLevels);

                Stats.TableName = "FPA_Peak_Stats";
                OverallTools.DataFunctions.addNewStatisticsToStatisticTable(Stats, dtAircraftMovementsSmoothed, new int[] { 2 }, distributionLevels);
                //OverallTools.DataFunctions.addNewStatisticsToStatisticTable(Stats, dtAircraftMovementsInstantaneous, new int[] { 2 }, distributionLevels);
                OverallTools.DataFunctions.addNewStatisticsToStatisticTable(Stats, dtTransferICTSmoothed, new int[] { 2, 4 }, distributionLevels);
                //OverallTools.DataFunctions.addNewStatisticsToStatisticTable(Stats, dtTransferICTInstantaneous, new int[] { 2, 4 }, distributionLevels);

                DataTable statsBHS = OverallTools.DataFunctions
                                            .getStatisticTable(paxGateSmoothedBHS, new int[12] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 }, distributionLevels);
                //OverallTools.DataFunctions.addNewStatisticsToStatisticTable(statsBHS, paxGateInstantaneousBHS, new int[12] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 }, distributionLevels);
                statsBHS.TableName = GlobalNames.fpaPeakStatsBHSTableName;
                // << Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics

                alResults.Add(dtPaxPerFlight);
                alResults.Add(dtPaxGateSmoothed);
                alResults.Add(dtPaxGateInstantaneous);
                // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                alResults.Add(statsBHS);
                alResults.Add(paxGateSmoothedBHS);
                alResults.Add(paxGateInstantaneousBHS);
                // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                alResults.Add(dtAircraftMovementsSmoothed);
                alResults.Add(dtAircraftMovementsInstantaneous);
                alResults.Add(dtFCDistribution);
                alResults.Add(Stats);
                alResults.Add(dtTransferICTSmoothed);
                alResults.Add(dtTransferICTInstantaneous);
                if (dtParking != null)
                {
                    for (j = 0; j < dtParking.Length; j++)
                        alResults.Add(dtParking[j]);
                }
                return alResults;
            }

            internal static ArrayList CalcStaticArrivalAnalysisPerAirline(DataTable FPATable,
                DataManagement.NormalTable dtLoadFactors,
                DataManagement.NormalTable TypeAvions,
                DataManagement.NormalTable dtNbBags,
                DataManagement.NormalTable dtNbVisitors,
                DataManagement.NormalTable dtNbTrolley,
                DataManagement.NormalTable dtICTTable,
                // << Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay
                DataManagement.NormalTable dtBaggageLoadingRateTable,
                DataManagement.NormalTable dtBaggageLoadingDelay,
                // >> Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay
                DataTable dtFlightCategories,
                DateTime dtBegin,
                DateTime dtEnd,
                Double dStepAnalysis,
                Double dStepCumul,
                ArrayList ListeErreurs,
                GestionDonneesHUB2SIM donnees,  // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                                // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                bool bUseDefinedNbPax,
                DataTable dtNumberOfPassengers,
                bool bUseDefinedNbBags,
                DataTable dtNumberOfBaggages
                // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                , double[] distributionLevels   // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                , List<FlightConfiguration> userDefinedFlightConfigurations
                )
            {
                ArrayList alResult = CalcStaticArrivalAnalysis2(FPATable, dtLoadFactors, TypeAvions, dtNbBags, dtNbVisitors,
                    dtNbTrolley, dtICTTable, dtBaggageLoadingRateTable, dtBaggageLoadingDelay,  // << Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay
                    dtFlightCategories, dtBegin, dtEnd, dStepAnalysis, dStepCumul, ListeErreurs, donnees,  // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                                                                                           // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                    bUseDefinedNbPax, dtNumberOfPassengers, bUseDefinedNbBags, dtNumberOfBaggages
                    // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                    , distributionLevels, userDefinedFlightConfigurations    // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                    );
                if (alResult == null)
                    return null;
                ArrayList alAirline = new ArrayList();
                int iIndexAirline = FPATable.Columns.IndexOf(GlobalNames.sFPD_A_Column_AirlineCode);
                if (iIndexAirline == -1)
                    return alResult;
                int i;
                if (FPATable.Rows.Count != 0)
                {
                    for (i = 0; i < FPATable.Rows.Count; i++)
                    {
                        if (!alAirline.Contains(FPATable.Rows[i][iIndexAirline].ToString()))
                            alAirline.Add(FPATable.Rows[i][iIndexAirline].ToString());
                    }
                    alAirline.Sort(new FonctionUtiles.ColumnsComparer());
                    DataTable dtTmp = FPATable.Clone();
                    DataTable FPD_AircraftMovementsAirline = null;
                    DataTable FPA_InboundSmoothed = null;
                    DataTable FPA_InboundInstantaneous = null;
                    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    DataTable FPA_InboundSmoothedBHSTotalAirline = null;
                    DataTable FPA_InboundInstantaneousBHSTotalAirline = null;

                    DataTable FPA_InboundSmoothedBHSTransferingAirline = null;
                    DataTable FPA_InboundInstantaneousBHSTransferingAirline = null;

                    DataTable FPA_InboundSmoothedBHSTerminatingAirline = null;
                    DataTable FPA_InboundInstantaneousBHSTerminatingAirline = null;
                    // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                    // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                    DataTable FPA_InboundSmoothedPAXTerminatingAirline = null;
                    DataTable FPA_InboundInstantaneousPAXTerminatingAirline = null;

                    DataTable FPA_InboundSmoothedPAXTransferingAirline = null;
                    DataTable FPA_InboundInstantaneousPAXTransferingAirline = null;

                    DataTable FPA_InboundSmoothedBagTerminatingAirline = null;
                    DataTable FPA_InboundInstantaneousBagTerminatingAirline = null;

                    DataTable FPA_InboundSmoothedBagTransferingAirline = null;
                    DataTable FPA_InboundInstantaneousBagTransferingAirline = null;

                    DataTable FPA_TransferICTSmoothedAirline = null;
                    DataTable FPA_TransferICTInstantaneousAirline = null;

                    DataTable FPA_TransferICTBagSmoothedAirline = null;
                    DataTable FPA_TransferICTBagInstantaneousAirline = null;
                    // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

                    DataTable FPA_InboundBagSmoothed = null;
                    DataTable FPA_InboundBagInstantaneous = null;

                    for (i = 0; i < alAirline.Count; i++)
                    {
                        String sAirline = alAirline[i].ToString();
                        dtTmp.Rows.Clear();
                        foreach (DataRow drTmp in FPATable.Rows)
                        {
                            if (drTmp[iIndexAirline].ToString() == sAirline)
                                dtTmp.Rows.Add(drTmp.ItemArray);
                        }
                        ArrayList alTmp = CalcStaticArrivalAnalysis2(dtTmp, dtLoadFactors, TypeAvions, dtNbBags,
                            dtNbVisitors, dtNbTrolley, dtICTTable, dtBaggageLoadingRateTable, dtBaggageLoadingDelay,    // << Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay
                            dtFlightCategories, dtBegin, dtEnd, dStepAnalysis, dStepCumul, ListeErreurs, donnees,   // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                                                                                                    // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                            bUseDefinedNbPax, dtNumberOfPassengers, bUseDefinedNbBags, dtNumberOfBaggages
                            // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                            , distributionLevels, userDefinedFlightConfigurations    // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                            );
                        if (alTmp == null)
                            continue;

                        DataTable dtAircraftMovement = null;

                        DataTable dtAirlineSmoothed = null;
                        DataTable dtAirlineInstantaneous = null;
                        // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                        DataTable airlineSmoothedBHSTable = null;
                        DataTable airlineInstantaneousBHSTable = null;
                        // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                        // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                        DataTable transferICTSmoothedAirlineTable = null;
                        DataTable transferICTInstantaneousAirlineTable = null;
                        // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

                        foreach (DataTable dtTmp2 in alTmp)
                        {
                            if (dtTmp2.TableName == "FPA_InBoundRolling")
                                dtAirlineSmoothed = dtTmp2;
                            if (dtTmp2.TableName == "FPA_InBoundInstantaneous")
                                dtAirlineInstantaneous = dtTmp2;
                            // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                            if (dtTmp2.TableName == GlobalNames.paxGateSmoothedBHSTableName)
                                airlineSmoothedBHSTable = dtTmp2;
                            if (dtTmp2.TableName == GlobalNames.paxGateInstantaneousBHSTableName)
                                airlineInstantaneousBHSTable = dtTmp2;
                            // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                            // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                            if (dtTmp2.TableName == GlobalNames.FPA_TransferICTSmoothedTableName)
                                transferICTSmoothedAirlineTable = dtTmp2;

                            if (dtTmp2.TableName == GlobalNames.FPA_TransferICTInstantaneousTableName)
                                transferICTInstantaneousAirlineTable = dtTmp2;
                            // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

                            if (dtTmp2.TableName == "FPA_AircraftMovementsRolling")
                                dtAircraftMovement = dtTmp2;
                        }
                        if ((dtAirlineSmoothed == null) || (dtAirlineInstantaneous == null))
                            continue;
                        // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                        if ((airlineSmoothedBHSTable == null) || (airlineInstantaneousBHSTable == null))
                            continue;
                        // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                        // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                        if (transferICTSmoothedAirlineTable == null || transferICTInstantaneousAirlineTable == null)
                            continue;
                        // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

                        if (FPA_InboundSmoothed == null)
                        {
                            FPA_InboundSmoothed = dtAirlineSmoothed.Copy();
                            FPA_InboundSmoothed.TableName = FPA_InboundSmoothed.TableName + "_Airline";
                            while (FPA_InboundSmoothed.Columns.Count > 1)
                                FPA_InboundSmoothed.Columns.RemoveAt(1);
                            FPA_InboundBagSmoothed = FPA_InboundSmoothed.Copy();
                            FPA_InboundBagSmoothed.TableName = dtAirlineSmoothed.TableName + "_Bag_Airline";
                        }
                        if (FPA_InboundInstantaneous == null)
                        {
                            FPA_InboundInstantaneous = dtAirlineInstantaneous.Copy();
                            FPA_InboundInstantaneous.TableName = FPA_InboundInstantaneous.TableName + "_Airline";
                            while (FPA_InboundInstantaneous.Columns.Count > 1)
                                FPA_InboundInstantaneous.Columns.RemoveAt(1);
                            FPA_InboundBagInstantaneous = FPA_InboundInstantaneous.Copy();
                            FPA_InboundBagInstantaneous.TableName = dtAirlineInstantaneous.TableName + "_Bag_Airline";
                        }
                        // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                        if (FPA_InboundSmoothedBHSTotalAirline == null)
                        {
                            FPA_InboundSmoothedBHSTotalAirline = airlineSmoothedBHSTable.Copy();
                            FPA_InboundSmoothedBHSTotalAirline.TableName = FPA_InboundSmoothedBHSTotalAirline.TableName + "_Total_Airline";
                            while (FPA_InboundSmoothedBHSTotalAirline.Columns.Count > 1)
                                FPA_InboundSmoothedBHSTotalAirline.Columns.RemoveAt(1);
                        }
                        if (FPA_InboundInstantaneousBHSTotalAirline == null)
                        {
                            FPA_InboundInstantaneousBHSTotalAirline = airlineInstantaneousBHSTable.Copy();
                            FPA_InboundInstantaneousBHSTotalAirline.TableName = FPA_InboundInstantaneousBHSTotalAirline.TableName + "_Total_Airline";
                            while (FPA_InboundInstantaneousBHSTotalAirline.Columns.Count > 1)
                                FPA_InboundInstantaneousBHSTotalAirline.Columns.RemoveAt(1);
                        }

                        if (FPA_InboundSmoothedBHSTransferingAirline == null)
                        {
                            FPA_InboundSmoothedBHSTransferingAirline = airlineSmoothedBHSTable.Copy();
                            FPA_InboundSmoothedBHSTransferingAirline.TableName = FPA_InboundSmoothedBHSTransferingAirline.TableName + "_Transfering_Airline";
                            while (FPA_InboundSmoothedBHSTransferingAirline.Columns.Count > 1)
                                FPA_InboundSmoothedBHSTransferingAirline.Columns.RemoveAt(1);
                        }
                        if (FPA_InboundInstantaneousBHSTransferingAirline == null)
                        {
                            FPA_InboundInstantaneousBHSTransferingAirline = airlineInstantaneousBHSTable.Copy();
                            FPA_InboundInstantaneousBHSTransferingAirline.TableName = FPA_InboundInstantaneousBHSTransferingAirline.TableName + "_Transfering_Airline";
                            while (FPA_InboundInstantaneousBHSTransferingAirline.Columns.Count > 1)
                                FPA_InboundInstantaneousBHSTransferingAirline.Columns.RemoveAt(1);
                        }

                        if (FPA_InboundSmoothedBHSTerminatingAirline == null)
                        {
                            FPA_InboundSmoothedBHSTerminatingAirline = airlineSmoothedBHSTable.Copy();
                            FPA_InboundSmoothedBHSTerminatingAirline.TableName = FPA_InboundSmoothedBHSTerminatingAirline.TableName + "_Terminating_Airline";
                            while (FPA_InboundSmoothedBHSTerminatingAirline.Columns.Count > 1)
                                FPA_InboundSmoothedBHSTerminatingAirline.Columns.RemoveAt(1);
                        }
                        if (FPA_InboundInstantaneousBHSTerminatingAirline == null)
                        {
                            FPA_InboundInstantaneousBHSTerminatingAirline = airlineInstantaneousBHSTable.Copy();
                            FPA_InboundInstantaneousBHSTerminatingAirline.TableName = FPA_InboundInstantaneousBHSTerminatingAirline.TableName + "_Terminating_Airline";
                            while (FPA_InboundInstantaneousBHSTerminatingAirline.Columns.Count > 1)
                                FPA_InboundInstantaneousBHSTerminatingAirline.Columns.RemoveAt(1);
                        }
                        // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                        if (FPD_AircraftMovementsAirline == null)
                        {
                            FPD_AircraftMovementsAirline = dtAircraftMovement.Copy();
                            FPD_AircraftMovementsAirline.TableName = "FPA_AircraftMovements_Airline";
                            while (FPD_AircraftMovementsAirline.Columns.Count > 1)
                                FPD_AircraftMovementsAirline.Columns.RemoveAt(1);
                        }

                        // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                        if (FPA_InboundSmoothedPAXTerminatingAirline == null)
                        {
                            FPA_InboundSmoothedPAXTerminatingAirline = dtAirlineSmoothed.Copy();
                            FPA_InboundSmoothedPAXTerminatingAirline.TableName = GlobalNames.fpaInboundSmoothedPAXTerminating_Airline;
                            while (FPA_InboundSmoothedPAXTerminatingAirline.Columns.Count > 1)
                                FPA_InboundSmoothedPAXTerminatingAirline.Columns.RemoveAt(1);
                            FPA_InboundSmoothedBagTerminatingAirline = FPA_InboundSmoothedPAXTerminatingAirline.Copy();
                            FPA_InboundSmoothedBagTerminatingAirline.TableName = GlobalNames.fpaInboundSmoothedBagTerminating_Airline;
                        }
                        if (FPA_InboundInstantaneousPAXTerminatingAirline == null)
                        {
                            FPA_InboundInstantaneousPAXTerminatingAirline = dtAirlineInstantaneous.Copy();
                            FPA_InboundInstantaneousPAXTerminatingAirline.TableName = GlobalNames.fpaInboundInstantaneousPAXTerminating_Airline;
                            while (FPA_InboundInstantaneousPAXTerminatingAirline.Columns.Count > 1)
                                FPA_InboundInstantaneousPAXTerminatingAirline.Columns.RemoveAt(1);
                            FPA_InboundInstantaneousBagTerminatingAirline = FPA_InboundInstantaneousPAXTerminatingAirline.Copy();
                            FPA_InboundInstantaneousBagTerminatingAirline.TableName = GlobalNames.fpaInboundInstantaneousBagTerminating_Airline;
                        }

                        if (FPA_InboundSmoothedPAXTransferingAirline == null)
                        {
                            FPA_InboundSmoothedPAXTransferingAirline = dtAirlineSmoothed.Copy();
                            FPA_InboundSmoothedPAXTransferingAirline.TableName = GlobalNames.fpaInboundSmoothedPAXTransferring_Airline;
                            while (FPA_InboundSmoothedPAXTransferingAirline.Columns.Count > 1)
                                FPA_InboundSmoothedPAXTransferingAirline.Columns.RemoveAt(1);
                            FPA_InboundSmoothedBagTransferingAirline = FPA_InboundSmoothedPAXTransferingAirline.Copy();
                            FPA_InboundSmoothedBagTransferingAirline.TableName = GlobalNames.fpaInboundSmoothedBagTransferring_Airline;
                        }
                        if (FPA_InboundInstantaneousPAXTransferingAirline == null)
                        {
                            FPA_InboundInstantaneousPAXTransferingAirline = dtAirlineInstantaneous.Copy();
                            FPA_InboundInstantaneousPAXTransferingAirline.TableName = GlobalNames.fpaInboundInstantaneousPAXTransferring_Airline;
                            while (FPA_InboundInstantaneousPAXTransferingAirline.Columns.Count > 1)
                                FPA_InboundInstantaneousPAXTransferingAirline.Columns.RemoveAt(1);
                            FPA_InboundInstantaneousBagTransferingAirline = FPA_InboundInstantaneousPAXTransferingAirline.Copy();
                            FPA_InboundInstantaneousBagTransferingAirline.TableName = GlobalNames.fpaInboundInstantaneousBagTransferring_Airline;
                        }

                        if (FPA_TransferICTSmoothedAirline == null)
                        {
                            FPA_TransferICTSmoothedAirline = transferICTSmoothedAirlineTable.Copy();
                            FPA_TransferICTSmoothedAirline.TableName = transferICTSmoothedAirlineTable.TableName + "_Airline";
                            while (FPA_TransferICTSmoothedAirline.Columns.Count > 1)
                                FPA_TransferICTSmoothedAirline.Columns.RemoveAt(1);
                            FPA_TransferICTBagSmoothedAirline = FPA_TransferICTSmoothedAirline.Copy();
                            FPA_TransferICTBagSmoothedAirline.TableName = transferICTSmoothedAirlineTable.TableName + "_Bag_Airline";
                        }
                        if (FPA_TransferICTInstantaneousAirline == null)
                        {
                            FPA_TransferICTInstantaneousAirline = transferICTInstantaneousAirlineTable.Copy();
                            FPA_TransferICTInstantaneousAirline.TableName = FPA_TransferICTInstantaneousAirline.TableName + "_Airline";
                            while (FPA_TransferICTInstantaneousAirline.Columns.Count > 1)
                                FPA_TransferICTInstantaneousAirline.Columns.RemoveAt(1);
                            FPA_TransferICTBagInstantaneousAirline = FPA_TransferICTInstantaneousAirline.Copy();
                            FPA_TransferICTBagInstantaneousAirline.TableName = transferICTInstantaneousAirlineTable.TableName + "_Bag_Airline";
                        }
                        // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

                        // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant                        
                        /*
                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundSmoothed, dtAirlineSmoothed, new int[] { 2 }, sAirline + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundInstantaneous, dtAirlineInstantaneous, new int[] { 2 }, sAirline + "_");

                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundBagSmoothed, dtAirlineSmoothed, new int[] { 8 }, sAirline + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundBagInstantaneous, dtAirlineInstantaneous, new int[] { 8 }, sAirline + "_");
                        */
                        // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundSmoothed, dtAirlineSmoothed, new int[] { 2 }, sAirline + "_"); // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundInstantaneous, dtAirlineInstantaneous, new int[] { 2 }, sAirline + "_");   // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundBagSmoothed, dtAirlineSmoothed, new int[] { 8 }, sAirline + "_");  // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns
                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundBagInstantaneous, dtAirlineInstantaneous, new int[] { 8 }, sAirline + "_");    // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                        // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundSmoothedBHSTotalAirline, airlineSmoothedBHSTable, new int[] { 8 }, sAirline + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundInstantaneousBHSTotalAirline, airlineInstantaneousBHSTable, new int[] { 8 }, sAirline + "_");

                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundSmoothedBHSTerminatingAirline, airlineSmoothedBHSTable, new int[] { 10 }, sAirline + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundInstantaneousBHSTerminatingAirline, airlineInstantaneousBHSTable, new int[] { 10 }, sAirline + "_");

                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundSmoothedBHSTransferingAirline, airlineSmoothedBHSTable, new int[] { 12 }, sAirline + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundInstantaneousBHSTransferingAirline, airlineInstantaneousBHSTable, new int[] { 12 }, sAirline + "_");
                        // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                        // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                        OverallTools.DataFunctions
                            .ConcateneTable(FPA_InboundSmoothedPAXTerminatingAirline, dtAirlineSmoothed, new int[] { 4 }, sAirline + "_");
                        OverallTools.DataFunctions
                            .ConcateneTable(FPA_InboundInstantaneousPAXTerminatingAirline, dtAirlineInstantaneous, new int[] { 4 }, sAirline + "_");

                        OverallTools.DataFunctions
                            .ConcateneTable(FPA_InboundSmoothedPAXTransferingAirline, dtAirlineSmoothed, new int[] { 6 }, sAirline + "_");
                        OverallTools.DataFunctions
                            .ConcateneTable(FPA_InboundInstantaneousPAXTransferingAirline, dtAirlineInstantaneous, new int[] { 6 }, sAirline + "_");

                        OverallTools.DataFunctions
                            .ConcateneTable(FPA_InboundSmoothedBagTerminatingAirline, dtAirlineSmoothed, new int[] { 10 }, sAirline + "_");
                        OverallTools.DataFunctions
                            .ConcateneTable(FPA_InboundInstantaneousBagTerminatingAirline, dtAirlineInstantaneous, new int[] { 10 }, sAirline + "_");

                        OverallTools.DataFunctions
                            .ConcateneTable(FPA_InboundSmoothedBagTransferingAirline, dtAirlineSmoothed, new int[] { 12 }, sAirline + "_");
                        OverallTools.DataFunctions
                            .ConcateneTable(FPA_InboundInstantaneousBagTransferingAirline, dtAirlineInstantaneous, new int[] { 12 }, sAirline + "_");

                        OverallTools.DataFunctions.ConcateneTable(FPA_TransferICTSmoothedAirline, transferICTSmoothedAirlineTable, new int[] { 2 }, sAirline + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPA_TransferICTInstantaneousAirline, transferICTInstantaneousAirlineTable, new int[] { 2 }, sAirline + "_");

                        OverallTools.DataFunctions.ConcateneTable(FPA_TransferICTBagSmoothedAirline, transferICTSmoothedAirlineTable, new int[] { 4 }, sAirline + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPA_TransferICTBagInstantaneousAirline, transferICTInstantaneousAirlineTable, new int[] { 4 }, sAirline + "_");
                        // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

                        OverallTools.DataFunctions.ConcateneTable(FPD_AircraftMovementsAirline, dtAircraftMovement, new int[] { 1 }, sAirline + "_");
                    }
                    DataTable dtStats = new DataTable("FPA_Airline_Stats");
                    dtStats.Columns.Add("Airline", typeof(String));

                    dtStats.Columns.Add("InBound_Smoothed_Pax_Max", typeof(Double));
                    dtStats.Columns.Add("InBound_Instantaneous_Pax_Max", typeof(Double));

                    dtStats.Columns.Add("InBound_Smoothed_Bag_Max", typeof(Double));
                    dtStats.Columns.Add("InBound_Instantaneous_Bag_Max", typeof(Double));

                    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    dtStats.Columns.Add("InBound_Smoothed_BHS_Total_Max", typeof(Double));
                    dtStats.Columns.Add("InBound_Instantaneous_BHS_Total_Max", typeof(Double));

                    dtStats.Columns.Add("InBound_Smoothed_BHS_Terminating_Max", typeof(Double));
                    dtStats.Columns.Add("InBound_Instantaneous_BHS_Terminating_Max", typeof(Double));

                    dtStats.Columns.Add("InBound_Smoothed_BHS_Transfering_Max", typeof(Double));
                    dtStats.Columns.Add("InBound_Instantaneous_BHS_Transfering_Max", typeof(Double));
                    // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant                    
                    /*
                    if (FPA_InboundSmoothed != null)
                    {
                        for (i = 1; i < FPA_InboundSmoothed.Columns.Count; i++)
                        {
                            DataRow drNewRow = dtStats.NewRow();
                            drNewRow[0] = alAirline[i - 1].ToString();
                            drNewRow[1] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundSmoothed, i);
                            drNewRow[2] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundInstantaneous, i);
                            drNewRow[3] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundBagSmoothed, i);
                            drNewRow[4] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundBagInstantaneous, i);
                            dtStats.Rows.Add(drNewRow);
                        }
                    }
                     */
                    if (FPA_InboundSmoothed != null && FPA_InboundBagSmoothed != null && FPA_InboundSmoothedBHSTotalAirline != null
                        && FPA_InboundSmoothedBHSTerminatingAirline != null && FPA_InboundSmoothedBHSTransferingAirline != null
                        && FPA_InboundInstantaneous != null && FPA_InboundBagInstantaneous != null && FPA_InboundInstantaneousBHSTotalAirline != null
                        && FPA_InboundInstantaneousBHSTerminatingAirline != null && FPA_InboundInstantaneousBHSTransferingAirline != null)
                    {
                        if (FPA_InboundSmoothed.Columns.Count == FPA_InboundBagSmoothed.Columns.Count
                            && FPA_InboundBagSmoothed.Columns.Count == FPA_InboundSmoothedBHSTotalAirline.Columns.Count
                            && FPA_InboundSmoothedBHSTotalAirline.Columns.Count == FPA_InboundSmoothedBHSTerminatingAirline.Columns.Count
                            && FPA_InboundSmoothedBHSTerminatingAirline.Columns.Count == FPA_InboundSmoothedBHSTransferingAirline.Columns.Count)
                        {
                            for (i = 1; i < FPA_InboundSmoothed.Columns.Count; i++)
                            {
                                if (alAirline.Count > i - 1)
                                {
                                    DataRow drNewRow = dtStats.NewRow();

                                    drNewRow[0] = alAirline[i - 1].ToString();
                                    drNewRow[1] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundSmoothed, i);
                                    drNewRow[2] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundInstantaneous, i);

                                    drNewRow[3] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundBagSmoothed, i);
                                    drNewRow[4] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundBagInstantaneous, i);

                                    drNewRow[5] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundSmoothedBHSTotalAirline, i);
                                    drNewRow[6] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundInstantaneousBHSTotalAirline, i);

                                    drNewRow[7] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundSmoothedBHSTerminatingAirline, i);
                                    drNewRow[8] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundInstantaneousBHSTerminatingAirline, i);

                                    drNewRow[9] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundSmoothedBHSTransferingAirline, i);
                                    drNewRow[10] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundInstantaneousBHSTransferingAirline, i);

                                    dtStats.Rows.Add(drNewRow);
                                }
                            }
                        }
                    }
                    // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant


                    alResult.Add(dtStats);
                    alResult.Add(FPA_InboundSmoothed);
                    alResult.Add(FPA_InboundInstantaneous);
                    alResult.Add(FPA_InboundBagSmoothed);
                    alResult.Add(FPA_InboundBagInstantaneous);
                    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    alResult.Add(FPA_InboundSmoothedBHSTotalAirline);
                    alResult.Add(FPA_InboundInstantaneousBHSTotalAirline);

                    alResult.Add(FPA_InboundSmoothedBHSTerminatingAirline);
                    alResult.Add(FPA_InboundInstantaneousBHSTerminatingAirline);

                    alResult.Add(FPA_InboundSmoothedBHSTransferingAirline);
                    alResult.Add(FPA_InboundInstantaneousBHSTransferingAirline);
                    // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                    // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                    alResult.Add(FPA_InboundSmoothedPAXTerminatingAirline);
                    alResult.Add(FPA_InboundInstantaneousPAXTerminatingAirline);

                    alResult.Add(FPA_InboundSmoothedPAXTransferingAirline);
                    alResult.Add(FPA_InboundInstantaneousPAXTransferingAirline);

                    alResult.Add(FPA_InboundSmoothedBagTerminatingAirline);
                    alResult.Add(FPA_InboundInstantaneousBagTerminatingAirline);

                    alResult.Add(FPA_InboundSmoothedBagTransferingAirline);
                    alResult.Add(FPA_InboundInstantaneousBagTransferingAirline);

                    alResult.Add(FPA_TransferICTSmoothedAirline);
                    alResult.Add(FPA_TransferICTInstantaneousAirline);

                    alResult.Add(FPA_TransferICTBagSmoothedAirline);
                    alResult.Add(FPA_TransferICTBagInstantaneousAirline);
                    // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

                    alResult.Add(FPD_AircraftMovementsAirline);


                }
                return alResult;
            }

            internal static ArrayList CalcStaticArrivalAnalysisPerTerminal(DataTable FPATable,
                DataManagement.NormalTable dtLoadFactors,
                DataManagement.NormalTable TypeAvions,
                DataManagement.NormalTable dtNbBags,
                DataManagement.NormalTable dtNbVisitors,
                DataManagement.NormalTable dtNbTrolley,
                DataManagement.NormalTable dtICTTable,
                // << Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay
                DataManagement.NormalTable dtBaggageLoadingRateTable,
                DataManagement.NormalTable dtBaggageLoadingDelatTable,
                // >> Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay
                DataTable dtFlightCategories,
                DateTime dtBegin,
                DateTime dtEnd,
                Double dStepAnalysis,
                Double dStepCumul,
                ArrayList ListeErreurs,
                GestionDonneesHUB2SIM donnees, // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                               // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                bool bUseDefinedNbPax,
                DataTable dtNumberOfPassengers,
                bool bUseDefinedNbBags,
                DataTable dtNumberOfBaggages
                // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                , double[] distributionLevels   // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                , List<FlightConfiguration> userDefinedFlightConfigurations
                )
            {
                ArrayList alResult = CalcStaticArrivalAnalysis2(FPATable, dtLoadFactors, TypeAvions,
                    dtNbBags, dtNbVisitors, dtNbTrolley, dtICTTable, dtBaggageLoadingRateTable, dtBaggageLoadingDelatTable, // << Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay 
                    dtFlightCategories, dtBegin, dtEnd, dStepAnalysis, dStepCumul, ListeErreurs, donnees,  // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                                                                                           // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                    bUseDefinedNbPax, dtNumberOfPassengers, bUseDefinedNbBags, dtNumberOfBaggages
                    // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                    , distributionLevels, userDefinedFlightConfigurations    // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                    );
                if (alResult == null)
                    return null;
                ArrayList alAirline = new ArrayList();
                int iIndexAirline = FPATable.Columns.IndexOf(GlobalNames.sFPD_A_Column_TerminalGate);
                if (iIndexAirline == -1)
                    return alResult;
                int i;
                if (FPATable.Rows.Count != 0)
                {
                    for (i = 0; i < FPATable.Rows.Count; i++)
                    {
                        if (!alAirline.Contains(FPATable.Rows[i][iIndexAirline].ToString()))
                            alAirline.Add(FPATable.Rows[i][iIndexAirline].ToString());
                    }
                    alAirline.Sort(new FonctionUtiles.ColumnsComparer());
                    DataTable dtTmp = FPATable.Clone();
                    DataTable FPD_AircraftMovementsTerminal = null;
                    DataTable FPA_InboundSmoothed = null;
                    DataTable FPA_InboundInstantaneous = null;

                    DataTable FPA_InboundBagSmoothed = null;
                    DataTable FPA_InboundBagInstantaneous = null;

                    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    DataTable FPA_InboundSmoothedBHSTotalTerminal = null;
                    DataTable FPA_InboundInstantaneousBHSTotalTerminal = null;

                    DataTable FPA_InboundSmoothedBHSTransferingTerminal = null;
                    DataTable FPA_InboundInstantaneousBHSTransferingTerminal = null;

                    DataTable FPA_InboundSmoothedBHSTerminatingTerminal = null;
                    DataTable FPA_InboundInstantaneousBHSTerminatingTerminal = null;
                    // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                    DataTable FPA_InboundSmoothedPAXTerminatingTerminal = null;
                    DataTable FPA_InboundInstantaneousPAXTerminatingTerminal = null;

                    DataTable FPA_InboundSmoothedPAXTransferingTerminal = null;
                    DataTable FPA_InboundInstantaneousPAXTransferingTerminal = null;

                    DataTable FPA_InboundSmoothedBagTerminatingTerminal = null;
                    DataTable FPA_InboundInstantaneousBagTerminatingTerminal = null;

                    DataTable FPA_InboundSmoothedBagTransferingTerminal = null;
                    DataTable FPA_InboundInstantaneousBagTransferingTerminal = null;

                    DataTable FPA_TransferICTSmoothedTerminal = null;
                    DataTable FPA_TransferICTInstantaneousTerminal = null;

                    DataTable FPA_TransferICTBagSmoothedTerminal = null;
                    DataTable FPA_TransferICTBagInstantaneousTerminal = null;
                    // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

                    for (i = 0; i < alAirline.Count; i++)
                    {
                        String sAirline = alAirline[i].ToString();
                        String sAirlineName = "Terminal " + alAirline[i].ToString();
                        dtTmp.Rows.Clear();
                        foreach (DataRow drTmp in FPATable.Rows)
                        {
                            if (drTmp[iIndexAirline].ToString() == sAirline)
                                dtTmp.Rows.Add(drTmp.ItemArray);
                        }
                        ArrayList alTmp = CalcStaticArrivalAnalysis2(dtTmp, dtLoadFactors, TypeAvions,
                            dtNbBags, dtNbVisitors, dtNbTrolley, dtICTTable, dtBaggageLoadingRateTable, dtBaggageLoadingDelatTable,  // << Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay
                            dtFlightCategories, dtBegin, dtEnd, dStepAnalysis, dStepCumul, ListeErreurs, donnees,  // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                                                                                                   // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                            bUseDefinedNbPax, dtNumberOfPassengers, bUseDefinedNbBags, dtNumberOfBaggages
                            // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                            , distributionLevels, userDefinedFlightConfigurations    // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                            );
                        if (alTmp == null)
                            continue;
                        DataTable dtAircraftMovement = null;
                        DataTable dtAirlineSmoothed = null;
                        DataTable dtAirlineInstantaneous = null;
                        // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                        DataTable terminalSmoothedBHS = null;
                        DataTable terminalInstantaneousBHS = null;
                        // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                        // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                        DataTable transferICTSmoothedTerminalTable = null;
                        DataTable transferICTInstantaneousTerminalTable = null;
                        // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

                        foreach (DataTable dtTmp2 in alTmp)
                        {
                            if (dtTmp2.TableName == "FPA_InBoundRolling")
                                dtAirlineSmoothed = dtTmp2;

                            if (dtTmp2.TableName == "FPA_InBoundInstantaneous")
                                dtAirlineInstantaneous = dtTmp2;
                            // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                            if (dtTmp2.TableName == GlobalNames.paxGateSmoothedBHSTableName)
                                terminalSmoothedBHS = dtTmp2;

                            if (dtTmp2.TableName == GlobalNames.paxGateInstantaneousBHSTableName)
                                terminalInstantaneousBHS = dtTmp2;
                            // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                            if (dtTmp2.TableName == "FPA_AircraftMovementsRolling")
                                dtAircraftMovement = dtTmp2;

                            // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                            if (dtTmp2.TableName == GlobalNames.FPA_TransferICTSmoothedTableName)
                                transferICTSmoothedTerminalTable = dtTmp2;

                            if (dtTmp2.TableName == GlobalNames.FPA_TransferICTInstantaneousTableName)
                                transferICTInstantaneousTerminalTable = dtTmp2;
                            // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                        }
                        if ((dtAirlineSmoothed == null) || (dtAirlineInstantaneous == null))
                            continue;
                        // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                        if ((terminalSmoothedBHS == null) || (terminalInstantaneousBHS == null))
                            continue;
                        // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                        // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                        if (transferICTSmoothedTerminalTable == null || transferICTInstantaneousTerminalTable == null)
                            continue;
                        // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

                        if (FPA_InboundSmoothed == null)
                        {
                            FPA_InboundSmoothed = dtAirlineSmoothed.Copy();
                            FPA_InboundSmoothed.TableName = FPA_InboundSmoothed.TableName + "_Terminal";
                            while (FPA_InboundSmoothed.Columns.Count > 1)
                                FPA_InboundSmoothed.Columns.RemoveAt(1);
                            FPA_InboundBagSmoothed = FPA_InboundSmoothed.Copy();
                            FPA_InboundBagSmoothed.TableName = dtAirlineSmoothed.TableName + "_Bag_Terminal";
                        }
                        if (FPA_InboundInstantaneous == null)
                        {
                            FPA_InboundInstantaneous = dtAirlineInstantaneous.Copy();
                            FPA_InboundInstantaneous.TableName = FPA_InboundInstantaneous.TableName + "_Terminal";
                            while (FPA_InboundInstantaneous.Columns.Count > 1)
                                FPA_InboundInstantaneous.Columns.RemoveAt(1);
                            FPA_InboundBagInstantaneous = FPA_InboundInstantaneous.Copy();
                            FPA_InboundBagInstantaneous.TableName = dtAirlineInstantaneous.TableName + "_Bag_Terminal";
                        }
                        // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                        if (FPA_InboundSmoothedBHSTotalTerminal == null)
                        {
                            FPA_InboundSmoothedBHSTotalTerminal = terminalSmoothedBHS.Copy();
                            FPA_InboundSmoothedBHSTotalTerminal.TableName = FPA_InboundSmoothedBHSTotalTerminal.TableName + "_Total_Terminal";
                            while (FPA_InboundSmoothedBHSTotalTerminal.Columns.Count > 1)
                                FPA_InboundSmoothedBHSTotalTerminal.Columns.RemoveAt(1);
                        }
                        if (FPA_InboundInstantaneousBHSTotalTerminal == null)
                        {
                            FPA_InboundInstantaneousBHSTotalTerminal = terminalInstantaneousBHS.Copy();
                            FPA_InboundInstantaneousBHSTotalTerminal.TableName = FPA_InboundInstantaneousBHSTotalTerminal.TableName + "_Total_Terminal";
                            while (FPA_InboundInstantaneousBHSTotalTerminal.Columns.Count > 1)
                                FPA_InboundInstantaneousBHSTotalTerminal.Columns.RemoveAt(1);
                        }

                        if (FPA_InboundSmoothedBHSTransferingTerminal == null)
                        {
                            FPA_InboundSmoothedBHSTransferingTerminal = terminalSmoothedBHS.Copy();
                            FPA_InboundSmoothedBHSTransferingTerminal.TableName = FPA_InboundSmoothedBHSTransferingTerminal.TableName + "_Transfering_Terminal";
                            while (FPA_InboundSmoothedBHSTransferingTerminal.Columns.Count > 1)
                                FPA_InboundSmoothedBHSTransferingTerminal.Columns.RemoveAt(1);
                        }
                        if (FPA_InboundInstantaneousBHSTransferingTerminal == null)
                        {
                            FPA_InboundInstantaneousBHSTransferingTerminal = terminalInstantaneousBHS.Copy();
                            FPA_InboundInstantaneousBHSTransferingTerminal.TableName = FPA_InboundInstantaneousBHSTransferingTerminal.TableName + "_Transfering_Terminal";
                            while (FPA_InboundInstantaneousBHSTransferingTerminal.Columns.Count > 1)
                                FPA_InboundInstantaneousBHSTransferingTerminal.Columns.RemoveAt(1);
                        }

                        if (FPA_InboundSmoothedBHSTerminatingTerminal == null)
                        {
                            FPA_InboundSmoothedBHSTerminatingTerminal = terminalSmoothedBHS.Copy();
                            FPA_InboundSmoothedBHSTerminatingTerminal.TableName = FPA_InboundSmoothedBHSTerminatingTerminal.TableName + "_Terminating_Terminal";
                            while (FPA_InboundSmoothedBHSTerminatingTerminal.Columns.Count > 1)
                                FPA_InboundSmoothedBHSTerminatingTerminal.Columns.RemoveAt(1);
                        }
                        if (FPA_InboundInstantaneousBHSTerminatingTerminal == null)
                        {
                            FPA_InboundInstantaneousBHSTerminatingTerminal = terminalInstantaneousBHS.Copy();
                            FPA_InboundInstantaneousBHSTerminatingTerminal.TableName = FPA_InboundInstantaneousBHSTerminatingTerminal.TableName + "_Terminating_Terminal";
                            while (FPA_InboundInstantaneousBHSTerminatingTerminal.Columns.Count > 1)
                                FPA_InboundInstantaneousBHSTerminatingTerminal.Columns.RemoveAt(1);
                        }
                        // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                        if (FPD_AircraftMovementsTerminal == null)
                        {
                            FPD_AircraftMovementsTerminal = dtAircraftMovement.Copy();
                            FPD_AircraftMovementsTerminal.TableName = "FPA_AircraftMovements_Terminal";
                            while (FPD_AircraftMovementsTerminal.Columns.Count > 1)
                                FPD_AircraftMovementsTerminal.Columns.RemoveAt(1);
                        }
                        // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                        if (FPA_InboundSmoothedPAXTerminatingTerminal == null)
                        {
                            FPA_InboundSmoothedPAXTerminatingTerminal = dtAirlineSmoothed.Copy();
                            FPA_InboundSmoothedPAXTerminatingTerminal.TableName = GlobalNames.fpaInboundSmoothedPAXTerminating_Terminal;
                            while (FPA_InboundSmoothedPAXTerminatingTerminal.Columns.Count > 1)
                                FPA_InboundSmoothedPAXTerminatingTerminal.Columns.RemoveAt(1);
                            FPA_InboundSmoothedBagTerminatingTerminal = FPA_InboundSmoothedPAXTerminatingTerminal.Copy();
                            FPA_InboundSmoothedBagTerminatingTerminal.TableName = GlobalNames.fpaInboundSmoothedBagTerminating_Terminal;
                        }
                        if (FPA_InboundInstantaneousPAXTerminatingTerminal == null)
                        {
                            FPA_InboundInstantaneousPAXTerminatingTerminal = dtAirlineInstantaneous.Copy();
                            FPA_InboundInstantaneousPAXTerminatingTerminal.TableName = GlobalNames.fpaInboundInstantaneousPAXTerminating_Terminal;
                            while (FPA_InboundInstantaneousPAXTerminatingTerminal.Columns.Count > 1)
                                FPA_InboundInstantaneousPAXTerminatingTerminal.Columns.RemoveAt(1);
                            FPA_InboundInstantaneousBagTerminatingTerminal = FPA_InboundInstantaneousPAXTerminatingTerminal.Copy();
                            FPA_InboundInstantaneousBagTerminatingTerminal.TableName = GlobalNames.fpaInboundInstantaneousBagTerminating_Terminal;
                        }

                        if (FPA_InboundSmoothedPAXTransferingTerminal == null)
                        {
                            FPA_InboundSmoothedPAXTransferingTerminal = dtAirlineSmoothed.Copy();
                            FPA_InboundSmoothedPAXTransferingTerminal.TableName = GlobalNames.fpaInboundSmoothedPAXTransferring_Terminal;
                            while (FPA_InboundSmoothedPAXTransferingTerminal.Columns.Count > 1)
                                FPA_InboundSmoothedPAXTransferingTerminal.Columns.RemoveAt(1);
                            FPA_InboundSmoothedBagTransferingTerminal = FPA_InboundSmoothedPAXTransferingTerminal.Copy();
                            FPA_InboundSmoothedBagTransferingTerminal.TableName = GlobalNames.fpaInboundSmoothedBagTransferring_Terminal;
                        }
                        if (FPA_InboundInstantaneousPAXTransferingTerminal == null)
                        {
                            FPA_InboundInstantaneousPAXTransferingTerminal = dtAirlineInstantaneous.Copy();
                            FPA_InboundInstantaneousPAXTransferingTerminal.TableName = GlobalNames.fpaInboundInstantaneousPAXTransferring_Terminal;
                            while (FPA_InboundInstantaneousPAXTransferingTerminal.Columns.Count > 1)
                                FPA_InboundInstantaneousPAXTransferingTerminal.Columns.RemoveAt(1);
                            FPA_InboundInstantaneousBagTransferingTerminal = FPA_InboundInstantaneousPAXTransferingTerminal.Copy();
                            FPA_InboundInstantaneousBagTransferingTerminal.TableName = GlobalNames.fpaInboundInstantaneousBagTransferring_Terminal;
                        }

                        if (FPA_TransferICTSmoothedTerminal == null)
                        {
                            FPA_TransferICTSmoothedTerminal = transferICTSmoothedTerminalTable.Copy();
                            FPA_TransferICTSmoothedTerminal.TableName = transferICTSmoothedTerminalTable.TableName + "_Terminal";
                            while (FPA_TransferICTSmoothedTerminal.Columns.Count > 1)
                                FPA_TransferICTSmoothedTerminal.Columns.RemoveAt(1);
                            FPA_TransferICTBagSmoothedTerminal = FPA_TransferICTSmoothedTerminal.Copy();
                            FPA_TransferICTBagSmoothedTerminal.TableName = transferICTSmoothedTerminalTable.TableName + "_Bag_Terminal";
                        }
                        if (FPA_TransferICTInstantaneousTerminal == null)
                        {
                            FPA_TransferICTInstantaneousTerminal = transferICTInstantaneousTerminalTable.Copy();
                            FPA_TransferICTInstantaneousTerminal.TableName = FPA_TransferICTInstantaneousTerminal.TableName + "_Terminal";
                            while (FPA_TransferICTInstantaneousTerminal.Columns.Count > 1)
                                FPA_TransferICTInstantaneousTerminal.Columns.RemoveAt(1);
                            FPA_TransferICTBagInstantaneousTerminal = FPA_TransferICTInstantaneousTerminal.Copy();
                            FPA_TransferICTBagInstantaneousTerminal.TableName = transferICTInstantaneousTerminalTable.TableName + "_Bag_Terminal";
                        }
                        // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                        /*
                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundSmoothed, dtAirlineSmoothed, new int[] { 2 }, sAirlineName + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundInstantaneous, dtAirlineInstantaneous, new int[] { 2 }, sAirlineName + "_");

                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundBagSmoothed, dtAirlineSmoothed, new int[] { 8 }, sAirlineName + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundBagInstantaneous, dtAirlineInstantaneous, new int[] { 8 }, sAirlineName + "_");
                        */

                        // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns                        
                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundSmoothed, dtAirlineSmoothed, new int[] { 2 }, sAirlineName + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundInstantaneous, dtAirlineInstantaneous, new int[] { 2 }, sAirlineName + "_");

                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundBagSmoothed, dtAirlineSmoothed, new int[] { 8 }, sAirlineName + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundBagInstantaneous, dtAirlineInstantaneous, new int[] { 8 }, sAirlineName + "_");
                        // >> Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                        // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundSmoothedBHSTotalTerminal, terminalSmoothedBHS, new int[] { 8 }, sAirline + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundInstantaneousBHSTotalTerminal, terminalInstantaneousBHS, new int[] { 8 }, sAirline + "_");

                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundSmoothedBHSTerminatingTerminal, terminalSmoothedBHS, new int[] { 10 }, sAirline + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundInstantaneousBHSTerminatingTerminal, terminalInstantaneousBHS, new int[] { 10 }, sAirline + "_");

                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundSmoothedBHSTransferingTerminal, terminalSmoothedBHS, new int[] { 12 }, sAirline + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundInstantaneousBHSTransferingTerminal, terminalInstantaneousBHS, new int[] { 12 }, sAirline + "_");
                        // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                        // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                        OverallTools.DataFunctions
                            .ConcateneTable(FPA_InboundSmoothedPAXTerminatingTerminal, dtAirlineSmoothed, new int[] { 4 }, sAirlineName + "_");
                        OverallTools.DataFunctions
                            .ConcateneTable(FPA_InboundInstantaneousPAXTerminatingTerminal, dtAirlineInstantaneous, new int[] { 4 }, sAirlineName + "_");

                        OverallTools.DataFunctions
                            .ConcateneTable(FPA_InboundSmoothedPAXTransferingTerminal, dtAirlineSmoothed, new int[] { 6 }, sAirlineName + "_");
                        OverallTools.DataFunctions
                            .ConcateneTable(FPA_InboundInstantaneousPAXTransferingTerminal, dtAirlineInstantaneous, new int[] { 6 }, sAirlineName + "_");

                        OverallTools.DataFunctions
                            .ConcateneTable(FPA_InboundSmoothedBagTerminatingTerminal, dtAirlineSmoothed, new int[] { 10 }, sAirlineName + "_");
                        OverallTools.DataFunctions
                            .ConcateneTable(FPA_InboundInstantaneousBagTerminatingTerminal, dtAirlineInstantaneous, new int[] { 10 }, sAirlineName + "_");

                        OverallTools.DataFunctions
                            .ConcateneTable(FPA_InboundSmoothedBagTransferingTerminal, dtAirlineSmoothed, new int[] { 12 }, sAirlineName + "_");
                        OverallTools.DataFunctions
                            .ConcateneTable(FPA_InboundInstantaneousBagTransferingTerminal, dtAirlineInstantaneous, new int[] { 12 }, sAirlineName + "_");

                        OverallTools.DataFunctions.ConcateneTable(FPA_TransferICTSmoothedTerminal, transferICTSmoothedTerminalTable, new int[] { 2 }, sAirlineName + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPA_TransferICTInstantaneousTerminal, transferICTInstantaneousTerminalTable, new int[] { 2 }, sAirlineName + "_");

                        OverallTools.DataFunctions.ConcateneTable(FPA_TransferICTBagSmoothedTerminal, transferICTSmoothedTerminalTable, new int[] { 4 }, sAirlineName + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPA_TransferICTBagInstantaneousTerminal, transferICTInstantaneousTerminalTable, new int[] { 4 }, sAirlineName + "_");
                        // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

                        OverallTools.DataFunctions.ConcateneTable(FPD_AircraftMovementsTerminal, dtAircraftMovement, new int[] { 1 }, sAirlineName + "_");
                    }
                    DataTable dtStats = new DataTable("FPA_Terminal_Stats");
                    dtStats.Columns.Add("Terminal", typeof(String));

                    dtStats.Columns.Add("InBound_Smoothed_Pax_Max", typeof(Double));
                    dtStats.Columns.Add("InBound_Instantaneous_Pax_Max", typeof(Double));

                    dtStats.Columns.Add("InBound_Smoothed_Bag_Max", typeof(Double));
                    dtStats.Columns.Add("InBound_Instantaneous_Bag_Max", typeof(Double));
                    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    dtStats.Columns.Add("InBound_Smoothed_BHS_Total_Max", typeof(Double));
                    dtStats.Columns.Add("InBound_Instantaneous_BHS_Total_Max", typeof(Double));

                    dtStats.Columns.Add("InBound_Smoothed_BHS_Terminating_Max", typeof(Double));
                    dtStats.Columns.Add("InBound_Instantaneous_BHS_Terminating_Max", typeof(Double));

                    dtStats.Columns.Add("InBound_Smoothed_BHS_Transfering_Max", typeof(Double));
                    dtStats.Columns.Add("InBound_Instantaneous_BHS_Transfering_Max", typeof(Double));
                    // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    if (FPA_InboundSmoothed != null && FPA_InboundBagSmoothed != null && FPA_InboundSmoothedBHSTotalTerminal != null
                        && FPA_InboundSmoothedBHSTerminatingTerminal != null && FPA_InboundSmoothedBHSTransferingTerminal != null
                        && FPA_InboundInstantaneous != null && FPA_InboundBagInstantaneous != null && FPA_InboundInstantaneousBHSTotalTerminal != null
                        && FPA_InboundInstantaneousBHSTerminatingTerminal != null && FPA_InboundInstantaneousBHSTransferingTerminal != null)
                    {
                        if (FPA_InboundSmoothed.Columns.Count == FPA_InboundBagSmoothed.Columns.Count
                            && FPA_InboundBagSmoothed.Columns.Count == FPA_InboundSmoothedBHSTotalTerminal.Columns.Count
                            && FPA_InboundSmoothedBHSTotalTerminal.Columns.Count == FPA_InboundSmoothedBHSTerminatingTerminal.Columns.Count
                            && FPA_InboundSmoothedBHSTerminatingTerminal.Columns.Count == FPA_InboundSmoothedBHSTransferingTerminal.Columns.Count)
                        {
                            for (i = 1; i < FPA_InboundSmoothed.Columns.Count; i++)
                            {
                                if (alAirline.Count > i - 1)
                                {
                                    DataRow drNewRow = dtStats.NewRow();

                                    drNewRow[0] = alAirline[i - 1].ToString();
                                    drNewRow[1] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundSmoothed, i);
                                    drNewRow[2] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundInstantaneous, i);

                                    drNewRow[3] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundBagSmoothed, i);
                                    drNewRow[4] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundBagInstantaneous, i);

                                    drNewRow[5] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundSmoothedBHSTotalTerminal, i);
                                    drNewRow[6] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundInstantaneousBHSTotalTerminal, i);

                                    drNewRow[7] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundSmoothedBHSTerminatingTerminal, i);
                                    drNewRow[8] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundInstantaneousBHSTerminatingTerminal, i);

                                    drNewRow[9] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundSmoothedBHSTransferingTerminal, i);
                                    drNewRow[10] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundInstantaneousBHSTransferingTerminal, i);

                                    dtStats.Rows.Add(drNewRow);
                                }
                            }
                        }
                    }
                    /*
                                        if (FPA_InboundSmoothed != null)
                                        {
                                            for (i = 1; i < FPA_InboundSmoothed.Columns.Count; i++)
                                            {
                                                DataRow drNewRow = dtStats.NewRow();
                                                drNewRow[0] = alAirline[i - 1].ToString();
                                                drNewRow[1] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundSmoothed, i);
                                                drNewRow[2] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundInstantaneous, i);
                                                drNewRow[3] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundBagSmoothed, i);
                                                drNewRow[4] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundBagInstantaneous, i);
                                                dtStats.Rows.Add(drNewRow);
                                            }
                                        }
                    */
                    // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                    alResult.Add(dtStats);
                    alResult.Add(FPA_InboundSmoothed);
                    alResult.Add(FPA_InboundInstantaneous);

                    alResult.Add(FPA_InboundBagSmoothed);
                    alResult.Add(FPA_InboundBagInstantaneous);

                    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    alResult.Add(FPA_InboundSmoothedBHSTotalTerminal);
                    alResult.Add(FPA_InboundInstantaneousBHSTotalTerminal);

                    alResult.Add(FPA_InboundSmoothedBHSTerminatingTerminal);
                    alResult.Add(FPA_InboundInstantaneousBHSTerminatingTerminal);

                    alResult.Add(FPA_InboundSmoothedBHSTransferingTerminal);
                    alResult.Add(FPA_InboundInstantaneousBHSTransferingTerminal);
                    // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                    // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                    alResult.Add(FPA_InboundSmoothedPAXTerminatingTerminal);
                    alResult.Add(FPA_InboundInstantaneousPAXTerminatingTerminal);

                    alResult.Add(FPA_InboundSmoothedPAXTransferingTerminal);
                    alResult.Add(FPA_InboundInstantaneousPAXTransferingTerminal);

                    alResult.Add(FPA_InboundSmoothedBagTerminatingTerminal);
                    alResult.Add(FPA_InboundInstantaneousBagTerminatingTerminal);

                    alResult.Add(FPA_InboundSmoothedBagTransferingTerminal);
                    alResult.Add(FPA_InboundInstantaneousBagTransferingTerminal);

                    alResult.Add(FPA_TransferICTSmoothedTerminal);
                    alResult.Add(FPA_TransferICTInstantaneousTerminal);

                    alResult.Add(FPA_TransferICTBagSmoothedTerminal);
                    alResult.Add(FPA_TransferICTBagInstantaneousTerminal);
                    // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

                    alResult.Add(FPD_AircraftMovementsTerminal);
                }
                return alResult;
            }


            internal static ArrayList CalcStaticArrivalAnalysisPerFlightCategory(DataTable FPATable,
                DataManagement.NormalTable dtLoadFactors,
                DataManagement.NormalTable TypeAvions,
                DataManagement.NormalTable dtNbBags,
                DataManagement.NormalTable dtNbVisitors,
                DataManagement.NormalTable dtNbTrolley,
                DataManagement.NormalTable dtICTTable,
                // << Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay
                DataManagement.NormalTable dtBaggageLoadingRateTable,
                DataManagement.NormalTable dtBaggageLoadingDelayTable,
                // >> Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay
                DataTable dtFlightCategories,
                DateTime dtBegin,
                DateTime dtEnd,
                Double dStepAnalysis,
                Double dStepCumul,
                ArrayList ListeErreurs,
                GestionDonneesHUB2SIM donnees, // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                               // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                bool bUseDefinedNbPax,
                DataTable dtNumberOfPassengers,
                bool bUseDefinedNbBags,
                DataTable dtNumberOfBaggages
                // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                , double[] distributionLevels   // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                , List<FlightConfiguration> userDefinedFlightConfigurations
                )
            {
                ArrayList alResult = CalcStaticArrivalAnalysis2(FPATable, dtLoadFactors, TypeAvions, dtNbBags,
                    dtNbVisitors, dtNbTrolley, dtICTTable, dtBaggageLoadingRateTable, dtBaggageLoadingDelayTable,   // << Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay
                    dtFlightCategories, dtBegin, dtEnd, dStepAnalysis, dStepCumul, ListeErreurs, donnees,  // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                                                                                           // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                    bUseDefinedNbPax, dtNumberOfPassengers, bUseDefinedNbBags, dtNumberOfBaggages
                    // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                    , distributionLevels, userDefinedFlightConfigurations    // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                    );
                if (alResult == null)
                    return null;
                ArrayList alFlightCategory = new ArrayList();
                int iIndexAirline = FPATable.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightCategory);
                if (iIndexAirline == -1)
                    return alResult;
                int i;
                if (FPATable.Rows.Count != 0)
                {
                    for (i = 0; i < FPATable.Rows.Count; i++)
                    {
                        if (!alFlightCategory.Contains(FPATable.Rows[i][iIndexAirline].ToString()))
                            alFlightCategory.Add(FPATable.Rows[i][iIndexAirline].ToString());
                    }
                    alFlightCategory.Sort(new FonctionUtiles.ColumnsComparer());
                    DataTable dtTmp = FPATable.Clone();
                    DataTable FPD_AircraftMovementsTerminal = null;
                    DataTable FPA_InboundSmoothed = null;
                    DataTable FPA_InboundInstantaneous = null;

                    DataTable FPA_InboundBagSmoothed = null;
                    DataTable FPA_InboundBagInstantaneous = null;
                    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    DataTable FPA_InboundSmoothedBHSTotalFC = null;
                    DataTable FPA_InboundInstantaneousBHSTotalFC = null;

                    DataTable FPA_InboundSmoothedBHSTransferingFC = null;
                    DataTable FPA_InboundInstantaneousBHSTransferingFC = null;

                    DataTable FPA_InboundSmoothedBHSTerminatingFC = null;
                    DataTable FPA_InboundInstantaneousBHSTerminatingFC = null;
                    // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                    // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                    DataTable FPA_InboundSmoothedPAXTerminatingFC = null;
                    DataTable FPA_InboundInstantaneousPAXTerminatingFC = null;

                    DataTable FPA_InboundSmoothedPAXTransferingFC = null;
                    DataTable FPA_InboundInstantaneousPAXTransferingFC = null;

                    DataTable FPA_InboundSmoothedBagTerminatingFC = null;
                    DataTable FPA_InboundInstantaneousBagTerminatingFC = null;

                    DataTable FPA_InboundSmoothedBagTransferingFC = null;
                    DataTable FPA_InboundInstantaneousBagTransferingFC = null;

                    DataTable FPA_TransferICTSmoothedFC = null;
                    DataTable FPA_TransferICTInstantaneousFC = null;

                    DataTable FPA_TransferICTBagSmoothedFC = null;
                    DataTable FPA_TransferICTBagInstantaneousFC = null;
                    // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

                    for (i = 0; i < alFlightCategory.Count; i++)
                    {
                        String sAirline = alFlightCategory[i].ToString();
                        dtTmp.Rows.Clear();
                        foreach (DataRow drTmp in FPATable.Rows)
                        {
                            if (drTmp[iIndexAirline].ToString() == sAirline)
                                dtTmp.Rows.Add(drTmp.ItemArray);
                        }
                        ArrayList alTmp = CalcStaticArrivalAnalysis2(dtTmp, dtLoadFactors, TypeAvions, dtNbBags,
                            dtNbVisitors, dtNbTrolley, dtICTTable, dtBaggageLoadingRateTable, dtBaggageLoadingDelayTable,   // << Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay
                            dtFlightCategories, dtBegin, dtEnd, dStepAnalysis, dStepCumul, ListeErreurs, donnees,  // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                                                                                                   // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                            bUseDefinedNbPax, dtNumberOfPassengers, bUseDefinedNbBags, dtNumberOfBaggages
                            // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                            , distributionLevels, userDefinedFlightConfigurations    // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                            );
                        if (alTmp == null)
                            continue;
                        DataTable dtAircraftMovement = null;
                        DataTable dtAirlineSmoothed = null;
                        DataTable dtAirlineInstantaneous = null;
                        // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                        DataTable flightCategoriesSmoothed = null;
                        DataTable flightCategoriesInstantaneous = null;
                        // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                        // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                        DataTable transferICTSmoothedFCTable = null;
                        DataTable transferICTInstantaneousFCTable = null;
                        // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

                        foreach (DataTable dtTmp2 in alTmp)
                        {
                            if (dtTmp2.TableName == "FPA_InBoundRolling")
                                dtAirlineSmoothed = dtTmp2;

                            if (dtTmp2.TableName == "FPA_InBoundInstantaneous")
                                dtAirlineInstantaneous = dtTmp2;

                            // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                            if (dtTmp2.TableName == GlobalNames.paxGateSmoothedBHSTableName)
                                flightCategoriesSmoothed = dtTmp2;

                            if (dtTmp2.TableName == GlobalNames.paxGateInstantaneousBHSTableName)
                                flightCategoriesInstantaneous = dtTmp2;
                            // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                            // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                            if (dtTmp2.TableName == GlobalNames.FPA_TransferICTSmoothedTableName)
                                transferICTSmoothedFCTable = dtTmp2;

                            if (dtTmp2.TableName == GlobalNames.FPA_TransferICTInstantaneousTableName)
                                transferICTInstantaneousFCTable = dtTmp2;
                            // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

                            if (dtTmp2.TableName == "FPA_AircraftMovementsRolling")
                                dtAircraftMovement = dtTmp2;
                        }
                        if ((dtAirlineSmoothed == null) || (dtAirlineInstantaneous == null))
                            continue;
                        // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                        if ((flightCategoriesSmoothed == null) || (flightCategoriesInstantaneous == null))
                            continue;
                        // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                        // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                        if (transferICTSmoothedFCTable == null || transferICTInstantaneousFCTable == null)
                            continue;
                        // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

                        if (FPA_InboundSmoothed == null)
                        {
                            FPA_InboundSmoothed = dtAirlineSmoothed.Copy();
                            FPA_InboundSmoothed.TableName = FPA_InboundSmoothed.TableName + "_FC";
                            while (FPA_InboundSmoothed.Columns.Count > 1)
                                FPA_InboundSmoothed.Columns.RemoveAt(1);
                            FPA_InboundBagSmoothed = FPA_InboundSmoothed.Copy();
                            FPA_InboundBagSmoothed.TableName = dtAirlineSmoothed.TableName + "_Bag_FC";
                        }
                        if (FPA_InboundInstantaneous == null)
                        {
                            FPA_InboundInstantaneous = dtAirlineInstantaneous.Copy();
                            FPA_InboundInstantaneous.TableName = FPA_InboundInstantaneous.TableName + "_FC";
                            while (FPA_InboundInstantaneous.Columns.Count > 1)
                                FPA_InboundInstantaneous.Columns.RemoveAt(1);
                            FPA_InboundBagInstantaneous = FPA_InboundInstantaneous.Copy();
                            FPA_InboundBagInstantaneous.TableName = dtAirlineInstantaneous.TableName + "_Bag_FC";
                        }
                        // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                        if (FPA_InboundSmoothedBHSTotalFC == null)
                        {
                            FPA_InboundSmoothedBHSTotalFC = flightCategoriesSmoothed.Copy();
                            FPA_InboundSmoothedBHSTotalFC.TableName = FPA_InboundSmoothedBHSTotalFC.TableName + "_Total_FC";
                            while (FPA_InboundSmoothedBHSTotalFC.Columns.Count > 1)
                                FPA_InboundSmoothedBHSTotalFC.Columns.RemoveAt(1);
                        }
                        if (FPA_InboundInstantaneousBHSTotalFC == null)
                        {
                            FPA_InboundInstantaneousBHSTotalFC = flightCategoriesInstantaneous.Copy();
                            FPA_InboundInstantaneousBHSTotalFC.TableName = FPA_InboundInstantaneousBHSTotalFC.TableName + "_Total_FC";
                            while (FPA_InboundInstantaneousBHSTotalFC.Columns.Count > 1)
                                FPA_InboundInstantaneousBHSTotalFC.Columns.RemoveAt(1);
                        }

                        if (FPA_InboundSmoothedBHSTransferingFC == null)
                        {
                            FPA_InboundSmoothedBHSTransferingFC = flightCategoriesSmoothed.Copy();
                            FPA_InboundSmoothedBHSTransferingFC.TableName = FPA_InboundSmoothedBHSTransferingFC.TableName + "_Transfering_FC";
                            while (FPA_InboundSmoothedBHSTransferingFC.Columns.Count > 1)
                                FPA_InboundSmoothedBHSTransferingFC.Columns.RemoveAt(1);
                        }
                        if (FPA_InboundInstantaneousBHSTransferingFC == null)
                        {
                            FPA_InboundInstantaneousBHSTransferingFC = flightCategoriesInstantaneous.Copy();
                            FPA_InboundInstantaneousBHSTransferingFC.TableName = FPA_InboundInstantaneousBHSTransferingFC.TableName + "_Transfering_FC";
                            while (FPA_InboundInstantaneousBHSTransferingFC.Columns.Count > 1)
                                FPA_InboundInstantaneousBHSTransferingFC.Columns.RemoveAt(1);
                        }

                        if (FPA_InboundSmoothedBHSTerminatingFC == null)
                        {
                            FPA_InboundSmoothedBHSTerminatingFC = flightCategoriesSmoothed.Copy();
                            FPA_InboundSmoothedBHSTerminatingFC.TableName = FPA_InboundSmoothedBHSTerminatingFC.TableName + "_Terminating_FC";
                            while (FPA_InboundSmoothedBHSTerminatingFC.Columns.Count > 1)
                                FPA_InboundSmoothedBHSTerminatingFC.Columns.RemoveAt(1);
                        }
                        if (FPA_InboundInstantaneousBHSTerminatingFC == null)
                        {
                            FPA_InboundInstantaneousBHSTerminatingFC = flightCategoriesInstantaneous.Copy();
                            FPA_InboundInstantaneousBHSTerminatingFC.TableName = FPA_InboundInstantaneousBHSTerminatingFC.TableName + "_Terminating_FC";
                            while (FPA_InboundInstantaneousBHSTerminatingFC.Columns.Count > 1)
                                FPA_InboundInstantaneousBHSTerminatingFC.Columns.RemoveAt(1);
                        }
                        // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                        if (FPD_AircraftMovementsTerminal == null)
                        {
                            FPD_AircraftMovementsTerminal = dtAircraftMovement.Copy();
                            FPD_AircraftMovementsTerminal.TableName = "FPA_AircraftMovements_FC";
                            while (FPD_AircraftMovementsTerminal.Columns.Count > 1)
                                FPD_AircraftMovementsTerminal.Columns.RemoveAt(1);
                        }
                        // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                        if (FPA_InboundSmoothedPAXTerminatingFC == null)
                        {
                            FPA_InboundSmoothedPAXTerminatingFC = dtAirlineSmoothed.Copy();
                            FPA_InboundSmoothedPAXTerminatingFC.TableName = GlobalNames.fpaInboundSmoothedPAXTerminating_FC;
                            while (FPA_InboundSmoothedPAXTerminatingFC.Columns.Count > 1)
                                FPA_InboundSmoothedPAXTerminatingFC.Columns.RemoveAt(1);
                            FPA_InboundSmoothedBagTerminatingFC = FPA_InboundSmoothedPAXTerminatingFC.Copy();
                            FPA_InboundSmoothedBagTerminatingFC.TableName = GlobalNames.fpaInboundSmoothedBagTerminating_FC;
                        }
                        if (FPA_InboundInstantaneousPAXTerminatingFC == null)
                        {
                            FPA_InboundInstantaneousPAXTerminatingFC = dtAirlineInstantaneous.Copy();
                            FPA_InboundInstantaneousPAXTerminatingFC.TableName = GlobalNames.fpaInboundInstantaneousPAXTerminating_FC;
                            while (FPA_InboundInstantaneousPAXTerminatingFC.Columns.Count > 1)
                                FPA_InboundInstantaneousPAXTerminatingFC.Columns.RemoveAt(1);
                            FPA_InboundInstantaneousBagTerminatingFC = FPA_InboundInstantaneousPAXTerminatingFC.Copy();
                            FPA_InboundInstantaneousBagTerminatingFC.TableName = GlobalNames.fpaInboundInstantaneousBagTerminating_FC;
                        }

                        if (FPA_InboundSmoothedPAXTransferingFC == null)
                        {
                            FPA_InboundSmoothedPAXTransferingFC = dtAirlineSmoothed.Copy();
                            FPA_InboundSmoothedPAXTransferingFC.TableName = GlobalNames.fpaInboundSmoothedPAXTransfering_FC;
                            while (FPA_InboundSmoothedPAXTransferingFC.Columns.Count > 1)
                                FPA_InboundSmoothedPAXTransferingFC.Columns.RemoveAt(1);
                            FPA_InboundSmoothedBagTransferingFC = FPA_InboundSmoothedPAXTransferingFC.Copy();
                            FPA_InboundSmoothedBagTransferingFC.TableName = GlobalNames.fpaInboundSmoothedBagTransfering_FC;
                        }
                        if (FPA_InboundInstantaneousPAXTransferingFC == null)
                        {
                            FPA_InboundInstantaneousPAXTransferingFC = dtAirlineInstantaneous.Copy();
                            FPA_InboundInstantaneousPAXTransferingFC.TableName = GlobalNames.fpaInboundInstantaneousPAXTransfering_FC;
                            while (FPA_InboundInstantaneousPAXTransferingFC.Columns.Count > 1)
                                FPA_InboundInstantaneousPAXTransferingFC.Columns.RemoveAt(1);
                            FPA_InboundInstantaneousBagTransferingFC = FPA_InboundInstantaneousPAXTransferingFC.Copy();
                            FPA_InboundInstantaneousBagTransferingFC.TableName = GlobalNames.fpaInboundInstantaneousBagTransfering_FC;
                        }

                        if (FPA_TransferICTSmoothedFC == null)
                        {
                            FPA_TransferICTSmoothedFC = transferICTSmoothedFCTable.Copy();
                            FPA_TransferICTSmoothedFC.TableName = transferICTSmoothedFCTable.TableName + "_FC";
                            while (FPA_TransferICTSmoothedFC.Columns.Count > 1)
                                FPA_TransferICTSmoothedFC.Columns.RemoveAt(1);
                            FPA_TransferICTBagSmoothedFC = FPA_TransferICTSmoothedFC.Copy();
                            FPA_TransferICTBagSmoothedFC.TableName = transferICTSmoothedFCTable.TableName + "_Bag_FC";
                        }
                        if (FPA_TransferICTInstantaneousFC == null)
                        {
                            FPA_TransferICTInstantaneousFC = transferICTInstantaneousFCTable.Copy();
                            FPA_TransferICTInstantaneousFC.TableName = FPA_TransferICTInstantaneousFC.TableName + "_FC";
                            while (FPA_TransferICTInstantaneousFC.Columns.Count > 1)
                                FPA_TransferICTInstantaneousFC.Columns.RemoveAt(1);
                            FPA_TransferICTBagInstantaneousFC = FPA_TransferICTInstantaneousFC.Copy();
                            FPA_TransferICTBagInstantaneousFC.TableName = transferICTInstantaneousFCTable.TableName + "_Bag_FC";
                        }
                        // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

                        // << Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns                        
                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundSmoothed, dtAirlineSmoothed, new int[] { 2 }, sAirline + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundInstantaneous, dtAirlineInstantaneous, new int[] { 2 }, sAirline + "_");

                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundBagSmoothed, dtAirlineSmoothed, new int[] { 8 }, sAirline + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundBagInstantaneous, dtAirlineInstantaneous, new int[] { 8 }, sAirline + "_");
                        // >> Task #9099 Pax2Sim - Static Analysis - FPA/FPD/FPA+FPD Stats - input and throughput columns

                        // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundSmoothedBHSTotalFC, flightCategoriesSmoothed, new int[] { 8 }, sAirline + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundInstantaneousBHSTotalFC, flightCategoriesInstantaneous, new int[] { 8 }, sAirline + "_");

                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundSmoothedBHSTerminatingFC, flightCategoriesSmoothed, new int[] { 10 }, sAirline + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundInstantaneousBHSTerminatingFC, flightCategoriesInstantaneous, new int[] { 10 }, sAirline + "_");

                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundSmoothedBHSTransferingFC, flightCategoriesSmoothed, new int[] { 12 }, sAirline + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPA_InboundInstantaneousBHSTransferingFC, flightCategoriesInstantaneous, new int[] { 12 }, sAirline + "_");
                        // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                        // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                        OverallTools.DataFunctions
                            .ConcateneTable(FPA_InboundSmoothedPAXTerminatingFC, dtAirlineSmoothed, new int[] { 4 }, sAirline + "_");
                        OverallTools.DataFunctions
                            .ConcateneTable(FPA_InboundInstantaneousPAXTerminatingFC, dtAirlineInstantaneous, new int[] { 4 }, sAirline + "_");

                        OverallTools.DataFunctions
                            .ConcateneTable(FPA_InboundSmoothedPAXTransferingFC, dtAirlineSmoothed, new int[] { 6 }, sAirline + "_");
                        OverallTools.DataFunctions
                            .ConcateneTable(FPA_InboundInstantaneousPAXTransferingFC, dtAirlineInstantaneous, new int[] { 6 }, sAirline + "_");

                        OverallTools.DataFunctions
                            .ConcateneTable(FPA_InboundSmoothedBagTerminatingFC, dtAirlineSmoothed, new int[] { 10 }, sAirline + "_");
                        OverallTools.DataFunctions
                            .ConcateneTable(FPA_InboundInstantaneousBagTerminatingFC, dtAirlineInstantaneous, new int[] { 10 }, sAirline + "_");

                        OverallTools.DataFunctions
                            .ConcateneTable(FPA_InboundSmoothedBagTransferingFC, dtAirlineSmoothed, new int[] { 12 }, sAirline + "_");
                        OverallTools.DataFunctions
                            .ConcateneTable(FPA_InboundInstantaneousBagTransferingFC, dtAirlineInstantaneous, new int[] { 12 }, sAirline + "_");

                        OverallTools.DataFunctions.ConcateneTable(FPA_TransferICTSmoothedFC, transferICTSmoothedFCTable, new int[] { 2 }, sAirline + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPA_TransferICTInstantaneousFC, transferICTInstantaneousFCTable, new int[] { 2 }, sAirline + "_");

                        OverallTools.DataFunctions.ConcateneTable(FPA_TransferICTBagSmoothedFC, transferICTSmoothedFCTable, new int[] { 4 }, sAirline + "_");
                        OverallTools.DataFunctions.ConcateneTable(FPA_TransferICTBagInstantaneousFC, transferICTInstantaneousFCTable, new int[] { 4 }, sAirline + "_");
                        // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

                        OverallTools.DataFunctions.ConcateneTable(FPD_AircraftMovementsTerminal, dtAircraftMovement, new int[] { 1 }, sAirline + "_");
                    }
                    DataTable dtStats = new DataTable("FPA_FC_Stats");
                    dtStats.Columns.Add("FlightCategory", typeof(String));

                    dtStats.Columns.Add("InBound_Smoothed_Pax_Max", typeof(Double));
                    dtStats.Columns.Add("InBound_Instantaneous_Pax_Max", typeof(Double));

                    dtStats.Columns.Add("InBound_Smoothed_Bag_Max", typeof(Double));
                    dtStats.Columns.Add("InBound_Instantaneous_Bag_Max", typeof(Double));

                    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    dtStats.Columns.Add("InBound_Smoothed_BHS_Total_Max", typeof(Double));
                    dtStats.Columns.Add("InBound_Instantaneous_BHS_Total_Max", typeof(Double));

                    dtStats.Columns.Add("InBound_Smoothed_BHS_Terminating_Max", typeof(Double));
                    dtStats.Columns.Add("InBound_Instantaneous_BHS_Terminating_Max", typeof(Double));

                    dtStats.Columns.Add("InBound_Smoothed_BHS_Transfering_Max", typeof(Double));
                    dtStats.Columns.Add("InBound_Instantaneous_BHS_Transfering_Max", typeof(Double));
                    // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    if (FPA_InboundSmoothed != null && FPA_InboundBagSmoothed != null && FPA_InboundSmoothedBHSTotalFC != null
                        && FPA_InboundSmoothedBHSTerminatingFC != null && FPA_InboundSmoothedBHSTransferingFC != null
                        && FPA_InboundInstantaneous != null && FPA_InboundBagInstantaneous != null && FPA_InboundInstantaneousBHSTotalFC != null
                        && FPA_InboundInstantaneousBHSTerminatingFC != null && FPA_InboundInstantaneousBHSTransferingFC != null)
                    {
                        if (FPA_InboundSmoothed.Columns.Count == FPA_InboundBagSmoothed.Columns.Count
                            && FPA_InboundBagSmoothed.Columns.Count == FPA_InboundSmoothedBHSTotalFC.Columns.Count
                            && FPA_InboundSmoothedBHSTotalFC.Columns.Count == FPA_InboundSmoothedBHSTerminatingFC.Columns.Count
                            && FPA_InboundSmoothedBHSTerminatingFC.Columns.Count == FPA_InboundSmoothedBHSTransferingFC.Columns.Count)
                        {
                            for (i = 1; i < FPA_InboundSmoothed.Columns.Count; i++)
                            {
                                if (alFlightCategory.Count > i - 1)
                                {
                                    DataRow drNewRow = dtStats.NewRow();

                                    drNewRow[0] = alFlightCategory[i - 1].ToString();
                                    drNewRow[1] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundSmoothed, i);
                                    drNewRow[2] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundInstantaneous, i);

                                    drNewRow[3] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundBagSmoothed, i);
                                    drNewRow[4] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundBagInstantaneous, i);

                                    drNewRow[5] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundSmoothedBHSTotalFC, i);
                                    drNewRow[6] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundInstantaneousBHSTotalFC, i);

                                    drNewRow[7] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundSmoothedBHSTerminatingFC, i);
                                    drNewRow[8] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundInstantaneousBHSTerminatingFC, i);

                                    drNewRow[9] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundSmoothedBHSTransferingFC, i);
                                    drNewRow[10] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundInstantaneousBHSTransferingFC, i);

                                    dtStats.Rows.Add(drNewRow);
                                }
                            }
                        }
                    }
                    /*
                    if (FPA_InboundSmoothed != null)
                    {
                        for (i = 1; i < FPA_InboundSmoothed.Columns.Count; i++)
                        {
                            DataRow drNewRow = dtStats.NewRow();
                            drNewRow[0] = alFlightCategory[i - 1].ToString();
                            drNewRow[1] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundSmoothed, i);
                            drNewRow[2] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundInstantaneous, i);
                            drNewRow[3] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundBagSmoothed, i);
                            drNewRow[4] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundBagInstantaneous, i);
                            dtStats.Rows.Add(drNewRow);
                        }
                    }*/
                    // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                    alResult.Add(dtStats);
                    alResult.Add(FPA_InboundSmoothed);
                    alResult.Add(FPA_InboundInstantaneous);

                    alResult.Add(FPA_InboundBagSmoothed);
                    alResult.Add(FPA_InboundBagInstantaneous);

                    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                    alResult.Add(FPA_InboundSmoothedBHSTotalFC);
                    alResult.Add(FPA_InboundInstantaneousBHSTotalFC);

                    alResult.Add(FPA_InboundSmoothedBHSTerminatingFC);
                    alResult.Add(FPA_InboundInstantaneousBHSTerminatingFC);

                    alResult.Add(FPA_InboundSmoothedBHSTransferingFC);
                    alResult.Add(FPA_InboundInstantaneousBHSTransferingFC);
                    // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                    // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
                    alResult.Add(FPA_InboundSmoothedPAXTerminatingFC);
                    alResult.Add(FPA_InboundInstantaneousPAXTerminatingFC);

                    alResult.Add(FPA_InboundSmoothedPAXTransferingFC);
                    alResult.Add(FPA_InboundInstantaneousPAXTransferingFC);

                    alResult.Add(FPA_InboundSmoothedBagTerminatingFC);
                    alResult.Add(FPA_InboundInstantaneousBagTerminatingFC);

                    alResult.Add(FPA_InboundSmoothedBagTransferingFC);
                    alResult.Add(FPA_InboundInstantaneousBagTransferingFC);

                    alResult.Add(FPA_TransferICTSmoothedFC);
                    alResult.Add(FPA_TransferICTInstantaneousFC);

                    alResult.Add(FPA_TransferICTBagSmoothedFC);
                    alResult.Add(FPA_TransferICTBagInstantaneousFC);
                    // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

                    alResult.Add(FPD_AircraftMovementsTerminal);
                }
                return alResult;
            }

            // << Task #9504 Pax2Sim - flight subCategories - peak flow segregation
            internal static ArrayList CalcStaticArrivalAnalysisPerFlightSubcategory(DataTable FPATable,
                DataManagement.NormalTable dtLoadFactors, DataManagement.NormalTable TypeAvions,
                DataManagement.NormalTable dtNbBags, DataManagement.NormalTable dtNbVisitors, DataManagement.NormalTable dtNbTrolley,
                DataManagement.NormalTable dtICTTable,
                // << Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay
                DataManagement.NormalTable dtBaggageLoadingRateTable,
                DataManagement.NormalTable dtBaggageLoadingDelayTable,
                // >> Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay
                DataTable dtFlightCategories, DataTable flightSubcategoriesTable,
                DateTime dtBegin, DateTime dtEnd, Double dStepAnalysis, Double dStepCumul,
                ArrayList ListeErreurs, GestionDonneesHUB2SIM donnees,
                // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                bool bUseDefinedNbPax,
                DataTable dtNumberOfPassengers,
                bool bUseDefinedNbBags,
                DataTable dtNumberOfBaggages
                // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                , double[] distributionLevels   // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                , List<FlightConfiguration> userDefinedFlightConfigurations
                )
            {
                ArrayList resultsList = new ArrayList();

                if (FPATable.Rows.Count > 0)
                {
                    //K: flightCategory, V: nb of flights for the FC
                    Dictionary<String, int> nbFlightsByFlightCategoryDictionary =
                        countNbOfFlightsByFlightCategories(FPATable);

                    // >> Task #9915 Pax2Sim - BNP development - Peak Flows - USA Standard directory                    
                    /*
                                        //K: Flight subcategory, V: corresponding Flight Category
                                        Dictionary<String, String> flightSubcategoriesLinkDictionary =
                                            getLinkBetweenFlightSubcatAndFlightCat(flightSubcategoriesTable, nbFlightsByFlightCategoryDictionary);

                                        //K: Flight subcategory, V: nb of flights for the subcategory
                                        Dictionary<String, int> nbFlightsByFlightSubcategoriesDictionary =
                                            countNbOfFLightsByFlightSubcategory(flightSubcategoriesTable, nbFlightsByFlightCategoryDictionary,
                                                                                    flightSubcategoriesLinkDictionary);
                                        //K: FlightId, V: flight subcategory
                                        Dictionary<FlightInformation, String> flightsDictionary =
                                            assignFlightSubcategoryToFlight(FPATable, nbFlightsByFlightSubcategoriesDictionary,
                                                                                flightSubcategoriesLinkDictionary);
                    */
                    // << Task #9915 Pax2Sim - BNP development - Peak Flows - USA Standard directory

                    //K:FlightSubcategory, V:Dict<FlightCategory, nb of flights for the FlightSUBcategory
                    Dictionary<String, Dictionary<String, int>> flightSubcategoriesAndFlightCategoriesWithNbFlightsPerFSCDictionary
                        = getLinkBetweenFlightSubcatAnd_FCwithNbFlightsForFSC(flightSubcategoriesTable, nbFlightsByFlightCategoryDictionary, FPATable.Rows.Count);

                    Dictionary<FlightInformation, String> flightsDictionary = assignFlightSubcategoryToFlight(FPATable,
                        flightSubcategoriesAndFlightCategoriesWithNbFlightsPerFSCDictionary);
                    // << Task #9915 Pax2Sim - BNP development - Peak Flows - USA Standard directory

                    DataTable FPA_flightInformationTable = createFlightInformationTable(flightsDictionary,
                                                                                            GlobalNames.FPA_table_preffix);
                    if (FPA_flightInformationTable != null)
                        resultsList.Add(FPA_flightInformationTable);

                    #region create the tables needed for the segregation

                    DataTable FPA_AircraftMovementsFSC = null;

                    DataTable FPA_InboundSmoothed = null;
                    DataTable FPA_InboundInstantaneous = null;

                    DataTable FPA_InboundSmoothedPAXTerminatingFSC = null;
                    DataTable FPA_InboundInstantaneousPAXTerminatingFSC = null;

                    DataTable FPA_InboundSmoothedPAXTransferringFSC = null;
                    DataTable FPA_InboundInstantaneousPAXTransferringFSC = null;

                    DataTable FPA_InboundBagSmoothed = null;
                    DataTable FPA_InboundBagInstantaneous = null;

                    DataTable FPA_InboundSmoothedBagTerminatingFSC = null;
                    DataTable FPA_InboundInstantaneousBagTerminatingFSC = null;

                    DataTable FPA_InboundSmoothedBagTransferringFSC = null;
                    DataTable FPA_InboundInstantaneousBagTransferringFSC = null;

                    DataTable FPA_InboundSmoothedBHSTotalFSC = null;
                    DataTable FPA_InboundInstantaneousBHSTotalFSC = null;

                    DataTable FPA_InboundSmoothedBHSTransferingFSC = null;
                    DataTable FPA_InboundInstantaneousBHSTransferingFSC = null;

                    DataTable FPA_InboundSmoothedBHSTerminatingFSC = null;
                    DataTable FPA_InboundInstantaneousBHSTerminatingFSC = null;

                    DataTable FPA_TransferICTSmoothedFSC = null;
                    DataTable FPA_TransferICTInstantaneousFSC = null;

                    DataTable FPA_TransferICTBagSmoothedFSC = null;
                    DataTable FPA_TransferICTBagInstantaneousFSC = null;

                    foreach (String flightSubcategory in flightSubcategoriesAndFlightCategoriesWithNbFlightsPerFSCDictionary.Keys)
                    {
                        DataTable tempFlightPlan = filterFlightPlanByFlightSubcategory(FPATable, flightSubcategory,
                                                                                        flightsDictionary);
                        if (tempFlightPlan != null && tempFlightPlan.Columns.Count > 0
                            && tempFlightPlan.Rows.Count > 0)
                        {
                            //call a function that creates the tables needed for the segregation
                            ArrayList staticAnalysisTablesList = CalcStaticArrivalAnalysis2(tempFlightPlan, dtLoadFactors,
                                TypeAvions, dtNbBags, dtNbVisitors, dtNbTrolley, dtICTTable, dtBaggageLoadingRateTable,
                                dtBaggageLoadingDelayTable,   // << Task #9121 Pax2Sim - Scenario Properties params - Loading Rate/Delay
                                dtFlightCategories, dtBegin, dtEnd, dStepAnalysis, dStepCumul, ListeErreurs, donnees,  // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                                                                                                       // << Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                                bUseDefinedNbPax, dtNumberOfPassengers, bUseDefinedNbBags, dtNumberOfBaggages
                                // >> Task #9536 Pax2Sim - table to specify direct the nb of different types of pax(orig, transf...)
                                , distributionLevels, userDefinedFlightConfigurations    // >> Task #10720 Pax2Sim - Static analysis - redesign Peak flow statistics
                                );

                            if (staticAnalysisTablesList == null)
                                continue;

                            DataTable dtAircraftMovement = null;
                            DataTable dtAirlineSmoothed = null;
                            DataTable dtAirlineInstantaneous = null;
                            DataTable flightCategoriesSmoothed = null;
                            DataTable flightCategoriesInstantaneous = null;
                            DataTable transferICTSmoothed = null;
                            DataTable transferICTInstantaneous = null;

                            foreach (DataTable dtTmp2 in staticAnalysisTablesList)
                            {
                                if (dtTmp2.TableName == "FPA_InBoundRolling")
                                    dtAirlineSmoothed = dtTmp2;

                                if (dtTmp2.TableName == "FPA_InBoundInstantaneous")
                                    dtAirlineInstantaneous = dtTmp2;

                                if (dtTmp2.TableName == GlobalNames.paxGateSmoothedBHSTableName)
                                    flightCategoriesSmoothed = dtTmp2;

                                if (dtTmp2.TableName == GlobalNames.paxGateInstantaneousBHSTableName)
                                    flightCategoriesInstantaneous = dtTmp2;

                                if (dtTmp2.TableName == GlobalNames.FPA_TransferICTSmoothedTableName)
                                    transferICTSmoothed = dtTmp2;

                                if (dtTmp2.TableName == GlobalNames.FPA_TransferICTInstantaneousTableName)
                                    transferICTInstantaneous = dtTmp2;

                                if (dtTmp2.TableName == "FPA_AircraftMovementsRolling")
                                    dtAircraftMovement = dtTmp2;
                            }
                            if ((dtAirlineSmoothed == null) || (dtAirlineInstantaneous == null))
                                continue;

                            if ((flightCategoriesSmoothed == null) || (flightCategoriesInstantaneous == null))
                                continue;

                            if (transferICTSmoothed == null || transferICTInstantaneous == null)
                                continue;

                            if (FPA_InboundSmoothed == null)
                            {
                                FPA_InboundSmoothed = dtAirlineSmoothed.Copy();
                                FPA_InboundSmoothed.TableName = FPA_InboundSmoothed.TableName + "_FSC";
                                while (FPA_InboundSmoothed.Columns.Count > 1)
                                    FPA_InboundSmoothed.Columns.RemoveAt(1);
                                FPA_InboundBagSmoothed = FPA_InboundSmoothed.Copy();
                                FPA_InboundBagSmoothed.TableName = dtAirlineSmoothed.TableName + "_Bag_FSC";
                            }
                            if (FPA_InboundInstantaneous == null)
                            {
                                FPA_InboundInstantaneous = dtAirlineInstantaneous.Copy();
                                FPA_InboundInstantaneous.TableName = FPA_InboundInstantaneous.TableName + "_FSC";
                                while (FPA_InboundInstantaneous.Columns.Count > 1)
                                    FPA_InboundInstantaneous.Columns.RemoveAt(1);
                                FPA_InboundBagInstantaneous = FPA_InboundInstantaneous.Copy();
                                FPA_InboundBagInstantaneous.TableName = dtAirlineInstantaneous.TableName + "_Bag_FSC";
                            }

                            if (FPA_InboundSmoothedPAXTerminatingFSC == null)
                            {
                                FPA_InboundSmoothedPAXTerminatingFSC = dtAirlineSmoothed.Copy();
                                FPA_InboundSmoothedPAXTerminatingFSC.TableName = GlobalNames.fpaInboundSmoothedPAXTerminating_FSC;
                                while (FPA_InboundSmoothedPAXTerminatingFSC.Columns.Count > 1)
                                    FPA_InboundSmoothedPAXTerminatingFSC.Columns.RemoveAt(1);
                                FPA_InboundSmoothedBagTerminatingFSC = FPA_InboundSmoothedPAXTerminatingFSC.Copy();
                                FPA_InboundSmoothedBagTerminatingFSC.TableName = GlobalNames.fpaInboundSmoothedBagTerminating_FSC;
                            }
                            if (FPA_InboundInstantaneousPAXTerminatingFSC == null)
                            {
                                FPA_InboundInstantaneousPAXTerminatingFSC = dtAirlineInstantaneous.Copy();
                                FPA_InboundInstantaneousPAXTerminatingFSC.TableName = GlobalNames.fpaInboundInstantaneousPAXTerminating_FSC;
                                while (FPA_InboundInstantaneousPAXTerminatingFSC.Columns.Count > 1)
                                    FPA_InboundInstantaneousPAXTerminatingFSC.Columns.RemoveAt(1);
                                FPA_InboundInstantaneousBagTerminatingFSC = FPA_InboundInstantaneousPAXTerminatingFSC.Copy();
                                FPA_InboundInstantaneousBagTerminatingFSC.TableName = GlobalNames.fpaInboundInstantaneousBagTerminating_FSC;
                            }

                            if (FPA_InboundSmoothedPAXTransferringFSC == null)
                            {
                                FPA_InboundSmoothedPAXTransferringFSC = dtAirlineSmoothed.Copy();
                                FPA_InboundSmoothedPAXTransferringFSC.TableName = GlobalNames.fpaInboundSmoothedPAXTransfering_FSC;
                                while (FPA_InboundSmoothedPAXTransferringFSC.Columns.Count > 1)
                                    FPA_InboundSmoothedPAXTransferringFSC.Columns.RemoveAt(1);
                                FPA_InboundSmoothedBagTransferringFSC = FPA_InboundSmoothedPAXTransferringFSC.Copy();
                                FPA_InboundSmoothedBagTransferringFSC.TableName = GlobalNames.fpaInboundSmoothedBagTransfering_FSC;
                            }
                            if (FPA_InboundInstantaneousPAXTransferringFSC == null)
                            {
                                FPA_InboundInstantaneousPAXTransferringFSC = dtAirlineInstantaneous.Copy();
                                FPA_InboundInstantaneousPAXTransferringFSC.TableName = GlobalNames.fpaInboundInstantaneousPAXTransfering_FSC;
                                while (FPA_InboundInstantaneousPAXTransferringFSC.Columns.Count > 1)
                                    FPA_InboundInstantaneousPAXTransferringFSC.Columns.RemoveAt(1);
                                FPA_InboundInstantaneousBagTransferringFSC = FPA_InboundInstantaneousPAXTransferringFSC.Copy();
                                FPA_InboundInstantaneousBagTransferringFSC.TableName = GlobalNames.fpaInboundInstantaneousBagTransfering_FSC;
                            }

                            if (FPA_InboundSmoothedBHSTotalFSC == null)
                            {
                                FPA_InboundSmoothedBHSTotalFSC = flightCategoriesSmoothed.Copy();
                                FPA_InboundSmoothedBHSTotalFSC.TableName = FPA_InboundSmoothedBHSTotalFSC.TableName + "_Total_FSC";
                                while (FPA_InboundSmoothedBHSTotalFSC.Columns.Count > 1)
                                    FPA_InboundSmoothedBHSTotalFSC.Columns.RemoveAt(1);
                            }
                            if (FPA_InboundInstantaneousBHSTotalFSC == null)
                            {
                                FPA_InboundInstantaneousBHSTotalFSC = flightCategoriesInstantaneous.Copy();
                                FPA_InboundInstantaneousBHSTotalFSC.TableName = FPA_InboundInstantaneousBHSTotalFSC.TableName + "_Total_FSC";
                                while (FPA_InboundInstantaneousBHSTotalFSC.Columns.Count > 1)
                                    FPA_InboundInstantaneousBHSTotalFSC.Columns.RemoveAt(1);
                            }

                            if (FPA_InboundSmoothedBHSTransferingFSC == null)
                            {
                                FPA_InboundSmoothedBHSTransferingFSC = flightCategoriesSmoothed.Copy();
                                FPA_InboundSmoothedBHSTransferingFSC.TableName = FPA_InboundSmoothedBHSTransferingFSC.TableName + "_Transfering_FSC";
                                while (FPA_InboundSmoothedBHSTransferingFSC.Columns.Count > 1)
                                    FPA_InboundSmoothedBHSTransferingFSC.Columns.RemoveAt(1);
                            }
                            if (FPA_InboundInstantaneousBHSTransferingFSC == null)
                            {
                                FPA_InboundInstantaneousBHSTransferingFSC = flightCategoriesInstantaneous.Copy();
                                FPA_InboundInstantaneousBHSTransferingFSC.TableName = FPA_InboundInstantaneousBHSTransferingFSC.TableName + "_Transfering_FSC";
                                while (FPA_InboundInstantaneousBHSTransferingFSC.Columns.Count > 1)
                                    FPA_InboundInstantaneousBHSTransferingFSC.Columns.RemoveAt(1);
                            }

                            if (FPA_InboundSmoothedBHSTerminatingFSC == null)
                            {
                                FPA_InboundSmoothedBHSTerminatingFSC = flightCategoriesSmoothed.Copy();
                                FPA_InboundSmoothedBHSTerminatingFSC.TableName = FPA_InboundSmoothedBHSTerminatingFSC.TableName + "_Terminating_FSC";
                                while (FPA_InboundSmoothedBHSTerminatingFSC.Columns.Count > 1)
                                    FPA_InboundSmoothedBHSTerminatingFSC.Columns.RemoveAt(1);
                            }
                            if (FPA_InboundInstantaneousBHSTerminatingFSC == null)
                            {
                                FPA_InboundInstantaneousBHSTerminatingFSC = flightCategoriesInstantaneous.Copy();
                                FPA_InboundInstantaneousBHSTerminatingFSC.TableName = FPA_InboundInstantaneousBHSTerminatingFSC.TableName + "_Terminating_FSC";
                                while (FPA_InboundInstantaneousBHSTerminatingFSC.Columns.Count > 1)
                                    FPA_InboundInstantaneousBHSTerminatingFSC.Columns.RemoveAt(1);
                            }
                            if (FPA_TransferICTSmoothedFSC == null)
                            {
                                FPA_TransferICTSmoothedFSC = transferICTSmoothed.Copy();
                                FPA_TransferICTSmoothedFSC.TableName = FPA_TransferICTSmoothedFSC + "_FSC";
                                while (FPA_TransferICTSmoothedFSC.Columns.Count > 1)
                                    FPA_TransferICTSmoothedFSC.Columns.RemoveAt(1);
                                FPA_TransferICTBagSmoothedFSC = FPA_TransferICTSmoothedFSC.Copy();
                                FPA_TransferICTBagSmoothedFSC.TableName = transferICTSmoothed.TableName + "_Bag_FSC";
                            }
                            if (FPA_TransferICTInstantaneousFSC == null)
                            {
                                FPA_TransferICTInstantaneousFSC = transferICTInstantaneous.Copy();
                                FPA_TransferICTInstantaneousFSC.TableName = FPA_TransferICTInstantaneousFSC + "_FSC";
                                while (FPA_TransferICTInstantaneousFSC.Columns.Count > 1)
                                    FPA_TransferICTInstantaneousFSC.Columns.RemoveAt(1);
                                FPA_TransferICTBagInstantaneousFSC = FPA_TransferICTInstantaneousFSC.Copy();
                                FPA_TransferICTBagInstantaneousFSC.TableName = transferICTInstantaneous.TableName + "_Bag_FSC";
                            }
                            if (FPA_AircraftMovementsFSC == null)
                            {
                                FPA_AircraftMovementsFSC = dtAircraftMovement.Copy();
                                FPA_AircraftMovementsFSC.TableName = "FPA_AircraftMovements_FSC";
                                while (FPA_AircraftMovementsFSC.Columns.Count > 1)
                                    FPA_AircraftMovementsFSC.Columns.RemoveAt(1);
                            }

                            OverallTools.DataFunctions.ConcateneTable(FPA_InboundSmoothed, dtAirlineSmoothed, new int[] { 2 }, flightSubcategory + "_");
                            OverallTools.DataFunctions.ConcateneTable(FPA_InboundInstantaneous, dtAirlineInstantaneous, new int[] { 2 }, flightSubcategory + "_");

                            OverallTools.DataFunctions.ConcateneTable(FPA_InboundSmoothedPAXTerminatingFSC, dtAirlineSmoothed, new int[] { 4 }, flightSubcategory + "_");
                            OverallTools.DataFunctions.ConcateneTable(FPA_InboundInstantaneousPAXTerminatingFSC, dtAirlineInstantaneous, new int[] { 4 }, flightSubcategory + "_");

                            OverallTools.DataFunctions.ConcateneTable(FPA_InboundSmoothedPAXTransferringFSC, dtAirlineSmoothed, new int[] { 6 }, flightSubcategory + "_");
                            OverallTools.DataFunctions.ConcateneTable(FPA_InboundInstantaneousPAXTransferringFSC, dtAirlineInstantaneous, new int[] { 6 }, flightSubcategory + "_");

                            OverallTools.DataFunctions.ConcateneTable(FPA_InboundBagSmoothed, dtAirlineSmoothed, new int[] { 8 }, flightSubcategory + "_");
                            OverallTools.DataFunctions.ConcateneTable(FPA_InboundBagInstantaneous, dtAirlineInstantaneous, new int[] { 8 }, flightSubcategory + "_");

                            OverallTools.DataFunctions.ConcateneTable(FPA_InboundSmoothedBagTerminatingFSC, dtAirlineSmoothed, new int[] { 10 }, flightSubcategory + "_");
                            OverallTools.DataFunctions.ConcateneTable(FPA_InboundInstantaneousBagTerminatingFSC, dtAirlineInstantaneous, new int[] { 10 }, flightSubcategory + "_");

                            OverallTools.DataFunctions.ConcateneTable(FPA_InboundSmoothedBagTransferringFSC, dtAirlineSmoothed, new int[] { 12 }, flightSubcategory + "_");
                            OverallTools.DataFunctions.ConcateneTable(FPA_InboundInstantaneousBagTransferringFSC, dtAirlineInstantaneous, new int[] { 12 }, flightSubcategory + "_");

                            OverallTools.DataFunctions.ConcateneTable(FPA_InboundSmoothedBHSTotalFSC, flightCategoriesSmoothed, new int[] { 8 }, flightSubcategory + "_");
                            OverallTools.DataFunctions.ConcateneTable(FPA_InboundInstantaneousBHSTotalFSC, flightCategoriesInstantaneous, new int[] { 8 }, flightSubcategory + "_");

                            OverallTools.DataFunctions.ConcateneTable(FPA_InboundSmoothedBHSTerminatingFSC, flightCategoriesSmoothed, new int[] { 10 }, flightSubcategory + "_");
                            OverallTools.DataFunctions.ConcateneTable(FPA_InboundInstantaneousBHSTerminatingFSC, flightCategoriesInstantaneous, new int[] { 10 }, flightSubcategory + "_");

                            OverallTools.DataFunctions.ConcateneTable(FPA_InboundSmoothedBHSTransferingFSC, flightCategoriesSmoothed, new int[] { 12 }, flightSubcategory + "_");
                            OverallTools.DataFunctions.ConcateneTable(FPA_InboundInstantaneousBHSTransferingFSC, flightCategoriesInstantaneous, new int[] { 12 }, flightSubcategory + "_");

                            OverallTools.DataFunctions.ConcateneTable(FPA_TransferICTSmoothedFSC, transferICTSmoothed, new int[] { 2 }, flightSubcategory + "_");
                            OverallTools.DataFunctions.ConcateneTable(FPA_TransferICTInstantaneousFSC, transferICTInstantaneous, new int[] { 2 }, flightSubcategory + "_");

                            OverallTools.DataFunctions.ConcateneTable(FPA_TransferICTBagSmoothedFSC, transferICTSmoothed, new int[] { 4 }, flightSubcategory + "_");
                            OverallTools.DataFunctions.ConcateneTable(FPA_TransferICTBagInstantaneousFSC, transferICTInstantaneous, new int[] { 4 }, flightSubcategory + "_");

                            OverallTools.DataFunctions.ConcateneTable(FPA_AircraftMovementsFSC, dtAircraftMovement, new int[] { 1 }, flightSubcategory + "_");
                        }
                    }
                    DataTable dtStats = new DataTable("FPA_FSC_Stats");
                    dtStats.Columns.Add("FlightSubCategory", typeof(String));
                    dtStats.Columns.Add("InBound_Smoothed_Pax_Max", typeof(Double));
                    dtStats.Columns.Add("InBound_Instantaneous_Pax_Max", typeof(Double));
                    dtStats.Columns.Add("InBound_Smoothed_Bag_Max", typeof(Double));
                    dtStats.Columns.Add("InBound_Instantaneous_Bag_Max", typeof(Double));
                    dtStats.Columns.Add("InBound_Smoothed_BHS_Total_Max", typeof(Double));
                    dtStats.Columns.Add("InBound_Instantaneous_BHS_Total_Max", typeof(Double));
                    dtStats.Columns.Add("InBound_Smoothed_BHS_Terminating_Max", typeof(Double));
                    dtStats.Columns.Add("InBound_Instantaneous_BHS_Terminating_Max", typeof(Double));
                    dtStats.Columns.Add("InBound_Smoothed_BHS_Transfering_Max", typeof(Double));
                    dtStats.Columns.Add("InBound_Instantaneous_BHS_Transfering_Max", typeof(Double));

                    if (FPA_InboundSmoothed != null && FPA_InboundBagSmoothed != null && FPA_InboundSmoothedBHSTotalFSC != null
                        && FPA_InboundSmoothedBHSTerminatingFSC != null && FPA_InboundSmoothedBHSTransferingFSC != null
                        && FPA_InboundInstantaneous != null && FPA_InboundBagInstantaneous != null && FPA_InboundInstantaneousBHSTotalFSC != null
                        && FPA_InboundInstantaneousBHSTerminatingFSC != null && FPA_InboundInstantaneousBHSTransferingFSC != null)
                    {
                        if (FPA_InboundSmoothed.Columns.Count == FPA_InboundBagSmoothed.Columns.Count
                            && FPA_InboundBagSmoothed.Columns.Count == FPA_InboundSmoothedBHSTotalFSC.Columns.Count
                            && FPA_InboundSmoothedBHSTotalFSC.Columns.Count == FPA_InboundSmoothedBHSTerminatingFSC.Columns.Count
                            && FPA_InboundSmoothedBHSTerminatingFSC.Columns.Count == FPA_InboundSmoothedBHSTransferingFSC.Columns.Count)
                        {
                            ArrayList flightSubcategoriesList = new ArrayList();
                            foreach (String flightSubcategory in flightSubcategoriesAndFlightCategoriesWithNbFlightsPerFSCDictionary.Keys)
                                flightSubcategoriesList.Add(flightSubcategory);

                            for (int i = 1; i < FPA_InboundSmoothed.Columns.Count; i++)
                            {
                                if (flightSubcategoriesList.Count > i - 1)
                                {
                                    DataRow drNewRow = dtStats.NewRow();

                                    drNewRow[0] = flightSubcategoriesList[i - 1].ToString();
                                    drNewRow[1] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundSmoothed, i);
                                    drNewRow[2] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundInstantaneous, i);

                                    drNewRow[3] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundBagSmoothed, i);
                                    drNewRow[4] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundBagInstantaneous, i);

                                    drNewRow[5] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundSmoothedBHSTotalFSC, i);
                                    drNewRow[6] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundInstantaneousBHSTotalFSC, i);

                                    drNewRow[7] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundSmoothedBHSTerminatingFSC, i);
                                    drNewRow[8] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundInstantaneousBHSTerminatingFSC, i);

                                    drNewRow[9] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundSmoothedBHSTransferingFSC, i);
                                    drNewRow[10] = OverallTools.DataFunctions.valeurMaximaleDansColonne2(FPA_InboundInstantaneousBHSTransferingFSC, i);

                                    dtStats.Rows.Add(drNewRow);
                                }
                            }
                        }
                    }

                    resultsList.Add(dtStats);
                    resultsList.Add(FPA_InboundSmoothed);
                    resultsList.Add(FPA_InboundInstantaneous);
                    resultsList.Add(FPA_InboundSmoothedPAXTerminatingFSC);
                    resultsList.Add(FPA_InboundInstantaneousPAXTerminatingFSC);
                    resultsList.Add(FPA_InboundSmoothedPAXTransferringFSC);
                    resultsList.Add(FPA_InboundInstantaneousPAXTransferringFSC);
                    resultsList.Add(FPA_InboundBagSmoothed);
                    resultsList.Add(FPA_InboundSmoothedBagTerminatingFSC);
                    resultsList.Add(FPA_InboundInstantaneousBagTerminatingFSC);
                    resultsList.Add(FPA_InboundSmoothedBagTransferringFSC);
                    resultsList.Add(FPA_InboundInstantaneousBagTransferringFSC);
                    resultsList.Add(FPA_InboundBagInstantaneous);
                    resultsList.Add(FPA_InboundSmoothedBHSTotalFSC);
                    resultsList.Add(FPA_InboundInstantaneousBHSTotalFSC);
                    resultsList.Add(FPA_InboundSmoothedBHSTerminatingFSC);
                    resultsList.Add(FPA_InboundInstantaneousBHSTerminatingFSC);
                    resultsList.Add(FPA_InboundSmoothedBHSTransferingFSC);
                    resultsList.Add(FPA_InboundInstantaneousBHSTransferingFSC);
                    resultsList.Add(FPA_AircraftMovementsFSC);
                    resultsList.Add(FPA_TransferICTSmoothedFSC);
                    resultsList.Add(FPA_TransferICTInstantaneousFSC);
                    resultsList.Add(FPA_TransferICTBagSmoothedFSC);
                    resultsList.Add(FPA_TransferICTBagInstantaneousFSC);
                    #endregion
                }
                return resultsList;
            }

            /// <summary>
            /// The function returns the FlightSubcategory segregation tables for FPD+FPA
            /// The tables are: Aircraft Movements, InOutBound, Pax Boarding Room, MakeUp flows,
            /// Departure Entrance and Departure Entrance BHS.
            /// </summary>
            /// <returns></returns>
            internal static List<DataTable> getFPDFPAFlightSubcategorySegregationTables(
                DataTable FPD_AircraftMovements_FSC, DataTable FPA_AircraftMovements_FSC,
                DataTable FPA_InBoundSmoothed_FSC, DataTable FPD_OutBoundSmoothed_FSC,
                DataTable FPA_InBoundInstantaneous_FSC, DataTable FPD_OutBoundInstantaneous_FSC,
                DataTable FPA_InBoundSmoothedPAXTransfering_FSC, DataTable FPA_InBoundInstantaneousPAXTransfering_FSC,
                DataTable FPD_OutBoundSmoothedPAXOriginating_FSC, DataTable FPD_OutBoundInstantaneousPAXOriginating_FSC,
                DataTable FPA_InBoundSmoothedBagTransfering_FSC, DataTable FPA_InBoundInstantaneousBagTransfering_FSC,
                DataTable FPD_OutBoundSmoothedBagOriginating_FSC, DataTable FPD_OutBoundInstantaneousBagOriginating_FSC,
                DataTable FPA_TransferICTSmoothed_FSC, DataTable FPD_CheckInShowUpSmoothed_FSC,
                DataTable FPA_TransferICTInstantaneous_FSC, DataTable FPD_CheckInShowUpInstantaneous_FSC,
                DataTable FPA_TransferICT_Bag_Smoothed_FSC, DataTable FPD_CheckInShowUp_Bag_Smoothed_FSC,
                DataTable FPA_TransferICT_Bag_Instantaneous_FSC, DataTable FPD_CheckInShowUp_Bag_Instantaneous_FSC,
                List<String> flightSubcategories)
            {
                List<DataTable> FPDFPASegregationTables = new List<DataTable>();

                #region Aircraft Movements
                if (FPD_AircraftMovements_FSC != null && FPA_AircraftMovements_FSC != null)
                {
                    List<string> segregationCategoryColumnNames = new List<string>();
                    foreach (DataColumn column in FPA_AircraftMovements_FSC.Columns)
                    {
                        if (!column.ColumnName.Equals("Time")
                            && !segregationCategoryColumnNames.Contains(column.ColumnName))
                        {
                            segregationCategoryColumnNames.Add(column.ColumnName);
                        }
                    }
                    foreach (DataColumn column in FPD_AircraftMovements_FSC.Columns)
                    {
                        if (!column.ColumnName.Equals("Time")
                            && !segregationCategoryColumnNames.Contains(column.ColumnName))
                        {
                            segregationCategoryColumnNames.Add(column.ColumnName);
                        }
                    }

                    DataTable FPDFPA_aircraftMovements_FSC_Table = FPD_AircraftMovements_FSC.Copy();
                    FPDFPA_aircraftMovements_FSC_Table.TableName = "FPDFPA_AircraftMovements_FSC";

                    for (int i = 1; i < FPDFPA_aircraftMovements_FSC_Table.Columns.Count; i++)
                        FPDFPA_aircraftMovements_FSC_Table.Columns[i].ColumnName += "_FPD";

                    int nbColumns = FPDFPA_aircraftMovements_FSC_Table.Columns.Count;

                    for (int i = 1; i < FPA_AircraftMovements_FSC.Columns.Count; i++)
                    {
                        String columnName = FPA_AircraftMovements_FSC.Columns[i].ColumnName + "_FPA";
                        Type dataType = FPA_AircraftMovements_FSC.Columns[i].DataType;
                        DataColumn column = new DataColumn(columnName, dataType);
                        column.DefaultValue = 0;

                        FPDFPA_aircraftMovements_FSC_Table.Columns.Add(column);
                    }

                    if (FPDFPA_aircraftMovements_FSC_Table.Rows.Count == FPA_AircraftMovements_FSC.Rows.Count)
                    {
                        for (int i = 0; i < FPDFPA_aircraftMovements_FSC_Table.Rows.Count; i++)
                        {
                            int indexColumnFPA_aircraftMovements = 0;
                            for (int j = nbColumns; j < FPDFPA_aircraftMovements_FSC_Table.Columns.Count; j++)
                            {
                                indexColumnFPA_aircraftMovements++;
                                if (indexColumnFPA_aircraftMovements < FPA_AircraftMovements_FSC.Columns.Count)
                                {
                                    int v1 = 0;
                                    int v2 = 0;
                                    Int32.TryParse(FPDFPA_aircraftMovements_FSC_Table.Rows[i][j].ToString(), out v1);
                                    Int32.TryParse(FPA_AircraftMovements_FSC.Rows[i][indexColumnFPA_aircraftMovements].ToString(), out v2);
                                    FPDFPA_aircraftMovements_FSC_Table.Rows[i][j] = v1 + v2;
                                }

                            }
                        }
                    }

                    foreach (String segregationCategory in segregationCategoryColumnNames)
                    {
                        DataColumn newColumn = new DataColumn("Total " + segregationCategory, typeof(Int32));
                        newColumn.DefaultValue = 0;
                        FPDFPA_aircraftMovements_FSC_Table.Columns.Add(newColumn);
                    }

                    foreach (DataRow row in FPDFPA_aircraftMovements_FSC_Table.Rows)
                    {
                        foreach (String segregation in segregationCategoryColumnNames)
                        {
                            int nbFlights = 0;
                            foreach (DataColumn col in FPDFPA_aircraftMovements_FSC_Table.Columns)
                            {
                                if (col.ColumnName.Contains(segregation))
                                {
                                    int val = 0;
                                    Int32.TryParse(row[col].ToString(), out val);
                                    nbFlights += val;
                                }
                            }
                            int indexOfTotalColumn = FPDFPA_aircraftMovements_FSC_Table.Columns.IndexOf("Total " + segregation);
                            if (indexOfTotalColumn != -1)
                                row[indexOfTotalColumn] = nbFlights;
                        }
                    }
                    FPDFPASegregationTables.Add(FPDFPA_aircraftMovements_FSC_Table);
                }
                #endregion

                #region InOutBound Smoothed
                if (FPA_InBoundSmoothed_FSC != null && FPD_OutBoundSmoothed_FSC != null)
                {
                    DataTable FPDFPA_inOutBoundTable = new DataTable();
                    FPDFPA_inOutBoundTable = FPA_InBoundSmoothed_FSC.Copy();
                    FPDFPA_inOutBoundTable.TableName = "FPDFPA_InOutBoundRolling_FSC";

                    List<string> FPD_extraColumns = new List<string>();

                    foreach (DataColumn fpdColumn in FPD_OutBoundSmoothed_FSC.Columns)
                    {
                        bool found = false;
                        foreach (DataColumn fpaColumn in FPA_InBoundSmoothed_FSC.Columns)
                        {
                            if (fpdColumn.ColumnName.Equals(fpaColumn.ColumnName))
                            {
                                found = true;
                                break;
                            }
                        }
                        if (!found)
                            FPD_extraColumns.Add(fpdColumn.ColumnName);
                    }


                    foreach (String extraColumnName in FPD_extraColumns)
                    {
                        DataColumn newColumn = new DataColumn(extraColumnName, typeof(Double));
                        newColumn.DefaultValue = 0;
                        FPDFPA_inOutBoundTable.Columns.Add(newColumn);
                    }

                    if (FPD_OutBoundSmoothed_FSC.Rows.Count == FPDFPA_inOutBoundTable.Rows.Count)
                    {
                        for (int i = 0; i < FPD_OutBoundSmoothed_FSC.Rows.Count; i++)
                        {
                            for (int j = 1; j < FPD_OutBoundSmoothed_FSC.Columns.Count; j++)
                            {
                                int FPDFPA_columnIndex = FPDFPA_inOutBoundTable.Columns.IndexOf(FPD_OutBoundSmoothed_FSC.Columns[j].ColumnName);
                                if (FPDFPA_columnIndex != -1)
                                {
                                    double val = 0;
                                    Double.TryParse(FPD_OutBoundSmoothed_FSC.Rows[i][j].ToString(), out val);
                                    double oldVal = 0;
                                    Double.TryParse(FPDFPA_inOutBoundTable.Rows[i][FPDFPA_columnIndex].ToString(), out oldVal);
                                    FPDFPA_inOutBoundTable.Rows[i][FPDFPA_columnIndex] = oldVal + val;
                                }
                            }
                        }
                    }

                    FPDFPASegregationTables.Add(FPDFPA_inOutBoundTable);
                }
                #endregion

                #region InOutBound Instantaneous
                if (FPA_InBoundInstantaneous_FSC != null && FPD_OutBoundInstantaneous_FSC != null)
                {
                    DataTable FPDFPA_inOutBoundInstantTable = new DataTable();
                    FPDFPA_inOutBoundInstantTable = FPA_InBoundInstantaneous_FSC.Copy();
                    FPDFPA_inOutBoundInstantTable.TableName = "FPDFPA_InOutBoundInstantaneous_FSC";

                    List<string> FPD_extraColumns = new List<string>();

                    foreach (DataColumn fpdColumn in FPD_OutBoundInstantaneous_FSC.Columns)
                    {
                        bool found = false;
                        foreach (DataColumn fpaColumn in FPA_InBoundInstantaneous_FSC.Columns)
                        {
                            if (fpdColumn.ColumnName.Equals(fpaColumn.ColumnName))
                            {
                                found = true;
                                break;
                            }
                        }
                        if (!found)
                            FPD_extraColumns.Add(fpdColumn.ColumnName);
                    }


                    foreach (String extraColumnName in FPD_extraColumns)
                    {
                        DataColumn newColumn = new DataColumn(extraColumnName, typeof(Double));
                        newColumn.DefaultValue = 0;
                        FPDFPA_inOutBoundInstantTable.Columns.Add(newColumn);
                    }

                    if (FPD_OutBoundInstantaneous_FSC.Rows.Count == FPDFPA_inOutBoundInstantTable.Rows.Count)
                    {
                        for (int i = 0; i < FPD_OutBoundInstantaneous_FSC.Rows.Count; i++)
                        {
                            for (int j = 1; j < FPD_OutBoundInstantaneous_FSC.Columns.Count; j++)
                            {
                                int FPDFPA_columnIndex = FPDFPA_inOutBoundInstantTable.Columns.IndexOf(FPD_OutBoundInstantaneous_FSC.Columns[j].ColumnName);
                                if (FPDFPA_columnIndex != -1)
                                {
                                    double val = 0;
                                    Double.TryParse(FPD_OutBoundInstantaneous_FSC.Rows[i][j].ToString(), out val);
                                    double oldVal = 0;
                                    Double.TryParse(FPDFPA_inOutBoundInstantTable.Rows[i][FPDFPA_columnIndex].ToString(), out oldVal);
                                    FPDFPA_inOutBoundInstantTable.Rows[i][FPDFPA_columnIndex] = oldVal + val;
                                }
                            }
                        }
                    }

                    FPDFPASegregationTables.Add(FPDFPA_inOutBoundInstantTable);
                }
                #endregion

                #region Pax boarding room smoothed
                if (FPA_TransferICTSmoothed_FSC != null && FPD_CheckInShowUpSmoothed_FSC != null)
                {
                    DataTable FPDFPA_PaxBoardingRoomSmoothed_FSC = new DataTable();
                    FPDFPA_PaxBoardingRoomSmoothed_FSC = FPA_TransferICTSmoothed_FSC.Copy();
                    FPDFPA_PaxBoardingRoomSmoothed_FSC.TableName = "PAX Boarding Room Rolling_FSC";

                    Dictionary<String, int> FPDFPA_ColumnsFromTransferICTDictionary = new Dictionary<String, int>();
                    for (int i = 1; i < FPDFPA_PaxBoardingRoomSmoothed_FSC.Columns.Count; i++)
                    {
                        FPDFPA_PaxBoardingRoomSmoothed_FSC.Columns[i].ColumnName = "Transfering "
                            + FPDFPA_PaxBoardingRoomSmoothed_FSC.Columns[i].ColumnName;
                        FPDFPA_ColumnsFromTransferICTDictionary.Add(FPDFPA_PaxBoardingRoomSmoothed_FSC.Columns[i].ColumnName, i);
                    }

                    Dictionary<String, int> FPDFPA_ColumnsFromCheckInShowUpDictionary = new Dictionary<String, int>();
                    for (int i = 1; i < FPD_CheckInShowUpSmoothed_FSC.Columns.Count; i++)
                    {
                        DataColumn checkInShowUpColumn = FPD_CheckInShowUpSmoothed_FSC.Columns[i];
                        String newColumnName = "Originating " + checkInShowUpColumn.ColumnName;
                        DataColumn newColumn = new DataColumn(newColumnName, checkInShowUpColumn.DataType);
                        newColumn.DefaultValue = 0;

                        int FPDFPA_indexNewColumn = FPDFPA_PaxBoardingRoomSmoothed_FSC.Columns.Count;
                        FPDFPA_PaxBoardingRoomSmoothed_FSC.Columns.Add(newColumn);
                        FPDFPA_ColumnsFromCheckInShowUpDictionary.Add(newColumn.ColumnName, FPDFPA_indexNewColumn);
                    }

                    for (int i = 0; i < FPD_CheckInShowUpSmoothed_FSC.Rows.Count; i++)
                    {
                        for (int j = 1; j < FPD_CheckInShowUpSmoothed_FSC.Columns.Count; j++)
                        {
                            DataColumn checkInShowUpColumn = FPD_CheckInShowUpSmoothed_FSC.Columns[j];
                            String fpdFpa_columnName = "Originating " + checkInShowUpColumn.ColumnName;

                            int FPDFPA_indexColumn = -1;
                            if (FPDFPA_ColumnsFromCheckInShowUpDictionary.TryGetValue(fpdFpa_columnName, out FPDFPA_indexColumn))
                            {
                                double value = -1;
                                if (Double.TryParse(FPD_CheckInShowUpSmoothed_FSC.Rows[i][j].ToString(), out value))
                                {
                                    double oldValue = 0;
                                    Double.TryParse(FPDFPA_PaxBoardingRoomSmoothed_FSC.Rows[i][FPDFPA_indexColumn].ToString(), out oldValue);
                                    FPDFPA_PaxBoardingRoomSmoothed_FSC.Rows[i][FPDFPA_indexColumn] = oldValue + value;
                                }
                            }
                        }
                    }

                    foreach (String flightSubcategory in flightSubcategories)
                    {
                        String newColumnName = "Departing " + flightSubcategory + " Passengers / h";
                        DataColumn newColumn = new DataColumn(newColumnName, typeof(Double));
                        newColumn.DefaultValue = 0;
                        FPDFPA_PaxBoardingRoomSmoothed_FSC.Columns.Add(newColumn);
                    }

                    foreach (DataRow row in FPDFPA_PaxBoardingRoomSmoothed_FSC.Rows)
                    {
                        foreach (String flightSubcategory in flightSubcategories)
                        {
                            double sum = 0;
                            foreach (DataColumn col in FPDFPA_PaxBoardingRoomSmoothed_FSC.Columns)
                            {
                                if (col.ColumnName.Contains(flightSubcategory) && !col.ColumnName.Contains("Departing"))
                                {
                                    double val = 0;
                                    Double.TryParse(row[col].ToString(), out val);
                                    sum += val;
                                }
                            }
                            int indexOfTotalColumn = FPDFPA_PaxBoardingRoomSmoothed_FSC
                                .Columns.IndexOf("Departing " + flightSubcategory + " Passengers / h");
                            if (indexOfTotalColumn != -1)
                                row[indexOfTotalColumn] = Math.Round(sum, 2);
                        }
                    }
                    FPDFPASegregationTables.Add(FPDFPA_PaxBoardingRoomSmoothed_FSC);
                }
                #endregion

                #region Pax boarding room instantaneous
                String tableName = "PAX Boarding Room Instantaneous_FSC";
                DataTable FPDFPA_PaxBoardingRoomInstantaneous_FSC = createFPDFPAFlightSubcategorySegregationTable(
                    FPA_TransferICTInstantaneous_FSC, FPD_CheckInShowUpInstantaneous_FSC, tableName, flightSubcategories, true);
                FPDFPASegregationTables.Add(FPDFPA_PaxBoardingRoomInstantaneous_FSC);
                #endregion

                #region Make Up Flows Smoothed
                tableName = "MakeUp Flows Rolling_FSC";
                DataTable FPDFPA_MakeUpFlowsSmoothed_FSC = createFPDFPAFlightSubcategorySegregationTable(
                    FPA_TransferICT_Bag_Smoothed_FSC, FPD_CheckInShowUp_Bag_Smoothed_FSC, tableName, flightSubcategories, false);
                FPDFPASegregationTables.Add(FPDFPA_MakeUpFlowsSmoothed_FSC);
                #endregion

                #region Make Up Flows Instantaneous
                tableName = "MakeUp Flows Instantaneous_FSC";
                DataTable FPDFPA_MakeUpFlowsInstantaneous_FSC = createFPDFPAFlightSubcategorySegregationTable(
                    FPA_TransferICT_Bag_Instantaneous_FSC, FPD_CheckInShowUp_Bag_Instantaneous_FSC, tableName, flightSubcategories, false);
                FPDFPASegregationTables.Add(FPDFPA_MakeUpFlowsInstantaneous_FSC);
                #endregion

                #region Departure Entrance PAX Smoothed
                tableName = GlobalNames.fpaFpdDepartureEntranceSmoothedTableName + "_FSC";
                DataTable FPDFPA_DepartureEntranceSmoothed_FSC = createFPDFPAFlightSubcategorySegregationTable(
                    FPA_InBoundSmoothedPAXTransfering_FSC, FPD_OutBoundSmoothedPAXOriginating_FSC, tableName, flightSubcategories, true);
                FPDFPASegregationTables.Add(FPDFPA_DepartureEntranceSmoothed_FSC);
                #endregion

                #region Departure Entrance PAX Instantaneous
                tableName = GlobalNames.fpaFpdDepartureEntranceInstantaneousTableName + "_FSC";
                DataTable FPDFPA_DepartureEntranceInstantaneous_FSC = createFPDFPAFlightSubcategorySegregationTable(
                    FPA_InBoundInstantaneousPAXTransfering_FSC, FPD_OutBoundInstantaneousPAXOriginating_FSC, tableName, flightSubcategories, true);
                FPDFPASegregationTables.Add(FPDFPA_DepartureEntranceInstantaneous_FSC);
                #endregion

                #region Departure Entrance Bag Smoothed
                tableName = GlobalNames.fpaFpdDepartureEntranceSmoothedTableName + "_Bag_FSC";
                DataTable FPDFPA_DepartureEntranceSmoothedBag_FSC = createFPDFPAFlightSubcategorySegregationTable(
                    FPA_InBoundSmoothedBagTransfering_FSC, FPD_OutBoundSmoothedBagOriginating_FSC, tableName, flightSubcategories, false);
                FPDFPASegregationTables.Add(FPDFPA_DepartureEntranceSmoothedBag_FSC);
                #endregion

                #region Departure Entrance Bag Instantaneous
                tableName = GlobalNames.fpaFpdDepartureEntranceInstantaneousTableName + "_Bag_FSC";
                DataTable FPDFPA_DepartureEntranceInstantaneousBag_FSC = createFPDFPAFlightSubcategorySegregationTable(
                    FPA_InBoundInstantaneousBagTransfering_FSC, FPD_OutBoundInstantaneousBagOriginating_FSC, tableName, flightSubcategories, false);
                FPDFPASegregationTables.Add(FPDFPA_DepartureEntranceInstantaneousBag_FSC);
                #endregion

                return FPDFPASegregationTables;
            }

            internal static DataTable createFPDFPAFlightSubcategorySegregationTable(DataTable sourceTable1,
                DataTable sourceTable2, String resultTableName, List<String> flightSubcategories, bool pax)
            {
                DataTable FPDFPA_Table_FSC = new DataTable();

                if (sourceTable1 != null && sourceTable2 != null)
                {
                    String unit = "";
                    if (pax)
                        unit = " Passengers / h";
                    else
                        unit = " Bags / h";

                    FPDFPA_Table_FSC = sourceTable1.Copy();
                    FPDFPA_Table_FSC.TableName = resultTableName;

                    Dictionary<String, int> FPDFPA_ColumnsFromSourceTable1Dictionary = new Dictionary<String, int>();
                    for (int i = 1; i < FPDFPA_Table_FSC.Columns.Count; i++)
                    {
                        FPDFPA_Table_FSC.Columns[i].ColumnName = "Transfering "
                            + FPDFPA_Table_FSC.Columns[i].ColumnName;
                        FPDFPA_ColumnsFromSourceTable1Dictionary.Add(FPDFPA_Table_FSC.Columns[i].ColumnName, i);
                    }

                    Dictionary<String, int> FPDFPA_ColumnsFromSourceTable2Dictionary = new Dictionary<String, int>();
                    for (int i = 1; i < sourceTable2.Columns.Count; i++)
                    {
                        DataColumn sourceTable2Column = sourceTable2.Columns[i];
                        String newColumnName = "Originating " + sourceTable2Column.ColumnName;
                        DataColumn newColumn = new DataColumn(newColumnName, sourceTable2Column.DataType);
                        newColumn.DefaultValue = 0;

                        int FPDFPA_indexNewColumn = FPDFPA_Table_FSC.Columns.Count;
                        FPDFPA_Table_FSC.Columns.Add(newColumn);
                        FPDFPA_ColumnsFromSourceTable2Dictionary.Add(newColumn.ColumnName, FPDFPA_indexNewColumn);
                    }

                    for (int i = 0; i < sourceTable2.Rows.Count; i++)
                    {
                        for (int j = 1; j < sourceTable2.Columns.Count; j++)
                        {
                            DataColumn sourceTable2Column = sourceTable2.Columns[j];
                            String fpdFpa_columnName = "Originating " + sourceTable2Column.ColumnName;

                            int FPDFPA_indexColumn = -1;
                            if (FPDFPA_ColumnsFromSourceTable2Dictionary.TryGetValue(fpdFpa_columnName, out FPDFPA_indexColumn))
                            {
                                double value = -1;
                                if (Double.TryParse(sourceTable2.Rows[i][j].ToString(), out value))
                                {
                                    double oldValue = 0;
                                    Double.TryParse(FPDFPA_Table_FSC.Rows[i][FPDFPA_indexColumn].ToString(), out oldValue);
                                    FPDFPA_Table_FSC.Rows[i][FPDFPA_indexColumn] = oldValue + value;
                                }
                            }
                        }
                    }

                    foreach (String flightSubcategory in flightSubcategories)
                    {
                        String newColumnName = "Departing " + flightSubcategory + unit;

                        DataColumn newColumn = new DataColumn(newColumnName, typeof(Double));
                        newColumn.DefaultValue = 0;
                        FPDFPA_Table_FSC.Columns.Add(newColumn);
                    }

                    foreach (DataRow row in FPDFPA_Table_FSC.Rows)
                    {
                        foreach (String flightSubcategory in flightSubcategories)
                        {
                            double sum = 0;
                            foreach (DataColumn col in FPDFPA_Table_FSC.Columns)
                            {
                                if (col.ColumnName.Contains(flightSubcategory) && !col.ColumnName.Contains("Departing"))
                                {
                                    double val = 0;
                                    Double.TryParse(row[col].ToString(), out val);
                                    sum += val;
                                }
                            }

                            int indexOfTotalColumn = FPDFPA_Table_FSC
                                .Columns.IndexOf("Departing " + flightSubcategory + unit);
                            if (indexOfTotalColumn != -1)
                                row[indexOfTotalColumn] = Math.Round(sum, 2);
                        }
                    }
                }
                return FPDFPA_Table_FSC;
            }
            // >> Task #9504 Pax2Sim - flight subCategories - peak flow segregation

            #endregion

            #region Fonction qui renvoie une table avec le nombre vols par tranche horaire.
            internal static DataTable CalcAllocationParkingDeparture(String sResultTableName,
                                                                   DataTable dtFlightPlan,
                                                                   DataManagement.NormalTable dtLoadFactors,
                                                                   DataManagement.NormalTable TypeAvions,
                                                                   DataTable dtFlightCategories,
                                                                   DateTime dtStartDate,
                                                                   DateTime dtEndDate,
                                                                   Double dStepAnalysis,
                                                                   bool bArrivalFlight,
                                                                   List<FlightConfiguration> userDefinedFlightConfigurations,
                                                                   ArrayList ListeErreurs)
            {
                int iIndexTerminalRessource = dtFlightPlan.Columns.IndexOf(GlobalNames.sFPD_A_Column_TerminalParking);
                int iIndexRessource = dtFlightPlan.Columns.IndexOf(GlobalNames.sFPD_A_Column_Parking);
                int iIndexID = dtFlightPlan.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID);
                int iIndexFlightN = dtFlightPlan.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightN);
                int iIndexFlightCate = dtFlightPlan.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightCategory);

                if ((iIndexTerminalRessource == -1) ||
                    (iIndexRessource == -1) ||
                    (iIndexID == -1) ||
                    (iIndexFlightN == -1) ||
                    (iIndexFlightCate == -1))
                {
                    return null;
                }

                #region We check for empty tables and wrong parameters

                if (dtFlightCategories.Rows.Count == 0)
                {
                    ListeErreurs.Add("Err00458 : Unable to calc the static results. There is no defined flight categories.");
                    return null;
                }

                DataManagement.ExceptionTable etLoadFactors;
                if (dtLoadFactors is DataManagement.ExceptionTable)
                    etLoadFactors = (DataManagement.ExceptionTable)dtLoadFactors;
                else
                    return null;

                DataManagement.ExceptionTable etAircraftType;
                if (TypeAvions is DataManagement.ExceptionTable)
                    etAircraftType = (DataManagement.ExceptionTable)TypeAvions;
                else
                    return null;

                #endregion

                Double dTerminalMax = DataFunctions.getMaxValue(dtFlightPlan, iIndexTerminalRessource);
                Double dParkingMax = DataFunctions.getMaxValue(dtFlightPlan, iIndexRessource);

                DataTable dtResultTable = new DataTable(sResultTableName);
                dtResultTable.Columns.Add("Time", typeof(DateTime));
                dtResultTable.Columns.Add("NbMax", typeof(int));
                int i;
                for (i = 1; i <= dTerminalMax; i++)
                {
                    for (int j = 1; j <= dParkingMax; j++)
                    {
                        dtResultTable.Columns.Add("T" + i.ToString() + "_Parking_" + j.ToString(), typeof(string));
                    }
                }
                OverallTools.DataFunctions.initialiserLignes(dtResultTable, dtStartDate, dtEndDate, dStepAnalysis);

                for (i = 0; i < dtResultTable.Rows.Count; i++)
                {
                    dtResultTable.Rows[i][1] = 0;

                    for (int j = 2; j < dtResultTable.Columns.Count; j++)
                    {
                        dtResultTable.Rows[i][j] = "(";
                    }
                }
                String sTime = GlobalNames.sFPD_Column_STD;
                if (bArrivalFlight)
                    sTime = GlobalNames.sFPA_Column_STA;
                bool bWarnMessage = false;
                foreach (DataRow lignePlanVols in dtFlightPlan.Rows)
                {
                    //On récupère le numéro d'identifiant de la ligne.
                    int iIdentifiantVol = (int)lignePlanVols[iIndexID];
                    String sIdentifiantVol = lignePlanVols[iIndexFlightN].ToString();

                    //double nombrePassagers = OverallTools.DataFunctions.numberOfPassengers(lignePlanVols, etAircraftType, dtFlightCategories, etLoadFactors, ListeErreurs);
                    FlightAttribute.ARR_OR_DEP_FLIGHT_TAG arrOrDep = FlightAttribute.ARR_OR_DEP_FLIGHT_TAG.D;
                    if (bArrivalFlight)
                    {
                        arrOrDep = FlightAttribute.ARR_OR_DEP_FLIGHT_TAG.A;
                    }
                    double nombrePassagers = OverallTools.DataFunctions.getNbPaxForFlight(lignePlanVols, etAircraftType, dtFlightCategories, etLoadFactors,
                        arrOrDep, iIdentifiantVol, userDefinedFlightConfigurations, ListeErreurs);
                    if (nombrePassagers == -1)
                    {
                        //On ignore ce vol car il n'est pas valide pour la génération statique
                        OverallTools.ExternFunctions.PrintLogFile("Flight " + arrOrDep.ToString() + "_" + iIdentifiantVol + " ignored from the Aircraft movements calculation.");
                        continue;
                    }

                    // On détermine l'heure d'arrivée.
                    DateTime dtJourHeureArrivee = OverallTools.DataFunctions.toDateTime(lignePlanVols[GlobalNames.sFPD_A_Column_DATE], lignePlanVols[sTime]);

                    String sValue = OverallTools.DataFunctions.getValue(dtFlightCategories, lignePlanVols[iIndexFlightCate].ToString(), 0, 0);
                    if ((sValue == null) || (sValue == ""))
                    {
                        //La catégorie de vol n'est pas reconnue.
                        continue;
                    }

                    if (dtJourHeureArrivee < dtStartDate)
                    {
                        ListeErreurs.Add("Warn00408 : Line ignored \"" + iIdentifiantVol + "\" doesn't match the range");
                        continue;
                    }

                    if (dtJourHeureArrivee > dtEndDate)
                    {
                        ListeErreurs.Add("Warn00408 : Line ignored \"" + iIdentifiantVol + "\" doesn't match the range");
                        continue;
                    }
                    //On Cherche désormais quels est(sont) l'(les) index des ressources allouées

                    int iTerminalRessource;
                    if (!Int32.TryParse(lignePlanVols.ItemArray[iIndexTerminalRessource].ToString(), out iTerminalRessource))
                        iTerminalRessource = 0;
                    int iRessource;
                    if (!Int32.TryParse(lignePlanVols.ItemArray[iIndexRessource].ToString(), out iRessource))
                        iRessource = 0;
                    if ((iTerminalRessource == 0) || (iRessource == 0))
                    {
                        if (!bWarnMessage)
                            ListeErreurs.Add("Warn00050 : Some fligths does not have any information about the parking. They would be ignored.");
                        bWarnMessage = true;
                        continue;
                    }
                    String nomColonne = "T" + iTerminalRessource.ToString() + "_Parking_" + iRessource.ToString();

                    int iIndexObjet = dtResultTable.Columns.IndexOf(nomColonne);
                    if (iIndexObjet == -1)
                    {
                        ListeErreurs.Add("Err00081 : The columns in the allocation table does not match. Please check for mistakes in tables.");
                        continue;
                    }

                    int iHeureDebut = DataFunctions.heureDebut(dtResultTable, dtJourHeureArrivee);
                    if ((iHeureDebut == -1) || (iHeureDebut > dtResultTable.Rows.Count))
                    {
                        continue;
                        //String sDeparture = " departure ";
                        //if(bArrivalFlight)
                        //    sDeparture = " arrival ";
                        //ListeErreurs.Add("Err10008 : Flight :\"" + sIdentifiantVol + "\" in the" + sDeparture + "flight plan is unvalid. Flight doesn't match the range.");
                        //continue;
                    }
                    dtResultTable.Rows[iHeureDebut][1] = (int)dtResultTable.Rows[iHeureDebut][1] + 1;
                    dtResultTable.Rows[iHeureDebut][iIndexObjet] = dtResultTable.Rows[iHeureDebut][iIndexObjet].ToString() + sIdentifiantVol + ", ";
                }
                String sResult;
                for (i = 0; i < dtResultTable.Rows.Count; i++)
                {
                    for (int j = 2; j < dtResultTable.Columns.Count; j++)
                    {
                        sResult = dtResultTable.Rows[i][j].ToString();
                        if (sResult.Length == 1)
                            dtResultTable.Rows[i][j] = "";
                        else
                            dtResultTable.Rows[i][j] = sResult.Remove(sResult.Length - 2) + ")";
                    }
                }
                dtResultTable.AcceptChanges();
                return dtResultTable;
            }

            #endregion

            #region Fonctions pour le calcul des coefficients multiplicateurs
            public static Hashtable CalculCoefficientMultiplicateur(DataTable dtTable)
            {
                System.Collections.Hashtable htMean = new Hashtable();
                for (int i = 1; i < dtTable.Columns.Count; i++)
                {
                    Double moyenne = 0.0;
                    //Il ne s'agit pas de la première ligne
                    foreach (DataRow ligne in dtTable.Rows)
                    {
                        moyenne += ((double)FonctionsType.getDouble(ligne[i], ligne[i].GetType()) *
                                   (double)FonctionsType.getDouble(ligne[0], ligne[0].GetType())) / 100.0f;
                    }
                    htMean.Add(dtTable.Columns[i].ColumnName, moyenne);
                }
                return htMean;
            }
            public static Double CalculCoefficientMultiplicateur(DataTable dtTable, String sColumnName)
            {
                if (dtTable == null)
                    return 0;
                return CalculCoefficientMultiplicateur(dtTable, dtTable.Columns.IndexOf(sColumnName));
            }
            public static Double CalculCoefficientMultiplicateur(DataTable dtTable, int iIndexColumn)
            {
                if (dtTable == null)
                    return 0;
                if (iIndexColumn < 0)
                    return 0;
                if (iIndexColumn > dtTable.Columns.Count)
                    return 0;
                Double moyenne = 0.0;
                //Il ne s'agit pas de la première ligne
                foreach (DataRow ligne in dtTable.Rows)
                {
                    moyenne += ((double)FonctionsType.getDouble(ligne[iIndexColumn], ligne[iIndexColumn].GetType()) *
                               (double)FonctionsType.getDouble(ligne[0], ligne[0].GetType())) / 100.0f;
                }
                return moyenne;
            }
            public static Double CalculCoefficientMultiplicateurTrolley(DataTable dtTable, DataTable dtBaggage, int iIndexColumn, int iIndexColumnBagage)
            {

                int TindexNombreTrolley = dtTable.Columns.IndexOf("NbTrolley");
                int TindexNombreBaggage = dtTable.Columns.IndexOf("NbBags");
                int BindexNombreBaggage = dtBaggage.Columns.IndexOf("NbBags");

                if ((TindexNombreTrolley == -1) || (TindexNombreBaggage == -1) || (BindexNombreBaggage == -1))
                    return 0;

                Double moyenne = 0.0;
                int iNBBag;
                for (int iBag = 0; iBag < dtBaggage.Rows.Count; iBag++)
                {
                    if (!Int32.TryParse(dtBaggage.Rows[iBag].ItemArray[0].ToString(), out iNBBag))
                        return moyenne;
                    int[] iLignes = OverallTools.DataFunctions.indexLignes(dtTable, TindexNombreBaggage, iNBBag.ToString());
                    if ((iLignes == null) || (iLignes.Length == 0))
                        continue;
                    foreach (int iLigne in iLignes)
                    {
                        if (iLigne == -1)
                            continue;
                        moyenne += ((((Double)dtTable.Rows[iLigne].ItemArray[iIndexColumn]) / 100)
                                    * (((Double)dtBaggage.Rows[iBag].ItemArray[iIndexColumnBagage]) / 100)
                                    * (((int)dtTable.Rows[iLigne].ItemArray[TindexNombreTrolley])));
                    }
                }
                return moyenne;
            }

            internal static void GetFirstAndLastValuesRow(DataTable dtTable, int iColumn, out int iFirstRow, out int iLastRow)
            {
                iFirstRow = -1;
                iLastRow = -1;
                if (dtTable == null)
                    return;
                int j;
                for (j = 0; j < dtTable.Rows.Count; j++)
                {
                    if ((Double)dtTable.Rows[j][iColumn] != 0.0)
                    {

                        if (iFirstRow == -1)
                        {
                            iFirstRow = j;
                        }
                        else
                        {
                            iLastRow = j;
                        }
                    }
                }
                if (iLastRow == -1)
                    iLastRow = iFirstRow;
            }
            #endregion

            #region Fonction pour le calcul des distribution des category de vol (Ou autre)
            private static DataTable getDistribution(Hashtable[] thtValues, String sTableName, String[] tsColumnName, String[] tsOrder)
            {
                if ((thtValues == null) || (sTableName == null) || (tsColumnName == null))
                    return null;
                if (thtValues.Length == 0)
                    return null;
                if (tsColumnName.Length != thtValues.Length + 1)
                    return null;
                int i, j;
                ArrayList alSum = new ArrayList();
                ArrayList alCumul = new ArrayList();
                DataTable dtFCDistribution = new DataTable(sTableName);
                dtFCDistribution.Columns.Add(tsColumnName[0], typeof(String));
                for (i = 1; i < tsColumnName.Length; i++)
                {
                    dtFCDistribution.Columns.Add(tsColumnName[i], typeof(Double));
                    alSum.Add((Double)0.0);
                    alCumul.Add((Double)0.0);
                }
                if ((tsOrder != null) && (tsOrder.Length > 0))
                {
                    for (i = 0; i < tsOrder.Length; i++)
                    {
                        DataRow newRow = dtFCDistribution.NewRow();
                        newRow[0] = tsOrder[i];
                        for (j = 0; j < thtValues.Length; j++)
                        {
                            if (thtValues[j].ContainsKey(tsOrder[i]))
                            {
                                newRow[j + 1] = (Double)thtValues[j][tsOrder[i]];
                                alSum[j] = (Double)alSum[j] + (Double)newRow[j + 1];
                                thtValues[j].Remove(tsOrder[i]);
                            }
                            else
                                newRow[j + 1] = 0;
                        }
                        dtFCDistribution.Rows.Add(newRow);
                    }
                }
                for (i = 0; i < thtValues.Length; i++)
                {
                    if (thtValues[i].Count != 0)
                    {
                        foreach (String sKey in thtValues[i].Keys)
                        {
                            DataRow newRow = dtFCDistribution.NewRow();
                            newRow[0] = sKey;
                            for (j = 0; j < thtValues.Length; j++)
                            {
                                if ((j < i) || (!thtValues[j].ContainsKey(sKey)))
                                    newRow[j + 1] = 0;
                                else if (j == i)
                                {
                                    newRow[j + 1] = (Double)thtValues[i][sKey];
                                    alSum[j] = (Double)alSum[j] + (Double)newRow[j + 1];
                                }
                                else
                                {
                                    newRow[j + 1] = (Double)thtValues[j][sKey];
                                    alSum[j] = (Double)alSum[j] + (Double)newRow[j + 1];
                                    thtValues[j].Remove(sKey);
                                }
                            }
                            dtFCDistribution.Rows.Add(newRow);
                        }
                    }
                }
                int iNbColumns = dtFCDistribution.Columns.Count;
                for (i = 1; i < iNbColumns; i++)
                {
                    dtFCDistribution.Columns.Add("%_" + dtFCDistribution.Columns[i].ColumnName, typeof(Double));
                }
                for (i = 1; i < iNbColumns; i++)
                {
                    dtFCDistribution.Columns.Add("%Cumul_" + dtFCDistribution.Columns[i].ColumnName, typeof(Double));
                }
                foreach (DataRow drLine in dtFCDistribution.Rows)
                {
                    for (i = 1; i < iNbColumns; i++)
                    {
                        Double dSum = (Double)alSum[i - 1];
                        if (dSum == 0)
                        {
                            drLine[i + iNbColumns - 1] = 0;
                            drLine[i + (iNbColumns - 1) * 2] = 0;
                        }
                        else
                        {
                            drLine[i + iNbColumns - 1] = Math.Round(((Double)drLine[i] * 100) / dSum, 2);
                            alCumul[i - 1] = (Double)alCumul[i - 1] + (Double)drLine[i];
                            drLine[i + (iNbColumns - 1) * 2] = Math.Round(((Double)alCumul[i - 1] * 100) / dSum, 2);
                        }
                        drLine[i] = Math.Round((Double)drLine[i], 2);
                    }
                }
                dtFCDistribution.AcceptChanges();
                return dtFCDistribution;
            }

            private static DataTable getDistribution(Dictionary<String, Double>[] thtValues, String sTableName, String[] tsColumnName, String[] tsOrder)
            {
                if ((thtValues == null) || (sTableName == null) || (tsColumnName == null))
                    return null;
                if (thtValues.Length == 0)
                    return null;
                if (tsColumnName.Length != thtValues.Length + 1)
                    return null;
                int i, j;
                ArrayList alSum = new ArrayList();
                ArrayList alCumul = new ArrayList();
                DataTable dtFCDistribution = new DataTable(sTableName);
                dtFCDistribution.Columns.Add(tsColumnName[0], typeof(String));
                for (i = 1; i < tsColumnName.Length; i++)
                {
                    dtFCDistribution.Columns.Add(tsColumnName[i], typeof(Double));
                    alSum.Add((Double)0.0);
                    alCumul.Add((Double)0.0);
                }
                if ((tsOrder != null) && (tsOrder.Length > 0))
                {
                    for (i = 0; i < tsOrder.Length; i++)
                    {
                        DataRow newRow = dtFCDistribution.NewRow();
                        newRow[0] = tsOrder[i];
                        for (j = 0; j < thtValues.Length; j++)
                        {
                            if (thtValues[j].ContainsKey(tsOrder[i]))
                            {
                                newRow[j + 1] = (Double)thtValues[j][tsOrder[i]];
                                alSum[j] = (Double)alSum[j] + (Double)newRow[j + 1];
                                thtValues[j].Remove(tsOrder[i]);
                            }
                            else
                                newRow[j + 1] = 0;
                        }
                        dtFCDistribution.Rows.Add(newRow);
                    }
                }
                for (i = 0; i < thtValues.Length; i++)
                {
                    if (thtValues[i].Count != 0)
                    {
                        foreach (String sKey in thtValues[i].Keys)
                        {
                            DataRow newRow = dtFCDistribution.NewRow();
                            newRow[0] = sKey;
                            for (j = 0; j < thtValues.Length; j++)
                            {
                                if ((j < i) || (!thtValues[j].ContainsKey(sKey)))
                                    newRow[j + 1] = 0;
                                else if (j == i)
                                {
                                    newRow[j + 1] = (Double)thtValues[i][sKey];
                                    alSum[j] = (Double)alSum[j] + (Double)newRow[j + 1];
                                }
                                else
                                {
                                    newRow[j + 1] = (Double)thtValues[j][sKey];
                                    alSum[j] = (Double)alSum[j] + (Double)newRow[j + 1];
                                    thtValues[j].Remove(sKey);
                                }
                            }
                            dtFCDistribution.Rows.Add(newRow);
                        }
                    }
                }
                int iNbColumns = dtFCDistribution.Columns.Count;
                for (i = 1; i < iNbColumns; i++)
                {
                    dtFCDistribution.Columns.Add("%_" + dtFCDistribution.Columns[i].ColumnName, typeof(Double));
                }
                for (i = 1; i < iNbColumns; i++)
                {
                    dtFCDistribution.Columns.Add("%Cumul_" + dtFCDistribution.Columns[i].ColumnName, typeof(Double));
                }
                foreach (DataRow drLine in dtFCDistribution.Rows)
                {
                    for (i = 1; i < iNbColumns; i++)
                    {
                        Double dSum = (Double)alSum[i - 1];
                        if (dSum == 0)
                        {
                            drLine[i + iNbColumns - 1] = 0;
                            drLine[i + (iNbColumns - 1) * 2] = 0;
                        }
                        else
                        {
                            drLine[i + iNbColumns - 1] = Math.Round(((Double)drLine[i] * 100) / dSum, 2);
                            alCumul[i - 1] = (Double)alCumul[i - 1] + (Double)drLine[i];
                            drLine[i + (iNbColumns - 1) * 2] = Math.Round(((Double)alCumul[i - 1] * 100) / dSum, 2);
                        }
                        drLine[i] = Math.Round((Double)drLine[i], 2);
                    }
                }
                dtFCDistribution.AcceptChanges();
                return dtFCDistribution;
            }
            #endregion

            #region La classe PaxPlanClass
            internal class PaxPlanClass
            {
                #region Les différentes variables de la classe.
                #region Variables résultat.
                DataTable _dtPaxPlanTable;
                DataTable _dtPax_GenTransferLog;
                DataTable _dtFPABags;
                DataTable _dtFPDBags;
                DataTable _dtFPAPassengers;
                DataTable _dtFPDPassengers;
                #region //SGE-26/03/2012-Begin
#if(PARKINGMULHOUSE)
                DataTable _dtPrkPlanTable;
#endif
                #endregion //SGE-26/03/2012-End

                private ArrayList alResultsTables;
                private Hashtable htResultsTables;
                #endregion

                #region Variables pour la configuration et le calcul du PaxPlan.
                private bool _bTransferArrivalGeneration;
                // << Task #8667 Pax2Sim - PaxPlan not showing departure pax with flights that have STD after the end of simulation
                private bool _bGenerateFlightsAtEnd;
                // >> Task #8667 Pax2Sim - PaxPlan not showing departure pax with flights that have STD after the end of simulation

                private GestionDonneesHUB2SIM _donnees; // >> Task #10764 Pax2Sim - new User attributes for Groups
                private ParamScenario scenarioParameters;

                private DateTime _dtStartDate;
                private DateTime _dtEndDate;

                private bool _bGenerateAllPax;
                private bool _bFillTransfer;

                private DataTable _dtFPATable;
                private DataTable _dtFPDTable;
                private DataManagement.ExceptionTable etFPALoadFactors;
                private DataManagement.ExceptionTable etFPDLoadFactors;

                private int iNbTerminaux = -1;
                private Double[,] tdTransferTerminalDistribution = null;
                private DataTable _dtTransferTerminalDistribution;


                private int iNbFlightCategory = -1;
                ArrayList alFlightCategory = null;
                private Double[,] tdTransferFlightCategoryDistribution = null;
                private DataTable _dtTransferFlightCategoryDistribution;

                private int[,] tiTransferTransferredFlights = null;

                private DataManagement.ExceptionTable etAircraftType;
                private DataManagement.ExceptionTable etCI_ShowUpTable;
                private DataManagement.ExceptionTable etInterConnectingTimesTable;
                private DataManagement.ExceptionTable etBagsDistrib;
                private DataManagement.ExceptionTable etVisitorsDistrib;
                private DataManagement.ExceptionTable etTrolleyDistrib;

                private DataTable _dtFlightCategories;

                private int _Seed;
                private Dictionary<int, int> htDepartingFlightLoading;
                private Dictionary<int, int> htArrivalFlightLoading;
#if(PAXINOUTUTILISATION)
                private DataManagement.ExceptionTable etPaxInDistrib;
                private DataManagement.ExceptionTable etPaxOutDistrib;
#endif
                #region //SGE-26/03/2012-Begin
#if(PARKINGMULHOUSE)
                private DataManagement.ExceptionTable etLongStayDistribution;
                private DataManagement.ExceptionTable etShortStayDistribution;
#endif
                #endregion //SGE-26/03/2012-End

                //<< Task #7405 - new Desk and extra information for Pax
                private DataTable userAttributesTable;
                private Dictionary<string, DataManagement.NormalTable> userAttributesDistributionTables;
                private Dictionary<string, DataTable> userAttribDistribExceptionTablesFB = new Dictionary<string, DataTable>();
                private Dictionary<string, DataTable> userAttribDistribExceptionTablesEco = new Dictionary<string, DataTable>();
                private Dictionary<string, int> userAttribDistribExceptionIndexesFB = new Dictionary<string, int>();
                private Dictionary<string, int> userAttribDistribExceptionIndexesEco = new Dictionary<string, int>();
                //>> Task #7405 - new Desk and extra information for Pax
                List<FlightConfiguration> flightConfigurations = new List<FlightConfiguration>();
                #endregion
                private Prompt.SIM_LoadingForm _slfLoadingForm;

                private static ArrayList _ListeErreurs;
                #endregion

                #region Accesseurs aux différents résultats.
                public DataTable PaxPlanTable
                {
                    get
                    {
                        return _dtPaxPlanTable;
                    }
                }
                public DataTable Pax_GenTransferLog
                {
                    get
                    {
                        return _dtPax_GenTransferLog;
                    }
                }
                public DataTable FPABags
                {
                    get
                    {
                        return _dtFPABags;
                    }
                }
                public DataTable FPDBags
                {
                    get
                    {
                        return _dtFPDBags;
                    }
                }
                public DataTable FPAPassengers
                {
                    get
                    {
                        return _dtFPAPassengers;
                    }
                }
                public DataTable FPDPassengers
                {
                    get
                    {
                        return _dtFPDPassengers;
                    }
                }
                public Hashtable FlightPlanGenerationDetails
                {
                    get
                    {
                        htResultsTables = new Hashtable();
                        foreach (DataTable dttable in alResultsTables)
                            htResultsTables.Add(dttable.TableName, dttable);
                        htResultsTables.Add(_dtPaxPlanTable.TableName, _dtPaxPlanTable);
                        htResultsTables.Add(_dtPax_GenTransferLog.TableName, _dtPax_GenTransferLog);
                        htResultsTables.Add(_dtFPABags.TableName, _dtFPABags);
                        htResultsTables.Add(_dtFPDBags.TableName, _dtFPDBags);
                        return htResultsTables;
                    }
                }
                #region //SGE-26/03/2012-Begin
#if(PARKINGMULHOUSE)
                internal DataTable PrkPlanTable
                {
                    get
                    {
                        //If the Parking mode is not set, then the parking table should not be calculated or used.
                        if (!PAX2SIM.bPKG)
                            return null;
                        return _dtPrkPlanTable;
                    }
                }
#endif
                #endregion //SGE-26/03/2012-End
                #endregion

                #region Constructeur de la classe
                internal PaxPlanClass(DateTime dtStartDate,
                                    DateTime stEndDate,
                                    bool bTransferArrivalGeneration,
                                    bool bFillTransfer,
                                    bool bGenerateAllPax,
                                    DataTable dtFPATable,
                                    DataTable dtFPDTable,
                                    DataTable dtTransferTerminalDistribution,
                                    DataTable dtTransferFlightCategoryDistribution,
                                    DataManagement.NormalTable dtFPAircraftType,
                                    DataTable dtFlightCategories,
                                    DataManagement.NormalTable dtFPALoadFactors,
                                    DataManagement.NormalTable dtFPDLoadFactors,
                                    DataManagement.NormalTable dtCI_ShowUpTable,
                                    DataManagement.NormalTable dtInterConnectingTimesTable,
                                    DataManagement.NormalTable dtBagsDistrib,
                                    DataManagement.NormalTable dtVisitorsDistrib,
                                    DataManagement.NormalTable dtTrolleyDistrib,
#if(PAXINOUTUTILISATION)
                                    DataManagement.NormalTable ntPaxInDistrib,
                                    DataManagement.NormalTable ntPaxOutDistrib,
#endif
                                    int Seed,
                                    ArrayList ListeErreurs,
                                    Prompt.SIM_LoadingForm slfLoadingForm
                                    // << Task #8667 Pax2Sim - PaxPlan not showing departure pax with flights that have STD after the end of simulation
                                    , bool generateFlightsAtEnd
                                    // >> Task #8667 Pax2Sim - PaxPlan not showing departure pax with flights that have STD after the end of simulation
                                    , GestionDonneesHUB2SIM donnees, // >> Task #10764 Pax2Sim - new User attributes for Groups
                                    List<FlightConfiguration> userDefinedFlightConfigurations,
                                    ParamScenario scenarioParameters
                                    )
                {
                    _dtStartDate = dtStartDate;
                    _dtEndDate = stEndDate;
                    _bGenerateAllPax = bGenerateAllPax;
                    _bFillTransfer = bFillTransfer;
                    _dtFPATable = dtFPATable;
                    _dtFPDTable = dtFPDTable;
                    _dtTransferTerminalDistribution = dtTransferTerminalDistribution;
                    _dtTransferFlightCategoryDistribution = dtTransferFlightCategoryDistribution;
                    if (dtFPAircraftType is DataManagement.ExceptionTable)
                        etAircraftType = (DataManagement.ExceptionTable)dtFPAircraftType;
                    _dtFlightCategories = dtFlightCategories;
                    if (dtFPALoadFactors is DataManagement.ExceptionTable)
                        etFPALoadFactors = (DataManagement.ExceptionTable)dtFPALoadFactors;
                    if (dtFPDLoadFactors is DataManagement.ExceptionTable)
                        etFPDLoadFactors = (DataManagement.ExceptionTable)dtFPDLoadFactors;
                    if (dtCI_ShowUpTable is DataManagement.ExceptionTable)
                        etCI_ShowUpTable = (DataManagement.ExceptionTable)dtCI_ShowUpTable;
                    if (dtInterConnectingTimesTable is DataManagement.ExceptionTable)
                        etInterConnectingTimesTable = (DataManagement.ExceptionTable)dtInterConnectingTimesTable;
                    if (dtBagsDistrib is DataManagement.ExceptionTable)
                        etBagsDistrib = (DataManagement.ExceptionTable)dtBagsDistrib;
                    if (dtVisitorsDistrib is DataManagement.ExceptionTable)
                        etVisitorsDistrib = (DataManagement.ExceptionTable)dtVisitorsDistrib;
                    if (dtTrolleyDistrib is DataManagement.ExceptionTable)
                        etTrolleyDistrib = (DataManagement.ExceptionTable)dtTrolleyDistrib;

#if (PAXINOUTUTILISATION)
                    if (ntPaxInDistrib is DataManagement.ExceptionTable)
                        etPaxInDistrib = (DataManagement.ExceptionTable)ntPaxInDistrib;

                    if (ntPaxOutDistrib is DataManagement.ExceptionTable)
                        etPaxOutDistrib = (DataManagement.ExceptionTable)ntPaxOutDistrib;
#endif
                    _Seed = Seed;
                    _ListeErreurs = ListeErreurs;
                    _slfLoadingForm = slfLoadingForm;
                    _bTransferArrivalGeneration = bTransferArrivalGeneration;

                    _dtPax_GenTransferLog = null;
                    _dtPaxPlanTable = null;
                    _dtFPABags = null;
                    _dtFPDBags = null;
                    _dtFPAPassengers = null;
                    _dtFPDPassengers = null;

                    htDepartingFlightLoading = null;
                    htArrivalFlightLoading = null;
                    alResultsTables = null;

                    // << Task #8667 Pax2Sim - PaxPlan not showing departure pax with flights that have STD after the end of simulation
                    _bGenerateFlightsAtEnd = generateFlightsAtEnd;
                    // >> Task #8667 Pax2Sim - PaxPlan not showing departure pax with flights that have STD after the end of simulation

                    _donnees = donnees; // >> Task #10764 Pax2Sim - new User attributes for Groups
                    flightConfigurations = userDefinedFlightConfigurations;
                    this.scenarioParameters = scenarioParameters;
                }
                #endregion

                //<< Task #7405 - new Desk and extra information for Pax
                public void setUserAttributesTables(DataTable pUserAttributesTable, Dictionary<string,
                    DataManagement.NormalTable> pUserAttributesDistributionTables)
                {
                    this.userAttributesTable = pUserAttributesTable;
                    this.userAttributesDistributionTables = pUserAttributesDistributionTables;
                }
                //>> Task #7405 - new Desk and extra information for Pax
                public Dictionary<string, int> userAttributesPaxPlanIndexes = new Dictionary<string, int>();
                private void InitializeTables()
                {
                    _dtPaxPlanTable = new DataTable("PaxPlanTable");
                    _dtPax_GenTransferLog = new DataTable("Pax_GenTransferLog");
                    OverallTools.FonctionUtiles.initialiserTable(_dtPaxPlanTable, GestionDonneesHUB2SIM.ListeEntete_PaxPlan, GestionDonneesHUB2SIM.ListeTypeEntete_PaxPlan, null);

                    // << Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab
                    // add the extra columns
                    List<string> userAttributesNames = getUserAttributesNames(userAttributesTable);
                    foreach (string userAttributeName in userAttributesNames)
                    {
                        if (_dtPaxPlanTable.Columns.IndexOf(userAttributeName) == -1)
                            _dtPaxPlanTable.Columns.Add(userAttributeName, typeof(String));
                    }
                    /*
                    if (userAttributesDistributionTables != null)
                    {
                        foreach (KeyValuePair<String, NormalTable> pair in userAttributesDistributionTables)
                        {
                            String newUserAttributeName = pair.Key;
                            NormalTable distributionTable = pair.Value;

                            if (distributionTable != null)
                            {
                                // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                if (GlobalNames.nonUserAttributesExceptionsList.Contains(newUserAttributeName))
                                    continue;
                                // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                if (_dtPaxPlanTable.Columns.IndexOf(newUserAttributeName) == -1)
                                {
                                    _dtPaxPlanTable.Columns.Add(newUserAttributeName, typeof(String));
                                }
                            }
                        }
                    }*/

                    // >> Task #10764 Pax2Sim - new User attributes for Groups
                    if (_dtPaxPlanTable.Columns.IndexOf(GlobalNames.PAX_CI_GROUP_USER_ATTRIBUTE) == -1)
                    {
                        _dtPaxPlanTable.Columns.Add(GlobalNames.PAX_CI_GROUP_USER_ATTRIBUTE, typeof(String));
                    }
                    if (_dtPaxPlanTable.Columns.IndexOf(GlobalNames.PAX_RECLAIM_GROUP_USER_ATTRIBUTE) == -1)
                    {
                        _dtPaxPlanTable.Columns.Add(GlobalNames.PAX_RECLAIM_GROUP_USER_ATTRIBUTE, typeof(String));
                    }
                    if (_dtPaxPlanTable.Columns.IndexOf(GlobalNames.PAX_TRANSFER_GROUP_USER_ATTRIBUTE) == -1)
                    {
                        _dtPaxPlanTable.Columns.Add(GlobalNames.PAX_TRANSFER_GROUP_USER_ATTRIBUTE, typeof(String));
                    }
                    if (_dtPaxPlanTable.Columns.IndexOf(GlobalNames.PAX_BOARDING_GATE_GROUP_USER_ATTRIBUTE) == -1)
                    {
                        _dtPaxPlanTable.Columns.Add(GlobalNames.PAX_BOARDING_GATE_GROUP_USER_ATTRIBUTE, typeof(String));
                    }
                    // << Task #10764 Pax2Sim - new User attributes for Groups

                    /*                  //<< Task #7405 - new Desk and extra information for Pax                    
                                        // add the extra columns
                                        if (userAttributesTable != null && userAttributesTable.Rows.Count > 0)
                                            foreach (DataRow row in userAttributesTable.Rows)
                                            {
                                                String newUserAttributeColumnName = row[GlobalNames.sUserAttributes_ColumnName].ToString();
                                                // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                                if (GlobalNames.nonUserAttributesExceptionsList.Contains(newUserAttributeColumnName))
                                                    continue;
                                                // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                                _dtPaxPlanTable.Columns.Add(newUserAttributeColumnName, typeof(String));

                                            }
                                        //>> Task #7405 - new Desk and extra information for Pax
                     */
                    // >> Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab
                    OverallTools.FonctionUtiles.initialiserTable(_dtPax_GenTransferLog, GestionDonneesHUB2SIM.ListeEntete_PaxGenTransferLog, new int[] { });

                    #region //SGE-26/03/2012-Begin
#if(PARKINGMULHOUSE)
                    if (PAX2SIM.bPKG)
                    {
                        _dtPrkPlanTable = _dtPaxPlanTable.Copy();
                        _dtPrkPlanTable.TableName = GlobalNames.PrkPlanName;
                    }

#endif
                    #endregion //SGE-26/03/2012-End
                    if (_slfLoadingForm != null)
                        _slfLoadingForm.setFileNumber(_slfLoadingForm.getFileNumber() + (_dtFPATable.Rows.Count + _dtFPDTable.Rows.Count));
                }

                public static List<string> getUserAttributesNames(DataTable userAttributesTable)
                {
                    List<string> names = new List<string>();
                    if (userAttributesTable == null || userAttributesTable.Columns.IndexOf(GlobalNames.sUserAttributes_ColumnName) == -1)
                        return names;
                    int columnIndexColumnName = userAttributesTable.Columns.IndexOf(GlobalNames.sUserAttributes_ColumnName);
                    foreach (DataRow row in userAttributesTable.Rows)
                    {
                        if (row[columnIndexColumnName] == null)
                            continue;
                        if (GlobalNames.nonUserAttributesExceptionsList.Contains(row[columnIndexColumnName].ToString()))
                            continue;
                        names.Add(row[columnIndexColumnName].ToString());
                    }
                    return names;
                }

                private bool CheckTables()
                {
                    if (etAircraftType == null)
                        return false;
                    if (etFPALoadFactors == null)
                        return false;
                    if (etFPDLoadFactors == null)
                        return false;
                    if (etCI_ShowUpTable == null)
                        return false;
                    if (etInterConnectingTimesTable == null)
                        return false;
                    if (etBagsDistrib == null)
                        return false;
                    if (etVisitorsDistrib == null)
                        return false;
                    if (etTrolleyDistrib == null)
                        return false;
#if(PAXINOUTUTILISATION)

                    if (etPaxInDistrib == null)
                        return false;
                    if (etPaxOutDistrib == null)
                        return false;
#endif
                    //<< Task #7405 - new Desk and extra information for Pax
                    if (userAttributesTable != null && userAttributesTable.Rows.Count > 0)
                        if (userAttributesDistributionTables != null)
                            foreach (KeyValuePair<string, DataManagement.NormalTable> element in userAttributesDistributionTables)
                            {
                                if (element.Value == null)
                                    return false;
                            }
                    //>> Task #7405 - new Desk and extra information for Pax
                    return true;
                }
                public bool effectuerCalculPaxPlan()
                {
                    InitializeTables();
                    if (!CheckTables())
                        return false;
                    if (_bTransferArrivalGeneration)
                    {
                        GeneratePassengersArrival(true);
                        GeneratePassengersDeparture(false);
                    }
                    else
                    {
                        GeneratePassengersDeparture(true);
                        GeneratePassengersArrival(false);
                    }
                    //
                    CalcDistributionTables();
                    return true;
                }
                public void AllocateSegregation(DataManagement.NormalTable dtSegregationTable, int iRandomSeed)
                {
                    if (dtSegregationTable == null)
                        return;
                    if (!typeof(DataManagement.ExceptionTable).IsInstanceOfType(dtSegregationTable))
                        return;
                    DataManagement.ExceptionTable etpSegregationTable = (DataManagement.ExceptionTable)dtSegregationTable;
                    if (_dtPaxPlanTable == null)
                        return;
                    if (_dtFPDTable == null)
                        return;
                    Random rRandom = new Random(iRandomSeed);
                    Hashtable htDistributions = new Hashtable();
                    int iIndexFC = _dtFPDTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightCategory);
                    int iIndexID = _dtFPDTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID);
                    if ((iIndexID == -1) || (iIndexFC == -1))
                        return;
                    Double[] dDistrib;
                    int i;
                    /*Dictionary<String, Double[]> htSegregationValues = new Dictionary<String, Double[]>();
                    for (i = 1; i < dtSegregationTable.Columns.Count; i++)
                    {
                        dDistrib = new double[dtSegregationTable.Rows.Count];
                        for (int j = 0; j < dDistrib.Length; j++)
                        {
                            dDistrib[j] = (double)dtSegregationTable.Rows[j][i];
                        }
                        htSegregationValues.Add(dtSegregationTable.Columns[i].ColumnName, dDistrib);
                    }*/
                    foreach (DataRow drLine in _dtFPDTable.Rows)
                    {
                        int iIndexLigne = OverallTools.DataFunctions.indexLigne(_dtFPDBags, 0, drLine[iIndexID].ToString());
                        if (iIndexLigne == -1)
                            continue;
                        int iBagsNumber = (int)_dtFPDBags.Rows[iIndexLigne][_dtFPDBags.Columns.Count - 1];
                        int iIndex;
                        DataTable dtSegregation = etpSegregationTable.GetInformationsColumns(0, "D_" + drLine[GlobalNames.sFPD_A_Column_ID].ToString(), drLine[GlobalNames.sFPD_A_Column_AirlineCode].ToString(), drLine[GlobalNames.sFPD_A_Column_FlightCategory].ToString(), out iIndex);
                        if (iIndex == -1)
                            continue;
                        /*if (!htSegregationValues.ContainsKey(drLine[iIndexFC].ToString()))
                            continue;*/
                        dDistrib = new Double[dtSegregation.Rows.Count];
                        for (int j = 0; j < dDistrib.Length; j++)
                        {
                            dDistrib[j] = (double)dtSegregation.Rows[j][iIndex];
                        }
                        //dDistrib = (Double[])htSegregationValues[drLine[iIndexFC].ToString()];
                        Double[] dBags = new double[dDistrib.Length];
                        for (i = 0; i < dDistrib.Length; i++)
                        {
                            dBags[i] = dDistrib[i] * iBagsNumber / 100;
                        }
                        htDistributions.Add(drLine[iIndexID], dBags);
                    }
                    foreach (DataRow drLine in _dtPaxPlanTable.Rows)
                    {
                        if ((int)drLine["FPD_ID"] == 0)
                            continue;
                        if (Convert.ToInt32(drLine[GlobalNames.sPaxPlan_BagsIG]) == 0)  // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                            continue;
                        //if ((int)drLine[GlobalNames.sPaxPlan_BagsIG] == 0)
                        //    continue;
                        int iIndexFPD = (int)drLine["FPD_ID"];
                        if (!htDistributions.ContainsKey(iIndexFPD))
                            continue;
                        dDistrib = (Double[])htDistributions[iIndexFPD];
                        Double dValue = 0;
                        for (i = 0; i < dDistrib.Length; i++)
                            dValue += dDistrib[i];
                        dValue = dValue * rRandom.NextDouble();
                        i = 0;
                        while ((i < dDistrib.Length) && (dValue > dDistrib[i]))
                        {
                            dValue -= dDistrib[i];
                            i++;
                        }
                        //dDistrib[i] -= (int)drLine[GlobalNames.sPaxPlan_BagsIG];
                        dDistrib[i] -= Convert.ToInt32(drLine[GlobalNames.sPaxPlan_BagsIG]);    // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                        if (dDistrib[i] < 0)
                            dDistrib[i] = 0;
                        drLine["Segregation"] = i + 1;
                    }
                    _dtPaxPlanTable.AcceptChanges();
                }

                #region Fonction utilisée pour répartir les pax entre les différents points d'entrée de l'aéroport.
                public Point GetInOutPointForPax(DataManagement.ExceptionTable etPaxDistribution,
                                            int iClasse,
                                            String sFlight,
                                            String sFlightCategorie,
                                            String sAirline,
                                            String sTerminal,
                                            Random rdAleatoire)
                {
                    DataRow Information = etPaxDistribution.GetInformationsRow(iClasse, sFlight, sAirline, sFlightCategorie, sTerminal);
                    if (Information == null)
                        return new Point(0, 0);
                    //On récupère l'index de la colonne To afin de savoir où commencent les distributions entre les points.
                    int iIndexTo = Information.Table.Columns.IndexOf(GlobalNames.sColumnTo);
                    Double dDistribution = 0;
                    if ((iIndexTo < 0) || (iIndexTo == (Information.ItemArray.Length - 1)))
                        return new Point(0, 0);
                    for (int i = iIndexTo + 1; i < Information.ItemArray.Length; i++)
                    {
                        dDistribution += FonctionsType.getDouble(Information.ItemArray[i]);
                    }
                    int EntreeSélectionnee = 0;
                    if (dDistribution == 0)
                    {
                        //Il n'y a pas d'information sur la distribution des pax aux différentes entrées. on va donc les dispersées
                        //sur l'ensemble des entrées présentes.
                        int iNombreEntree = Information.ItemArray.Length - iIndexTo - 1;
                        EntreeSélectionnee = (int)Math.Floor(rdAleatoire.NextDouble() * iNombreEntree) + iIndexTo + 1;
                    }
                    else
                    {
                        Double dValeur = rdAleatoire.NextDouble() * dDistribution;
                        for (int i = iIndexTo; i < Information.ItemArray.Length; i++)
                        {
                            dValeur -= FonctionsType.getDouble(Information.ItemArray[i]);
                            if (dValeur <= 0)
                            {
                                EntreeSélectionnee = i;
                                break;
                            }
                        }
                    }
                    if ((EntreeSélectionnee <= iIndexTo) || (EntreeSélectionnee > Information.ItemArray.Length))
                        return new Point(0, 0);
                    String sEntree = Information.Table.Columns[EntreeSélectionnee].ColumnName;
                    sEntree = sEntree.Substring(0, sEntree.IndexOf('(') - 1);
                    int[] iReference = OverallTools.DataFunctions.AnalyzeGroupName(sEntree);
                    if ((iReference == null) || (iReference.Length != 4))
                        return new Point(0, 0);
                    return new Point(iReference[0], iReference[3]);
                }
                #endregion
                internal class FlightStatistics
                {
                    #region The differents variables.
                    private int _iFlightID;

                    private int iNbPaxExpected;
                    private int iNbGeneratedPax;
                    private int iNbGeneratedBags;
                    private int iNbGeneratedVisitors;

                    private int iNbOriginatingTerminatingPax;
                    private int iNbOriginatingTerminatingBags;
                    private int iNbOriginatingTerminatingVisitors;

                    private int iNbTransferredPax;
                    private int iNbTransferredBags;

                    private int iNbRecheckPax;
                    private int iNbRecheckBags;

                    private int iNbTransferredUnallocatedPax;
                    private int iNbTransferredUnallocatedBags;

                    private int iNbRecheckUnallocatedPax;
                    private int iNbRecheckUnallocatedBags;

                    private int iNbOnlineCheckInPax;
                    private int iNbOnlineCheckInInBags;
                    private int iNbOnlineCheckInVisitors;
                    #endregion

                    internal FlightStatistics(int iFlightId, int iExpectedPax)
                    {
                        _iFlightID = iFlightId;
                        iNbPaxExpected = iExpectedPax;
                        iNbGeneratedPax = 0;
                        iNbGeneratedBags = 0;
                        iNbGeneratedVisitors = 0;

                        iNbOriginatingTerminatingPax = 0;
                        iNbOriginatingTerminatingBags = 0;
                        iNbOriginatingTerminatingVisitors = 0;

                        iNbTransferredPax = 0;
                        iNbTransferredBags = 0;

                        iNbRecheckPax = 0;
                        iNbRecheckBags = 0;

                        iNbTransferredUnallocatedPax = 0;
                        iNbTransferredUnallocatedBags = 0;

                        iNbRecheckUnallocatedPax = 0;
                        iNbRecheckUnallocatedBags = 0;

                        iNbOnlineCheckInPax = 0;
                        iNbOnlineCheckInInBags = 0;
                        iNbOnlineCheckInVisitors = 0;
                    }
                    #region Function which permits to add a new pax with his different informations.
                    private void AddPax(int NbBags, int NbVisitors)
                    {
                        iNbGeneratedPax++;
                        iNbGeneratedBags += NbBags;
                        iNbGeneratedVisitors += NbVisitors;
                    }
                    public void AddOriginatingTerminatingPax(int NbBags, int NbVisitors)
                    {
                        AddPax(NbBags, NbVisitors);
                        iNbOriginatingTerminatingPax++;
                        iNbOriginatingTerminatingBags += NbBags;
                        iNbOriginatingTerminatingVisitors += NbVisitors;
                    }
                    public void AddTransferringPax(int NbBags)
                    {
                        AddPax(NbBags, 0);

                        iNbTransferredPax++;
                        iNbTransferredBags += NbBags;
                    }
                    public void AddRecheckPax(int NbBags)
                    {
                        AddPax(NbBags, 0);

                        iNbRecheckPax++;
                        iNbRecheckBags += NbBags;
                    }
                    public void AddTransferredUnallocatedPax(int NbBags)
                    {
                        AddPax(NbBags, 0);

                        iNbTransferredUnallocatedPax++;
                        iNbTransferredUnallocatedBags += NbBags;
                    }
                    public void AddRecheckUnallocatedPax(int NbBags)
                    {
                        AddPax(NbBags, 0);

                        iNbRecheckUnallocatedPax++;
                        iNbRecheckUnallocatedBags += NbBags;
                    }
                    public void AddOnlineCheckInPax(int NbBags, int NbVisitors)
                    {
                        AddPax(NbBags, NbVisitors);

                        iNbOnlineCheckInPax++;
                        iNbOnlineCheckInInBags += NbBags;
                        //iNbTransferredBags += NbBags;
                        iNbOnlineCheckInVisitors += NbVisitors;
                    }
                    #endregion

                    #region Static function which permit to have the columns name ot the tables.                    
                    public static String[] getArrivalLineColumns()
                    {
                        return new String[] { "Flight ID",
                                           "Expected Pax",
                                           "Generated Pax",
                                           "Terminating Pax",
                                           "Transferred Pax",
                                           "Generated Bags",
                                           "Terminating Bags",
                                           "Transferred Bags",
                                           "Generated Visitors"};
                    }
                    public const string FPD_PAX_COLUMN_NAME_FLIGHT_ID = "Flight ID";
                    public const string FPD_PAX_COLUMN_NAME_GENERATED_BAGS = "Generated Bags";
                    public const string FPD_PAX_COLUMN_NAME_ORIGINATING_BAGS = "Originating Bags";
                    public const string FPD_PAX_COLUMN_NAME_SELF_CI_BAGS = "Self Check In Bags";
                    public const string FPD_PAX_COLUMN_NAME_TRANSFERRED_BAGS = "Transferred Bags";
                    public static String[] getDepartureLineColumns()
                    {
                        return new String[] { FPD_PAX_COLUMN_NAME_FLIGHT_ID,        //"Flight ID", 
                                           "Expected Pax",
                                           "Generated Pax",
                                           "Originating Pax",
                                           "Self Check In Pax",
                                           "Transferred Pax",
                                           FPD_PAX_COLUMN_NAME_GENERATED_BAGS,      //"Generated Bags", 
                                           FPD_PAX_COLUMN_NAME_ORIGINATING_BAGS,    //"Originating Bags",
                                           FPD_PAX_COLUMN_NAME_SELF_CI_BAGS,        //"Self Check In Bags",
                                           FPD_PAX_COLUMN_NAME_TRANSFERRED_BAGS,    //"Transferred Bags",
                                           "Generated Visitors",
                                           "Originating Visitors",
                                           "Self Check In Visitors"};
                    }
                    public static String[] getArrivalPaxDetailsColumns()
                    {
                        return new String[] { "Flight ID",
                                           "Expected Pax",
                                           "Generated Pax",
                                           "Terminating Pax",
                                           "Transferred Pax",// (1/10)",
                                           "Recheck Pax",// (2)",
                                           "Unallocated Transferred Pax",// (-1/-10)",
                                           "Unallocated Recheck Pax"};// (-2)"};
                    }
                    public static String[] getDeparturePaxDetailsColumns()
                    {
                        return new String[] { "Flight ID",
                                           "Expected Pax",
                                           "Generated Pax",
                                           "Originating Pax",
                                           "Self check in Pax",
                                           "Transferred Pax",// (1/10)",
                                           "Recheck Pax",// (2)",
                                           "Unallocated Transferred Pax",// (-1/-10)",
                                           "Unallocated Recheck Pax"};// (-2)"};
                    }

                    public static String[] getArrivalBagsDetailsColumns()
                    {
                        return new String[] { "Flight ID",
                                           "Nb Terminating",// (0)", 
                                           "Nb Recheck",// (2)",
                                           "Nb Recheck (unallocated)",// (-2)",
                                           "Nb Transfer",//(1/10)",
                                           "Nb Transfer (unallocated)",// (-1/-10)",
                                           "Nb Total" };
                    }
                    public static String[] getDepartureBagsDetailsColumns()
                    {
                        return new String[] { "Flight ID",
                                           "Nb Originating",// (0)",
                                           "Nb Recheck",// (2)",
                                           "Nb Recheck (unallocated)",// (-2)",
                                           "Nb Transfer",//(1/10)",
                                           "Nb Transfer (unallocated)",// (-1/-10)",
                                           "Nb Total" };
                    }
                    public static String[] getArrivalVisitorsDetailsColumns()
                    {
                        return new String[] { "Flight ID",
                                              "Generated visitors"};
                    }
                    public static String[] getDepartureVisitorsDetailsColumns()
                    {
                        return new String[] {  "Flight ID",
                                               "Generated visitors",
                                               "Originating Visitors",
                                               "Self check in Visitors"};
                    }

                    #endregion

                    #region Functions which return the informations about the flights generated in the paxplan.
                    public Object[] getArrivalLine()
                    {
                        return new Object[] { _iFlightID,
                                           iNbPaxExpected,
                                           iNbGeneratedPax,
                                           iNbOriginatingTerminatingPax ,
                                           iNbTransferredPax + iNbRecheckPax+iNbTransferredUnallocatedPax+iNbRecheckUnallocatedPax,
                                           iNbGeneratedBags,
                                           iNbOriginatingTerminatingBags,
                                           iNbTransferredBags + iNbRecheckBags+iNbTransferredUnallocatedBags+iNbRecheckUnallocatedBags,
                                           iNbGeneratedVisitors};
                    }
                    public Object[] getDepartureLine()
                    {
                        return new Object[] { _iFlightID,
                                           iNbPaxExpected,
                                           iNbGeneratedPax,
                                           iNbOriginatingTerminatingPax ,
                                           iNbOnlineCheckInPax,
                                           iNbTransferredPax + iNbRecheckPax+iNbTransferredUnallocatedPax+iNbRecheckUnallocatedPax,
                                           iNbGeneratedBags,
                                           iNbOriginatingTerminatingBags,
                                           iNbOnlineCheckInInBags,
                                           iNbTransferredBags + iNbRecheckBags+iNbTransferredUnallocatedBags+iNbRecheckUnallocatedBags,
                                           iNbGeneratedVisitors,
                                           iNbOriginatingTerminatingVisitors,
                                           iNbOnlineCheckInVisitors};
                    }
                    public Object[] getArrivalPaxDetails()
                    {
                        return new Object[] { _iFlightID,
                                           iNbPaxExpected,
                                           iNbGeneratedPax,
                                           iNbOriginatingTerminatingPax ,
                                           iNbTransferredPax ,
                                           iNbRecheckPax,
                                           iNbTransferredUnallocatedPax,
                                           iNbRecheckUnallocatedPax};
                    }
                    public Object[] getDeparturePaxDetails()
                    {
                        return new Object[] { _iFlightID,
                                           iNbPaxExpected,
                                           iNbGeneratedPax,
                                           iNbOriginatingTerminatingPax,
                                           iNbOnlineCheckInPax,
                                           iNbTransferredPax ,
                                           iNbRecheckPax,
                                           iNbTransferredUnallocatedPax,
                                           iNbRecheckUnallocatedPax};
                    }

                    public Object[] getArrivalBagsDetails()
                    {
                        return new Object[] { _iFlightID,
                                           iNbOriginatingTerminatingBags,
                                           iNbRecheckBags,
                                           iNbRecheckUnallocatedBags,
                                           iNbTransferredBags ,
                                           iNbTransferredUnallocatedBags,
                                           iNbGeneratedBags };
                    }
                    public Object[] getDepartureBagsDetails()
                    {
                        return new Object[] { _iFlightID,
                                           iNbOriginatingTerminatingBags,
                                           iNbRecheckBags,
                                           iNbRecheckUnallocatedBags,
                                           iNbTransferredBags,
                                           iNbTransferredUnallocatedBags,
                                           iNbGeneratedBags };
                    }
                    public Object[] getArrivalVisitorsDetails()
                    {
                        return new Object[] { _iFlightID,
                                           iNbGeneratedVisitors};
                    }
                    public Object[] getDepartureVisitorsDetails()
                    {
                        return new Object[] { _iFlightID,
                                           iNbGeneratedVisitors,
                                           iNbOriginatingTerminatingVisitors,
                                           iNbOnlineCheckInVisitors};
                    }
                    #endregion
                }

                private bool CalcDistributionTables()
                {
                    if (_dtPaxPlanTable == null)
                        return false;
                    #region Initialisation des variables temporaires qui vont contenir les résultats attendus.
                    Dictionary<int, FlightStatistics> htDepartingFlight = new Dictionary<int, FlightStatistics>();
                    Dictionary<int, FlightStatistics> htArrivingFlight = new Dictionary<int, FlightStatistics>();
                    int i = 0;
                    for (i = 0; i < _dtFPDTable.Rows.Count; i++)
                    {
                        int iIdFlight = (int)_dtFPDTable.Rows[i][GlobalNames.sFPD_A_Column_ID];
                        int iExpectedPax = 0;
                        if (htDepartingFlightLoading.ContainsKey(iIdFlight))
                        {
                            iExpectedPax = (int)htDepartingFlightLoading[iIdFlight];
                        }
                        htDepartingFlight.Add(iIdFlight, new FlightStatistics(iIdFlight, iExpectedPax));
                    }
                    for (i = 0; i < _dtFPATable.Rows.Count; i++)
                    {
                        int iIdFlight = (int)_dtFPATable.Rows[i][GlobalNames.sFPD_A_Column_ID];
                        int iExpectedPax = 0;
                        if (htArrivalFlightLoading.ContainsKey(iIdFlight))
                        {
                            iExpectedPax = (int)htArrivalFlightLoading[iIdFlight];
                        }
                        htArrivingFlight.Add(iIdFlight, new FlightStatistics(iIdFlight, iExpectedPax));
                    }
                    #endregion
                    int iTransferValue, iNbBags, iNbVisitors, iFPD, iFPA, iSelfCheckIn;
                    FlightStatistics fsTmp;

                    int iIndexFPD = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_FPDID);
                    int iIndexBagages = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_BagsIG);
                    int iIndexVisitors = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_Visitors);
                    int iIndexFPA = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_FPAID);
                    int iIndexTransfer = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_Transfer);
                    int iIndexSelfCheckIn = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_SelfCI);
                    if (iIndexFPD == -1)
                        return false;
                    if (iIndexBagages == -1)
                        return false;
                    if (iIndexVisitors == -1)
                        return false;
                    if (iIndexFPA == -1)
                        return false;
                    if (iIndexTransfer == -1)
                        return false;
                    if (iIndexSelfCheckIn == -1)
                        return false;

                    #region Boucle de parcours du Paxplan
                    foreach (DataRow drLine in _dtPaxPlanTable.Rows)
                    {
                        iTransferValue = (int)drLine[iIndexTransfer];
                        iNbBags = Convert.ToInt32(drLine[iIndexBagages]);   // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                        //iNbBags = (int)drLine[iIndexBagages];
                        iNbVisitors = (int)drLine[iIndexVisitors];
                        iFPD = (int)drLine[iIndexFPD];
                        iFPA = (int)drLine[iIndexFPA];
                        iSelfCheckIn = (int)drLine[iIndexSelfCheckIn];
                        if ((iFPD != 0) && (iFPA == 0))
                        {
                            #region Departing pur
                            if (!htDepartingFlight.ContainsKey(iFPD))
                                continue;
                            fsTmp = (FlightStatistics)htDepartingFlight[iFPD];
                            if (iSelfCheckIn != 0)
                            {
                                fsTmp.AddOnlineCheckInPax(iNbBags, iNbVisitors);
                            }
                            else
                                if (iTransferValue == 0)
                            {
                                fsTmp.AddOriginatingTerminatingPax(iNbBags, iNbVisitors);
                            }/*
                            else if (iTransferValue == 1)
                            {
                                fsTmp.AddOnlineCheckInPax(iNbVisitors);
                            }*/
                            else if (iTransferValue == -2)
                            {
                                fsTmp.AddRecheckUnallocatedPax(iNbBags);
                            }
                            else
                            {
                                fsTmp.AddTransferredUnallocatedPax(iNbBags);
                            }
                            #endregion
                        }
                        else if ((iFPD == 0) && (iFPA != 0))
                        {
                            #region Arriving pur
                            if (!htArrivingFlight.ContainsKey(iFPA))
                                continue;
                            fsTmp = (FlightStatistics)htArrivingFlight[iFPA];
                            if (iTransferValue == 0)
                            {
                                fsTmp.AddOriginatingTerminatingPax(iNbBags, iNbVisitors);
                            }
                            else if (iTransferValue == -2)
                            {
                                fsTmp.AddRecheckUnallocatedPax(iNbBags);
                            }
                            else
                            {
                                fsTmp.AddTransferredUnallocatedPax(iNbBags);
                            }
                            #endregion
                        }
                        else
                        {
                            #region Transfer pur
                            if (!htArrivingFlight.ContainsKey(iFPA))
                                continue;
                            if (!htDepartingFlight.ContainsKey(iFPD))
                                continue;
                            if (iTransferValue == 2)
                            {
                                fsTmp = (FlightStatistics)htArrivingFlight[iFPA];
                                fsTmp.AddRecheckPax(iNbBags);

                                fsTmp = (FlightStatistics)htDepartingFlight[iFPD];
                                fsTmp.AddRecheckPax(iNbBags);
                            }
                            else if ((iTransferValue == 1) || (iTransferValue == 10))
                            {
                                fsTmp = (FlightStatistics)htArrivingFlight[iFPA];
                                fsTmp.AddTransferringPax(iNbBags);

                                fsTmp = (FlightStatistics)htDepartingFlight[iFPD];
                                fsTmp.AddTransferringPax(iNbBags);
                            }
                            #endregion
                        }
                    }
                    #endregion

                    //Table pour les nombres de baggages pour les vols.
                    _dtFPABags = new DataTable("FPA_Bags");
                    _dtFPDBags = new DataTable("FPD_Bags");
                    OverallTools.FonctionUtiles.initialiserTable(_dtFPABags, FlightStatistics.getArrivalBagsDetailsColumns(), typeof(Int32));
                    OverallTools.FonctionUtiles.initialiserTable(_dtFPDBags, FlightStatistics.getDepartureBagsDetailsColumns(), typeof(Int32));

                    _dtFPDPassengers = new DataTable("FPD_Pax");
                    _dtFPAPassengers = new DataTable("FPA_Pax");
                    OverallTools.FonctionUtiles.initialiserTable(_dtFPDPassengers, FlightStatistics.getDepartureLineColumns(), typeof(Int32));
                    OverallTools.FonctionUtiles.initialiserTable(_dtFPAPassengers, FlightStatistics.getArrivalLineColumns(), typeof(Int32));

                    DataTable dtDPaxDetails = new DataTable("Departure Pax Details");
                    DataTable dtAPaxDetails = new DataTable("Arrival Pax Details");
                    OverallTools.FonctionUtiles.initialiserTable(dtDPaxDetails, FlightStatistics.getDeparturePaxDetailsColumns(), typeof(Int32));
                    OverallTools.FonctionUtiles.initialiserTable(dtAPaxDetails, FlightStatistics.getArrivalPaxDetailsColumns(), typeof(Int32));

                    DataTable dtDVisitorsDetails = new DataTable("Departure Visitors Details");
                    DataTable dtAVisitorsDetails = new DataTable("Arrival Visitors Details");
                    OverallTools.FonctionUtiles.initialiserTable(dtDVisitorsDetails, FlightStatistics.getDepartureVisitorsDetailsColumns(), typeof(Int32));
                    OverallTools.FonctionUtiles.initialiserTable(dtAVisitorsDetails, FlightStatistics.getArrivalVisitorsDetailsColumns(), typeof(Int32));

                    foreach (FlightStatistics fsTmp2 in htDepartingFlight.Values)
                    {
                        _dtFPDBags.Rows.Add(fsTmp2.getDepartureBagsDetails());
                        _dtFPDPassengers.Rows.Add(fsTmp2.getDepartureLine());
                        dtDPaxDetails.Rows.Add(fsTmp2.getDeparturePaxDetails());
                        dtDVisitorsDetails.Rows.Add(fsTmp2.getDepartureVisitorsDetails());
                    }
                    foreach (FlightStatistics fsTmp2 in htArrivingFlight.Values)
                    {
                        _dtFPABags.Rows.Add(fsTmp2.getArrivalBagsDetails());
                        _dtFPAPassengers.Rows.Add(fsTmp2.getArrivalLine());
                        dtAPaxDetails.Rows.Add(fsTmp2.getArrivalPaxDetails());
                        dtAVisitorsDetails.Rows.Add(fsTmp2.getArrivalVisitorsDetails());
                    }

                    _dtFPDBags = OverallTools.DataFunctions.sortTable(_dtFPDBags, "Flight ID");
                    _dtFPABags = OverallTools.DataFunctions.sortTable(_dtFPABags, "Flight ID");

                    _dtFPDPassengers = OverallTools.DataFunctions.sortTable(_dtFPDPassengers, "Flight ID");
                    dtDPaxDetails = OverallTools.DataFunctions.sortTable(dtDPaxDetails, "Flight ID");
                    dtDVisitorsDetails = OverallTools.DataFunctions.sortTable(dtDVisitorsDetails, "Flight ID");

                    _dtFPAPassengers = OverallTools.DataFunctions.sortTable(_dtFPAPassengers, "Flight ID");
                    dtAPaxDetails = OverallTools.DataFunctions.sortTable(dtAPaxDetails, "Flight ID");
                    dtDVisitorsDetails = OverallTools.DataFunctions.sortTable(dtDVisitorsDetails, "Flight ID");

                    alResultsTables = new ArrayList();
                    alResultsTables.Add(_dtFPDPassengers);
                    alResultsTables.Add(dtDPaxDetails);
                    alResultsTables.Add(dtDVisitorsDetails);
                    alResultsTables.Add(_dtFPAPassengers);
                    alResultsTables.Add(dtAPaxDetails);
                    alResultsTables.Add(dtDVisitorsDetails);

                    return true;
                }

                #region Fonction statique pour la génération du nombre de bagages ou de passagers.
                /// <summary>
                /// Fonction statique pour la génération du nombre de bagages ou de passagers ou des temps de transfert.
                /// </summary>
                /// <param name="flightCategory">La categorie de vol</param>
                /// <param name="Repartition">La table de répartition</param>
                /// <param name="indexColonneResultat">La colonne a renvoyer.</param>
                /// <param name="rand">Le nombre aléatoire</param>
                /// <returns>Renvoie le contenu de la colonne spécifiée à la ligne répondant aux attentes</returns>
                private static String getNombreBaggageVisitorsTransferTime(String flightCategory, DataTable Repartition, int indexColonneResultat, double rand)
                {
                    int indexColonne = Repartition.Columns.IndexOf(flightCategory);
                    if (indexColonne == -1)
                    {
                        _ListeErreurs.Add("Err00152 : The flight category doesn't exist in the table" + Repartition.TableName);
                        return null;
                    }
                    return getNombreBaggageVisitorsTransferTime(indexColonne, Repartition, indexColonneResultat, rand);
                    /*double dValue;
                    foreach (DataRow lineRepartion in Repartition.Rows)
                    {
                        if (!Double.TryParse(lineRepartion.ItemArray[indexColonne].ToString(), out dValue))
                        {
                            _ListeErreurs.Add("Err00153 : The data in '" + Repartition.TableName + "' table does not have a good format.");
                            return null;
                        }
                        if ((dValue / 100.0f) > rand)
                        {
                            return lineRepartion.ItemArray[indexColonneResultat].ToString();
                        }
                        rand -= (dValue / 100.0f);
                    }

                    _ListeErreurs.Add("Err00154 : The data in '" + Repartition.TableName + "' table does not have a good format.");
                    return null;*/
                }

                /// <summary>
                /// Fonction statique pour la génération du nombre de bagages ou de passagers ou des temps de transfert.
                /// </summary>
                /// <param name="iIndexColumnDistrib">La colonne qui contient la distribution qui doit être observée.</param>
                /// <param name="Repartition">La table de répartition</param>
                /// <param name="indexColonneResultat">La colonne a renvoyer.</param>
                /// <param name="rand">Le nombre aléatoire</param>
                /// <returns>Renvoie le contenu de la colonne spécifiée à la ligne répondant aux attentes</returns>
                internal static String getNombreBaggageVisitorsTransferTime(int iIndexColumnDistrib, DataTable Repartition, int indexColonneResultat, double rand)
                {
                    if (Repartition == null)
                        return null;
                    if (iIndexColumnDistrib > Repartition.Columns.Count)
                        return null;
                    if (Repartition.Rows.Count == 0)
                        return null;

                    double dValue;

                    try
                    {
                        foreach (DataRow lineRepartion in Repartition.Rows)
                        {
                            if (!Double.TryParse(lineRepartion.ItemArray[iIndexColumnDistrib].ToString(), out dValue))
                            {
                                _ListeErreurs.Add("Err00153 : The data in '" + Repartition.TableName + "' table does not have a good format.");
                                return null;
                            }

                            if ((dValue / 100.0f) >= rand)
                            {
                                return lineRepartion.ItemArray[indexColonneResultat].ToString();
                            }

                            rand -= (dValue / 100.0f);
                        }
                    }
                    catch (Exception ex)
                    {
                        throw ex;
                    }

                    _ListeErreurs.Add("Err00154 : The data in '" + Repartition.TableName + "' table does not have a good format.");
                    return null;
                    //return "";
                }
                /// <summary>
                /// Fonction statique pour la génération du nombre de trolley en fonction du nombre de bagages.
                /// </summary>
                /// <param name="flightCategory">La categorie de vol</param>
                /// <param name="Repartition">La table de répartition</param>
                /// <param name="indexColonneResultat">La colonne a renvoyer.</param>
                /// <param name="rand">Le nombre aléatoire</param>
                /// <returns>Renvoie le contenu de la colonne spécifiée à la ligne répondant aux attentes</returns>
                private static String getNombreTrolley(String flightCategory, DataTable Repartition, int indexColonneResultat, int iNBBags, double rand)
                {
                    int indexColonne = Repartition.Columns.IndexOf(flightCategory);
                    if (indexColonne == -1)
                    {
                        _ListeErreurs.Add("Err00156 : The flight category doesn't exist in the table" + Repartition.TableName);
                        return null;
                    }
                    return getNombreTrolley(indexColonne, Repartition, indexColonneResultat, iNBBags, rand);
                    /*int iIndexTests = iNBBags * 3;
                    double dValue;
                    for (int i = 0; i < 3; i++)
                    {
                        if (!Double.TryParse(Repartition.Rows[iIndexTests + i][indexColonne].ToString(), out dValue))
                        {
                            _ListeErreurs.Add("Err00157 : The data in '" + Repartition.TableName + "' table does not have a good format.");
                            return null;
                        }
                        if ((dValue / 100.0f) > rand)
                        {
                            return Repartition.Rows[iIndexTests + i][indexColonneResultat].ToString();
                        }
                        rand -= (dValue / 100.0f);
                    }

                    _ListeErreurs.Add("Err00154 : The data in '" + Repartition.TableName + "' table does not have a good format.");
                    return null;*/
                }
                private static String getNombreTrolley(int iIndexColumnDistrib, DataTable Repartition, int indexColonneResultat, int iNBBags, double rand)
                {
                    if (Repartition.Columns.Count <= iIndexColumnDistrib)
                        return null;
                    if (Repartition.Rows.Count == 0)
                        return null;

                    int iIndexTests = iNBBags * 3;
                    if (iIndexTests >= Repartition.Rows.Count)
                    {
                        iIndexTests = Repartition.Rows.Count - 3;   // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                    }
                    double dValue;
                    for (int i = 0; i < 3; i++)
                    {
                        if (!Double.TryParse(Repartition.Rows[iIndexTests + i][iIndexColumnDistrib].ToString(), out dValue))
                        {
                            _ListeErreurs.Add("Err00157 : The data in '" + Repartition.TableName + "' table does not have a good format.");
                            return null;
                        }
                        if ((dValue / 100.0f) > rand)
                        {
                            return Repartition.Rows[iIndexTests + i][indexColonneResultat].ToString();
                        }
                        rand -= (dValue / 100.0f);
                    }

                    _ListeErreurs.Add("Err00154 : The data in '" + Repartition.TableName + "' table does not have a good format.");
                    return null;
                }
                //<< Task #7405 - new Desk and extra information for Pax
                internal static String getUserAttributeValue(int iIndexColumnDistrib, DataTable Repartition, int indexColonneResultat, double rand)
                {
                    if (Repartition == null)
                        return null;
                    if (iIndexColumnDistrib > Repartition.Columns.Count)
                        return null;
                    if (Repartition.Rows.Count == 0)
                        return null;

                    double dValue;
                    foreach (DataRow lineRepartion in Repartition.Rows)
                    {
                        if (!Double.TryParse(lineRepartion.ItemArray[iIndexColumnDistrib].ToString(), out dValue))
                        {
                            _ListeErreurs.Add("Err00153 : The data in '" + Repartition.TableName + "' table does not have a good format.");
                            return null;
                        }
                        if ((dValue / 100.0f) > rand)
                        {
                            return lineRepartion.ItemArray[indexColonneResultat].ToString();
                        }
                        rand -= (dValue / 100.0f);
                    }

                    _ListeErreurs.Add("Err00154 : The data in '" + Repartition.TableName + "' table does not have a good format.");
                    return null;
                }
                //>> Task #7405 - new Desk and extra information for Pax
                #endregion

                #region Nouvelle fonction pour la génération des passagers en arrivée.
                private bool _GeneratePassengersArrival(bool bCalcTransfer)
                {
                    //The new line for the PaxPlan
                    DataRow nouvelleLigne;
                    #region Get the indexes of the differents columns in PaxPlanTable
                    int iPaxID = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_PaxID);
                    int iPaxCreationTime = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_CreationTime);
                    int iFPA_ID = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_FPAID);
                    int iFPA_Class = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_FPAClass);
                    int iFPD_ID = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_FPDID);
                    int iFDP_Class = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_FPDClass);
                    int iFPD_STD = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_FPDSTD);
                    int iSelf_CheckIn = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_SelfCI);

                    int iNbVisitors = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_Visitors);
                    int iNbBags = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_BagsIG);
                    int iNbBagsOOG = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_BagsOOG);
                    int iNBTrolleys = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_Trolleys);
                    int iSegregation = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_Segregation);

                    int iPassportLocal = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_Local);
                    int iTransfer = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_Transfer);

#if (PAXINOUTUTILISATION)
                    int iTerminalInOut = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_TerminalInOut);
                    int iInOut = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_InOut);
#endif
                    #region //SGE-26/03/2012-Begin
#if(PARKINGMULHOUSE)
                    int iCarIndex = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_Car);
#endif
                    #endregion //SGE-26/03/2012-End
                    //<< Task #7405 - new Desk and extra information for Pax
                    Dictionary<string, int> indexesForUserAttribColumnsDictionary = new Dictionary<string, int>();

                    // << Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab
                    if (userAttributesDistributionTables != null && userAttributesDistributionTables.Count > 0)
                    {
                        foreach (KeyValuePair<String, NormalTable> pair in userAttributesDistributionTables)
                        {
                            String columnName = pair.Key;
                            // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                            if (GlobalNames.nonUserAttributesExceptionsList.Contains(columnName))
                                continue;
                            // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                            int columnIndex = _dtPaxPlanTable.Columns.IndexOf(columnName);
                            if (columnIndex != -1)
                                indexesForUserAttribColumnsDictionary.Add(columnName, columnIndex);
                        }
                    }
                    // >> Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab
                    //>> Task #7405 - new Desk and extra information for Pax

                    // >> Task #10764 Pax2Sim - new User attributes for Groups
                    int paxCheckInGroupUserAttributeColumnIndex = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.PAX_CI_GROUP_USER_ATTRIBUTE);
                    int paxTransferGroupUserAttributeColumnIndex = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.PAX_TRANSFER_GROUP_USER_ATTRIBUTE);
                    int paxReclaimGroupUserAttributeColumnIndex = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.PAX_RECLAIM_GROUP_USER_ATTRIBUTE);
                    int paxBoardingGateGroupUserAttributeColumnIndex = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.PAX_BOARDING_GATE_GROUP_USER_ATTRIBUTE);
                    // << Task #10764 Pax2Sim - new User attributes for Groups
                    #endregion
                    int FPid;
                    //The new row for the Pax_TransferLog.
                    String[] Pax_GenTransferLogLine = new String[GestionDonneesHUB2SIM.ListeEntete_PaxGenTransferLog.Length];
                    int i;


                    int identifiantPax = 1;
                    if (_dtPaxPlanTable.Rows.Count > 0)
                    {
                        //We look for the identifier for the first passenger.
                        identifiantPax = (int)OverallTools.DataFunctions.getMaxValue(_dtPaxPlanTable, 0) + 1;
                    }
                    #region Initialization of the differents informations for transfers
                    if (tdTransferTerminalDistribution == null)
                        obtenirDistributionTerminal();
                    if (tdTransferFlightCategoryDistribution == null)
                        obtenirDistributionFlightCategory();
                    if (bCalcTransfer)
                    {
                        //We just find in the flight plan departure the number of passagers which are in transfer.
                        tiTransferTransferredFlights = obtenirNombreTransfert(_dtFPDTable, etFPDLoadFactors, false, (tdTransferFlightCategoryDistribution != null));
                    }
                    //The min and max inter connecting time
                    DataTable dtInterConnectingTable = etInterConnectingTimesTable.Table;
                    Double tempsMini = OverallTools.DataFunctions.valeurMinimaleDansColonne(dtInterConnectingTable, 0);
                    Double tempsMaxi = OverallTools.DataFunctions.valeurMaximaleDansColonne(dtInterConnectingTable, 1);
                    #endregion

                    #region Initialisation of all the random streams
                    Random randClasse = new Random(_Seed);
                    Random randPassport = new Random(_Seed * 2);
                    Random randTerminating = new Random(_Seed * 3);
                    Random randVisitors = new Random(_Seed * 4);
                    Random randReCheck = new Random(_Seed * 5);
                    Random randDesk = new Random(_Seed * 6);
                    Random randBaggage = new Random(_Seed * 7);
                    Random randTime = new Random(_Seed * 8);
                    Random randCreneau = new Random(_Seed * 9);
                    Random randVol = new Random(_Seed * 10);
                    Random randTerminal = new Random(_Seed * 11);
                    Random randTrolley = new Random(_Seed * 17);
                    Random randOOGTransf = new Random(_Seed * 18);
                    Random randOOGTerm = new Random(_Seed * 20);
                    Random randOutTerminal = new Random(_Seed * 24);

                    //<< Task #7405 - new Desk and extra information for Pax
                    Dictionary<string, Random> randomsForUserAttribColumnsDictionary = new Dictionary<string, Random>();
                    if (userAttributesTable != null && userAttributesTable.Rows.Count > 0)
                    {
                        int k = 100;
                        if (userAttributesDistributionTables != null)
                        {
                            foreach (KeyValuePair<String, NormalTable> pair in userAttributesDistributionTables)
                            {
                                String userAttributeName = pair.Key;
                                NormalTable distributionTable = pair.Value;
                                String columnName = userAttributeName;
                                // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                if (GlobalNames.nonUserAttributesExceptionsList.Contains(columnName))
                                    continue;
                                // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                k++;
                                Random randUserAttribute = new Random(_Seed * k);
                                randomsForUserAttribColumnsDictionary.Add(columnName, randUserAttribute);

                            }
                        }
                        /*
                                                foreach (DataRow row in userAttributesTable.Rows)
                                                {                            
                                                    String columnName = row[GlobalNames.sUserAttributes_ColumnName].ToString();
                                                    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                                    if (GlobalNames.nonUserAttributesExceptionsList.Contains(columnName))
                                                        continue;
                                                    // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                                    k++;
                                                    Random randUserAttribute = new Random(_Seed * k);
                                                    randomsForUserAttribColumnsDictionary.Add(columnName, randUserAttribute);                            
                                                }
                        */
                    }
                    //>> Task #7405 - new Desk and extra information for Pax

                    #region //SGE-26/03/2012-Begin
#if(PARKINGMULHOUSE)
                    Random randShortStay = new Random(_Seed * 25);
                    Random randLongStay = new Random(_Seed * 26);
                    Random randStaySpread = new Random(_Seed * 27);
                    Random randEmport = new Random(_Seed * 28);
#endif
                    #endregion //SGE-26/03/2012-End
                    #endregion


                    htArrivalFlightLoading = new Dictionary<int, int>();

                    //For each flight which arrive
                    foreach (DataRow line in _dtFPATable.Rows)
                    {
                        FPid = FonctionsType.getInt(OverallTools.DataFunctions.getValue(line, GlobalNames.sFPD_A_Column_ID), typeof(String));

                        #region First we look if this flight is between the 2 dates.
                        DateTime heureArrivee, heureSortiePax;
                        heureArrivee = OverallTools.DataFunctions.toDateTime(OverallTools.DataFunctions.getValue(line, GlobalNames.sFPD_A_Column_DATE), OverallTools.DataFunctions.getValue(line, GlobalNames.sFPA_Column_STA));
                        if (_slfLoadingForm != null)
                            _slfLoadingForm.ChargementFichier("PaxPlan generation : Arrival Flight : " + FPid.ToString());

                        if (heureArrivee == DateTime.MinValue)
                        {
                            _ListeErreurs.Add("Err00095 : The date or the time does not have a valid format.");
                            continue;
                        }
                        if ((heureArrivee < _dtStartDate) || (heureArrivee > _dtEndDate))
                        {
                            _ListeErreurs.Add("Warn151 : Flight " + FPid.ToString() + " from the FPA is ignored. It doesn't match the range.");
                            continue;
                        }
                        #endregion

                        heureSortiePax = heureArrivee;

                        #region We look for the number of passenger which have take their flight (and their specification (passport / Bags...)
                        double nombrePassagers = -1;    // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                        FlightConfiguration flightConfiguration = Tools.FlightPlanParametersTools
                            .getFlightConfigurationByArrOrDepAndFlightId(FlightAttribute.ARR_OR_DEP_FLIGHT_TAG.A, FPid, flightConfigurations);
                        if (flightConfiguration != null)
                        {
                            nombrePassagers = flightConfiguration.flightParameter.nbTermEcoPax + flightConfiguration.flightParameter.nbTermFbPax
                                + flightConfiguration.flightParameter.nbTransferEcoPax + flightConfiguration.flightParameter.nbTransferFbPax;
                        }
                        else
                        {
                            nombrePassagers = OverallTools.DataFunctions.numberOfPassengers(line, etAircraftType, _dtFlightCategories, etFPALoadFactors, _ListeErreurs);
                        }
                        if (nombrePassagers == -1)
                        {
                            //The number of passengers is not valid
                            _ListeErreurs.Add("Err00096 : The number of passenger on the arrival flight " + FPid.ToString() + " cannot be found.");
                            continue;
                        }
                        //We look for the flight category of this flight and for the load factors.
                        String sFlightCategory = OverallTools.DataFunctions.getValue(line, GlobalNames.sFPD_A_Column_FlightCategory);
                        String sAirline = OverallTools.DataFunctions.getValue(line, GlobalNames.sFPD_A_Column_AirlineCode);

                        Dictionary<String, String> dssLoadFactorsEco = etFPALoadFactors.GetInformationsColumns(0, "A_" + FPid.ToString(), sAirline, sFlightCategory);
                        Dictionary<String, String> dssLoadFactorsFirst = etFPALoadFactors.GetInformationsColumns(1, "A_" + FPid.ToString(), sAirline, sFlightCategory);
                        String sPremiere = dssLoadFactorsEco[GlobalNames.sLFD_A_Line_C];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_C, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        String sSeconde = dssLoadFactorsEco[GlobalNames.sLFD_A_Line_Y]; //OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_Y, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));

                        htArrivalFlightLoading.Add(FPid, (int)nombrePassagers);
                        double dPremiere, dSeconde;
                        if ((sPremiere == null) || (sSeconde == null) ||
                            (!double.TryParse(sPremiere, out dPremiere)) ||
                            (!double.TryParse(sSeconde, out dSeconde)))
                        {
                            _ListeErreurs.Add("Err00093 : The class distribution doesn't have a good format");
                            continue;
                        }
                        String sLocal, sNotLocal, sTerminating, sTransferring, sTransferReCheck, sTransferDesk, sOOGTerm, sOOGtransf, sEmport;
                        String sLocalFB, sNotLocalFB, sTerminatingFB, sTransferringFB, sTransferReCheckFB, sTransferDeskFB, sOOGTermFB, sOOGtransfFB, sEmportFB;

                        sLocal = dssLoadFactorsEco[GlobalNames.sLFD_A_Line_Local];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_Local, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sNotLocal = dssLoadFactorsEco[GlobalNames.sLFD_A_Line_NotLocal];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_NotLocal, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sTerminating = dssLoadFactorsEco[GlobalNames.sLFA_Line_Terminating];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFA_Line_Terminating, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sTransferring = dssLoadFactorsEco[GlobalNames.sLFD_A_Line_Transferring];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_Transferring, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sTransferReCheck = dssLoadFactorsEco[GlobalNames.sLFD_A_Line_ReCheck];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_ReCheck, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sTransferDesk = dssLoadFactorsEco[GlobalNames.sLFD_A_Line_TransferDesk];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_TransferDesk, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sOOGTerm = dssLoadFactorsEco[GlobalNames.sLFA_Line_OOGTerm];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFA_Line_OOGTerm, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sOOGtransf = dssLoadFactorsEco[GlobalNames.sLFD_A_Line_OOGTransf];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_OOGTransf, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));

                        sLocalFB = dssLoadFactorsFirst[GlobalNames.sLFD_A_Line_Local];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_Local, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sNotLocalFB = dssLoadFactorsFirst[GlobalNames.sLFD_A_Line_NotLocal];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_NotLocal, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sTerminatingFB = dssLoadFactorsFirst[GlobalNames.sLFA_Line_Terminating];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFA_Line_Terminating, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sTransferringFB = dssLoadFactorsFirst[GlobalNames.sLFD_A_Line_Transferring];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_Transferring, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sTransferReCheckFB = dssLoadFactorsFirst[GlobalNames.sLFD_A_Line_ReCheck];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_ReCheck, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sTransferDeskFB = dssLoadFactorsFirst[GlobalNames.sLFD_A_Line_TransferDesk];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_TransferDesk, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sOOGTermFB = dssLoadFactorsFirst[GlobalNames.sLFA_Line_OOGTerm];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFA_Line_OOGTerm, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sOOGtransfFB = dssLoadFactorsFirst[GlobalNames.sLFD_A_Line_OOGTransf];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_OOGTransf, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));


                        #region //SGE-26/03/2012-Begin
#if(PARKINGMULHOUSE)
                        if (!dssLoadFactorsEco.ContainsKey(GlobalNames.sLFD_A_Line_NbPaxPerCar))
                            sEmport = "0";
                        else
                            sEmport = dssLoadFactorsEco[GlobalNames.sLFD_A_Line_NbPaxPerCar];
                        if (!dssLoadFactorsFirst.ContainsKey(GlobalNames.sLFD_A_Line_NbPaxPerCar))
                            sEmportFB = "0";
                        else
                            sEmportFB = dssLoadFactorsFirst[GlobalNames.sLFD_A_Line_NbPaxPerCar];
                        Double dEmport, dEmportFB;
#endif
                        #endregion //SGE-26/03/2012-End

                        Double dLocal, dNotLocal, dTerminatingPercent, dTransferring, dTransferReCheck, dTransferDesk, dOOGTerm, dOOGtransf;
                        if ((sLocal == null) || (sNotLocal == null) || (sTerminating == null) || (sTransferring == null) || (sTransferReCheck == null) || (sTransferDesk == null) ||
                        #region //SGE-26/03/2012-Begin
#if(PARKINGMULHOUSE)
                            (sEmport == null) ||
                            (!double.TryParse(sEmport, out dEmport)) ||
#endif
                        #endregion //SGE-26/03/2012-End

                            (!double.TryParse(sLocal, out dLocal)) ||
                            (!double.TryParse(sNotLocal, out dNotLocal)) ||
                            (!double.TryParse(sTerminating, out dTerminatingPercent)) ||
                            (!double.TryParse(sTransferring, out dTransferring)) ||
                            (!double.TryParse(sTransferReCheck, out dTransferReCheck)) ||
                            (!double.TryParse(sTransferDesk, out dTransferDesk)) ||
                            (!double.TryParse(sOOGtransf, out dOOGtransf)) ||
                            (!double.TryParse(sOOGTerm, out dOOGTerm)))
                        {
                            _ListeErreurs.Add("Err00094 : The transfer distribution doesn't have a good format");
                            continue;
                        }

                        Double dLocalFB, dNotLocalFB, dTerminatingFB, dTransferringFB, dTransferReCheckFB, dTransferDeskFB, dOOGTermFB, dOOGtransfFB;
                        if ((sLocalFB == null) || (sNotLocalFB == null) || (sTerminatingFB == null) || (sTransferringFB == null) || (sTransferReCheckFB == null) || (sTransferDeskFB == null) ||
                        #region //SGE-26/03/2012-Begin
#if(PARKINGMULHOUSE)
                           (sEmportFB == null) ||
                            (!double.TryParse(sEmportFB, out dEmportFB)) ||
#endif
                        #endregion //SGE-26/03/2012-End
                            (!double.TryParse(sLocalFB, out dLocalFB)) ||
                            (!double.TryParse(sNotLocalFB, out dNotLocalFB)) ||
                            (!double.TryParse(sTerminatingFB, out dTerminatingFB)) ||
                            (!double.TryParse(sTransferringFB, out dTransferringFB)) ||
                            (!double.TryParse(sTransferReCheckFB, out dTransferReCheckFB)) ||
                            (!double.TryParse(sTransferDeskFB, out dTransferDeskFB)) ||
                            (!double.TryParse(sOOGtransfFB, out dOOGtransfFB)) ||
                            (!double.TryParse(sOOGTermFB, out dOOGTermFB)))
                        {
                            _ListeErreurs.Add("Err00427 : The transfer distribution doesn't have a good format for the First & Business classes.");
                            continue;
                        }
                        #endregion

                        #region Transfer specifications
                        Double dClasse, dTypePassport, dReCheck, dDesk;
                        int transferValue = 0;

                        Double dFirstFlightTime = OverallTools.DataFunctions.MinuteDifference(_dtStartDate, heureArrivee.AddMinutes(tempsMini));
                        Double dLastFlightTime = OverallTools.DataFunctions.MinuteDifference(_dtStartDate, heureArrivee.AddMinutes(tempsMaxi));

                        int iTerminalGate;
                        if (!Int32.TryParse(line[GlobalNames.sFPD_A_Column_TerminalGate].ToString(), out iTerminalGate))
                            iTerminalGate = -1;
                        if (_dtTransferTerminalDistribution == null)
                            iTerminalGate = -1;
                        if (_dtTransferFlightCategoryDistribution != null)
                        {
                            iTerminalGate = alFlightCategory.IndexOf(sFlightCategory);
                        }
                        //On obtient un tableau contenant tous les vols qui peuvent faire l'objet d'un transfert à partir du vol courant.
                        bool[] VolsTransferable = null;
                        double iPaxTransfer = -1;   // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                        if (flightConfiguration != null)
                        {
                            iPaxTransfer = flightConfiguration.flightParameter.nbTransferEcoPax + flightConfiguration.flightParameter.nbTransferFbPax;
                        }
                        else
                        {
                            iPaxTransfer = (int)Math.Round(((100.0 - dTerminatingPercent) * (Double)nombrePassagers) / 100);
                        }

                        int iFlightIndex = -1;
                        if (bCalcTransfer)
                        {
                            VolsTransferable = obtenirVolsTransfert(tiTransferTransferredFlights, dFirstFlightTime, dLastFlightTime, iTerminalGate);
                        }
                        else
                        {
                            double iMissedFlight = 0;
                            if (_bFillTransfer)
                            {
                                iFlightIndex = getFlightIndex(FPid);
                                if (iFlightIndex != -1)
                                {
                                    iMissedFlight = tiTransferTransferredFlights[iFlightIndex, 3] + tiTransferTransferredFlights[iFlightIndex, 4];
                                }
                            }
                            nombrePassagers -= iPaxTransfer - iMissedFlight;
                            iPaxTransfer = iMissedFlight;
                        }
                        #endregion


                        Pax_GenTransferLogLine[2] = OverallTools.DataFunctions.MinuteDifference(_dtStartDate, heureArrivee).ToString();
                        Pax_GenTransferLogLine[1] = FPid.ToString();
                        #region We are getting the informations for every expcetion tables.
                        int iIndexVisitorEco, iIndexVisitorFB, iIndexBagageEco, iIndexBagageFB, iIndexTrolleyEco, iIndexTrolleyFB;
                        DataTable dtVisitorEco = etVisitorsDistrib.GetInformationsColumns(0, "A_" + FPid.ToString(), sAirline, sFlightCategory, out iIndexVisitorEco);
                        DataTable dtVisitorFB = etVisitorsDistrib.GetInformationsColumns(1, "A_" + FPid.ToString(), sAirline, sFlightCategory, out iIndexVisitorFB);
                        DataTable dtBagageEco = etBagsDistrib.GetInformationsColumns(0, "A_" + FPid.ToString(), sAirline, sFlightCategory, out iIndexBagageEco);
                        DataTable dtBagageFB = etBagsDistrib.GetInformationsColumns(1, "A_" + FPid.ToString(), sAirline, sFlightCategory, out iIndexBagageFB);
                        DataTable dtTrolleyEco = etTrolleyDistrib.GetInformationsColumns(0, "A_" + FPid.ToString(), sAirline, sFlightCategory, out iIndexTrolleyEco);
                        DataTable dtTrolleyFB = etTrolleyDistrib.GetInformationsColumns(1, "A_" + FPid.ToString(), sAirline, sFlightCategory, out iIndexTrolleyFB);

                        #region //SGE-26/03/2012-Begin
#if (PARKINGMULHOUSE)
                        /*int iIndexShortStayFB, iIndexShortStay;
                        DataTable dtShortStay = etShortStayDistribution.GetInformationsColumns(0, "A_" + FPid.ToString(), sAirline, sFlightCategory, out iIndexShortStay);
                        DataTable dtShortStayFB = etShortStayDistribution.GetInformationsColumns(1, "A_" + FPid.ToString(), sAirline, sFlightCategory, out iIndexShortStayFB);*/
#endif
                        #endregion//SGE-26/03/2012-End

                        //<< Task #7405 - new Desk and extra information for Pax
                        if (userAttributesDistributionTables != null)
                        {
                            userAttribDistribExceptionTablesEco.Clear();
                            userAttribDistribExceptionTablesFB.Clear();
                            userAttribDistribExceptionIndexesEco.Clear();
                            userAttribDistribExceptionIndexesFB.Clear();
                            foreach (KeyValuePair<string, DataManagement.NormalTable> pair in userAttributesDistributionTables)
                            {

                                DataManagement.NormalTable distributionTable = pair.Value;
                                // << Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab
                                //String distributionTableName = pair.Key;
                                String distributionTableName = "";
                                if (distributionTable != null)
                                    distributionTableName = distributionTable.Table.TableName;
                                // >> Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab

                                int indexDistributionEco = -1;
                                int indexDistributionFB = -1;
                                DataTable distributionTableEco = null;
                                DataTable distributionTableFB = null;
                                DataManagement.ExceptionTable distributionExceptionTable = null;

                                if (distributionTable is DataManagement.ExceptionTable)
                                {
                                    distributionExceptionTable = (DataManagement.ExceptionTable)distributionTable;

                                    if (distributionExceptionTable != null)
                                    {
                                        distributionTableEco = distributionExceptionTable.GetInformationsColumns(0, "A_" + FPid.ToString(), sAirline, sFlightCategory, out indexDistributionEco);
                                        distributionTableFB = distributionExceptionTable.GetInformationsColumns(1, "A_" + FPid.ToString(), sAirline, sFlightCategory, out indexDistributionFB);
                                    }
                                    if (distributionTableEco != null && indexDistributionEco != -1)
                                    {
                                        userAttribDistribExceptionTablesEco.Add(distributionTableName, distributionTableEco);
                                        userAttribDistribExceptionIndexesEco.Add(distributionTableName, indexDistributionEco);
                                    }
                                    if (distributionTableFB != null && indexDistributionFB != -1)
                                    {
                                        userAttribDistribExceptionTablesFB.Add(distributionTableName, distributionTableFB);
                                        userAttribDistribExceptionIndexesFB.Add(distributionTableName, indexDistributionFB);
                                    }
                                }
                                else
                                {
                                    // >> Bug #11385 Pax2Sim - Pax plan - Flight subcategories column not filled
                                    if (distributionTable.Table.TableName.Equals(GlobalNames.flightSubcategoriesTableName))
                                    {
                                        int selectedFlightCategoryIndex = distributionTable.Table.Columns.IndexOf(sFlightCategory);
                                        if (selectedFlightCategoryIndex != -1)
                                        {
                                            userAttribDistribExceptionTablesEco.Add(distributionTableName, distributionTable.Table);
                                            userAttribDistribExceptionIndexesEco.Add(distributionTableName, selectedFlightCategoryIndex);

                                            userAttribDistribExceptionTablesFB.Add(distributionTableName, distributionTable.Table);
                                            userAttribDistribExceptionIndexesFB.Add(distributionTableName, selectedFlightCategoryIndex);
                                        }
                                    }
                                    // << Bug #11385 Pax2Sim - Pax plan - Flight subcategories column not filled
                                }
                            }
                        }
                        //>> Task #7405 - new Desk and extra information for Pax
                        #endregion

                        // >> Task #10764 Pax2Sim - new User attributes for Groups                        
                        String terminalNbReclaimGroupNbLabel = _donnees
                            .getTerminalNbGroupNbLabelByGroupType(GlobalNames.RECLAIM_GROUP_TYPE, line);
                        // << Task #10764 Pax2Sim - new User attributes for Groups

                        Double dTmp;
                        for (i = 0; i < nombrePassagers; i++)
                        {
                            #region Decide here if the passenger is a transfer passenger or not.
                            bool bTransferredPax = randTerminating.NextDouble() >= (dTerminatingPercent / 100.0f);
                            bTransferredPax = bTransferredPax || (iPaxTransfer == (nombrePassagers - i));
                            bTransferredPax = bTransferredPax && (iPaxTransfer > 0);
                            if (bTransferredPax)
                                iPaxTransfer--;
                            #endregion

                            #region Calculation of the arriving time of the passenger on the airport
                            Double lCreationTime = OverallTools.DataFunctions.MinuteDifference(_dtStartDate, heureSortiePax);
                            if ((lCreationTime < 0) && !_bGenerateAllPax)
                            {
                                continue;
                            }
                            else if (lCreationTime < 0)
                            {
                                lCreationTime = 0;
                            }
                            #endregion

                            nouvelleLigne = _dtPaxPlanTable.NewRow();
                            nouvelleLigne[iPaxID] = identifiantPax;
                            nouvelleLigne[iPaxCreationTime] = lCreationTime;
                            nouvelleLigne[iFPA_ID] = FPid;

                            #region We have to choose the class for the passenger : 
                            dClasse = randClasse.NextDouble();
                            bool bSecond = true;
                            if (dClasse < (dPremiere / 100.0f))
                            {
                                nouvelleLigne[iFPA_Class] = 1;
                                bSecond = false;
                            }
                            else
                            {
                                nouvelleLigne[iFPA_Class] = 2;
                            }
                            #endregion

                            #region We choose the type of passport
                            dTmp = dLocal;
                            if (!bSecond)
                                dTmp = dLocalFB;
                            dTypePassport = randPassport.NextDouble();
                            if (dTypePassport < (dTmp / 100.0f))
                            {
                                nouvelleLigne[iPassportLocal] = 1;
                            }
                            else
                            {
                                nouvelleLigne[iPassportLocal] = 2;
                            }
                            #endregion

                            nouvelleLigne[iFPD_ID] = 0;
                            nouvelleLigne[iFDP_Class] = 0;
                            nouvelleLigne[iFPD_STD] = 0;
                            nouvelleLigne[iSelf_CheckIn] = 0;

                            transferValue = 0;
                            if (!bTransferredPax)
                            {
                                #region Terminating passenger
                                nouvelleLigne[iTransfer] = 0;
                                String nbVisitors = "";
                                if (bSecond)
                                {
                                    nbVisitors = getNombreBaggageVisitorsTransferTime(iIndexVisitorEco, dtVisitorEco, 0, randVisitors.NextDouble());
                                }
                                else
                                {
                                    nbVisitors = getNombreBaggageVisitorsTransferTime(iIndexVisitorFB, dtVisitorFB, 0, randVisitors.NextDouble());
                                }

                                if (nbVisitors == null)
                                {
                                    continue;
                                }
                                nouvelleLigne[iNbVisitors] = FonctionsType.getInt(nbVisitors, nbVisitors.GetType());

#if (PAXINOUTUTILISATION)
                                Point ptOut = GetInOutPointForPax(etPaxOutDistrib, (int)nouvelleLigne[iFPA_Class], "A_" + FPid.ToString(), line[GlobalNames.sFPD_A_Column_FlightCategory].ToString(), sAirline, "T" + line[GlobalNames.sFPA_Column_TerminalReclaim].ToString(), randOutTerminal);
                                nouvelleLigne[iTerminalInOut] = ptOut.X;
                                nouvelleLigne[iInOut] = ptOut.Y;
#endif

                                #endregion
                            }
                            else
                            {
                                #region Transfering Passagers

                                #region Deceide what kind of transfer for the passenger
                                dTmp = dTransferReCheck;
                                if (!bSecond)
                                    dTmp = dTransferReCheckFB;

                                dReCheck = randReCheck.NextDouble();
                                if (dReCheck < (dTmp / 100.0f))
                                {
                                    transferValue = 2;
                                }
                                else
                                {
                                    transferValue = 1;
                                    /*Ici, déplacer les 4 lignes de codes ci dessous en dehors du if pour
                                     * pourvoir regénérer les Transfer 20.*/

                                    dTmp = dTransferDesk;
                                    if (!bSecond)
                                        dTmp = dTransferDeskFB;

                                    dDesk = randDesk.NextDouble();
                                    if (dDesk < (dTmp / 100.0f))
                                    {
                                        transferValue *= 10;
                                    }
                                }
                                #endregion

                                nouvelleLigne[iNbVisitors] = 0;
                                nouvelleLigne[iTransfer] = transferValue;

                                Pax_GenTransferLogLine[0] = nouvelleLigne[0].ToString();
                                Pax_GenTransferLogLine[3] = nouvelleLigne[3].ToString();

                                double ictPeriodStartMinute = -1;
                                double ictPeriodEndMinute = -1;
                                #region Transfer selection for a departure flight
                                if ((!bCalcTransfer) ||
                                    (!choixTransfert(nouvelleLigne, line[GlobalNames.sFPD_A_Column_FlightCategory].ToString(), sAirline, tiTransferTransferredFlights, iTerminalGate, Pax_GenTransferLogLine, _dtFPDTable, VolsTransferable, heureArrivee, randVol, randCreneau, randTerminal, true, out ictPeriodStartMinute, out ictPeriodEndMinute)))
                                {
                                    transferValue = -transferValue;
                                    nouvelleLigne[iTransfer] = transferValue;
                                    Pax_GenTransferLogLine[4] = "No FPD Seat available in whole Transfer ICT range";
#if(PAXINOUTUTILISATION)
                                    Point ptOut = GetInOutPointForPax(etPaxOutDistrib, (int)nouvelleLigne[iFPA_Class], "A_" + FPid.ToString(), line[GlobalNames.sFPD_A_Column_FlightCategory].ToString(), sAirline, "T" + line[GlobalNames.sFPA_Column_TerminalReclaim].ToString(), randOutTerminal);
                                    nouvelleLigne[iTerminalInOut] = ptOut.X;
                                    nouvelleLigne[iInOut] = ptOut.Y;
                                }
                                else
                                {
                                    nouvelleLigne[iTerminalInOut] = 0;
                                    nouvelleLigne[iInOut] = 0;
#endif
                                }
                                #endregion
                                _dtPax_GenTransferLog.Rows.Add(Pax_GenTransferLogLine);
                                #endregion
                            }
                            #region Generation du nombre de bagages
                            double dNbBags = -1;   // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                            if (flightConfiguration != null)
                            {
                                if (bSecond && bTransferredPax)
                                {
                                    if (flightConfiguration.flightParameter.nbTransferEcoPax == 0)
                                    {
                                        dNbBags = 0;
                                    }
                                    else
                                    {
                                        dNbBags = flightConfiguration.flightParameter.nbTransferEcoBags / flightConfiguration.flightParameter.nbTransferEcoPax;
                                    }
                                }
                                else if (bSecond && !bTransferredPax)
                                {
                                    if (flightConfiguration.flightParameter.nbTermEcoPax == 0)
                                    {
                                        dNbBags = 0;
                                    }
                                    else
                                    {
                                        dNbBags = flightConfiguration.flightParameter.nbTermEcoBags / flightConfiguration.flightParameter.nbTermEcoPax;
                                    }
                                }
                                else if (!bSecond && bTransferredPax)
                                {
                                    if (flightConfiguration.flightParameter.nbTransferFbPax == 0)
                                    {
                                        dNbBags = 0;
                                    }
                                    else
                                    {
                                        dNbBags = flightConfiguration.flightParameter.nbTransferFbBags / flightConfiguration.flightParameter.nbTransferFbPax;
                                    }
                                }
                                else if (!bSecond && !bTransferredPax)
                                {
                                    if (flightConfiguration.flightParameter.nbTermFbPax == 0)
                                    {
                                        dNbBags = 0;
                                    }
                                    else
                                    {
                                        dNbBags = flightConfiguration.flightParameter.nbTermFbBags / flightConfiguration.flightParameter.nbTermFbPax;
                                    }
                                }
                            }
                            else
                            {
                                String nbBags = null;
                                if (bSecond)
                                    nbBags = getNombreBaggageVisitorsTransferTime(iIndexBagageEco, dtBagageEco, 0, randBaggage.NextDouble());
                                else
                                    nbBags = getNombreBaggageVisitorsTransferTime(iIndexBagageFB, dtBagageFB, 0, randBaggage.NextDouble());

                                if (nbBags == null)
                                    continue;
                                dNbBags = FonctionsType.getInt(nbBags, nbBags.GetType());
                            }

                            Int32 iNbOOGBags = 0;
                            if (dNbBags > 0)
                            {
                                #region Distribution of baggages between normal and OOG.
                                Random rdStream = randOOGTransf;
                                Double dDistrib = dOOGtransf;
                                if (!bSecond)
                                    dDistrib = dOOGtransfFB;
                                if (transferValue == 0)
                                {
                                    rdStream = randOOGTerm;
                                    dDistrib = dOOGTerm;
                                    if (!bSecond)
                                        dDistrib = dOOGTermFB;
                                }
                                dDistrib = dDistrib / 100.0f;
                                for (int k = 0; k < dNbBags; k++)
                                {
                                    if (rdStream.NextDouble() < dDistrib)
                                    {
                                        iNbOOGBags++;
                                    }
                                }
                                dNbBags -= iNbOOGBags;
                                #endregion
                            }
                            #endregion

                            #region Choose the number of trolley
                            String sNbTrolleys = null;// getNombreTrolley(sFlightCategory, _dtTrolleyDistrib, 1, (int)dNbBags + iNbOOGBags, randTrolley.NextDouble());

                            if (bSecond)
                            {
                                sNbTrolleys = getNombreTrolley(iIndexTrolleyEco, dtTrolleyEco, 1, (int)dNbBags + iNbOOGBags, randTrolley.NextDouble());
                            }
                            else
                            {
                                sNbTrolleys = getNombreTrolley(iIndexTrolleyFB, dtTrolleyFB, 1, (int)dNbBags + iNbOOGBags, randTrolley.NextDouble());
                            }
                            nouvelleLigne[iNBTrolleys] = 0;
                            if (sNbTrolleys != null)
                                nouvelleLigne[iNBTrolleys] = FonctionsType.getInt(sNbTrolleys, sNbTrolleys.GetType());
                            #endregion
                            nouvelleLigne[iNbBags] = Math.Round(dNbBags, 2);
                            nouvelleLigne[iNbBagsOOG] = iNbOOGBags;
                            nouvelleLigne[iSegregation] = 0;

                            nouvelleLigne[iCarIndex] = 0;
                            if ((FonctionsType.getInt(nouvelleLigne[iTransfer]) <= 0) && (FonctionsType.getInt(nouvelleLigne[iTerminalInOut]) != 0) && (FonctionsType.getInt(nouvelleLigne[iNbVisitors]) > 0))
                            {
                                #region //SGE-26/03/2012-Begin
#if(PARKINGMULHOUSE)
                                if ((iCarIndex != -1) && (PAX2SIM.bPKG))
                                {
                                    #region Gestion de l'emport et du choix des pax ayant un véhicule.
                                    double dVehicle = 1;
                                    if ((dEmport > 0) && ((int)nouvelleLigne[iFPA_Class] == 2))
                                    {
                                        dVehicle = dEmport * randEmport.NextDouble();
                                    }
                                    else if ((dEmportFB > 0) && ((int)nouvelleLigne[iFPA_Class] == 1))
                                    {
                                        dVehicle = dEmportFB * randEmport.NextDouble();
                                    }
                                    if (dVehicle < 1)
                                    {
                                        nouvelleLigne[iCarIndex] = 1;
                                        _dtPrkPlanTable.Rows.Add(nouvelleLigne.ItemArray);
                                        #endregion

                                        /*#region For the pax with vehicules

                                        String sOccupation = "0";
                                        int interval = 0;
                                        if (FonctionsType.getInt(nouvelleLigne[iNbVisitors]) != 0)
                                        {
                                            if (bSecond)
                                            {
                                                if (dtShortStay.Rows.Count > 0)
                                                    interval = FonctionsType.getInt(dtShortStay.Rows[0].ItemArray[1]) - FonctionsType.getInt(dtShortStay.Rows[0].ItemArray[0]);
                                                sOccupation = getNombreBaggageVisitorsTransferTime(iIndexShortStay, dtShortStay, 0, randShortStay.NextDouble());

                                            }
                                            else
                                            {
                                                if (dtShortStayFB.Rows.Count > 0)
                                                    interval = FonctionsType.getInt(dtShortStayFB.Rows[0].ItemArray[1]) - FonctionsType.getInt(dtShortStayFB.Rows[0].ItemArray[0]);
                                                sOccupation = getNombreBaggageVisitorsTransferTime(iIndexShortStayFB, dtShortStayFB, 0, randShortStay.NextDouble());
                                            }
                                            Double dOccupation = FonctionsType.getDouble(sOccupation) + interval * randStaySpread.NextDouble();
                                        }

                                        #endregion*/
                                    }
                                }
#endif
                                #endregion //SGE-26/03/2012-End
                            }
                            //<< Task #7405 - new Desk and extra information for Pax
                            if (userAttributesDistributionTables != null)
                            {
                                #region User attributes
                                foreach (KeyValuePair<string, DataManagement.NormalTable> pair in userAttributesDistributionTables)
                                {

                                    DataManagement.NormalTable distributionTable = pair.Value;
                                    // << Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab
                                    //String distributionTableName = pair.Key;
                                    String userAttributeName = pair.Key;
                                    String distributionTableName = "";
                                    if (distributionTable != null)
                                        distributionTableName = distributionTable.Table.TableName;
                                    // >> Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab                                    

                                    int indexColumnPaxPlan = -1;
                                    if (indexesForUserAttribColumnsDictionary.TryGetValue(userAttributeName, out indexColumnPaxPlan))
                                    {
                                        String userAttributesValue = "";
                                        int indexUserAttributeEco = -1;
                                        int indexUserAttributeFB = -1;
                                        DataTable dtUserAttributeEco;
                                        DataTable dtUserAttributeFB;
                                        Random randUserAttribute;

                                        if (userAttribDistribExceptionIndexesEco.TryGetValue(distributionTableName, out indexUserAttributeEco) &&
                                            userAttribDistribExceptionIndexesFB.TryGetValue(distributionTableName, out indexUserAttributeFB) &&
                                            userAttribDistribExceptionTablesEco.TryGetValue(distributionTableName, out dtUserAttributeEco) &&
                                            userAttribDistribExceptionTablesFB.TryGetValue(distributionTableName, out dtUserAttributeFB) &&
                                            randomsForUserAttribColumnsDictionary.TryGetValue(userAttributeName, out randUserAttribute))
                                        {

                                            if (bSecond)
                                            {
                                                userAttributesValue = getUserAttributeValue(indexUserAttributeEco, dtUserAttributeEco, 0, randUserAttribute.NextDouble());
                                            }
                                            else
                                            {
                                                userAttributesValue = getUserAttributeValue(indexUserAttributeFB, dtUserAttributeFB, 0, randUserAttribute.NextDouble());
                                            }

                                            if (userAttributesValue == null)
                                            {
                                                continue;
                                            }
                                            nouvelleLigne[indexColumnPaxPlan] = userAttributesValue;
                                        }
                                    }
                                }
                                #endregion
                            }
                            //>> Task #7405 - new Desk and extra information for Pax

                            // >> Task #10764 Pax2Sim - new User attributes for Groups
                            String terminalNbBoardingGateGroupNbLabel = "";
                            String trasnferDepartureFlightStringId = "";
                            if (nouvelleLigne[iFPD_ID] != null)
                            {
                                trasnferDepartureFlightStringId = nouvelleLigne[iFPD_ID].ToString();
                            }
                            int transferDepartureFlightId = -1;

                            if (trasnferDepartureFlightStringId != ""
                                && Int32.TryParse(trasnferDepartureFlightStringId, out transferDepartureFlightId))
                            {
                                foreach (DataRow fpdRow in _dtFPDTable.Rows)
                                {
                                    if (_dtFPDTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID) != -1
                                        && fpdRow[_dtFPDTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID)] != null)
                                    {
                                        int currentDepartureFlightId = -1;
                                        if (Int32.TryParse(fpdRow[_dtFPDTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID)].ToString(), out currentDepartureFlightId))
                                        {
                                            if (currentDepartureFlightId == transferDepartureFlightId)
                                            {
                                                terminalNbBoardingGateGroupNbLabel = _donnees
                                                        .getTerminalNbGroupNbLabelByGroupType(GlobalNames.BOARDING_GATE_GROUP_TYPE, fpdRow);
                                                break;
                                            }
                                        }
                                    }
                                }
                            }

                            if (paxCheckInGroupUserAttributeColumnIndex != -1)
                            {
                                nouvelleLigne[paxCheckInGroupUserAttributeColumnIndex] = "";
                            }
                            if (paxTransferGroupUserAttributeColumnIndex != -1)
                            {
                                nouvelleLigne[paxTransferGroupUserAttributeColumnIndex] = "";
                            }
                            if (paxReclaimGroupUserAttributeColumnIndex != -1)
                            {
                                nouvelleLigne[paxReclaimGroupUserAttributeColumnIndex] = terminalNbReclaimGroupNbLabel;
                            }
                            if (paxBoardingGateGroupUserAttributeColumnIndex != -1)
                            {
                                nouvelleLigne[paxBoardingGateGroupUserAttributeColumnIndex] = terminalNbBoardingGateGroupNbLabel;
                            }
                            // << Task #10764 Pax2Sim - new User attributes for Groups

                            _dtPaxPlanTable.Rows.Add(nouvelleLigne);
                            identifiantPax++;
                        }
                    }
                    return true;
                }

                class TransferAvailability
                {
                    public FlightAttribute flight { get; set; }
                    public double simStartToFlightDateNbMinutes { get; set; }
                    public double nbAvailableEcoTransferSeats { get; set; }
                    public double nbAvailableFbTransferSeats { get; set; }
                }

                private bool GeneratePassengersArrival(bool bCalcTransfer)
                {
                    //The new line for the PaxPlan
                    DataRow nouvelleLigne;
                    #region Get the indexes of the differents columns in PaxPlanTable
                    int iPaxID = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_PaxID);
                    int iPaxCreationTime = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_CreationTime);
                    int iFPA_ID = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_FPAID);
                    int iFPA_Class = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_FPAClass);
                    int iFPD_ID = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_FPDID);
                    int iFDP_Class = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_FPDClass);
                    int iFPD_STD = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_FPDSTD);
                    int iSelf_CheckIn = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_SelfCI);

                    int iNbVisitors = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_Visitors);
                    int iNbBags = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_BagsIG);
                    int iNbBagsOOG = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_BagsOOG);
                    int iNBTrolleys = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_Trolleys);
                    int iSegregation = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_Segregation);

                    int iPassportLocal = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_Local);
                    int iTransfer = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_Transfer);

#if(PAXINOUTUTILISATION)
                    int iTerminalInOut = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_TerminalInOut);
                    int iInOut = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_InOut);
#endif
                    #region //SGE-26/03/2012-Begin
#if(PARKINGMULHOUSE)
                    int iCarIndex = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_Car);
#endif
                    #endregion //SGE-26/03/2012-End
                    //<< Task #7405 - new Desk and extra information for Pax
                    Dictionary<string, int> indexesForUserAttribColumnsDictionary = new Dictionary<string, int>();

                    // << Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab
                    if (userAttributesDistributionTables != null && userAttributesDistributionTables.Count > 0)
                    {
                        foreach (KeyValuePair<String, NormalTable> pair in userAttributesDistributionTables)
                        {
                            String columnName = pair.Key;
                            // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                            if (GlobalNames.nonUserAttributesExceptionsList.Contains(columnName))
                                continue;
                            // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                            int columnIndex = _dtPaxPlanTable.Columns.IndexOf(columnName);
                            if (columnIndex != -1)
                                indexesForUserAttribColumnsDictionary.Add(columnName, columnIndex);
                        }
                    }
                    // >> Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab
                    //>> Task #7405 - new Desk and extra information for Pax

                    // >> Task #10764 Pax2Sim - new User attributes for Groups
                    int paxCheckInGroupUserAttributeColumnIndex = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.PAX_CI_GROUP_USER_ATTRIBUTE);
                    int paxTransferGroupUserAttributeColumnIndex = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.PAX_TRANSFER_GROUP_USER_ATTRIBUTE);
                    int paxReclaimGroupUserAttributeColumnIndex = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.PAX_RECLAIM_GROUP_USER_ATTRIBUTE);
                    int paxBoardingGateGroupUserAttributeColumnIndex = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.PAX_BOARDING_GATE_GROUP_USER_ATTRIBUTE);
                    // << Task #10764 Pax2Sim - new User attributes for Groups
                    #endregion
                    int FPid;
                    //The new row for the Pax_TransferLog.
                    String[] Pax_GenTransferLogLine = new String[GestionDonneesHUB2SIM.ListeEntete_PaxGenTransferLog.Length];
                    int i;


                    int identifiantPax = 1;
                    if (_dtPaxPlanTable.Rows.Count > 0)
                    {
                        //We look for the identifier for the first passenger.
                        identifiantPax = (int)OverallTools.DataFunctions.getMaxValue(_dtPaxPlanTable, 0) + 1;
                    }
                    #region Initialization of the differents informations for transfers
                    List<DeterministicTransferDistributionParameter> deterministicTransferDistributions = new List<DeterministicTransferDistributionParameter>();
                    List<TransferAvailability> overallDepartureTransferAvailability = new List<TransferAvailability>();

                    if (tdTransferTerminalDistribution == null)
                        obtenirDistributionTerminal();
                    if (tdTransferFlightCategoryDistribution == null)
                        obtenirDistributionFlightCategory();
                    if (bCalcTransfer)
                    {
                        //We just find in the flight plan departure the number of passagers which are in transfer.
                        tiTransferTransferredFlights = obtenirNombreTransfert(_dtFPDTable, etFPDLoadFactors, false, (tdTransferFlightCategoryDistribution != null));
                        if (scenarioParameters.IsTransferDistributionDeterministic)
                        {
                            deterministicTransferDistributions = getDeterministicTransferDistributionsByFlightPlanName(FlightGroupRulesEditor.FLIGHT_GROUP_RULES_TABLE_TECHNICAL_NAME,
                                DeterministicTransferDistributionEditor.DETERMINISTIC_TRANSFER_DISTRIBUTION_TABLE_TECHNICAL_NAME, _dtFPATable.TableName);
                            overallDepartureTransferAvailability = getOverallTransferAvailability(tiTransferTransferredFlights, _dtFPDTable);
                        }
                    }
                    //The min and max inter connecting time
                    DataTable dtInterConnectingTable = etInterConnectingTimesTable.Table;
                    Double tempsMini = OverallTools.DataFunctions.valeurMinimaleDansColonne(dtInterConnectingTable, 0);
                    Double tempsMaxi = OverallTools.DataFunctions.valeurMaximaleDansColonne(dtInterConnectingTable, 1);
                    #endregion

                    #region Initialisation of all the random streams
                    Random randClasse = new Random(_Seed);
                    Random randPassport = new Random(_Seed * 2);
                    Random randTerminating = new Random(_Seed * 3);
                    Random randVisitors = new Random(_Seed * 4);
                    Random randReCheck = new Random(_Seed * 5);
                    Random randDesk = new Random(_Seed * 6);
                    Random randBaggage = new Random(_Seed * 7);
                    Random randTime = new Random(_Seed * 8);
                    Random randCreneau = new Random(_Seed * 9);
                    Random randVol = new Random(_Seed * 10);
                    Random randTerminal = new Random(_Seed * 11);
                    Random randTrolley = new Random(_Seed * 17);
                    Random randOOGTransf = new Random(_Seed * 18);
                    Random randOOGTerm = new Random(_Seed * 20);
                    Random randOutTerminal = new Random(_Seed * 24);

                    //<< Task #7405 - new Desk and extra information for Pax
                    Dictionary<string, Random> randomsForUserAttribColumnsDictionary = new Dictionary<string, Random>();
                    if (userAttributesTable != null && userAttributesTable.Rows.Count > 0)
                    {
                        int k = 100;
                        if (userAttributesDistributionTables != null)
                        {
                            foreach (KeyValuePair<String, NormalTable> pair in userAttributesDistributionTables)
                            {
                                String userAttributeName = pair.Key;
                                NormalTable distributionTable = pair.Value;
                                String columnName = userAttributeName;
                                // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                if (GlobalNames.nonUserAttributesExceptionsList.Contains(columnName))
                                    continue;
                                // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                k++;
                                Random randUserAttribute = new Random(_Seed * k);
                                randomsForUserAttribColumnsDictionary.Add(columnName, randUserAttribute);

                            }
                        }
                        /*
                                                foreach (DataRow row in userAttributesTable.Rows)
                                                {                            
                                                    String columnName = row[GlobalNames.sUserAttributes_ColumnName].ToString();
                                                    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                                    if (GlobalNames.nonUserAttributesExceptionsList.Contains(columnName))
                                                        continue;
                                                    // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                                    k++;
                                                    Random randUserAttribute = new Random(_Seed * k);
                                                    randomsForUserAttribColumnsDictionary.Add(columnName, randUserAttribute);                            
                                                }
                        */
                    }
                    //>> Task #7405 - new Desk and extra information for Pax

                    #region //SGE-26/03/2012-Begin
#if(PARKINGMULHOUSE)
                    Random randShortStay = new Random(_Seed * 25);
                    Random randLongStay = new Random(_Seed * 26);
                    Random randStaySpread = new Random(_Seed * 27);
                    Random randEmport = new Random(_Seed * 28);
#endif
                    #endregion //SGE-26/03/2012-End
                    #endregion


                    htArrivalFlightLoading = new Dictionary<int, int>();

                    //For each flight which arrive
                    foreach (DataRow line in _dtFPATable.Rows)
                    {
                        FPid = FonctionsType.getInt(OverallTools.DataFunctions.getValue(line, GlobalNames.sFPD_A_Column_ID), typeof(String));

                        #region First we look if this flight is between the 2 dates.
                        DateTime heureArrivee, heureSortiePax;
                        heureArrivee = OverallTools.DataFunctions.toDateTime(OverallTools.DataFunctions.getValue(line, GlobalNames.sFPD_A_Column_DATE), OverallTools.DataFunctions.getValue(line, GlobalNames.sFPA_Column_STA));
                        if (_slfLoadingForm != null)
                            _slfLoadingForm.ChargementFichier("PaxPlan generation : Arrival Flight : " + FPid.ToString());

                        if (heureArrivee == DateTime.MinValue)
                        {
                            _ListeErreurs.Add("Err00095 : The date or the time does not have a valid format.");
                            continue;
                        }
                        if ((heureArrivee < _dtStartDate) || (heureArrivee > _dtEndDate))
                        {
                            _ListeErreurs.Add("Warn151 : Flight " + FPid.ToString() + " from the FPA is ignored. It doesn't match the range.");
                            continue;
                        }
                        #endregion

                        heureSortiePax = heureArrivee;

                        #region We look for the number of passenger which have take their flight (and their specification (passport / Bags...)
                        double nombrePassagers = -1;    // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                        FlightConfiguration flightConfiguration = Tools.FlightPlanParametersTools
                            .getFlightConfigurationByArrOrDepAndFlightId(FlightAttribute.ARR_OR_DEP_FLIGHT_TAG.A, FPid, flightConfigurations);
                        if (flightConfiguration != null)
                        {
                            nombrePassagers = flightConfiguration.flightParameter.nbTermEcoPax + flightConfiguration.flightParameter.nbTermFbPax
                                + flightConfiguration.flightParameter.nbTransferEcoPax + flightConfiguration.flightParameter.nbTransferFbPax;
                        }
                        else
                        {
                            nombrePassagers = OverallTools.DataFunctions.numberOfPassengers(line, etAircraftType, _dtFlightCategories, etFPALoadFactors, _ListeErreurs);
                            nombrePassagers = Math.Round(nombrePassagers, 0);
                        }
                        if (nombrePassagers == -1)
                        {
                            //The number of passengers is not valid
                            _ListeErreurs.Add("Err00096 : The number of passenger on the arrival flight " + FPid.ToString() + " cannot be found.");
                            continue;
                        }
                        //We look for the flight category of this flight and for the load factors.
                        String sFlightCategory = OverallTools.DataFunctions.getValue(line, GlobalNames.sFPD_A_Column_FlightCategory);
                        String sAirline = OverallTools.DataFunctions.getValue(line, GlobalNames.sFPD_A_Column_AirlineCode);

                        Dictionary<String, String> dssLoadFactorsEco = etFPALoadFactors.GetInformationsColumns(0, "A_" + FPid.ToString(), sAirline, sFlightCategory);
                        Dictionary<String, String> dssLoadFactorsFirst = etFPALoadFactors.GetInformationsColumns(1, "A_" + FPid.ToString(), sAirline, sFlightCategory);
                        String sPremiere = dssLoadFactorsEco[GlobalNames.sLFD_A_Line_C];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_C, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        String sSeconde = dssLoadFactorsEco[GlobalNames.sLFD_A_Line_Y]; //OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_Y, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));

                        htArrivalFlightLoading.Add(FPid, (int)nombrePassagers);
                        double dPremiere, dSeconde;
                        if ((sPremiere == null) || (sSeconde == null) ||
                            (!double.TryParse(sPremiere, out dPremiere)) ||
                            (!double.TryParse(sSeconde, out dSeconde)))
                        {
                            _ListeErreurs.Add("Err00093 : The class distribution doesn't have a good format");
                            continue;
                        }
                        String sLocal, sNotLocal, sTerminating, sTransferring, sTransferReCheck, sTransferDesk, sOOGTerm, sOOGtransf, sEmport;
                        String sLocalFB, sNotLocalFB, sTerminatingFB, sTransferringFB, sTransferReCheckFB, sTransferDeskFB, sOOGTermFB, sOOGtransfFB, sEmportFB;

                        sLocal = dssLoadFactorsEco[GlobalNames.sLFD_A_Line_Local];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_Local, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sNotLocal = dssLoadFactorsEco[GlobalNames.sLFD_A_Line_NotLocal];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_NotLocal, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sTerminating = dssLoadFactorsEco[GlobalNames.sLFA_Line_Terminating];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFA_Line_Terminating, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sTransferring = dssLoadFactorsEco[GlobalNames.sLFD_A_Line_Transferring];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_Transferring, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sTransferReCheck = dssLoadFactorsEco[GlobalNames.sLFD_A_Line_ReCheck];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_ReCheck, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sTransferDesk = dssLoadFactorsEco[GlobalNames.sLFD_A_Line_TransferDesk];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_TransferDesk, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sOOGTerm = dssLoadFactorsEco[GlobalNames.sLFA_Line_OOGTerm];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFA_Line_OOGTerm, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sOOGtransf = dssLoadFactorsEco[GlobalNames.sLFD_A_Line_OOGTransf];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_OOGTransf, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));

                        sLocalFB = dssLoadFactorsFirst[GlobalNames.sLFD_A_Line_Local];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_Local, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sNotLocalFB = dssLoadFactorsFirst[GlobalNames.sLFD_A_Line_NotLocal];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_NotLocal, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sTerminatingFB = dssLoadFactorsFirst[GlobalNames.sLFA_Line_Terminating];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFA_Line_Terminating, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sTransferringFB = dssLoadFactorsFirst[GlobalNames.sLFD_A_Line_Transferring];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_Transferring, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sTransferReCheckFB = dssLoadFactorsFirst[GlobalNames.sLFD_A_Line_ReCheck];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_ReCheck, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sTransferDeskFB = dssLoadFactorsFirst[GlobalNames.sLFD_A_Line_TransferDesk];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_TransferDesk, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sOOGTermFB = dssLoadFactorsFirst[GlobalNames.sLFA_Line_OOGTerm];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFA_Line_OOGTerm, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sOOGtransfFB = dssLoadFactorsFirst[GlobalNames.sLFD_A_Line_OOGTransf];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_OOGTransf, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));


                        #region //SGE-26/03/2012-Begin
#if(PARKINGMULHOUSE)
                        if (!dssLoadFactorsEco.ContainsKey(GlobalNames.sLFD_A_Line_NbPaxPerCar))
                            sEmport = "0";
                        else
                            sEmport = dssLoadFactorsEco[GlobalNames.sLFD_A_Line_NbPaxPerCar];
                        if (!dssLoadFactorsFirst.ContainsKey(GlobalNames.sLFD_A_Line_NbPaxPerCar))
                            sEmportFB = "0";
                        else
                            sEmportFB = dssLoadFactorsFirst[GlobalNames.sLFD_A_Line_NbPaxPerCar];
                        Double dEmport, dEmportFB;
#endif
                        #endregion //SGE-26/03/2012-End

                        Double dLocal, dNotLocal, dTerminatingPercent, dTransferring, dTransferReCheck, dTransferDesk, dOOGTerm, dOOGtransf;
                        if ((sLocal == null) || (sNotLocal == null) || (sTerminating == null) || (sTransferring == null) || (sTransferReCheck == null) || (sTransferDesk == null) ||
                        #region //SGE-26/03/2012-Begin
#if(PARKINGMULHOUSE)
 (sEmport == null) ||
                            (!double.TryParse(sEmport, out dEmport)) ||
#endif
                        #endregion //SGE-26/03/2012-End

 (!double.TryParse(sLocal, out dLocal)) ||
                            (!double.TryParse(sNotLocal, out dNotLocal)) ||
                            (!double.TryParse(sTerminating, out dTerminatingPercent)) ||
                            (!double.TryParse(sTransferring, out dTransferring)) ||
                            (!double.TryParse(sTransferReCheck, out dTransferReCheck)) ||
                            (!double.TryParse(sTransferDesk, out dTransferDesk)) ||
                            (!double.TryParse(sOOGtransf, out dOOGtransf)) ||
                            (!double.TryParse(sOOGTerm, out dOOGTerm)))
                        {
                            _ListeErreurs.Add("Err00094 : The transfer distribution doesn't have a good format");
                            continue;
                        }

                        Double dLocalFB, dNotLocalFB, dTerminatingFB, dTransferringFB, dTransferReCheckFB, dTransferDeskFB, dOOGTermFB, dOOGtransfFB;
                        if ((sLocalFB == null) || (sNotLocalFB == null) || (sTerminatingFB == null) || (sTransferringFB == null) || (sTransferReCheckFB == null) || (sTransferDeskFB == null) ||
                        #region //SGE-26/03/2012-Begin
#if(PARKINGMULHOUSE)
 (sEmportFB == null) ||
                            (!double.TryParse(sEmportFB, out dEmportFB)) ||
#endif
                        #endregion //SGE-26/03/2012-End
 (!double.TryParse(sLocalFB, out dLocalFB)) ||
                            (!double.TryParse(sNotLocalFB, out dNotLocalFB)) ||
                            (!double.TryParse(sTerminatingFB, out dTerminatingFB)) ||
                            (!double.TryParse(sTransferringFB, out dTransferringFB)) ||
                            (!double.TryParse(sTransferReCheckFB, out dTransferReCheckFB)) ||
                            (!double.TryParse(sTransferDeskFB, out dTransferDeskFB)) ||
                            (!double.TryParse(sOOGtransfFB, out dOOGtransfFB)) ||
                            (!double.TryParse(sOOGTermFB, out dOOGTermFB)))
                        {
                            _ListeErreurs.Add("Err00427 : The transfer distribution doesn't have a good format for the First & Business classes.");
                            continue;
                        }
                        #endregion

                        #region Transfer specifications
                        Double dClasse, dTypePassport, dReCheck, dDesk;
                        int transferValue = 0;

                        Double dFirstFlightTime = OverallTools.DataFunctions.MinuteDifference(_dtStartDate, heureArrivee.AddMinutes(tempsMini));
                        Double dLastFlightTime = OverallTools.DataFunctions.MinuteDifference(_dtStartDate, heureArrivee.AddMinutes(tempsMaxi));

                        int iTerminalGate;
                        if (!Int32.TryParse(line[GlobalNames.sFPD_A_Column_TerminalGate].ToString(), out iTerminalGate))
                            iTerminalGate = -1;
                        if (_dtTransferTerminalDistribution == null)
                            iTerminalGate = -1;
                        if (_dtTransferFlightCategoryDistribution != null)
                        {
                            iTerminalGate = alFlightCategory.IndexOf(sFlightCategory);
                        }
                        //On obtient un tableau contenant tous les vols qui peuvent faire l'objet d'un transfert à partir du vol courant.
                        bool[] VolsTransferable = null;
                        double iPaxTransfer = -1;   // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                        if (scenarioParameters.IsTransferDistributionDeterministic)
                        {
                            iPaxTransfer = getDeterministicNbTransferForArrivalFlight(scenarioParameters.FPA, FPid,
                                DeterministicTransferDistributionEditor.DETERMINISTIC_TRANSFER_DISTRIBUTION_TABLE_TECHNICAL_NAME, DeterministicTransferDistributionEditor.DETERMINISTIC_TRANSFER_DISTRIBUTION_TABLE_COLUMN_NAME_TRANSFER_BAGS_DISTRIBUTION);

                            dTerminatingPercent = (1 - iPaxTransfer / nombrePassagers) * 100;
                            if (iPaxTransfer > nombrePassagers)
                            {
                                _ListeErreurs.Add("Warn: The number of transfer passengers set in the Deterministic transfer table "
                                    + "exceeds the flight's nb of passengers for the arrival flight " + FPid.ToString() + ". The flight is ignored.");
                                continue;
                            }
                        }
                        else if (flightConfiguration != null)
                        {
                            iPaxTransfer = flightConfiguration.flightParameter.nbTransferEcoPax + flightConfiguration.flightParameter.nbTransferFbPax;
                        }
                        else
                        {
                            iPaxTransfer = (int)Math.Round(((100.0 - dTerminatingPercent) * (Double)nombrePassagers) / 100);
                        }

                        //                      List<TransferAvailability> departureTransferAvailabilityForCurrentArrivalFlight = new List<TransferAvailability>();
                        int iFlightIndex = -1;
                        if (bCalcTransfer)
                        {
                            VolsTransferable = obtenirVolsTransfert(tiTransferTransferredFlights, dFirstFlightTime, dLastFlightTime, iTerminalGate);
                            /*
                            if (scenarioParameters.IsTransferDistributionDeterministic)
                            {
                                departureTransferAvailabilityForCurrentArrivalFlight
                                    = filterTransferAvailabilityByTimePeriod(overallDepartureTransferAvailability, dFirstFlightTime, dLastFlightTime);
                            }
                            */
                        }
                        else
                        {
                            double iMissedFlight = 0;
                            if (_bFillTransfer)
                            {
                                iFlightIndex = getFlightIndex(FPid);
                                if (iFlightIndex != -1)
                                {
                                    iMissedFlight = tiTransferTransferredFlights[iFlightIndex, 3] + tiTransferTransferredFlights[iFlightIndex, 4];
                                }
                            }
                            nombrePassagers -= iPaxTransfer - iMissedFlight;
                            iPaxTransfer = iMissedFlight;
                        }
                        #endregion


                        Pax_GenTransferLogLine[2] = OverallTools.DataFunctions.MinuteDifference(_dtStartDate, heureArrivee).ToString();
                        Pax_GenTransferLogLine[1] = FPid.ToString();
                        #region We are getting the informations for every expcetion tables.
                        int iIndexVisitorEco, iIndexVisitorFB, iIndexBagageEco, iIndexBagageFB, iIndexTrolleyEco, iIndexTrolleyFB;
                        DataTable dtVisitorEco = etVisitorsDistrib.GetInformationsColumns(0, "A_" + FPid.ToString(), sAirline, sFlightCategory, out iIndexVisitorEco);
                        DataTable dtVisitorFB = etVisitorsDistrib.GetInformationsColumns(1, "A_" + FPid.ToString(), sAirline, sFlightCategory, out iIndexVisitorFB);
                        DataTable dtBagageEco = etBagsDistrib.GetInformationsColumns(0, "A_" + FPid.ToString(), sAirline, sFlightCategory, out iIndexBagageEco);
                        DataTable dtBagageFB = etBagsDistrib.GetInformationsColumns(1, "A_" + FPid.ToString(), sAirline, sFlightCategory, out iIndexBagageFB);
                        DataTable dtTrolleyEco = etTrolleyDistrib.GetInformationsColumns(0, "A_" + FPid.ToString(), sAirline, sFlightCategory, out iIndexTrolleyEco);
                        DataTable dtTrolleyFB = etTrolleyDistrib.GetInformationsColumns(1, "A_" + FPid.ToString(), sAirline, sFlightCategory, out iIndexTrolleyFB);

                        #region //SGE-26/03/2012-Begin
#if(PARKINGMULHOUSE)
                        /*int iIndexShortStayFB, iIndexShortStay;
                        DataTable dtShortStay = etShortStayDistribution.GetInformationsColumns(0, "A_" + FPid.ToString(), sAirline, sFlightCategory, out iIndexShortStay);
                        DataTable dtShortStayFB = etShortStayDistribution.GetInformationsColumns(1, "A_" + FPid.ToString(), sAirline, sFlightCategory, out iIndexShortStayFB);*/
#endif
                        #endregion//SGE-26/03/2012-End

                        //<< Task #7405 - new Desk and extra information for Pax
                        if (userAttributesDistributionTables != null)
                        {
                            userAttribDistribExceptionTablesEco.Clear();
                            userAttribDistribExceptionTablesFB.Clear();
                            userAttribDistribExceptionIndexesEco.Clear();
                            userAttribDistribExceptionIndexesFB.Clear();
                            foreach (KeyValuePair<string, DataManagement.NormalTable> pair in userAttributesDistributionTables)
                            {

                                DataManagement.NormalTable distributionTable = pair.Value;
                                // << Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab
                                //String distributionTableName = pair.Key;
                                String distributionTableName = "";
                                if (distributionTable != null)
                                    distributionTableName = distributionTable.Table.TableName;
                                // >> Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab

                                int indexDistributionEco = -1;
                                int indexDistributionFB = -1;
                                DataTable distributionTableEco = null;
                                DataTable distributionTableFB = null;
                                DataManagement.ExceptionTable distributionExceptionTable = null;

                                if (distributionTable is DataManagement.ExceptionTable)
                                {
                                    distributionExceptionTable = (DataManagement.ExceptionTable)distributionTable;

                                    if (distributionExceptionTable != null)
                                    {
                                        distributionTableEco = distributionExceptionTable.GetInformationsColumns(0, "A_" + FPid.ToString(), sAirline, sFlightCategory, out indexDistributionEco);
                                        distributionTableFB = distributionExceptionTable.GetInformationsColumns(1, "A_" + FPid.ToString(), sAirline, sFlightCategory, out indexDistributionFB);
                                    }
                                    if (distributionTableEco != null && indexDistributionEco != -1)
                                    {
                                        userAttribDistribExceptionTablesEco.Add(distributionTableName, distributionTableEco);
                                        userAttribDistribExceptionIndexesEco.Add(distributionTableName, indexDistributionEco);
                                    }
                                    if (distributionTableFB != null && indexDistributionFB != -1)
                                    {
                                        userAttribDistribExceptionTablesFB.Add(distributionTableName, distributionTableFB);
                                        userAttribDistribExceptionIndexesFB.Add(distributionTableName, indexDistributionFB);
                                    }
                                }
                                else
                                {
                                    // >> Bug #11385 Pax2Sim - Pax plan - Flight subcategories column not filled
                                    if (distributionTable.Table.TableName.Equals(GlobalNames.flightSubcategoriesTableName))
                                    {
                                        int selectedFlightCategoryIndex = distributionTable.Table.Columns.IndexOf(sFlightCategory);
                                        if (selectedFlightCategoryIndex != -1)
                                        {
                                            userAttribDistribExceptionTablesEco.Add(distributionTableName, distributionTable.Table);
                                            userAttribDistribExceptionIndexesEco.Add(distributionTableName, selectedFlightCategoryIndex);

                                            userAttribDistribExceptionTablesFB.Add(distributionTableName, distributionTable.Table);
                                            userAttribDistribExceptionIndexesFB.Add(distributionTableName, selectedFlightCategoryIndex);
                                        }
                                    }
                                    // << Bug #11385 Pax2Sim - Pax plan - Flight subcategories column not filled
                                }
                            }
                        }
                        //>> Task #7405 - new Desk and extra information for Pax
                        #endregion

                        // >> Task #10764 Pax2Sim - new User attributes for Groups                        
                        String terminalNbReclaimGroupNbLabel = _donnees
                            .getTerminalNbGroupNbLabelByGroupType(GlobalNames.RECLAIM_GROUP_TYPE, line);
                        // << Task #10764 Pax2Sim - new User attributes for Groups

                        Double dTmp;
                        for (i = 0; i < nombrePassagers; i++)
                        {
                            #region Decide here if the passenger is a transfer passenger or not.

                            bool bTransferredPax = randTerminating.NextDouble() >= (dTerminatingPercent / 100.0f);
                            bTransferredPax = bTransferredPax || (iPaxTransfer == (int)(nombrePassagers - i));
                            bTransferredPax = bTransferredPax && (iPaxTransfer > 0);
                            if (bTransferredPax)
                                iPaxTransfer--;
                            #endregion

                            #region Calculation of the arriving time of the passenger on the airport
                            Double lCreationTime = OverallTools.DataFunctions.MinuteDifference(_dtStartDate, heureSortiePax);
                            if ((lCreationTime < 0) && !_bGenerateAllPax)
                            {
                                continue;
                            }
                            else if (lCreationTime < 0)
                            {
                                lCreationTime = 0;
                            }
                            #endregion

                            nouvelleLigne = _dtPaxPlanTable.NewRow();
                            nouvelleLigne[iPaxID] = identifiantPax;
                            nouvelleLigne[iPaxCreationTime] = lCreationTime;
                            nouvelleLigne[iFPA_ID] = FPid;

                            #region We have to choose the class for the passenger :
                            dClasse = randClasse.NextDouble();
                            bool bSecond = true;
                            if (dClasse < (dPremiere / 100.0f))
                            {
                                nouvelleLigne[iFPA_Class] = 1;
                                bSecond = false;
                            }
                            else
                            {
                                nouvelleLigne[iFPA_Class] = 2;
                            }
                            #endregion

                            #region We choose the type of passport
                            dTmp = dLocal;
                            if (!bSecond)
                                dTmp = dLocalFB;
                            dTypePassport = randPassport.NextDouble();
                            if (dTypePassport < (dTmp / 100.0f))
                            {
                                nouvelleLigne[iPassportLocal] = 1;
                            }
                            else
                            {
                                nouvelleLigne[iPassportLocal] = 2;
                            }
                            #endregion

                            nouvelleLigne[iFPD_ID] = 0;
                            nouvelleLigne[iFDP_Class] = 0;
                            nouvelleLigne[iFPD_STD] = 0;
                            nouvelleLigne[iSelf_CheckIn] = 0;

                            TransferAvailability chosenTransferAvailability = null;
                            transferValue = 0;
                            if (!bTransferredPax)
                            {
                                #region Terminating passenger
                                nouvelleLigne[iTransfer] = 0;
                                transferValue = 0;
                                String nbVisitors = "";
                                if (bSecond)
                                {
                                    nbVisitors = getNombreBaggageVisitorsTransferTime(iIndexVisitorEco, dtVisitorEco, 0, randVisitors.NextDouble());
                                }
                                else
                                {
                                    nbVisitors = getNombreBaggageVisitorsTransferTime(iIndexVisitorFB, dtVisitorFB, 0, randVisitors.NextDouble());
                                }

                                if (nbVisitors != null)
                                    nouvelleLigne[iNbVisitors] = FonctionsType.getInt(nbVisitors, nbVisitors.GetType());

#if(PAXINOUTUTILISATION)
                                Point ptOut = GetInOutPointForPax(etPaxOutDistrib, (int)nouvelleLigne[iFPA_Class], "A_" + FPid.ToString(), line[GlobalNames.sFPD_A_Column_FlightCategory].ToString(), sAirline, "T" + line[GlobalNames.sFPA_Column_TerminalReclaim].ToString(), randOutTerminal);
                                nouvelleLigne[iTerminalInOut] = ptOut.X;
                                nouvelleLigne[iInOut] = ptOut.Y;
#endif

                                #endregion
                            }
                            else
                            {
                                #region Transfering Passagers

                                #region Deceide what kind of transfer for the passenger
                                dTmp = dTransferReCheck;
                                if (!bSecond)
                                    dTmp = dTransferReCheckFB;

                                dReCheck = randReCheck.NextDouble();
                                if (dReCheck < (dTmp / 100.0f))
                                {
                                    transferValue = 2;
                                }
                                else
                                {
                                    transferValue = 1;
                                    /*Ici, déplacer les 4 lignes de codes ci dessous en dehors du if pour
                                     * pourvoir regénérer les Transfer 20.*/

                                    dTmp = dTransferDesk;
                                    if (!bSecond)
                                        dTmp = dTransferDeskFB;

                                    dDesk = randDesk.NextDouble();
                                    if (dDesk < (dTmp / 100.0f))
                                    {
                                        transferValue *= 10;
                                    }
                                }
                                #endregion

                                nouvelleLigne[iNbVisitors] = 0;
                                nouvelleLigne[iTransfer] = transferValue;

                                Pax_GenTransferLogLine[0] = nouvelleLigne[0].ToString();
                                Pax_GenTransferLogLine[3] = nouvelleLigne[3].ToString();
                                /*
                                                                #region Transfer selection for a departure flight
                                                                if ((!bCalcTransfer) ||
                                                                    (!choixTransfert(nouvelleLigne, line[GlobalNames.sFPD_A_Column_FlightCategory].ToString(), sAirline, tiTransferTransferredFlights, iTerminalGate, Pax_GenTransferLogLine, _dtFPDTable, VolsTransferable, heureArrivee, randVol, randCreneau, randTerminal, true)))
                                                                {
                                                                    transferValue = -transferValue;
                                                                    nouvelleLigne[iTransfer] = transferValue;
                                                                    Pax_GenTransferLogLine[4] = "No FPD Seat available in whole Transfer ICT range";
                                #if(PAXINOUTUTILISATION)
                                                                    Point ptOut = GetInOutPointForPax(etPaxOutDistrib, (int)nouvelleLigne[iFPA_Class], "A_" + FPid.ToString(), line[GlobalNames.sFPD_A_Column_FlightCategory].ToString(), sAirline, "T" + line[GlobalNames.sFPA_Column_TerminalReclaim].ToString(), randOutTerminal);
                                                                    nouvelleLigne[iTerminalInOut] = ptOut.X;
                                                                    nouvelleLigne[iInOut] = ptOut.Y;
                                                                }
                                                                else
                                                                {
                                                                    nouvelleLigne[iTerminalInOut] = 0;
                                                                    nouvelleLigne[iInOut] = 0;
                                #endif
                                                                }
                                                                #endregion
                                */
                                #region Transfer selection for a departure flight
                                double ictPeriodStartMinute = -1;
                                double ictPeriodEndMinute = -1;

                                int staTime = FonctionsType.getInt(Pax_GenTransferLogLine[2], Pax_GenTransferLogLine[2].GetType());

                                bool foundTransferPlace = false;
                                if (bCalcTransfer)
                                {
                                    if (scenarioParameters.IsTransferDistributionDeterministic)
                                    {
                                        int paxClass = FonctionsType.getInt(nouvelleLigne[3], nouvelleLigne[3].GetType());
                                        string flightCategory = line[GlobalNames.sFPD_A_Column_FlightCategory].ToString();

                                        List<TransferAvailability> departureTransferAvailabilityForCurrentPax = filterTransferAvailabilityByPaxRelatedTimePeriodAndPaxClass(overallDepartureTransferAvailability,
                                            FPid, heureArrivee, paxClass, bSecond, flightCategory, sAirline, randCreneau, out ictPeriodStartMinute, out ictPeriodEndMinute);

                                        foundTransferPlace = chooseTransferByDeterministicDistribution(FPid, bSecond, deterministicTransferDistributions,
                                            departureTransferAvailabilityForCurrentPax, nouvelleLigne, Pax_GenTransferLogLine, randCreneau,
                                            ictPeriodStartMinute, ictPeriodEndMinute, staTime, out chosenTransferAvailability);
                                    }
                                    else
                                    {
                                        foundTransferPlace = choixTransfert(nouvelleLigne, line[GlobalNames.sFPD_A_Column_FlightCategory].ToString(), sAirline,
                                                                            tiTransferTransferredFlights, iTerminalGate, Pax_GenTransferLogLine, _dtFPDTable, VolsTransferable,
                                                                            heureArrivee, randVol, randCreneau, randTerminal, true, out ictPeriodStartMinute, out ictPeriodEndMinute);
                                    }
                                }
                                if (!bCalcTransfer || !foundTransferPlace)
                                {
                                    transferValue = -transferValue;
                                    nouvelleLigne[iTransfer] = transferValue;
                                    Pax_GenTransferLogLine[4] = "No FPD Seat available in whole Transfer ICT range";

                                    if (ictPeriodStartMinute != -1 && ictPeriodEndMinute != -1)
                                    {
                                        Pax_GenTransferLogLine[4] += " [" + ictPeriodStartMinute + ", " + ictPeriodEndMinute + "]";
                                        double ictAndStaStart = staTime + ictPeriodStartMinute;
                                        double ictAndStaEnd = staTime + ictPeriodEndMinute;
                                        Pax_GenTransferLogLine[4] += " | ICT + STA: [" + ictAndStaStart + ", " + ictAndStaEnd + "]";

                                        if (scenarioParameters.IsTransferDistributionDeterministic)
                                        {
                                            DeterministicTransferDistributionParameter flightDistribution = null;
                                            foreach (DeterministicTransferDistributionParameter d in deterministicTransferDistributions)
                                            {
                                                if (d.flight != null && d.flight.flightId == FPid)
                                                {
                                                    flightDistribution = d;
                                                    break;
                                                }
                                            }
                                            if (flightDistribution != null)
                                            {
                                                string rulesStatus = " | Current Transfer Dispatch Status: ";
                                                for (int k = 0; k < flightDistribution.deterministicValues.Count; k++)
                                                {
                                                    rulesStatus += flightDistribution.deterministicValues[k].rule.ruleName + " = "
                                                                    + flightDistribution.deterministicValues[k].nbTransferBags + " ";
                                                    if (k < flightDistribution.deterministicValues.Count - 1)
                                                        rulesStatus += ", ";
                                                }
                                                Pax_GenTransferLogLine[4] += rulesStatus;
                                            }
                                        }
                                    }

#if(PAXINOUTUTILISATION)
                                    Point ptOut = GetInOutPointForPax(etPaxOutDistrib, (int)nouvelleLigne[iFPA_Class], "A_" + FPid.ToString(), line[GlobalNames.sFPD_A_Column_FlightCategory].ToString(), sAirline, "T" + line[GlobalNames.sFPA_Column_TerminalReclaim].ToString(), randOutTerminal);
                                    nouvelleLigne[iTerminalInOut] = ptOut.X;
                                    nouvelleLigne[iInOut] = ptOut.Y;
                                }
                                else
                                {
                                    nouvelleLigne[iTerminalInOut] = 0;
                                    nouvelleLigne[iInOut] = 0;
#endif
                                }
                                #endregion
                                if (bCalcTransfer)  // don't add the fake fill transfer pax generated to comply with the arrival transfer percent.
                                    _dtPax_GenTransferLog.Rows.Add(Pax_GenTransferLogLine);
                                #endregion
                            }
                            if (transferValue < 0)
                            {
#if (PAXINOUTUTILISATION)
                                Point ptOut = GetInOutPointForPax(etPaxOutDistrib, (int)nouvelleLigne[iFPA_Class], "A_" + FPid.ToString(), line[GlobalNames.sFPD_A_Column_FlightCategory].ToString(), sAirline, "T" + line[GlobalNames.sFPA_Column_TerminalReclaim].ToString(), randOutTerminal);
                                nouvelleLigne[iTerminalInOut] = ptOut.X;
                                nouvelleLigne[iInOut] = ptOut.Y;
#endif
                            }

                            #region Generation du nombre de bagages
                            double dNbBags = -1;   // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                            if (flightConfiguration != null)
                            {
                                if (bSecond && bTransferredPax)
                                {
                                    if (flightConfiguration.flightParameter.nbTransferEcoPax == 0)
                                    {
                                        dNbBags = 0;
                                    }
                                    else
                                    {
                                        dNbBags = flightConfiguration.flightParameter.nbTransferEcoBags / flightConfiguration.flightParameter.nbTransferEcoPax;
                                    }
                                }
                                else if (bSecond && !bTransferredPax)
                                {
                                    if (flightConfiguration.flightParameter.nbTermEcoPax == 0)
                                    {
                                        dNbBags = 0;
                                    }
                                    else
                                    {
                                        dNbBags = flightConfiguration.flightParameter.nbTermEcoBags / flightConfiguration.flightParameter.nbTermEcoPax;
                                    }
                                }
                                else if (!bSecond && bTransferredPax)
                                {
                                    if (flightConfiguration.flightParameter.nbTransferFbPax == 0)
                                    {
                                        dNbBags = 0;
                                    }
                                    else
                                    {
                                        dNbBags = flightConfiguration.flightParameter.nbTransferFbBags / flightConfiguration.flightParameter.nbTransferFbPax;
                                    }
                                }
                                else if (!bSecond && !bTransferredPax)
                                {
                                    if (flightConfiguration.flightParameter.nbTermFbPax == 0)
                                    {
                                        dNbBags = 0;
                                    }
                                    else
                                    {
                                        dNbBags = flightConfiguration.flightParameter.nbTermFbBags / flightConfiguration.flightParameter.nbTermFbPax;
                                    }
                                }
                            }
                            else
                            {
                                if (bTransferredPax && bCalcTransfer && scenarioParameters.IsTransferDistributionDeterministic && chosenTransferAvailability != null
                                    && chosenTransferAvailability.flight != null)
                                {
                                    FlightAttribute depTransferFlight = chosenTransferAvailability.flight;
                                    dtBagageEco = etBagsDistrib.GetInformationsColumns(0, "D_" + depTransferFlight.flightId.ToString(), depTransferFlight.airlineCode,
                                                                                        depTransferFlight.flightCategory, out iIndexBagageEco);
                                    dtBagageFB = etBagsDistrib.GetInformationsColumns(1, "D_" + depTransferFlight.flightId.ToString(), depTransferFlight.airlineCode,
                                                                                        depTransferFlight.flightCategory, out iIndexBagageFB);
                                }
                                String nbBags = null;
                                if (bSecond)
                                    nbBags = getNombreBaggageVisitorsTransferTime(iIndexBagageEco, dtBagageEco, 0, randBaggage.NextDouble());
                                else
                                    nbBags = getNombreBaggageVisitorsTransferTime(iIndexBagageFB, dtBagageFB, 0, randBaggage.NextDouble());

                                if (nbBags != null)
                                    dNbBags = FonctionsType.getInt(nbBags, nbBags.GetType());
                                else
                                    dNbBags = 0;
                            }

                            Int32 iNbOOGBags = 0;
                            if (dNbBags > 0)
                            {
                                #region Distribution of baggages between normal and OOG.
                                Random rdStream = randOOGTransf;
                                Double dDistrib = dOOGtransf;
                                if (!bSecond)
                                    dDistrib = dOOGtransfFB;
                                if (transferValue == 0)
                                {
                                    rdStream = randOOGTerm;
                                    dDistrib = dOOGTerm;
                                    if (!bSecond)
                                        dDistrib = dOOGTermFB;
                                }
                                dDistrib = dDistrib / 100.0f;
                                for (int k = 0; k < dNbBags; k++)
                                {
                                    if (rdStream.NextDouble() < dDistrib)
                                    {
                                        iNbOOGBags++;
                                    }
                                }
                                dNbBags -= iNbOOGBags;
                                #endregion
                            }
                            #endregion

                            #region Choose the number of trolley
                            String sNbTrolleys = null;// getNombreTrolley(sFlightCategory, _dtTrolleyDistrib, 1, (int)dNbBags + iNbOOGBags, randTrolley.NextDouble());

                            if (bSecond)
                            {
                                sNbTrolleys = getNombreTrolley(iIndexTrolleyEco, dtTrolleyEco, 1, (int)dNbBags + iNbOOGBags, randTrolley.NextDouble());
                            }
                            else
                            {
                                sNbTrolleys = getNombreTrolley(iIndexTrolleyFB, dtTrolleyFB, 1, (int)dNbBags + iNbOOGBags, randTrolley.NextDouble());
                            }
                            nouvelleLigne[iNBTrolleys] = 0;
                            if (sNbTrolleys != null)
                                nouvelleLigne[iNBTrolleys] = FonctionsType.getInt(sNbTrolleys, sNbTrolleys.GetType());
                            #endregion
                            nouvelleLigne[iNbBags] = Math.Round(dNbBags, 2);
                            nouvelleLigne[iNbBagsOOG] = iNbOOGBags;
                            nouvelleLigne[iSegregation] = 0;

                            nouvelleLigne[iCarIndex] = 0;
                            if ((FonctionsType.getInt(nouvelleLigne[iTransfer]) <= 0) && (FonctionsType.getInt(nouvelleLigne[iTerminalInOut]) != 0) && (FonctionsType.getInt(nouvelleLigne[iNbVisitors]) > 0))
                            {
                                #region //SGE-26/03/2012-Begin
#if(PARKINGMULHOUSE)
                                if ((iCarIndex != -1) && (PAX2SIM.bPKG))
                                {
                                    #region Gestion de l'emport et du choix des pax ayant un véhicule.
                                    double dVehicle = 1;
                                    if ((dEmport > 0) && ((int)nouvelleLigne[iFPA_Class] == 2))
                                    {
                                        dVehicle = dEmport * randEmport.NextDouble();
                                    }
                                    else if ((dEmportFB > 0) && ((int)nouvelleLigne[iFPA_Class] == 1))
                                    {
                                        dVehicle = dEmportFB * randEmport.NextDouble();
                                    }
                                    if (dVehicle < 1)
                                    {
                                        nouvelleLigne[iCarIndex] = 1;
                                        _dtPrkPlanTable.Rows.Add(nouvelleLigne.ItemArray);
                                        #endregion

                                        /*#region For the pax with vehicules

                                        String sOccupation = "0";
                                        int interval = 0;
                                        if (FonctionsType.getInt(nouvelleLigne[iNbVisitors]) != 0)
                                        {
                                            if (bSecond)
                                            {
                                                if (dtShortStay.Rows.Count > 0)
                                                    interval = FonctionsType.getInt(dtShortStay.Rows[0].ItemArray[1]) - FonctionsType.getInt(dtShortStay.Rows[0].ItemArray[0]);
                                                sOccupation = getNombreBaggageVisitorsTransferTime(iIndexShortStay, dtShortStay, 0, randShortStay.NextDouble());

                                            }
                                            else
                                            {
                                                if (dtShortStayFB.Rows.Count > 0)
                                                    interval = FonctionsType.getInt(dtShortStayFB.Rows[0].ItemArray[1]) - FonctionsType.getInt(dtShortStayFB.Rows[0].ItemArray[0]);
                                                sOccupation = getNombreBaggageVisitorsTransferTime(iIndexShortStayFB, dtShortStayFB, 0, randShortStay.NextDouble());
                                            }
                                            Double dOccupation = FonctionsType.getDouble(sOccupation) + interval * randStaySpread.NextDouble();
                                        }

                                        #endregion*/
                                    }
                                }
#endif
                                #endregion //SGE-26/03/2012-End
                            }
                            //<< Task #7405 - new Desk and extra information for Pax
                            if (userAttributesDistributionTables != null)
                            {
                                #region User attributes
                                foreach (KeyValuePair<string, DataManagement.NormalTable> pair in userAttributesDistributionTables)
                                {

                                    DataManagement.NormalTable distributionTable = pair.Value;
                                    // << Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab
                                    //String distributionTableName = pair.Key;
                                    String userAttributeName = pair.Key;
                                    String distributionTableName = "";
                                    if (distributionTable != null)
                                        distributionTableName = distributionTable.Table.TableName;
                                    // >> Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab                                    

                                    int indexColumnPaxPlan = -1;
                                    if (indexesForUserAttribColumnsDictionary.TryGetValue(userAttributeName, out indexColumnPaxPlan))
                                    {
                                        String userAttributesValue = "";
                                        int indexUserAttributeEco = -1;
                                        int indexUserAttributeFB = -1;
                                        DataTable dtUserAttributeEco;
                                        DataTable dtUserAttributeFB;
                                        Random randUserAttribute;

                                        if (userAttribDistribExceptionIndexesEco.TryGetValue(distributionTableName, out indexUserAttributeEco) &&
                                            userAttribDistribExceptionIndexesFB.TryGetValue(distributionTableName, out indexUserAttributeFB) &&
                                            userAttribDistribExceptionTablesEco.TryGetValue(distributionTableName, out dtUserAttributeEco) &&
                                            userAttribDistribExceptionTablesFB.TryGetValue(distributionTableName, out dtUserAttributeFB) &&
                                            randomsForUserAttribColumnsDictionary.TryGetValue(userAttributeName, out randUserAttribute))
                                        {

                                            if (bSecond)
                                            {
                                                userAttributesValue = getUserAttributeValue(indexUserAttributeEco, dtUserAttributeEco, 0, randUserAttribute.NextDouble());
                                            }
                                            else
                                            {
                                                userAttributesValue = getUserAttributeValue(indexUserAttributeFB, dtUserAttributeFB, 0, randUserAttribute.NextDouble());
                                            }

                                            if (userAttributesValue != null)
                                                nouvelleLigne[indexColumnPaxPlan] = userAttributesValue;
                                        }
                                    }
                                }
                                #endregion
                            }
                            //>> Task #7405 - new Desk and extra information for Pax

                            // >> Task #10764 Pax2Sim - new User attributes for Groups
                            #region Task #10764 Pax2Sim - new User attributes for Groups
                            String terminalNbBoardingGateGroupNbLabel = "";
                            String trasnferDepartureFlightStringId = "";
                            if (nouvelleLigne[iFPD_ID] != null)
                            {
                                trasnferDepartureFlightStringId = nouvelleLigne[iFPD_ID].ToString();
                            }
                            int transferDepartureFlightId = -1;

                            if (trasnferDepartureFlightStringId != ""
                                && Int32.TryParse(trasnferDepartureFlightStringId, out transferDepartureFlightId))
                            {
                                foreach (DataRow fpdRow in _dtFPDTable.Rows)
                                {
                                    if (_dtFPDTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID) != -1
                                        && fpdRow[_dtFPDTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID)] != null)
                                    {
                                        int currentDepartureFlightId = -1;
                                        if (Int32.TryParse(fpdRow[_dtFPDTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID)].ToString(), out currentDepartureFlightId))
                                        {
                                            if (currentDepartureFlightId == transferDepartureFlightId)
                                            {
                                                terminalNbBoardingGateGroupNbLabel = _donnees
                                                        .getTerminalNbGroupNbLabelByGroupType(GlobalNames.BOARDING_GATE_GROUP_TYPE, fpdRow);
                                                break;
                                            }
                                        }
                                    }
                                }
                            }

                            if (paxCheckInGroupUserAttributeColumnIndex != -1)
                            {
                                nouvelleLigne[paxCheckInGroupUserAttributeColumnIndex] = "";
                            }
                            if (paxTransferGroupUserAttributeColumnIndex != -1)
                            {
                                nouvelleLigne[paxTransferGroupUserAttributeColumnIndex] = "";
                            }
                            if (paxReclaimGroupUserAttributeColumnIndex != -1)
                            {
                                nouvelleLigne[paxReclaimGroupUserAttributeColumnIndex] = terminalNbReclaimGroupNbLabel;
                            }
                            if (paxBoardingGateGroupUserAttributeColumnIndex != -1)
                            {
                                nouvelleLigne[paxBoardingGateGroupUserAttributeColumnIndex] = terminalNbBoardingGateGroupNbLabel;
                            }
                            #endregion
                            // << Task #10764 Pax2Sim - new User attributes for Groups

                            _dtPaxPlanTable.Rows.Add(nouvelleLigne);
                            identifiantPax++;
                        }
                    }
                    if (scenarioParameters.IsTransferDistributionDeterministic)
                    {
                        // update the initial code array used to hold the Departure flights - nb eco, fb transfer available (remaining after the arrival pax creation) seats
                        // with the values from the new list that holds the Departure flights - nb eco, fb transfer available (remaining) seats
                        foreach (TransferAvailability overallTransferAvailability in overallDepartureTransferAvailability)
                        {
                            int idDepartureFlightForTransfer = overallTransferAvailability.flight.flightId;
                            int flightIndexFromArray = getFlightIndex(idDepartureFlightForTransfer);
                            if (flightIndexFromArray != -1)
                            {
                                tiTransferTransferredFlights[flightIndexFromArray, 3] = (int)overallTransferAvailability.nbAvailableFbTransferSeats;
                                tiTransferTransferredFlights[flightIndexFromArray, 4] = (int)overallTransferAvailability.nbAvailableEcoTransferSeats;
                            }
                        }
                    }
                    return true;
                }

                private List<DeterministicTransferDistributionParameter> getDeterministicTransferDistributionsByFlightPlanName(string flightGroupRuleTableName,
                    string deterministicDistributionTableName, string flightSearchingForTransferFlightPlanName)
                {
                    List<DeterministicTransferDistributionParameter> result = new List<DeterministicTransferDistributionParameter>();
                    DataTable flightGroupRulesTable = _donnees.getTable("Input", flightGroupRuleTableName);
                    DataTable deterministicDistributionTable = _donnees.getTable("Input", deterministicDistributionTableName);
                    DataTable flightPlan = _donnees.getTable("Input", flightSearchingForTransferFlightPlanName);
                    if (flightGroupRulesTable == null || deterministicDistributionTable == null)
                        return result;

                    result = DeterministicTransferDistributionEditor.getParametersFromGivenTableByFlightPlan(flightPlan, deterministicDistributionTable, flightGroupRulesTable);
                    return result;
                }

                private List<TransferAvailability> getOverallTransferAvailability(int[,] flightIdAndNbAvailableTransferSeats, DataTable flightPlan)
                {
                    List<TransferAvailability> availableTransferSeats = new List<TransferAvailability>();
                    //flightIdAndNbAvailableTransferSeats:
                    // - Flight id
                    // - Flight terminal  / Flight Category
                    // - Time
                    // - Transferred Pax (first)
                    // - Transferred Pax (Eco)
                    List<FlightAttribute> flights = DeterministicTransferDistributionEditor.retrieveFlightsByFlightPlan(flightPlan);
                    for (int i = 0; i < flightIdAndNbAvailableTransferSeats.Length / 5; i++)
                    {
                        int flightId = flightIdAndNbAvailableTransferSeats[i, 0];
                        FlightAttribute flight = null;
                        foreach (FlightAttribute f in flights)
                        {
                            if (f.flightId == flightId)
                            {
                                flight = f;
                                break;
                            }
                        }
                        if (flight == null)
                            continue;
                        TransferAvailability availability = new TransferAvailability();
                        availability.flight = flight;
                        availability.simStartToFlightDateNbMinutes = flightIdAndNbAvailableTransferSeats[i, 2];
                        availability.nbAvailableFbTransferSeats = flightIdAndNbAvailableTransferSeats[i, 3];
                        availability.nbAvailableEcoTransferSeats = flightIdAndNbAvailableTransferSeats[i, 4];
                        availableTransferSeats.Add(availability);
                    }
                    return availableTransferSeats;
                }

                private double getDeterministicNbTransferForArrivalFlight(string flightPlanTableName, int flightID, string deterministicDistributionTableName,
                    string deterministicDistributionColumnName)
                {
                    DataTable flightPlan = _donnees.getTable("Input", flightPlanTableName);
                    DataTable deterministicDistributionTable = _donnees.getTable("Input", deterministicDistributionTableName);

                    double result = -1;

                    if (flightPlan == null || deterministicDistributionTable == null)
                        return result;

                    int columnIndexFlightPlan = deterministicDistributionTable.Columns
                        .IndexOf(DeterministicTransferDistributionEditor.DETERMINISTIC_TRANSFER_DISTRIBUTION_TABLE_COLUMN_NAME_FLIGHT_PLAN_NAME);
                    int columnIndexFlightId = deterministicDistributionTable.Columns
                        .IndexOf(DeterministicTransferDistributionEditor.DETERMINISTIC_TRANSFER_DISTRIBUTION_TABLE_COLUMN_NAME_FLIGHT_ID);
                    int columnIndexDistribution = deterministicDistributionTable.Columns
                        .IndexOf(DeterministicTransferDistributionEditor.DETERMINISTIC_TRANSFER_DISTRIBUTION_TABLE_COLUMN_NAME_TRANSFER_BAGS_DISTRIBUTION);
                    if (columnIndexFlightPlan == -1 || columnIndexFlightId == -1 || columnIndexDistribution == -1)
                        return result;

                    string flightPlanName = flightPlan.TableName;

                    result = 0;
                    string distributionAsString = string.Empty;
                    foreach (DataRow row in deterministicDistributionTable.Rows)
                    {
                        int currentRowFlightId = -1;
                        if (row[columnIndexFlightId] == null || !Int32.TryParse(row[columnIndexFlightId].ToString(), out currentRowFlightId))
                            continue;
                        if (flightPlanName == row[columnIndexFlightPlan].ToString() && flightID == currentRowFlightId)
                        {
                            distributionAsString = row[columnIndexDistribution].ToString();
                            break;
                        }
                    }
                    if (distributionAsString == string.Empty)
                        return result;
                    List<RuleAndDeterministicValues> ruleAndValues = DeterministicTransferDistributionEditor
                        .getDeterministicValuesByDeterministicTransferTableCellContent(distributionAsString);
                    foreach (RuleAndDeterministicValues ruleAndValue in ruleAndValues)
                        result += ruleAndValue.nbTransferBags;
                    return result;
                }

                private List<TransferAvailability> filterTransferAvailabilityByTimePeriod(List<TransferAvailability> overallTransferAvailability,
                    double periodStartMinute, double periodEndMinute)
                {
                    List<TransferAvailability> transferAvailabilityByTimePeriod = new List<TransferAvailability>();
                    //flight is considered if its flight time (minutes since scenario start) is in the interval [periodStartMinute, periodEndMinute)
                    foreach (TransferAvailability trAv in overallTransferAvailability)
                    {
                        if (trAv.simStartToFlightDateNbMinutes >= periodStartMinute && trAv.simStartToFlightDateNbMinutes < periodEndMinute)
                            transferAvailabilityByTimePeriod.Add(trAv);
                    }
                    return transferAvailabilityByTimePeriod;
                }

                private List<TransferAvailability> filterTransferAvailabilityByPaxRelatedTimePeriodAndPaxClass(List<TransferAvailability> overallDepartureTransferAvailability,
                    int flightId, DateTime flightTime, int paxClass, bool isSecondClass, string flightCategory, string airline, Random randCreneau,
                    out double ictPeriodStartMinute, out double ictPeriodEndMinute)
                {
                    ictPeriodStartMinute = -1;
                    ictPeriodEndMinute = -1;

                    List<TransferAvailability> transferAvailabilityByTimePeriod = new List<TransferAvailability>();
                    double periodStartMinute = -1;
                    double periodEndMinute = -1;

                    // using the old code [start]
                    String sPrefixe = "A_";

                    int iIndexColumn;
                    DataTable dtInterConnectingTimes
                        = etInterConnectingTimesTable.GetInformationsColumns(paxClass, sPrefixe + flightId.ToString(), airline, flightCategory, out iIndexColumn);

                    String sCreneauHoraireChoisi = getNombreBaggageVisitorsTransferTime(iIndexColumn, dtInterConnectingTimes, 0, randCreneau.NextDouble());
                    int indexCreneau = OverallTools.DataFunctions.indexLigne(dtInterConnectingTimes, 0, sCreneauHoraireChoisi);
                    if (indexCreneau == -1)
                    {
                        //Il n'y a plus aucun siège de disponible pour une correspondance.
                        return transferAvailabilityByTimePeriod;
                    }
                    //On convertit les bornes du créneau en double afin de pouvoir les exploiter.
                    Double dCreneauHoraireChoisi, dCreneauHoraireChoisiMax;
                    dCreneauHoraireChoisiMax = (Double)((Int32)dtInterConnectingTimes.Rows[indexCreneau].ItemArray[1]);
                    Double.TryParse(sCreneauHoraireChoisi, out dCreneauHoraireChoisi);

                    ictPeriodStartMinute = dCreneauHoraireChoisi;
                    ictPeriodEndMinute = dCreneauHoraireChoisiMax;

                    DateTime dtCreneauHoraireChoisi = flightTime.AddMinutes(dCreneauHoraireChoisi);
                    DateTime dtCreneauHoraireChoisiMax = flightTime.AddMinutes(dCreneauHoraireChoisiMax);

                    dCreneauHoraireChoisi = OverallTools.DataFunctions.MinuteDifference(_dtStartDate, dtCreneauHoraireChoisi);
                    dCreneauHoraireChoisiMax = OverallTools.DataFunctions.MinuteDifference(_dtStartDate, dtCreneauHoraireChoisiMax);
                    // using the old code [end]

                    periodStartMinute = dCreneauHoraireChoisi;
                    periodEndMinute = dCreneauHoraireChoisiMax;

                    //flight is considered if its flight time (minutes since scenario start) is in the interval [periodStartMinute, periodEndMinute)
                    foreach (TransferAvailability trAv in overallDepartureTransferAvailability)
                    {
                        if (isSecondClass && trAv.nbAvailableEcoTransferSeats == 0)
                            continue;
                        if (!isSecondClass && trAv.nbAvailableFbTransferSeats == 0)
                            continue;
                        //                        if (trAv.simStartToFlightDateNbMinutes >= periodStartMinute && trAv.simStartToFlightDateNbMinutes < periodEndMinute)
                        if (trAv.simStartToFlightDateNbMinutes >= periodStartMinute && trAv.simStartToFlightDateNbMinutes <= periodEndMinute)   // transfer period: includes start, includes end
                            transferAvailabilityByTimePeriod.Add(trAv);
                    }
                    return transferAvailabilityByTimePeriod;
                }


                private bool chooseTransferByDeterministicDistribution(int flightId, bool isEcoPax,
                    List<DeterministicTransferDistributionParameter> allDeterministicTransferDistributions, List<TransferAvailability> currentFlightTransferAvailabilities,
                    DataRow currentPaxPlanTableRow, string[] Pax_GenTransferLogLine, Random random, double ictPeriodStartMinute, double ictPeriodEndMinute, double staTime,
                    out TransferAvailability chosenTransferAvailability)
                {
                    chosenTransferAvailability = null;
                    DeterministicTransferDistributionParameter distribution = null;
                    foreach (DeterministicTransferDistributionParameter d in allDeterministicTransferDistributions)
                    {
                        if (d.flight != null && d.flight.flightId == flightId)
                        {
                            distribution = d;
                            break;
                        }
                    }
                    if (distribution == null)
                        return false;
                    bool hasTransfer = false;
                    foreach (RuleAndDeterministicValues ruleAndValues in distribution.deterministicValues)
                    {
                        if (ruleAndValues.nbTransferBags == 0)
                            continue;
                        hasTransfer = true;
                        TransferAvailability transferAvailability = findTransferForCurrentPax(ruleAndValues.rule, currentFlightTransferAvailabilities, random);
                        if (transferAvailability != null)
                        {
                            if (isEcoPax)
                                transferAvailability.nbAvailableEcoTransferSeats--;
                            else
                                transferAvailability.nbAvailableFbTransferSeats--;
                            ruleAndValues.nbTransferBags--;

                            currentPaxPlanTableRow[4] = transferAvailability.flight.flightId;
                            currentPaxPlanTableRow[5] = currentPaxPlanTableRow[3];  //pax class
                            currentPaxPlanTableRow[6] = transferAvailability.simStartToFlightDateNbMinutes;

                            Pax_GenTransferLogLine[4] = "#" + currentPaxPlanTableRow[4] + "  " + currentPaxPlanTableRow[6] + " (" + ruleAndValues.rule.ruleName + ")";
                            if (ictPeriodStartMinute != -1 && ictPeriodEndMinute != -1)
                            {
                                Pax_GenTransferLogLine[4] += " | ICT: [" + ictPeriodStartMinute + ", " + ictPeriodEndMinute + "]";

                                double ictAndStaStart = staTime + ictPeriodStartMinute;
                                double ictAndStaEnd = staTime + ictPeriodEndMinute;
                                Pax_GenTransferLogLine[4] += " | ICT + STA: [" + ictAndStaStart + ", " + ictAndStaEnd + "]";
                            }
                            chosenTransferAvailability = transferAvailability;
                            return true;
                        }
                    }
                    if (hasTransfer)
                        return false;
                    return true;
                }

                private TransferAvailability findTransferForCurrentPax(FlightGroupRulesParameter rule,
                    List<TransferAvailability> availableTransfers, Random random)
                {
                    if (rule == null)
                        return null;
                    List<TransferAvailability> allowed = new List<TransferAvailability>();
                    foreach (TransferAvailability availableTransfer in availableTransfers)
                    {
                        if (ruleAllowsTransferAvailability(rule, availableTransfer))
                            allowed.Add(availableTransfer);// return availableTransfer;
                    }
                    if (allowed.Count == 1)
                        return allowed[0];
                    else if (allowed.Count > 1)
                        return allowed[random.Next(allowed.Count)];
                    return null;
                }

                private bool ruleAllowsTransferAvailability(FlightGroupRulesParameter rule, TransferAvailability transferAvailability)
                {
                    if (rule == null || transferAvailability == null || transferAvailability.flight == null)
                        return false;
                    if (rule.flightCategories.Count > 0 && !rule.flightCategories.Contains(transferAvailability.flight.flightCategory))
                        return false;
                    if (rule.airlines.Count > 0 && !rule.airlines.Contains(transferAvailability.flight.airlineCode))
                        return false;
                    if (rule.airports.Count > 0 && !rule.airports.Contains(transferAvailability.flight.airportCode))
                        return false;
                    if (rule.user1Contents.Count > 0 && !rule.user1Contents.Contains(transferAvailability.flight.user1))
                        return false;
                    if (rule.user2Contents.Count > 0 && !rule.user2Contents.Contains(transferAvailability.flight.user2))
                        return false;
                    if (rule.user3Contents.Count > 0 && !rule.user3Contents.Contains(transferAvailability.flight.user3))
                        return false;
                    if (rule.user4Contents.Count > 0 && !rule.user4Contents.Contains(transferAvailability.flight.user4))
                        return false;
                    if (rule.user5Contents.Count > 0 && !rule.user5Contents.Contains(transferAvailability.flight.user5))
                        return false;
                    return true;
                }

                #endregion

                #region Fonction pour la génération des passagers en partance
                /// <summary>
                /// Fonction qui génère les passagers au départ. 
                /// </summary>
                private bool GeneratePassengersDeparture(bool bCalcTransfer)
                {
                    int count = 0;
                    DataRow nouvelleLigne;

                    # region Get the indexes of the differents columns in PaxPlanTable
                    int iPaxID = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_PaxID);
                    int iPaxCreationTime = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_CreationTime);
                    int iFPA_ID = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_FPAID);
                    int iFPA_Class = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_FPAClass);
                    int iFPD_ID = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_FPDID);
                    int iFDP_Class = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_FPDClass);
                    int iFPD_STD = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_FPDSTD);
                    int iSelf_CheckIn = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_SelfCI);

                    int iNbVisitors = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_Visitors);
                    int iNbBags = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_BagsIG);
                    int iNbBagsOOG = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_BagsOOG);
                    int iNBTrolleys = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_Trolleys);
                    int iSegregation = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_Segregation);

                    int iPassportLocal = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_Local);
                    int iTransfer = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_Transfer);

#if(PAXINOUTUTILISATION)
                    int iTerminalInOut = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_TerminalInOut);
                    int iInOut = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_InOut);
#endif
                    #region //SGE-26/03/2012-Begin
#if(PARKINGMULHOUSE)
                    int iCarIndex = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.sPaxPlan_Car);
#endif
                    #endregion //SGE-26/03/2012-End

                    //<< Task #7405 - new Desk and extra information for Pax
                    Dictionary<string, int> indexesForUserAttribColumnsDictionary = new Dictionary<string, int>();
                    if (userAttributesTable != null && userAttributesTable.Rows.Count > 0)
                    {
                        // << Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab
                        if (userAttributesDistributionTables != null)
                        {
                            foreach (KeyValuePair<String, NormalTable> pair in userAttributesDistributionTables)
                            {
                                String userAttributeName = pair.Key;
                                NormalTable distributionTable = pair.Value;
                                String columnName = userAttributeName;

                                // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                if (GlobalNames.nonUserAttributesExceptionsList.Contains(columnName))
                                    continue;
                                // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant

                                int columnIndex = _dtPaxPlanTable.Columns.IndexOf(columnName);
                                if (columnIndex != -1)
                                    indexesForUserAttribColumnsDictionary.Add(columnName, columnIndex);
                            }
                        }
                        /*
                                                foreach (DataRow row in userAttributesTable.Rows)
                                                {
                                                    String columnName = row[GlobalNames.sUserAttributes_ColumnName].ToString();
                                                    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                                    if (GlobalNames.nonUserAttributesExceptionsList.Contains(columnName))
                                                        continue;
                                                    // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                                    int columnIndex = _dtPaxPlanTable.Columns.IndexOf(columnName);
                                                    if (columnIndex != -1)
                                                        indexesForUserAttribColumnsDictionary.Add(columnName, columnIndex);
                                                }
                        */
                        // >> Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab
                    }
                    //>> Task #7405 - new Desk and extra information for Pax

                    // >> Task #10764 Pax2Sim - new User attributes for Groups
                    int paxCheckInGroupUserAttributeColumnIndex = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.PAX_CI_GROUP_USER_ATTRIBUTE);
                    int paxTransferGroupUserAttributeColumnIndex = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.PAX_TRANSFER_GROUP_USER_ATTRIBUTE);
                    int paxReclaimGroupUserAttributeColumnIndex = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.PAX_RECLAIM_GROUP_USER_ATTRIBUTE);
                    int paxBoardingGateGroupUserAttributeColumnIndex = _dtPaxPlanTable.Columns.IndexOf(GlobalNames.PAX_BOARDING_GATE_GROUP_USER_ATTRIBUTE);
                    // << Task #10764 Pax2Sim - new User attributes for Groups
                    #endregion

                    int FPid;
                    int FPSTD;
                    int i;

                    String[] Pax_GenTransferLogLine = new String[GestionDonneesHUB2SIM.ListeEntete_PaxGenTransferLog.Length];
                    //For each line in the FPD table we must create passengers
                    int identifiantPax = 1;
                    if (_dtPaxPlanTable.Rows.Count > 0)
                    {
                        identifiantPax = (int)OverallTools.DataFunctions.getMaxValue(_dtPaxPlanTable, 0) + 1;
                    }

                    DataTable dtCIShowUp = etCI_ShowUpTable.Table;
                    DataTable dtICT = etInterConnectingTimesTable.Table;
                    int interval = FonctionsType.getInt(dtCIShowUp.Rows[0].ItemArray[1]) - FonctionsType.getInt(dtCIShowUp.Rows[0].ItemArray[0]);
                    int intervalICT = FonctionsType.getInt(dtICT.Rows[0].ItemArray[1]) - FonctionsType.getInt(dtICT.Rows[0].ItemArray[0]);

                    #region Initialization of the differents informations for transfers
                    if (tdTransferTerminalDistribution == null)
                        obtenirDistributionTerminal();
                    if (tdTransferFlightCategoryDistribution == null)
                        obtenirDistributionFlightCategory();

                    if (bCalcTransfer)
                    {
                        tiTransferTransferredFlights = obtenirNombreTransfert(_dtFPATable, etFPALoadFactors, true, (tdTransferFlightCategoryDistribution != null));
                    }


                    //The min and max inter connecting time
                    DataTable dtInterConnectingTable = etInterConnectingTimesTable.Table;
                    Double tempsMini = OverallTools.DataFunctions.valeurMinimaleDansColonne(dtInterConnectingTable, 0);
                    Double tempsMaxi = OverallTools.DataFunctions.valeurMaximaleDansColonne(dtInterConnectingTable, 1);
                    #endregion

                    #region Initialization of the random streams
                    Random rand = new Random(_Seed * 11);
                    Random randCheckIn = new Random(_Seed * 12);
                    Random randTransfer = new Random(_Seed * 13);
                    Random randReCheck = new Random(_Seed * 14);
                    Random randDesk = new Random(_Seed * 15);
                    Random randTrolley = new Random(_Seed * 16);
                    Random randOOGTransf = new Random(_Seed * 21);
                    Random randOOGOrig = new Random(_Seed * 22);
                    Random randInOut = new Random(_Seed * 23);
                    #region //SGE-26/03/2012-Begin
#if(PARKINGMULHOUSE)
                    Random randShortStay = new Random(_Seed * 29);
                    Random randLongStay = new Random(_Seed * 30);
                    Random randStaySpread = new Random(_Seed * 31);
                    Random randEmport = new Random(_Seed * 32);
#endif
                    #endregion //SGE-26/03/2012-End
                    //<< Task #7405 - new Desk and extra information for Pax
                    Dictionary<string, Random> randomsForUserAttribColumnsDictionary = new Dictionary<string, Random>();
                    if (userAttributesTable != null && userAttributesTable.Rows.Count > 0)
                    {
                        int k = 200;

                        // << Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab
                        if (userAttributesDistributionTables != null)
                        {
                            foreach (KeyValuePair<String, NormalTable> pair in userAttributesDistributionTables)
                            {
                                String userAttributeName = pair.Key;
                                NormalTable distributionTable = pair.Value;
                                String columnName = userAttributeName;

                                // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                if (GlobalNames.nonUserAttributesExceptionsList.Contains(columnName))
                                    continue;
                                // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                k++;
                                Random randUserAttribute = new Random(_Seed * k);
                                randomsForUserAttribColumnsDictionary.Add(columnName, randUserAttribute);

                            }
                        }
                        /*
                                                foreach (DataRow row in userAttributesTable.Rows)
                                                {

                                                    String columnName = row[GlobalNames.sUserAttributes_ColumnName].ToString();
                                                    // << Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                                    if (GlobalNames.nonUserAttributesExceptionsList.Contains(columnName))
                                                        continue;
                                                    // >> Task #9066 Pax2Sim - Peak FLows - BHS Inbounds Smooth/Instant
                                                    k++;
                                                    Random randUserAttribute = new Random(_Seed * k);
                                                    randomsForUserAttribColumnsDictionary.Add(columnName, randUserAttribute);
                                                }
                        */
                        // >> Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab
                    }
                    //>> Task #7405 - new Desk and extra information for Pax
                    #endregion

                    htDepartingFlightLoading = new Dictionary<int, int>();

                    foreach (DataRow line in _dtFPDTable.Rows)
                    {
                        FPid = FonctionsType.getInt(OverallTools.DataFunctions.getValue(line, GlobalNames.sFPD_A_Column_ID), typeof(String));
                        if (_slfLoadingForm != null)
                            _slfLoadingForm.ChargementFichier("PaxPlan generation : Departure Flight : " + FPid.ToString());

                        #region Calcul de l'heure de départ
                        DateTime heureDepart;
                        heureDepart = OverallTools.DataFunctions.toDateTime(OverallTools.DataFunctions.getValue(line, GlobalNames.sFPD_A_Column_DATE), OverallTools.DataFunctions.getValue(line, GlobalNames.sFPD_Column_STD));
                        if (heureDepart == (DateTime.MinValue))
                        {
                            _ListeErreurs.Add("Err00751 : The date or the time does not have a valid format for the departure flight \"" + FPid.ToString() + "\".");
                            continue;
                        }

                        // << Task #8667 Pax2Sim - PaxPlan not showing departure pax with flights that have STD after the end of simulation                        
                        if (_bGenerateFlightsAtEnd)
                        {
                            if (heureDepart < _dtStartDate)
                            {
                                _ListeErreurs.Add("Warn00752 : Flight " + FPid.ToString() + " from the departure flight plan is ignored. The flight departs before the start of the simulation.");
                                continue;
                            }
                        }
                        else
                        {
                            if ((heureDepart < _dtStartDate) || (heureDepart > _dtEndDate))
                            {
                                _ListeErreurs.Add("Warn00752 : Flight " + FPid.ToString() + " from the departure flight plan is ignored. It doesn't match the dates.");
                                continue;
                            }
                        }
                        // >> Task #8667 Pax2Sim - PaxPlan not showing departure pax with flights that have STD after the end of simulation

                        FPSTD = (int)OverallTools.DataFunctions.MinuteDifference(_dtStartDate, heureDepart);
                        #endregion

                        #region We look for the number of passenger which will try to take their flight
                        double nombrePassagers = -1;    // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                        FlightConfiguration flightConfiguration = Tools.FlightPlanParametersTools
                            .getFlightConfigurationByArrOrDepAndFlightId(FlightAttribute.ARR_OR_DEP_FLIGHT_TAG.D, FPid, flightConfigurations);
                        if (flightConfiguration != null)
                        {
                            nombrePassagers = flightConfiguration.flightParameter.nbOrigEcoPax + flightConfiguration.flightParameter.nbOrigFbPax
                                + flightConfiguration.flightParameter.nbTransferEcoPax + flightConfiguration.flightParameter.nbTransferFbPax;
                        }
                        else
                        {
                            nombrePassagers = OverallTools.DataFunctions.numberOfPassengers(line, etAircraftType, _dtFlightCategories, etFPDLoadFactors, _ListeErreurs);
                            nombrePassagers = Math.Round(nombrePassagers, 0);
                        }
                        if (nombrePassagers == -1)
                        {
                            _ListeErreurs.Add("Err00753 : The number of passenger on departure flight " + FPid.ToString() + " cannot be found.");
                            continue;
                        }

                        htDepartingFlightLoading.Add(FPid, (int)nombrePassagers);
                        int iTerminal = -1;
                        if (tdTransferTerminalDistribution != null
                            && line[GlobalNames.sFPD_A_Column_TerminalGate] != null)
                        {
                            Int32.TryParse(line[GlobalNames.sFPD_A_Column_TerminalGate].ToString(), out iTerminal);
                        }
                        //Les différenciations entre les différentes classes.
                        String sFlightCategory = OverallTools.DataFunctions.getValue(line, GlobalNames.sFPD_A_Column_FlightCategory);
                        String sAirline = OverallTools.DataFunctions.getValue(line, GlobalNames.sFPD_A_Column_AirlineCode);

                        Dictionary<String, String> dssLoadFactorsEco = etFPDLoadFactors.GetInformationsColumns(0, "D_" + FPid.ToString(), sAirline, sFlightCategory);
                        Dictionary<String, String> dssLoadFactorsFirst = etFPDLoadFactors.GetInformationsColumns(1, "D_" + FPid.ToString(), sAirline, sFlightCategory);
                        String sPremiere = dssLoadFactorsEco[GlobalNames.sLFD_A_Line_C];
                        String sSeconde = dssLoadFactorsEco[GlobalNames.sLFD_A_Line_Y];
                        double dPremiere, dSeconde;
                        if ((sPremiere == null) || (sSeconde == null) ||
                            (!double.TryParse(sPremiere, out dPremiere)) ||
                            (!double.TryParse(sSeconde, out dSeconde)))
                        {
                            _ListeErreurs.Add("Err00093 : The class distribution doesn't have a good format");
                            continue;
                        }
                        String sLocal, sNotLocal, sOriginating, sTransferring, sTransferReCheck, sTransferDesk, sOOGOrig, sOOGtransf, sCheckInOnline;
                        String sLocalFB, sNotLocalFB, sOriginatingFB, sTransferringFB, sTransferReCheckFB, sTransferDeskFB, sOOGOrigFB, sOOGtransfFB, sCheckInOnlineFB;


                        sLocal = dssLoadFactorsEco[GlobalNames.sLFD_A_Line_Local];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_Local, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sNotLocal = dssLoadFactorsEco[GlobalNames.sLFD_A_Line_NotLocal];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_NotLocal, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sOriginating = dssLoadFactorsEco[GlobalNames.sLFD_Line_Originating];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFA_Line_Terminating, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sTransferring = dssLoadFactorsEco[GlobalNames.sLFD_A_Line_Transferring];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_Transferring, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sTransferReCheck = dssLoadFactorsEco[GlobalNames.sLFD_A_Line_ReCheck];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_ReCheck, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sTransferDesk = dssLoadFactorsEco[GlobalNames.sLFD_A_Line_TransferDesk];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_TransferDesk, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sOOGOrig = dssLoadFactorsEco[GlobalNames.sLFD_Line_OOGOrig];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFA_Line_OOGTerm, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sOOGtransf = dssLoadFactorsEco[GlobalNames.sLFD_A_Line_OOGTransf];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_OOGTransf, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sCheckInOnline = dssLoadFactorsEco[GlobalNames.sLFD_Line_SelfCI];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_OOGTransf, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));

                        sLocalFB = dssLoadFactorsFirst[GlobalNames.sLFD_A_Line_Local];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_Local, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sNotLocalFB = dssLoadFactorsFirst[GlobalNames.sLFD_A_Line_NotLocal];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_NotLocal, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sOriginatingFB = dssLoadFactorsFirst[GlobalNames.sLFD_Line_Originating];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFA_Line_Terminating, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sTransferringFB = dssLoadFactorsFirst[GlobalNames.sLFD_A_Line_Transferring];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_Transferring, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sTransferReCheckFB = dssLoadFactorsFirst[GlobalNames.sLFD_A_Line_ReCheck];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_ReCheck, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sTransferDeskFB = dssLoadFactorsFirst[GlobalNames.sLFD_A_Line_TransferDesk];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_TransferDesk, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sOOGOrigFB = dssLoadFactorsFirst[GlobalNames.sLFD_Line_OOGOrig];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFA_Line_OOGTerm, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sOOGtransfFB = dssLoadFactorsFirst[GlobalNames.sLFD_A_Line_OOGTransf];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_OOGTransf, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));
                        sCheckInOnlineFB = dssLoadFactorsEco[GlobalNames.sLFD_Line_SelfCI];//OverallTools.DataFunctions.getValue(_dtFPALoadFactors, GlobalNames.sLFD_A_Line_OOGTransf, 0, _dtFPALoadFactors.Columns.IndexOf(sFlightCategory));

                        #region //SGE-26/03/2012-Begin
#if (PARKINGMULHOUSE)
                        String sEmport, sEmportFB;
                        sEmport = dssLoadFactorsEco[GlobalNames.sLFD_A_Line_NbPaxPerCar];
                        sEmportFB = dssLoadFactorsFirst[GlobalNames.sLFD_A_Line_NbPaxPerCar];
                        Double dEmport, dEmportFB;
#endif
                        #endregion //SGE-26/03/2012-End
                        Double dLocal, dNotLocal, dOriginatingPercent, dTransferring, dTransferReCheck, dTransferDesk, dOOGtransf, dOOGOrig, dOnlineCheckIn;
                        if ((sLocal == null) || (sNotLocal == null) || (sOriginating == null) || (sTransferring == null) || (sTransferReCheck == null) || (sTransferDesk == null) || (sCheckInOnline == null) ||
                        #region //SGE-26/03/2012-Begin
#if(PARKINGMULHOUSE)
                            (sEmport == null) ||
                            (!double.TryParse(sEmport, out dEmport)) ||
#endif
                        #endregion //SGE-26/03/2012-End
                            (!double.TryParse(sLocal, out dLocal)) ||
                            (!double.TryParse(sNotLocal, out dNotLocal)) ||
                            (!double.TryParse(sOriginating, out dOriginatingPercent)) ||
                            (!double.TryParse(sTransferring, out dTransferring)) ||
                            (!double.TryParse(sTransferReCheck, out dTransferReCheck)) ||
                            (!double.TryParse(sTransferDesk, out dTransferDesk)) ||
                            (!double.TryParse(sOOGtransf, out dOOGtransf)) ||
                            (!double.TryParse(sOOGOrig, out dOOGOrig)) ||
                            (!double.TryParse(sCheckInOnline, out dOnlineCheckIn)))
                        {
                            _ListeErreurs.Add("Err00428 : The transfer distribution doesn't have a good format");
                            continue;
                        }

                        Double dLocalFB, dNotLocalFB, dOriginatingFB, dTransferringFB, dTransferReCheckFB, dTransferDeskFB, dOOGtransfFB, dOOGOrigFB, dOnlineCheckInFB;
                        if ((sLocalFB == null) || (sNotLocalFB == null) || (sOriginatingFB == null) || (sTransferringFB == null) || (sTransferReCheckFB == null) || (sTransferDeskFB == null) || (sCheckInOnlineFB == null) ||
                        #region //SGE-26/03/2012-Begin
#if(PARKINGMULHOUSE)
                            (sEmportFB == null) ||
                            (!double.TryParse(sEmportFB, out dEmportFB)) ||
#endif
                        #endregion //SGE-26/03/2012-End
                            (!double.TryParse(sLocalFB, out dLocalFB)) ||
                            (!double.TryParse(sNotLocalFB, out dNotLocalFB)) ||
                            (!double.TryParse(sOriginatingFB, out dOriginatingFB)) ||
                            (!double.TryParse(sTransferringFB, out dTransferringFB)) ||
                            (!double.TryParse(sTransferReCheckFB, out dTransferReCheckFB)) ||
                            (!double.TryParse(sTransferDeskFB, out dTransferDeskFB)) ||
                            (!double.TryParse(sOOGtransfFB, out dOOGtransfFB)) ||
                            (!double.TryParse(sOOGOrigFB, out dOOGOrigFB)) ||
                            (!double.TryParse(sCheckInOnlineFB, out dOnlineCheckInFB)))
                        {
                            _ListeErreurs.Add("Err00429 : The transfer distribution doesn't have a good format for the First & Business classes.");
                            continue;
                        }
                        #endregion

                        #region Calculation of transfer informations

                        Double dClasse, dOriginatingTrip, dPassportType;
                        Double dReCheck, transferValue = 0, dDesk;
                        double iPaxTransfer = -1;   // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                        if (flightConfiguration != null)
                        {
                            iPaxTransfer = flightConfiguration.flightParameter.nbTransferEcoPax + flightConfiguration.flightParameter.nbTransferFbPax;
                        }
                        else
                        {
                            iPaxTransfer = (int)Math.Round(((100.0 - dOriginatingPercent) * (Double)nombrePassagers) / 100);
                        }
                        bool[] tbTransferable = null;
                        int iFlightIndex = -1;
                        if (bCalcTransfer)
                        {
                            tbTransferable = obtenirVolsTransfert(tiTransferTransferredFlights, FPSTD - tempsMaxi, FPSTD - tempsMini, iTerminal);
                        }
                        else
                        {
                            double iMissedFlight = iPaxTransfer;
                            if (_bFillTransfer)
                            {
                                iFlightIndex = getFlightIndex(FPid);
                                if (iFlightIndex != -1)
                                {
                                    iMissedFlight = tiTransferTransferredFlights[iFlightIndex, 3] + tiTransferTransferredFlights[iFlightIndex, 4];
                                }
                            }
                            nombrePassagers -= iPaxTransfer - iMissedFlight;
                            iPaxTransfer = iMissedFlight;
                        }
                        #endregion

                        #region Initialisation of all different exceptions tables.
                        int iIndexCIShowUpEco, iIndexCIShowUpFB, iIndexICTEco, iIndexICTFB, iIndexVisitorEco, iIndexVisitorFB, iIndexBagageEco, iIndexBagageFB, iIndexTrolleyEco, iIndexTrolleyFB;
                        DataTable dtICTEco = etInterConnectingTimesTable.GetInformationsColumns(0, "D_" + FPid.ToString(), sAirline, sFlightCategory, out iIndexICTEco);
                        DataTable dtICTFB = etInterConnectingTimesTable.GetInformationsColumns(1, "D_" + FPid.ToString(), sAirline, sFlightCategory, out iIndexICTFB);
                        DataTable dtCIShowUpEco = etCI_ShowUpTable.GetInformationsColumns(0, "D_" + FPid.ToString(), sAirline, sFlightCategory, out iIndexCIShowUpEco);
                        DataTable dtCIShowUpFB = etCI_ShowUpTable.GetInformationsColumns(1, "D_" + FPid.ToString(), sAirline, sFlightCategory, out iIndexCIShowUpFB);

                        DataTable dtVisitorEco = etVisitorsDistrib.GetInformationsColumns(0, "D_" + FPid.ToString(), sAirline, sFlightCategory, out iIndexVisitorEco);
                        DataTable dtVisitorFB = etVisitorsDistrib.GetInformationsColumns(1, "D_" + FPid.ToString(), sAirline, sFlightCategory, out iIndexVisitorFB);
                        DataTable dtBagageEco = etBagsDistrib.GetInformationsColumns(0, "D_" + FPid.ToString(), sAirline, sFlightCategory, out iIndexBagageEco);
                        DataTable dtBagageFB = etBagsDistrib.GetInformationsColumns(1, "D_" + FPid.ToString(), sAirline, sFlightCategory, out iIndexBagageFB);
                        DataTable dtTrolleyEco = etTrolleyDistrib.GetInformationsColumns(0, "D_" + FPid.ToString(), sAirline, sFlightCategory, out iIndexTrolleyEco);
                        DataTable dtTrolleyFB = etTrolleyDistrib.GetInformationsColumns(1, "D_" + FPid.ToString(), sAirline, sFlightCategory, out iIndexTrolleyFB);


                        #region //SGE-26/03/2012-Begin
#if (PARKINGMULHOUSE)
                        /*int iIndexShortStayFB, iIndexShortStay, iIndexLongStayFB, iIndexLongStay;
                        DataTable dtShortStay = etShortStayDistribution.GetInformationsColumns(0, "D_" + FPid.ToString(), sAirline, sFlightCategory, out iIndexShortStay);
                        DataTable dtShortStayFB = etShortStayDistribution.GetInformationsColumns(1, "D_" + FPid.ToString(), sAirline, sFlightCategory, out iIndexShortStayFB);
                        DataTable dtLongStay = etLongStayDistribution.GetInformationsColumns(0, "D_" + FPid.ToString(), sAirline, sFlightCategory, out iIndexLongStay);
                        DataTable dtLongStayFB = etLongStayDistribution.GetInformationsColumns(1, "D_" + FPid.ToString(), sAirline, sFlightCategory, out iIndexLongStayFB);*/
#endif
                        #endregion//SGE-26/03/2012-End
                        //<< Task #7405 - new Desk and extra information for Pax
                        if (userAttributesDistributionTables != null)
                        {
                            userAttribDistribExceptionTablesEco.Clear();
                            userAttribDistribExceptionTablesFB.Clear();
                            userAttribDistribExceptionIndexesEco.Clear();
                            userAttribDistribExceptionIndexesFB.Clear();
                            foreach (KeyValuePair<string, DataManagement.NormalTable> pair in userAttributesDistributionTables)
                            {
                                DataManagement.NormalTable distributionTable = pair.Value;
                                // << Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab
                                //String distributionTableName = pair.Key;
                                String distributionTableName = "";
                                if (distributionTable != null)
                                    distributionTableName = distributionTable.Table.TableName;
                                // >> Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab

                                int indexDistributionEco = -1;
                                int indexDistributionFB = -1;
                                DataTable distributionTableEco = null;
                                DataTable distributionTableFB = null;
                                DataManagement.ExceptionTable distributionExceptionTable = null;


                                if (distributionTable is DataManagement.ExceptionTable)
                                {
                                    distributionExceptionTable = (DataManagement.ExceptionTable)distributionTable;

                                    if (distributionExceptionTable != null)
                                    {
                                        distributionTableEco = distributionExceptionTable.GetInformationsColumns(0, "D_" + FPid.ToString(), sAirline, sFlightCategory, out indexDistributionEco);
                                        distributionTableFB = distributionExceptionTable.GetInformationsColumns(1, "D_" + FPid.ToString(), sAirline, sFlightCategory, out indexDistributionFB);
                                    }
                                    if (distributionTableEco != null && indexDistributionEco != -1)
                                    {
                                        userAttribDistribExceptionTablesEco.Add(distributionTableName, distributionTableEco);
                                        userAttribDistribExceptionIndexesEco.Add(distributionTableName, indexDistributionEco);
                                    }
                                    if (distributionTableFB != null && indexDistributionFB != -1)
                                    {
                                        userAttribDistribExceptionTablesFB.Add(distributionTableName, distributionTableFB);
                                        userAttribDistribExceptionIndexesFB.Add(distributionTableName, indexDistributionFB);
                                    }
                                }
                                else
                                {
                                    // >> Bug #11385 Pax2Sim - Pax plan - Flight subcategories column not filled
                                    if (distributionTable.Table.TableName.Equals(GlobalNames.flightSubcategoriesTableName))
                                    {
                                        int selectedFlightCategoryIndex = distributionTable.Table.Columns.IndexOf(sFlightCategory);
                                        if (selectedFlightCategoryIndex != -1)
                                        {
                                            userAttribDistribExceptionTablesEco.Add(distributionTableName, distributionTable.Table);
                                            userAttribDistribExceptionIndexesEco.Add(distributionTableName, selectedFlightCategoryIndex);

                                            userAttribDistribExceptionTablesFB.Add(distributionTableName, distributionTable.Table);
                                            userAttribDistribExceptionIndexesFB.Add(distributionTableName, selectedFlightCategoryIndex);
                                        }
                                    }
                                    // << Bug #11385 Pax2Sim - Pax plan - Flight subcategories column not filled
                                }

                            }
                        }
                        //>> Task #7405 - new Desk and extra information for Pax
                        #endregion


                        // >> Task #10764 Pax2Sim - new User attributes for Groups                        
                        String terminalNbBoardingGateGroupNbLabel = _donnees
                            .getTerminalNbGroupNbLabelByGroupType(GlobalNames.BOARDING_GATE_GROUP_TYPE, line);
                        // << Task #10764 Pax2Sim - new User attributes for Groups


                        Double dTmp;
                        count++;

                        //Valuecoders=> Task-T-36
                        //PAX Count
                        int originatingFirstPax = 0, originatingFirstPaxIndex = 0, transferingFirstPax = 0, originatingSecondPax = 0, originatingSecondPaxIndexStart = 0, transferingSecondPax = 0, firstClassPax = 0, secondClassPax = 0, totalPax = 0, originatingFirstBag = 0, transferingFirstBag = 0, originatingSecondBag = 0, transferingSecondBag = 0, firstClassBag = 0, secondClassBag = 0, totalBag = 0, loopMode = 0, remainingBagValue = 0, remainingOriginatingFirstBagValue = 0, remainingTransferingFirstBagValue = 0, remainingOriginatingSecondBagValue = 0, remainingTransferingSecondBagValue = 0;
                        Dictionary<int, int> Dic = new Dictionary<int, int>();
                        if (flightConfiguration != null)
                        {
                            var originatingFirst = flightConfiguration.flightParameter.nbOrigFbPax;

                            originatingFirstPax = Convert.ToInt32(flightConfiguration.flightParameter.nbOrigFbPax);
                            originatingFirstPaxIndex = originatingFirstPax;
                            transferingFirstPax = Convert.ToInt32(flightConfiguration.flightParameter.nbTransferFbPax);
                            originatingSecondPax = Convert.ToInt32(flightConfiguration.flightParameter.nbOrigEcoPax);
                            originatingSecondPaxIndexStart = originatingSecondPax + originatingFirstPax + transferingFirstPax;
                            transferingSecondPax = Convert.ToInt32(flightConfiguration.flightParameter.nbTransferEcoPax);

                            firstClassPax = originatingFirstPax + transferingFirstPax;
                            secondClassPax = originatingSecondPax + transferingSecondPax;
                            totalPax = firstClassPax + secondClassPax;
                            //int classCount = 0;

                            originatingFirstBag = Convert.ToInt32(flightConfiguration.flightParameter.nbOrigFbBags);
                            transferingFirstBag = Convert.ToInt32(flightConfiguration.flightParameter.nbTransferFbBags);
                            originatingSecondBag = Convert.ToInt32(flightConfiguration.flightParameter.nbOrigEcoBags);
                            transferingSecondBag = Convert.ToInt32(flightConfiguration.flightParameter.nbTransferEcoBags);

                            firstClassBag = originatingFirstBag + transferingFirstBag;
                            secondClassBag = originatingSecondBag + transferingSecondBag;
                            totalBag = firstClassBag + secondClassBag;

                            loopMode = totalBag / totalPax;
                            remainingBagValue = totalBag % totalPax;

                            Dic = calculation(originatingFirstPax, transferingFirstPax, originatingSecondPax, transferingSecondPax, originatingFirstBag, transferingFirstBag, originatingSecondBag, transferingSecondBag);

                            //int remainingOriginatingFirstBagValue = originatingFirstBag % originatingFirstPax;
                            remainingOriginatingFirstBagValue = (originatingFirstBag > originatingFirstPax) ? originatingFirstBag % originatingFirstPax : 0;
                            //int remainingTransferingFirstBagValue = transferingFirstBag % transferingFirstPax;
                            remainingTransferingFirstBagValue = (transferingFirstBag > transferingFirstPax) ? transferingFirstBag % transferingFirstPax : 0;
                            //int remainingOriginatingSecondBagValue = originatingSecondBag % originatingSecondPax;
                            remainingOriginatingSecondBagValue = (originatingSecondBag > originatingSecondPax) ? originatingSecondBag % originatingSecondPax : 0;
                            //int remainingTransferingSecondBagValue = transferingSecondBag % transferingSecondPax;
                            remainingTransferingSecondBagValue = (transferingSecondBag > transferingSecondPax) ? transferingSecondBag % transferingSecondPax : 0;

                            int Keshaw = 350;
                            int Prakash = 300;
                            int loop = Keshaw / Prakash;
                            int Rem = Keshaw % Prakash;
                            
                        }

                        //bool firstPaxOriginating = false;
                        //bool firstPaxTransferring = false;
                        //bool secondPaxOriginating = false;
                        //bool secondPaxTransferring = false;
                        //bool firstClass = false;
                        //bool secondClass = false;

                        

                        for (i = 0; i < nombrePassagers; i++)
                        {
                            bool firstPaxOriginating = false;
                            bool firstPaxTransferring = false;
                            bool secondPaxOriginating = false;
                            bool secondPaxTransferring = false;
                            bool firstClass = false;
                            bool secondClass = false;
                            //Condition for holding the breakpoint for the error T31.
                            if (nombrePassagers == 162 && i == 53 && count == 650)
                            {
                                System.Diagnostics.Debugger.Break();
                                int number = i;
                            }

                            #region Transfert
                            bool bTransferPax = (i < iPaxTransfer);

                            if ((bTransferPax) && (!bCalcTransfer))
                            {
                                //On vérifie si l'on doit ignorer les passagers en transfert ou pas.
                                if (!_bFillTransfer)
                                    continue;
                                if (iFlightIndex == -1)
                                    continue;
                                if (!((tiTransferTransferredFlights[iFlightIndex, 3] > 0) ||
                                    (tiTransferTransferredFlights[iFlightIndex, 4] > 0)))
                                    continue;
                            }
                            #endregion
                            nouvelleLigne = _dtPaxPlanTable.NewRow();
                            #region We have to choose the class for the passenger :
                            dClasse = rand.NextDouble();
                            bool bSecond = true;

                            // << Task T-36 ValueCoders - Code change to correct the Passenger class value
                            if (flightConfiguration != null)
                            {
                                if (i < firstClassPax)
                                {
                                    nouvelleLigne[iFDP_Class] = 1;
                                    bSecond = false;
                                    firstClass = true;
                                    if (i < originatingFirstPaxIndex)
                                    {
                                        firstPaxOriginating = true;
                                    }
                                    else
                                    {
                                        firstPaxTransferring = true;
                                    }
                                }
                                else
                                {
                                    nouvelleLigne[iFDP_Class] = 2;
                                    secondClass = true;
                                    if (i < originatingSecondPaxIndexStart)
                                    {
                                        secondPaxOriginating = true;
                                    }
                                    else
                                    {
                                        secondPaxTransferring = true;
                                    }
                                }
                            }

                            else
                            {
                                if (dClasse < (dPremiere / 100.0f))
                                {
                                    nouvelleLigne[iFDP_Class] = 1;
                                    bSecond = false;
                                }
                                else
                                {
                                    nouvelleLigne[iFDP_Class] = 2;
                                }
                            }
                            #endregion


                            Double lCreationTime = 0;
                            String sTimeBefore;
                            double dTimeBefore = 0;
                            if (bTransferPax)
                            {
                                #region Transfer Passengers
                                sTimeBefore = null;
                                if (scenarioParameters.FillDepartureTransferBasedOnCheckInShowUp)
                                {
                                    if (bSecond)
                                        sTimeBefore = getNombreBaggageVisitorsTransferTime(iIndexCIShowUpEco, dtCIShowUpEco, 0, rand.NextDouble());
                                    else
                                        sTimeBefore = getNombreBaggageVisitorsTransferTime(iIndexCIShowUpFB, dtCIShowUpFB, 0, rand.NextDouble());
                                    if (!Double.TryParse(sTimeBefore, out dTimeBefore))
                                    {
                                        _ListeErreurs.Add("Err00763 : The Show up table has problem. Wrong value format");
                                        continue;
                                    }
                                    dTimeBefore += interval * rand.NextDouble();
                                }
                                else
                                {
                                    if (bSecond)
                                        sTimeBefore = getNombreBaggageVisitorsTransferTime(iIndexICTEco, dtICTEco, 0, rand.NextDouble());
                                    else
                                        sTimeBefore = getNombreBaggageVisitorsTransferTime(iIndexICTFB, dtICTFB, 0, rand.NextDouble());

                                    if (!Double.TryParse(sTimeBefore, out dTimeBefore))
                                    {
                                        _ListeErreurs.Add("Err00766 : The ICT table have problem. Wrong format for the values inside the table.");
                                        continue;
                                    }
                                    dTimeBefore += intervalICT * rand.NextDouble();
                                }

#if(PAXINOUTUTILISATION)
                                nouvelleLigne[iTerminalInOut] = 0;
                                nouvelleLigne[iInOut] = 0;
#endif
                                #endregion
                            }
                            else
                            {
                                #region Originating Passenger
                                sTimeBefore = null;
                                if (bSecond)
                                    sTimeBefore = getNombreBaggageVisitorsTransferTime(iIndexCIShowUpEco, dtCIShowUpEco, 0, rand.NextDouble());
                                else
                                    sTimeBefore = getNombreBaggageVisitorsTransferTime(iIndexCIShowUpFB, dtCIShowUpFB, 0, rand.NextDouble());

                                //sTimeBefore = getNombreBaggageVisitorsTransferTime(sFlightCategory, _dtCI_ShowUpTable, 0, rand.NextDouble());
                                if (!Double.TryParse(sTimeBefore, out dTimeBefore))
                                {
                                    _ListeErreurs.Add("Err00763 : The Show up table have problem. Wrong format for the values inside the table.");
                                    continue;
                                }
                                dTimeBefore += interval * rand.NextDouble();

#if(PAXINOUTUTILISATION)
                                Point ptOut = GetInOutPointForPax(etPaxInDistrib, (int)nouvelleLigne[iFDP_Class], "D_" + FPid.ToString(), line[GlobalNames.sFPD_A_Column_FlightCategory].ToString(), sAirline, "T" + line[GlobalNames.sFPD_Column_TerminalCI].ToString(), randInOut);
                                nouvelleLigne[iTerminalInOut] = ptOut.X;
                                nouvelleLigne[iInOut] = ptOut.Y;
#endif
                                #endregion
                            }
                            DateTime heureArriveePax = heureDepart.AddMinutes(-dTimeBefore);
                            lCreationTime = Math.Round(OverallTools.DataFunctions.MinuteDifference(_dtStartDate, heureArriveePax), 2);

                            // << Task #8667 Pax2Sim - PaxPlan not showing departure pax with flights that have STD after the end of simulation
                            if (heureArriveePax > _dtEndDate)
                                continue;
                            // >> Task #8667 Pax2Sim - PaxPlan not showing departure pax with flights that have STD after the end of simulation

                            if ((lCreationTime < 0) && !_bGenerateAllPax)
                            {
                                continue;
                            }
                            else if (lCreationTime < 0)
                            {
                                lCreationTime = 0;
                            }
                            if (bTransferPax)
                            {
                                #region Transfer passenger
                                dTmp = dTransferReCheck;
                                if (!bSecond)
                                    dTmp = dTransferReCheckFB;
                                dReCheck = randReCheck.NextDouble();
                                if (dReCheck < (dTmp / 100.0f))
                                {
                                    transferValue = 2;
                                }
                                else
                                {
                                    transferValue = 1;
                                    /*Ici, déplacer les 4 lignes de codes ci dessous en dehors du if pour
                                     * pourvoir regénérer les Transfer 20.*/
                                    dTmp = dTransferDesk;
                                    if (!bSecond)
                                        dTmp = dTransferDeskFB;
                                    dDesk = randDesk.NextDouble();
                                    if (dDesk < (dTmp / 100.0f))
                                    {
                                        transferValue *= 10;
                                    }
                                }
                                nouvelleLigne[iNbVisitors] = 0;
                                nouvelleLigne[iTransfer] = transferValue;
                                #endregion
                            }

                            nouvelleLigne[iPaxCreationTime] = lCreationTime;
                            nouvelleLigne[iFPA_ID] = 0;
                            nouvelleLigne[iFPA_Class] = 0;
                            nouvelleLigne[iFPD_ID] = FPid;
                            nouvelleLigne[iFPD_STD] = FPSTD;
                            nouvelleLigne[iSelf_CheckIn] = 0;
                            nouvelleLigne[iPassportLocal] = 0;
                            if ((bTransferPax) && (!bCalcTransfer))
                            {
                                #region in the case that we are in the filling queue mode. And we are generating the passengers that werent generated from the arrival flight plan.

                                if (tiTransferTransferredFlights[iFlightIndex, 2 + (int)nouvelleLigne[iFDP_Class]] == 0)
                                    nouvelleLigne[iFDP_Class] = (((int)nouvelleLigne[iFDP_Class]) % 2) + 1;
                                tiTransferTransferredFlights[iFlightIndex, 2 + (int)nouvelleLigne[5]]--;
                                nouvelleLigne[iPassportLocal] = -(int)nouvelleLigne[iPassportLocal];
                                #endregion
                            }

                            #region Local passport 
                            dTmp = dLocal;
                            if (!bSecond)
                                dTmp = dLocalFB;
                            dPassportType = rand.NextDouble();
                            if (dPassportType < (dTmp / 100.0f))
                            {
                                nouvelleLigne[iPassportLocal] = 1;
                            }
                            else
                            {
                                nouvelleLigne[iPassportLocal] = 2;
                            }
                            #endregion

                            #region Self service check in.
                            dTmp = dOnlineCheckIn;
                            if (!bSecond)
                                dTmp = dOnlineCheckInFB;
                            //We choose if he pax must go to the check in or not.
                            dOriginatingTrip = rand.NextDouble();
                            if ((!bTransferPax) && (randCheckIn.NextDouble() < (dTmp / 100.0f)))
                            {
                                nouvelleLigne[iSelf_CheckIn] = 1;
                            }
                            else
                            {
                                nouvelleLigne[iSelf_CheckIn] = 0;
                            }
                            #endregion

                            #region Calculate the number of baggages
                            double iNombreBags = -1;   // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                            if (flightConfiguration != null)
                            {
                                if (firstClass)
                                {
                                    //Region of First Class Pax
                                    if (firstPaxOriginating)
                                    {
                                        if (Dic.ContainsKey(i))
                                        {
                                            var value = Convert.ToInt32(Dic[i].ToString());
                                            iNombreBags = value;
                                        }
                                        else
                                        {
                                            iNombreBags = 0;
                                        }
                                        originatingFirstPax = originatingFirstPax - 1;
                                    }
                                    else
                                    {
                                        //Region of First Class Transferring Pax
                                        if (firstPaxTransferring)
                                        {
                                            if (Dic.ContainsKey(i))
                                            {
                                                var value = Convert.ToInt32(Dic[i].ToString());
                                                iNombreBags = value;
                                            }
                                            else {
                                                iNombreBags = 0;
                                            }
                                            transferingFirstPax = transferingFirstPax - 1;
                                        }
                                        else
                                        {
                                            //Unwanted Passenger.Need to handle
                                        }
                                    }
                                }
                                else
                                {
                                    //Region of Second Class Pax
                                    if (secondPaxOriginating)
                                    {
                                        if (Dic.ContainsKey(i))
                                        {
                                            var value = Convert.ToInt32(Dic[i].ToString());
                                            iNombreBags = value;
                                        }
                                        else
                                        {
                                            iNombreBags = 0;
                                        }
                                        originatingSecondPax = originatingSecondPax - 1;
                                    }
                                    else
                                    {
                                        
                                        if (secondPaxTransferring)
                                        {
                                            if (Dic.ContainsKey(i))
                                            {
                                                var value = Convert.ToInt32(Dic[i].ToString());
                                                iNombreBags = value;
                                            }
                                            else
                                            {
                                                iNombreBags = 0;
                                            }
                                            transferingSecondPax = transferingSecondPax - 1;
                                        }
                                        else
                                        {
                                            //Unwanted Passenger.Need to handle
                                        }
                                    }
                                }
                            }


                            #region OldCode

                            //if (flightConfiguration != null)
                            //{
                            //    if (bSecond && bTransferPax)
                            //    {
                            //        if (flightConfiguration.flightParameter.nbTransferEcoPax == 0)
                            //        {
                            //            iNombreBags = 0;
                            //        }
                            //        else
                            //        {
                            //            //iNombreBags = flightConfiguration.flightParameter.nbTransferEcoBags / flightConfiguration.flightParameter.nbTransferEcoPax;


                            //            iNombreBags = Math.Round(flightConfiguration.flightParameter.nbTransferEcoBags / flightConfiguration.flightParameter.nbTransferEcoPax);
                            //        }
                            //    }
                            //    else if (bSecond && !bTransferPax)
                            //    {
                            //        if (flightConfiguration.flightParameter.nbOrigEcoPax == 0)
                            //        {
                            //            iNombreBags = 0;
                            //        }
                            //        else
                            //        {
                            //            //iNombreBags = flightConfiguration.flightParameter.nbOrigEcoBags / flightConfiguration.flightParameter.nbOrigEcoPax;
                            //            iNombreBags = Math.Round(flightConfiguration.flightParameter.nbOrigEcoBags / flightConfiguration.flightParameter.nbOrigEcoPax);
                            //        }
                            //    }
                            //    else if (!bSecond && bTransferPax)
                            //    {
                            //        if (flightConfiguration.flightParameter.nbTransferFbPax == 0)
                            //        {
                            //            iNombreBags = 0;
                            //        }
                            //        else
                            //        {
                            //            iNombreBags = Math.Round(flightConfiguration.flightParameter.nbTransferFbBags / flightConfiguration.flightParameter.nbTransferFbPax);
                            //        }
                            //    }
                            //    else if (!bSecond && !bTransferPax)
                            //    {
                            //        if (flightConfiguration.flightParameter.nbOrigFbPax == 0)
                            //        {
                            //            iNombreBags = 0;
                            //        }
                            //        else
                            //        {
                            //            iNombreBags = Math.Round(flightConfiguration.flightParameter.nbOrigFbBags / flightConfiguration.flightParameter.nbOrigFbPax);
                            //        }
                            //    }
                            //}
                            #endregion
                            else
                            {
                                String nbBags = null;
                                if (bSecond)
                                    nbBags = getNombreBaggageVisitorsTransferTime(iIndexBagageEco, dtBagageEco, 0, rand.NextDouble());
                                else
                                    nbBags = getNombreBaggageVisitorsTransferTime(iIndexBagageFB, dtBagageFB, 0, rand.NextDouble());

                                if (nbBags == null)
                                {
                                    _ListeErreurs.Add("Err00764 : The table for the bags distribution contains errors. Unable to continue the PaxPlan Generation. (Departure flight ID:\"" + FPid + "\")");
                                    return false;
                                }
                                iNombreBags = FonctionsType.getInt(nbBags, nbBags.GetType());
                            }
                            int iNbOOGBags = 0;
                            if (iNombreBags > 0)
                            {
                                #region distribution of baggages between normal and OOG.
                                Random rdStream = randOOGTransf;
                                Double dDistrib = dOOGtransf;
                                if (!bSecond)
                                    dDistrib = dOOGtransfFB;
                                if (transferValue == 0)
                                {
                                    rdStream = randOOGOrig;
                                    dDistrib = dOOGOrig;
                                    if (!bSecond)
                                        dDistrib = dOOGOrigFB;
                                }
                                dDistrib = dDistrib / 100.0f;
                                for (int k = 0; k < (int)iNombreBags; k++)
                                {
                                    if (rdStream.NextDouble() < dDistrib)
                                    {
                                        iNbOOGBags++;
                                    }
                                }
                                iNombreBags -= iNbOOGBags;
                                #endregion
                            }
                            #endregion

                            nouvelleLigne[iNbBags] = Math.Round(iNombreBags, 2);
                            nouvelleLigne[iNbBagsOOG] = iNbOOGBags;
                            #region Transfer State Old
                            //if (bTransferPax)
                            //{
                            //    #region in the case that we are in the filling queue mode. And we are generating the passengers that werent generated from the arrival flight plan.


                            //    nouvelleLigne[iTransfer] = 1;
                            //    transferValue = 1;

                            //if ((_bFillTransfer) && (!bCalcTransfer))
                            //{
                            //    nouvelleLigne[iTransfer] = -1;
                            //    transferValue = -1;
                            //}
                            //    #endregion
                            //}
                            //else
                            //{
                            //    nouvelleLigne[iTransfer] = 0;
                            //    transferValue = 0;
                            //}
                            #endregion

                            // << Task T-36 ValueCoders - Code change to correct the transfer column value

                            if (flightConfiguration != null)
                            {
                                if (firstClass)
                                {
                                    //First Class
                                    if (firstPaxOriginating)
                                    {
                                        nouvelleLigne[iTransfer] = 0;
                                        transferValue = 0;
                                    }
                                    else
                                    {
                                        nouvelleLigne[iTransfer] = -1;
                                        transferValue = -1;
                                        if ((_bFillTransfer) && (!bCalcTransfer))
                                        {
                                            nouvelleLigne[iTransfer] = -1;
                                            transferValue = -1;
                                        }
                                    }
                                }
                                else
                                {
                                    //Second Class
                                    if (secondPaxOriginating)
                                    {
                                        nouvelleLigne[iTransfer] = 0;
                                        transferValue = 0;
                                    }
                                    else
                                    {
                                        nouvelleLigne[iTransfer] = -1;
                                        transferValue = -1;
                                        if ((_bFillTransfer) && (!bCalcTransfer))
                                        {
                                            nouvelleLigne[iTransfer] = -1;
                                            transferValue = -1;
                                        }
                                    }
                                }
                            }
                            else
                            {
                                if (bTransferPax)
                                {
                                    #region in the case that we are in the filling queue mode. And we are generating the passengers that werent generated from the arrival flight plan.


                                    nouvelleLigne[iTransfer] = 1;
                                    transferValue = 1;

                                    if ((_bFillTransfer) && (!bCalcTransfer))
                                    {
                                        nouvelleLigne[iTransfer] = -1;
                                        transferValue = -1;
                                    }
                                    #endregion
                                }
                                else
                                {
                                    nouvelleLigne[iTransfer] = 0;
                                    transferValue = 0;
                                }
                            }


                            nouvelleLigne[iSegregation] = 0;

                            #region Calculate the trolley distribution
                            if (FonctionsType.getInt(nouvelleLigne[iTransfer]) == 0)
                            {
                                String sNbTrolleys = null;
                                if (bSecond)
                                    sNbTrolleys = getNombreTrolley(iIndexTrolleyEco, dtTrolleyEco, 1, (int)iNombreBags + iNbOOGBags, randTrolley.NextDouble());
                                else
                                    sNbTrolleys = getNombreTrolley(iIndexTrolleyFB, dtTrolleyFB, 1, (int)iNombreBags + iNbOOGBags, randTrolley.NextDouble());
                                //Choix du nombre de Trolley
                                nouvelleLigne[iNBTrolleys] = 0;
                                if (sNbTrolleys != null)
                                {
                                    nouvelleLigne[iNBTrolleys] = FonctionsType.getInt(sNbTrolleys, sNbTrolleys.GetType());
                                }
                            }
                            else
                            {
                                nouvelleLigne[iNBTrolleys] = 0;
                            }
                            #endregion

                            if ((bTransferPax) && (bCalcTransfer))
                            {
                                #region Calculate the transfer informations
                                Pax_GenTransferLogLine[0] = identifiantPax.ToString();
                                Pax_GenTransferLogLine[1] = "0";
                                Pax_GenTransferLogLine[2] = "0";
                                Pax_GenTransferLogLine[3] = nouvelleLigne[5].ToString();
                                Pax_GenTransferLogLine[4] = "";

                                double ictPeriodStartMinute = -1;
                                double ictPeriodEndMinute = -1;

                                //On est le passager en transfer, maintenant on doit trouver le vol en transfer qui nous correspond le mieux.
                                if (!choixTransfert(nouvelleLigne, sFlightCategory, sAirline, tiTransferTransferredFlights, iTerminal, Pax_GenTransferLogLine,
                                                    _dtFPATable, tbTransferable, heureDepart, rand, rand, rand, false, out ictPeriodStartMinute, out ictPeriodEndMinute))
                                {
                                    nouvelleLigne[iPaxCreationTime] = lCreationTime;
                                    if(flightConfiguration==null)
                                    {
                                        nouvelleLigne[iTransfer] = -(int)nouvelleLigne[iTransfer];
                                        transferValue = -(int)nouvelleLigne[iTransfer];
                                    }
                                    //nouvelleLigne[iTransfer] = -(int)nouvelleLigne[iTransfer];
                                    //transferValue = -(int)nouvelleLigne[iTransfer];
                                    Pax_GenTransferLogLine[4] = "No FPA Seat available in whole Transfer ICT range";

                                    if (ictPeriodStartMinute != -1 && ictPeriodEndMinute != -1)
                                    {
                                        Pax_GenTransferLogLine[4] += " [" + ictPeriodStartMinute + ", " + ictPeriodEndMinute + "]";
                                        double stdMinusIctStart = FPSTD - ictPeriodEndMinute;
                                        double stdMinusIctEnd = FPSTD - ictPeriodStartMinute;
                                        Pax_GenTransferLogLine[4] += " | STD - ICT: [" + stdMinusIctStart + ", " + stdMinusIctEnd + "]";
                                    }
                                    if (scenarioParameters.MissedDepartureTransferBasedOnCheckInShowUp)
                                    {
                                        //only if the user chooses to use the CI show-up for the missed pax. otherwise the creation time is not modified
                                        double creationTimeForMissedTransfer = generateCreationTimeForDeparturePax(heureDepart, _dtStartDate, bSecond,
                                            iIndexCIShowUpEco, iIndexCIShowUpFB, dtCIShowUpEco, dtCIShowUpFB, interval, rand);

                                        if (creationTimeForMissedTransfer < 0 && !_bGenerateAllPax)
                                            continue;   // no global params affected until this point (the transfer distrib matrix is updated only when generating the departure fake transfer)
                                        else if (creationTimeForMissedTransfer < 0)
                                            creationTimeForMissedTransfer = 0;
                                        nouvelleLigne[iPaxCreationTime] = creationTimeForMissedTransfer;
                                    }
                                }
                                _dtPax_GenTransferLog.Rows.Add(Pax_GenTransferLogLine);
                                #endregion
                            }

                            if (transferValue < 0)
                            {
#if(PAXINOUTUTILISATION)
                                Point ptOut = GetInOutPointForPax(etPaxInDistrib, (int)nouvelleLigne[iFDP_Class], "D_" + FPid.ToString(), line[GlobalNames.sFPD_A_Column_FlightCategory].ToString(), sAirline, "T" + line[GlobalNames.sFPD_Column_TerminalCI].ToString(), randInOut);
                                nouvelleLigne[iTerminalInOut] = ptOut.X;
                                nouvelleLigne[iInOut] = ptOut.Y;
#endif
                            }

                            #region Visitors
                            String nbVisitors = "";
                            if (bSecond)
                                nbVisitors = getNombreBaggageVisitorsTransferTime(iIndexVisitorEco, dtVisitorEco, 0, rand.NextDouble());
                            else
                                nbVisitors = getNombreBaggageVisitorsTransferTime(iIndexVisitorFB, dtVisitorFB, 0, rand.NextDouble());

                            if (nbVisitors == null)
                            {
                                _ListeErreurs.Add("Err00765 : The table for the visitors distribution contains errors. Unable to continue the PaxPlan Generation. (Departure flight ID:\"" + FPid + "\")");
                                return false;
                            }
                            nouvelleLigne[iNbVisitors] = FonctionsType.getInt(nbVisitors, nbVisitors.GetType());
                            #endregion

                            nouvelleLigne[iPaxID] = identifiantPax;
                            nouvelleLigne[iCarIndex] = 0;
                            if ((FonctionsType.getInt(nouvelleLigne[iTransfer]) <= 0) && (FonctionsType.getInt(nouvelleLigne[iTerminalInOut]) != 0))
                            {
                                #region //SGE-26/03/2012-Begin
#if (PARKINGMULHOUSE)
                                if (iCarIndex != -1 && PAX2SIM.bPKG)    // >> Bug #14889 P2S crashing on Training computer
                                {
                                    #region Gestion de l'emport et du choix des pax ayant un véhicule.
                                    double dVehicle = 1;
                                    if ((dEmport > 0) && ((int)nouvelleLigne[iFDP_Class] == 2))
                                    {
                                        dVehicle = dEmport * randEmport.NextDouble();
                                    }
                                    else if ((dEmportFB > 0) && ((int)nouvelleLigne[iFDP_Class] == 1))
                                    {
                                        dVehicle = dEmportFB * randEmport.NextDouble();
                                    }
                                    if (dVehicle < 1)
                                    {
                                        nouvelleLigne[iCarIndex] = 1;
                                        _dtPrkPlanTable.Rows.Add(nouvelleLigne.ItemArray);
                                        #endregion

                                        #region For the pax with vehicules
                                        /*
                                        String sOccupation = "0";
                                        interval = 0;
                                        if (FonctionsType.getInt(nouvelleLigne[iNbVisitors]) != 0)
                                        {
                                            if (bSecond)
                                            {
                                                if (dtShortStay.Rows.Count > 0)
                                                    interval = FonctionsType.getInt(dtShortStay.Rows[0].ItemArray[1]) - FonctionsType.getInt(dtShortStay.Rows[0].ItemArray[0]);
                                                sOccupation = getNombreBaggageVisitorsTransferTime(iIndexShortStay, dtShortStay, 0, randShortStay.NextDouble());

                                            }
                                            else
                                            {
                                                if (dtShortStayFB.Rows.Count > 0)
                                                    interval = FonctionsType.getInt(dtShortStayFB.Rows[0].ItemArray[1]) - FonctionsType.getInt(dtShortStayFB.Rows[0].ItemArray[0]);
                                                sOccupation = getNombreBaggageVisitorsTransferTime(iIndexShortStayFB, dtShortStayFB, 0, randShortStay.NextDouble());
                                            }
                                        }
                                        else
                                        {
                                            if (bSecond)
                                            {
                                                if (dtLongStay.Rows.Count > 0)
                                                    interval = FonctionsType.getInt(dtLongStay.Rows[0].ItemArray[1]) - FonctionsType.getInt(dtLongStay.Rows[0].ItemArray[0]);
                                                sOccupation = getNombreBaggageVisitorsTransferTime(iIndexLongStay, dtLongStay, 0, randLongStay.NextDouble());

                                            }
                                            else
                                            {
                                                if (dtLongStayFB.Rows.Count > 0)
                                                    interval = FonctionsType.getInt(dtLongStayFB.Rows[0].ItemArray[1]) - FonctionsType.getInt(dtLongStayFB.Rows[0].ItemArray[0]);
                                                sOccupation = getNombreBaggageVisitorsTransferTime(iIndexLongStayFB, dtLongStayFB, 0, randLongStay.NextDouble());
                                            }
                                        }
                                        Double dOccupation = FonctionsType.getDouble(sOccupation) + interval * randStaySpread.NextDouble();
                                        */
                                        #endregion
                                    }

                                }
#endif
                                #endregion //SGE-26/03/2012-End
                            }

                            //<< Task #7405 - new Desk and extra information for Pax
                            if (userAttributesDistributionTables != null)
                            {
                                foreach (KeyValuePair<string, DataManagement.NormalTable> pair in userAttributesDistributionTables)
                                {
                                    DataManagement.NormalTable distributionTable = pair.Value;
                                    // << Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab                                    
                                    //String distributionTableName = pair.Key;
                                    String userAttributeName = pair.Key;
                                    String distributionTableName = "";
                                    if (distributionTable != null)
                                        distributionTableName = distributionTable.Table.TableName;
                                    // >> Task #9163 Pax2Sim - Scenario Properties - User Attributes tables Tab

                                    int indexColumnPaxPlan = -1;
                                    if (indexesForUserAttribColumnsDictionary.TryGetValue(userAttributeName, out indexColumnPaxPlan))
                                    {
                                        String userAttributesValue = "";
                                        int indexUserAttributeEco = -1;
                                        int indexUserAttributeFB = -1;
                                        DataTable dtUserAttributeEco;
                                        DataTable dtUserAttributeFB;
                                        Random randUserAttribute;

                                        if (userAttribDistribExceptionIndexesEco.TryGetValue(distributionTableName, out indexUserAttributeEco) &&
                                            userAttribDistribExceptionIndexesFB.TryGetValue(distributionTableName, out indexUserAttributeFB) &&
                                            userAttribDistribExceptionTablesEco.TryGetValue(distributionTableName, out dtUserAttributeEco) &&
                                            userAttribDistribExceptionTablesFB.TryGetValue(distributionTableName, out dtUserAttributeFB) &&
                                            randomsForUserAttribColumnsDictionary.TryGetValue(userAttributeName, out randUserAttribute))
                                        {

                                            if (bSecond)
                                            {
                                                userAttributesValue = getUserAttributeValue(indexUserAttributeEco, dtUserAttributeEco, 0, randUserAttribute.NextDouble());
                                            }
                                            else
                                            {
                                                userAttributesValue = getUserAttributeValue(indexUserAttributeFB, dtUserAttributeFB, 0, randUserAttribute.NextDouble());
                                            }

                                            if (userAttributesValue != null)
                                                nouvelleLigne[indexColumnPaxPlan] = userAttributesValue;
                                        }
                                    }
                                }
                            }
                            //>> Task #7405 - new Desk and extra information for Pax

                            // >> Task #10764 Pax2Sim - new User attributes for Groups                            
                            String terminalNbReclaimGateGroupNbLabel = "";
                            String trasnferArrivalFlightStringId = "";
                            if (nouvelleLigne[iFPA_ID] != null)
                            {
                                trasnferArrivalFlightStringId = nouvelleLigne[iFPA_ID].ToString();
                            }
                            int trasnferArrivalFlightId = -1;

                            if (trasnferArrivalFlightStringId != ""
                                && Int32.TryParse(trasnferArrivalFlightStringId, out trasnferArrivalFlightId))
                            {
                                foreach (DataRow fpaRow in _dtFPATable.Rows)
                                {
                                    if (_dtFPATable.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID) != -1
                                        && fpaRow[_dtFPATable.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID)] != null)
                                    {
                                        int currentArrivalFlightId = -1;
                                        if (Int32.TryParse(fpaRow[_dtFPATable.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID)].ToString(), out currentArrivalFlightId))
                                        {
                                            if (currentArrivalFlightId == trasnferArrivalFlightId)
                                            {
                                                terminalNbReclaimGateGroupNbLabel = _donnees
                                                        .getTerminalNbGroupNbLabelByGroupType(GlobalNames.RECLAIM_GROUP_TYPE, fpaRow);
                                                break;
                                            }
                                        }
                                    }
                                }
                            }

                            if (paxCheckInGroupUserAttributeColumnIndex != -1)
                            {
                                nouvelleLigne[paxCheckInGroupUserAttributeColumnIndex] = "";
                            }
                            if (paxTransferGroupUserAttributeColumnIndex != -1)
                            {
                                nouvelleLigne[paxTransferGroupUserAttributeColumnIndex] = "";
                            }
                            if (paxReclaimGroupUserAttributeColumnIndex != -1)
                            {
                                nouvelleLigne[paxReclaimGroupUserAttributeColumnIndex] = terminalNbReclaimGateGroupNbLabel;
                            }
                            if (paxBoardingGateGroupUserAttributeColumnIndex != -1)
                            {
                                nouvelleLigne[paxBoardingGateGroupUserAttributeColumnIndex] = terminalNbBoardingGateGroupNbLabel;
                            }
                            // << Task #10764 Pax2Sim - new User attributes for Groups

                            _dtPaxPlanTable.Rows.Add(nouvelleLigne);
                            identifiantPax++;
                        }


                        #region New Bag Calculation
                        Random paxRandom = new Random();
                        //104 totalBag
                        for (int p = 0; p < 104; p++)
                        {
                            //115 totalPax
                            int paxNumber = paxRandom.Next(0, 115);
                            if (paxNumber < firstClassPax)
                            {
                                //First Class Passenger
                                if (paxNumber < originatingFirstPaxIndex)
                                {
                                   //Originating First Class Pax
                                }
                                else
                                {
                                    //Transferring first class Pax
                                }
                            }
                            else
                            {
                                //Second Class Pax
                                if (paxNumber < originatingSecondPaxIndexStart)
                                {
                                   //Originating second Class Pax
                                }
                                else
                                {
                                    //Transferring Second class pax
                                }
                            }

                        }

                        #endregion
                    }
                    return true;
                }

                //Amit  // Distibution of bags to passenger
                private Dictionary<int, int> calculation(int originatingFirstPax, int transferingFirstPax, int originatingSecondPax, int transferingSecondPax, int originatingFirstBag, int transferingFirstBag, int originatingSecondBag, int transferingSecondBag) 
                {
                    Dictionary<int, int> dict = new Dictionary<int, int>();

                    Random random = new Random();
                    //Region of First Class Originating Pax
                    for (int p = 0; p < originatingFirstBag; p++) {
                        int OrigFPNo = random.Next(1, originatingFirstPax);
                        if(dict.ContainsKey(OrigFPNo))
                        {

                            var value = Convert.ToInt32( dict[OrigFPNo].ToString());
                            value = value + 1;
                            dict[OrigFPNo] = value;

                        }
                        else
                        {
                            dict.Add(OrigFPNo, 1);
                        }
                    }
                    //Region of First Class Transferring Pax
                    for (int p = 0; p < transferingFirstBag; p++)
                    {
                        int OrigFPNo = random.Next(originatingFirstPax + 1, originatingFirstPax + transferingFirstPax);
                        if (dict.ContainsKey(OrigFPNo))
                        {

                            var value = Convert.ToInt32(dict[OrigFPNo].ToString());
                            value = value + 1;
                            dict[OrigFPNo] = value;
                        }
                        else
                        {
                            dict.Add(OrigFPNo, 1);
                        }
                    }
                    //Region of Second Class Pax Originating
                    for (int p = 0; p < originatingSecondBag; p++)
                    {
                        int OrigFPNo = random.Next(originatingFirstPax + transferingFirstPax + 1,  originatingSecondPax + originatingFirstPax + transferingFirstPax);
                        if (dict.ContainsKey(OrigFPNo))
                        {

                            var value = Convert.ToInt32(dict[OrigFPNo].ToString());
                            value = value + 1;
                            dict[OrigFPNo] = value;
                        }
                        else
                        {
                            dict.Add(OrigFPNo, 1);
                        }
                    }
                    //Region of Second Class Pax Transferring
                    for (int p = 0; p < transferingSecondBag; p++)
                    {
                        int OrigFPNo = random.Next(originatingFirstPax + transferingFirstPax + originatingSecondPax + 1, originatingFirstPax + transferingFirstPax + originatingSecondPax + transferingSecondPax);
                        if (dict.ContainsKey(OrigFPNo))
                        {

                            var value = Convert.ToInt32(dict[OrigFPNo].ToString());
                            value = value + 1;
                            dict[OrigFPNo] = value;
                        }
                        else
                        {
                            dict.Add(OrigFPNo, 1);
                        }
                    }

                    return dict;
                }

                private double generateCreationTimeBasedOnICT(DateTime heureDepart, DateTime scenarioStart, bool bSecond,
                    int iIndexICTEco, int iIndexICTFB, DataTable dtICTEco, DataTable dtICTFB, int intervalICT, Random rand)
                {
                    double lCreationTime = -1;

                    double dTimeBefore = -1;
                    string sTimeBefore = null;
                    if (bSecond)
                        sTimeBefore = getNombreBaggageVisitorsTransferTime(iIndexICTEco, dtICTEco, 0, rand.NextDouble());
                    else
                        sTimeBefore = getNombreBaggageVisitorsTransferTime(iIndexICTFB, dtICTFB, 0, rand.NextDouble());

                    if (Double.TryParse(sTimeBefore, out dTimeBefore))
                    {
                        dTimeBefore += intervalICT * rand.NextDouble();

                        DateTime heureArriveePax = heureDepart.AddMinutes(-dTimeBefore);
                        lCreationTime = Math.Round(OverallTools.DataFunctions.MinuteDifference(scenarioStart, heureArriveePax), 2);
                    }
                    return lCreationTime;
                }

                private double generateCreationTimeBasedOnCheckInShowUp(DateTime heureDepart, DateTime scenarioStart, bool bSecond,
                    int iIndexCIShowUpEco, int iIndexCIShowUpFB, DataTable dtCIShowUpEco, DataTable dtCIShowUpFB, int interval, Random rand)
                {
                    double lCreationTime = -1;

                    double dTimeBefore = -1;
                    string sTimeBefore = null;
                    if (bSecond)
                        sTimeBefore = getNombreBaggageVisitorsTransferTime(iIndexCIShowUpEco, dtCIShowUpEco, 0, rand.NextDouble());
                    else
                        sTimeBefore = getNombreBaggageVisitorsTransferTime(iIndexCIShowUpFB, dtCIShowUpFB, 0, rand.NextDouble());
                    if (Double.TryParse(sTimeBefore, out dTimeBefore))
                    {
                        dTimeBefore += interval * rand.NextDouble();

                        DateTime heureArriveePax = heureDepart.AddMinutes(-dTimeBefore);
                        lCreationTime = Math.Round(OverallTools.DataFunctions.MinuteDifference(_dtStartDate, heureArriveePax), 2);
                    }
                    return lCreationTime;
                }

                private double generateCreationTimeForDeparturePax(DateTime heureDepart, DateTime scenarioStart, bool bSecond,
                    int iIndexShowUpDistributionEco, int iIndexShowUpDistributionFB,
                    DataTable dtShowUpDistributionEco, DataTable dtShowUpDistributionFB, int distributionIntervalInMinutes,
                    Random rand)
                {
                    double lCreationTime = -1;

                    double dTimeBefore = -1;
                    string sTimeBefore = null;
                    if (bSecond)
                        sTimeBefore = getNombreBaggageVisitorsTransferTime(iIndexShowUpDistributionEco, dtShowUpDistributionEco, 0, rand.NextDouble());
                    else
                        sTimeBefore = getNombreBaggageVisitorsTransferTime(iIndexShowUpDistributionFB, dtShowUpDistributionFB, 0, rand.NextDouble());
                    if (Double.TryParse(sTimeBefore, out dTimeBefore))
                    {
                        dTimeBefore += distributionIntervalInMinutes * rand.NextDouble();

                        DateTime heureArriveePax = heureDepart.AddMinutes(-dTimeBefore);
                        lCreationTime = Math.Round(OverallTools.DataFunctions.MinuteDifference(_dtStartDate, heureArriveePax), 2);
                    }
                    return lCreationTime;
                }
                #endregion

                #region private int[,] obtenirNombreTransfert(...)
                /// <summary>
                /// Fonction qui retourne une table de (FPTable.rows.count) lignes sur 5 colonnes. Cette table contient
                /// tous les vols valides pour un transfer avec :
                ///     Colonne 1 : Identifiant du vol.
                ///     Colonne 2 : Terminal de la porte du vol.
                ///     Colonne 3 : Heure du vol.
                ///     Colonne 4 : Passagers en tranfer en première classe.
                ///     Colonne 5 : Passagers en tranfer en seconde classe.
                /// </summary>
                /// <param name="startDate">Heure de départ de la simulation.</param>
                /// <param name="FPTable">Table des plans de vols (départ ou arrivés)</param>
                /// <param name="AircraftTypeTable">La table des typse d'appareils avec leurs capacités.</param>
                /// <param name="FlightCategories">La table des catégories de vols.</param>
                /// <param name="LoadFactorTable">La table des facteurs de chargement.</param>
                /// <param name="bArrival">Booléen indiquant si c'est une feuille de vol départ ou arrivée.</param>
                /// <returns>Tableau de 5 colonnes de large.</returns>
                private int[,] obtenirNombreTransfert(DataTable FPTable,
                                                      DataManagement.ExceptionTable LoadFactorTable,
                                                      bool bArrival,
                                                      bool bFlightCategory)
                {
                    //For each row :
                    // - Flight id
                    // - Flight terminal  / Flight Category
                    // - Time
                    // - Transferred Pax (first)
                    // - Transferred Pax (Eco)

                    int[,] resultat = new int[FPTable.Rows.Count, 5];
                    Double nombreDePassagers;
                    String sSTTime = GlobalNames.sFPD_Column_STD;
                    if (bArrival)
                        sSTTime = GlobalNames.sFPA_Column_STA;
                    for (int i = 0; i < FPTable.Rows.Count; i++)
                    {
                        resultat[i, 0] = (int)FPTable.Rows[i][GlobalNames.sFPD_A_Column_ID];
                        if (!Int32.TryParse(FPTable.Rows[i][GlobalNames.sFPD_A_Column_TerminalGate].ToString(), out resultat[i, 1]))
                            continue;
                        String sFlightCategory = FPTable.Rows[i][GlobalNames.sFPD_A_Column_FlightCategory].ToString();
                        String sAirline = FPTable.Rows[i][GlobalNames.sFPD_A_Column_AirlineCode].ToString();
                        if (bFlightCategory)
                        {
                            resultat[i, 1] = alFlightCategory.IndexOf(sFlightCategory);
                        }
                        DateTime dtFlightTime = OverallTools.DataFunctions.toDateTime(FPTable.Rows[i][GlobalNames.sFPD_A_Column_DATE], FPTable.Rows[i][sSTTime]);
                        if (dtFlightTime < _dtStartDate)
                        {
                            resultat[i, 2] = -1;
                            resultat[i, 3] = 0;
                            resultat[i, 4] = 0;
                            continue;
                        }
                        resultat[i, 2] = (int)OverallTools.DataFunctions.MinuteDifference(_dtStartDate, dtFlightTime);

                        nombreDePassagers = OverallTools.DataFunctions.numberOfPassengers(FPTable.Rows[i], etAircraftType, _dtFlightCategories, LoadFactorTable, _ListeErreurs);

                        String sPrefixe = "A_";
                        if (!bArrival)
                            sPrefixe = "D_";

                        int iIndexColumn;
                        DataTable dtLoadFactor = LoadFactorTable.GetInformationsColumns(0, sPrefixe + resultat[i, 0].ToString(), sAirline, sFlightCategory, out iIndexColumn);
                        int iIndexColumnFB;
                        DataTable dtLoadFactorFB = LoadFactorTable.GetInformationsColumns(1, sPrefixe + resultat[i, 0].ToString(), sAirline, sFlightCategory, out iIndexColumnFB);

                        if (nombreDePassagers > 0)
                        {
                            String sPremiere = OverallTools.DataFunctions.getValue(dtLoadFactor, GlobalNames.sLFD_A_Line_C, 0, iIndexColumn);
                            String sSeconde = OverallTools.DataFunctions.getValue(dtLoadFactor, GlobalNames.sLFD_A_Line_Y, 0, iIndexColumn);
                            /*String sPremiere = OverallTools.DataFunctions.getValue(LoadFactorTable, GlobalNames.sLFD_A_Line_C, 0, LoadFactorTable.Columns.IndexOf(sFlightCategory));
                            String sSeconde = OverallTools.DataFunctions.getValue(LoadFactorTable, GlobalNames.sLFD_A_Line_Y, 0, LoadFactorTable.Columns.IndexOf(sFlightCategory));*/
                            Double dPremiere;
                            Double dSeconde;
                            if ((!Double.TryParse(sPremiere, out dPremiere)) || (!Double.TryParse(sSeconde, out dSeconde)))
                            {
                                _ListeErreurs.Add("Err00150 : The '" + dtLoadFactor.TableName + "' table have a problem");
                                return null;
                            }
                            Double dPremiereClasse = (nombreDePassagers * dPremiere) / 100;
                            Double dSecondeClasse = (nombreDePassagers * dSeconde) / 100;
                            String sTransferring = OverallTools.DataFunctions.getValue(dtLoadFactor, GlobalNames.sLFD_A_Line_Transferring, 0, iIndexColumn);
                            String sTransferringFB = OverallTools.DataFunctions.getValue(dtLoadFactorFB, GlobalNames.sLFD_A_Line_Transferring, 0, iIndexColumnFB);

                            Double dTransferring, dTransferringFB;
                            if ((!Double.TryParse(sTransferring, out dTransferring)) || (!Double.TryParse(sTransferringFB, out dTransferringFB)))
                            {
                                _ListeErreurs.Add("Err00151 : The '" + dtLoadFactor.TableName + "' table have a problem");
                                return null;
                            }
                            resultat[i, 3] = (int)Math.Round((dTransferringFB * dPremiereClasse) / 100);
                            resultat[i, 4] = (int)Math.Round((dTransferring * dSecondeClasse) / 100);
                        }
                        else
                        {
                            resultat[i, 3] = 0;
                            resultat[i, 4] = 0;
                        }
                    }
                    return resultat;
                }
                #endregion

                #region private bool[] obtenirVolsTransfert(...)
                /// <summary>
                /// Fonction qui permet d'obtenir les vols contenus dans la tranche horaire passée en paramètre.
                /// </summary>
                /// <param name="tiDepartingFlight">Table de x lignes sur 5 colonnes.</param>
                /// <param name="dTimeBegin">Heure de début du créneau</param>
                /// <param name="dTimeEnd">Heure de fin du créneau</param>
                /// <param name="iTerminal">Terminal (-1 pour indiqué qu'il ne doit pas être pris en compte)</param>
                /// <returns></returns>
                private bool[] obtenirVolsTransfert(int[,] tiDepartingFlight, Double dTimeBegin, double dTimeEnd, int iTerminal)
                {
                    int i;
                    bool[] resultat = new bool[tiDepartingFlight.Length / 5];
                    for (i = 0; i < resultat.Length; i++)
                    {
                        if ((tiDepartingFlight[i, 2] == -1) ||
                            (tiDepartingFlight[i, 2] < dTimeBegin) ||
                            //(tiDepartingFlight[i, 2] >= dTimeEnd) ||
                            (tiDepartingFlight[i, 2] > dTimeEnd) ||    // transfer period: includes start, includes end
                            ((iTerminal != -1) && (tiDepartingFlight[i, 1] != iTerminal)))
                            resultat[i] = false;
                        else
                            resultat[i] = true;
                    }
                    return resultat;
                }
                #endregion

                private int getFlightIndex(int iFlightId)
                {
                    for (int i = 0; i <= tiTransferTransferredFlights.Length / 5; i++)
                    {
                        if (tiTransferTransferredFlights[i, 0] == iFlightId)
                            return i;
                    }
                    return -1;
                }

                #region private void obtenirDistributionTerminal()
                private void obtenirDistributionTerminal()
                {
                    iNbTerminaux = 0;
                    if (_dtTransferTerminalDistribution == null)
                        return;
                    int iMaxTerminal = 0;
                    if (_dtTransferTerminalDistribution.Rows.Count == 0)
                        return;
                    foreach (DataRow line in _dtTransferTerminalDistribution.Rows)
                    {
                        String TerminalName = line[0].ToString();
                        int iIndex = 1;
                        String sTerminalIndex = OverallTools.FonctionUtiles.nextInt(TerminalName, ref iIndex);
                        if (sTerminalIndex.Length == 0)
                            return;
                        if (!Int32.TryParse(sTerminalIndex, out iIndex))
                            return;
                        if (iIndex > iMaxTerminal)
                            iMaxTerminal = iIndex;
                    }
                    if (iMaxTerminal == 0)
                        return;
                    int[] iTerminal = new int[iMaxTerminal + 1];
                    for (int i = 1; i < _dtTransferTerminalDistribution.Columns.Count; i++)
                    {

                        String TerminalName = _dtTransferTerminalDistribution.Columns[i].ColumnName;
                        int iIndex = 1;
                        String sTerminalIndex = OverallTools.FonctionUtiles.nextInt(TerminalName, ref iIndex);
                        if (!Int32.TryParse(sTerminalIndex, out iIndex))
                            return;
                        iTerminal[i] = iIndex - 1;
                    }

                    tdTransferTerminalDistribution = new Double[iMaxTerminal, iMaxTerminal];
                    foreach (DataRow line in _dtTransferTerminalDistribution.Rows)
                    {

                        String TerminalName = line[0].ToString();
                        int iIndex = 1;
                        String sTerminalIndex = OverallTools.FonctionUtiles.nextInt(TerminalName, ref iIndex);
                        if (!Int32.TryParse(sTerminalIndex, out iIndex))
                        {
                            tdTransferTerminalDistribution = null;
                            return;
                        }
                        for (int i = 1; i < _dtTransferTerminalDistribution.Columns.Count; i++)
                        {
                            tdTransferTerminalDistribution[iIndex - 1, iTerminal[i]] = (Double)line[i];
                        }
                    }
                    for (int jLine = 0; jLine < iMaxTerminal; jLine++)
                    {
                        Double dSum = 0;
                        for (int kCol = 0; kCol < iMaxTerminal; kCol++)
                        {
                            dSum += tdTransferTerminalDistribution[jLine, kCol];
                        }
                        if (dSum == 100)
                            continue;
                        if (dSum == 0)
                        {
                            for (int kCol = 0; kCol < iMaxTerminal; kCol++)
                            {
                                tdTransferTerminalDistribution[jLine, kCol] = 100.0 / (Double)iMaxTerminal;
                            }
                        }
                        else
                        {
                            Double dRatio = 100.0 / dSum;
                            for (int kCol = 0; kCol < iMaxTerminal; kCol++)
                            {
                                tdTransferTerminalDistribution[jLine, kCol] *= dRatio;
                            }
                        }
                    }
                    iNbTerminaux = iMaxTerminal;
                }
                #endregion

                #region private void obtenirDistributionFlightCategory()
                private void obtenirDistributionFlightCategory()
                {
                    iNbFlightCategory = 0;
                    if (_dtTransferFlightCategoryDistribution == null)
                        return;
                    if (_dtTransferFlightCategoryDistribution.Rows.Count == 0)
                        return;
                    int iMaxFlightCategory = _dtTransferFlightCategoryDistribution.Rows.Count;
                    alFlightCategory = new ArrayList();
                    foreach (DataRow drRow in _dtTransferFlightCategoryDistribution.Rows)
                    {
                        alFlightCategory.Add(drRow[0].ToString());
                    }
                    alFlightCategory.Sort(new FonctionUtiles.ColumnsComparer());

                    int[] iIndexColumns = new int[_dtTransferFlightCategoryDistribution.Columns.Count - 1];
                    int iIndex;
                    for (int i = 1; i < _dtTransferFlightCategoryDistribution.Columns.Count; i++)
                    {
                        iIndex = alFlightCategory.IndexOf(_dtTransferFlightCategoryDistribution.Columns[i].ColumnName);
                        if (iIndex == -1)
                            return;
                        iIndexColumns[i - 1] = iIndex;
                    }

                    tdTransferFlightCategoryDistribution = new Double[iMaxFlightCategory, iMaxFlightCategory];
                    foreach (DataRow line in _dtTransferFlightCategoryDistribution.Rows)
                    {
                        String FlightCategoryName = line[0].ToString();
                        iIndex = alFlightCategory.IndexOf(FlightCategoryName);
                        if (iIndex == -1)
                        {
                            tdTransferFlightCategoryDistribution = null;
                            return;
                        }
                        for (int i = 1; i < _dtTransferFlightCategoryDistribution.Columns.Count; i++)
                        {
                            tdTransferFlightCategoryDistribution[iIndex, iIndexColumns[i - 1]] = (Double)line[i];
                        }
                    }
                    /*                        
                     * for (i = 0; i < tdTransferFlightCategoryDistribution.Length / iNbFlightCategory; i++)
                        {
                            if (dValue < tdTransferFlightCategoryDistribution[iArrivalTerminal, i])
                            {
                                iChooseTerminal = i;
                                break;
                            }
                            dValue -= tdTransferFlightCategoryDistribution[iArrivalTerminal, i];
                        }*/
                    for (int jLine = 0; jLine < iMaxFlightCategory; jLine++)
                    {
                        Double dSum = 0;
                        for (int kCol = 0; kCol < iMaxFlightCategory; kCol++)
                        {
                            dSum += tdTransferFlightCategoryDistribution[jLine, kCol];
                        }
                        if (dSum == 100)
                            continue;
                        if (dSum == 0)
                        {
                            for (int kCol = 0; kCol < iMaxFlightCategory; kCol++)
                            {
                                tdTransferFlightCategoryDistribution[jLine, kCol] = 100.0 / (Double)iMaxFlightCategory;
                            }
                        }
                        else
                        {
                            Double dRatio = 100.0 / dSum;
                            for (int kCol = 0; kCol < iMaxFlightCategory; kCol++)
                            {
                                tdTransferFlightCategoryDistribution[jLine, kCol] *= dRatio;
                            }
                        }
                    }
                    iNbFlightCategory = iMaxFlightCategory;
                }
                #endregion

                #region private bool choixTransfert(...)
                /// <summary>
                /// 
                /// </summary>
                /// <param name="NouveauPassager">The current line that represents the passenger</param>
                /// <param name="sFlightCategorie">The current flight categorie of the passenger</param>
                /// <param name="sAirline">The airline of the current passenger.</param>
                /// <param name="siegesLibre">The informations about the flight with available spaces for transfer passengers.</param>
                /// <param name="iArrivalTerminal">The arrival terminal (or Flight categori) when using the transfer distribution per terminal or flight categories</param>
                /// <param name="Pax_GenTransferLogLine">The line for the result of allocation for transfer passagers.</param>
                /// <param name="FPTable">The departure flight plan (if we are allocating the arrival passengers) or the arrival flight plan if we are allocating the departure passengers.</param>
                /// <param name="VolsTransferable">Table of boolean that indicates which flights are available for the current passager (in \ref siegesLibre).</param>
                /// <param name="heureVol">The current arrival /departure time for the current passenger.</param>
                /// <param name="randVol">The random stream to choose a flight</param>
                /// <param name="randCreneau">The random stream to choose a position.</param>
                /// <param name="randTerminalDistribution">A random stream for the allocation with the transfer distribution per terminal  or flight categorie</param>
                /// <param name="bArrivalFlights">Boolean that indicates if we are currently for an arriving flight or departing.</param>
                /// <returns></returns>
                private bool choixTransfert(DataRow NouveauPassager,
                                            String sFlightCategorie,
                                            String sAirline,
                                            int[,] siegesLibre,
                                            int iArrivalTerminal,
                                            String[] Pax_GenTransferLogLine,
                                            DataTable FPTable,
                                            bool[] VolsTransferable,
                                            DateTime heureVol,
                                            Random randVol,
                                            Random randCreneau,
                                            Random randTerminalDistribution,
                                            bool bArrivalFlights,
                                            out double ictPeriodStartMinute, out double ictPeriodEndMinute)
                {
                    ictPeriodStartMinute = -1;
                    ictPeriodEndMinute = -1;

                    bool bUseTerminalDistribution = (tdTransferTerminalDistribution != null) && (iArrivalTerminal != -1);
                    bool bUseFlightCategoryDistribution = (tdTransferFlightCategoryDistribution != null) && (iArrivalTerminal != -1);

                    int iChooseTerminal = -1;
                    int iFlight = (Int32)NouveauPassager[2];
                    //On récupère la classe du passager courant
                    int classe = FonctionsType.getInt(NouveauPassager[3], NouveauPassager[3].GetType());
                    if (!bArrivalFlights)
                    {
                        classe = FonctionsType.getInt(NouveauPassager[5]);
                        iFlight = (Int32)NouveauPassager[4];
                    }

                    int nbCreneauValide, iCreneauSelectionne = 0;

                    String sPrefixe = "A_";
                    if (!bArrivalFlights)
                        sPrefixe = "D_";

                    int iIndexColumn;
                    DataTable dtInterConnectingTimes = etInterConnectingTimesTable.GetInformationsColumns(classe, sPrefixe + iFlight.ToString(), sAirline, sFlightCategorie, out iIndexColumn);

                    //On Sélectionne une tranche horaire pour le vol souhaité. Il est tiré aléatoirement parmi
                    //les tranches horaires qui existe.
                    String sCreneauHoraireChoisi = getNombreBaggageVisitorsTransferTime(iIndexColumn, dtInterConnectingTimes, 0, randCreneau.NextDouble());
                    int indexCreneau = OverallTools.DataFunctions.indexLigne(dtInterConnectingTimes, 0, sCreneauHoraireChoisi);
                    if (indexCreneau == -1)
                    {
                        //Il n'y a plus aucun siège de disponible pour une correspondance.
                        return false;
                    }
                    //On convertit les bornes du créneau en double afin de pouvoir les exploiter.
                    Double dCreneauHoraireChoisi, dCreneauHoraireChoisiMax;
                    dCreneauHoraireChoisiMax = (Double)((Int32)dtInterConnectingTimes.Rows[indexCreneau].ItemArray[1]);
                    Double.TryParse(sCreneauHoraireChoisi, out dCreneauHoraireChoisi);

                    ictPeriodStartMinute = dCreneauHoraireChoisi;
                    ictPeriodEndMinute = dCreneauHoraireChoisiMax;

                    bool valide = false;
                    int i;
                    //On vérifie qu'il y a au moins un siège de libre sur un vol en partance dans la tranche horaire possible
                    for (i = 0; i < VolsTransferable.Length; i++)
                    {
                        if ((VolsTransferable[i]) && (siegesLibre[i, 3 + classe - 1] != 0))
                        {
                            valide = true;
                            break;
                        }
                    }
                    if (!valide)
                    {
                        //Il n'y a plus aucun siège de disponible pour une correspondance.
                        return false;
                    }
                    valide = false;

                    if (bUseTerminalDistribution)
                    {
                        Double dValue = randCreneau.NextDouble() * 100.0;
                        for (i = 0; i < tdTransferTerminalDistribution.Length / iNbTerminaux; i++)
                        {
                            if (dValue < tdTransferTerminalDistribution[iArrivalTerminal - 1, i])
                            {
                                iChooseTerminal = i + 1;
                                break;
                            }
                            dValue -= tdTransferTerminalDistribution[iArrivalTerminal - 1, i];
                        }
                        if (iChooseTerminal == -1)
                            return false;
                    }
                    if (bUseFlightCategoryDistribution)
                    {
                        Double dValue = randCreneau.NextDouble() * 100.0;
                        for (i = 0; i < tdTransferFlightCategoryDistribution.Length / iNbFlightCategory; i++)
                        {
                            if (dValue < tdTransferFlightCategoryDistribution[iArrivalTerminal, i])
                            {
                                iChooseTerminal = i;
                                break;
                            }
                            dValue -= tdTransferFlightCategoryDistribution[iArrivalTerminal, i];
                        }
                        if (iChooseTerminal == -1)
                            return false;
                    }
                    DateTime dtCreneauHoraireChoisi;
                    DateTime dtCreneauHoraireChoisiMax;
                    if (bArrivalFlights)
                    {
                        dtCreneauHoraireChoisi = heureVol.AddMinutes(dCreneauHoraireChoisi);
                        dtCreneauHoraireChoisiMax = heureVol.AddMinutes(dCreneauHoraireChoisiMax);
                    }
                    else
                    {
                        dtCreneauHoraireChoisi = heureVol.AddMinutes(-dCreneauHoraireChoisiMax);
                        dtCreneauHoraireChoisiMax = heureVol.AddMinutes(-dCreneauHoraireChoisi);
                    }

                    dCreneauHoraireChoisi = OverallTools.DataFunctions.MinuteDifference(_dtStartDate, dtCreneauHoraireChoisi);
                    dCreneauHoraireChoisiMax = OverallTools.DataFunctions.MinuteDifference(_dtStartDate, dtCreneauHoraireChoisiMax);

                    //On recherche un vol valide pour le créneau désigné.
                    bool[] VolsTransferablecreneau = obtenirVolsTransfert(siegesLibre, dCreneauHoraireChoisi, dCreneauHoraireChoisiMax, iChooseTerminal);

                    //On vérifie qu'il y a bien un vol de non rempli pour le créneau sélectionné.
                    nbCreneauValide = 0;
                    for (i = 0; i < VolsTransferablecreneau.Length; i++)
                    {
                        if (VolsTransferablecreneau[i] && (siegesLibre[i, 3 + classe - 1] != 0))
                        {
                            //Il y a au moins un vol non rempli, on peut continuer
                            iCreneauSelectionne = i;
                            nbCreneauValide++;
                        }
                    }
                    //Aucun vol n'a de places pour le passager
                    if (nbCreneauValide == 0)
                    {
                        return false;
                    }
                    //On sélectionne un vol parmi tous ceux valides. (S'il n'y avait qu'un seul vol de valide
                    //alors il est déjà initialisé (iCreneauSelectionne).
                    if (nbCreneauValide > 1)
                    {
                        //On choisit aléatoirement un des creneaux possibles
                        iCreneauSelectionne = randVol.Next(nbCreneauValide) + 1;
                        for (i = 0; i < VolsTransferablecreneau.Length; i++)
                        {
                            if (VolsTransferablecreneau[i] && (siegesLibre[i, 3 + classe - 1] != 0))
                            {
                                //On décrémente, ainsi on est sur de bien prendre le nieme vol.
                                iCreneauSelectionne--;
                                //Lorsque l'on arrive à Zéro c'est que l'on a vu i creneau valide défiler.
                                if (iCreneauSelectionne == 0)
                                {
                                    iCreneauSelectionne = i;
                                    break;
                                }
                            }
                        }
                    }
                    siegesLibre[iCreneauSelectionne, 3 + classe - 1]--;
                    if (bArrivalFlights)
                    {
                        NouveauPassager[4] = siegesLibre[iCreneauSelectionne, 0];//FonctionsType.getInt(OverallTools.DataFunctions.getValue(FPDTable.Rows[iCreneauSelectionne], "ID"));
                        NouveauPassager[5] = classe;
                        NouveauPassager[6] = siegesLibre[iCreneauSelectionne, 2];//OverallTools.DataFunctions.MinuteDifference(startDate, heureDepart);
                    }
                    else
                    {
                        NouveauPassager[2] = siegesLibre[iCreneauSelectionne, 0];//FonctionsType.getInt(OverallTools.DataFunctions.getValue(FPDTable.Rows[iCreneauSelectionne], "ID"));
                        NouveauPassager[3] = classe;
                        NouveauPassager[1] = siegesLibre[iCreneauSelectionne, 2];//OverallTools.DataFunctions.MinuteDifference(startDate, heureDepart);
                    }
                    Pax_GenTransferLogLine[4] = "#" + NouveauPassager[4] + "  " + NouveauPassager[6];
                    return true;
                }
                #endregion
            }
            #endregion

            #region //SGE-26/03/2012-Begin
            /// <summary>
            /// Class permettant l'analyse du PRKPLAN
            /// </summary>
            internal class PRKTrace
            {
                /// <summary>
                /// Function tha will analyse the PRKPlan by generating the associated PRKTrace and return the tables calculated.
                /// </summary>
                /// <param name="dtBeginDate">Starting date for the analysis.</param>
                /// <param name="dtEndDate">Ending date for the analysis.</param>
                /// <param name="dStep">Step use for the results tables</param>
                /// <param name="dStepDistribution">Step used for the results that are distribution </param>
                /// <param name="iNbClasses">Number of classes used for the results that are distribution</param>
                /// <param name="DonneesEnCours">The actual global project, (to be able to get missing tables or parameters)</param>
                /// <param name="dtPrkPlan">The PrkPlan to analyse</param>
                /// <param name="dtFPDTable">The departure flight plan used to generate the PrkPlan</param>
                /// <param name="dtFPATable">The arrival flight plan used to generate the PRKPlan</param>
                /// <param name="etShortStayException">The table used for the passengers that are in short stay process</param>
                /// <param name="etLongStayException">The table used for the passengers that are in long stay process</param>
                /// <param name="dtInitialState">The initiale state of the different parking (number of vehicules already present in the parking)</param>
                /// <param name="iSeed">The seed for the random calculation.</param>
                /// <param name="chForm">The form used to show the user the progress bar.</param>
                /// <param name="lsNames">The names of the table calculated by the function and that has to be showned in the directory for the current analysis. (Used for the functions linked to the \ref BagTrace analysis).</param>
                /// <returns>Returns the tables calculated for the current occupation of the parkings.</returns>
                internal static Hashtable GenerateAndAnalysePRKTrace(DateTime dtBeginDate,
                    DateTime dtEndDate,
                    Double dStep,
                    Double dStepDistribution,
                    int iNbClasses,
                    GestionDonneesHUB2SIM DonneesEnCours,
                    DataTable dtPrkPlan,
                    DataTable dtFPDTable,
                    DataTable dtFPATable,
                    DataManagement.ExceptionTable etShortStayException,
                    DataManagement.ExceptionTable etLongStayException,
                    DataTable dtInitialState,
                    int iSeed,
                    SIMCORE_TOOL.Prompt.SIM_LoadingForm chForm,
                    out List<String> lsNames,
                    Double analysisRange,   // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation)
                    List<double> paramScenarioPercentiles)
                {
                    List<String> lsTrace = new List<string>();
                    int iId = 1;
                    lsNames = null;
                    lsTrace.Add("BagID	PaxID	Flight	ST(mn)	Recirc	IntLnk	STEPS TRACE...");

                    double percentile1 = -1;
                    double percentile2 = -1;
                    double percentile3 = -1;
                    if (paramScenarioPercentiles != null && paramScenarioPercentiles.Count == 3)    // >> Task #9936 Pax2Sim - project properties saved specifically for each scenario + Times stats Spec
                    {
                        percentile1 = paramScenarioPercentiles[0];
                        percentile2 = paramScenarioPercentiles[1];
                        percentile3 = paramScenarioPercentiles[2];
                    }
                    else if (paramScenarioPercentiles != null && paramScenarioPercentiles.Count == 0)
                    {
                        percentile1 = DonneesEnCours.Levels[0];
                        percentile2 = DonneesEnCours.Levels[1];
                        percentile3 = DonneesEnCours.Levels[2];

                        paramScenarioPercentiles.Add(DonneesEnCours.Levels[0]);
                        paramScenarioPercentiles.Add(DonneesEnCours.Levels[1]);
                        paramScenarioPercentiles.Add(DonneesEnCours.Levels[2]);
                    }

                    #region We get the informations about the parking informations.
                    List<Point> lpIn = new List<Point>();
                    List<Point> lpOut = new List<Point>();
                    for (int iLigne = 0; iLigne < dtInitialState.Rows.Count; iLigne++)
                    {

                        #region We find the distribution columns and treat the information about the current parking object we need to use for the specidied Parking
                        String sName = dtInitialState.Rows[iLigne][0].ToString();
                        String sObjetName = sName.Substring(0, sName.IndexOf('(') - 1);

                        int[] tiObjetType = OverallTools.DataFunctions.AnalyzeGroupName(sObjetName);
                        if (tiObjetType == null)
                            continue;
                        if (tiObjetType.Length != 4)
                            continue;
                        if (tiObjetType[2] == GestionDonneesHUB2SIM.ModelInGroup)
                            lpIn.Add(new Point(tiObjetType[0], tiObjetType[3]));
                        else
                            lpOut.Add(new Point(tiObjetType[0], tiObjetType[3]));
                        #endregion
                    }
                    #endregion
                    ///We generate the cars that are initialy in the parkings.
                    GenerateInitialCars(lsTrace, dtInitialState, etLongStayException.Table, iSeed, ref iId);

                    GenerateOriginatingCars(lsTrace, dtBeginDate, dtEndDate, dtPrkPlan, dtFPDTable, etShortStayException, etLongStayException, iSeed, lpIn, ref iId);
                    GenerateTerminatingCars(lsTrace, dtBeginDate, dtEndDate, dtPrkPlan, dtFPATable, etShortStayException, iSeed,/*lpOut*/lpIn, ref iId);
                    /*StreamWriter sw = new StreamWriter("D:\\Tmp.txt");
                    foreach (String sTmp in lsTrace)
                        sw.WriteLine(sTmp);
                    sw.Close();*/
                    BagTraceAnalysis bagAnalyse = new BagTraceAnalysis(lsTrace, percentile1, percentile2, percentile3);


                    Double dEndingTime = OverallTools.DataFunctions.MinuteDifference(dtBeginDate, dtEndDate);
                    if (!bagAnalyse.OpenBagTrace(dEndingTime, chForm))
                        return null;
                    XmlNode airportStructure = DonneesEnCours.getRacine();  // >> Task #13659 IST MakeUp segregation
                    Hashtable htResult = bagAnalyse.GenerateResults(dtBeginDate, dtEndDate, dStep, dStepDistribution,
                        iNbClasses, chForm, analysisRange, true, true, true, airportStructure, new List<AnalysisResultFilter>(),
                        new List<AnalysisResultFilter>(), new List<string>(), paramScenarioPercentiles); // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation   // >> Task #13955 Pax2Sim -BHS trace loading issue    // >> Task #14280 Bag Trace Loading time too long
                    lsNames = bagAnalyse.Names;
                    return htResult;
                }

                /// <summary>
                /// Function that will generate the originating cars following the prkPlan. That will then 
                /// </summary>
                /// <param name="lsPRKTrace"></param>
                /// <param name="dtBeginDate"></param>
                /// <param name="dtEndDate"></param>
                /// <param name="dtPrkPlan"></param>
                /// <param name="dtFPDTable"></param>
                /// <param name="etShortStayException"></param>
                /// <param name="etLongStayException"></param>
                /// <param name="iSeed"></param>
                /// <param name="lpIn"></param>
                /// <param name="iId"></param>
                private static void GenerateOriginatingCars(
                    List<String> lsPRKTrace,
                    DateTime dtBeginDate,
                    DateTime dtEndDate,
                    DataTable dtPrkPlan,
                    DataTable dtFPDTable,
                    DataManagement.ExceptionTable etShortStayException,
                    DataManagement.ExceptionTable etLongStayException,
                    int iSeed,
                    List<Point> lpIn,
                    ref int iId)
                {

                    # region Get the indexes of the differents columns in PaxPlanTable
                    int iPaxID = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_PaxID);
                    int iPaxCreationTime = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_CreationTime);
                    int iFPA_ID = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_FPAID);
                    int iFPA_Class = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_FPAClass);
                    int iFPD_ID = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_FPDID);
                    int iFDP_Class = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_FPDClass);
                    int iFPD_STD = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_FPDSTD);
                    int iSelf_CheckIn = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_SelfCI);

                    int iNbVisitors = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_Visitors);
                    int iNbBags = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_BagsIG);
                    int iNbBagsOOG = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_BagsOOG);
                    int iNBTrolleys = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_Trolleys);
                    int iSegregation = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_Segregation);

                    int iPassportLocal = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_Local);
                    int iTransfer = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_Transfer);

#if(PAXINOUTUTILISATION)
                    int iTerminalInOut = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_TerminalInOut);
                    int iInOut = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_InOut);
#endif
                    int iCarIndex = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_Car);
                    #endregion

                    Random rdLongStay = new Random(iSeed + 3);
                    Random rdShortStay = new Random(iSeed + 4);
                    Random rdSpreadStay = new Random(iSeed + 5);

                    Dictionary<int, TableInformations.FlightInformation> difiInformations = TableInformations.getFlightsInformation(dtFPDTable);


                    int iIndexColumn;
                    DataTable dtTableForDistrib;
                    int interval;
                    foreach (DataRow drRow in dtPrkPlan.Rows)
                    {
                        if (FonctionsType.getInt(drRow[iCarIndex]) == 0)
                            continue;
                        if (FonctionsType.getInt(drRow[iTransfer]) > 0)
                            continue;
                        int iTerminal = FonctionsType.getInt(drRow[iTerminalInOut]);
                        if (iTerminal == 0)
                            continue;
                        int iIndexOut = FonctionsType.getInt(drRow[iInOut]);
                        if (iIndexOut == 0)
                            continue;
                        Point p = new Point(iTerminal, iIndexOut);
                        if (!lpIn.Contains(p))
                            continue;

                        int iClass = FonctionsType.getInt(drRow[iFDP_Class]);
                        int FlightID = FonctionsType.getInt(drRow[iFPD_ID]);
                        if (!difiInformations.ContainsKey(FlightID))
                            continue;
                        Random rdTmp = rdLongStay;
                        if (FonctionsType.getInt(drRow[iNbVisitors]) > 0)
                        {
                            dtTableForDistrib = etShortStayException.GetInformationsColumns(iClass, "D_" + FlightID.ToString(), difiInformations[FlightID].AirlineCode, difiInformations[FlightID].FlightCategory, out iIndexColumn);
                            rdTmp = rdShortStay;
                            if (dtTableForDistrib == null)
                            {

                                ///We are in the case where there is no exception for the current flight. We have to find the parking Name for the current
                                ///In/Out objet in the original table.
                                dtTableForDistrib = etShortStayException.Table;
                                if (dtTableForDistrib == null)
                                    continue;
                                iIndexColumn = GetIndexOfDistribution(dtTableForDistrib, iTerminal, iIndexOut, GestionDonneesHUB2SIM.ModelInGroup);
                                if (iIndexColumn == -1)
                                    continue;
                            }
                        }
                        else
                        {
                            dtTableForDistrib = etLongStayException.GetInformationsColumns(iClass, "D_" + FlightID.ToString(), difiInformations[FlightID].AirlineCode, difiInformations[FlightID].FlightCategory, out iIndexColumn);
                            if (dtTableForDistrib == null)
                            {

                                ///We are in the case where there is no exception for the current flight. We have to find the parking Name for the current
                                ///In/Out objet in the original table.
                                dtTableForDistrib = etLongStayException.Table;
                                if (dtTableForDistrib == null)
                                    continue;
                                iIndexColumn = GetIndexOfDistribution(dtTableForDistrib, iTerminal, iIndexOut, GestionDonneesHUB2SIM.ModelInGroup);
                                if (iIndexColumn == -1)
                                    continue;
                            }
                        }

                        interval = 0;
                        if (dtTableForDistrib.Rows.Count > 0)
                            interval = FonctionsType.getInt(dtTableForDistrib.Rows[0].ItemArray[1]) - FonctionsType.getInt(dtTableForDistrib.Rows[0].ItemArray[0]);
                        String sOccupation = PaxPlanClass.getNombreBaggageVisitorsTransferTime(iIndexColumn, dtTableForDistrib, 0, rdTmp.NextDouble());
                        Double dCreationTime = FonctionsType.getDouble(drRow[iPaxCreationTime]);
                        Double dOccupation = dCreationTime + FonctionsType.getDouble(sOccupation) + interval * rdSpreadStay.NextDouble();
                        Double dSTD = OverallTools.DataFunctions.MinuteDifference(dtBeginDate, difiInformations[FlightID].Time);
                        String PRKObject = BagTraceAnalysis.sPersonalParking + "_" + iTerminal.ToString() + "_" + iIndexOut.ToString();


                        lsPRKTrace.Add(iId.ToString() + "\t" + FonctionsType.getString(drRow[iPaxID]) + "\t" + FlightID.ToString() + "\t" + dSTD.ToString() + "\t0\t0\t" + PRKObject + "\t" + dCreationTime.ToString() + "\t" + dOccupation.ToString());
                        iId++;
                    }
                }
                private static int GetIndexOfDistribution(DataTable dtTable, int iTerminal, int iIndex, int iTypeObjet)
                {
                    if (dtTable == null)
                        return -1;
                    for (int i = 2; i < dtTable.Columns.Count; i++)
                    {

                        String sColumnName = dtTable.Columns[i].ColumnName;
                        sColumnName = sColumnName.Substring(0, sColumnName.IndexOf('(') - 1);
                        int[] iTmp = OverallTools.DataFunctions.AnalyzeGroupName(sColumnName);
                        if (iTmp.Length != 4)
                            continue;
                        if (iTmp[2] != iTypeObjet)
                            continue;
                        if (iTmp[0] != iTerminal)
                            continue;
                        if (iTmp[3] == iIndex)
                            return i;
                    }
                    return -1;
                }
                private static void GenerateTerminatingCars(
                    List<String> lsPRKTrace,
                    DateTime dtBeginDate,
                    DateTime dtEndDate,
                    DataTable dtPrkPlan,
                    DataTable dtFPATable,
                    DataManagement.ExceptionTable etShortStayException,
                    int iSeed,
                    List<Point> lpOut,
                    ref int iId)
                {
                    # region Get the indexes of the differents columns in PaxPlanTable
                    int iPaxID = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_PaxID);
                    int iPaxCreationTime = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_CreationTime);
                    int iFPA_ID = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_FPAID);
                    int iFPA_Class = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_FPAClass);
                    int iFPD_ID = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_FPDID);
                    int iFDP_Class = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_FPDClass);
                    int iFPD_STD = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_FPDSTD);
                    int iSelf_CheckIn = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_SelfCI);

                    int iNbVisitors = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_Visitors);
                    int iNbBags = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_BagsIG);
                    int iNbBagsOOG = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_BagsOOG);
                    int iNBTrolleys = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_Trolleys);
                    int iSegregation = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_Segregation);

                    int iPassportLocal = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_Local);
                    int iTransfer = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_Transfer);

#if(PAXINOUTUTILISATION)
                    int iTerminalInOut = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_TerminalInOut);
                    int iInOut = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_InOut);
#endif
                    int iCarIndex = dtPrkPlan.Columns.IndexOf(GlobalNames.sPaxPlan_Car);
                    #endregion

                    Random rdShortStay = new Random(iSeed + 6);
                    Random rdSpreadStay = new Random(iSeed + 7);

                    Dictionary<int, TableInformations.FlightInformation> difiInformations = TableInformations.getFlightsInformation(dtFPATable);


                    int iIndexColumn;
                    DataTable dtTableForDistrib;
                    int interval;
                    foreach (DataRow drRow in dtPrkPlan.Rows)
                    {
                        if (FonctionsType.getInt(drRow[iCarIndex]) == 0)
                            continue;
                        if (FonctionsType.getInt(drRow[iTransfer]) > 0)
                            continue;
                        if (FonctionsType.getInt(drRow[iNbVisitors]) == 0)
                            continue;

                        int iTerminal = FonctionsType.getInt(drRow[iTerminalInOut]);
                        if (iTerminal == 0)
                            continue;
                        int iIndexOut = FonctionsType.getInt(drRow[iInOut]);
                        if (iIndexOut == 0)
                            continue;
                        Point p = new Point(iTerminal, iIndexOut);
                        if (!lpOut.Contains(p))
                            continue;

                        int iClass = FonctionsType.getInt(drRow[iFPA_Class]);
                        int FlightID = FonctionsType.getInt(drRow[iFPA_ID]);
                        if (!difiInformations.ContainsKey(FlightID))
                            continue;

                        dtTableForDistrib = etShortStayException.GetInformationsColumns(iClass, "A_" + FlightID.ToString(), difiInformations[FlightID].AirlineCode, difiInformations[FlightID].FlightCategory, out iIndexColumn);
                        if (dtTableForDistrib == null)
                        {

                            ///We are in the case where there is no exception for the current flight. We have to find the parking Name for the current
                            ///In/Out objet in the original table.
                            dtTableForDistrib = etShortStayException.Table;
                            if (dtTableForDistrib == null)
                                continue;
                            iIndexColumn = GetIndexOfDistribution(dtTableForDistrib, iTerminal, iIndexOut, GestionDonneesHUB2SIM.ModelInGroup);
                            if (iIndexColumn == -1)
                                continue;
                        }
                        interval = 0;
                        if (dtTableForDistrib.Rows.Count > 0)
                            interval = FonctionsType.getInt(dtTableForDistrib.Rows[0].ItemArray[1]) - FonctionsType.getInt(dtTableForDistrib.Rows[0].ItemArray[0]);
                        String sOccupation = PaxPlanClass.getNombreBaggageVisitorsTransferTime(iIndexColumn, dtTableForDistrib, 0, rdShortStay.NextDouble());
                        Double dCreationTime = FonctionsType.getDouble(drRow[iPaxCreationTime]);
                        Double dOccupation = /*dCreationTime -*/ (FonctionsType.getDouble(sOccupation) + interval * rdSpreadStay.NextDouble());
                        if (dOccupation < 0)
                            dOccupation = 0;

                        Double dSTD = OverallTools.DataFunctions.MinuteDifference(dtBeginDate, difiInformations[FlightID].Time);
                        dOccupation = dSTD - dOccupation;
                        if (dOccupation < 0)
                            dOccupation = 0;
                        String PRKObject = BagTraceAnalysis.sPersonalParking + "_" + iTerminal.ToString() + "_" + iIndexOut.ToString();


                        lsPRKTrace.Add(iId.ToString() + "\t" + FonctionsType.getString(drRow[iPaxID]) + "\t" + FlightID.ToString() + "\t" + dSTD.ToString() + "\t0\t0\t" + PRKObject + "\t" + dOccupation.ToString() + "\t" + dCreationTime.ToString());
                        iId++;
                    }
                }
                private static void GenerateInitialCars(
                    List<String> lsPRKTrace,
                    DataTable dtInitialState,
                    DataTable dtLongStay,
                    int iSeed,
                    ref int iId)
                {
                    if (dtInitialState == null)
                        return;
                    if (dtLongStay.Rows.Count == 0)
                        return;
                    if (dtInitialState.Rows.Count == 0)
                        return;
                    int iInterval = FonctionsType.getInt(dtLongStay.Rows[0][1]) - FonctionsType.getInt(dtLongStay.Rows[0][0]);
                    Random rdLongStay = new Random(iSeed + 1);
                    Random rdSpreadStay = new Random(iSeed + 2);
                    for (int iLigne = 0; iLigne < dtInitialState.Rows.Count; iLigne++)
                    {

                        #region We find the distribution columns and treat the information about the current parking object we need to use for the specidied Parking
                        String sName = dtInitialState.Rows[iLigne][0].ToString();
                        String sObjetName = sName.Substring(0, sName.IndexOf('(') - 1);
                        sName = sName.Substring(sName.IndexOf('(') + 1);
                        sName = sName.Substring(0, sName.LastIndexOf(')'));
                        int iColumn = dtLongStay.Columns.IndexOf(sName);

                        if (iColumn == -1)
                        {
                            iColumn = 2;
                        }
                        int[] tiObjetType = OverallTools.DataFunctions.AnalyzeGroupName(sObjetName);
                        if (tiObjetType == null)
                            continue;
                        if (tiObjetType.Length != 4)
                            continue;
                        String PRKObject = BagTraceAnalysis.sPersonalParking + "_" + tiObjetType[0] + "_" + tiObjetType[3];
                        #endregion

                        int iNumberOfcars = FonctionsType.getInt(dtInitialState.Rows[iLigne][1]);
                        for (int iCars = 1; iCars <= iNumberOfcars; iCars++)
                        {
                            String sTime = PaxPlanClass.getNombreBaggageVisitorsTransferTime(iColumn, dtLongStay, 0, rdLongStay.NextDouble());
                            Double dOccupation = FonctionsType.getDouble(sTime) + iInterval * rdSpreadStay.NextDouble();
                            lsPRKTrace.Add(iId.ToString() + "\t0\0\t0\t0\t0\t0\t" + PRKObject + "\t0\t" + dOccupation.ToString());
                            iId++;
                        }
                    }
                }
            }
            #endregion //SGE-26/03/2012-End

            // << Task #9260 Pax2Sim - Static Analysis - EBS algorithm - EBS per Terminal            
            #region new FPD EBS Calculation
            internal static List<DataTable> CalcEBSNeeds(DataTable dtFlightPlans,
                DataManagement.NormalTable dtLoadFactors,
                DataManagement.NormalTable dtAircraftType,
                DataManagement.NormalTable dtShowUpProfile,
                DataManagement.NormalTable dtICTTable,  // << Task #9117 Pax2Sim - Static Analysis - FPD_EBS calculation - transfering pax missing
                DataManagement.NormalTable dtOCTCheckIn,
                DataManagement.NormalTable dtNbBags,
                DataManagement.NormalTable dtOCTMakeUp,
                // << Task #9172 Pax2Sim - Static Analysis - EBS algorithm - Input/Output Rates
                DataTable dtEBSInputRateTable,
                DataTable dtEBSOutputRateTable,
                // >> Task #9172 Pax2Sim - Static Analysis - EBS algorithm - Input/Output Rates
                DataTable dtFlightCategories,
                DateTime dtBegin,
                DateTime dtEnd,
                Double dStepAnalysis,
                Double dStepCumul,
                bool bUseStatisticStep,
                Double dStatisticStep,
                String sStatisticMode,
                ArrayList ListeErreurs,
                int seed,   // >> Bug #11859 PAx2Sim - Static analysis - EBS calculation FB exception
                List<FlightConfiguration> userDefinedFlightConfigurations)
            {
                int i, j;
                #region We check for empty tables and wrong parameters
                if (dtFlightPlans.Rows.Count == 0)
                {
                    ListeErreurs.Add("Err00400 : Unable to calc the static results. The flight plan table for departures must contain a row.");
                    return null;
                }
                if (dtFlightCategories.Rows.Count == 0)
                {
                    ListeErreurs.Add("Err00402 : Unable to calc the static results. There is no defined flight categories.");
                    return null;
                }

                // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                if (dtBegin >= dtEnd)
                {
                    ListeErreurs.Add("Unable to calculate the static results. Please review the time interval set for the simultation.(Begin and End dates)");
                    return null;
                }
                // >> Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns

                // << Task #9260 Pax2Sim - Static Analysis - EBS algorithm - EBS per Terminal
                if (dtEBSInputRateTable == null || dtEBSInputRateTable.Rows.Count == 0)
                {
                    ListeErreurs.Add("Unable to calculate the static results. The EBS Input Rate table has a wrong format.");
                }
                if (dtEBSOutputRateTable == null || dtEBSOutputRateTable.Rows.Count == 0)
                {
                    ListeErreurs.Add("Unable to calculate the static results. The EBS Output Rate table has a wrong format.");
                }
                // >> Task #9260 Pax2Sim - Static Analysis - EBS algorithm - EBS per Terminal

                DataManagement.ExceptionTable etLoadFactors;
                if (dtLoadFactors is DataManagement.ExceptionTable)
                    etLoadFactors = (DataManagement.ExceptionTable)dtLoadFactors;
                else
                    return null;

                DataManagement.ExceptionTable etAircraftType;
                if (dtAircraftType is DataManagement.ExceptionTable)
                    etAircraftType = (DataManagement.ExceptionTable)dtAircraftType;
                else
                    return null;

                DataManagement.ExceptionTable etShowUpProfile;
                if (dtShowUpProfile is DataManagement.ExceptionTable)
                    etShowUpProfile = (DataManagement.ExceptionTable)dtShowUpProfile;
                else
                    return null;

                // << Task #9117 Pax2Sim - Static Analysis - FPD_EBS calculation - transfering pax missing
                DataManagement.ExceptionTable etICTExceptionTable;
                if (dtICTTable is DataManagement.ExceptionTable)
                    etICTExceptionTable = (DataManagement.ExceptionTable)dtICTTable;
                else
                    return null;
                // >> Task #9117 Pax2Sim - Static Analysis - FPD_EBS calculation - transfering pax missing

                DataManagement.ExceptionTable etOCTCheckIn;
                if (dtOCTCheckIn is DataManagement.ExceptionTable)
                    etOCTCheckIn = (DataManagement.ExceptionTable)dtOCTCheckIn;
                else
                    return null;

                DataManagement.ExceptionTable etNbBags;
                if (dtNbBags is DataManagement.ExceptionTable)
                    etNbBags = (DataManagement.ExceptionTable)dtNbBags;
                else
                    return null;

                DataManagement.ExceptionTable etOCTMakeUp;
                if (dtOCTMakeUp is DataManagement.ExceptionTable)
                    etOCTMakeUp = (DataManagement.ExceptionTable)dtOCTMakeUp;
                else
                    return null;

                if ((dtBegin > dtEnd) /*|| (dtBegin.AddDays(7)<dtEnd)*/)
                {
                    ListeErreurs.Add("Err00406 : Unable to calc the static results. The dates are not valids.");
                    return null;
                }
                if ((dStepAnalysis < 1) || (dStepAnalysis > 60))
                {
                    ListeErreurs.Add("Err00407 : Unable to calc the static results. The analysis step is not valid.");
                    return null;
                }
                if ((dStepCumul < 1) || (dStepCumul > 60))
                {
                    ListeErreurs.Add("Err00408 : Unable to calc the static results. The analysis step is not valid.");
                    return null;
                }
                int iIndexID = dtFlightPlans.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID);
                int iIndexFlightNb = dtFlightPlans.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightN);
                int iIndexAirline = dtFlightPlans.Columns.IndexOf(GlobalNames.sFPD_A_Column_AirlineCode);
                int iIndexFC = dtFlightPlans.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightCategory);
                int iIndexDate = dtFlightPlans.Columns.IndexOf(GlobalNames.sFPD_A_Column_DATE);
                int iIndexTime = dtFlightPlans.Columns.IndexOf(GlobalNames.sFPD_Column_STD);
                if ((iIndexID == -1) ||
                    (iIndexAirline == -1) ||
                    (iIndexFC == -1) ||
                    (iIndexDate == -1) ||
                    (iIndexTime == -1))
                {
                    return null;
                }
                #endregion

                // << Task #9260 Pax2Sim - Static Analysis - EBS algorithm - EBS per Terminal                
                #region EBS Input / Output Rates tables
                int ebsInputNbOfTerminals = dtEBSInputRateTable.Columns.Count;
                int ebsOutputNbOfTerminals = dtEBSOutputRateTable.Columns.Count;
                int nbOfTerminals = Math.Max(ebsInputNbOfTerminals, ebsOutputNbOfTerminals);
                #endregion
                // >> Task #9260 Pax2Sim - Static Analysis - EBS algorithm - EBS per Terminal

                #region The results table for the analysis
                Dictionary<int, DataTable> ebsTablesDictionary = new Dictionary<int, DataTable>();
                Dictionary<int, DataTable> ebsSummariesTablesDictionary = new Dictionary<int, DataTable>();
                Dictionary<int, DataTable> ebsIssuesTablesDictionary = new Dictionary<int, DataTable>();
                Dictionary<int, List<EbsIssue>> ebsIssuesByTerminalDictionary = new Dictionary<int, List<EbsIssue>>();

                for (int k = 0; k < nbOfTerminals; k++)
                {
                    String tableName = "FPD_EBS_Rolling_Terminal_" + k.ToString();  // >> Task #13761 Pax2Sim - Static Analysis - Instant and Smoothed calculations
                    DataTable ebsTable = createEBSTable(tableName);
                    OverallTools.DataFunctions.initialiserLignes(ebsTable, dtBegin, dtEnd, dStepAnalysis);

                    for (j = 0; j < ebsTable.Rows.Count; j++)
                    {
                        for (i = 1; i < ebsTable.Columns.Count; i++)
                            ebsTable.Rows[j][i] = 0.0d;
                    }
                    ebsTablesDictionary.Add(k, ebsTable);

                    // >> Task #9171 Pax2Sim - Static Analysis - EBS algorithm - Throughputs C#5
                    string summaryTableName = EbsStatisticsGenerator.GLOBAL_EBS_SUMMARY_TABLE_NAME + "_Terminal_" + k.ToString();
                    DataTable summaryTable = EbsStatisticsGenerator.getEbsSummaryTableStructure(summaryTableName);
                    ebsSummariesTablesDictionary.Add(k, summaryTable);

                    string issuesTableName = "FPD_EBS_Issues_Terminal_" + k.ToString();
                    DataTable issuesTable = EbsLogger.createEbsIssuesTableStructure(issuesTableName);
                    ebsIssuesTablesDictionary.Add(k, issuesTable);
                    ebsIssuesByTerminalDictionary.Add(k, new List<EbsIssue>());
                    // << Task #9171 Pax2Sim - Static Analysis - EBS algorithm - Throughputs C#5

                    //add the ebs terminal table to the list of static results
                    bool tableAlreadyExistsInList = false;
                    foreach (string s in GestionDonneesHUB2SIM.StaticResultsFPD)
                    {
                        if (s.Equals(tableName))
                            tableAlreadyExistsInList = true;
                    }
                    if (!tableAlreadyExistsInList)
                    {
                        Array.Resize(ref GestionDonneesHUB2SIM.StaticResultsFPD, GestionDonneesHUB2SIM.StaticResultsFPD.Length + 1);
                        int index = GestionDonneesHUB2SIM.StaticResultsFPD.Length - 1;
                        GestionDonneesHUB2SIM.StaticResultsFPD[index] = tableName;
                    }
                    // >> Task #9171 Pax2Sim - Static Analysis - EBS algorithm - Throughputs C#5
                    tableAlreadyExistsInList = false;
                    foreach (string s in GestionDonneesHUB2SIM.StaticResultsFPD)
                    {
                        if (s.Equals(summaryTableName))
                            tableAlreadyExistsInList = true;
                    }
                    if (!tableAlreadyExistsInList)
                    {
                        Array.Resize(ref GestionDonneesHUB2SIM.StaticResultsFPD, GestionDonneesHUB2SIM.StaticResultsFPD.Length + 1);
                        int index = GestionDonneesHUB2SIM.StaticResultsFPD.Length - 1;
                        GestionDonneesHUB2SIM.StaticResultsFPD[index] = summaryTableName;
                    }

                    tableAlreadyExistsInList = false;
                    foreach (string s in GestionDonneesHUB2SIM.StaticResultsFPD)
                    {
                        if (s.Equals(issuesTableName))
                            tableAlreadyExistsInList = true;
                    }
                    if (!tableAlreadyExistsInList)
                    {
                        Array.Resize(ref GestionDonneesHUB2SIM.StaticResultsFPD, GestionDonneesHUB2SIM.StaticResultsFPD.Length + 1);
                        int index = GestionDonneesHUB2SIM.StaticResultsFPD.Length - 1;
                        GestionDonneesHUB2SIM.StaticResultsFPD[index] = issuesTableName;
                    }
                    // << Task #9171 Pax2Sim - Static Analysis - EBS algorithm - Throughputs C#5
                }

                DataTable dtFPD_EBSSmoothed = createEBSTable(GlobalNames.FPD_EBS_ROLLING_TABLE_NAME);

                // << Task #9171 Pax2Sim - Static Analysis - EBS algorithm - Throughputs

                int indexColumnInput = dtFPD_EBSSmoothed.Columns.IndexOf(GlobalNames.FPD_EBS_INPUT_COLUMN_NAME);
                int indexColumnThroughputInput = dtFPD_EBSSmoothed.Columns.IndexOf(GlobalNames.FPD_EBS_THROUGHPUT_INPUT_COLUMN_NAME);
                int indexColumnOutput = dtFPD_EBSSmoothed.Columns.IndexOf(GlobalNames.FPD_EBS_OUTPUT_COLUMN_NAME);
                int indexColumnThroughputOutput = dtFPD_EBSSmoothed.Columns.IndexOf(GlobalNames.FPD_EBS_THROUGHPUT_OUTPUT_COLUMN_NAME);
                int indexColumnTotal = dtFPD_EBSSmoothed.Columns.IndexOf(GlobalNames.FPD_EBS_CONSTRAINED_COLUMN_NAME);
                // >> Task #9171 Pax2Sim - Static Analysis - EBS algorithm - Throughputs
                #endregion



                #region Pour la répartition suivant les parkings.

                int iIndexTerminalMup = dtFlightPlans.Columns.IndexOf(GlobalNames.sFPD_Column_TerminalMup);
                int iIndexStartMup = dtFlightPlans.Columns.IndexOf(GlobalNames.sFPD_Column_Eco_Mup_Start);
                int iIndexEndMup = dtFlightPlans.Columns.IndexOf(GlobalNames.sFPD_Column_Eco_Mup_End);
                int iIndexStartMupFB = dtFlightPlans.Columns.IndexOf(GlobalNames.sFPD_Column_First_Mup_Start);
                int iIndexEndMupFB = dtFlightPlans.Columns.IndexOf(GlobalNames.sFPD_Column_First_Mup_End);

                int iNbTerminal = 0;
                if ((iIndexStartMup != -1) && (iIndexTerminalMup != -1) && (iIndexEndMup != -1) && (iIndexStartMupFB != -1) && (iIndexEndMupFB != -1))
                    iNbTerminal = DataFunctions.valeurMaximaleDansColonne(dtFlightPlans, iIndexTerminalMup);

                // << Task #9171 Pax2Sim - Static Analysis - EBS algorithm - Throughputs
                //ebsTable.Columns.Add("Unknow Terminal", System.Type.GetType("System.Double"));
                //dtFPD_EBSSmoothed.Columns.Add(GlobalNames.FPD_EBS_UNKNOWN_TERMINAL_COLUMN_NAME, System.Type.GetType("System.Double"));
                //int indexColumnUnknownTerminal = dtFPD_EBSSmoothed.Columns.IndexOf(GlobalNames.FPD_EBS_UNKNOWN_TERMINAL_COLUMN_NAME);
                // >> Task #9171 Pax2Sim - Static Analysis - EBS algorithm - Throughputs
                /*
                for (i = 1; i <= iNbTerminal; i++)
                {
                    dtFPD_EBSSmoothed.Columns.Add("Terminal " + i.ToString(), System.Type.GetType("System.Double"));
                }
                */
                #endregion

                #region Initialize the tables
                OverallTools.DataFunctions.initialiserLignes(dtFPD_EBSSmoothed, dtBegin, dtEnd, dStepAnalysis);

                for (j = 0; j < dtFPD_EBSSmoothed.Rows.Count; j++)
                {
                    for (i = 1; i < dtFPD_EBSSmoothed.Columns.Count; i++)
                        dtFPD_EBSSmoothed.Rows[j][i] = 0.0d;
                }
                #endregion

                #region Les différentes ArrayList qui permettront de gérer les distributions and the order of the flight categories
                ArrayList alPaxPerFlight = new ArrayList();
                Hashtable htFlightPerFC = new Hashtable();
                Hashtable htPaxPerFC = new Hashtable();
                Hashtable htBagsPerFC = new Hashtable();

                String[] tsFlightCategoriesOrder = new String[dtFlightCategories.Rows.Count];
                DataTable dtTmp = dtOCTCheckIn.Table;
                for (i = 1; i < dtTmp.Columns.Count; i++)
                {
                    String sColumnName = dtTmp.Columns[i].ColumnName;
                    tsFlightCategoriesOrder[i - 1] = sColumnName;
                }
                #endregion

                computeEBSResultsPerTerminal(ebsTablesDictionary, ebsIssuesByTerminalDictionary, iIndexID, iIndexFlightNb, iIndexDate, iIndexTime, dtBegin, dtEnd, iIndexFC,
                    iIndexAirline, etOCTCheckIn, etOCTMakeUp, etShowUpProfile, etICTExceptionTable, etAircraftType, etLoadFactors,
                    etNbBags, dStepAnalysis, dStepCumul, dtFlightCategories, dtFlightPlans, dtEBSInputRateTable, dtEBSOutputRateTable,
                    iIndexTerminalMup, ListeErreurs, seed, userDefinedFlightConfigurations); // >> Bug #11859 PAx2Sim - Static analysis - EBS calculation FB exception

                //fill the FPD_EBS table from the tables segregated by terminal
                foreach (KeyValuePair<int, DataTable> pair in ebsTablesDictionary)
                {
                    DataTable ebsSegregatedTable = pair.Value;
                    if (ebsSegregatedTable != null
                        && ebsSegregatedTable.Rows.Count == dtFPD_EBSSmoothed.Rows.Count)
                    {
                        int indexColumnInputDemandForSegregation = ebsSegregatedTable.Columns.IndexOf(GlobalNames.FPD_EBS_INPUT_DEMAND_COLUMN_NAME);
                        int indexColumnInputOverflowForSegregation = ebsSegregatedTable.Columns.IndexOf(GlobalNames.FPD_EBS_INPUT_OVERFLOW_COLUMN_NAME);
                        int indexColumnInputForSegregation = ebsSegregatedTable.Columns.IndexOf(GlobalNames.FPD_EBS_INPUT_COLUMN_NAME);

                        int indexColumnOutputDemandForSegrgation = ebsSegregatedTable.Columns.IndexOf(GlobalNames.FPD_EBS_OUTPUT_DEMAND_COLUMN_NAME);
                        int indexColumnOutputBacklogForSegrgation = ebsSegregatedTable.Columns.IndexOf(GlobalNames.FPD_EBS_OUTPUT_BACKLOG_COLUMN_NAME);
                        int indexColumnOutputForSegrgation = ebsSegregatedTable.Columns.IndexOf(GlobalNames.FPD_EBS_OUTPUT_COLUMN_NAME);

                        int indexColumnTotalForSegregation = ebsSegregatedTable.Columns.IndexOf(GlobalNames.FPD_EBS_CONSTRAINED_COLUMN_NAME);
                        int indexColumnTheoreticalOccupationForSegregation = ebsSegregatedTable.Columns.IndexOf(GlobalNames.FPD_EBS_UNCONSTRAINED_OCCUPATION_COLUMN_NAME);

                        for (int r = 0; r < dtFPD_EBSSmoothed.Rows.Count; r++)
                        {
                            if (indexColumnInputDemandForSegregation != -1)
                            {
                                dtFPD_EBSSmoothed.Rows[r][indexColumnInputDemandForSegregation] = (Double)dtFPD_EBSSmoothed.Rows[r][indexColumnInputDemandForSegregation]
                                    + (Double)ebsSegregatedTable.Rows[r][indexColumnInputDemandForSegregation];
                            }
                            if (indexColumnInputOverflowForSegregation != -1)
                            {
                                dtFPD_EBSSmoothed.Rows[r][indexColumnInputOverflowForSegregation] = (Double)dtFPD_EBSSmoothed.Rows[r][indexColumnInputOverflowForSegregation]
                                    + (Double)ebsSegregatedTable.Rows[r][indexColumnInputOverflowForSegregation];
                            }
                            if (indexColumnInputForSegregation != -1)
                            {
                                dtFPD_EBSSmoothed.Rows[r][indexColumnInput] = (Double)dtFPD_EBSSmoothed.Rows[r][indexColumnInput]
                                    + (Double)ebsSegregatedTable.Rows[r][indexColumnInputForSegregation];
                            }

                            if (indexColumnOutputDemandForSegrgation != -1)
                            {
                                dtFPD_EBSSmoothed.Rows[r][indexColumnOutputDemandForSegrgation] = (Double)dtFPD_EBSSmoothed.Rows[r][indexColumnOutputDemandForSegrgation]
                                    + (Double)ebsSegregatedTable.Rows[r][indexColumnOutputDemandForSegrgation];
                            }
                            if (indexColumnOutputBacklogForSegrgation != -1)
                            {
                                dtFPD_EBSSmoothed.Rows[r][indexColumnOutputBacklogForSegrgation] = (Double)dtFPD_EBSSmoothed.Rows[r][indexColumnOutputBacklogForSegrgation]
                                    + (Double)ebsSegregatedTable.Rows[r][indexColumnOutputBacklogForSegrgation];
                            }
                            if (indexColumnOutputForSegrgation != -1)
                            {
                                dtFPD_EBSSmoothed.Rows[r][indexColumnOutput] = (Double)dtFPD_EBSSmoothed.Rows[r][indexColumnOutput]
                                    + (Double)ebsSegregatedTable.Rows[r][indexColumnOutputForSegrgation];
                            }

                            if (indexColumnTotalForSegregation != -1)
                            {
                                dtFPD_EBSSmoothed.Rows[r][indexColumnTotal] = (Double)dtFPD_EBSSmoothed.Rows[r][indexColumnTotal]
                                    + (Double)ebsSegregatedTable.Rows[r][indexColumnTotalForSegregation];
                            }
                            if (indexColumnTheoreticalOccupationForSegregation != -1)
                            {
                                dtFPD_EBSSmoothed.Rows[r][indexColumnTheoreticalOccupationForSegregation]
                                    = (Double)dtFPD_EBSSmoothed.Rows[r][indexColumnTheoreticalOccupationForSegregation]
                                        + (Double)ebsSegregatedTable.Rows[r][indexColumnTheoreticalOccupationForSegregation];
                            }
                        }
                    }
                }

                // << Task #9171 Pax2Sim - Static Analysis - EBS algorithm - Throughputs                
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtFPD_EBSSmoothed, indexColumnInput, indexColumnThroughputInput,
                    dStepAnalysis, dStepCumul);
                ResultFunctions.AnalyzePeak_SlidingHourDouble(dtFPD_EBSSmoothed, indexColumnOutput, indexColumnThroughputOutput,
                    dStepAnalysis, dStepCumul);
                // >> Task #9171 Pax2Sim - Static Analysis - EBS algorithm - Throughputs

                foreach (DataRow Ligne in dtFPD_EBSSmoothed.Rows)
                {
                    if (Ligne[0].ToString().Length == 0) continue;
                    for (i = 1; i < dtFPD_EBSSmoothed.Columns.Count; i++)
                        Ligne[i] = Math.Round((Double)Ligne[i], 2);
                }

                // >> Task #9171 Pax2Sim - Static Analysis - EBS algorithm - Throughputs C#5
                DataTable globalSummaryTable = EbsStatisticsGenerator.getEbsSummaryTableStructure(EbsStatisticsGenerator.GLOBAL_EBS_SUMMARY_TABLE_NAME);
                if (dtFPD_EBSSmoothed.Columns.Count >= 11)
                {
                    DataTable statsTable = OverallTools.DataFunctions.GetStatTable(dtFPD_EBSSmoothed, new int[10] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 });
                    List<EbsSummaryKpi> kpis = EbsStatisticsGenerator.getEbsSummaryKpis(statsTable);
                    EbsStatisticsGenerator.addKpisToEbsSummaryTable(globalSummaryTable, kpis);
                }
                else
                {
                    OverallTools.ExternFunctions.PrintLogFile("Error while generating the EBS summary table \"" + dtFPD_EBSSmoothed.TableName
                            + "\". The summary table doesn't contain the required number of columns.");
                }
                foreach (KeyValuePair<int, DataTable> pair in ebsTablesDictionary)
                {
                    DataTable ebsSegregatedTable = pair.Value;
                    if (!ebsSummariesTablesDictionary.ContainsKey(pair.Key) || ebsSegregatedTable == null)
                    {
                        continue;
                    }
                    DataTable ebsSummaryTable = ebsSummariesTablesDictionary[pair.Key];
                    if (ebsSegregatedTable.Columns.Count >= 11)
                    {

                        DataTable segregatedStatsTable = OverallTools.DataFunctions.GetStatTable(ebsSegregatedTable, new int[10] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 });
                        List<EbsSummaryKpi> segregatedKpis = EbsStatisticsGenerator.getEbsSummaryKpis(segregatedStatsTable);
                        EbsStatisticsGenerator.addKpisToEbsSummaryTable(ebsSummaryTable, segregatedKpis);
                    }
                    else
                    {
                        OverallTools.ExternFunctions.PrintLogFile("Error while generating the EBS summary table \"" + ebsSummaryTable.TableName
                            + "\". The summary table doesn't contain the required number of columns.");
                    }
                }

                List<EbsIssue> allEbsIssues = new List<EbsIssue>();
                Dictionary<string, EbsFlightStatistics> ebsFlightStatistics = new Dictionary<string, EbsFlightStatistics>();
                foreach (KeyValuePair<int, DataTable> pair in ebsIssuesTablesDictionary)
                {
                    int terminalNb = pair.Key;
                    if (!ebsIssuesByTerminalDictionary.ContainsKey(terminalNb))
                    {
                        continue;
                    }
                    DataTable ebsIssuesTable = pair.Value;
                    List<EbsIssue> ebsIssues = ebsIssuesByTerminalDictionary[terminalNb];
                    ebsFlightStatistics = EbsStatisticsGenerator.getEbsIssuesStatistics(ebsIssues);
                    EbsLogger.fillEbsIssuesTable(ebsIssuesTable, ebsFlightStatistics);
                    allEbsIssues.AddRange(ebsIssues.ToArray());
                }
                DataTable globalEbsIssuesTable = EbsLogger.createEbsIssuesTableStructure(EbsLogger.GLOBAL_EBS_ISSUES_TABLE_NAME);
                ebsFlightStatistics = EbsStatisticsGenerator.getEbsIssuesStatistics(allEbsIssues);
                EbsLogger.fillEbsIssuesTable(globalEbsIssuesTable, ebsFlightStatistics);
                // << Task #9171 Pax2Sim - Static Analysis - EBS algorithm - Throughputs C#5

                List<DataTable> ldtTmp = new List<DataTable>();
                ldtTmp.Add(dtFPD_EBSSmoothed);
                foreach (KeyValuePair<int, DataTable> pair in ebsTablesDictionary)
                {
                    ldtTmp.Add(pair.Value);
                }

                ldtTmp.Add(globalSummaryTable);
                foreach (KeyValuePair<int, DataTable> pair in ebsSummariesTablesDictionary)    // >> Task #9171 Pax2Sim - Static Analysis - EBS algorithm - Throughputs C#5
                {
                    ldtTmp.Add(pair.Value);
                }

                ldtTmp.Add(globalEbsIssuesTable);
                foreach (KeyValuePair<int, DataTable> pair in ebsIssuesTablesDictionary)    // >> Task #9171 Pax2Sim - Static Analysis - EBS algorithm - Throughputs C#5
                {
                    ldtTmp.Add(pair.Value);
                }
                return ldtTmp;
            }

            private static DataTable createEBSTable(String tableName)
            {
                DataTable ebsTable = new DataTable(tableName);

                ebsTable.Columns.Add(GlobalNames.FPD_EBS_TIME_COLUMN_NAME, System.Type.GetType("System.DateTime"));
                ebsTable.Columns.Add(GlobalNames.FPD_EBS_INPUT_DEMAND_COLUMN_NAME, System.Type.GetType("System.Double"));
                ebsTable.Columns.Add(GlobalNames.FPD_EBS_INPUT_OVERFLOW_COLUMN_NAME, System.Type.GetType("System.Double"));
                ebsTable.Columns.Add(GlobalNames.FPD_EBS_INPUT_COLUMN_NAME, System.Type.GetType("System.Double"));
                ebsTable.Columns.Add(GlobalNames.FPD_EBS_THROUGHPUT_INPUT_COLUMN_NAME, System.Type.GetType("System.Double"));

                ebsTable.Columns.Add(GlobalNames.FPD_EBS_OUTPUT_DEMAND_COLUMN_NAME, System.Type.GetType("System.Double"));
                ebsTable.Columns.Add(GlobalNames.FPD_EBS_OUTPUT_BACKLOG_COLUMN_NAME, System.Type.GetType("System.Double"));
                ebsTable.Columns.Add(GlobalNames.FPD_EBS_OUTPUT_COLUMN_NAME, System.Type.GetType("System.Double"));
                ebsTable.Columns.Add(GlobalNames.FPD_EBS_THROUGHPUT_OUTPUT_COLUMN_NAME, System.Type.GetType("System.Double"));

                ebsTable.Columns.Add(GlobalNames.FPD_EBS_CONSTRAINED_COLUMN_NAME, System.Type.GetType("System.Double"));
                ebsTable.Columns.Add(GlobalNames.FPD_EBS_UNCONSTRAINED_OCCUPATION_COLUMN_NAME, System.Type.GetType("System.Double"));

                return ebsTable;
            }

            // >> Bug #11859 PAx2Sim - Static analysis - EBS calculation FB exception
            private static DataTable sumValuesByPaxClassPercent_(DataTable ecoTable, DataTable fbTable, int columnIndex, double ecoPercentage, double fbPercentage)
            {
                if (ecoTable == null || fbTable == null || columnIndex < 0
                    || ecoTable.Columns.Count - 1 < columnIndex || fbTable.Columns.Count - 1 < columnIndex)
                {
                    return null;
                }

                DataTable resultTable = ecoTable.Copy();

                int rowNb = 0;
                foreach (DataRow row in resultTable.Rows)
                {
                    double ecoValue = 0;
                    double fbValue = 0;

                    if (ecoTable.Rows.Count > rowNb && fbTable.Rows.Count > rowNb
                        && ecoTable.Rows[rowNb][columnIndex] != null && Double.TryParse(ecoTable.Rows[rowNb][columnIndex].ToString(), out ecoValue)
                        && fbTable.Rows[rowNb][columnIndex] != null && Double.TryParse(fbTable.Rows[rowNb][columnIndex].ToString(), out fbValue))
                    {
                        row[columnIndex] = ecoValue * ecoPercentage + fbValue * fbPercentage;
                    }
                    rowNb++;
                }

                resultTable.AcceptChanges();
                return resultTable;
            }

            private static DataTable sumValuesByPaxClassPercent(DataTable ecoTable, DataTable fbTable,
                int ecoColumnIndex, int fbColumnIndex, double ecoPercentage, double fbPercentage, out bool useEcoAsBasis)
            {
                useEcoAsBasis = true;
                if (ecoTable == null || fbTable == null || ecoColumnIndex < 0 || fbColumnIndex < 0
                    || ecoTable.Columns.Count - 1 < ecoColumnIndex || fbTable.Columns.Count - 1 < fbColumnIndex)
                {
                    return null;
                }

                DataTable resultTable = ecoTable.Copy();

                if (ecoTable.Rows.Count < fbTable.Rows.Count)
                {
                    resultTable = fbTable.Copy();
                    useEcoAsBasis = false;
                }

                int rowNb = 0;
                foreach (DataRow row in resultTable.Rows)
                {
                    double ecoValue = 0;
                    double fbValue = 0;

                    if (ecoTable.Rows.Count > rowNb && ecoTable.Rows[rowNb][ecoColumnIndex] != null)
                    {
                        Double.TryParse(ecoTable.Rows[rowNb][ecoColumnIndex].ToString(), out ecoValue);
                    }
                    if (fbTable.Rows.Count > rowNb && fbTable.Rows[rowNb][fbColumnIndex] != null)
                    {
                        Double.TryParse(fbTable.Rows[rowNb][fbColumnIndex].ToString(), out fbValue);
                    }
                    if (useEcoAsBasis)
                        row[ecoColumnIndex] = ecoValue * ecoPercentage + fbValue * fbPercentage;
                    else
                        row[fbColumnIndex] = ecoValue * ecoPercentage + fbValue * fbPercentage;

                    rowNb++;
                }

                resultTable.AcceptChanges();
                return resultTable;
            }
            // << Bug #11859 PAx2Sim - Static analysis - EBS calculation FB exception

            private static void computeEBSResultsPerTerminal(Dictionary<int, DataTable> ebsTablesDictionary,    // >> Bug #11860 Pax2Sim - Static analysis - EBS calculation FB exception 2
                Dictionary<int, List<EbsIssue>> ebsIssuesByTerminalDictionary, int iIndexID,
                int iIndexFlightNb, int iIndexDate, int iIndexTime, DateTime dtBegin, DateTime dtEnd, int iIndexFC, int iIndexAirline,
                DataManagement.ExceptionTable etOCTCheckIn, DataManagement.ExceptionTable etOCTMakeUp,
                DataManagement.ExceptionTable etShowUpProfile, DataManagement.ExceptionTable etICTExceptionTable,
                DataManagement.ExceptionTable etAircraftType, DataManagement.ExceptionTable etLoadFactors,
                DataManagement.ExceptionTable etNbBags, Double dStepAnalysis, Double dStepCumul,
                DataTable dtFlightCategories, DataTable dtFlightPlans, DataTable dtEBSInputRateTable,
                DataTable dtEBSOutputRateTable, int iIndexTerminalMup, ArrayList ListeErreurs,
                int seed, List<FlightConfiguration> userDefinedFlightConfigurations)
            {
                //K : index for the time slot that contains the surplus output bags / V = list of surplus bag nb (each flight can have an eco or fb bag surplus)
                Dictionary<int, List<double>> outputSurplusDictionary = new Dictionary<int, List<double>>();
                DataTable ebsTable = new DataTable();
                Random randClasse = new Random(seed);

                DataView dv = dtFlightPlans.DefaultView;
                int indexColumnSTD = dtFlightPlans.Columns.IndexOf(GlobalNames.sFPD_Column_STD);
                if (indexColumnSTD != -1)
                {
                    dv.Sort = GlobalNames.sFPD_Column_STD + " asc";
                    dtFlightPlans = dv.ToTable();
                }
                string flightId = "";
                string flightNb = "";
                DateTime flightSTD = DateTime.MinValue;
                string flightCategory = "";
                string airlineCode = "";
                foreach (DataRow ligne in dtFlightPlans.Rows)
                {
                    getFlightInformation(ligne, iIndexID, iIndexFlightNb, iIndexDate, iIndexTime, iIndexFC, iIndexAirline,
                        out flightId, out flightNb, out flightSTD, out flightCategory, out airlineCode);
                    if (flightSTD < dtBegin)
                    {
                        ListeErreurs.Add("Warn00408 : Line ignored \"" + flightId + "\" doesn't match the range");
                        continue;
                    }

                    double fbPaxPercent = 0;
                    double ecoPaxPercent = 0;
                    if (!getPaxClassPercentages(etLoadFactors, flightId, airlineCode, flightCategory, ListeErreurs,
                        out fbPaxPercent, out ecoPaxPercent))
                    {
                        continue;
                    }

                    double originatingEcoPaxNb = 0;
                    double transferEcoPaxNb = 0;
                    double originatingFBPaxNb = 0;
                    double transferFBPaxNb = 0;
                    FlightConfiguration flightConfiguration = Tools.FlightPlanParametersTools.getFlightConfigurationByArrOrDepAndFlightId(FlightAttribute.ARR_OR_DEP_FLIGHT_TAG.D,
                        Convert.ToInt32(flightId), userDefinedFlightConfigurations);
                    if (flightConfiguration != null)
                    {
                        originatingEcoPaxNb = flightConfiguration.flightParameter.nbOrigEcoPax;
                        transferEcoPaxNb = flightConfiguration.flightParameter.nbTransferEcoPax;

                        originatingFBPaxNb = flightConfiguration.flightParameter.nbOrigFbPax;
                        transferFBPaxNb = flightConfiguration.flightParameter.nbTransferFbPax;
                    }
                    else
                    {
                        if (!getNumberOfPassengers(ligne, etAircraftType, etLoadFactors, dtFlightCategories, flightId, airlineCode, flightCategory, ListeErreurs,
                            ecoPaxPercent, fbPaxPercent, out originatingEcoPaxNb, out transferEcoPaxNb, out originatingFBPaxNb, out transferFBPaxNb))
                        {
                            continue;
                        }
                    }

                    double averageNbEcoBags = -1;
                    double averageNbFBBags = -1;
                    if (flightConfiguration != null)
                    {
                        double totalNbEcoPax = originatingEcoPaxNb + transferEcoPaxNb;
                        double totalNbEcoBags = flightConfiguration.flightParameter.nbOrigEcoBags + flightConfiguration.flightParameter.nbTransferEcoBags;
                        if (totalNbEcoPax == 0)
                        {
                            averageNbEcoBags = 0;
                        }
                        else
                        {
                            averageNbEcoBags = totalNbEcoBags / totalNbEcoPax;
                        }
                        double totalNbFbPax = originatingFBPaxNb + transferFBPaxNb;
                        double totalNbFbBags = flightConfiguration.flightParameter.nbOrigFbBags + flightConfiguration.flightParameter.nbTransferFbBags;
                        if (totalNbFbPax == 0)
                        {
                            averageNbFBBags = 0;
                        }
                        else
                        {
                            averageNbFBBags = totalNbFbBags / totalNbFbPax;
                        }
                    }
                    else
                    {
                        if (!getAverageNbBags(etNbBags, flightId, airlineCode, flightCategory, ECO_PAX_CLASS, ListeErreurs, out averageNbEcoBags))
                            continue;
                        if (etNbBags.ExceptionFB != null || etNbBags.ExceptionAirlineFB != null || etNbBags.ExceptionFlightFB != null)
                        {
                            if (!getAverageNbBags(etNbBags, flightId, airlineCode, flightCategory, FB_PAX_CLASS, ListeErreurs, out averageNbFBBags))
                                continue;
                        }
                    }
                    double ecoCheckInOpeningMinute = -1;
                    double ecoCheckInClosingMinute = -1;
                    if (!getCheckInOpeningClosingMinutes(etOCTCheckIn, flightId, airlineCode, flightCategory, ECO_PAX_CLASS,
                        out ecoCheckInOpeningMinute, out ecoCheckInClosingMinute))
                    {
                        continue;
                    }
                    double fbCheckInOpeningMinute = -1;
                    double fbCheckInClosingMinute = -1;
                    if (etOCTCheckIn.ExceptionFB != null || etOCTCheckIn.ExceptionAirlineFB != null || etOCTCheckIn.ExceptionFlightFB != null)
                    {
                        if (!getCheckInOpeningClosingMinutes(etOCTCheckIn, flightId, airlineCode, flightCategory, FB_PAX_CLASS,
                            out fbCheckInOpeningMinute, out fbCheckInClosingMinute))
                        {
                            continue;
                        }
                    }

                    //Make-up doesn't support FB exceptions
                    double mupOpeningMinute = 0;
                    double ebsDeliveryStartMinute = 0;
                    double mupClosingMinute = 0;
                    if (!getMakeUpInformation(etOCTMakeUp, flightId, airlineCode, flightCategory, ECO_PAX_CLASS,
                        out mupOpeningMinute, out ebsDeliveryStartMinute, out mupClosingMinute))
                    {
                        continue;
                    }

                    DataTable dtEcoShowUp = null;
                    int showUpEcoColumnIndex = -1;
                    DataTable dtFBShowUp = null;
                    int showUpFBColumnIndex = -1;
                    int firstEcoOrigPaxMinute = 0;
                    int lastEcoOrigPaxMinute = 0;
                    int firstFBOrigPaxMinute = 0;
                    int lastFBOrigPaxMinute = 0;
                    if (!getFirstLastOrigPaxMinute(etShowUpProfile, flightId, airlineCode, flightCategory, ECO_PAX_CLASS, ListeErreurs,
                        out firstEcoOrigPaxMinute, out lastEcoOrigPaxMinute, out dtEcoShowUp, out showUpEcoColumnIndex))
                    {
                        continue;
                    }
                    if (etShowUpProfile.ExceptionFB != null || etShowUpProfile.ExceptionAirlineFB != null || etShowUpProfile.ExceptionFlightFB != null)
                    {
                        if (!getFirstLastOrigPaxMinute(etShowUpProfile, flightId, airlineCode, flightCategory, FB_PAX_CLASS, ListeErreurs,
                            out firstFBOrigPaxMinute, out lastFBOrigPaxMinute, out dtFBShowUp, out showUpFBColumnIndex))
                        {
                            continue;
                        }
                    }
                    DataTable dtEcoICT = null;
                    int ictEcoColumnIndex = -1;
                    DataTable dtFBICT = null;
                    int ictFBColumnIndex = -1;
                    int firstEcoTransfPaxMinute = 0;
                    int lastEcoTransfPaxMinute = 0;
                    int firstFBTransfPaxMinute = 0;
                    int lastFBTransfPaxMinute = 0;
                    if (!getFirstLastTransferPaxMinute(etICTExceptionTable, flightId, airlineCode, flightCategory, ECO_PAX_CLASS, ListeErreurs,
                        out firstEcoTransfPaxMinute, out lastEcoTransfPaxMinute, out dtEcoICT, out ictEcoColumnIndex))
                    {
                        continue;
                    }
                    if (etICTExceptionTable.ExceptionFB != null || etICTExceptionTable.ExceptionAirlineFB != null || etICTExceptionTable.ExceptionFlightFB != null)
                    {
                        if (!getFirstLastTransferPaxMinute(etICTExceptionTable, flightId, airlineCode, flightCategory, FB_PAX_CLASS, ListeErreurs,
                              out firstFBTransfPaxMinute, out lastFBTransfPaxMinute, out dtFBICT, out ictFBColumnIndex))
                        {
                            continue;
                        }
                    }

                    int mupTerminal = FonctionsType.getInt(ligne[iIndexTerminalMup]);
                    double inputRatePerMinute = getNbBagHandledPerMinute(mupTerminal, dtEBSInputRateTable, out mupTerminal);
                    double outputRatePerMinute = getNbBagHandledPerMinute(mupTerminal, dtEBSOutputRateTable, out mupTerminal);
                    if (ebsTablesDictionary.TryGetValue(mupTerminal, out ebsTable))
                    {
                        List<EbsIssue> ebsIssues = new List<EbsIssue>();    // >> Task #9171 Pax2Sim - Static Analysis - EBS algorithm - Throughputs C#5
                        int ecoOutputSurplusIndex = -1;
                        double ecoOutputSurplusBags = -1;
                        int fbOutputSurplusIndex = -1;
                        double fbOutputSurplusBags = -1;

                        bool ecoPaxProcessed = updateEBSTable(false, dtBegin, dtEnd, ebsTable, flightId, flightSTD, flightNb, flightCategory, airlineCode, dStepAnalysis,
                            dtEcoShowUp, showUpEcoColumnIndex, dtEcoICT, ictEcoColumnIndex,
                            ecoCheckInOpeningMinute, ecoCheckInClosingMinute, mupOpeningMinute, ebsDeliveryStartMinute, mupClosingMinute,
                            firstEcoOrigPaxMinute, firstEcoTransfPaxMinute, inputRatePerMinute, outputRatePerMinute,
                            originatingEcoPaxNb, transferEcoPaxNb, averageNbEcoBags, ListeErreurs, ebsIssues, out ecoOutputSurplusIndex, out ecoOutputSurplusBags);
                        if (ecoPaxProcessed && (originatingFBPaxNb != 0 || transferFBPaxNb != 0))
                        {
                            if (dtFBShowUp == null)
                            {
                                dtFBShowUp = dtEcoShowUp;
                                showUpFBColumnIndex = showUpEcoColumnIndex;
                                firstFBOrigPaxMinute = firstEcoOrigPaxMinute;
                            }
                            if (dtFBICT == null)
                            {
                                dtFBICT = dtEcoICT;
                                ictFBColumnIndex = ictEcoColumnIndex;
                                firstFBTransfPaxMinute = firstEcoTransfPaxMinute;
                            }
                            if (fbCheckInOpeningMinute == -1)
                                fbCheckInOpeningMinute = ecoCheckInOpeningMinute;
                            if (fbCheckInClosingMinute == -1)
                                fbCheckInClosingMinute = ecoCheckInClosingMinute;
                            if (averageNbFBBags == -1)
                                averageNbFBBags = averageNbEcoBags;
                            updateEBSTable(true, dtBegin, dtEnd, ebsTable, flightId, flightSTD, flightNb, flightCategory, airlineCode, dStepAnalysis, dtFBShowUp,
                                showUpFBColumnIndex, dtFBICT, ictFBColumnIndex,
                                fbCheckInOpeningMinute, fbCheckInClosingMinute, mupOpeningMinute, ebsDeliveryStartMinute, mupClosingMinute,
                                firstFBOrigPaxMinute, firstFBTransfPaxMinute, inputRatePerMinute, outputRatePerMinute,
                                originatingFBPaxNb, transferFBPaxNb, averageNbFBBags, ListeErreurs, ebsIssues, out fbOutputSurplusIndex, out fbOutputSurplusBags);
                        }
                        if (ecoOutputSurplusIndex >= 0)
                        {
                            if (outputSurplusDictionary.ContainsKey(ecoOutputSurplusIndex))
                                outputSurplusDictionary[ecoOutputSurplusIndex].Add(ecoOutputSurplusBags);
                            else
                            {
                                List<double> surplusBags = new List<double>();
                                surplusBags.Add(ecoOutputSurplusBags);
                                outputSurplusDictionary.Add(ecoOutputSurplusIndex, surplusBags);
                            }
                        }
                        if (fbOutputSurplusIndex >= 0)
                        {
                            if (outputSurplusDictionary.ContainsKey(fbOutputSurplusIndex))
                                outputSurplusDictionary[fbOutputSurplusIndex].Add(fbOutputSurplusBags);
                            else
                            {
                                List<double> surplusBags = new List<double>();
                                surplusBags.Add(fbOutputSurplusBags);
                                outputSurplusDictionary.Add(fbOutputSurplusIndex, surplusBags);
                            }
                        }
                        if (ebsIssuesByTerminalDictionary.ContainsKey(mupTerminal)) // >> Task #9171 Pax2Sim - Static Analysis - EBS algorithm - Throughputs C#5
                        {
                            ebsIssuesByTerminalDictionary[mupTerminal].AddRange(ebsIssues.ToArray());
                        }
                    }
                }

                #region indexes for the EBS table
                int indexColumnInputDemandForSegregation = ebsTable.Columns.IndexOf(GlobalNames.FPD_EBS_INPUT_DEMAND_COLUMN_NAME);
                int indexColumnInputOverflowForSegregation = ebsTable.Columns.IndexOf(GlobalNames.FPD_EBS_INPUT_OVERFLOW_COLUMN_NAME);
                int indexColumnInput = ebsTable.Columns.IndexOf(GlobalNames.FPD_EBS_INPUT_COLUMN_NAME);
                int indexColumnThroughputInput = ebsTable.Columns.IndexOf(GlobalNames.FPD_EBS_THROUGHPUT_INPUT_COLUMN_NAME);

                int indexColumnOutputDemandForSegrgation = ebsTable.Columns.IndexOf(GlobalNames.FPD_EBS_OUTPUT_DEMAND_COLUMN_NAME);
                int indexColumnOutputBacklogForSegrgation = ebsTable.Columns.IndexOf(GlobalNames.FPD_EBS_OUTPUT_BACKLOG_COLUMN_NAME);
                int indexColumnOutput = ebsTable.Columns.IndexOf(GlobalNames.FPD_EBS_OUTPUT_COLUMN_NAME);
                int indexColumnThroughputOutput = ebsTable.Columns.IndexOf(GlobalNames.FPD_EBS_THROUGHPUT_OUTPUT_COLUMN_NAME);

                int indexColumnConstrainedOccupation = ebsTable.Columns.IndexOf(GlobalNames.FPD_EBS_CONSTRAINED_COLUMN_NAME);   // total occupation
                int indexColumnUnconstrainedOccupation = ebsTable.Columns.IndexOf(GlobalNames.FPD_EBS_UNCONSTRAINED_OCCUPATION_COLUMN_NAME);  //theoretical occupation for segregation
                #endregion

                double previousSlotTotalOccupation = 0;
                double currentInput = 0;
                double currentOutput = 0;
                double currentTotalOccupation = 0;
                for (int i = 0; i < ebsTable.Rows.Count; i++)
                {
                    if (i > 0)
                        previousSlotTotalOccupation = (Double)ebsTable.Rows[i - 1][indexColumnConstrainedOccupation];
                    currentInput = (Double)ebsTable.Rows[i][indexColumnInput];
                    currentOutput = (Double)ebsTable.Rows[i][indexColumnOutput];
                    currentTotalOccupation = (Double)ebsTable.Rows[i][indexColumnConstrainedOccupation];
                    if (outputSurplusDictionary.ContainsKey(i))
                    {
                        List<double> surplusBagsList = outputSurplusDictionary[i];
                        double totalSurplusBagsNb = 0;
                        foreach (double surplusNb in surplusBagsList)
                            totalSurplusBagsNb += surplusNb;

                        if (i > 0)
                        {
                            ebsTable.Rows[i][indexColumnOutputBacklogForSegrgation] = (Double)ebsTable.Rows[i - 1][indexColumnOutputBacklogForSegrgation]
                                + (Double)ebsTable.Rows[i][indexColumnOutputDemandForSegrgation] - (Double)ebsTable.Rows[i][indexColumnOutput] - totalSurplusBagsNb;
                        }
                        ebsTable.Rows[i][indexColumnConstrainedOccupation] = previousSlotTotalOccupation + (currentInput - currentOutput) - totalSurplusBagsNb;
                    }
                    else
                    {
                        if (i > 0)
                        {
                            ebsTable.Rows[i][indexColumnOutputBacklogForSegrgation] = (Double)ebsTable.Rows[i - 1][indexColumnOutputBacklogForSegrgation]
                                + (Double)ebsTable.Rows[i][indexColumnOutputDemandForSegrgation] - (Double)ebsTable.Rows[i][indexColumnOutput];
                        }
                        ebsTable.Rows[i][indexColumnConstrainedOccupation] = previousSlotTotalOccupation + currentInput - currentOutput;
                    }
                    ebsTable.Rows[i][indexColumnUnconstrainedOccupation] = (Double)ebsTable.Rows[i][indexColumnConstrainedOccupation]
                        + (Double)ebsTable.Rows[i][indexColumnInputOverflowForSegregation] - (Double)ebsTable.Rows[i][indexColumnOutputBacklogForSegrgation];
                }

                foreach (KeyValuePair<int, DataTable> pair in ebsTablesDictionary)
                {
                    DataTable table = pair.Value;
                    if (table != null)
                    {
                        indexColumnInput = table.Columns.IndexOf(GlobalNames.FPD_EBS_INPUT_COLUMN_NAME);
                        indexColumnThroughputInput = table.Columns.IndexOf(GlobalNames.FPD_EBS_THROUGHPUT_INPUT_COLUMN_NAME);
                        indexColumnOutput = table.Columns.IndexOf(GlobalNames.FPD_EBS_OUTPUT_COLUMN_NAME);
                        indexColumnThroughputOutput = table.Columns.IndexOf(GlobalNames.FPD_EBS_THROUGHPUT_OUTPUT_COLUMN_NAME);
                        indexColumnConstrainedOccupation = table.Columns.IndexOf(GlobalNames.FPD_EBS_CONSTRAINED_COLUMN_NAME);

                        ResultFunctions.AnalyzePeak_SlidingHourDouble(table, indexColumnInput, indexColumnThroughputInput, dStepAnalysis, dStepCumul);
                        ResultFunctions.AnalyzePeak_SlidingHourDouble(table, indexColumnOutput, indexColumnThroughputOutput, dStepAnalysis, dStepCumul);

                        foreach (DataRow Ligne in table.Rows)
                        {
                            if (Ligne[0].ToString().Length == 0)
                                continue;
                            for (int i = 1; i < table.Columns.Count; i++)
                                Ligne[i] = Math.Round((Double)Ligne[i], 2);
                        }
                    }
                }
            }

            private static void getFlightInformation(DataRow fpRow, int flightIdColumnIndex, int flightNbColumnIndex,
                int flightSTDColumnIndex, int flightTimeColumnIndex, int flightCategoryColumnIndex, int airlineCodeColumnIndex,
                out string flightId, out string flightNb, out DateTime flightSTD, out string flightCategory, out string airlineCode)
            {
                flightId = fpRow[flightIdColumnIndex].ToString();
                flightNb = fpRow[flightNbColumnIndex].ToString();
                flightSTD = DataFunctions.toDateTime(fpRow[flightSTDColumnIndex], fpRow[flightTimeColumnIndex]);
                flightCategory = fpRow[flightCategoryColumnIndex].ToString();
                airlineCode = fpRow[airlineCodeColumnIndex].ToString();
            }

            private static bool getPaxClassPercentages(ExceptionTable etLoadFactors, string flightId, string airlineCode, string flightCategory,
                ArrayList ListeErreurs,
                out double fbPaxPercent, out double ecoPaxPercent)
            {
                fbPaxPercent = 0;
                ecoPaxPercent = 0;
                Dictionary<String, String> dssLoadFactors = etLoadFactors.GetInformationsColumns(0, "D_" + flightId, airlineCode, flightCategory);
                if (dssLoadFactors == null)
                {
                    ListeErreurs.Add("Warning : Line ignored \"" + flightId + "\". Could not find an exception ( Flight id: "
                        + flightId + ", Airline code: " + airlineCode + ", Flight category :" + flightCategory + ")");
                    return false;
                }
                String fbPaxPercentString = dssLoadFactors[GlobalNames.sLFD_A_Line_C];
                String ecoPaxPercentString = dssLoadFactors[GlobalNames.sLFD_A_Line_Y];
                if (fbPaxPercentString == null || ecoPaxPercentString == null
                    || !double.TryParse(fbPaxPercentString, out fbPaxPercent) || !double.TryParse(ecoPaxPercentString, out ecoPaxPercent)
                    || fbPaxPercent < 0 || ecoPaxPercent < 0)
                {
                    ListeErreurs.Add("Err00093 : Compute EBS Results Per Terminal - The class distribution doesn't have a good format");
                    return false;
                }
                return true;
            }

            const int FB_PAX_CLASS = 1;
            const int ECO_PAX_CLASS = 0;
            private static bool getCheckInOpeningClosingMinutes(ExceptionTable etOCTCheckIn, string flightId, string airlineCode, string flightCategory,
                int paxClass, out double checkInOpening, out double checkInClosing)
            {
                checkInOpening = 0;
                checkInClosing = 0;
                Dictionary<String, String> dssOCT_CI = etOCTCheckIn.GetInformationsColumns(paxClass, "D_" + flightId, airlineCode, flightCategory);
                if (dssOCT_CI == null)
                    return false;
                String openingMinuteAsString = dssOCT_CI[GlobalNames.sOCT_CI_Line_Opening];
                String closingMinuteAsString = dssOCT_CI[GlobalNames.sOCT_CI_Line_Closing];
                if (!Double.TryParse(openingMinuteAsString, out checkInOpening))
                    return false;
                if (!Double.TryParse(closingMinuteAsString, out checkInClosing))
                    return false;
                return true;
            }

            private static bool getMakeUpInformation(ExceptionTable etOCTMakeUp, string flightId, string airlineCode, string flightCategory, int paxClass,
                out double mupOpeningMinute, out double ebsDeliveryStartMinute, out double mupClosingMinute)
            {
                mupOpeningMinute = 0;
                ebsDeliveryStartMinute = 0;
                mupClosingMinute = 0;
                Dictionary<String, String> dssOCT_Mup = etOCTMakeUp.GetInformationsColumns(paxClass, "D_" + flightId, airlineCode, flightCategory);
                if (dssOCT_Mup == null)
                    return false;
                string mupOpeningMinuteAsString = dssOCT_Mup[GlobalNames.sOCT_MakeUpOpening];
                string ebsDeliveryTimeBeforeSTDAsString = dssOCT_Mup[GlobalNames.sOCT_MakeUpEBS_Delivery];
                string mupClosingMinuteAsString = dssOCT_Mup[GlobalNames.sOCT_MakeUpClosing];
                if (!Double.TryParse(mupOpeningMinuteAsString, out mupOpeningMinute))
                    return false;
                if (!Double.TryParse(ebsDeliveryTimeBeforeSTDAsString, out ebsDeliveryStartMinute))
                    return false;
                if (!Double.TryParse(mupClosingMinuteAsString, out mupClosingMinute))
                    return false;
                return true;
            }

            private static double getNbBagHandledPerMinute(int mupTerminal, DataTable ebsRateTable, out int usedMupTerminal)
            {
                double nbBagsPerMinute = -1;   // >> Task #9172 Pax2Sim - Static Analysis - EBS algorithm - Input/Output Rates
                usedMupTerminal = mupTerminal;

                String terminalColumnName = GlobalNames.TERMINAL_ABBREVIATION + mupTerminal.ToString();
                int terminalColumnIndex = ebsRateTable.Columns.IndexOf(terminalColumnName);
                if (terminalColumnIndex != -1)
                    double.TryParse(ebsRateTable.Rows[0][terminalColumnIndex].ToString(), out nbBagsPerMinute);
                else  //unknown terminal
                {
                    terminalColumnName = GlobalNames.TERMINAL_ABBREVIATION + "0";
                    terminalColumnIndex = ebsRateTable.Columns.IndexOf(terminalColumnName);
                    double.TryParse(ebsRateTable.Rows[0][terminalColumnIndex].ToString(), out nbBagsPerMinute);
                    usedMupTerminal = 0;
                }
                return nbBagsPerMinute;
            }

            private static bool getFirstLastOrigPaxMinute(ExceptionTable etShowUpProfile, string flightId, string airlineCode, string flightCategory,
                int paxClass, ArrayList ListeErreurs, out int firstOrigPaxMinute, out int lastOrigPaxMinute, out DataTable dtShowUp, out int columnIndex)
            {
                dtShowUp = null;
                columnIndex = -1;
                firstOrigPaxMinute = 0;
                lastOrigPaxMinute = 0;

                dtShowUp = etShowUpProfile.GetInformationsColumns(paxClass, "D_" + flightId, airlineCode, flightCategory, out columnIndex);
                if (columnIndex == -1 || dtShowUp == null)
                {
                    ListeErreurs.Add("Err00410 : Flight category does not exist in the Show up table or Show up table doesn't have exceptions."
                        + " Please check your tables for mistakes.");
                    return false;
                }
                int iIndexFirst = -1;
                int iIndexLast = -1;
                GetFirstAndLastValuesRow(dtShowUp, columnIndex, out iIndexFirst, out iIndexLast);
                if (iIndexFirst == -1 || iIndexLast == -1)
                    return false;
                firstOrigPaxMinute = (int)dtShowUp.Rows[iIndexLast][1];
                lastOrigPaxMinute = (int)dtShowUp.Rows[iIndexFirst][0];
                return true;
            }

            private static bool getFirstLastTransferPaxMinute(ExceptionTable etICTExceptionTable, string flightId, string airlineCode, string flightCategory,
                int paxClass, ArrayList ListeErreurs, out int firstTransferPaxMinute, out int lastTransferPaxMinute, out DataTable dtICT, out int columnIndex)
            {
                dtICT = null;
                columnIndex = -1;
                firstTransferPaxMinute = 0;
                lastTransferPaxMinute = 0;

                dtICT = etICTExceptionTable.GetInformationsColumns(paxClass, "D_" + flightId, airlineCode, flightCategory, out columnIndex);
                if (dtICT == null || columnIndex == -1)
                {
                    ListeErreurs.Add("Err00410 : Flight category does not exist in the Inter-Connecting Times table. "
                        + "Please check the table for mistakes.");
                    return false;
                }
                int iIndexFirst = -1;
                int iIndexLast = -1;
                GetFirstAndLastValuesRow(dtICT, columnIndex, out iIndexFirst, out iIndexLast);
                if (iIndexFirst == -1 || iIndexLast == -1)
                    return false;
                firstTransferPaxMinute = (int)dtICT.Rows[iIndexLast][1];
                lastTransferPaxMinute = (int)dtICT.Rows[iIndexFirst][0];
                return true;
            }

            private static bool getNumberOfPassengers(DataRow fpRow, ExceptionTable etAircraftType, ExceptionTable etLoadFactors, DataTable dtFlightCategories,
                string flightId, string airlineCode, string flightCategory, ArrayList ListeErreurs, double ecoPaxPercent, double fbPaxPercent,
                out double nbEcoOriginatingPax, out double nbEcoTransferPax, out double nbFBOriginatingPax, out double nbFBTransferPax)
            {
                nbEcoOriginatingPax = 0;
                nbEcoTransferPax = 0;
                nbFBOriginatingPax = 0;
                nbFBTransferPax = 0;
                double totalPaxNb = OverallTools.DataFunctions.numberOfPassengers(fpRow, etAircraftType, dtFlightCategories, etLoadFactors, ListeErreurs);
                if (totalPaxNb == -1)
                {
                    ListeErreurs.Add("Warn00411 : Line ignored \"" + flightId + "\". The number of passenger for that fligt is not valid.");
                    return false;
                }
                double totalEcoPaxNb = (totalPaxNb * ecoPaxPercent) / 100;
                double totalFBPaxNb = (totalPaxNb * fbPaxPercent) / 100;

                Dictionary<String, String> dssLoadFactors = etLoadFactors.GetInformationsColumns(0, "D_" + flightId, airlineCode, flightCategory);
                String originatingPaxPercentAsString = dssLoadFactors[GlobalNames.sLFD_Line_Originating];
                if (originatingPaxPercentAsString == null)
                {
                    ListeErreurs.Add("Err00420 : The load factor table have problems.");
                    return false;
                }
                Double originatingPaxPercent = 0;
                if (!Double.TryParse(originatingPaxPercentAsString, out originatingPaxPercent))
                {
                    ListeErreurs.Add("Err00421 : The load factor value  for the originating passengers is not valid.");
                    return false;
                }
                nbEcoOriginatingPax = (totalEcoPaxNb * originatingPaxPercent) / 100;
                nbEcoTransferPax = (totalEcoPaxNb * (100 - originatingPaxPercent)) / 100;
                nbFBOriginatingPax = (totalFBPaxNb * originatingPaxPercent) / 100;
                nbFBTransferPax = (totalFBPaxNb * (100 - originatingPaxPercent)) / 100;
                return true;
            }

            private static bool getAverageNbBags(ExceptionTable etNbBags, string flightId, string airlineCode, string flightCategory, int paxClass,
                ArrayList ListeErreurs, out double averageNbBags)
            {
                averageNbBags = 0;
                int columnIndex = -1;
                DataTable dtNbBagsTable = etNbBags.GetInformationsColumns(paxClass, "D_" + flightId, airlineCode, flightCategory, out columnIndex);
                if (dtNbBagsTable == null || columnIndex == -1)
                {
                    ListeErreurs.Add("Err00410 : Flight category does not exist in the Bags distribution table. "
                        + "Please check the table for mistakes.");
                    return false;
                }
                averageNbBags = CalculCoefficientMultiplicateur(dtNbBagsTable, columnIndex);
                return true;
            }

            private static bool updateEBSTable(bool isFB, DateTime dtBegin, DateTime dtEnd, DataTable ebsTable,
                string flightId, DateTime flightSTD, string flightNb, string flightCategory, string airline, double analysisStep,
                DataTable dtShowUp, int showUpColumnIndex, DataTable dtICT, int ictColumnIndex, double checkInOpeningMinute, double checkInClosingMinute,
                double mupOpeningMinute, double ebsDeliveryStartMinute, double mupClosingMinute, double firstOrigPaxMinute, double firstTransferPaxMinute,
                double inputRatePerMinute, double outputRatePerMinute, double originatingPaxNb, double transferPaxNb,
                double averageNbBags, ArrayList ListeErreurs, List<EbsIssue> ebsIssues, // >> Task #9171 Pax2Sim - Static Analysis - EBS algorithm - Throughputs C#5
                out int outputSurplusIndex, out double outputBagsSurplus)
            {
                outputSurplusIndex = -1;
                outputBagsSurplus = 0;

                EbsIssue.BAG_TYPE issueBagType = EbsIssue.BAG_TYPE.ECO;
                string bagsType = "Eco.";
                if (isFB)
                {
                    bagsType = "FB";
                    issueBagType = EbsIssue.BAG_TYPE.FB;
                }

                #region indexes for the EBS table
                int indexColumnInputDemand = ebsTable.Columns.IndexOf(GlobalNames.FPD_EBS_INPUT_DEMAND_COLUMN_NAME);
                int indexColumnInputOverflow = ebsTable.Columns.IndexOf(GlobalNames.FPD_EBS_INPUT_OVERFLOW_COLUMN_NAME);
                int indexColumnInput = ebsTable.Columns.IndexOf(GlobalNames.FPD_EBS_INPUT_COLUMN_NAME);
                int indexColumnThroughputInput = ebsTable.Columns.IndexOf(GlobalNames.FPD_EBS_THROUGHPUT_INPUT_COLUMN_NAME);

                int indexColumnOutputDemand = ebsTable.Columns.IndexOf(GlobalNames.FPD_EBS_OUTPUT_DEMAND_COLUMN_NAME);
                int indexColumnOutputBacklog = ebsTable.Columns.IndexOf(GlobalNames.FPD_EBS_OUTPUT_BACKLOG_COLUMN_NAME);
                int indexColumnOutput = ebsTable.Columns.IndexOf(GlobalNames.FPD_EBS_OUTPUT_COLUMN_NAME);
                int indexColumnThroughputOutput = ebsTable.Columns.IndexOf(GlobalNames.FPD_EBS_THROUGHPUT_OUTPUT_COLUMN_NAME);
                int indexColumnTotalOccupation = ebsTable.Columns.IndexOf(GlobalNames.FPD_EBS_CONSTRAINED_COLUMN_NAME);
                #endregion

                DateTime checkInOpeningTime = flightSTD.AddMinutes(-checkInOpeningMinute);
                DateTime checkInClosingTime = flightSTD.AddMinutes(-checkInClosingMinute);
                DateTime mupOpeningTime = flightSTD.AddMinutes(-mupOpeningMinute);
                double ebsReleaseMinute = Math.Min(mupOpeningMinute, ebsDeliveryStartMinute); //case mup opening is after ebs release = closest to STD
                DateTime ebsReleaseTime = flightSTD.AddMinutes(-ebsReleaseMinute);
                DateTime mupClosingTime = flightSTD.AddMinutes(-mupClosingMinute);
                if (checkInOpeningTime > dtEnd)
                {
                    ListeErreurs.Add("Warn00411 : EBS calculation: The departing flight \"" + flightId.ToString() + "\" will be ignored."
                        + " The Check-In opening time (" + checkInOpeningTime.ToShortDateString()
                        + ") is after the scenario end time (" + dtEnd.ToShortDateString() + ")");
                    return false;
                }


                if (outputRatePerMinute > 0)
                {
                    int ebsReleaseInterval = DataFunctions.heureDebut(ebsTable, ebsReleaseTime);
                    int mupClosingInterval = DataFunctions.heureDebut(ebsTable, mupClosingTime);
                    if (ebsReleaseInterval == -1)
                    {
                        ListeErreurs.Add("Warn00411 : EBS calculation: The departing flight \"" + flightId.ToString() + "\" will be ignored."
                        + " The EBS Release time (" + ebsReleaseTime.ToShortDateString()
                        + ") is not inside the scenario's time frame.(" + dtBegin.ToShortDateString() + "_ " + dtEnd.ToShortDateString() + ")");
                        return false;
                    }
                    if (mupClosingInterval == -1)
                    {
                        ListeErreurs.Add("Warn00411 : EBS calculation: The departing flight \"" + flightId.ToString() + "\" will be ignored."
                        + " The MakeUp Closing time (" + mupClosingTime.ToShortDateString()
                        + ") is not inside the scenario's time frame.(" + dtBegin.ToShortDateString() + "_ " + dtEnd.ToShortDateString() + ")");
                        return false;
                    }
                }
                else
                {
                    DateTime outputTime = flightSTD.AddMinutes(-ebsDeliveryStartMinute);
                    int outputInterval = DataFunctions.heureDebut(ebsTable, outputTime);
                    if (outputInterval == -1)
                    {
                        ListeErreurs.Add("Warn00411 : EBS calculation: The departing flight \"" + flightId.ToString() + "\" will be ignored."
                        + " The Output time based on the EBS delivery minute (EBS delivery minute: " + ebsDeliveryStartMinute
                        + " , Output time: " + outputTime.ToShortDateString()
                        + ") is not inside the scenario's time frame.(" + dtBegin.ToShortDateString() + "_ " + dtEnd.ToShortDateString() + ")");
                        return false;
                    }
                }

                //Calcul de la courbe de présentation des passagers.
                //Il faut dans un premier temps limité l'interval à calculer.
                int iHeureDebut;
                //if (firstOrigPaxMinute < checkInOpeningMinute)
                //    iHeureDebut = DataFunctions.heureDebut(ebsTable, flightSTD.AddMinutes(-firstOrigPaxMinute));
                //else
                //    iHeureDebut = DataFunctions.heureDebut(ebsTable, checkInOpeningTime);
                if (firstOrigPaxMinute > checkInOpeningMinute)
                    iHeureDebut = DataFunctions.heureDebut(ebsTable, flightSTD.AddMinutes(-firstOrigPaxMinute));
                else
                    iHeureDebut = DataFunctions.heureDebut(ebsTable, checkInOpeningTime);
                Double dOpeningForOriginating = firstOrigPaxMinute;
                if (iHeureDebut == -1)
                {
                    if ((((DateTime)ebsTable.Rows[0][0]) > checkInOpeningTime) && (((DateTime)ebsTable.Rows[0][0]) < checkInClosingTime))
                    {
                        dOpeningForOriginating = DataFunctions.MinuteDifference(((DateTime)ebsTable.Rows[0][0]), flightSTD);
                        iHeureDebut = 0;
                    }
                    if (iHeureDebut == -1)
                    {
                        ListeErreurs.Add("Warn00422 : EBS calculation : The departing flight \"" + flightId.ToString() + "\" will be ignored. Originating passengers begin arriving at "
                            + flightSTD.AddMinutes(-firstOrigPaxMinute).ToString("dd/MM/yyyy HH:mm") + ", which is before the scenario starting time ("
                            + dtBegin.ToString("dd/MM/yyyy HH:mm") + ").");
                        return false;
                    }
                }

                int indexHeureDebutForTransfer = DataFunctions.heureDebut(ebsTable, flightSTD.AddMinutes(-firstTransferPaxMinute));
                Double dOpeningForTransfer = firstTransferPaxMinute;

                if (indexHeureDebutForTransfer == -1)
                {
                    if ((DateTime)ebsTable.Rows[0][0] > checkInOpeningTime
                        && (DateTime)ebsTable.Rows[0][0] < checkInClosingTime)
                    {
                        dOpeningForTransfer = DataFunctions.MinuteDifference(((DateTime)ebsTable.Rows[0][0]), flightSTD);
                        indexHeureDebutForTransfer = 0;
                    }
                    if (indexHeureDebutForTransfer == -1)
                    {
                        ListeErreurs.Add("Warn00422 : EBS calculation : The departing flight \"" + flightId.ToString() + "\" will be ignored. Transferring passengers begin arriving at "
                            + flightSTD.AddMinutes(-firstTransferPaxMinute).ToString("dd/MM/yyyy HH:mm") + ", which is before the scenario starting date ("
                            + dtBegin.ToString("dd/MM/yyyy HH:mm") + ").");
                        return false;
                    }
                }

                if (indexHeureDebutForTransfer < iHeureDebut)
                    iHeureDebut = indexHeureDebutForTransfer;

                DateTime analysedSlotStartTime = (DateTime)ebsTable.Rows[iHeureDebut][0];
                double dPercentForOriginating = 0;
                double dPercentForTransfer = 0;
                double totalNbBagsPerFlight = 0;
                double originatingNbBagsBeforeCheckInOpening = 0;

                Double bagSurplussFromPreviousSlots = 0;

                if (inputRatePerMinute > 0)
                {
                    double nbBagsAllowedPerSlot = inputRatePerMinute * analysisStep;

                    //add the ebs time interval(from Mup Opening to EBS release) so that we can show
                    // the ebs bags if the release is after the Mup opening or partial opening 
                    //-> will be used in the output part at the end of input calculation iHeureDebut must be before ebs release
                    while ((analysedSlotStartTime < mupOpeningTime) //mupOpeningTime.AddMinutes(ebsDelayMinutes))  // << Task #9140 Pax2Sim - Static Analysis - FPD_EBS new parameters
                        && (iHeureDebut < ebsTable.Rows.Count))
                    {
                        Double inputBaggagePerSlot = 0;
                        Double nbOriginatingBagsPerSlot = 0;
                        Double nbTransferingBagsPerSlot = 0;
                        //nb of bags that were placed in this time slots by previous flights
                        Double nbBagsAlreadyOnTimeSlot = (Double)ebsTable.Rows[iHeureDebut][indexColumnInput];

                        DateTime analysedSlotEndTime = analysedSlotStartTime.AddMinutes(analysisStep);

                        if (analysedSlotEndTime > mupOpeningTime)
                        {
                            //analysedSlotEndTime = mupOpeningTime;
                            TimeSpan span = mupOpeningTime.Subtract(analysedSlotStartTime);
                            nbBagsAllowedPerSlot = inputRatePerMinute * span.TotalMinutes;
                        }
                        Double dClosing = DataFunctions.MinuteDifference(analysedSlotEndTime, flightSTD);

                        dPercentForOriginating = getDistribution((int)dOpeningForOriginating, (int)dClosing, dtShowUp, showUpColumnIndex);
                        if (dPercentForOriginating > 0)
                            nbOriginatingBagsPerSlot = dPercentForOriginating * originatingPaxNb * averageNbBags;
                        dPercentForTransfer = getDistribution((int)dOpeningForTransfer, (int)dClosing, dtICT, ictColumnIndex);
                        if (dPercentForTransfer > 0)
                            nbTransferingBagsPerSlot = dPercentForTransfer * transferPaxNb * averageNbBags;

                        double bagsForSlot = 0;
                        if (analysedSlotEndTime <= checkInOpeningTime)  //if slot end time == CI opening we don't add the bags because the time slot doesn't include the end time => [startTime, endTime)
                        {
                            originatingNbBagsBeforeCheckInOpening += nbOriginatingBagsPerSlot;
                            bagsForSlot = nbTransferingBagsPerSlot;
                        }
                        else if (analysedSlotStartTime <= checkInOpeningTime     //place the accumulated orig bags on the time slot that contains the CI opening time => CI opening is in the interval [startTime, endTime)                        
                                 && analysedSlotEndTime > checkInOpeningTime)
                        {
                            bagsForSlot = nbOriginatingBagsPerSlot + nbTransferingBagsPerSlot + originatingNbBagsBeforeCheckInOpening;
                        }
                        else
                        {
                            bagsForSlot = nbOriginatingBagsPerSlot + nbTransferingBagsPerSlot;
                        }

                        if (bagsForSlot <= nbBagsAllowedPerSlot - nbBagsAlreadyOnTimeSlot)
                        {
                            double remainingSpaceForSurplussBags = nbBagsAllowedPerSlot - nbBagsAlreadyOnTimeSlot - bagsForSlot;
                            if (bagSurplussFromPreviousSlots > 0)
                            {
                                if (bagSurplussFromPreviousSlots > remainingSpaceForSurplussBags)
                                {
                                    inputBaggagePerSlot = nbBagsAllowedPerSlot - nbBagsAlreadyOnTimeSlot;
                                    if (inputBaggagePerSlot < 0)
                                        inputBaggagePerSlot = 0;
                                    totalNbBagsPerFlight = totalNbBagsPerFlight + inputBaggagePerSlot;
                                    bagSurplussFromPreviousSlots = bagSurplussFromPreviousSlots - remainingSpaceForSurplussBags;
                                }
                                else
                                {
                                    inputBaggagePerSlot = bagsForSlot + bagSurplussFromPreviousSlots;
                                    totalNbBagsPerFlight = totalNbBagsPerFlight + inputBaggagePerSlot;
                                    bagSurplussFromPreviousSlots = 0;
                                }
                            }
                            else
                            {
                                totalNbBagsPerFlight = totalNbBagsPerFlight + bagsForSlot;
                                inputBaggagePerSlot = bagsForSlot;
                            }
                        }
                        else
                        {
                            double addedBaggs = nbBagsAllowedPerSlot - nbBagsAlreadyOnTimeSlot;
                            if (addedBaggs < 0)
                                addedBaggs = 0;
                            totalNbBagsPerFlight = totalNbBagsPerFlight + addedBaggs;
                            inputBaggagePerSlot = addedBaggs;
                            bagSurplussFromPreviousSlots = bagSurplussFromPreviousSlots + (bagsForSlot - addedBaggs);
                        }

                        if (indexColumnInputDemand != -1)
                        {
                            ebsTable.Rows[iHeureDebut][indexColumnInputDemand]
                                = (Double)ebsTable.Rows[iHeureDebut][indexColumnInputDemand] + bagsForSlot;
                        }
                        if (indexColumnInputOverflow != -1)
                        {
                            ebsTable.Rows[iHeureDebut][indexColumnInputOverflow]
                                                        = (Double)ebsTable.Rows[iHeureDebut][indexColumnInputOverflow] + bagSurplussFromPreviousSlots;
                        }
                        ebsTable.Rows[iHeureDebut][indexColumnInput]
                            = (Double)ebsTable.Rows[iHeureDebut][indexColumnInput] + inputBaggagePerSlot;

                        dOpeningForTransfer = dClosing;
                        dOpeningForOriginating = dClosing;
                        analysedSlotStartTime = analysedSlotEndTime;
                        iHeureDebut++;
                    }
                    if (bagSurplussFromPreviousSlots > 0)
                    {
                        /*ListeErreurs.Add("Warn00433 : " + ebsTable.TableName + ": At " + ebsReleaseTime.ToString("dd/MM/yyyy HH:mm") + " the departing flight \"" 
                            + flightId + "\", " + flightNb + " generated " + Math.Round(bagSurplussFromPreviousSlots, 1) + " overflow "
                            + bagsType + " bags due to the input rate limit.");*/
                        EbsIssue issue = EbsLogger.getEbsIssue(ebsReleaseTime, ebsTable.TableName, flightId, flightNb, flightCategory,
                            airline, flightSTD.Date, flightSTD.TimeOfDay, Math.Round(bagSurplussFromPreviousSlots, 1), issueBagType, EbsIssue.EBS_PROCESS_TYPE.INPUT);
                        ebsIssues.Add(issue);
                    }
                }
                else
                {
                    //add the ebs time interval(from Mup Opening to EBS release) so that we can show
                    // the ebs bags if the release is after the Mup opening or partial opening
                    while ((analysedSlotStartTime < mupOpeningTime)
                        && (iHeureDebut < ebsTable.Rows.Count))
                    {
                        double originatingBagsInputPerSlot = 0;
                        double transferingBagsInputPerSlot = 0;

                        DateTime analysedSlotEndTime = analysedSlotStartTime.AddMinutes(analysisStep);
                        if (analysedSlotEndTime > mupOpeningTime)
                        {
                            //analysedSlotEndTime = mupOpeningTime;
                        }
                        Double dClosing = DataFunctions.MinuteDifference(analysedSlotEndTime, flightSTD);

                        //add only if the makeUp is not opened
                        if (analysedSlotStartTime < mupOpeningTime)
                        {
                            dPercentForOriginating = getDistribution((int)dOpeningForOriginating, (int)dClosing, dtShowUp, showUpColumnIndex);
                            if (dPercentForOriginating > 0)
                            {
                                originatingBagsInputPerSlot = dPercentForOriginating * originatingPaxNb * averageNbBags;
                                //totalNbBagsPerFlight += originatingBagsInputPerSlot;
                            }
                            dPercentForTransfer = getDistribution((int)dOpeningForTransfer, (int)dClosing,
                                dtICT, ictColumnIndex);
                            if (dPercentForTransfer > 0)
                            {
                                transferingBagsInputPerSlot = dPercentForTransfer * transferPaxNb * averageNbBags;
                                //totalNbBagsPerFlight += transferingBagsInputPerSlot;
                            }
                        }

                        double nbInputBagsPerSlot = 0;
                        //double nbTotalBagsPerSlot = totalNbBagsPerFlight;
                        if (analysedSlotEndTime <= checkInOpeningTime)  //if slot end time == CI opening we don't add the bags because the time slot doesn't include the end time => [startTime, endTime)
                        {
                            originatingNbBagsBeforeCheckInOpening += originatingBagsInputPerSlot;
                            nbInputBagsPerSlot = transferingBagsInputPerSlot;
                            //nbTotalBagsPerSlot = totalNbBagsPerFlight - originatingBagsInputPerSlot;                            
                        }
                        else if (analysedSlotStartTime <= checkInOpeningTime && analysedSlotEndTime > checkInOpeningTime)    //place the accumulated orig bags on the time slot that contains the CI opening time => CI opening is in the interval [startTime, endTime)                        
                            nbInputBagsPerSlot = originatingBagsInputPerSlot + transferingBagsInputPerSlot + originatingNbBagsBeforeCheckInOpening;
                        else
                            nbInputBagsPerSlot = originatingBagsInputPerSlot + transferingBagsInputPerSlot;

                        totalNbBagsPerFlight += nbInputBagsPerSlot;

                        if (indexColumnInputDemand != -1)
                            ebsTable.Rows[iHeureDebut][indexColumnInputDemand] = (Double)ebsTable.Rows[iHeureDebut][indexColumnInputDemand] + nbInputBagsPerSlot;

                        if (indexColumnInputOverflow != -1)
                            ebsTable.Rows[iHeureDebut][indexColumnInputOverflow] = 0;

                        ebsTable.Rows[iHeureDebut][indexColumnInput] = (Double)ebsTable.Rows[iHeureDebut][indexColumnInput] + nbInputBagsPerSlot;

                        dOpeningForTransfer = dClosing;
                        dOpeningForOriginating = dClosing;
                        analysedSlotStartTime = analysedSlotEndTime;
                        iHeureDebut++;
                    }
                }


                double nbOutputBags = totalNbBagsPerFlight;
                if (outputRatePerMinute > 0)
                {
                    int indexCurrentInterval = DataFunctions
                        .heureDebut(ebsTable, ebsReleaseTime);//flightSTD.AddMinutes(-ebsDeliveryStartMinute));
                    int indexMupClosing = DataFunctions.heureDebut(ebsTable, mupClosingTime);

                    double nbOutputBagsAllowedPerSlot = outputRatePerMinute * (int)analysisStep;
                    double nbOutputBagsAlreadyOnTimeSlot = 0;
                    bool firstOutput = true;
                    while (nbOutputBags > 0 && indexCurrentInterval <= indexMupClosing
                        && indexCurrentInterval < ebsTable.Rows.Count)
                    {
                        if (firstOutput)
                        {
                            DateTime startOfFirstInterval = (DateTime)ebsTable.Rows[indexCurrentInterval][0];
                            DateTime endOfFirstInterval = startOfFirstInterval.AddMinutes(analysisStep);
                            TimeSpan timeSpan = endOfFirstInterval.Subtract(ebsReleaseTime);
                            double minutesBetweenEbsReleaseAndEndOfFirstInterval = timeSpan.Minutes;
                            double usagePercent = minutesBetweenEbsReleaseAndEndOfFirstInterval / analysisStep;
                            nbOutputBagsAllowedPerSlot = outputRatePerMinute * analysisStep * usagePercent;
                        }
                        else if (indexCurrentInterval == indexMupClosing)
                        {
                            DateTime startOfIntervalWithMupClosing = (DateTime)ebsTable.Rows[indexCurrentInterval][0];
                            TimeSpan timeSpan = mupClosingTime.Subtract(startOfIntervalWithMupClosing);
                            double minutesBetweenIntervalStartAndMupClosing = timeSpan.Minutes;
                            double usagePercentage = minutesBetweenIntervalStartAndMupClosing / analysisStep;
                            nbOutputBagsAllowedPerSlot = outputRatePerMinute * analysisStep * usagePercentage;
                        }
                        else
                            nbOutputBagsAllowedPerSlot = outputRatePerMinute * (int)analysisStep;
                        nbOutputBagsAlreadyOnTimeSlot = (Double)ebsTable.Rows[indexCurrentInterval][indexColumnOutput];

                        if (nbOutputBags <= nbOutputBagsAllowedPerSlot - nbOutputBagsAlreadyOnTimeSlot)
                        {
                            if (firstOutput)
                            {
                                ebsTable.Rows[indexCurrentInterval][indexColumnOutputDemand]
                                    = (Double)ebsTable.Rows[indexCurrentInterval][indexColumnOutputDemand] + nbOutputBags;

                                //ebsTable.Rows[indexCurrentInterval][indexColumnOutputBacklog]
                                //= (Double)ebsTable.Rows[indexCurrentInterval][indexColumnOutputBacklog] + 0;
                            }
                            ebsTable.Rows[indexCurrentInterval][indexColumnOutput]
                                = (Double)ebsTable.Rows[indexCurrentInterval][indexColumnOutput] + nbOutputBags;
                            nbOutputBags = 0;
                        }
                        else
                        {
                            double nbBagsOutputedPerSlot = 0;
                            if (nbOutputBagsAllowedPerSlot > nbOutputBagsAlreadyOnTimeSlot)
                                nbBagsOutputedPerSlot = nbOutputBagsAllowedPerSlot - nbOutputBagsAlreadyOnTimeSlot;
                            nbOutputBags = nbOutputBags - nbBagsOutputedPerSlot;

                            if (firstOutput)
                            {
                                ebsTable.Rows[indexCurrentInterval][indexColumnOutputDemand]
                                    = (Double)ebsTable.Rows[indexCurrentInterval][indexColumnOutputDemand] + totalNbBagsPerFlight;

                                //ebsTable.Rows[indexCurrentInterval][indexColumnOutputBacklog]
                                //= (Double)ebsTable.Rows[indexCurrentInterval][indexColumnOutputBacklog] + nbOutputBags;
                            }
                            ebsTable.Rows[indexCurrentInterval][indexColumnOutput]
                                = (Double)ebsTable.Rows[indexCurrentInterval][indexColumnOutput] + nbBagsOutputedPerSlot;
                        }
                        indexCurrentInterval++;
                        firstOutput = false;
                    }
                    if (nbOutputBags > 0)
                    {
                        outputSurplusIndex = indexCurrentInterval - 1;
                        outputBagsSurplus = nbOutputBags;
                        /*ListeErreurs.Add("Warn00434 : " + ebsTable.TableName + ": At " + flightSTD.ToString("dd/MM/yyyy HH:mm") + " the departing flight \""
                            + flightId + "\", " + flightNb  + " generated " + Math.Round(nbOutputBags, 1) + " overflow " + bagsType
                            + " bags due to the output rate limit.");*/
                        EbsIssue issue = EbsLogger.getEbsIssue(flightSTD, ebsTable.TableName, flightId, flightNb, flightCategory,
                            airline, flightSTD.Date, flightSTD.TimeOfDay, Math.Round(nbOutputBags, 1), issueBagType, EbsIssue.EBS_PROCESS_TYPE.OUTPUT);
                        ebsIssues.Add(issue);
                    }
                }
                else
                {
                    int outputTimeSlotIndex = DataFunctions.heureDebut(ebsTable, ebsReleaseTime);//flightSTD.AddMinutes(-ebsDeliveryStartMinute));
                    if (outputTimeSlotIndex < ebsTable.Rows.Count)
                    {
                        ebsTable.Rows[outputTimeSlotIndex][indexColumnOutputDemand] = (Double)ebsTable.Rows[outputTimeSlotIndex][indexColumnOutputDemand] + totalNbBagsPerFlight;
                        //ebsTable.Rows[outputTimeSlotIndex][indexColumnOutputBacklog] = 0;
                        ebsTable.Rows[outputTimeSlotIndex][indexColumnOutput] = (Double)ebsTable.Rows[outputTimeSlotIndex][indexColumnOutput] + totalNbBagsPerFlight;

                    }
                    else
                    {
                        ebsTable.Rows[outputTimeSlotIndex - 1][indexColumnOutputDemand] = (Double)ebsTable.Rows[outputTimeSlotIndex - 1][indexColumnOutputDemand] + totalNbBagsPerFlight;
                        //ebsTable.Rows[outputTimeSlotIndex - 1][indexColumnOutputBacklog] = 0;
                        ebsTable.Rows[outputTimeSlotIndex - 1][indexColumnOutput] = (Double)ebsTable.Rows[outputTimeSlotIndex - 1][indexColumnOutput] + totalNbBagsPerFlight;
                    }
                }


                return true;
            }
            #endregion
            // >> Task #9260 Pax2Sim - Static Analysis - EBS algorithm - EBS per Terminal

            #region ====================================   Containers =======================================
            private class FlightCategoryInformations
            {
                public String sName;
                public Double dOpenningTime;
                public Double dClosingTime;
                public Double dAllocatedMakeUp;

                public int iSegregationNumber;
                public int iContainerSize;
                public int iDeadTime;//To change a container (in s)
                public int iLateralNumbers;

                public FlightCategoryInformations(DataTable dtOCT, int iColumnIndex)
                {
                    if (dtOCT.Columns.Count < iColumnIndex)
                        return;
                    sName = dtOCT.Columns[iColumnIndex].ColumnName;
                    dOpenningTime = (Double)dtOCT.Rows[0][iColumnIndex];
                    dClosingTime = (Double)dtOCT.Rows[1][iColumnIndex];
                    //EbsDeliveryTime= (Double)dtOCT.Rows[2][iColumnIndex];
                    dAllocatedMakeUp = (Double)dtOCT.Rows[3][iColumnIndex];

                    iSegregationNumber = (int)((Double)dtOCT.Rows[6][iColumnIndex]);
                    iContainerSize = (int)((Double)dtOCT.Rows[7][iColumnIndex]);
                    iDeadTime = (int)((Double)dtOCT.Rows[8][iColumnIndex]);
                    iLateralNumbers = (int)((Double)dtOCT.Rows[9][iColumnIndex]);
                }
            }
            internal static DataTable CalcContainerStatistics(DataTable dtFPDTable,
                                                       DataManagement.NormalTable dtMakeUpAllocation,
                                                       DataManagement.NormalTable dtShowUpProfile,
                                                       DataManagement.NormalTable dtSegregation,
                                                       DataManagement.NormalTable dtICTProfile,
                                                       DataManagement.NormalTable dtOCTCheckIn,
                                                       DataManagement.NormalTable dtLoadFactor,
                                                       DataManagement.NormalTable dtAircraftType,
                                                       DataTable dtFlightCategories,
                                                       DataManagement.NormalTable dtNbBags,
                                                       DateTime dtBeginDate,
                                                       DateTime dtEndDate,
                                                       List<FlightConfiguration> userDefinedFlightConfigurations,
                                                       ArrayList ListeErreurs)
            {
                if ((dtFPDTable == null) ||
                    (dtMakeUpAllocation == null) ||
                    (dtShowUpProfile == null) ||
                    (dtICTProfile == null) ||
                    (dtOCTCheckIn == null) ||
                    (dtLoadFactor == null) ||
                    (dtAircraftType == null) ||
                    (dtFlightCategories == null) ||
                    (dtNbBags == null) ||
                    (dtSegregation == null))
                {
                    ListeErreurs.Add("Err00465 : Invalids parameters for the container calc. Please check your tables for mistakes.");
                    return null;
                }

                DataManagement.ExceptionTable etMakeUpAllocation;
                if (dtMakeUpAllocation is DataManagement.ExceptionTable)
                    etMakeUpAllocation = (DataManagement.ExceptionTable)dtMakeUpAllocation;
                else
                    return null;

                DataManagement.ExceptionTable etShowUpProfile;
                if (dtShowUpProfile is DataManagement.ExceptionTable)
                    etShowUpProfile = (DataManagement.ExceptionTable)dtShowUpProfile;
                else
                    return null;

                DataManagement.ExceptionTable etSegregation;
                if (dtSegregation is DataManagement.ExceptionTable)
                    etSegregation = (DataManagement.ExceptionTable)dtSegregation;
                else
                    return null;

                DataManagement.ExceptionTable etICTProfile;
                if (dtICTProfile is DataManagement.ExceptionTable)
                    etICTProfile = (DataManagement.ExceptionTable)dtICTProfile;
                else
                    return null;

                DataManagement.ExceptionTable etOCTCheckIn;
                if (dtOCTCheckIn is DataManagement.ExceptionTable)
                    etOCTCheckIn = (DataManagement.ExceptionTable)dtOCTCheckIn;
                else
                    return null;

                DataManagement.ExceptionTable etLoadFactor;
                if (dtLoadFactor is DataManagement.ExceptionTable)
                    etLoadFactor = (DataManagement.ExceptionTable)dtLoadFactor;
                else
                    return null;

                DataManagement.ExceptionTable etAircraftType;
                if (dtAircraftType is DataManagement.ExceptionTable)
                    etAircraftType = (DataManagement.ExceptionTable)dtAircraftType;
                else
                    return null;

                DataManagement.ExceptionTable etNbBags;
                if (dtNbBags is DataManagement.ExceptionTable)
                    etNbBags = (DataManagement.ExceptionTable)dtNbBags;
                else
                    return null;



                int i;
                int iIndexID = dtFPDTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID);
                int iIndexAirline = dtFPDTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_AirlineCode);
                int iIndexFC = dtFPDTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightCategory);
                int iIndexDate = dtFPDTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_DATE);
                int iIndexTime = dtFPDTable.Columns.IndexOf(GlobalNames.sFPD_Column_STD);
                if ((iIndexID == -1) ||
                    (iIndexAirline == -1) ||
                    (iIndexFC == -1) ||
                    (iIndexDate == -1) ||
                    (iIndexTime == -1))
                {
                    return null;
                }

                DataTable dtICTTmp = dtICTProfile.Table;
                DataTable dtShowUpTmp = dtShowUpProfile.Table;

                int iPas = Math.Min((Int32)dtICTTmp.Rows[0][1] - (Int32)dtICTTmp.Rows[0][0], (Int32)dtShowUpTmp.Rows[0][1] - (Int32)dtShowUpTmp.Rows[0][0]);
                DataTable dtResults = new DataTable("Container results");
                dtResults.Columns.Add("Flight Id", typeof(Int32));
                dtResults.Columns.Add("Segregation", typeof(Int32));
                dtResults.Columns.Add("Index Container", typeof(Int32));
                dtResults.Columns.Add("Time", typeof(DateTime));
                dtResults.Columns.Add("Number of Baggage", typeof(Int32));
                foreach (DataRow drLine in dtFPDTable.Rows)
                {
                    //On récupère l'identifiant du vol.
                    int iIdentifiantVol = (int)drLine.ItemArray[iIndexID];
                    //Heure de départ du vol.
                    DateTime dateDepart = DataFunctions.toDateTime(drLine[iIndexDate], drLine[iIndexTime]);
                    if (dateDepart < dtBeginDate)
                    {
                        ListeErreurs.Add("Warn00462 : Line \"" + iIdentifiantVol.ToString() + "\" doesn't match the range, ignored for the container calc.");
                        continue;
                    }
                    if (dateDepart > dtEndDate)
                    {
                        ListeErreurs.Add("Warn00469 : Line \"" + iIdentifiantVol.ToString() + "\" doesn't match the range, ignored for the container calc.");
                        continue;
                    }
                    String FlightCateg = drLine[iIndexFC].ToString();
                    String sAirline = drLine[iIndexAirline].ToString();
                    /*if (!htFCIInformations.ContainsKey(FlightCateg))
                    {
                        ListeErreurs.Add("Err00463 : Flight category does not exist in the " + dtMakeUpAllocation.TableName + " table. Please check your tables for mistakes.");
                        continue;
                    }*/

                    int iIndexColumn;
                    DataTable dtOCT_MakeUp = etMakeUpAllocation.GetInformationsColumns(0, "D_" + iIdentifiantVol.ToString(), sAirline, FlightCateg, out iIndexColumn);
                    if (iIndexColumn == -1)
                        continue;
                    FlightCategoryInformations fciTmp = new FlightCategoryInformations(dtOCT_MakeUp, iIndexColumn);


                    Dictionary<String, String> dssOCT_CI = etOCTCheckIn.GetInformationsColumns(0, "D_" + iIdentifiantVol.ToString(), sAirline, FlightCateg);
                    if (dssOCT_CI == null)
                        continue;

                    String sOpening = dssOCT_CI[GlobalNames.sOCT_CI_Line_Opening];
                    String sClosing = dssOCT_CI[GlobalNames.sOCT_CI_Line_Closing];

                    Double dOuvertureCI;// = ((Double[])htOCTCheckIn[FlightCateg])[0];
                    Double dFermetureCI;// = ((Double[])htOCTCheckIn[FlightCateg])[1];
                    if (!Double.TryParse(sOpening, out dOuvertureCI))
                    {
                        continue;
                    }
                    if (!Double.TryParse(sClosing, out dFermetureCI))
                    {
                        continue;
                    }

                    /*if (!htOCTCheckIn.ContainsKey(FlightCateg))
                    {
                        ListeErreurs.Add("Err00466 : Flight category does not exist in OCT_CI table. Please check your tables for mistakes.");
                        continue;
                    }*/

                    int iIndexColumnEco;
                    DataTable dtShowUpEco = etShowUpProfile.GetInformationsColumns(0, "D_" + iIdentifiantVol.ToString(), sAirline, FlightCateg, out iIndexColumnEco);

                    if (iIndexColumnEco == -1)
                    {
                        ListeErreurs.Add("Err00467 : Flight category does not exist in the Show up table. Please check your tables for mistakes.");
                        continue;
                    }

                    int iIndexFirst, iIndexLast;
                    GetFirstAndLastValuesRow(dtShowUpEco, iIndexColumnEco, out iIndexFirst, out iIndexLast);
                    if (iIndexFirst == -1)
                        continue;
                    Double dFirstCheckInPassengerTime = (int)dtShowUpEco.Rows[iIndexLast][1];
                    Double dLastCheckInPassengerTime = (int)dtShowUpEco.Rows[iIndexFirst][0];



                    int iIndexICTColumnEco;
                    DataTable dtICTEco = etICTProfile.GetInformationsColumns(0, "D_" + iIdentifiantVol.ToString(), sAirline, FlightCateg, out iIndexICTColumnEco);

                    if (iIndexICTColumnEco == -1)
                    {
                        ListeErreurs.Add("Err00468 : Flight category does not exist in the inter connecting time table. Please check your tables for mistakes.");
                        continue;
                    }

                    int iIndexFirstICT, iIndexLastICT;
                    GetFirstAndLastValuesRow(dtICTEco, iIndexICTColumnEco, out iIndexFirstICT, out iIndexLastICT);
                    if (iIndexFirst == -1)
                        continue;
                    Double dFirstICTPassengerTime = (int)dtICTEco.Rows[iIndexLastICT][1];//Bug - ShowUp used instead of ICT
                    Double dLastICTPassengerTime = (int)dtICTEco.Rows[iIndexFirstICT][0];





                    /*if (!htICT.ContainsKey(FlightCateg))
                    {
                        ListeErreurs.Add("Err00468 : Flight category does not exist in the inter connecting time table. Please check your tables for mistakes.");
                        continue;
                    }

                    Double dFirstICTPassengerTime = (int)dtICTProfile.Rows[((int[])htICT[FlightCateg])[1]][1];
                    Double dLastICTPassengerTime = (int)dtICTProfile.Rows[((int[])htICT[FlightCateg])[0]][0];
                    */
                    int iColumnBag;
                    DataTable dtTableBags = etNbBags.GetInformationsColumns(0, "D_" + iIdentifiantVol.ToString(), sAirline, FlightCateg, out iColumnBag);
                    if (dtTableBags == null)
                        continue;
                    Double dMeanBaggage = CalculCoefficientMultiplicateur(dtTableBags, iColumnBag);


                    /*if (!MeanBaggage.ContainsKey(FlightCateg))
                    {
                        ListeErreurs.Add("Err00474 : Flight category does not exist in the Baggage table. Please check your tables for mistakes.");
                        continue;
                    }
                    Double dMeanBaggage = (double)MeanBaggage[FlightCateg];
                    */

                    int iColumnSegregation;
                    DataTable dtTableSegregation = etSegregation.GetInformationsColumns(0, "D_" + iIdentifiantVol.ToString(), sAirline, FlightCateg, out iColumnSegregation);
                    if (iColumnSegregation == -1)
                    //if (!dtSegregation.Columns.Contains(FlightCateg))
                    {
                        ListeErreurs.Add("Err00475 : Flight category\"" + FlightCateg + "\" does not exist in the Segregation table. Please check your tables for mistakes.");
                        continue;
                    }

                    #region We determine the number of passengers for that flight
                    // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                    double dTotalNumberOfPassengers = OverallTools.DataFunctions.getNbPaxForFlight(drLine, etAircraftType, dtFlightCategories, etLoadFactor,
                        FlightAttribute.ARR_OR_DEP_FLIGHT_TAG.D, iIdentifiantVol, userDefinedFlightConfigurations, ListeErreurs);
                    //double dTotalNumberOfPassengers = OverallTools.DataFunctions.numberOfPassengers(drLine, etAircraftType, dtFlightCategories, etLoadFactor, ListeErreurs);

                    if (dTotalNumberOfPassengers == -1)
                    {
                        ListeErreurs.Add("Warn00470 : Line ignored \"" + iIdentifiantVol + "\". The number of passenger for that fligt is not valid.");
                        continue;
                    }
                    //We have to ignore the transferred passengers
                    Dictionary<String, String> dssLoadFactors = etLoadFactor.GetInformationsColumns(0, "D_" + iIdentifiantVol.ToString(), sAirline, FlightCateg);

                    String sOriginating = dssLoadFactors[GlobalNames.sLFD_Line_Originating];


                    //String sOriginating = DataFunctions.getValue(dtLoadFactor, GlobalNames.sLFD_Line_Originating, 0, dtLoadFactor.Columns.IndexOf(FlightCateg));
                    if (sOriginating == null)
                    {
                        ListeErreurs.Add("Err00471 : The load factor table have problems for the container calc.");
                        return null;
                    }
                    Double dOriginating;
                    if (!Double.TryParse(sOriginating, out dOriginating))
                    {
                        ListeErreurs.Add("Err00472 : The load factor value  for the originating passengers is not valid.");
                        return null;
                    }

                    Double dTransferPassenger = (dTotalNumberOfPassengers * (100 - dOriginating)) / 100.0f;
                    Double dOriginatingPassengers = (dTotalNumberOfPassengers * dOriginating) / 100.0f;
                    #endregion

                    //Double dTotalBaggage = dMeanBaggage * dTotalNumberOfPassengers;   // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                    Double dTotalBaggage = -1;
                    FlightConfiguration flightConfiguration = Tools.FlightPlanParametersTools
                            .getFlightConfigurationByArrOrDepAndFlightId(FlightAttribute.ARR_OR_DEP_FLIGHT_TAG.D, iIdentifiantVol, userDefinedFlightConfigurations);
                    if (flightConfiguration != null)
                    {
                        dTotalBaggage = flightConfiguration.flightParameter.nbOrigEcoBags + flightConfiguration.flightParameter.nbOrigFbBags +
                            flightConfiguration.flightParameter.nbTransferEcoBags + flightConfiguration.flightParameter.nbTransferFbBags;
                    }
                    else
                    {
                        dTotalBaggage = dMeanBaggage * dTotalNumberOfPassengers;
                    }

                    Double[] tdSegregationDistribution = new double[dtTableSegregation.Rows.Count];
                    Double[] tdSegregationBaggage = new double[dtTableSegregation.Rows.Count];
                    Double[] tdSegregationBaggageCurrent = new double[dtTableSegregation.Rows.Count];
                    Int32[] tiIndexContainers = new Int32[dtTableSegregation.Rows.Count];
                    //int iIndexFlightCateg = dtSegregation.Columns.IndexOf(FlightCateg);
                    for (i = 0; i < dtTableSegregation.Rows.Count; i++)
                    {
                        tdSegregationDistribution[i] = (Double)dtTableSegregation.Rows[i][iColumnSegregation];
                        tdSegregationBaggage[i] = (dTotalBaggage * tdSegregationDistribution[i]) / 100;
                        tdSegregationBaggageCurrent[i] = 0;
                        tiIndexContainers[i] = 0;
                    }

                    /* dOuvertureCI
                     * dFermetureCI
                     * dFirstCheckInPassengerTime
                     * dLastCheckInPassengerTime
                     * dFirstICTPassengerTime
                     * dLastICTPassengerTime
                     */

                    //On ajoute tous les différents bagages arrivés avant l'ouverture des Make-Up (ils étaients stockés dans l'EBS).
                    /*Double dPercentOrig = getDistribution((int)dFirstCheckInPassengerTime, tciTmp.dOpenningTime, dtShowUpProfile, FlightCateg);
                    Double dPercentTransf = getDistribution((int)dFirstICTPassengerTime, tciTmp.dOpenningTime, dtICTProfile, FlightCateg);
                    dPercentOrig = (dPercentOrig * (dOriginating / 100.0f)) * dTotalBaggage;
                    dPercentTransf = (dPercentTransf * ((100.0f - dOriginating) / 100.0f)) * dTotalBaggage;
                    AddBaggageSegregation(tdSegregationBaggageCurrent, tdSegregationDistribution, dPercentOrig + dPercentTransf);
                    */
                    Double dPercentOrig, dPercentTransf;
                    Double dClosingCurrent = fciTmp.dOpenningTime;
                    Double dOpeningCurrent = Math.Max(dFirstCheckInPassengerTime, dFirstICTPassengerTime);
                    while (dClosingCurrent > (fciTmp.dClosingTime))
                    {
                        dPercentOrig = getDistribution((int)dOpeningCurrent, (int)dClosingCurrent, dtShowUpEco, iIndexColumnEco);
                        dPercentTransf = getDistribution((int)dOpeningCurrent, (int)dClosingCurrent, dtICTEco, iIndexICTColumnEco);
                        dPercentOrig = (dPercentOrig * (dOriginating / 100.0f)) * dTotalBaggage;
                        dPercentTransf = (dPercentTransf * ((100.0f - dOriginating) / 100.0f)) * dTotalBaggage;
                        AddBaggageSegregation(tdSegregationBaggageCurrent, tdSegregationDistribution, dPercentOrig + dPercentTransf);
                        CheckBaggageSegregation(tdSegregationBaggageCurrent, tiIndexContainers, dtResults, fciTmp.iContainerSize, iIdentifiantVol, dateDepart.AddMinutes(-dClosingCurrent));
                        dOpeningCurrent = dClosingCurrent;
                        dClosingCurrent -= iPas;
                    }

                    for (i = 0; i < tdSegregationBaggageCurrent.Length; i++)
                    {
                        if (tdSegregationBaggageCurrent[i] >= 1)
                        {
                            DataRow drNewRow = dtResults.NewRow();
                            drNewRow[0] = iIdentifiantVol;
                            drNewRow[1] = i + 1;
                            tiIndexContainers[i]++;
                            drNewRow[2] = tiIndexContainers[i];
                            drNewRow[3] = dateDepart.AddMinutes(-dClosingCurrent);
                            drNewRow[4] = (int)tdSegregationBaggageCurrent[i];
                            dtResults.Rows.Add(drNewRow);
                        }
                    }
                }
                dtResults.AcceptChanges();
                return dtResults;
            }
            private static void CheckBaggageSegregation(Double[] tdResult,
                                                        Int32[] tiIndexContainer,
                                                        DataTable dtResult,
                                                        int iContainerCapacity,
                                                        int iFlightId,
                                                        DateTime dtEndTime)
            {
                //SGE : 22/06/2011 : Modification pour éviter la boucle infinie.
                if (iContainerCapacity == 0)
                    return;
                for (int i = 0; i < tdResult.Length; i++)
                {
                    while (tdResult[i] > iContainerCapacity)
                    {
                        tdResult[i] -= iContainerCapacity;
                        DataRow drNewRow = dtResult.NewRow();
                        drNewRow[0] = iFlightId;
                        drNewRow[1] = i + 1;
                        tiIndexContainer[i]++;
                        drNewRow[2] = tiIndexContainer[i];
                        drNewRow[3] = dtEndTime;
                        drNewRow[4] = iContainerCapacity;
                        dtResult.Rows.Add(drNewRow);
                    }
                }
            }
            private static void AddBaggageSegregation(Double[] tdResult, Double[] tdDistribution, Double dBaggage)
            {
                for (int i = 0; i < tdResult.Length; i++)
                {
                    tdResult[i] += (tdDistribution[i] * dBaggage) / 100.0f;
                }
            }
            #endregion

            #region Function which generate an analyse of the flight plans

            private class cFlightCategoryResult
            {
                public String sName;
                public Double dBagPerPax;

                public Double dArrLoadFactor;
                public Double dArrTransfer;

                public Int32 iArrivalFlights;
                public Double dArrivalPax;
                public Double dArrivalBags;
                public Double dArrivalTerminating;
                public Double dArrivalTransferring;
                // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                public Double arrivalTerminatingBags;
                public Double arrivalTransferringBags;
                // >> Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns

                public Double dDepLoadFactor;
                public Double dDepTransfer;
                public Int32 iDepartureFlights;
                public Double dDeparturePax;
                public Double dDepartureBags;
                public Double dDepartureOriginating;
                public Double dDepartureTransferring;
                // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                public Double departureOriginatingBags;
                public Double departureTransferringBags;
                // >> Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns

                public void AddArrivalFlight(int iArrivalFlights_, Double dArrLoadFactor_, Double dArrTransfer_, Double dArrivalPax_,
                                             Double dArrivalBags_, Double dArrivalTerminating_, Double dArrivalTransferring_,
                                             Double arrivalTerminatingBags_, Double arrivalTransferringBags_)   // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns                
                {
                    Double dArrLoadFactor_Tmp = (dArrLoadFactor + dArrLoadFactor_) / 2;

                    if (dArrivalPax + dArrivalPax_ != 0)
                    {
                        if (dArrivalPax == 0)
                            dArrLoadFactor = dArrLoadFactor_;
                        else if (dArrivalPax_ == 0)
                        {
                        }
                        else
                        {
                            Double dtmp = (dArrivalPax * 100) / dArrLoadFactor;
                            Double dtmp2 = (dArrivalPax_ * 100) / dArrLoadFactor_;
                            dArrLoadFactor = (dArrivalPax + dArrivalPax_) / (dtmp + dtmp2) * 100;
                        }
                    }


                    dArrivalPax += dArrivalPax_;
                    dArrivalTerminating += dArrivalTerminating_;
                    dArrivalTransferring += dArrivalTransferring_;
                    iArrivalFlights += iArrivalFlights_;
                    dArrivalBags += dArrivalBags_;
                    // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                    arrivalTerminatingBags += arrivalTerminatingBags_;
                    arrivalTransferringBags += arrivalTransferringBags_;
                    // >> Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns

                    dBagPerPax = 0;
                    if (dArrivalPax != 0)
                        dBagPerPax = dArrivalBags / dArrivalPax;



                    dArrTransfer = 0;
                    if (dArrivalPax > 0)
                    {
                        dArrTransfer = (dArrivalTransferring / dArrivalPax) * 100;
                    }
                }
                public void AddArrivalFlight(Double dArrLoadFactor_, Double dArrTransfer_, Double dArrivalPax_,
                                             Double dArrivalBags_, Double dArrivalTerminating_, Double dArrivalTransferring,
                                             Double arrivalTerminatingBags_, Double arrivalTransferingBags_)  // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns                
                {
                    AddArrivalFlight(1, dArrLoadFactor_, dArrTransfer_, dArrivalPax_, dArrivalBags_, dArrivalTerminating_, dArrivalTransferring,
                        arrivalTerminatingBags_, arrivalTransferingBags_);  // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns                    
                }
                public void AddDepartureFlight(int iDepartureFlights_, Double dDepLoadFactor_, Double dDepTransfer_, Double dDeparturePax_,
                             Double dDepartureBags_, Double dDepartureOriginating_, Double dDepartureTransferring_,
                             Double departureOriginatingBags_, Double departureTransferingBags_)    // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                {
                    Double dDepLoadFactor_Tmp = (dDepLoadFactor + dDepLoadFactor_) / 2;

                    if (dDeparturePax + dDeparturePax_ != 0)
                    {
                        if (dDeparturePax == 0)
                            dDepLoadFactor = dDepLoadFactor_;
                        else if (dDeparturePax_ == 0)
                        { }
                        else
                        {
                            Double dtmp = (dDeparturePax * 100) / dDepLoadFactor;
                            Double dtmp2 = (dDeparturePax_ * 100) / dDepLoadFactor_;
                            dDepLoadFactor = (dDeparturePax + dDeparturePax_) / (dtmp + dtmp2) * 100;
                        }
                    }


                    dDeparturePax += dDeparturePax_;
                    dDepartureOriginating += dDepartureOriginating_;
                    dDepartureTransferring += dDepartureTransferring_;
                    iDepartureFlights += iDepartureFlights_;
                    dDepartureBags += dDepartureBags_;
                    // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                    departureOriginatingBags += departureOriginatingBags_;
                    departureTransferringBags += departureTransferingBags_;
                    // >> Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns

                    dBagPerPax = 0;
                    if (dDeparturePax != 0)
                        dBagPerPax = dDepartureBags / dDeparturePax;

                    dDepTransfer = 0;
                    if (dDeparturePax > 0)
                    {
                        dDepTransfer = (dDepartureTransferring / dDeparturePax) * 100;
                    }
                }
                public void AddDepartureFlight(Double dDepLoadFactor_, Double dDepTransfer_, Double dDeparturePax_,
                             Double dDepartureBags_, Double dDepartureOriginating_, Double dDepartureTransferring,
                             Double departureOriginatingBags_, Double departureTransferingBags_)    // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                {
                    AddDepartureFlight(1, dDepLoadFactor_, dDepTransfer_, dDeparturePax_,
                        dDepartureBags_, dDepartureOriginating_, dDepartureTransferring,
                        departureOriginatingBags_, departureTransferingBags_);  // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                }

                public cFlightCategoryResult(String sName_)
                {
                    sName = sName_;
                    dBagPerPax = 0;
                    dArrLoadFactor = 0;
                    dArrTransfer = 0;

                    iArrivalFlights = 0;
                    dArrivalPax = 0;
                    dArrivalBags = 0;
                    dArrivalTerminating = 0;
                    dArrivalTransferring = 0;
                    // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                    arrivalTerminatingBags = 0;
                    arrivalTransferringBags = 0;
                    // >> Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns

                    iDepartureFlights = 0;
                    dDeparturePax = 0;
                    dDepartureBags = 0;
                    dDepartureOriginating = 0;
                    dDepartureTransferring = 0;
                    // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                    departureOriginatingBags = 0;
                    departureTransferringBags = 0;
                    // >> Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                }
                public static cFlightCategoryResult operator +(cFlightCategoryResult cfcrTmp1, cFlightCategoryResult cfcrTmp2)
                {
                    cFlightCategoryResult cfcrResult = new cFlightCategoryResult(cfcrTmp1.sName);

                    cfcrResult.dArrivalPax = cfcrTmp1.dArrivalPax + cfcrTmp2.dArrivalPax;
                    cfcrResult.dArrivalTerminating = cfcrTmp1.dArrivalTerminating + cfcrTmp2.dArrivalTerminating;
                    cfcrResult.dArrivalTransferring = cfcrTmp1.dArrivalTransferring + cfcrTmp2.dArrivalTransferring;
                    cfcrResult.iArrivalFlights = cfcrTmp1.iArrivalFlights + cfcrTmp2.iArrivalFlights;
                    cfcrResult.dArrivalBags = cfcrTmp1.dArrivalBags + cfcrTmp2.dArrivalBags;
                    // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                    cfcrResult.arrivalTerminatingBags = cfcrTmp1.arrivalTerminatingBags + cfcrTmp2.arrivalTerminatingBags;
                    cfcrResult.arrivalTransferringBags = cfcrTmp1.arrivalTransferringBags + cfcrTmp2.arrivalTransferringBags;
                    // >> Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns

                    cfcrResult.dDeparturePax = cfcrTmp1.dDeparturePax + cfcrTmp2.dDeparturePax;
                    cfcrResult.dDepartureBags = cfcrTmp1.dDepartureBags + cfcrTmp2.dDepartureBags;
                    cfcrResult.dDepartureOriginating = cfcrTmp1.dDepartureOriginating + cfcrTmp2.dDepartureOriginating;
                    cfcrResult.dDepartureTransferring = cfcrTmp1.dDepartureTransferring + cfcrTmp2.dDepartureTransferring;
                    cfcrResult.iDepartureFlights = cfcrTmp1.iDepartureFlights + cfcrTmp2.iDepartureFlights;
                    // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                    cfcrResult.departureOriginatingBags = cfcrTmp1.departureOriginatingBags + cfcrTmp2.departureOriginatingBags;
                    cfcrResult.departureTransferringBags = cfcrTmp1.departureTransferringBags + cfcrTmp2.departureTransferringBags;
                    // >> Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns


                    cfcrResult.dArrLoadFactor = (cfcrTmp1.dArrLoadFactor + cfcrTmp2.dArrLoadFactor) / 2;
                    if (cfcrTmp1.dArrivalPax == 0)
                    {
                        cfcrResult.dArrLoadFactor = cfcrTmp2.dArrLoadFactor;
                    }
                    else if (cfcrTmp2.dArrivalPax == 0)
                    {
                        cfcrResult.dArrLoadFactor = cfcrTmp1.dArrLoadFactor;
                    }
                    else if (((cfcrTmp1.dArrivalPax + cfcrTmp2.dArrivalPax) != 0) &&
                        (cfcrTmp1.dArrLoadFactor != 0) && (cfcrTmp2.dArrLoadFactor != 0))
                    {
                        Double dtmp = (cfcrTmp1.dArrivalPax * 100) / cfcrTmp1.dArrLoadFactor;
                        Double dtmp2 = (cfcrTmp2.dArrivalPax * 100) / cfcrTmp2.dArrLoadFactor;
                        cfcrResult.dArrLoadFactor = (cfcrTmp1.dArrivalPax + cfcrTmp2.dArrivalPax) / (dtmp + dtmp2) * 100;
                    }

                    cfcrResult.dArrTransfer = 0;
                    if (cfcrTmp1.dArrivalPax == 0)
                    {
                        cfcrResult.dArrTransfer = cfcrTmp2.dArrTransfer;
                    }
                    else if (cfcrTmp2.dArrivalPax == 0)
                    {
                        cfcrResult.dArrTransfer = cfcrTmp1.dArrTransfer;
                    }
                    else if (cfcrResult.dArrivalPax > 0)
                    {
                        cfcrResult.dArrTransfer = (cfcrResult.dArrivalTransferring / cfcrResult.dArrivalPax) * 100;
                    }

                    cfcrResult.dBagPerPax = 0;
                    if (cfcrResult.dArrivalPax != 0)
                        cfcrResult.dBagPerPax = cfcrResult.dArrivalBags / cfcrResult.dArrivalPax;

                    cfcrResult.dDepLoadFactor = (cfcrTmp1.dDepLoadFactor + cfcrTmp2.dDepLoadFactor) / 2;
                    if (cfcrTmp1.dDeparturePax == 0)
                    {
                        cfcrResult.dDepLoadFactor = cfcrTmp2.dDepLoadFactor;
                    }
                    else if (cfcrTmp2.dDeparturePax == 0)
                    {
                        cfcrResult.dDepLoadFactor = cfcrTmp1.dDepLoadFactor;
                    }
                    else if (((cfcrTmp1.dDeparturePax + cfcrTmp2.dDeparturePax) != 0) &&
                        (cfcrTmp1.dDepLoadFactor != 0) && (cfcrTmp2.dDepLoadFactor != 0))
                    {
                        Double dtmp = (cfcrTmp1.dDeparturePax * 100) / cfcrTmp1.dDepLoadFactor;
                        Double dtmp2 = (cfcrTmp2.dDeparturePax * 100) / cfcrTmp2.dDepLoadFactor;
                        cfcrResult.dDepLoadFactor = ((cfcrTmp1.dDeparturePax + cfcrTmp2.dDeparturePax) / (dtmp + dtmp2)) * 100;
                    }

                    if (cfcrResult.dDeparturePax != 0)
                        cfcrResult.dBagPerPax = cfcrResult.dDepartureBags / cfcrResult.dDeparturePax;

                    if (cfcrTmp1.dDeparturePax == 0)
                    {
                        cfcrResult.dDepTransfer = cfcrTmp2.dDepTransfer;
                    }
                    else if (cfcrTmp2.dDeparturePax == 0)
                    {
                        cfcrResult.dDepTransfer = cfcrTmp1.dDepTransfer;
                    }
                    else if (cfcrResult.dDeparturePax > 0)
                    {
                        cfcrResult.dDepTransfer = (cfcrResult.dDepartureTransferring / cfcrResult.dDeparturePax) * 100;
                    }


                    return cfcrResult;
                }
            }

            internal static DataTable getDistribution(DateTime dtStartDate,
                                              DateTime dtEndDate,
                                              DataTable dtFPDTable,
                                              DataTable dtFPATable,
                                              DataTable dtFlightCategorie,
                                              DataManagement.NormalTable dtAircraftTypes,
                                              DataManagement.NormalTable dtFPDLoadFactors,
                                              DataManagement.NormalTable dtFPALoadFactors,
                                              DataManagement.NormalTable dtNbBagsTable,
                                              String sColumnDistribution,
                                              List<FlightConfiguration> userDefinedFlightConfigurations,
                                              out int iNbAirline,
                                              ArrayList alErrors)
            {
                int i = 0;
                iNbAirline = 0;
                //<<Statistic tables 
                bool isArrival = (dtFPATable != null);
                bool isDeparture = (dtFPDTable != null);
                //>>Statistic tables 
                #region Vérification des données passées en entrée
                if ((dtStartDate >= dtEndDate) ||
                   ((dtFPDTable == null) && (dtFPATable == null)) ||    //>>Statistic tables 
                   (dtFlightCategorie == null) ||
                   (dtAircraftTypes == null) ||
                   (isDeparture && dtFPDLoadFactors == null) ||
                   (isArrival && dtFPALoadFactors == null) ||
                   (dtNbBagsTable == null))
                {
                    return null;
                }
                DataManagement.ExceptionTable etAircraftTypes;
                if (dtAircraftTypes is DataManagement.ExceptionTable)
                    etAircraftTypes = (DataManagement.ExceptionTable)dtAircraftTypes;
                else
                    return null;

                DataManagement.ExceptionTable etFPDLoadFactors = null;
                if (isDeparture)
                {
                    if (dtFPDLoadFactors is DataManagement.ExceptionTable)
                        etFPDLoadFactors = (DataManagement.ExceptionTable)dtFPDLoadFactors;
                    else
                        return null;
                }

                DataManagement.ExceptionTable etFPALoadFactors = null;
                if (isArrival)
                {
                    if (dtFPALoadFactors is DataManagement.ExceptionTable)
                        etFPALoadFactors = (DataManagement.ExceptionTable)dtFPALoadFactors;
                    else
                        return null;
                }

                DataManagement.ExceptionTable etNbBagsTable;
                if (dtNbBagsTable is DataManagement.ExceptionTable)
                    etNbBagsTable = (DataManagement.ExceptionTable)dtNbBagsTable;
                else
                    return null;

                //<<Statistic tables 
                int iIndexIDFPA = 0;
                int iIndexIDFPD = 0;
                int iIndexAirlineFPA = 0;
                int iIndexAirlineFPD = 0;
                int iIndexFCFPA = 0;
                int iIndexFCFPD = 0;
                int iIndexDateFPA = 0;
                int iIndexDateFPD = 0;
                int iIndexTimeFPA = 0;
                int iIndexTimeFPD = 0;

                if (isArrival)
                {
                    iIndexIDFPA = dtFPATable.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID);
                    iIndexAirlineFPA = dtFPATable.Columns.IndexOf(GlobalNames.sFPD_A_Column_AirlineCode);
                    iIndexFCFPA = dtFPATable.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightCategory);
                    iIndexDateFPA = dtFPATable.Columns.IndexOf(GlobalNames.sFPD_A_Column_DATE);
                    iIndexTimeFPA = dtFPATable.Columns.IndexOf(GlobalNames.sFPA_Column_STA);
                }
                if (isDeparture)
                {
                    iIndexIDFPD = dtFPDTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID);
                    iIndexAirlineFPD = dtFPDTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_AirlineCode);
                    iIndexFCFPD = dtFPDTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightCategory);
                    iIndexDateFPD = dtFPDTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_DATE);
                    iIndexTimeFPD = dtFPDTable.Columns.IndexOf(GlobalNames.sFPD_Column_STD);
                }
                //>>Statistic tables 
                if ((iIndexIDFPA == -1) ||
                    (iIndexIDFPD == -1) ||
                    (iIndexAirlineFPA == -1) ||
                    (iIndexAirlineFPD == -1) ||
                    (iIndexFCFPA == -1) ||
                    (iIndexFCFPD == -1) ||
                    (iIndexDateFPA == -1) ||
                    (iIndexDateFPD == -1) ||
                    (iIndexTimeFPA == -1) ||
                    (iIndexTimeFPD == -1))
                {
                    return null;
                }
                #endregion

                #region To know the different terminal used by the flight plan.
                //<<Statistic tables 
                int iIndexTerminalGate = 0;
                if (isDeparture)
                    iIndexTerminalGate = dtFPDTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_TerminalGate);
                else
                    iIndexTerminalGate = dtFPATable.Columns.IndexOf(GlobalNames.sFPD_A_Column_TerminalGate);
                //>>Statistic tables
                int iNbTerminal = FonctionUtiles.CountTerminalGate(dtFPDTable);
                int iNbTerminalArr = FonctionUtiles.CountTerminalGate(dtFPATable);
                if (iNbTerminalArr > iNbTerminal)
                    iNbTerminal = iNbTerminalArr;
                if ((iNbTerminal == 0) || (iIndexTerminalGate == -1))
                    return null;
                ///First Dimension : Index of the terminal
                ///Second dimension is a dictionnary with :
                ///         First dimension : The name of the flight category / Airline / Ground handler
                ///         Second dimention : information about the flight category / Airline / ground handler (\ref cFlightCategoryResult)
                Dictionary<Int32, Dictionary<String, cFlightCategoryResult>> htResults = new Dictionary<Int32, Dictionary<String, cFlightCategoryResult>>();
                for (i = 1; i <= iNbTerminal; i++)
                {
                    htResults.Add(i, new Dictionary<String, cFlightCategoryResult>());
                }
                List<String> alOrder = new List<String>();
                bool bAirline = true;
                if (sColumnDistribution == GlobalNames.sFPD_A_Column_FlightCategory)
                {
                    bAirline = false;
                    foreach (DataRow drLine in dtFlightCategorie.Rows)
                    {
                        alOrder.Add(drLine[0].ToString());
                    }
                }
                #endregion
                if (dtFPDTable != null)     //<<Statistic tables 
                {
                    foreach (DataRow ligne in dtFPDTable.Rows)
                    {
                        //On récupère l'identifiant du vol.
                        String iIdentifiantVol = ligne.ItemArray[iIndexIDFPD].ToString();
                        //Heure de départ du vol.
                        DateTime dateDepart = DataFunctions.toDateTime(ligne.ItemArray[iIndexDateFPD], ligne.ItemArray[iIndexTimeFPD]);
                        if ((dateDepart < dtStartDate) || (dateDepart > dtEndDate))
                        {
                            alErrors.Add("Warn00133 : Line ignored \"" + iIdentifiantVol + "\" doesn't match the range");
                            continue;
                        }
                        String FlightCateg = ligne[iIndexFCFPD].ToString();

                        String sAirline = ligne[iIndexAirlineFPD].ToString();

                        #region We determine the number of passengers for that flight                        
                        // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                        //double dTotalNumberOfPassengers = OverallTools.DataFunctions.numberOfPassengers(ligne, etAircraftTypes, dtFlightCategorie, etFPDLoadFactors, alErrors);
                        double dTotalNumberOfPassengers = OverallTools.DataFunctions.getNbPaxForFlight(ligne, etAircraftTypes, dtFlightCategorie, etFPDLoadFactors,
                            FlightAttribute.ARR_OR_DEP_FLIGHT_TAG.D, Convert.ToInt32(iIdentifiantVol), userDefinedFlightConfigurations, alErrors);
                        if (dTotalNumberOfPassengers == -1)
                        {
                            alErrors.Add("Warn00135 : Line ignored \"" + iIdentifiantVol + "\". The number of passenger for that fligt is not valid.");
                            continue;
                        }
                        //We have to ignore the transferred passengers

                        Dictionary<String, String> dssResultEco = etFPDLoadFactors.GetInformationsColumns(0, "D_" + iIdentifiantVol, sAirline, FlightCateg);
                        //Dictionary<String,String>dssResultFirst = etFPDLoadFactors.GetInformationsColumns(1, iIdentifiantVol, sAirline, FlightCateg);
                        if (dssResultEco == null)
                        {
                            continue;
                        }

                        String sOriginating = dssResultEco[GlobalNames.sLFD_Line_Originating];
                        if (sOriginating == null)
                        {
                            alErrors.Add("Err00136 : The load factor table have problems.");
                            return null;
                        }
                        Double dOriginating;
                        if (!Double.TryParse(sOriginating, out dOriginating))
                        {
                            alErrors.Add("Err00137 : The load factor value  for the originating passengers is not valid.");
                            return null;
                        }
                        FlightConfiguration flightConfiguration = Tools.FlightPlanParametersTools
                            .getFlightConfigurationByArrOrDepAndFlightId(FlightAttribute.ARR_OR_DEP_FLIGHT_TAG.D, Convert.ToInt32(iIdentifiantVol),
                                                                            userDefinedFlightConfigurations);
                        Double totalNbOfTransferPassengers = -1;
                        Double totalNbOfOriginatingPassengers = -1;
                        if (flightConfiguration != null)    // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                        {
                            totalNbOfOriginatingPassengers = flightConfiguration.flightParameter.nbOrigEcoPax + flightConfiguration.flightParameter.nbOrigFbPax;
                            totalNbOfTransferPassengers = flightConfiguration.flightParameter.nbTransferEcoPax + flightConfiguration.flightParameter.nbTransferFbPax;
                        }
                        else
                        {
                            totalNbOfTransferPassengers = (dTotalNumberOfPassengers * (100 - dOriginating)) / 100.0f;
                            totalNbOfOriginatingPassengers = (dTotalNumberOfPassengers * dOriginating) / 100.0f;
                        }
                        #endregion
                        int iTerminal;
                        if (!Int32.TryParse(ligne[iIndexTerminalGate].ToString(), out iTerminal))
                            continue;

                        int iColumn;
                        DataTable dtTable = etNbBagsTable.GetInformationsColumns(0, "D_" + iIdentifiantVol, sAirline, FlightCateg, out iColumn);
                        if (dtTable == null)
                            continue;
                        Double dMeanBaggage = -1;
                        double dMeanTransferBaggage = -1;
                        double dMeanOriginatingBaggage = -1;
                        double dMeanTotalBaggage = -1;
                        if (flightConfiguration != null)    // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                        {
                            double totalNbOriginatingBags = flightConfiguration.flightParameter.nbOrigEcoBags + flightConfiguration.flightParameter.nbOrigFbBags;
                            double totalNbTransferringBags = flightConfiguration.flightParameter.nbTransferEcoBags + flightConfiguration.flightParameter.nbTransferFbBags;
                            if (dTotalNumberOfPassengers == 0)
                            {
                                dMeanTotalBaggage = 0;
                            }
                            else
                            {
                                dMeanTotalBaggage = (totalNbOriginatingBags + totalNbTransferringBags) / dTotalNumberOfPassengers;
                            }
                            if (totalNbOfOriginatingPassengers == 0)
                            {
                                dMeanOriginatingBaggage = 0;
                            }
                            else
                            {
                                dMeanOriginatingBaggage = totalNbOriginatingBags / totalNbOfOriginatingPassengers;
                            }
                            if (totalNbOfTransferPassengers == 0)
                            {
                                dMeanTransferBaggage = 0;
                            }
                            else
                            {
                                dMeanTransferBaggage = totalNbTransferringBags / totalNbOfTransferPassengers;
                            }
                        }
                        else
                        {
                            dMeanBaggage = CalculCoefficientMultiplicateur(dtTable, iColumn);
                        }
                        String sKey = FlightCateg;
                        if (bAirline)
                            sKey = sAirline;
                        if (!htResults[iTerminal].ContainsKey(sKey))
                        {
                            htResults[iTerminal].Add(sKey, new cFlightCategoryResult(sKey));
                            if (!alOrder.Contains(sKey))
                                alOrder.Add(sKey);
                        }
                        cFlightCategoryResult cfcrTmp = htResults[iTerminal][sKey];

                        String sFull = dssResultEco[GlobalNames.sLFD_A_Line_Full];
                        if (sFull == null)
                        {
                            return null;
                        }
                        Double dFull;
                        if (!Double.TryParse(sFull, out dFull))
                        {
                            return null;
                        }

                        String sTranfering = dssResultEco[GlobalNames.sLFD_A_Line_Transferring];
                        if (sTranfering == null)
                        {
                            return null;
                        }
                        Double dTranfering;
                        if (!Double.TryParse(sTranfering, out dTranfering))
                        {
                            return null;
                        }
                        if (flightConfiguration != null)
                        {
                            dFull = 100;
                            dTranfering = 0;
                            if (dTotalNumberOfPassengers > 0)
                            {
                                dTranfering = Math.Round(totalNbOfTransferPassengers / dTotalNumberOfPassengers, 3);
                            }
                            cfcrTmp.AddDepartureFlight(dFull, dTranfering, dTotalNumberOfPassengers,
                                   dTotalNumberOfPassengers * dMeanTotalBaggage, totalNbOfOriginatingPassengers, totalNbOfTransferPassengers,
                                   totalNbOfOriginatingPassengers * dMeanOriginatingBaggage, totalNbOfTransferPassengers * dMeanTransferBaggage);
                        }
                        else
                        {
                            cfcrTmp.AddDepartureFlight(dFull, dTranfering, dTotalNumberOfPassengers,
                                dTotalNumberOfPassengers * dMeanBaggage, totalNbOfOriginatingPassengers, totalNbOfTransferPassengers,
                                totalNbOfOriginatingPassengers * dMeanBaggage, totalNbOfTransferPassengers * dMeanBaggage);  // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                        }
                    }
                }
                //iIndexTerminalGate = dtFPATable.Columns.IndexOf(GlobalNames.sFPD_A_Column_TerminalGate);
                if (dtFPATable != null)     //<<Statistic tables 
                {
                    iIndexTerminalGate = dtFPATable.Columns.IndexOf(GlobalNames.sFPD_A_Column_TerminalGate);
                    foreach (DataRow ligne in dtFPATable.Rows)
                    {
                        //On récupère l'identifiant du vol.
                        String iIdentifiantVol = ligne.ItemArray[iIndexIDFPA].ToString();
                        //Heure de départ du vol.
                        DateTime dateDepart = DataFunctions.toDateTime(ligne.ItemArray[iIndexDateFPA], ligne.ItemArray[iIndexTimeFPA]);
                        if ((dateDepart < dtStartDate) || (dateDepart > dtEndDate))
                        {
                            alErrors.Add("Warn00138 : Line ignored \"" + iIdentifiantVol + "\" doesn't match the range");
                            continue;
                        }
                        String FlightCateg = ligne[iIndexFCFPA].ToString();
                        String sAirline = ligne[iIndexAirlineFPA].ToString();
                        #region We determine the number of passengers for that flight
                        // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                        //double dTotalNumberOfPassengers = OverallTools.DataFunctions.numberOfPassengers(ligne, etAircraftTypes, dtFlightCategorie, etFPALoadFactors, alErrors);
                        double dTotalNumberOfPassengers = OverallTools.DataFunctions.getNbPaxForFlight(ligne, etAircraftTypes, dtFlightCategorie, etFPALoadFactors,
                            FlightAttribute.ARR_OR_DEP_FLIGHT_TAG.A, Convert.ToInt32(iIdentifiantVol), userDefinedFlightConfigurations, alErrors);
                        if (dTotalNumberOfPassengers == -1)
                        {
                            alErrors.Add("Warn00139 : Line ignored \"" + iIdentifiantVol + "\". The number of passenger for that fligt is not valid.");
                            continue;
                        }
                        //We have to ignore the transferred passengers
                        Dictionary<String, String> dssResult = etFPALoadFactors.GetInformationsColumns(0, "A_" + iIdentifiantVol, sAirline, FlightCateg);

                        String sTerminating = dssResult[GlobalNames.sLFA_Line_Terminating];
                        if (sTerminating == null)
                        {
                            alErrors.Add("Err00140 : The load factor table have problems.");
                            return null;
                        }
                        Double dTerminating;
                        if (!Double.TryParse(sTerminating, out dTerminating))
                        {
                            alErrors.Add("Err00141 : The load factor value  for the originating passengers is not valid.");
                            return null;
                        }
                        FlightConfiguration flightConfiguration = Tools.FlightPlanParametersTools
                            .getFlightConfigurationByArrOrDepAndFlightId(FlightAttribute.ARR_OR_DEP_FLIGHT_TAG.A, Convert.ToInt32(iIdentifiantVol),
                                                                            userDefinedFlightConfigurations);
                        Double totalNbOfTransferPassengers = -1;
                        Double totalNbOfTerminatingPassengers = -1;
                        if (flightConfiguration != null)
                        {
                            totalNbOfTerminatingPassengers = flightConfiguration.flightParameter.nbTermEcoPax + flightConfiguration.flightParameter.nbTermFbPax;
                            totalNbOfTransferPassengers = flightConfiguration.flightParameter.nbTransferEcoPax + flightConfiguration.flightParameter.nbTransferFbPax;
                        }
                        else
                        {
                            totalNbOfTerminatingPassengers = (dTotalNumberOfPassengers * dTerminating) / 100.0f;
                            totalNbOfTransferPassengers = (dTotalNumberOfPassengers * (100 - dTerminating)) / 100.0f;
                        }
                        #endregion
                        int iTerminal;
                        if (!Int32.TryParse(ligne[iIndexTerminalGate].ToString(), out iTerminal))
                            continue;
                        int iColumn;
                        DataTable dtTable = etNbBagsTable.GetInformationsColumns(0, "A_" + iIdentifiantVol, sAirline, FlightCateg, out iColumn);
                        if (dtTable == null)
                            continue;
                        Double dMeanBaggage = -1;
                        double dMeanTransferBaggage = -1;
                        double dMeanTerminatingBaggage = -1;
                        double dMeanTotalBaggage = -1;
                        if (flightConfiguration != null)    // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                        {
                            double totalNbTerminatingBags = flightConfiguration.flightParameter.nbTermEcoBags + flightConfiguration.flightParameter.nbTermFbBags;
                            double totalNbTransferringBags = flightConfiguration.flightParameter.nbTransferEcoBags + flightConfiguration.flightParameter.nbTransferFbBags;
                            if (dTotalNumberOfPassengers == 0)
                            {
                                dMeanTotalBaggage = 0;
                            }
                            else
                            {
                                dMeanTotalBaggage = (totalNbTerminatingBags + totalNbTransferringBags) / dTotalNumberOfPassengers;
                            }
                            if (totalNbTerminatingBags == 0)
                            {
                                dMeanTerminatingBaggage = 0;
                            }
                            else
                            {
                                dMeanTerminatingBaggage = totalNbTerminatingBags / totalNbOfTerminatingPassengers;
                            }
                            if (totalNbOfTransferPassengers == 0)
                            {
                                dMeanTransferBaggage = 0;
                            }
                            else
                            {
                                dMeanTransferBaggage = totalNbTransferringBags / totalNbOfTransferPassengers;
                            }
                        }
                        else
                        {
                            dMeanBaggage = CalculCoefficientMultiplicateur(dtTable, iColumn);
                        }

                        String sKey = FlightCateg;
                        if (bAirline)
                            sKey = sAirline;
                        if (!htResults[iTerminal].ContainsKey(sKey))
                        {
                            htResults[iTerminal].Add(sKey, new cFlightCategoryResult(sKey));
                            if (!alOrder.Contains(sKey))
                                alOrder.Add(sKey);
                        }
                        cFlightCategoryResult cfcrTmp = htResults[iTerminal][sKey];

                        String sFull = dssResult[GlobalNames.sLFD_A_Line_Full];
                        if (sFull == null)
                        {
                            return null;
                        }
                        Double dFull;
                        if (!Double.TryParse(sFull, out dFull))
                        {
                            return null;
                        }

                        String sTranfering = dssResult[GlobalNames.sLFD_A_Line_Transferring];
                        if (sTranfering == null)
                        {
                            return null;
                        }
                        Double dTranfering;
                        if (!Double.TryParse(sTranfering, out dTranfering))
                        {
                            return null;
                        }
                        if (flightConfiguration != null)    // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                        {
                            dFull = 100;
                            dTranfering = 0;
                            if (dTotalNumberOfPassengers > 0)
                            {
                                dTranfering = Math.Round(totalNbOfTransferPassengers / dTotalNumberOfPassengers, 3);
                            }
                            cfcrTmp.AddArrivalFlight(dFull, dTranfering, dTotalNumberOfPassengers,
                                dTotalNumberOfPassengers * dMeanTotalBaggage, totalNbOfTerminatingPassengers, totalNbOfTransferPassengers,
                                totalNbOfTerminatingPassengers * dMeanTerminatingBaggage, totalNbOfTransferPassengers * dMeanTransferBaggage);
                        }
                        else
                        {
                            cfcrTmp.AddArrivalFlight(dFull, dTranfering, dTotalNumberOfPassengers,
                                dTotalNumberOfPassengers * dMeanBaggage, totalNbOfTerminatingPassengers, totalNbOfTransferPassengers,
                                totalNbOfTerminatingPassengers * dMeanBaggage, totalNbOfTransferPassengers * dMeanBaggage);  // >> Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                        }
                    }
                }

                /*-------------------------------------*/

                DataTable dtResult = new DataTable("Airport Statistics");
                if (bAirline)
                    dtResult.TableName = "Airline Statistics";
                //<<Statistic tables
                if (isArrival != isDeparture)
                    if (isArrival)
                        dtResult.TableName = "FPA_" + dtResult.TableName;
                    else
                        dtResult.TableName = "FPD_" + dtResult.TableName;
                //>>Statistic tables 
                dtResult.Columns.Add("Terminal", typeof(String));
                if (bAirline)
                    dtResult.Columns.Add("Airline Code", typeof(String));
                else
                    dtResult.Columns.Add("Flight category", typeof(String));
                dtResult.Columns.Add("BPP", typeof(Double));
                //<<Statistic tables 
                if (isArrival)
                {
                    dtResult.Columns.Add("Arr_SeatUse", typeof(Double));
                    dtResult.Columns.Add("Arr_Transfer", typeof(Double));
                    dtResult.Columns.Add("Arr_FLT", typeof(Int32));
                    dtResult.Columns.Add("Arr_Pax", typeof(Int32));
                    dtResult.Columns.Add("Arr_Bags", typeof(Int32));
                    dtResult.Columns.Add("Arr_TE", typeof(Int32));
                    // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                    //dtResult.Columns.Add("Arr_TR", typeof(Int32));
                    dtResult.Columns.Add("Arr_TE_Bags", typeof(Int32));
                    dtResult.Columns.Add("Arr_TR", typeof(Int32));
                    dtResult.Columns.Add("Arr_TR_Bags", typeof(Int32));
                    // >> Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                }
                if (isDeparture)
                {
                    dtResult.Columns.Add("Dep_SeatUse", typeof(Double));
                    dtResult.Columns.Add("Dep_Transfer", typeof(Double));
                    dtResult.Columns.Add("Dep_FLT", typeof(Int32));
                    dtResult.Columns.Add("Dep_PAX", typeof(Int32));
                    dtResult.Columns.Add("Dep_Bags", typeof(Int32));
                    dtResult.Columns.Add("Dep_CI", typeof(Int32));
                    // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns                    
                    //dtResult.Columns.Add("Dep_TR", typeof(Int32));
                    dtResult.Columns.Add("Dep_CI_Bags", typeof(Int32));
                    dtResult.Columns.Add("Dep_TR", typeof(Int32));
                    dtResult.Columns.Add("Dep_TR_Bags", typeof(Int32));
                    // >> Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                }
                //>>Statistic tables
                cFlightCategoryResult cfcrTotal;
                DataRow drnewLine;
                Dictionary<String, cFlightCategoryResult> htGlobal = new Dictionary<String, cFlightCategoryResult>();
                //<<Statistic tables 
                Dictionary<String, String> departureColumnDictionary = new Dictionary<String, String>()
                    {
                        {"Dep_FLT", "%_Nb Dep_FLT"},
                        {"Dep_PAX", "%_Nb Dep_PAX"},
                        {"Dep_Bags", "%_Nb Dep_Bags"},
                        {"Dep_CI", "%_Nb Dep_CI"},
                        {"Dep_CI_Bags", "%_Nb Dep_CI_bags"},    // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                        {"Dep_TR", "%_Nb Dep_TR"},
                        {"Dep_TR_Bags", "%_Nb Dep_TR_Bags"}     // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                    };
                Dictionary<String, String> arrivalColumnDictionary = new Dictionary<String, String>()
                    {
                        {"Arr_FLT", "%_Nb Arr_FLT"},
                        {"Arr_PAX", "%_Nb Arr_PAX"},
                        {"Arr_Bags", "%_Nb Arr_Bags"},
                        {"Arr_TE", "%_Nb Arr_TE"},
                        {"Arr_TE_Bags", "%_Nb Arr_TE_Bags"},    // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                        {"Arr_TR", "%_Nb Arr_TR"},
                        {"Arr_TR_Bags", "%_Nb Arr_TR_Bags"}     // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                    };
                //>>Statistic tables
                if (bAirline)
                    alOrder.Sort();
                for (i = 1; i <= iNbTerminal; i++)
                {
                    cfcrTotal = new cFlightCategoryResult("Total");
                    foreach (String sFC in alOrder)
                    {
                        if (!htResults[i].ContainsKey(sFC))
                        {
                            drnewLine = dtResult.NewRow();
                            PrintLineAirportStatistics(drnewLine, new cFlightCategoryResult(sFC), i.ToString(), isArrival, isDeparture);
                            dtResult.Rows.Add(drnewLine);
                            continue;
                        }
                        if (!htGlobal.ContainsKey(sFC))
                        {
                            htGlobal.Add(sFC, new cFlightCategoryResult(sFC));
                        }
                        cFlightCategoryResult cfcrTmp = (cFlightCategoryResult)htResults[i][sFC];
                        cfcrTotal += cfcrTmp;
                        cFlightCategoryResult cfcrTmp2 = ((cFlightCategoryResult)htGlobal[sFC]);
                        cfcrTmp2 += cfcrTmp;
                        htGlobal[sFC] = cfcrTmp2;
                        drnewLine = dtResult.NewRow();
                        PrintLineAirportStatistics(drnewLine, cfcrTmp, i.ToString(), isArrival, isDeparture);
                        dtResult.Rows.Add(drnewLine);
                    }
                    htResults[i].Clear();
                    drnewLine = dtResult.NewRow();
                    PrintLineAirportStatistics(drnewLine, cfcrTotal, i.ToString(), isArrival, isDeparture);
                    dtResult.Rows.Add(drnewLine);
                }
                cfcrTotal = new cFlightCategoryResult("Total");
                foreach (String sFC in alOrder)
                {
                    if (!htGlobal.ContainsKey(sFC))
                    {
                        drnewLine = dtResult.NewRow();
                        PrintLineAirportStatistics(drnewLine, new cFlightCategoryResult(sFC), "T", isArrival, isDeparture);
                        dtResult.Rows.Add(drnewLine);
                        continue;
                    }
                    cFlightCategoryResult cfcrTmp = htGlobal[sFC];
                    cfcrTotal += cfcrTmp;
                    drnewLine = dtResult.NewRow();
                    PrintLineAirportStatistics(drnewLine, cfcrTmp, "Airport Total", isArrival, isDeparture);
                    dtResult.Rows.Add(drnewLine);
                }
                drnewLine = dtResult.NewRow();
                PrintLineAirportStatistics(drnewLine, cfcrTotal, "Airport Total", isArrival, isDeparture);
                dtResult.Rows.Add(drnewLine);
                iNbAirline = alOrder.Count;

                //<<Statistic tables 
                #region add distribution columns
                int startRow = 0;
                for (int j = 0; j < dtResult.Rows.Count; j++)
                {
                    String rowType = "";
                    rowType = dtResult.Rows[j][1].ToString();
                    if (rowType == "Total")
                    {
                        if (isDeparture)
                        {
                            addPercentageDistributionColumns(dtResult, departureColumnDictionary, startRow, j - 1);
                            roundSumColumn(dtResult, dtResult.Rows[j], departureColumnDictionary, startRow, j - 1);
                        }
                        if (isArrival)
                        {
                            addPercentageDistributionColumns(dtResult, arrivalColumnDictionary, startRow, j - 1);
                            roundSumColumn(dtResult, dtResult.Rows[j], arrivalColumnDictionary, startRow, j - 1);
                        }
                        startRow = j + 1;
                    }
                }
                #endregion
                //>>Statistic tables

                dtResult.AcceptChanges();
                return dtResult;
            }

            //<<Statistic tables
            private static void addPercentageDistributionColumns(DataTable dtResult, Dictionary<String, String> arrDepColumnDict,
                                                                 int startRow, int endRow)
            {
                foreach (var pair in arrDepColumnDict)
                {
                    int colIndex = dtResult.Columns.IndexOf(pair.Key);
                    if (colIndex != -1)
                        ResultFunctions.GenerateRepartition(dtResult, colIndex, pair.Value, null, startRow, endRow);
                }
            }

            private static void roundSumColumn(DataTable dtResult, DataRow drnewLine, Dictionary<String, String> arrDepColumnDict,
                                               int startRow, int endRow)
            {
                foreach (var pair in arrDepColumnDict)
                {
                    if (dtResult.Columns.IndexOf(pair.Value) != -1)
                    {
                        double totalPerc = DataFunctions.SumColumn(dtResult, pair.Value, startRow, endRow);
                        if (totalPerc > 100)
                            totalPerc = Math.Floor(totalPerc);
                        else
                            totalPerc = Math.Ceiling(totalPerc);
                        drnewLine[dtResult.Columns.IndexOf(pair.Value)] = totalPerc;
                    }
                }

            }
            //<<Statistic tables

            public static DataTable getHandlingAgentDistribution(DataTable dtAirlineDistribution,
                                              DataTable dtAirlineCodesTable,
                                              out int iNbHandligne,
                                              ArrayList alErrors)
            {
                iNbHandligne = 0;
                //<<Statistic tables 
                int iIndexFPDColumn = dtAirlineDistribution.Columns.IndexOf("Dep_SeatUse");
                int iIndexFPAColumn = dtAirlineDistribution.Columns.IndexOf("Arr_SeatUse");

                bool isDeparture = (iIndexFPDColumn != -1);
                bool isArrival = (iIndexFPAColumn != -1);

                if (!isArrival && !isDeparture)
                    return null;
                //>>Statistic tables
                int iIndexAirline = dtAirlineCodesTable.Columns.IndexOf(GlobalNames.sFPAirline_AirlineCode);
                int iIndexHandlingComapnies = dtAirlineCodesTable.Columns.IndexOf(GlobalNames.sFPAirline_GroundHandlers);
                if ((iIndexAirline == -1) ||
                    (iIndexHandlingComapnies == -1))
                {
                    alErrors.Add("Err00729 : The airline table does not have a good format.");
                    return null;
                }
                int iIndexAirlineStat = dtAirlineDistribution.Columns.IndexOf("Airline Code");
                if (iIndexAirlineStat == -1)
                {
                    alErrors.Add("Err00730 : The airline statistics table does not have a good format.");
                    return null;
                }
                DataTable dtResult = new DataTable("Ground Handlers Statistics");
                //<<Statistic tables 
                if (isArrival != isDeparture)
                    if (isArrival)
                        dtResult.TableName = "FPA_" + dtResult.TableName;
                    else
                        dtResult.TableName = "FPD_" + dtResult.TableName;
                //>>Statistic tables
                dtResult.Columns.Add("Terminal", typeof(String));
                dtResult.Columns.Add("Handling Company", typeof(String));
                dtResult.Columns.Add("BPP", typeof(Double));
                //<<Statistic tables 
                if (isArrival)
                {
                    dtResult.Columns.Add("Arr_SeatUse", typeof(Double));
                    dtResult.Columns.Add("Arr_Transfer", typeof(Double));
                    dtResult.Columns.Add("Arr_FLT", typeof(Int32));
                    dtResult.Columns.Add("Arr_Pax", typeof(Int32));
                    dtResult.Columns.Add("Arr_Bags", typeof(Int32));
                    dtResult.Columns.Add("Arr_TE", typeof(Int32));
                    // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                    dtResult.Columns.Add("Arr_TE_Bags", typeof(Int32));
                    // >> Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                    dtResult.Columns.Add("Arr_TR", typeof(Int32));
                    // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                    dtResult.Columns.Add("Arr_TR_Bags", typeof(Int32));
                    // >> Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                }
                if (isDeparture)
                {
                    dtResult.Columns.Add("Dep_SeatUse", typeof(Double));
                    dtResult.Columns.Add("Dep_Transfer", typeof(Double));
                    dtResult.Columns.Add("Dep_FLT", typeof(Int32));
                    dtResult.Columns.Add("Dep_PAX", typeof(Int32));
                    dtResult.Columns.Add("Dep_Bags", typeof(Int32));
                    dtResult.Columns.Add("Dep_CI", typeof(Int32));
                    // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                    dtResult.Columns.Add("Dep_CI_Bags", typeof(Int32));
                    // >> Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                    dtResult.Columns.Add("Dep_TR", typeof(Int32));
                    // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                    dtResult.Columns.Add("Dep_TR_Bags", typeof(Int32));
                    // >> Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                }
                //>>Statistic tables 
                List<String> alAirline = new List<String>();
                foreach (DataRow drLine in dtAirlineDistribution.Rows)
                {
                    if ((!alAirline.Contains(drLine[iIndexAirlineStat].ToString())) &&
                        (drLine[iIndexAirlineStat].ToString() != "Total"))
                    {
                        alAirline.Add(drLine[iIndexAirlineStat].ToString());
                    }
                }
                List<String> alCompanies = new List<String>();
                foreach (String sAirline in alAirline)
                {
                    String sValue = DataFunctions.getValue(dtAirlineCodesTable, sAirline, iIndexAirline, iIndexAirline);
                    if ((sValue == null) || (sValue == ""))
                    {
                        alErrors.Add("Err00731 : At least one airline from the Flight Plans is not defined in the Airlines Codes table.");
                        return null;
                    }
                    sValue = DataFunctions.getValue(dtAirlineCodesTable, sAirline, iIndexAirline, iIndexHandlingComapnies);
                    if ((sValue == null) || (sValue == ""))
                        sValue = "Unknown";
                    alCompanies.Add(sValue);
                }
                List<String> alSortedCompanies = new List<String>();
                foreach (String sCompanie in alCompanies)
                {
                    if (!alSortedCompanies.Contains(sCompanie))
                        alSortedCompanies.Add(sCompanie);
                }

                alSortedCompanies.Sort(new FonctionUtiles.ColumnsComparerList());
                iNbHandligne = alSortedCompanies.Count + 1;

                String sLastTerminal = "";
                DataRow NewRow = null;
                foreach (DataRow drLine in dtAirlineDistribution.Rows)
                {
                    String sTerminal = drLine[0].ToString();
                    String sAirline = drLine[1].ToString();
                    if (sLastTerminal == sTerminal)
                    {
                        if (sAirline == "Total")
                        {
                            NewRow = dtResult.NewRow();
                            NewRow[0] = sTerminal;
                            NewRow[1] = sAirline;
                            for (int i = 2; i < dtResult.Columns.Count; i++)
                                NewRow[i] = drLine[i];
                            dtResult.Rows.Add(NewRow);
                        }
                        continue;
                    }
                    sLastTerminal = sTerminal;
                    foreach (String sHandlingName in alSortedCompanies)
                    {
                        NewRow = dtResult.NewRow();
                        NewRow[0] = sTerminal;
                        NewRow[1] = sHandlingName;
                        for (int i = 2; i < dtResult.Columns.Count; i++)
                            NewRow[i] = 0;
                        dtResult.Rows.Add(NewRow);
                    }

                }
                int iIndex = -1;
                foreach (DataRow drLine in dtAirlineDistribution.Rows)
                {
                    String sTerminal = drLine[0].ToString();
                    String sAirline = drLine[1].ToString();
                    if (!alAirline.Contains(sAirline))
                        continue;
                    String sHandling = (string)alCompanies[alAirline.IndexOf(sAirline)];

                    for (iIndex = 0; iIndex < dtResult.Rows.Count; iIndex++)
                    {
                        if ((dtResult.Rows[iIndex][0].ToString() == sTerminal) &&
                            (dtResult.Rows[iIndex][1].ToString() == sHandling))
                            break;
                    }
                    if (iIndex == dtResult.Rows.Count)
                    {
                        continue;
                    }
                    DataRow drNewRow = dtResult.Rows[iIndex];
                    if ((Double)drNewRow[3] == 0)
                    {
                        for (int i = 3; i <= 11; i++)   // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                            drNewRow[i] = drLine[i];
                    }
                    else if ((Double)drLine[3] != 0)
                    {
                        Double dtmp = (100.0f * (int)drNewRow[6]) / (Double)drNewRow[3];
                        Double dtmp2 = (100.0f * (int)drLine[6]) / (Double)drLine[3];
                        drNewRow[3] = ((int)drNewRow[6] + (int)drLine[6]) / (dtmp + dtmp2) * 100;
                        for (int i = 5; i <= 11; i++)   // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                            drNewRow[i] = (int)drNewRow[i] + (int)drLine[i];
                    }

                    if (isArrival && isDeparture)   //<<Statistic tables 
                    {
                        if ((Double)drNewRow[12] == 0)  // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                        {
                            for (int i = 12; i <= 20; i++)  // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                                drNewRow[i] = drLine[i];
                        }
                        else if ((Double)drLine[12] != 0)   // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                        {
                            Double dtmp = (100.0f * (int)drNewRow[15]) / (Double)drNewRow[12];  // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                            Double dtmp2 = (100.0f * (int)drLine[15]) / (Double)drLine[12]; // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns 
                            drNewRow[12] = ((int)drNewRow[15] + (int)drLine[15]) / (dtmp + dtmp2) * 100;    // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                            for (int i = 14; i <= 20; i++)  // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                                drNewRow[i] = (int)drNewRow[i] + (int)drLine[i];
                        }
                    }
                }

                foreach (DataRow drLine in dtResult.Rows)
                {
                    if ((int)drLine[6] != 0)
                        drLine[2] = (double)Math.Round(((double)(int)drLine[7]) / ((Double)(int)drLine[6]), 2);
                    drLine[3] = (double)Math.Round((Double)drLine[3], 2);

                    if ((int)drLine[6] != 0)
                        drLine[4] = (double)Math.Round(((double)(int)drLine[10]) / ((Double)(int)drLine[6]) * 100, 2);// << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns

                    if (isArrival && isDeparture)   //<<Statistic tables 
                    {
                        drLine[12] = (double)Math.Round((Double)drLine[12], 2);// << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                        if ((int)drLine[15] != 0)
                            drLine[13] = (double)Math.Round(((double)(int)drLine[19]) / ((Double)(int)drLine[15]) * 100, 2);
                    }
                }
                //<<Statistic tables 
                int startRow = 0;
                Dictionary<String, String> departureColumnDictionary = new Dictionary<String, String>()
                    {
                        {"Dep_FLT", "%_Nb Dep_FLT"},
                        {"Dep_PAX", "%_Nb Dep_PAX"},
                        {"Dep_Bags", "%_Nb Dep_Bags"},
                        {"Dep_CI", "%_Nb Dep_CI"},
                        {"Dep_CI_Bags", "%_Nb Dep_CI_Bags"},   // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                        {"Dep_TR", "%_Nb Dep_TR"},
                        {"Dep_TR_Bags", "%_Nb Dep_TR_Bags"}             // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                    };
                Dictionary<String, String> arrivalColumnDictionary = new Dictionary<String, String>()
                    {
                        {"Arr_FLT", "%_Nb Arr_FLT"},
                        {"Arr_PAX", "%_Nb Arr_PAX"},
                        {"Arr_Bags", "%_Nb Arr_Bags"},
                        {"Arr_TE", "%_Nb Arr_TE"},
                        {"Arr_TE_Bags", "%_Nb Arr_TE_Bags"},    // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                        {"Arr_TR", "%_Nb Arr_TR"},
                        {"Arr_TR_Bags", "%_Nb Arr_TR_Bags"}               // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                    };
                for (int i = 0; i < dtResult.Rows.Count; i++)
                {
                    String rowType = dtResult.Rows[i][1].ToString();
                    if (rowType == "Total")
                    {
                        if (isDeparture)
                        {
                            addPercentageDistributionColumns(dtResult, departureColumnDictionary, startRow, i - 1);
                            roundSumColumn(dtResult, dtResult.Rows[i], departureColumnDictionary, startRow, i - 1);
                        }
                        if (isArrival)
                        {
                            addPercentageDistributionColumns(dtResult, arrivalColumnDictionary, startRow, i - 1);
                            roundSumColumn(dtResult, dtResult.Rows[i], arrivalColumnDictionary, startRow, i - 1);
                        }
                        startRow = i + 1;
                    }
                }
                //>>Statistic tables
                dtResult.AcceptChanges();
                return dtResult;
            }

            private static void PrintLineAirportStatistics(DataRow drLine, cFlightCategoryResult cfcrTmp, String sTerminal,
                 Boolean isArrival, Boolean isDeparture)     //<<Statistic tables )
            {
                int iOffsetDeparture = 3;   //<<Statistic tables
                drLine[0] = sTerminal;
                drLine[1] = cfcrTmp.sName;
                drLine[2] = Math.Round(cfcrTmp.dBagPerPax, 2);

                //<<Statistic tables 
                if (isArrival)
                {
                    iOffsetDeparture = 12;                                  // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                    drLine[3] = Math.Round(cfcrTmp.dArrLoadFactor, 2);
                    drLine[4] = Math.Round(cfcrTmp.dArrTransfer, 2);
                    drLine[5] = cfcrTmp.iArrivalFlights;
                    drLine[6] = FonctionsType.getInt(cfcrTmp.dArrivalPax, typeof(Double));
                    drLine[7] = FonctionsType.getInt(cfcrTmp.dArrivalBags, typeof(Double));
                    drLine[8] = FonctionsType.getInt(cfcrTmp.dArrivalTerminating, typeof(Double));
                    drLine[9] = FonctionsType.getInt(cfcrTmp.arrivalTerminatingBags, typeof(Double));  // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                    drLine[10] = FonctionsType.getInt(cfcrTmp.dArrivalTransferring, typeof(Double));
                    drLine[11] = FonctionsType.getInt(cfcrTmp.arrivalTransferringBags, typeof(Double)); // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                }

                if (isDeparture)
                {
                    drLine[iOffsetDeparture] = Math.Round(cfcrTmp.dDepLoadFactor, 2);
                    drLine[iOffsetDeparture + 1] = Math.Round(cfcrTmp.dDepTransfer, 2);
                    drLine[iOffsetDeparture + 2] = cfcrTmp.iDepartureFlights;
                    drLine[iOffsetDeparture + 3] = FonctionsType.getInt(cfcrTmp.dDeparturePax, typeof(Double));
                    drLine[iOffsetDeparture + 4] = FonctionsType.getInt(cfcrTmp.dDepartureBags, typeof(Double));
                    drLine[iOffsetDeparture + 5] = FonctionsType.getInt(cfcrTmp.dDepartureOriginating, typeof(Double));
                    // << Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns
                    drLine[iOffsetDeparture + 6] = FonctionsType.getInt(cfcrTmp.departureOriginatingBags, typeof(Double));
                    drLine[iOffsetDeparture + 7] = FonctionsType.getInt(cfcrTmp.dDepartureTransferring, typeof(Double));
                    drLine[iOffsetDeparture + 8] = FonctionsType.getInt(cfcrTmp.departureTransferringBags, typeof(Double));
                    //drLine[iOffsetDeparture + 6] = FonctionsType.getInt(cfcrTmp.dDepartureTransferring, typeof(Double));
                    // >> Task #9221 Pax2Sim - Static Analysis - FPD_FPA Airport Statistics - CI/Transfer bags columns                    
                }
                //>>Statistic tables

            }
            #endregion
        }
        #endregion

        #region La classe UpdateAllocation    ----  Classe qui permet l'allocation des postes en suivant les plans de vols  (09.10.2009)
        public class UpdateAllocation
        {
            internal static int FindLevel(DataTable AllocationTable, int iTerminal, String sType, int iIndex)
            {
                String sName = "T" + iTerminal.ToString() + "L";
                String sEndName = "_" + sType + " " + iIndex.ToString();
                if (!GestionDonneesHUB2SIM.htSizeAutomodModel.ContainsKey(PAX2SIM.sLevelName))
                    return 1;
                int iNbLevel = (int)GestionDonneesHUB2SIM.htSizeAutomodModel[PAX2SIM.sLevelName];
                for (int i = 1; i <= iNbLevel; i++)
                {
                    if (AllocationTable.Columns.Contains(sName + i.ToString() + sEndName))
                        return i;
                }
                return -1;
            }

            #region Fonction qui s'occupe de la mise en forme des données dans les tables d'allocation.
            /// <summary>
            /// Fonction qui s'occupe d'ajouter les virgules lors de l'ajout de valeurs dans les tables d'allocation.
            /// </summary>
            /// <param name="ancienneValeur">Ancienne valeur contenue dans la table d'allocation.</param>
            /// <param name="identifiantVol">Identifiant du vol qu'il faut ajouter dans la table d'allocation.</param>
            /// <param name="useClass">Booléen indiquant si l'on doit faire apparaître la classe</param>
            /// <param name="ClasseTraitee">La classe que l'on doit ajouter au numéro de vol</param>
            /// <returns>Renvoie la nouvelle valeur </returns>
            internal static String traitementAllocation(String ancienneValeur, String identifiantVol, bool useClass, String ClasseTraitee)
            {

                if ((ancienneValeur == null) || (ancienneValeur.Length == 0))
                    ancienneValeur = "(";
                else
                    ancienneValeur = ancienneValeur.Substring(0, ancienneValeur.Length - 1);
                String retour = ancienneValeur;
                if (ancienneValeur.Length != 1)
                {
                    //On ajoute une virgule pour séparé les différents identifiants de vol.
                    retour += ",";
                }
                retour += identifiantVol;
                if (useClass)
                {
                    retour += "(" + ClasseTraitee + ")";
                }
                return retour + ")";
            }
            #endregion

            #region Fonction qui fait le calcul des allocations des check-in
            /// <summary>
            /// Fonction qui s'occupe d'effectuer les calculs pour l'allocation des ressources
            /// en fonction des trois tables passées en paramètres.
            /// <para>La fonction renvoie le nombre d'erreurs qui sont apparues au cours de l'exécution.</para>
            /// </summary>
            /// <param name="tablePlanVols">La table des plans de vol.</param>
            /// <param name="tableAllocation">La table des allocation que l'on doit mettre à jour.</param>
            /// <param name="tableOCT">La table des ouvertures et fermetures des bureaux.</param>
            /// <param name="depart">Booléen indiquant s'il s'agit d'un vol départ ou arrivée.</param>
            /// <param name="sTerminalAllocation">Nom de la colonne indiquant le terminal de la ressource traitées</param>
            /// <param name="sLevelAllocation">Nom de la colonne indiquant le level de la ressource traitées </param>
            /// <param name="CheckInAllocation">Booléen indiquant si on traite les check in ou non</param>
            /// <param name="sRessourceAllocation">Nom de la colonne de la ressource traitée actuellement</param>
            /// <param name="sRessourceFinAllocation">Dans le cas des check in, nom de la colonne de fin des ressources allouées</param>
            /// <param name="sRessourceName">Nom de la ressource utilisé dans la table à allouer</param>
            /// <param name="dateAnalyse">Date de l'analyse</param>
            /// <param name="finAnalyse">Date de fin de l'analyse</param>
            /// <param name="sRessourceAllocationEco">Dans le cas des check in, Nom de la colonne pour les check ins de la classe économique</param>
            /// <param name="sRessourceFinAllocationEco">Dans le cas des check in, Nom de la colonne pour les check ins de la classe économique</param>
            /// <returns>Renvoie le nombre d'erreurs rencontrées durant l'allocation.</returns>
            internal static int effectuerCalculAllocation(DataTable tablePlanVols,
                DataTable tableAllocation,
                DataManagement.NormalTable tableOCT,
                bool depart,
                int iPasAnalyse,
                String sDateColumn,
                String sTimeColumn,
                String sFCColumn,
                String IDColumn,
                String AirlineColumn,
                String sLineOpening,
                String sLineClosing,
                String sTerminalAllocation,
                /*String sLevelAllocation,*/
                bool CheckInAllocation,
                String sRessourceAllocation,
                String sRessourceFinAllocation,
                String sRessourceName,
                String sRessourceAllocationEco,
                String sRessourceFinAllocationEco,
                ArrayList ListeErreurs)
            {
                //Remise à zéro du nombre d'erreurs.
                int nombreErreurs = 0;
                DateTime dateDebut;
                DateTime dateFin;
                int i;
                String sPrefixe = "A_";
                if (depart)
                    sPrefixe = "D_";
                DataManagement.ExceptionTable etTableOCT;
                if (tableOCT is DataManagement.ExceptionTable)
                    etTableOCT = (DataManagement.ExceptionTable)tableOCT;
                else
                    return 1;

                ///Get the dates for the current flight plan, will return the dates that are currently in the flight plan with the OCT applied.
                if (!DataFunctions.SearchDates(tablePlanVols, etTableOCT, !depart, sDateColumn, sTimeColumn, sFCColumn, IDColumn, AirlineColumn, sLineOpening, sLineClosing, out dateDebut, out dateFin, ListeErreurs))
                {
                    return 1;
                }
                tableAllocation.Rows.Clear();
                DataFunctions.initialiserLignes(tableAllocation, dateDebut, dateFin, iPasAnalyse);

                // Suppression de toutes les données contenues dans la table d'allocation.
                //    On supprime toutes les informations contenues dans les colonnes ayant un
                //    index supérieur à 0 (colonne avec les heures conservée)
                foreach (DataRow ligne in tableAllocation.Rows)
                {
                    ligne.BeginEdit();
                    for (i = 1; i < ligne.ItemArray.Length; i++)
                        ligne[i] = "";
                }

                #region Les variables contenant les index des colonnes de la table des plans de vols.
                int iColumnTerminal = tablePlanVols.Columns.IndexOf(sTerminalAllocation);
                int iColumnRessource = tablePlanVols.Columns.IndexOf(sRessourceAllocation);
                int iColumnRessourceFin = -1, iColumnRessourceEco = -1, iColumnRessourceEcoFin = -1;
                int iColumnID = tablePlanVols.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID);
                int iColumnFlight = tablePlanVols.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightN);
                int iColumnDate = tablePlanVols.Columns.IndexOf(sDateColumn);
                int iColumnTime = tablePlanVols.Columns.IndexOf(sTimeColumn);
                int iColumnFC = tablePlanVols.Columns.IndexOf(sFCColumn);
                int iColumnAirline = tablePlanVols.Columns.IndexOf(GlobalNames.sFPD_A_Column_AirlineCode);
                #endregion

                #region Vérification des noms des colonnes et recherche de leurs index.
                if (iColumnID == -1)
                {
                    ListeErreurs.Add("Err00520 : Unable to locate the column \"ID\" in the table\"" + tablePlanVols.TableName + "\". Please check for mistakes in tables.");
                    return 0;
                }
                if (iColumnFlight == -1)
                {
                    ListeErreurs.Add("Err00521 : Unable to locate the column \"FLIGHT N\" in the table\"" + tablePlanVols.TableName + "\". Please check for mistakes in tables.");
                    return 0;
                }
                if (iColumnDate == -1)
                {
                    ListeErreurs.Add("Err00522 : Unable to locate the column \"" + sDateColumn + "\" in the table\"" + tablePlanVols.TableName + "\". Please check for mistakes in tables.");
                    return 0;
                }
                if (iColumnTime == -1)
                {
                    ListeErreurs.Add("Err00523 : Unable to locate the column \"" + sTimeColumn + "\" in the table\"" + tablePlanVols.TableName + "\". Please check for mistakes in tables.");
                    return 0;
                }
                if (iColumnFC == -1)
                {
                    ListeErreurs.Add("Err00524 : Unable to locate the column \"" + sFCColumn + "\" in the table\"" + tablePlanVols.TableName + "\". Please check for mistakes in tables.");
                    return 0;
                }
                if (iColumnTerminal == -1)
                {
                    ListeErreurs.Add("Err00503 : Unable to locate the column \"" + sTerminalAllocation + "\" in the table\"" + tablePlanVols.TableName + "\". Please check for mistakes in tables.");
                    return 0;
                }
                if (iColumnRessource == -1)
                {
                    ListeErreurs.Add("Err00504 : The column \"" + sRessourceAllocation + "\" for the ressource value does not appear in the flight plan table \"" + tablePlanVols.TableName + "\". Please check for mistakes in tables.");
                    return 0;
                }
                if (iColumnAirline == -1)
                {
                    return 0;
                }
                if (CheckInAllocation)
                {
                    //Dans le cas des checkin, il y a plusieurs ressources d'allouées.
                    //elles sont désignées par un index de début et un index de fin.
                    iColumnRessourceFin = tablePlanVols.Columns.IndexOf(sRessourceFinAllocation);
                    if (iColumnRessourceFin == -1)
                    {
                        //Le nom de colonne pour définir la ressource n'existe pas.
                        ListeErreurs.Add("Err00505 : The column \"" + sRessourceFinAllocation + "\" for the ressource value does not appear in the flight plan table \"" + tablePlanVols.TableName + "\". Please check for mistakes in tables.");
                        return 0;
                    }
                    iColumnRessourceEco = tablePlanVols.Columns.IndexOf(sRessourceAllocationEco);
                    if (iColumnRessourceEco == -1)
                    {
                        //Le nom de colonne pour définir la ressource n'existe pas.
                        ListeErreurs.Add("Err00506 : The column \"" + sRessourceAllocationEco + "\" for the ressource value does not appear in the flight plan table \"" + tablePlanVols.TableName + "\". Please check for mistakes in tables.");
                        return 0;
                    }

                    iColumnRessourceEcoFin = tablePlanVols.Columns.IndexOf(sRessourceFinAllocationEco);
                    if (iColumnRessourceEcoFin == -1)
                    {
                        //Le nom de colonne pour définir la ressource n'existe pas.
                        ListeErreurs.Add("Err00507 : The column \"" + sRessourceFinAllocationEco + "\" for the ressource value does not appear in the flight plan table \"" + tablePlanVols.TableName + "\". Please check for mistakes in tables.");
                        return 0;
                    }
                }
                #endregion

                // On parcours la table plan de vols.
                // Pour chaque ligne, on va vérifier quel ressource a été attribuée.
                foreach (DataRow lignePlanVols in tablePlanVols.Rows)
                {
                    int iIdentifiantVol = 0;
                    try
                    {
                        //On récupère le numéro d'identifiant de la ligne.
                        iIdentifiantVol = FonctionsType.getInt(lignePlanVols[iColumnID], lignePlanVols[iColumnID].GetType());
                    }
                    catch (Exception exc)
                    {
                        //Le nom de colonne pour définir la ressource n'existe pas.
                        nombreErreurs++;
                        ListeErreurs.Add("Err00508 : Value in the column \"ID\" of the table \"" + tablePlanVols.TableName + "\" is not a valid number : \"" + lignePlanVols.ItemArray[iColumnID].ToString() + "\". Please check for mistakes in tables.");
                        OverallTools.ExternFunctions.PrintLogFile("Err00508: effectuerCalculAllocation throw an exception: " + exc.Message);
                        //On oublie ce vol et on passe au suivant.
                        continue;
                    }

                    String sIdentifiantVol = lignePlanVols[iColumnFlight].ToString();

                    // On détermine l'heure d'arrivée.
                    DateTime dtJourHeureArrivee = OverallTools.DataFunctions.toDateTime(lignePlanVols[iColumnDate], lignePlanVols[iColumnTime]);

                    // On récupère le type de vol dont il s'agit
                    String sCategorieVol = lignePlanVols[iColumnFC].ToString();
                    String sAirline = lignePlanVols[iColumnAirline].ToString();

                    Dictionary<String, String> dssOCT_ = etTableOCT.GetInformationsColumns(0, sPrefixe + iIdentifiantVol.ToString(), sAirline, sCategorieVol);
                    Dictionary<String, String> dssOCT_First = null;
                    if (CheckInAllocation)
                        dssOCT_First = etTableOCT.GetInformationsColumns(1, sPrefixe + iIdentifiantVol.ToString(), sAirline, sCategorieVol);
                    if ((dssOCT_ == null) || (!dssOCT_.ContainsKey(sLineOpening)) || (!dssOCT_.ContainsKey(sLineClosing)) ||
                        (CheckInAllocation && ((dssOCT_First == null) || (!dssOCT_First.ContainsKey(sLineOpening)) || (!dssOCT_First.ContainsKey(sLineClosing)))))
                    //    return 1;


                    // On détermine l'heure d'ouverture et de fermeture de la ressource pour le vol.
                    //int indexFC = tableOCT.Columns.IndexOf(sCategorieVol);
                    //if (indexFC == -1)
                    {
                        //La catégorie de vol n'existe pas.
                        nombreErreurs++;
                        ListeErreurs.Add("Err00509 : The flight category for flight " + iIdentifiantVol.ToString() + " does not exist. Please check for mistakes in tables.");
                        //On oublie ce vol et on passe au suivant.
                        continue;
                    }
                    DateTime heureOuvertureRessourceEco;
                    DateTime heureFermetureRessourceEco;
                    DateTime heureOuvertureRessourceFirst = DateTime.Now;
                    DateTime heureFermetureRessourceFirst = DateTime.Now;
                    int oct_val1, oct_val2, oct_val1FB = 0, oct_val2FB = 0;
                    if ((!Int32.TryParse(dssOCT_[sLineOpening], out oct_val1)) || (!Int32.TryParse(dssOCT_[sLineClosing], out oct_val2)) ||
                       (CheckInAllocation) && ((!Int32.TryParse(dssOCT_First[sLineOpening], out oct_val1FB)) || (!Int32.TryParse(dssOCT_First[sLineClosing], out oct_val2FB))))
                    {
                        continue;
                    }

                    if (depart)
                    {
                        //Nous sommes dans le cas d'un départ, les heures d'ouverture et de fermeture
                        //sont donc exprimées en minutes avant départ
                        heureOuvertureRessourceEco = dtJourHeureArrivee.AddMinutes(-oct_val1);
                        heureFermetureRessourceEco = dtJourHeureArrivee.AddMinutes(-oct_val2);
                        if (CheckInAllocation)
                        {
                            heureOuvertureRessourceFirst = dtJourHeureArrivee.AddMinutes(-oct_val1FB);
                            heureFermetureRessourceFirst = dtJourHeureArrivee.AddMinutes(-oct_val2FB);
                        }
                    }
                    else
                    {
                        //Il s'agit de vols en arrivée. Les heures d'ouverture et de fermeture sont
                        //donc exprimées en minutes après arrivée.
                        heureOuvertureRessourceEco = dtJourHeureArrivee.AddMinutes(oct_val1);
                        heureFermetureRessourceEco = dtJourHeureArrivee.AddMinutes(oct_val2);
                        if (CheckInAllocation)
                        {
                            heureOuvertureRessourceFirst = dtJourHeureArrivee.AddMinutes(oct_val1FB);
                            heureFermetureRessourceFirst = dtJourHeureArrivee.AddMinutes(oct_val2FB);
                        }
                    }
                    /*
                    DateTime tmpDepart, tmpFin;
                    if (bArrivalFlight)
                    {
                        tmpDepart = tmp.AddMinutes(oct_val1);
                        tmpFin = tmp.AddMinutes(oct_val2);
                    }
                    else
                    {
                        tmpDepart = tmp.AddMinutes(-oct_val1);
                        tmpFin = tmp.AddMinutes(-oct_val2);
                    }*/
                    /*if (depart)
                    {
                        //Nous sommes dans le cas d'un départ, les heures d'ouverture et de fermeture
                        //sont donc exprimées en minutes avant départ
                        heureOuvertureRessource = heureOuvertureRessource.AddMinutes(-FonctionsType.getInt(tableOCT.Rows[0].ItemArray[indexFC]));
                        heureFermetureRessource = heureFermetureRessource.AddMinutes(-FonctionsType.getInt(tableOCT.Rows[1].ItemArray[indexFC]));
                    }
                    else
                    {
                        //Il s'agit de vols en arrivée. Les heures d'ouverture et de fermeture sont
                        //donc exprimées en minutes après arrivée.
                        heureOuvertureRessource = heureOuvertureRessource.AddMinutes(FonctionsType.getInt(tableOCT.Rows[0].ItemArray[indexFC]));
                        heureFermetureRessource = heureFermetureRessource.AddMinutes(FonctionsType.getInt(tableOCT.Rows[1].ItemArray[indexFC]));
                    }*/
                    if (heureOuvertureRessourceEco >= heureFermetureRessourceEco)
                    {
                        //La table des oct ne doit pas être correcte.
                        nombreErreurs++;
                        ListeErreurs.Add("Err00510 : The opening time is after closing time for flight " + iIdentifiantVol.ToString() + ". Please check for mistakes in tables.");
                        //On oublie ce vol et on passe au suivant.
                        continue;
                    }
                    if (CheckInAllocation && ((heureOuvertureRessourceFirst >= heureFermetureRessourceFirst)))
                    {
                        //La table des oct ne doit pas être correcte.
                        nombreErreurs++;
                        ListeErreurs.Add("Err00510b : The opening time is after closing time for flight " + iIdentifiantVol.ToString() + ". Please check for mistakes in tables.");
                        //On oublie ce vol et on passe au suivant.
                        continue;
                    }

                    int iTerminal;
                    if (!Int32.TryParse(lignePlanVols.ItemArray[iColumnTerminal].ToString(), out iTerminal))
                        iTerminal = -1;
                    //    Dans un second temps on cherche le level affecté.
                    int iLevel = -1;
                    //On Cherche désormais quels est(sont) l'(les) index des ressources allouées
                    int iRessource;
                    if (!Int32.TryParse(lignePlanVols.ItemArray[iColumnRessource].ToString(), out iRessource))
                        iRessource = -1;
                    int iRessourceFin = -1;
                    int iRessourceEco = -1;
                    int iRessourceEcoFin = -1;

                    #region Dans le cas des checkIn
                    if (CheckInAllocation)
                    {
                        if (!Int32.TryParse(lignePlanVols.ItemArray[iColumnRessourceFin].ToString(), out iRessourceFin))
                            iRessourceFin = -1;
                        if (iRessourceFin < iRessource)
                        {
                            //L'index de la colonne du dernier check in et inférieur à
                            //l'index du premier, chose impossible.
                            nombreErreurs++;
                            ListeErreurs.Add("Err00511 : Departure flight with ID \"" + iIdentifiantVol.ToString() + "\". The value in the column \"" + tablePlanVols.Columns[iColumnRessourceFin].ColumnName + "\" must be greater than the value in the column \"" + tablePlanVols.Columns[iColumnRessource].ColumnName + "\".");
                            //On oublie ce vol et on passe au suivant.
                            continue;
                        }
                        if (!Int32.TryParse(lignePlanVols.ItemArray[iColumnRessourceEco].ToString(), out iRessourceEco))
                            iRessourceEco = -1;

                        if (!Int32.TryParse(lignePlanVols.ItemArray[iColumnRessourceEcoFin].ToString(), out iRessourceEcoFin))
                            iRessourceEcoFin = -1;
                        if (iRessourceEcoFin < iRessourceEco)
                        {
                            //L'index de la colonne du dernier check in et inférieur à
                            //l'index du premier, chose impossible.
                            nombreErreurs++;
                            ListeErreurs.Add("Err00512 : Departure flight with ID \"" + iIdentifiantVol.ToString() + "\". The value in the column \"" + tablePlanVols.Columns[iColumnRessourceEcoFin].ColumnName + "\" must be greater than the value in the column \"" + tablePlanVols.Columns[iColumnRessourceEco].ColumnName + "\".");
                            //On oublie ce vol et on passe au suivant.
                            continue;
                        }
                    }
                    #endregion

                    String nomColonne;
                    String[] nomsColonnes = null;
                    String[] nomsColonnesEco = null;
                    iLevel = FindLevel(tableAllocation, iTerminal, sRessourceName, iRessource);
                    if (iLevel == -1)
                    {
                        nombreErreurs++;
                        ListeErreurs.Add("Err00513 : The terminal \"" + iTerminal.ToString() + "\" does not contain an object of the type \"" + sRessourceName + "\" with the index \"" + iRessource.ToString() + "\". Please check for mistakes in tables.");
                        continue;
                    }
                    nomColonne = "T" + iTerminal.ToString() + "L" + iLevel.ToString() + "_" + sRessourceName + " " + iRessource.ToString();

                    #region Dans le cas des checkIn
                    if (CheckInAllocation)
                    {
                        nomsColonnes = new String[iRessourceFin - iRessource];
                        for (i = iRessource + 1; i <= iRessourceFin; i++)
                        {
                            iLevel = FindLevel(tableAllocation, iTerminal, sRessourceName, i);
                            if (iLevel == -1)
                            {
                                nombreErreurs++;
                                nomsColonnes[i - iRessource - 1] = "";
                                ListeErreurs.Add("Warn00514 : The terminal \"" + iTerminal.ToString() + "\" does not contain an object of the type \"" + sRessourceName + "\" with the index \"" + i.ToString() + "\". Please check for mistakes in tables.");
                                continue;
                            }
                            nomsColonnes[i - iRessource - 1] = "T" + iTerminal.ToString() + "L" + iLevel.ToString() + "_" + sRessourceName + " " + i.ToString();
                        }
                        if (i <= iRessourceFin)
                            continue;

                        nomsColonnesEco = new String[iRessourceEcoFin - iRessourceEco + 1];
                        for (i = iRessourceEco; i <= iRessourceEcoFin; i++)
                        {
                            iLevel = FindLevel(tableAllocation, iTerminal, sRessourceName, i);
                            if (iLevel == -1)
                            {
                                nombreErreurs++;
                                nomsColonnesEco[i - iRessourceEco] = "";
                                ListeErreurs.Add("Warn00515 : The terminal \"" + iTerminal.ToString() + "\" does not contain an object of the type \"" + sRessourceName + "\" with the index \"" + i.ToString() + "\". Please check for mistakes in tables.");
                                continue;
                            }
                            nomsColonnesEco[i - iRessourceEco] = "T" + iTerminal.ToString() + "L" + iLevel.ToString() + "_" + sRessourceName + " " + i.ToString();
                        }
                        if (i <= iRessourceEcoFin)
                            continue;
                    }
                    #endregion
                    //DateTime heureOuvertureRessource = OverallTools.DataFunctions.Min(heureOuvertureRessourceEco, heureOuvertureRessourceFirst);
                    //DateTime heureFermetureRessource = OverallTools.DataFunctions.Max(heureFermetureRessourceEco, heureFermetureRessourceFirst);
                    int iIndexOpenningEco = (int)((OverallTools.DataFunctions.MinuteDifference(dateDebut, heureOuvertureRessourceEco)) / iPasAnalyse);
                    int iClosingOpenningEco = (int)((OverallTools.DataFunctions.MinuteDifference(dateDebut, heureFermetureRessourceEco) - 0.001) / iPasAnalyse);
                    int iIndexOpenningFirst = iIndexOpenningEco, iClosingOpenningFirst = iClosingOpenningEco;
                    if (CheckInAllocation)
                    {
                        iIndexOpenningFirst = (int)((OverallTools.DataFunctions.MinuteDifference(dateDebut, heureOuvertureRessourceFirst)) / iPasAnalyse);
                        iClosingOpenningFirst = (int)((OverallTools.DataFunctions.MinuteDifference(dateDebut, heureFermetureRessourceFirst) - 0.001) / iPasAnalyse);
                    }

                    int iIndexRessource = tableAllocation.Columns.IndexOf(nomColonne);
                    if (iIndexRessource == -1)
                    {
                        //La colonne désirée n'existe pas dans la table.
                        nombreErreurs++;
                        ListeErreurs.Add("Err00517 : The columns in the allocation table does not match. Please check for mistakes in tables.");
                        //On quitte le foreach afin de passer à l'analyse du vol suivant.
                        continue;
                    }
                    int[] iIndexColumns = null;
                    int[] iIndexColumnsEco = null;
                    #region Dans le cas des checkIn
                    if (CheckInAllocation)
                    {
                        iIndexColumns = new int[nomsColonnes.Length];
                        iIndexColumnsEco = new int[nomsColonnesEco.Length];
                        for (i = 0; i < nomsColonnes.Length; i++)
                        {
                            if (nomsColonnes[i] == "")
                            {
                                iIndexColumns[i] = -1;
                                continue;
                            }
                            iIndexColumns[i] = tableAllocation.Columns.IndexOf(nomsColonnes[i]);
                            if (iIndexRessource == -1)
                            {
                                //La colonne désirée n'existe pas dans la table.
                                nombreErreurs++;
                                ListeErreurs.Add("Err00518 : The columns in the allocation table does not match. Please check for mistakes in tables.");
                                //On quitte le foreach afin de passer à l'analyse du vol suivant.
                                break;
                            }
                        }
                        if (i < nomsColonnes.Length)
                            continue;

                        for (i = 0; i < nomsColonnesEco.Length; i++)
                        {
                            if (nomsColonnesEco[i] == "")
                            {
                                iIndexColumnsEco[i] = -1;
                                continue;
                            }
                            iIndexColumnsEco[i] = tableAllocation.Columns.IndexOf(nomsColonnesEco[i]);
                            if (iIndexRessource == -1)
                            {
                                //La colonne désirée n'existe pas dans la table.
                                nombreErreurs++;
                                ListeErreurs.Add("Err00519 : The columns in the allocation table does not match. Please check for mistakes in tables.");
                                //On quitte le foreach afin de passer à l'analyse du vol suivant.
                                break;
                            }
                        }
                        if (i < iIndexColumnsEco.Length)
                            continue;
                    }
                    #endregion
                    int iIndexOpening = Math.Min(iIndexOpenningEco, iIndexOpenningFirst);
                    int iClosingOpening = Math.Max(iClosingOpenningEco, iClosingOpenningFirst);

                    for (i = iIndexOpening; i <= iClosingOpening; i++)
                    {
                        String sAncienneValeur = tableAllocation.Rows[i][iIndexRessource].ToString();
                        if ((i >= iIndexOpenningFirst) && (i <= iClosingOpenningFirst))
                            tableAllocation.Rows[i][iIndexRessource] = traitementAllocation(sAncienneValeur, sIdentifiantVol, CheckInAllocation, "F");
                        if (CheckInAllocation)
                        {
                            for (int j = 0; j < iIndexColumns.Length; j++)
                            {
                                if (iIndexColumns[j] == -1)
                                    continue;
                                sAncienneValeur = tableAllocation.Rows[i][iIndexColumns[j]].ToString();
                                if ((i >= iIndexOpenningFirst) && (i <= iClosingOpenningFirst))
                                    tableAllocation.Rows[i][iIndexColumns[j]] = traitementAllocation(sAncienneValeur, sIdentifiantVol, CheckInAllocation, "F");
                            }
                            for (int j = 0; j < iIndexColumnsEco.Length; j++)
                            {
                                if (iIndexColumnsEco[j] == -1)
                                    continue;
                                sAncienneValeur = tableAllocation.Rows[i][iIndexColumnsEco[j]].ToString();
                                if ((i >= iIndexOpenningEco) && (i <= iClosingOpenningEco))
                                    tableAllocation.Rows[i][iIndexColumnsEco[j]] = traitementAllocation(sAncienneValeur, sIdentifiantVol, CheckInAllocation, "E");
                            }
                        }
                    }
                }
                tableAllocation.AcceptChanges();
                return nombreErreurs;
            }
            #endregion

            #region Fonction qui fait le calcul des allocations des make-up
            /// <summary>
            /// Fonction qui s'occupe d'effectuer les calculs pour l'allocation des ressources
            /// en fonction des trois tables passées en paramètres.
            /// <para>La fonction renvoie le nombre d'erreurs qui sont apparues au cours de l'exécution.</para>
            /// </summary>
            /// <param name="tablePlanVols">La table des plans de vol.</param>
            /// <param name="tableAllocation">La table des allocation que l'on doit mettre à jour.</param>
            /// <param name="tableOCT">La table des ouvertures et fermetures des bureaux.</param>
            /// <param name="depart">Booléen indiquant s'il s'agit d'un vol départ ou arrivée.</param>
            /// <param name="sTerminalAllocation">Nom de la colonne indiquant le terminal de la ressource traitées</param>
            /// <param name="sRessourceAllocation">Nom de la colonne de la ressource traitée actuellement</param>
            /// <param name="sRessourceAllocationEco">Dans le cas des check in, Nom de la colonne pour les check ins de la classe économique</param>
            /// <returns>Renvoie le nombre d'erreurs rencontrées durant l'allocation.</returns>
            public static int effectuerCalculAllocation(DataTable tablePlanVols,
                DataTable tableAllocation,
                DataTable tableOCT,
                DataTable dtAirline,
                int iCurrentTerminal,
                bool depart,
                int iPasAnalyse,
                String sDateColumn,
                String sTimeColumn,
                String sFCColumn,
                String sTerminalAllocation,
                String sRessourceAllocation,
                String sRessourceAllocationEco,
                String sRessourceAllocationFBStart,
                String sRessourceAllocationFBEnd,
                String sRessourceName,
                bool bColorByAirline,
                out VisualisationMode vmMode,
                ArrayList ListeErreurs)
            {
                vmMode = null;
                if (tableOCT == null)
                    return 1;
                if (tableAllocation == null)
                    return 1;
                int i, j;
                String sAncienneValeur;
                bool bColorByHandlers = (dtAirline != null);
                //Remise à zéro du nombre d'erreurs.
                int nombreErreurs = 0;
                DateTime dateDebut;
                DateTime dateFin;
                tableAllocation.Rows.Clear();

                if (!DataFunctions.SearchDates(tablePlanVols, tableOCT, !depart, sDateColumn, sTimeColumn, sFCColumn, out dateDebut, out dateFin, ListeErreurs))
                {
                    return 1;
                }
                int iIndexID = tablePlanVols.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID);
                int iIndexFlight = tablePlanVols.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightN);
                int iIndexAirline = tablePlanVols.Columns.IndexOf(GlobalNames.sFPD_A_Column_AirlineCode);
                int iTerminal = tablePlanVols.Columns.IndexOf(sTerminalAllocation);
                if (iTerminal == -1)
                {
                    //Le nom de colonne pour définir le terminal n'existe pas.
                    ListeErreurs.Add("Err00072 : The column name for the terminal value does not appear in the flight table. Please check for mistakes in tables.");
                    return 1;
                }

                //On Cherche désormais quels est(sont) l'(les) index des ressources allouées
                int iRessource = tablePlanVols.Columns.IndexOf(sRessourceAllocation);
                if (iRessource == -1)
                {
                    //Le nom de colonne pour définir la ressource n'existe pas.
                    ListeErreurs.Add("Err00073 : The column name for the ressource value does not appear in the flight table. Please check for mistakes in tables.");
                    return 1;
                }

                int iRessourceEco = tablePlanVols.Columns.IndexOf(sRessourceAllocationEco);
                if (iRessourceEco == -1)
                {
                    //Le nom de colonne pour définir la ressource n'existe pas.
                    ListeErreurs.Add("Err00074 : The column name for the ressource value does not appear in the flight table. Please check for mistakes in tables.");
                    return 1;
                }

                int iRessourceFBStart = tablePlanVols.Columns.IndexOf(sRessourceAllocationFBStart);

                if (iRessourceFBStart == -1)
                {
                    //Le nom de colonne pour définir la ressource n'existe pas.
                    ListeErreurs.Add("Err00325 : The column name for the ressource value does not appear in the flight table. Please check for mistakes in tables.");
                    return 1;
                }

                int iRessourceFBEnd = tablePlanVols.Columns.IndexOf(sRessourceAllocationFBEnd);
                if (iRessourceFBEnd == -1)
                {
                    //Le nom de colonne pour définir la ressource n'existe pas.
                    ListeErreurs.Add("Err00326 : The column name for the ressource value does not appear in the flight table. Please check for mistakes in tables.");
                    return 1;
                }

                ArrayList alAirlineColors = null;
                ArrayList alHandlerColors = null;
                Hashtable htAirlineHandlers = null;
                ConditionnalFormatErrors cfeErrors = null;
                #region Partie pour les couleurs
                if ((bColorByAirline) || (bColorByHandlers))
                {
                    alAirlineColors = new ArrayList();
                    vmMode = new VisualisationMode(false, false, false, new int[] { 0 }, new int[] { 0 }, true, true,
                            Color.White, Color.Blue, Color.Black, Color.White, VisualisationMode.SelectionModeEnum.Cell,
                            VisualisationMode.EditModeEnum.Row, new int[] { 0 }, null, null, null, null);

                    cfeErrors = new ConditionnalFormatErrors();
                    vmMode.ConditionnalFormatClass = new VisualisationMode.ConditionnalFormat[1] { cfeErrors };
                    if ((bColorByHandlers) && (dtAirline.Columns.IndexOf(GlobalNames.sFPAirline_GroundHandlers) != -1))
                    {
                        alHandlerColors = new ArrayList();
                        htAirlineHandlers = new Hashtable();
                        foreach (DataRow drLine in dtAirline.Rows)
                        {
                            String sHandlers = drLine[GlobalNames.sFPAirline_GroundHandlers].ToString();
                            htAirlineHandlers.Add(drLine[GlobalNames.sFPAirline_AirlineCode].ToString(), sHandlers);
                            if (sHandlers == "")
                                continue;
                            if (alHandlerColors.Contains(sHandlers))
                                continue;
                            alHandlerColors.Add(sHandlers);
                        }
                        if (alHandlerColors.Count == 0)
                        {
                            alHandlerColors = null;
                            htAirlineHandlers = null;
                            bColorByHandlers = false;
                        }
                        else
                            alHandlerColors.Sort(new FonctionUtiles.ColumnsComparer());
                    }
                }
                #endregion
                DateTime dateAnalyse = dateDebut;
                DateTime finAnalyse = dateFin;
                DataFunctions.initialiserLignes(tableAllocation, dateDebut, dateFin, iPasAnalyse);

                // Suppression de toutes les données contenues dans la table d'allocation.
                //    On supprime toutes les informations contenues dans les colonnes ayant un
                //    index supérieur à 0 (colonne avec les heures conservée)
                foreach (DataRow ligne in tableAllocation.Rows)
                {
                    ligne.BeginEdit();
                    for (i = 1; i < ligne.ItemArray.Length; i++)
                        ligne[i] = "";
                }

                // On parcours la table plan de vols.
                //    Pour chaque ligne, on va vérifier quel ressource a été attribuée.
                foreach (DataRow lignePlanVols in tablePlanVols.Rows)
                {
                    //On récupère le numéro d'identifiant de la ligne.
                    int iIdentifiantVol = FonctionsType.getInt(lignePlanVols[iIndexID], lignePlanVols[iIndexID].GetType());
                    String sIdentifiantVol = lignePlanVols[iIndexFlight].ToString();

                    //On détermine quelles ressources ont été affectées au vol.
                    //    Premièrement on cherche quel terminal est affecté au vol.
                    int iAllocateTerminal = FonctionsType.getInt(lignePlanVols[iTerminal], lignePlanVols[iTerminal].GetType());
                    if (iAllocateTerminal != iCurrentTerminal)
                        continue;
                    #region Partie pour les couleurs
                    Color cColor = Color.White;
                    if ((alAirlineColors != null) || (alHandlerColors != null))
                    {
                        String sAirline = lignePlanVols[iIndexAirline].ToString();
                        if (bColorByHandlers)
                        {
                            if (htAirlineHandlers.ContainsKey(sAirline))
                            {
                                String sHandler = htAirlineHandlers[sAirline].ToString();
                                if (alHandlerColors.Contains(sHandler))
                                    cColor = FonctionUtiles.getColor(alHandlerColors.IndexOf(sHandler));
                            }
                        }
                        else if (bColorByAirline)
                        {
                            if (!alAirlineColors.Contains(sAirline))
                            {
                                alAirlineColors.Add(sAirline);
                            }
                            cColor = FonctionUtiles.getColor(alAirlineColors.IndexOf(sAirline));
                        }
                    }
                    #endregion

                    // On détermine l'heure d'arrivée.
                    DateTime dtJourHeureArrivee = OverallTools.DataFunctions.toDateTime(lignePlanVols[sDateColumn], lignePlanVols[sTimeColumn]);

                    // On récupère le type de vol dont il s'agit
                    String sCategorieVol = lignePlanVols[sFCColumn].ToString();

                    // On détermine l'heure d'ouverture et de fermeture de la ressource pour le vol.
                    int indexFC = tableOCT.Columns.IndexOf(sCategorieVol);
                    if (indexFC == -1)
                    {
                        //La catégorie de vol n'existe pas.
                        nombreErreurs++;
                        ListeErreurs.Add("Err00066 : The flight category for flight " + iIdentifiantVol.ToString() + " does not exist. Please check for mistakes in tables.");
                        //On oublie ce vol et on passe au suivant.
                        continue;
                    }
                    DateTime heureOuvertureRessource = new DateTime(dtJourHeureArrivee.Ticks);
                    DateTime heureFermetureRessource = new DateTime(dtJourHeureArrivee.Ticks);
                    if (depart)
                    {
                        //Nous sommes dans le cas d'un départ, les heures d'ouverture et de fermeture
                        //sont donc exprimées en minutes avant départ
                        heureOuvertureRessource = heureOuvertureRessource.AddMinutes(-FonctionsType.getInt(tableOCT.Rows[0].ItemArray[indexFC], tableOCT.Rows[0].ItemArray[indexFC].GetType()));
                        heureFermetureRessource = heureFermetureRessource.AddMinutes(-FonctionsType.getInt(tableOCT.Rows[1].ItemArray[indexFC], tableOCT.Rows[1].ItemArray[indexFC].GetType()));
                    }
                    else
                    {
                        //Il s'agit de vols en arrivée. Les heures d'ouverture et de fermeture sont
                        //donc exprimées en minutes après arrivée.
                        heureOuvertureRessource = heureOuvertureRessource.AddMinutes(FonctionsType.getInt(tableOCT.Rows[0].ItemArray[indexFC], tableOCT.Rows[0].ItemArray[indexFC].GetType()));
                        heureFermetureRessource = heureFermetureRessource.AddMinutes(FonctionsType.getInt(tableOCT.Rows[1].ItemArray[indexFC], tableOCT.Rows[1].ItemArray[indexFC].GetType()));
                    }
                    if (heureOuvertureRessource >= heureFermetureRessource)
                    {
                        //La table des oct ne doit pas être correcte.
                        nombreErreurs++;
                        ListeErreurs.Add("Err00069 : The opening time is after closing time for flight " + iIdentifiantVol.ToString() + ". Please check for mistakes in tables.");
                        //On oublie ce vol et on passe au suivant.
                        continue;
                    }

                    int iAllocateRessource = FonctionsType.getInt(lignePlanVols.ItemArray[iRessource], lignePlanVols.ItemArray[iRessource].GetType());
                    int iAllocateRessourceEco = FonctionsType.getInt(lignePlanVols.ItemArray[iRessourceEco], lignePlanVols.ItemArray[iRessourceEco].GetType());

                    int iAllocateRessourceFBStart = FonctionsType.getInt(lignePlanVols.ItemArray[iRessourceFBStart], lignePlanVols.ItemArray[iRessourceFBStart].GetType());
                    int iAllocateRessourceFBEnd = FonctionsType.getInt(lignePlanVols.ItemArray[iRessourceFBEnd], lignePlanVols.ItemArray[iRessourceFBEnd].GetType());

                    String nomColonne;




                    int iIndexOpenning = (int)((OverallTools.DataFunctions.MinuteDifference(dateDebut, heureOuvertureRessource)) / iPasAnalyse);
                    int iClosingOpenning = (int)((OverallTools.DataFunctions.MinuteDifference(dateDebut, heureFermetureRessource) - 0.001) / iPasAnalyse);


                    int[] tiIndex = new int[iAllocateRessource - iAllocateRessourceEco + 1];
                    for (i = iAllocateRessourceEco; i <= iAllocateRessource; i++)
                    {
                        nomColonne = sRessourceName + " " + i.ToString();
                        tiIndex[i - iAllocateRessourceEco] = tableAllocation.Columns.IndexOf(nomColonne);
                        if ((tiIndex[i - iAllocateRessourceEco] == -1))
                        {
                            //La colonne désirée n'existe pas dans la table.
                            nombreErreurs++;
                            ListeErreurs.Add("Err00076 : The columns \"" + nomColonne + "\"in the allocation table does not exist. Please check for mistakes in the tables.");
                            //On quitte le foreach afin de passer à l'analyse du vol suivant.
                            break;
                        }
                    }
                    if (i < tiIndex.Length)
                        continue;
                    bool hasInvalidIndex = false;
                    foreach (int index in tiIndex)  // >> Task #10272 Pax2Sim - MUP Allocation
                    {
                        if (index < 0)
                        {
                            hasInvalidIndex = true;
                            break;
                        }
                    }
                    if (hasInvalidIndex)
                    {
                        continue;
                    }
                    List<Int32> lsIndexFB = new List<int>();

                    bool bUseFirstClass = (iAllocateRessourceFBStart != 0) && (iAllocateRessourceFBEnd != 0);
                    if (bUseFirstClass)
                    {

                        //int[] tiIndexFB = new int[iAllocateRessourceFBEnd - iAllocateRessourceFBStart + 1];
                        for (i = iAllocateRessourceFBStart; i <= iAllocateRessourceFBEnd; i++)
                        {
                            nomColonne = sRessourceName + " " + i.ToString();
                            lsIndexFB.Add(tableAllocation.Columns.IndexOf(nomColonne));
                            //tiIndexFB[i - iAllocateRessourceFBStart] = tableAllocation.Columns.IndexOf(nomColonne);
                            if ((lsIndexFB[lsIndexFB.Count - 1] == -1))
                            {
                                //La colonne désirée n'existe pas dans la table.
                                nombreErreurs++;
                                ListeErreurs.Add("Err00327 : The columns \"" + nomColonne + "\"in the allocation table does not exist. Please check for mistakes in the tables.");
                                //On quitte le foreach afin de passer à l'analyse du vol suivant.
                                break;
                            }
                        }
                        if (i < tiIndex.Length)
                            continue;
                    }
                    List<Int32> liAllocated = new List<int>();
                    for (i = iIndexOpenning; i <= iClosingOpenning; i++)
                    {
                        for (j = 0; j < tiIndex.Length; j++)
                        {
                            sAncienneValeur = tableAllocation.Rows[i][tiIndex[j]].ToString();
                            if (lsIndexFB.Contains(tiIndex[j]))
                            {
                                tableAllocation.Rows[i][tiIndex[j]] = traitementAllocation(sAncienneValeur, sIdentifiantVol, bUseFirstClass, "E,F");
                                if (!liAllocated.Contains(tiIndex[j]))
                                    liAllocated.Add(tiIndex[j]);
                            }
                            else
                            {
                                tableAllocation.Rows[i][tiIndex[j]] = traitementAllocation(sAncienneValeur, sIdentifiantVol, bUseFirstClass, "E");
                            }
                            if (cColor == Color.White)
                                continue;
                            if ((bColorByHandlers) && (alHandlerColors != null))
                                cfeErrors.setCondition(j, i, cColor);
                            else if (alAirlineColors != null)
                                cfeErrors.setCondition(j, i, cColor);
                        }
                        for (j = 0; j < lsIndexFB.Count; j++)
                        {
                            sAncienneValeur = tableAllocation.Rows[i][lsIndexFB[j]].ToString();
                            if (liAllocated.Contains(lsIndexFB[j]))
                            {
                                continue;
                            }
                            else
                            {
                                tableAllocation.Rows[i][lsIndexFB[j]] = traitementAllocation(sAncienneValeur, sIdentifiantVol, bUseFirstClass, "F");
                            }
                            if (cColor == Color.White)
                                continue;
                            if ((bColorByHandlers) && (alHandlerColors != null))
                                cfeErrors.setCondition(j, i, cColor);
                            else if (alAirlineColors != null)
                                cfeErrors.setCondition(j, i, cColor);
                        }
                    }
                }
                tableAllocation.AcceptChanges();
                return nombreErreurs;
            }
            #endregion

            #region Fonction qui fait le calcul des allocations pour les parkings
            class FPInformations
            {
                internal DateTime DepartureTime;
                internal String FlightName;
                internal FPInformations()
                {
                    FlightName = "";
                    DepartureTime = DateTime.Now;
                }
            }

            // >> Bug #13471 V6.148 analysis error
            private static bool flightPlanContainsFlightByFlightId(DataTable flightPlan, int flightId)
            {
                if (flightPlan == null || flightId <= 0)
                    return false;

                int flightIdColumnIndex = flightPlan.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID);
                if (flightIdColumnIndex != -1)
                {
                    foreach (DataRow row in flightPlan.Rows)
                    {
                        int currentFlightId = -1;
                        if (row[flightIdColumnIndex] != null
                            && Int32.TryParse(row[flightIdColumnIndex].ToString(), out currentFlightId)
                            && currentFlightId == flightId)
                        {
                            return true;
                        }
                    }
                }
                return false;
            }
            // << Bug #13471 V6.148 analysis error

            /// <summary>
            /// Fonction qui s'occupe d'effectuer les calculs pour l'allocation des ressources
            /// en fonction des trois tables passées en paramètres.
            /// <para>La fonction renvoie le nombre d'erreurs qui sont apparues au cours de l'exécution.</para>
            /// </summary>
            /// <param name="tablePlanVolsD">La table des plans de vol Departs.</param>
            /// <param name="tablePlanVolsA">La table des plans de vol Arrivée</param>
            /// <param name="tableAllocation">La table des allocation que l'on doit mettre à jour.</param>
            /// <param name="tableOCT">La table des ouvertures et fermetures des bureaux.</param>
            /// <param name="iPasAnalyse">Le pas à suivre pour analyser (en minutes)</param>
            /// <returns>Renvoie le nombre d'erreurs rencontrées durant l'allocation.</returns>
            public static int effectuerCalculParkingAllocation(
                DataTable tablePlanVolsD,
                DataTable tablePlanVolsA,
                DataTable tableAircraftLinks,
                DataTable tableAllocation,
                DataTable tableOCT,
                bool bAllocateArrival,
                bool bAllocateDeparture,
                int iPasAnalyse,
                ArrayList ListeErreurs)
            {
                //Remise à zéro du nombre d'erreurs.
                int nombreErreurs = 0;
                DateTime dateDebutD = DateTime.Now;
                DateTime dateFinD = DateTime.Now;
                if (tablePlanVolsD != null)
                {
                    if (!DataFunctions.SearchDates(tablePlanVolsD, tableOCT, false, GlobalNames.sFPD_A_Column_DATE, GlobalNames.sFPD_Column_STD, GlobalNames.sFPD_A_Column_FlightCategory, out dateDebutD, out dateFinD, ListeErreurs))
                    {
                        return 1;
                    }
                }
                DateTime dateDebutA;
                DateTime dateFinA;
                if (tablePlanVolsA != null)
                {
                    if (!DataFunctions.SearchDates(tablePlanVolsA, tableOCT, true, GlobalNames.sFPD_A_Column_DATE, GlobalNames.sFPA_Column_STA, GlobalNames.sFPD_A_Column_FlightCategory, out dateDebutA, out dateFinA, ListeErreurs))
                    {
                        return 1;
                    }
                    if (tablePlanVolsD != null)
                    {
                        if (dateDebutD > dateDebutA)
                            dateDebutD = dateDebutA;

                        if (dateFinD < dateFinA)
                            dateFinD = dateFinA;
                    }
                    else
                    {
                        dateDebutD = dateDebutA;
                        dateFinD = dateFinA;
                    }
                }

                DateTime dateAnalyse = dateDebutD;
                DateTime finAnalyse = dateFinD;
                tableAllocation.Rows.Clear();
                DataFunctions.initialiserLignes(tableAllocation, dateDebutD, dateFinD, iPasAnalyse);

                // Suppression de toutes les données contenues dans la table d'allocation.
                //    On supprime toutes les informations contenues dans les colonnes ayant un
                //    index supérieur à 0 (colonne avec les heures conservée)
                foreach (DataRow ligne in tableAllocation.Rows)
                {
                    ligne.BeginEdit();
                    for (int i = 1; i < ligne.ItemArray.Length; i++)
                        ligne[i] = "";
                }
                int iIndexID;
                int iIndexFN;

                int iIndexDate;
                int iIndexST;
                int iIndexFC;

                int iIndexTerminalRessource;
                int iIndexRessource;

                Dictionary<int, int> liLinkedArrivalFlights = new Dictionary<int, int>();
                Dictionary<int, FPInformations> liLinkedDepartureFlights = new Dictionary<int, FPInformations>();
                if ((tableAircraftLinks != null) && (tablePlanVolsD != null) && (tablePlanVolsA != null))
                {
                    int iIndexFPDID = tableAircraftLinks.Columns.IndexOf(GlobalNames.sFPLinks_Column_FPDID);
                    int iIndexFPAID = tableAircraftLinks.Columns.IndexOf(GlobalNames.sFPLinks_Column_FPAID);
                    if ((iIndexFPDID != -1) && (iIndexFPAID != -1))
                    {
                        foreach (DataRow drRow in tableAircraftLinks.Rows)
                        {
                            if (drRow[iIndexFPDID] != null && drRow[iIndexFPAID] != null
                                && drRow[iIndexFPDID].ToString() != "" && drRow[iIndexFPAID].ToString() != "")
                            {
                                Int32 iValueFPD, iValueFPA;
                                // >> Bug #13471 V6.148 analysis error                                
                                /*
                                if (!Int32.TryParse(drRow[iIndexFPDID].ToString(), out iValueFPD))
                                {
                                    continue;
                                }
                                liLinkedDepartureFlights.Add(iValueFPD, new FPInformations());

                                if (Int32.TryParse(drRow[iIndexFPAID].ToString(), out iValueFPA))
                                    liLinkedArrivalFlights.Add(iValueFPA, iValueFPD);
                                */
                                if (Int32.TryParse(drRow[iIndexFPDID].ToString(), out iValueFPD)
                                    && Int32.TryParse(drRow[iIndexFPAID].ToString(), out iValueFPA))
                                {
                                    if (flightPlanContainsFlightByFlightId(tablePlanVolsD, iValueFPD)
                                        && flightPlanContainsFlightByFlightId(tablePlanVolsA, iValueFPA))
                                    {
                                        liLinkedDepartureFlights.Add(iValueFPD, new FPInformations());
                                        liLinkedArrivalFlights.Add(iValueFPA, iValueFPD);
                                    }
                                }
                                // << Bug #13471 V6.148 analysis error
                            }

                        }
                    }
                }


                if (tablePlanVolsD != null)
                {
                    iIndexTerminalRessource = tablePlanVolsD.Columns.IndexOf(GlobalNames.sFPD_A_Column_TerminalParking);
                    iIndexRessource = tablePlanVolsD.Columns.IndexOf(GlobalNames.sFPD_A_Column_Parking);
                    if ((iIndexTerminalRessource == -1) || (iIndexRessource == -1))
                    {
                        //La catégorie de vol n'existe pas.
                        nombreErreurs++;
                        ListeErreurs.Add("Err00091 : The departure flight plan table is not valid. Unable to find the Terminal or Parking column. Please check for mistakes in tables.");
                        return nombreErreurs;
                    }
                    iIndexID = tablePlanVolsD.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID);
                    iIndexFN = tablePlanVolsD.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightN);
                    iIndexDate = tablePlanVolsD.Columns.IndexOf(GlobalNames.sFPD_A_Column_DATE);
                    iIndexST = tablePlanVolsD.Columns.IndexOf(GlobalNames.sFPD_Column_STD);
                    iIndexFC = tablePlanVolsD.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightCategory);

                    if (iIndexID == -1)
                    {
                        nombreErreurs++;
                        ListeErreurs.Add("Err00140 : The departure flight plan table is not valid. Unable to find the ID column. Please check for mistakes in tables.");
                        return nombreErreurs;
                    }

                    if (iIndexFN == -1)
                    {
                        nombreErreurs++;
                        ListeErreurs.Add("Err00141 : The departure flight plan table is not valid. Unable to find the flight number column. Please check for mistakes in tables.");
                        return nombreErreurs;
                    }
                    if (iIndexDate == -1)
                    {
                        nombreErreurs++;
                        ListeErreurs.Add("Err00142 : The departure flight plan table is not valid. Unable to find the date column. Please check for mistakes in tables.");
                        return nombreErreurs;
                    }
                    if (iIndexST == -1)
                    {
                        nombreErreurs++;
                        ListeErreurs.Add("Err00145 : The departure flight plan table is not valid. Unable to find the STD (time) column. Please check for mistakes in tables.");
                        return nombreErreurs;
                    }
                    if (iIndexFC == -1)
                    {
                        nombreErreurs++;
                        ListeErreurs.Add("Err00144 : The departure flight plan table is not valid. Unable to find the flight category column. Please check for mistakes in tables.");
                        return nombreErreurs;
                    }
                    // On parcours la table plan de vols.
                    //    Pour chaque ligne, on va vérifier quel ressource a été attribuée.
                    foreach (DataRow lignePlanVols in tablePlanVolsD.Rows)
                    {
                        //On récupère le numéro d'identifiant de la ligne.
                        int iIdentifiantVol = FonctionsType.getInt(lignePlanVols.ItemArray[iIndexID], lignePlanVols.ItemArray[iIndexID].GetType());

                        String sIdentifiantVol = lignePlanVols.ItemArray[iIndexFN].ToString();

                        // On détermine l'heure d'arrivée.
                        DateTime dtJourHeureArrivee = OverallTools.DataFunctions.toDateTime(lignePlanVols[iIndexDate], lignePlanVols[iIndexST]);

                        if (liLinkedDepartureFlights.ContainsKey(iIdentifiantVol))
                        {
                            liLinkedDepartureFlights[iIdentifiantVol].DepartureTime = dtJourHeureArrivee;
                            liLinkedDepartureFlights[iIdentifiantVol].FlightName = sIdentifiantVol;
                            continue;
                        }
                        if (!bAllocateDeparture)
                            continue;
                        // On récupère le type de vol dont il s'agit
                        String sCategorieVol = lignePlanVols[iIndexFC].ToString();

                        // On détermine l'heure d'ouverture et de fermeture de la ressource pour le vol.
                        int indexFC = tableOCT.Columns.IndexOf(sCategorieVol);
                        if (indexFC == -1)
                        {
                            //La catégorie de vol n'existe pas.
                            nombreErreurs++;
                            ListeErreurs.Add("Err00067 : The flight category for departure flight " + iIdentifiantVol.ToString() + " does not exist. Please check for mistakes in tables.");
                            //On oublie ce vol et on passe au suivant.
                            continue;
                        }
                        DateTime heureOuvertureRessource = new DateTime(dtJourHeureArrivee.Ticks);
                        DateTime heureFermetureRessource = new DateTime(dtJourHeureArrivee.Ticks);
                        Int32 open = FonctionsType.getInt(tableOCT.Rows[0].ItemArray[indexFC], tableOCT.Rows[0].ItemArray[indexFC].GetType());
                        Int32 close = FonctionsType.getInt(tableOCT.Rows[1].ItemArray[indexFC], tableOCT.Rows[1].ItemArray[indexFC].GetType());
                        if (close > open)
                        {
                            open = close;
                            close = FonctionsType.getInt(tableOCT.Rows[0].ItemArray[indexFC], tableOCT.Rows[0].ItemArray[indexFC].GetType());
                        }

                        heureOuvertureRessource = heureOuvertureRessource.AddMinutes(-open);
                        heureFermetureRessource = heureFermetureRessource.AddMinutes(-close);

                        if (heureOuvertureRessource >= heureFermetureRessource)
                        {
                            //La table des oct ne doit pas être correcte.
                            nombreErreurs++;
                            ListeErreurs.Add("Err00070 : The opening time is after closing time for flight " + iIdentifiantVol.ToString() + ". Please check for mistakes in tables.");
                            //On oublie ce vol et on passe au suivant.
                            continue;
                        }



                        //On Cherche désormais quels est(sont) l'(les) index des ressources allouées

                        int iTerminalRessource;
                        if (!Int32.TryParse(lignePlanVols.ItemArray[iIndexTerminalRessource].ToString(), out iTerminalRessource))
                            iTerminalRessource = 0;
                        int iRessource;
                        if (!Int32.TryParse(lignePlanVols.ItemArray[iIndexRessource].ToString(), out iRessource))
                            continue;
                        if (iRessource == 0)
                            continue;
                        String nomColonne = "T" + iTerminalRessource.ToString() + "_Parking_" + iRessource.ToString();

                        int iIndexObjet = tableAllocation.Columns.IndexOf(nomColonne);
                        if (iIndexObjet == -1)
                        {
                            //ListeErreurs.Add("Err00077 : The columns in the allocation table does not match. Please check for mistakes in tables.");
                            ListeErreurs.Add("Err00077 : " + " Could not find the column \"" + nomColonne + "\" in the table \"" + tableAllocation.TableName + "\".");
                            nombreErreurs++;
                            continue;
                        }

                        int iIndexOpenning = (int)((OverallTools.DataFunctions.MinuteDifference(dateDebutD, heureOuvertureRessource)) / iPasAnalyse);
                        int iClosingOpenning = (int)((OverallTools.DataFunctions.MinuteDifference(dateDebutD, heureFermetureRessource) - 0.001) / iPasAnalyse);
                        for (int i = iIndexOpenning; i <= iClosingOpenning; i++)
                        {
                            String sAncienneValeur = tableAllocation.Rows[i][iIndexObjet].ToString();
                            tableAllocation.Rows[i][iIndexObjet] = traitementAllocation(sAncienneValeur, sIdentifiantVol, true, "D");
                        }
                    }
                }

                if (tablePlanVolsA != null)
                {
                    iIndexTerminalRessource = tablePlanVolsA.Columns.IndexOf(GlobalNames.sFPD_A_Column_TerminalParking);
                    iIndexRessource = tablePlanVolsA.Columns.IndexOf(GlobalNames.sFPD_A_Column_Parking);
                    if ((iIndexTerminalRessource == -1) || (iIndexRessource == -1))
                    {
                        //La catégorie de vol n'existe pas.
                        nombreErreurs++;
                        ListeErreurs.Add("Err00092 : The arrival flight plan table is not valid. Unable to find the Terminal or Parking column. Please check for mistakes in tables.");
                        //On oublie ce vol et on passe au suivant.
                        return nombreErreurs;
                    }
                    iIndexID = tablePlanVolsA.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID);
                    iIndexFN = tablePlanVolsA.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightN);
                    iIndexDate = tablePlanVolsA.Columns.IndexOf(GlobalNames.sFPD_A_Column_DATE);
                    iIndexST = tablePlanVolsA.Columns.IndexOf(GlobalNames.sFPA_Column_STA);
                    iIndexFC = tablePlanVolsA.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightCategory);

                    if (iIndexID == -1)
                    {
                        nombreErreurs++;
                        ListeErreurs.Add("Err00146 : The arrival flight plan table is not valid. Unable to find the ID column. Please check for mistakes in tables.");
                        return nombreErreurs;
                    }

                    if (iIndexFN == -1)
                    {
                        nombreErreurs++;
                        ListeErreurs.Add("Err00147 : The arrival flight plan table is not valid. Unable to find the flight number column. Please check for mistakes in tables.");
                        return nombreErreurs;
                    }
                    if (iIndexDate == -1)
                    {
                        nombreErreurs++;
                        ListeErreurs.Add("Err00148 : The arrival flight plan table is not valid. Unable to find the date column. Please check for mistakes in tables.");
                        return nombreErreurs;
                    }
                    if (iIndexST == -1)
                    {
                        nombreErreurs++;
                        ListeErreurs.Add("Err00149 : The arrival flight plan table is not valid. Unable to find the STA (time) column. Please check for mistakes in tables.");
                        return nombreErreurs;
                    }
                    if (iIndexFC == -1)
                    {
                        nombreErreurs++;
                        ListeErreurs.Add("Err00155 : The arrival flight plan table is not valid. Unable to find the flight category column. Please check for mistakes in tables.");
                        return nombreErreurs;
                    }
                    // On parcours la table plan de vols.
                    //    Pour chaque ligne, on va vérifier quel ressource a été attribuée.
                    foreach (DataRow lignePlanVols in tablePlanVolsA.Rows)
                    {
                        //On récupère le numéro d'identifiant de la ligne.
                        int iIdentifiantVol = FonctionsType.getInt(lignePlanVols.ItemArray[iIndexID], lignePlanVols.ItemArray[iIndexID].GetType());

                        String sIdentifiantVol = lignePlanVols.ItemArray[iIndexFN].ToString();

                        FPInformations DepartureFlight = null;
                        if (liLinkedArrivalFlights.ContainsKey(iIdentifiantVol))
                            DepartureFlight = liLinkedDepartureFlights[liLinkedArrivalFlights[iIdentifiantVol]];

                        // On détermine l'heure d'arrivée.
                        DateTime dtJourHeureArrivee = OverallTools.DataFunctions.toDateTime(lignePlanVols[iIndexDate], lignePlanVols[iIndexST]);


                        DateTime heureOuvertureRessource = new DateTime(dtJourHeureArrivee.Ticks);
                        DateTime heureFermetureRessource = new DateTime(dtJourHeureArrivee.Ticks);

                        if (DepartureFlight != null)
                        {
                            heureFermetureRessource = DepartureFlight.DepartureTime;
                            if (bAllocateDeparture && bAllocateArrival)
                                sIdentifiantVol = sIdentifiantVol + "-" + DepartureFlight.FlightName;
                            else if (!bAllocateArrival)
                                sIdentifiantVol = DepartureFlight.FlightName;
                        }
                        else
                        {
                            if (!bAllocateArrival)
                                continue;
                            // On récupère le type de vol dont il s'agit
                            String sCategorieVol = lignePlanVols[iIndexFC].ToString();
                            // On détermine l'heure d'ouverture et de fermeture de la ressource pour le vol.
                            int indexFC = tableOCT.Columns.IndexOf(sCategorieVol);
                            if (indexFC == -1)
                            {
                                //La catégorie de vol n'existe pas.
                                nombreErreurs++;
                                ListeErreurs.Add("Err00068 : The flight category for flight " + iIdentifiantVol.ToString() + " does not exist. Please check for mistakes in tables.");
                                //On oublie ce vol et on passe au suivant.
                                continue;
                            }

                            Int32 open = FonctionsType.getInt(tableOCT.Rows[0].ItemArray[indexFC], tableOCT.Rows[0].ItemArray[indexFC].GetType());
                            Int32 close = FonctionsType.getInt(tableOCT.Rows[1].ItemArray[indexFC], tableOCT.Rows[1].ItemArray[indexFC].GetType());
                            if (close < open)
                            {
                                open = close;
                                close = FonctionsType.getInt(tableOCT.Rows[0].ItemArray[indexFC], tableOCT.Rows[0].ItemArray[indexFC].GetType());
                            }
                            heureOuvertureRessource = heureOuvertureRessource.AddMinutes(open);
                            heureFermetureRessource = heureFermetureRessource.AddMinutes(close);
                            if (heureOuvertureRessource >= heureFermetureRessource)
                            {
                                //La table des oct ne doit pas être correcte.
                                nombreErreurs++;
                                ListeErreurs.Add("Err00071 : The opening time is after closing time for flight " + iIdentifiantVol.ToString() + ". Please check for mistakes in tables.");
                                //On oublie ce vol et on passe au suivant.
                                continue;
                            }
                        }


                        int iTerminalRessource;
                        if (!Int32.TryParse(lignePlanVols.ItemArray[iIndexTerminalRessource].ToString(), out iTerminalRessource))
                            iTerminalRessource = 0;
                        int iRessource;
                        if (!Int32.TryParse(lignePlanVols.ItemArray[iIndexRessource].ToString(), out iRessource))
                            iRessource = 0;

                        String nomColonne = "T" + iTerminalRessource.ToString() + "_Parking_" + iRessource.ToString();

                        if (iRessource == 0)
                            continue;
                        int iIndexObjet = tableAllocation.Columns.IndexOf(nomColonne);
                        if (iIndexObjet == -1)
                        {
                            //ListeErreurs.Add("Err00079 : The columns in the allocation table does not match. Please check for mistakes in tables.");
                            ListeErreurs.Add("Err00079 : " + " Could not find the column \"" + nomColonne + "\" in the table \"" + tableAllocation.TableName + "\".");
                            nombreErreurs++;
                            continue;
                        }



                        int iIndexOpenning = (int)((OverallTools.DataFunctions.MinuteDifference(dateDebutD, heureOuvertureRessource)) / iPasAnalyse);
                        int iClosingOpenning = (int)((OverallTools.DataFunctions.MinuteDifference(dateDebutD, heureFermetureRessource) - 0.001) / iPasAnalyse);
                        for (int i = iIndexOpenning; i <= iClosingOpenning; i++)
                        {
                            String sAncienneValeur = tableAllocation.Rows[i][iIndexObjet].ToString();
                            tableAllocation.Rows[i][iIndexObjet] = traitementAllocation(sAncienneValeur, sIdentifiantVol, true, "A");
                        }

                        /*
                        //Maintenant que nous avons récupéré les noms des colonnes à mettre à jour, nous 
                        //allons parcourir la table d'allocation et la mettre à jour aux endroits propices
                        foreach (DataRow lignesOuverture in tableAllocation.Rows)
                        {
                            DateTime heureTable;
                            //On détermine quelle ligne nous sommes en train de traiter
                            //Toutes les tables d'allocation ont l'index du temps à la première colonne.
                            if (!DateTime.TryParse(lignesOuverture.ItemArray[0].ToString(), out heureTable))
                            {
                                ListeErreurs.Add("Err00080 : Invalid format for date in table \"Check-In desk allocation\".");
                                continue;
                            }
                            if (heureTable >= heureFermetureRessource)
                                break;
                            DateTime heureTableSuivant = heureTable.AddMinutes(iPasAnalyse);
                            if (heureTableSuivant <= heureOuvertureRessource)
                                continue;
                            String sAncienneValeur = lignesOuverture.ItemArray[iIndexObjet].ToString();
                            lignesOuverture.BeginEdit();
                            lignesOuverture[iIndexObjet] = traitementAllocation(sAncienneValeur, sIdentifiantVol, true, "A");
                        }*/
                    }
                }
                /*
                //On referme les parentheses et on supprime celles inutiles
                foreach (DataRow ligne in tableAllocation.Rows)
                {
                    for (int i = 1; i < ligne.ItemArray.Length; i++)
                    {
                        if (ligne[i].ToString().Length <= 1)
                        {
                            ligne[i] = "";
                        }
                        else
                        {
                            ligne[i] = ligne[i] + ")";
                        }
                    }
                }*/
                tableAllocation.AcceptChanges();
                return nombreErreurs;
            }
            #endregion
        }
        #endregion

        #region La classe PaxTraceAnalysis
        /// <summary>
        /// Classe permettant l'analyse du PaxTrace.
        /// Cette classe regroupe toutes les classes et toutes les fonctions utilisées pour l'analyse
        /// du paxtrace résultat.
        /// </summary>
        public class PaxTraceAnalysis
        {
            #region Le constructeur de la classe.
            /// <summary>
            /// The class constructor
            /// </summary>
            /// <param name="PaxTraceLocation">The paxtrace location.</param>
            /// <param name="AnalyseStep_">The step defined by the user for the analysis.</param>
            /// <param name="ErrorList">A list for store the errors descritptions that could appears</param>
            private PaxTraceAnalysis(String sOutputsDirectory,
                                     String sBGLocation,
                                     Double AnalyseStep_,
                                     Double dWarmUp_,
                                     ArrayList ErrorList,
                                     Double analysisRange_)  // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
            {
                sOutputsDirectory_ = sOutputsDirectory;
                sBGLocation_ = sBGLocation;
                ErrorList_ = ErrorList;
                PaxInformations_ = null;
                dPasRemaining = 10;
                iNbClassesRemaining = 12;
                dWarmUp = dWarmUp_;
                dPasTime = 5;
                iNbClassesTime = 12;


                dPasOccupation = AnalyseStep_;
                dPasUtilisation = AnalyseStep_;
                dPasPaxDistribution = AnalyseStep_;
                dtBagList = null;
                dtFPDTable_ = null;
                dtAllocationResults = null;

                dtAllocationResults = null;
                dtAllocationReclaim = null;
                dsdTable = null;
                tfFilter = null;

                // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                analysisRange = analysisRange_;
                // >> Task #8775 Pax2Sim - Occupation stat - Throughput calculation
            }
            #endregion

            #region Fonction statique pour l'analyse du paxtrace d'un scénario donné

            /// <summary>
            /// Fonction qui se charge d'analyser le Paxtrace passé en parametres et de compiler les résultats sous
            /// forme de classes qui peuvent ensuite générer les résultats de la simulation.
            /// </summary>
            /// <param name="sOutputsDirectory">The location of the PaxTrace (if the location can be the paxtrace itself)</param>
            /// <param name="ScenarioName">Le scénario qui a été simulé.</param>
            /// <param name="Data">La structure de données contenant les données sources.</param>
            /// <param name="tnScenarioNode">L'arbre représentant la structure de l'aéroport.</param>
            /// <param name="dPas">Le pas de l'analyse.</param>
            /// <returns>Cette fonction renvoie un objet de type PaxTraceAnalysis contenant toutes les statistiques des différents postes.</returns>
            public static PaxTraceAnalysis AnalysePaxTrace(String ScenarioName,
                                                           String sOutputsDirectory,
                                                           String sBGLocation,
                                                           GestionDonneesHUB2SIM Data,
                                                           Double dPas,
                                                           Double dWarmUp,
                                                           bool bSaveTraceMode,
                                                           bool bSlidingHour)
            {
                bool bFile = false;
                if (File.Exists(sOutputsDirectory))
                    bFile = true;
                if ((!Directory.Exists(sOutputsDirectory)) && (!bFile))
                    return null;
                //on récupère les parametres du scénario simulé, afin de pouvoir connaitre les différentes
                //tables utilisées et les différentes dates de la simulation.
                SIMCORE_TOOL.Classes.ParamScenario Params = (SIMCORE_TOOL.Classes.ParamScenario)Data.GetScenario(ScenarioName);
                if (Params == null)
                    return null;

                //On doit dans un premier temps calculer les allocations à partir des tables utilisées pour la simulation.
                //Ceci pour connaitre les différents temps d'ouverture de chaque poste.
                DataTable dtBaggageClaimAllocation = Data.getTable("Input", "Alloc_BaggageClaimTable").Clone();
                DataTable dtCheckInAllocation = Data.getTable("Input", "Alloc_CITable").Clone();
                DataTable dtBoardingGateAllocation = Data.getTable("Input", "Alloc_BoardGateTable").Clone();

                DataTable dtFPDTable = null;
                if (Params.FPD != "")
                    dtFPDTable = Data.getTable("Input", Params.FPD);
                else
                    dtFPDTable = Data.getTable("Input", GlobalNames.FPDTableName);
                DataTable dtFPATable = null;
                if (Params.FPA != "")
                    dtFPATable = Data.getTable("Input", Params.FPA);
                else
                    dtFPATable = Data.getTable("Input", GlobalNames.FPATableName);

                NormalTable dtOCT_CI_Table = null;
                if (Params.OCT_CI_Table != "")
                    dtOCT_CI_Table = Data.GetTable("Input", Params.OCT_CI_Table);
                else
                    dtOCT_CI_Table = Data.GetTable("Input", GlobalNames.OCT_CITableName);

                NormalTable dtOCT_BC = null;
                if (Params.OCT_BC != "")
                    dtOCT_BC = Data.GetTable("Input", Params.OCT_BC);
                else
                    dtOCT_BC = Data.GetTable("Input", GlobalNames.OCT_BaggageClaimTableName);

                NormalTable dtOCT_BG = null;
                if (Params.OCT_BG != "")
                    dtOCT_BG = Data.GetTable("Input", Params.OCT_BG);
                else
                    dtOCT_BG = Data.GetTable("Input", GlobalNames.OCT_BaggageClaimTableName);

                NormalTable dtOCT_BagDrop = null; // << Task #9413 Pax2sim -Scenario properties - FPD export table - OCT for CheckIn and BagDrop
                if (Params.OCT_BagDropTableName != "")
                    dtOCT_BagDrop = Data.GetTable("Input", Params.OCT_BagDropTableName);
                else
                    dtOCT_BagDrop = Data.GetTable("Input", GlobalNames.OCT_BaggDropTableName);

                DataTable dtSecurity = null;
                if (Params.Security != "")
                    dtSecurity = Data.getTable("Input", Params.Security);
                else
                    dtSecurity = Data.getTable("Input", GlobalNames.Alloc_SecurityCheckTableName);

                // << Task #7570 new Desk and extra information for Pax -Phase I B
                DataTable dtUserProcess = Data.getTable("Input", Params.UserProcess);
                // if the scenario is old (made when the User Process table wasn't available)
                // we load the default User Process table from the project.
                if (dtUserProcess == null)
                    dtUserProcess = Data.getTable("Input", GlobalNames.Alloc_UserProcessCheckTableName);
                // >> Task #7570 new Desk and extra information for Pax -Phase I B

                DataTable dtPassport = Data.getTable("Input", Params.Passport);
                if (dtPassport == null)
                    dtPassport = Data.getTable("Input", GlobalNames.Alloc_PassportCheckTableName);

                DataTable dtTransfer = Data.getTable("Input", Params.Transfer);
                if (dtTransfer == null)
                    dtTransfer = Data.getTable("Input", GlobalNames.Alloc_TransferDeskTableName);

                DataTable dtPaxPlan = Data.getTable(ScenarioName, "PaxPlanTable");
                DataTable dtOCT_BoardingGate = Data.getTable("Input", Params.OCT_BG);
                if (dtOCT_BoardingGate == null)
                    dtOCT_BoardingGate = Data.getTable("Input", GlobalNames.OCT_BoardGateTableName);


                if (Data.UseAlphaNumericForFlightInfo)
                {
                    dtFPDTable = GestionDonneesHUB2SIM.ConvertFPDInformations(dtFPDTable, Data.getRacine(), false, false);
                    dtFPATable = GestionDonneesHUB2SIM.ConvertFPDInformations(dtFPATable, Data.getRacine(), false, false);
                }


                if ((dtBaggageClaimAllocation == null) || (dtCheckInAllocation == null) ||
                    (dtBoardingGateAllocation == null) || (dtFPDTable == null) ||
                    (dtOCT_CI_Table == null) || (dtFPATable == null) ||
                    (dtOCT_BC == null) || (dtOCT_BG == null) ||
                    (dtSecurity == null) || (dtPassport == null) ||
                    (dtTransfer == null) || (dtPaxPlan == null))
                {
                    return null;
                }

                // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation                
                //On crée une nouvelle instance de la classe PaxTraceAnalysis.
                PaxTraceAnalysis AnalysePaxTrace = new PaxTraceAnalysis(sOutputsDirectory, sBGLocation,
                    dPas, dWarmUp, GestionDonneesHUB2SIM.getWarningsErreursProject(), Params.AnalysisRange);
                // >> Task #8775 Pax2Sim - Occupation stat - Throughput calculation

                AnalysePaxTrace.dtPaxPlan = dtPaxPlan;
                if (Params.Opening_CITable != "")
                {
                    dtCheckInAllocation = Data.getTable("Input", Params.Opening_CITable);
                }
                else
                {

                    OverallTools.UpdateAllocation.effectuerCalculAllocation(dtFPDTable,
                        dtCheckInAllocation,
                        dtOCT_CI_Table, true, 5,
                        GlobalNames.sFPD_A_Column_DATE,
                        GlobalNames.sFPD_Column_STD,
                        GlobalNames.sFPD_A_Column_FlightCategory,
                        GlobalNames.sFPD_A_Column_ID,
                        GlobalNames.sFPD_A_Column_AirlineCode,
                        GlobalNames.sOCT_CI_Line_Opening,
                        GlobalNames.sOCT_CI_Line_Closing,
                        GlobalNames.sFPD_Column_TerminalCI,
                        true,
                        GlobalNames.sFPD_Column_FB_CI_Start,
                        GlobalNames.sFPD_Column_FB_CI_End,
                        "Check In",
                        GlobalNames.sFPD_Column_Eco_CI_Start,
                        GlobalNames.sFPD_Column_Eco_CI_End,
                        GestionDonneesHUB2SIM.getWarningsErreursProject());
                }

                OverallTools.UpdateAllocation.effectuerCalculAllocation(dtFPATable,
                    dtBaggageClaimAllocation,
                    dtOCT_BC,
                    false,
                    5,
                    GlobalNames.sFPD_A_Column_DATE,
                    GlobalNames.sFPA_Column_STA,
                    GlobalNames.sFPD_A_Column_FlightCategory,
                    GlobalNames.sFPD_A_Column_ID,
                    GlobalNames.sFPD_A_Column_AirlineCode,
                    GlobalNames.sOCT_Baggage_Line_Opening,
                    GlobalNames.sOCT_Baggage_Line_Closing,
                    GlobalNames.sFPA_Column_TerminalReclaim,
                    false,
                    GlobalNames.sFPA_Column_ReclaimObject,
                    null,
                    "Baggage Claim",
                    null,
                    null,
                    GestionDonneesHUB2SIM.getWarningsErreursProject());

                OverallTools.UpdateAllocation.effectuerCalculAllocation(dtFPDTable,
                    dtBoardingGateAllocation,
                    dtOCT_BG,
                    true,
                    5,
                    GlobalNames.sFPD_A_Column_DATE,
                    GlobalNames.sFPD_Column_STD,
                    GlobalNames.sFPD_A_Column_FlightCategory,
                    GlobalNames.sFPD_A_Column_ID,
                    GlobalNames.sFPD_A_Column_AirlineCode,
                    GlobalNames.sOCT_Board_Line_Opening,
                    GlobalNames.sOCT_Board_Line_Closing,
                    GlobalNames.sFPD_A_Column_TerminalGate,
                    false,
                    GlobalNames.sFPD_Column_BoardingGate,
                    null,
                    GlobalNames.sFPD_Column_BoardingGate,
                    null,
                    null,
                    GestionDonneesHUB2SIM.getWarningsErreursProject());


                //We open the babPlan.txt generated by the simulation
                AnalysePaxTrace.OpenBagPlan(ScenarioName, Data);

                //We finally open the paxtrace and we generate the differents objects that will contains the paxTrace.
                if (!AnalysePaxTrace.analysePaxTrace(Data, Params.DateDebut, Params.DateFin, dWarmUp, bSlidingHour, dtBaggageClaimAllocation,
                    dtCheckInAllocation, dtBoardingGateAllocation, dtPassport, dtSecurity, dtUserProcess, dtTransfer, Params.percentilesLevels))
                    return null;

                // We determined the flight and the times for each flight.
                FlightPlanAnalysis(AnalysePaxTrace.PaxResults,
                                   dtPaxPlan,
                                   dtFPDTable,
                                   dtFPATable,
                                   dtOCT_BoardingGate,
                                   AnalysePaxTrace.ErrorList_);
                if (PAX2SIM.bShowAllocationTools)
                {
                    AnalysePaxTrace.AnalyseBagList(dtFPATable, dtFPDTable);
                    //AnalysePaxTrace.AnalyseFPDtable(dtFPDTable);
                }

                // >> Task #8958 Reclaim Synchronisation mode Gantt
                string reclaimLogFullPath = "";

                string reclaimLogFullPathInTmpDirectory = "";
                if (sOutputsDirectory.EndsWith(".tmp"))
                {
                    string tempOutputDir = sOutputsDirectory.Substring(0, sOutputsDirectory.LastIndexOf("\\"));
                    reclaimLogFullPathInTmpDirectory = tempOutputDir + "\\" + "ReclaimLog.TXT";
                }
                else
                    reclaimLogFullPathInTmpDirectory = sOutputsDirectory + "ReclaimLog.TXT";

                string projectDirectoryPath = Data.getDossierEnregistrement();
                string scenarioDirectory = projectDirectoryPath + "Output\\" + ScenarioName + "\\";
                string reclaimLogFullPathInScenarioOutputDirectory = scenarioDirectory + GlobalNames.RECLAIM_LOG_FILE_NAME + ".txt";

                if (File.Exists(reclaimLogFullPathInTmpDirectory))
                    reclaimLogFullPath = reclaimLogFullPathInTmpDirectory;
                else if (File.Exists(reclaimLogFullPathInScenarioOutputDirectory))
                    reclaimLogFullPath = reclaimLogFullPathInScenarioOutputDirectory;
                // << Task #8958 Reclaim Synchronisation mode Gantt

                if (PAX2SIM.bJNK || Params.DynamicReclaimAllocation || reclaimLogFullPath != "")//File.Exists(sOutputsDirectory + "ReclaimLog.TXT"))
                {
                    DataTable reclaimLogDistribution = Data.getTable("Input", Params.reclaimBagsLimitDistributionTableName);

                    AnalysePaxTrace.dtAllocationMin = dtBaggageClaimAllocation.Clone();
                    AnalysePaxTrace.dtAllocationMin.Rows.Clear();
                    AnalysePaxTrace.dtAllocationResults = AnalysePaxTrace.getPassengerOccupation(reclaimLogFullPath,//sOutputsDirectory + "ReclaimLog.TXT",
                        sOutputsDirectory + "AllocationDelays.txt",
                        Params.DateDebut,
                        Params.DateFin,
                        dtFPATable,
                        AnalysePaxTrace.dtAllocationMin,
                        reclaimLogDistribution,
                        Params.Seed,
                        out AnalysePaxTrace.dtAllocationReclaim,
                        out AnalysePaxTrace.vmAllocationResults,
                        out AnalysePaxTrace.vmAllocationReclaim,
                        dPas);
                    if (AnalysePaxTrace.dtAllocationResults == null)
                        AnalysePaxTrace.dtAllocationMin = null;
                }
                AnalysePaxTrace.dtSimpleFPDTable = GestionDonneesHUB2SIM.calcOCT_FPD(dtFPDTable,
                    dtOCT_CI_Table, dtOCT_BG, new List<string>(), new List<string>(), Params.DateDebut, null, false);
                AnalysePaxTrace.dtFPDTableNormal = dtFPDTable;
                // >> Task #13206 Pax2Sim - Dynamic Analysis - Arrival Flight Statistics
                AnalysePaxTrace.dtSimpleFPATable = GestionDonneesHUB2SIM.calcOCT_FPA(dtFPATable, dtOCT_BC,
                    new List<string>(), new List<string>(), Params.DateDebut, null, false);
                AnalysePaxTrace.dtFPATableNormal = dtFPATable;
                // << Task #13206 Pax2Sim - Dynamic Analysis - Arrival Flight Statistics

                //if (bSaveTraceMode)
                //{
                //We copy the paxtrace in the temporary directory, to save it later with the project.
                String sTempDirectory = ExternFunctions.getTempDirectoryForPax2sim();
                if (sTempDirectory != "")
                {
                    if (ExternFunctions.CheckCreateDirectory(sTempDirectory))
                    {
                        String sPaxTrace = AnalysePaxTrace.sOutputsDirectory_;
                        if (!System.IO.File.Exists(sPaxTrace))
                        {
                            sPaxTrace += "PaxTrace.txt";
                        }
                        ExternFunctions.CopyFile(sTempDirectory + ScenarioName + "_PaxTrace.tmp", sPaxTrace, "", null, null, null);
                    }
                }
                //}

                // << Task #7949 Capacity Analysis - IST tables modification                
                setUserAttributes(AnalysePaxTrace, Data);
                setPaxUserAttributesValues(AnalysePaxTrace);
                // >> Task #7949 Capacity Analysis - IST tables modification

                return AnalysePaxTrace;
            }

            // << Task #7949 Capacity Analysis - IST tables modification

            /// <summary>
            /// Add the Dictionary containing the distribution table name and the distribution as Normal table
            ///  and add the user process table to the PaxTraceAnalysis object.
            /// </summary>
            /// <param name="AnalysePaxTrace">object that will receive the computed information about the user attributes</param>
            /// <param name="Data">data used to retrieve the tables</param>
            private static void setUserAttributes(PaxTraceAnalysis AnalysePaxTrace, GestionDonneesHUB2SIM Data)
            {
                Dictionary<string, NormalTable> distributionTables = new Dictionary<string, NormalTable>();
                DataTable paxPlan = AnalysePaxTrace.dtPaxPlan;
                if (paxPlan != null)
                {
                    int lastUnneededColumnIndex = -1;
                    //The last column in the pax plan before the User attributes can be:
                    //  Transfer(default), InOut(pax inout utilisation) or Car(parking Mulhouse).
                    //We can't depend on the PARKINGMULHOUSE/PAXINOUTUTILISATION parameters because theese might be 
                    //  diffrent when the scenario was generated as oposed to when the scenario is loaded.
                    if (paxPlan.Columns.Contains(GlobalNames.sPaxPlan_Car))
                        lastUnneededColumnIndex = paxPlan.Columns.IndexOf(GlobalNames.sPaxPlan_Car);
                    else if (paxPlan.Columns.Contains(GlobalNames.sPaxPlan_InOut))
                        lastUnneededColumnIndex = paxPlan.Columns.IndexOf(GlobalNames.sPaxPlan_InOut);
                    else
                        lastUnneededColumnIndex = paxPlan.Columns.IndexOf(GlobalNames.sPaxPlan_Transfer);

                    if (lastUnneededColumnIndex != -1)
                    {
                        int userAttributesColumnIndex = lastUnneededColumnIndex + 1;
                        while (paxPlan.Columns.Count > userAttributesColumnIndex)
                        {
                            String userAttributeName = paxPlan.Columns[userAttributesColumnIndex].ColumnName;
                            NormalTable distributionTable = Data.GetTable("Input", userAttributeName);
                            distributionTables.Add(userAttributeName, distributionTable);
                            userAttributesColumnIndex++;
                        }
                    }
                }
                // add the dictionary to the PaxTraceAnalysis object
                if (PaxTraceAnalysis.userAttributesDistributionTables != null)
                    PaxTraceAnalysis.userAttributesDistributionTables.Clear();
                PaxTraceAnalysis.userAttributesDistributionTables = distributionTables;
            }

            /// <summary>
            /// Calls setRandomsForUserAttributes() to set up the randoms for each user attribute
            ///  and then, for each pax calls setPaxUserAttributesValues() to set the values of the user attributes.
            /// </summary>
            /// <param name="AnalysePaxTrace">Object containing the Dictionary with all the pax and their information</param>
            private static void setPaxUserAttributesValues(PaxTraceAnalysis AnalysePaxTrace)
            {
                DataTable paxPlanTable = AnalysePaxTrace.dtPaxPlan;
                if (paxPlanTable != null)
                {
                    foreach (PaxResultsStruct PaxInformation in AnalysePaxTrace.PaxResults.Values)
                    {
                        copyPaxUserAttributesValuesFromPaxPlan(PaxInformation, paxPlanTable);
                    }
                }
            }

            private static void copyPaxUserAttributesValuesFromPaxPlan(PaxResultsStruct paxtmp, DataTable paxPlanTable)
            {
                //find in the paxPlan table and copy the row that contains the user attributes values for this pax
                int paxId = paxtmp.IdPax;
                DataRow[] paxPlanRow = null;
                if (paxPlanTable != null)
                    paxPlanRow = paxPlanTable.Select(GlobalNames.sPaxPlan_PaxID + " = " + paxId);

                if (userAttributesDistributionTables != null && paxPlanRow != null && paxPlanRow.Length > 0)
                {
                    foreach (KeyValuePair<string, DataManagement.NormalTable> pair in userAttributesDistributionTables)
                    {
                        String distributionTableName = pair.Key;
                        String userAttributeValue = null;
                        if (paxPlanTable.Columns.Contains(distributionTableName) && paxPlanRow[0][distributionTableName] != null)
                            userAttributeValue = paxPlanRow[0][distributionTableName].ToString();

                        if (userAttributeValue != null)
                            paxtmp.paxUserAttributesDictionary.Add(distributionTableName, userAttributeValue);
                    }
                }
            }

            // >> Task #7949 Capacity Analysis - IST tables modification            
            #endregion

            #region Fonctions pour générer les différentes classes avec les informations sur chaque pax et chaque Desk.
            #region Fonction qui s'occupe d'analyser le PaxTrace


            private bool AnalyseBagList(DataTable dtFPA, DataTable dtFPD)
            {
                if (!System.IO.File.Exists(sOutputsDirectory_ + "BagList.txt"))
                    return false;
                try
                {
                    dtBagList = new DataTable("BagList");
                    if (!OverallTools.FonctionUtiles.LectureFichier(dtBagList, sOutputsDirectory_ + "BagList.txt", "\t", ErrorList_))
                    {
                        dtBagList = null;
                        return false;
                    }
                    Hashtable htFPD = new Hashtable();
                    Hashtable htFPA = new Hashtable();
                    foreach (DataRow drRow in dtFPD.Rows)
                    {
                        htFPD.Add(drRow[GlobalNames.sFPD_A_Column_ID].ToString(), drRow[GlobalNames.sFPD_A_Column_FlightN].ToString());
                    }
                    foreach (DataRow drRow in dtFPA.Rows)
                    {
                        htFPA.Add(drRow[GlobalNames.sFPD_A_Column_ID].ToString(), drRow[GlobalNames.sFPD_A_Column_FlightN].ToString());
                    }
                    foreach (DataRow drRow in dtBagList.Rows)
                    {
                        if (drRow["ArrFlightName"].ToString() != "")
                        {
                            if (htFPA.ContainsKey(drRow["ArrFlightName"].ToString()))
                                drRow["ArrFlightName"] = (String)htFPA[drRow["ArrFlightName"].ToString()];
                        }
                        if (drRow["DepFlightName"].ToString() != "")
                        {
                            if (htFPD.ContainsKey(drRow["DepFlightName"].ToString()))
                                drRow["DepFlightName"] = (String)htFPD[drRow["DepFlightName"].ToString()];
                        }
                    }
                }
                catch (Exception exc)
                {
                    dtBagList = null;
                    OverallTools.ExternFunctions.PrintLogFile("Except02023: " + this.GetType().ToString() + " throw an exception: " + exc.Message);
                    return false;
                }
                return true;
            }
            private bool AnalyseFPDtable(DataTable dtFPD)
            {
                dtFPDTable_ = new DataTable(GlobalNames.FPDTableName);
                dtFPDTable_.Columns.Add("DepFlightName", typeof(String));
                dtFPDTable_.Columns.Add("DepFlightType", typeof(String));
                dtFPDTable_.Columns.Add("Day", typeof(String));
                dtFPDTable_.Columns.Add("STD", typeof(String));
                dtFPDTable_.Columns.Add("DestArea", typeof(String));
                dtFPDTable_.Columns.Add("SEG", typeof(String));
                dtFPDTable_.Columns.Add("AircraftCode", typeof(String));
                dtFPDTable_.Columns.Add("Bags", typeof(String));
                foreach (DataRow drLine in dtFPD.Rows)
                {
                    if ((int)drLine[GlobalNames.sFPD_A_Column_TerminalParking] != 2)
                        continue;
                    DataRow drNewLine = dtFPDTable_.NewRow();
                    drNewLine[0] = drLine[GlobalNames.sFPD_A_Column_FlightN].ToString();
                    drNewLine[1] = drLine[GlobalNames.sFPD_A_Column_FlightCategory].ToString();
                    drNewLine[2] = drLine[GlobalNames.sFPD_A_Column_DATE].ToString();
                    drNewLine[3] = drLine[GlobalNames.sFPD_Column_STD].ToString();
                    switch ((int)drLine[GlobalNames.sFPD_A_Column_Parking])
                    {
                        case 1:
                            drNewLine[4] = "T2A";
                            break;
                        case 2:
                            drNewLine[4] = "T2B";
                            break;
                        case 3:
                            drNewLine[4] = "T2C";
                            break;
                        default:
                            drNewLine.Delete();
                            continue;
                    }
                    drNewLine[5] = "";
                    drNewLine[6] = drLine[GlobalNames.sFPD_A_Column_AircraftType].ToString();
                    drNewLine[5] = "0";
                    dtFPDTable_.Rows.Add(drNewLine);
                }
                return true;
            }

            /// <summary>
            /// Function use for analyse the PaxTrace.
            /// </summary>
            /// <param name="Data">The current project, only to know the airport structure.</param>
            /// <param name="BeginDate">The simulation starting date.</param>
            /// <param name="EndDate">The simulation ending date.</param>
            /// <param name="dtBaggageClaimAllocation">The table allocation for the baggage claim</param>
            /// <param name="dtCheckInAllocation">The table allocation for the check in</param>
            /// <param name="dtBoardingGateAllocation">The table allocation for the boarding gate</param>
            /// <param name="dtPassportAllocation">The table allocation for the passport</param>
            /// <param name="dtSecurityAllocation">The table allocation for the security</param>
            /// <param name="dtUserProcessAllocation">The table allocation for the User process</param>
            /// <param name="dtTransferAllocation">The table allocation for the transfer</param>
            /// <returns>Return a boolean which indicate if the analysis work properly or not.</returns>
            public Boolean analysePaxTrace(GestionDonneesHUB2SIM Data,
                                           DateTime BeginDate,
                                           DateTime EndDate,
                                           Double dWarmUp,
                                           bool bSlidingHour,
                                           DataTable dtBaggageClaimAllocation,
                                           DataTable dtCheckInAllocation,
                                           DataTable dtBoardingGateAllocation,
                                           DataTable dtPassportAllocation,
                                           DataTable dtSecurityAllocation,
                                           DataTable dtUserProcessAllocation,   // << Task #7570 new Desk and extra information for Pax -Phase I B
                                           DataTable dtTransferAllocation,
                                           List<double> paramPercentiles)   // >> Task #9936 Pax2Sim - project properties saved specifically for each scenario + Times stats Spec 
            {
                dtBeginTime_ = BeginDate;
                dtEndTime_ = EndDate;
                bSlidingHour_ = bSlidingHour;

                if (paramPercentiles == null || paramPercentiles.Count == 0)
                {
                    percentilesLevels_ = Data.Levels;// >> Bug #14922 Pax2Sim - BHS trace - Time chute to Exit Segregation per line problem
                }
                else if (paramPercentiles.Count == 3)
                {
                    percentilesLevels_ = new double[3];
                    percentilesLevels_[0] = paramPercentiles[0];
                    percentilesLevels_[1] = paramPercentiles[1];
                    percentilesLevels_[2] = paramPercentiles[2];
                }

                String uneLigne;
                String sPaxTrace = sOutputsDirectory_;
                if (!System.IO.File.Exists(sPaxTrace))
                {
                    sPaxTrace += "PaxTrace.txt";
                }
                if (!System.IO.File.Exists(sPaxTrace))
                {
                    ErrorList_.Add("Err00127 : A problem appear when trying to read the Automod file result");
                    return false;
                }
                System.IO.StreamReader monLecteur = new System.IO.StreamReader(sPaxTrace);
                if (monLecteur == null)
                    return false;
                PaxInformations_ = null;

                int IdPax;              //L'identifiant du passager
                String[] valeurs;       //Les différents points de cheminement du passager
                bool bValue, bGroup;    //Booleen indiquant s'il s'agit d'une valeur ou non, et s'il s'agit d'un groupe ou non.
                String sResult;         //String which contains the word read in the line.
                double dValue;          //The value read n the line.
                bool bAncTypeEstDesk;   //Bool to know if the last value was a desk or not.
                int iIndexValeur;       //Index to know which value is processed (from 0 to 4).
                String sAncienDesk;     //The name of the last desk.
                String sDesk;           //The name of the current desk.
                int iGroupDeskType = -1;            //Le type de bureau ou de groupe par lequel le Pax vient de transiter.
                int iLastGroupDeskType = -1;
                int iIndexDesk = 0;
                int iAncienIndexDesk;
                // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)                
                double[] tdValues = new double[5];
                // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)

                while (monLecteur.Peek() != -1)
                {
                    uneLigne = monLecteur.ReadLine();
                    uneLigne = uneLigne.Trim();
                    valeurs = uneLigne.Split('\t');
                    if (!Int32.TryParse(valeurs[0], out IdPax))
                    {
                        ErrorList_.Add("Err00121 : PaxTrace contains errors");
                        continue;
                    }
                    PaxResultsStruct PaxTmp = new PaxResultsStruct(IdPax);
                    PaxResults.Add(IdPax, PaxTmp);

                    bAncTypeEstDesk = false;
                    iLastGroupDeskType = -1;
                    iIndexValeur = 0;
                    iAncienIndexDesk = 0;
                    sDesk = "";
                    sAncienDesk = "";
                    int j;
                    // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                    for (j = 0; j < 5; j++)
                    {
                        tdValues[j] = 0;
                    }
                    // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                    for (int i = 1; i < valeurs.Length; i++)
                    {
                        if (
                            !ConvertGroupDesk(valeurs[i], out bValue, out bGroup, out sResult, out dValue,
                                              out iGroupDeskType, out iIndexDesk))
                        {
                            ErrorList_.Add("Err00122 : PaxTrace contains errors");
                            return false;
                        }

                        if (!bValue)
                        {
                            if (sResult == "")
                                continue;
                            if ((sResult.ToLower() == "missed") || (sResult.ToLower() == "stopped")
                                || (sResult.ToLower() == "lost"))
                            {
                                PaxTmp.HadMissed = (sResult.ToLower() == "missed");
                                PaxTmp.Stopped = (sResult.ToLower() == "stopped");
                                PaxTmp.Lost = (sResult.ToLower() == "lost");

                                // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)                                
                                if (bAncTypeEstDesk && iIndexValeur < 5)
                                // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                                {
                                    PaxTmp.AddPaxTravel(sDesk, false, tdValues[0], tdValues[2] - tdValues[1], 0, tdValues[1] - tdValues[0]);
                                }
                                // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)                                
                                else if (iIndexValeur < 5)
                                // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                                {
                                    PaxTmp.AddPaxTravel(sDesk, !bAncTypeEstDesk, tdValues[0], 0, 0, tdValues[1] - tdValues[0]);
                                }
                                // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)                                                                
                                if (PaxTmp.Lost || iIndexValeur == 5)
                                    break;
                                // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                                //break;
                            }
                            else
                            {
                                if (bGroup)
                                {
                                    if (iLastGroupDeskType == 0)
                                    {
                                        // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                                        //We enter here for Levels => Levels don't have delay time so we set it to 0.
                                        double delayTime = 0;
                                        if (tdValues[1] > tdValues[0])
                                            delayTime = tdValues[1] - tdValues[0];
                                        PaxTmp.AddPaxTravel(sDesk, !bAncTypeEstDesk, tdValues[0], 0, 0, delayTime);
                                        // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                                    }
                                    if (iLastGroupDeskType != iGroupDeskType)
                                    {
                                        // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)                                                                                
                                        for (j = 0; j < 5; j++)
                                        {
                                            tdValues[j] = 0;
                                        }
                                        // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                                    }
                                    iIndexValeur = 0;
                                }
                                else if (iLastGroupDeskType == iGroupDeskType)
                                {
                                    // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)                                    
                                    iIndexValeur = 2; // [0], [1] are delay and group queue entry time
                                    // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                                }
                                iAncienIndexDesk = iIndexDesk;
                                bAncTypeEstDesk = !bGroup;
                                sAncienDesk = sDesk;
                                sDesk = sResult;
                                iLastGroupDeskType = iGroupDeskType;
                                continue;
                            }
                        }
                        else
                        {
                            tdValues[iIndexValeur] = dValue;
                            iIndexValeur++;
                        }
                        /*if (dValue < dWarmUp)
                        {
                            continue;
                        }*/
                        // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)                        
                        if (iIndexValeur == 3 && (!(PaxTmp.HadMissed || PaxTmp.Stopped)))
                        {
                            PaxTmp.AddPaxTravel(sAncienDesk, true, tdValues[0], tdValues[2] - tdValues[1], 0, tdValues[1] - tdValues[0]);
                        }
                        // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)

                        // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)                                                
                        if (iIndexValeur == 5 || PaxTmp.HadMissed || PaxTmp.Stopped)
                        // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                        {
                            Double dDelay = -1;
                            Double dProcess = -1;
                            Double dWaitingGroup = -1;
                            Double dWaitingDesk = -1;

                            // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)                            
                            if (tdValues[1] >= tdValues[0])
                                dDelay = tdValues[1] - tdValues[0];

                            if (tdValues[2] >= tdValues[1] && dDelay >= 0)
                                dWaitingGroup = tdValues[2] - tdValues[1];

                            if ((tdValues[3] >= tdValues[2]) && (dWaitingGroup >= 0))
                                dWaitingDesk = tdValues[3] - tdValues[2];

                            // << Task #8618 Pax2Sim - Dynamic Analysis - Pax - histograns and timeline tables for Dwell Area
                            if (tdValues[4] >= tdValues[3] && dWaitingDesk >= 0)
                                dProcess = tdValues[4] - tdValues[3];
                            // >> Task #8618 Pax2Sim - Dynamic Analysis - Pax - histograns and timeline tables for Dwell Area
                            // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)

                            // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)                                                        
                            if (iIndexValeur >= 3)
                            // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)                            
                            {
                                // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)                                
                                //we have a desk to add => the first 2 values are group values(pax arrival at group and group entry). The 3rd(tdValues[3]) is the desk arrival time.
                                if (iIndexValeur == 5)
                                    PaxTmp.AddPaxTravel(sDesk, false, tdValues[2], dWaitingDesk, dProcess, dDelay);
                                // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)

                                if (!DeskResults.ContainsKey(sDesk))
                                {
                                    #region Ajout à la liste de l'objet manquant.

                                    DeskResults.Add(sDesk, new DeskGroupResultsStruct(sDesk, BeginDate));
                                    if (iLastGroupDeskType == GestionDonneesHUB2SIM.BaggageClaimGroup)
                                    {
                                        ((DeskGroupResultsStruct)DeskResults[sDesk]).TotalOpeningTime =
                                            AnalyseOpeningTime(dtBaggageClaimAllocation, BeginDate, EndDate, sDesk);
                                        ((DeskGroupResultsStruct)DeskResults[sDesk]).AllocationTable =
                                            dtBaggageClaimAllocation;
                                        ((DeskGroupResultsStruct)DeskResults[sDesk]).ColumnIndex =
                                            dtBaggageClaimAllocation.Columns.IndexOf(sDesk);
                                        ((DeskGroupResultsStruct)DeskResults[sDesk]).IndexDesk = -1;
                                    }
                                    else if (iLastGroupDeskType == GestionDonneesHUB2SIM.CheckInGroup)
                                    {
                                        ((DeskGroupResultsStruct)DeskResults[sDesk]).TotalOpeningTime =
                                            AnalyseOpeningTime(dtCheckInAllocation, BeginDate, EndDate, sDesk);
                                        ((DeskGroupResultsStruct)DeskResults[sDesk]).AllocationTable =
                                            dtCheckInAllocation;
                                        ((DeskGroupResultsStruct)DeskResults[sDesk]).ColumnIndex =
                                            dtCheckInAllocation.Columns.IndexOf(sDesk);
                                        ((DeskGroupResultsStruct)DeskResults[sDesk]).IndexDesk = -1;
                                    }
                                    else if (iLastGroupDeskType == GestionDonneesHUB2SIM.BoardingGateGroup)
                                    {
                                        ((DeskGroupResultsStruct)DeskResults[sDesk]).TotalOpeningTime =
                                            AnalyseOpeningTime(dtBoardingGateAllocation, BeginDate, EndDate, sDesk);
                                        ((DeskGroupResultsStruct)DeskResults[sDesk]).AllocationTable =
                                            dtBoardingGateAllocation;
                                        ((DeskGroupResultsStruct)DeskResults[sDesk]).ColumnIndex =
                                            dtBoardingGateAllocation.Columns.IndexOf(sDesk);
                                        ((DeskGroupResultsStruct)DeskResults[sDesk]).IndexDesk = -1;
                                    }
                                    else if (iLastGroupDeskType == GestionDonneesHUB2SIM.PassportCheckGroup)
                                    {
                                        int[] tiGroup = DataFunctions.AnalyzeGroupName(sAncienDesk);
                                        int iIndexFirst = Data.getIndexFirstDesk(tiGroup[0], /*tiGroup[1],*/ tiGroup[2],
                                                                                 tiGroup[3]);
                                        ((DeskGroupResultsStruct)DeskResults[sDesk]).TotalOpeningTime =
                                            AnalyseOpeningTime(dtPassportAllocation, BeginDate, EndDate, sAncienDesk,
                                                               iAncienIndexDesk - iIndexFirst + 1);
                                        ((DeskGroupResultsStruct)DeskResults[sDesk]).AllocationTable =
                                            dtPassportAllocation;
                                        ((DeskGroupResultsStruct)DeskResults[sDesk]).ColumnIndex =
                                            dtPassportAllocation.Columns.IndexOf(sAncienDesk);
                                        ((DeskGroupResultsStruct)DeskResults[sDesk]).IndexDesk = iAncienIndexDesk;
                                    }
                                    else if (iLastGroupDeskType == GestionDonneesHUB2SIM.SecurityCheckGroup)
                                    {
                                        int[] tiGroup = DataFunctions.AnalyzeGroupName(sAncienDesk);
                                        int iIndexFirst = Data.getIndexFirstDesk(tiGroup[0], /*tiGroup[1],*/ tiGroup[2],
                                                                                 tiGroup[3]);
                                        ((DeskGroupResultsStruct)DeskResults[sDesk]).TotalOpeningTime =
                                            AnalyseOpeningTime(dtSecurityAllocation, BeginDate, EndDate, sAncienDesk,
                                                               iAncienIndexDesk - iIndexFirst + 1);
                                        ((DeskGroupResultsStruct)DeskResults[sDesk]).AllocationTable =
                                            dtSecurityAllocation;
                                        ((DeskGroupResultsStruct)DeskResults[sDesk]).ColumnIndex =
                                            dtSecurityAllocation.Columns.IndexOf(sAncienDesk);
                                        ((DeskGroupResultsStruct)DeskResults[sDesk]).IndexDesk = iAncienIndexDesk;
                                    }
                                    // << Task #7570 new Desk and extra information for Pax -Phase I B
                                    else if (iLastGroupDeskType == GestionDonneesHUB2SIM.ShuttleGroup)
                                    {
                                        int[] tiGroup = DataFunctions.AnalyzeGroupName(sAncienDesk);
                                        int iIndexFirst = Data.getIndexFirstDesk(tiGroup[0], /*tiGroup[1],*/ tiGroup[2],
                                                                                 tiGroup[3]);
                                        ((DeskGroupResultsStruct)DeskResults[sDesk]).TotalOpeningTime =
                                            AnalyseOpeningTime(dtUserProcessAllocation, BeginDate, EndDate, sAncienDesk,
                                                               iAncienIndexDesk - iIndexFirst + 1);
                                        ((DeskGroupResultsStruct)DeskResults[sDesk]).AllocationTable =
                                            dtUserProcessAllocation;
                                        ((DeskGroupResultsStruct)DeskResults[sDesk]).ColumnIndex =
                                            dtUserProcessAllocation.Columns.IndexOf(sAncienDesk);
                                        ((DeskGroupResultsStruct)DeskResults[sDesk]).IndexDesk = iAncienIndexDesk;
                                    }
                                    // >> Task #7570 new Desk and extra information for Pax -Phase I B
                                    else if (iLastGroupDeskType == GestionDonneesHUB2SIM.TransferGroup)
                                    {
                                        int[] tiGroup = DataFunctions.AnalyzeGroupName(sAncienDesk);
                                        int iIndexFirst = Data.getIndexFirstDesk(tiGroup[0], /*tiGroup[1],*/ tiGroup[2],
                                                                                 tiGroup[3]);
                                        ((DeskGroupResultsStruct)DeskResults[sDesk]).TotalOpeningTime =
                                            AnalyseOpeningTime(dtTransferAllocation, BeginDate, EndDate, sAncienDesk,
                                                               iAncienIndexDesk - iIndexFirst + 1);
                                        ((DeskGroupResultsStruct)DeskResults[sDesk]).AllocationTable =
                                            dtTransferAllocation;
                                        ((DeskGroupResultsStruct)DeskResults[sDesk]).ColumnIndex =
                                            dtTransferAllocation.Columns.IndexOf(sAncienDesk);
                                        ((DeskGroupResultsStruct)DeskResults[sDesk]).IndexDesk = iAncienIndexDesk;
                                    }

                                    #endregion
                                }
                                if ((PaxTmp.HadMissed) || (PaxTmp.Stopped))
                                {
                                    // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)                                    
                                    ((DeskGroupResultsStruct)DeskResults[sDesk]).AddPaxPassingMissedStopped(PaxTmp,
                                                                                                             tdValues[0],
                                                                                                             dWaitingDesk,
                                                                                                             dWaitingGroup,
                                                                                                             dDelay);
                                    // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                                }

                                else
                                    // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                                    ((DeskGroupResultsStruct)DeskResults[sDesk]).AddPaxPassing(PaxTmp, tdValues[0],
                                                                                                tdValues[4] - tdValues[3],
                                                                                                tdValues[3] - tdValues[2],
                                                                                                tdValues[2] - tdValues[1],
                                                                                                tdValues[1] - tdValues[0]);
                                // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                            }
                            else
                            {
                                sAncienDesk = sDesk;
                            }
                            /*if (iIndexValeur < 2)
                                continue;*/
                            if (!DeskResults.ContainsKey(sAncienDesk))
                            {
                                DeskResults.Add(sAncienDesk, new DeskGroupResultsStruct(sAncienDesk, BeginDate));
                            }
                            if ((PaxTmp.HadMissed) || (PaxTmp.Stopped))
                            {
                                // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)                                
                                ((DeskGroupResultsStruct)DeskResults[sAncienDesk]).AddPaxPassingMissedStopped(PaxTmp,
                                                                                                               tdValues[0],
                                                                                                               dWaitingDesk,
                                                                                                               dWaitingGroup,
                                                                                                               dDelay);
                                // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                            }

                            else
                                // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)                                
                                ((DeskGroupResultsStruct)DeskResults[sAncienDesk]).AddPaxPassing(PaxTmp, tdValues[0],
                                                                                                  tdValues[4] - tdValues[3],
                                                                                                  tdValues[3] - tdValues[2],
                                                                                                  tdValues[2] - tdValues[1],
                                                                                                  tdValues[1] - tdValues[0]);
                            // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                        }
                    }
                }
                monLecteur.Close();
                return true;
            }

            /// <summary>
            /// Function used to load the BagPlan.
            /// </summary>
            /// <returns>Return a boolean which indicate if BagPlan had been loaded.</returns>
            public Boolean OpenBagPlan(String sScenarioName, GestionDonneesHUB2SIM Data)
            {
                dtBagPlan = null;
                //Le BagPlan n'a pas été généré.
                if (!PAX2SIM.bBHS_BagPlan)
                    return true;

                if (!System.IO.File.Exists(sOutputsDirectory_ + "BagPlan.txt"))
                {
                    ErrorList_.Add("Err00162 : Unable to find the output file BagPlan.txt. File ignored.");
                    return false;
                }
                //On ouvre le bagplan et on le charge dans un nouveau fichier.
                dtBagPlan = new DataTable(GestionDonneesHUB2SIM.sTableBagPlan);
                FonctionUtiles.initialiserTable(dtBagPlan, GestionDonneesHUB2SIM.ListeEntete_BagPlan,
                    GestionDonneesHUB2SIM.ListeTypeEntete_BagPlan, null);
                if (!FonctionUtiles.LectureFichier(dtBagPlan, sOutputsDirectory_ + "BagPlan.txt", "\t", ErrorList_))
                {
                    ErrorList_.Add("Err163 : Unable to load the output file BagPlan.txt. File ignored.");
                    return false;
                }
                Data.AddReplaceTable(sScenarioName, dtBagPlan);

                //new Bag Plan
                // << Sodexi Task#7129 Bagplan Update
                DataTable dtBagPlan2 = null;
                if (!System.IO.File.Exists(sOutputsDirectory_ + "BagPlan_2.txt"))
                {
                    ErrorList_.Add("Err00162 : Unable to find the output file BagPlan_2.txt. File ignored.");
                    return false;
                }
                dtBagPlan2 = new DataTable(GlobalNames.BagPlan2Name);
                FonctionUtiles.initialiserTable(dtBagPlan2, GestionDonneesHUB2SIM.bagPlan2HeaderList,
                    GestionDonneesHUB2SIM.bagPlan2HeaderTypeList, null);
                if (!FonctionUtiles.LectureFichier(dtBagPlan2, sOutputsDirectory_ + "BagPlan_2.txt", "\t", ErrorList_))
                {
                    ErrorList_.Add("Err163 : Unable to load the output file BagPlan_2.txt. File ignored.");
                    return false;
                }
                Data.AddReplaceTable(sScenarioName, dtBagPlan2);
                // >> Sodexi Task#7129 Bagplan Update
                return true;
            }
            #endregion

            #region Fonction qui se charge de vérifier les temps d'ouverture pour les tables allouées automatiquement par le programme.
            /// <summary>
            /// Function use for determine the total openning time of the named desk.
            /// </summary>
            /// <param name="dtAllocationTable">The allocation table for this kind of desk.</param>
            /// <param name="dtBeginDate">The simulation starting date.</param>
            /// <param name="dtEndDate">The simulation ending date.</param>
            /// <param name="sNameColumn">The analysed desk name.</param>
            /// <returns>Return the total openning time on the selected range.</returns>
            public static Double AnalyseOpeningTime(DataTable dtAllocationTable, DateTime dtBeginDate, DateTime dtEndDate, String sNameColumn)
            {
                if (dtAllocationTable == null)
                    return 0.0;
                if (!dtAllocationTable.Columns.Contains(sNameColumn))
                    return 0.0;
                return AnalyseOpeningTime(dtAllocationTable, dtBeginDate, dtEndDate, dtAllocationTable.Columns.IndexOf(sNameColumn));
            }
            /// <summary>
            /// Function use for determine the total openning time of the selected desk.
            /// </summary>
            /// <param name="dtAllocationTable">The allocation table for this kind of desk.</param>
            /// <param name="dtBeginDate">The simulation starting date.</param>
            /// <param name="dtEndDate">The simulation ending date.</param>
            /// <param name="iIndexColumn">The index of the column</param>
            /// <returns>Return the total openning time on the selected range.</returns>
            public static Double AnalyseOpeningTime(DataTable dtAllocationTable, DateTime dtBeginDate, DateTime dtEndDate, Int32 iIndexColumn)
            {
                Double TimeStep = 0;
                if (dtAllocationTable.Rows.Count > 2)
                {
                    TimeStep = OverallTools.DataFunctions.MinuteDifference((DateTime)dtAllocationTable.Rows[0][0], (DateTime)dtAllocationTable.Rows[1][0]);
                }
                Double Result = 0;
                foreach (DataRow line in dtAllocationTable.Rows)
                {
                    if ((((DateTime)line[0]) >= dtBeginDate) && ((DateTime)line[0]) < dtEndDate)
                    {
                        if ((dtAllocationTable.Columns[iIndexColumn].DataType == typeof(Boolean)) ||
                            (dtAllocationTable.Columns[iIndexColumn].DataType == typeof(Boolean)))
                        {
                            if ((Boolean)line[iIndexColumn])
                                Result += TimeStep;
                        }
                        else if (line[iIndexColumn].ToString() != "")
                        {
                            Result += TimeStep;
                        }

                    }
                }
                return Result;
            }

            public static Double AnalyseGroupOpeningTime(DataTable dtAllocationTable, DateTime dtBeginDate, DateTime dtEndDate)
            {
                if (dtAllocationTable == null)
                    return 0.0;

                Double TimeStep = 0;
                if (dtAllocationTable.Rows.Count > 2)
                {
                    TimeStep = OverallTools.DataFunctions.MinuteDifference((DateTime)dtAllocationTable.Rows[0][0], (DateTime)dtAllocationTable.Rows[1][0]);
                }

                Double Result = 0;
                List<int> timeSlotIndexesUsedList = new List<int>();
                for (int k = 1; k < dtAllocationTable.Columns.Count; k++)
                {

                    for (int i = 0; i < dtAllocationTable.Rows.Count; i++)
                    {
                        DataRow line = dtAllocationTable.Rows[i];

                        if ((((DateTime)line[0]) >= dtBeginDate) && ((DateTime)line[0]) < dtEndDate)
                        {
                            if ((dtAllocationTable.Columns[k].DataType == typeof(Boolean)) ||
                                (dtAllocationTable.Columns[k].DataType == typeof(Boolean)))
                            {
                                if ((Boolean)line[k])
                                    //Result += TimeStep;
                                    if (!timeSlotIndexesUsedList.Contains(i))
                                        timeSlotIndexesUsedList.Add(i);
                            }
                            else if (line[k].ToString() != "")
                            {
                                //Result += TimeStep;
                                if (!timeSlotIndexesUsedList.Contains(i))
                                    timeSlotIndexesUsedList.Add(i);
                            }
                        }
                    }
                }
                Result = TimeStep * timeSlotIndexesUsedList.Count;
                return Result;
            }

            /// <summary>
            /// Function use for determine the total openning time of the selected desk.
            /// </summary>
            /// <param name="dtAllocationTable">The allocation table for this kind of desk.</param>
            /// <param name="dtBeginDate">The simulation starting date.</param>
            /// <param name="dtEndDate">The simulation ending date.</param>
            /// <param name="sNameColumn">The name of the column</param>
            /// <param name="iIndexDesk">The index of the analysed desk.</param>
            /// <returns>Return the total openning time on the selected range.</returns>
            public static Double AnalyseOpeningTime(DataTable dtAllocationTable, DateTime dtBeginDate, DateTime dtEndDate, String sNameColumn, int iIndexDesk)
            {
                if (dtAllocationTable == null)
                    return 0.0;
                if (!dtAllocationTable.Columns.Contains(sNameColumn))
                    return 0.0;
                return AnalyseOpeningTime(dtAllocationTable, dtBeginDate, dtEndDate, dtAllocationTable.Columns.IndexOf(sNameColumn), iIndexDesk);
            }

            // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
            public static Double AnalyseOpeningTime(DataTable dtAllocationTable, DateTime dtBeginDate, DateTime dtEndDate, Int32 iIndexColumn, int iIndexDesk)
            {
                if (iIndexColumn >= dtAllocationTable.Columns.Count)
                    return 0.0;
                Double TimeStep = 0;
                if (dtAllocationTable.Rows.Count > 2)
                {
                    TimeStep = OverallTools.DataFunctions.MinuteDifference((DateTime)dtAllocationTable.Rows[0][0], (DateTime)dtAllocationTable.Rows[1][0]);
                }
                Double Result = 0;
                foreach (DataRow line in dtAllocationTable.Rows)
                {
                    if ((((DateTime)line[0]) >= dtBeginDate) && ((DateTime)line[0]) < dtEndDate)
                    {
                        if (line[iIndexColumn].ToString() != "")
                        {
                            if ((dtAllocationTable.Columns[iIndexColumn].DataType == typeof(String)) ||
                                (dtAllocationTable.Columns[iIndexColumn].DataType == typeof(string)))
                            {
                                Double maxNbOfDesksOpened;
                                String[] sInformations = line[iIndexColumn].ToString().Split(';');
                                if (sInformations.Length == 0 || !Double.TryParse(sInformations[0], out maxNbOfDesksOpened))
                                {
                                    return 0.0;
                                }

                                if (iIndexDesk <= maxNbOfDesksOpened)
                                {
                                    Result += TimeStep;
                                }
                            }
                            else
                            {
                                if (iIndexDesk <= (Double)line[iIndexColumn])
                                {
                                    Result += TimeStep;
                                }
                            }
                        }
                    }
                }
                return Result;
            }

            /// <summary>
            /// Function use for determine the total openning time of the selected desk.
            /// </summary>
            /// <param name="dtAllocationTable">The allocation table for this kind of desk.</param>
            /// <param name="dtBeginDate">The simulation starting date.</param>
            /// <param name="dtEndDate">The simulation ending date.</param>
            /// <param name="sNameColumn">The index of the column</param>
            /// <param name="iIndexDesk">The index of the analysed desk.</param>
            /// <returns>Return the total openning time on the selected range.</returns>
            public static Double AnalyseOpeningTime_(DataTable dtAllocationTable, DateTime dtBeginDate, DateTime dtEndDate, Int32 iIndexColumn, int iIndexDesk)
            {
                if (iIndexColumn >= dtAllocationTable.Columns.Count)
                    return 0.0;
                Double TimeStep = 0;
                if (dtAllocationTable.Rows.Count > 2)
                {
                    TimeStep = OverallTools.DataFunctions.MinuteDifference((DateTime)dtAllocationTable.Rows[0][0], (DateTime)dtAllocationTable.Rows[1][0]);
                }
                Double Result = 0;
                foreach (DataRow line in dtAllocationTable.Rows)
                {
                    if ((((DateTime)line[0]) >= dtBeginDate) && ((DateTime)line[0]) < dtEndDate)
                    {
                        if (line[iIndexColumn].ToString() != "")
                        {
                            if ((dtAllocationTable.Columns[iIndexColumn].DataType == typeof(String)) ||
                                (dtAllocationTable.Columns[iIndexColumn].DataType == typeof(string)))
                            {
                                Double dValue;
                                String[] sInformations = line[iIndexColumn].ToString().Split(',');
                                if ((sInformations.Length != 2) || (!Double.TryParse(sInformations[1], out dValue)))
                                {
                                    return 0.0;
                                }
                                if ((sInformations[0] == "1") || (sInformations[0] == "2") || (sInformations[0] == "3"))
                                {
                                    if (iIndexDesk <= dValue)
                                    {
                                        Result += TimeStep;
                                    }
                                }
                                else
                                {
                                    return 0.0;
                                }
                            }
                            else
                            {
                                if (iIndexDesk <= (Double)line[iIndexColumn])
                                {
                                    Result += TimeStep;
                                }
                            }
                        }
                    }
                }
                return Result;
            }

            public static Double AnalyseGroupOpeningTimeUsingPlanningTable(DataTable dtPlanningTable, DateTime dtBeginDate, DateTime dtEndDate, Int32 iIndexColumn)
            {
                if (dtPlanningTable == null || iIndexColumn == -1 || iIndexColumn >= dtPlanningTable.Columns.Count)
                    return 0.0;

                Double TimeStep = 0;
                if (dtPlanningTable.Rows.Count > 2)
                {
                    TimeStep = OverallTools.DataFunctions.MinuteDifference((DateTime)dtPlanningTable.Rows[0][0], (DateTime)dtPlanningTable.Rows[1][0]);
                }
                Double Result = 0;
                foreach (DataRow line in dtPlanningTable.Rows)
                {
                    if ((((DateTime)line[0]) >= dtBeginDate) && ((DateTime)line[0]) < dtEndDate)
                    {
                        if (line[iIndexColumn].ToString() != "")
                        {
                            if ((dtPlanningTable.Columns[iIndexColumn].DataType == typeof(String)) ||
                                (dtPlanningTable.Columns[iIndexColumn].DataType == typeof(string)))
                            {
                                Double maxNbOfDesksOpened;
                                String[] sInformations = line[iIndexColumn].ToString().Split(';');
                                if (sInformations.Length == 0 || !Double.TryParse(sInformations[0], out maxNbOfDesksOpened))
                                {
                                    return 0.0;
                                }

                                if (maxNbOfDesksOpened > 0)
                                {
                                    Result += TimeStep;
                                }
                            }
                        }
                    }
                }
                return Result;
            }

            // << Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
            #endregion

            #region Fonction pour convertir une information du paxtrace en une données préanalysée.
            public static bool ConvertGroupDesk(String ligne, out bool bValue, out bool bGroup, out String sResult, out Double dValue, out int GroupDeskType, out int iIndexDesk)
            {
                bValue = false;
                bGroup = false;
                sResult = null;
                dValue = 0;
                iIndexDesk = 0;
                GroupDeskType = 0;
                int iNbUnderScore = OverallTools.FonctionUtiles.nombreCaractere(ligne, '_');
                if (iNbUnderScore == 0)
                {
                    if (!Double.TryParse(ligne, out dValue))
                    {
                        if ((ligne.ToLower() == "missed") || (ligne.ToLower() == "stopped")
                             || (ligne.ToLower() == "lost"))
                        {
                            sResult = ligne;
                            return true;
                        }
                        return false;
                    }
                    bValue = true;
                    return true;
                }
                if (iNbUnderScore != 4)
                {
                    return false;
                }
                String[] sValeurs = ligne.Split('_');
                int[] iValeurs = new int[5];
                for (int i = 0; i < 5; i++)
                {
                    if (!Int32.TryParse(sValeurs[i], out iValeurs[i]))
                    {
                        return false;
                    }
                }

                iIndexDesk = iValeurs[4];
                bGroup = (iValeurs[4] == 0);
                sResult = "T" + iValeurs[0].ToString() + "L" + iValeurs[1].ToString() + "_";
                GroupDeskType = iValeurs[2];
                if (iValeurs[3] == 0)
                {
                    sResult = sResult.Substring(0, sResult.Length - 1);
                }
                else
                {
                    if (bGroup)
                    {
                        sResult += DataFunctions.AnalyzeName(iValeurs[2]) + " " + iValeurs[3].ToString();
                    }
                    else
                    {
                        sResult += DataFunctions.AnalyzeName(iValeurs[2] + GestionDonneesHUB2SIM.LastGroupIndex) + " " + iValeurs[4].ToString();
                    }
                }
                return true;
            }
            #endregion
            #endregion

            #region Fonction pour réattribué à chaque PAX les informations sur son vol.
            /// <summary>
            /// Function used to do the link between flight plans and results.
            /// It look all the passengers and catch their flight.
            /// </summary>
            /// <param name="atPaxInformations">The list of passengers with their stats</param>
            /// <param name="dtPaxPlan">The paxplan</param>
            /// <param name="dtFPDTable">The flight plan of departure</param>
            /// <param name="dtFPATable">The flight plan of arrival</param>
            /// <param name="ErrorList">A list of which regroups all errors.</param>
            internal static void FlightPlanAnalysis(Dictionary<Int32, PaxResultsStruct> atPaxInformations,
                                                  DataTable dtPaxPlan,
                                                  DataTable dtFPDTable,
                                                  DataTable dtFPATable,
                                                  DataTable dtOCT_BG,
                                                  ArrayList ErrorList)
            {
                DataTable sortedFPA = OverallTools.DataFunctions.sortTable(dtFPATable, dtFPATable.Columns[0].ColumnName);
                DataTable sortedFPD = OverallTools.DataFunctions.sortTable(dtFPDTable, dtFPDTable.Columns[0].ColumnName);
                DataTable sortedPaxPlan = OverallTools.DataFunctions.sortTable(dtPaxPlan, dtPaxPlan.Columns[0].ColumnName);
                PaxResultsStruct.FlightInformations.OCT_BooardingGate = dtOCT_BG;
                PaxResultsStruct.FlightInformations.BoardingTimes = null;
                int iIndexPax;
                int iIndexA;
                int iIndexD;

                int iIndexFPD = dtPaxPlan.Columns.IndexOf(GlobalNames.sPaxPlan_FPDID);
                int iIndexFPA = dtPaxPlan.Columns.IndexOf(GlobalNames.sPaxPlan_FPAID);
                int iIndexSelfCI = dtPaxPlan.Columns.IndexOf(GlobalNames.sPaxPlan_SelfCI);
                //int iIndexFPD = dtPaxPlan.Columns.IndexOf(GlobalNames.sPaxPlan_FPDID);
                //int iIndexFPD = dtPaxPlan.Columns.IndexOf(GlobalNames.sPaxPlan_FPDID);
                if ((iIndexFPD == -1) || (iIndexFPA == -1) || (iIndexSelfCI == -1))
                {
                    ErrorList.Add("Err00220 : The PaxPlanTable does not have a good format");
                    return;
                }

                foreach (PaxResultsStruct PaxInformation in atPaxInformations.Values)
                {
                    iIndexA = 0;
                    iIndexD = 0;
                    iIndexPax = getIndexRow(sortedPaxPlan, PaxInformation.IdPax);
                    if (iIndexPax == -1)
                    {
                        ErrorList.Add("Err00119 : The pax " + PaxInformation.IdPax.ToString() + " does not exist in the PaxPlanTable");
                        continue;
                    }
                    DataRow drLignePaxPlan = sortedPaxPlan.Rows[iIndexPax];
                    if (drLignePaxPlan[iIndexFPA].ToString() != "")
                        iIndexA = (int)drLignePaxPlan[iIndexFPA];
                    if (drLignePaxPlan[iIndexFPD].ToString() != "")
                        iIndexD = (int)drLignePaxPlan[iIndexFPD];

                    try
                    {
                        PaxInformation.Informations = new PaxResultsStruct.PaxPlanInformations();
                        PaxInformation.Informations.dCreationTime = (double)drLignePaxPlan[GlobalNames.sPaxPlan_CreationTime];
                        PaxInformation.Informations.FPA_Class = (Int32)drLignePaxPlan[GlobalNames.sPaxPlan_FPAClass];
                        PaxInformation.Informations.FPD_Class = (Int32)drLignePaxPlan[GlobalNames.sPaxPlan_FPDClass];
                        if (dtPaxPlan.Columns.Contains(GlobalNames.sPaxPlan_BagsIG))
                        {
                            //PaxInformation.Informations.nbBags = (Int32)drLignePaxPlan[GlobalNames.sPaxPlan_BagsIG];
                            PaxInformation.Informations.nbBags = Convert.ToInt32(drLignePaxPlan[GlobalNames.sPaxPlan_BagsIG]);  // >> Task #17690 PAX2SIM - Flight Plan Parameters table
                        }
                        else
                            PaxInformation.Informations.nbBags = (Int32)drLignePaxPlan["NbBags"];
                        PaxInformation.Informations.nbBagsOOG = (Int32)drLignePaxPlan[GlobalNames.sPaxPlan_BagsOOG];
                        PaxInformation.Informations.nbTrolleys = (Int32)drLignePaxPlan[GlobalNames.sPaxPlan_Trolleys];
                        PaxInformation.Informations.nbVisitors = (Int32)drLignePaxPlan[GlobalNames.sPaxPlan_Visitors];
                        PaxInformation.Informations.Passport = (Int32)drLignePaxPlan[GlobalNames.sPaxPlan_Local];
                        PaxInformation.Informations.SelfCheckIn = (((Int32)drLignePaxPlan[GlobalNames.sPaxPlan_SelfCI]) == 1);
                        PaxInformation.Informations.Tranfer = (Int32)drLignePaxPlan[GlobalNames.sPaxPlan_Transfer];
                    }
                    catch (Exception except)
                    {
                        OverallTools.ExternFunctions.PrintLogFile("Err00732 : PaxPlan has wrong format. " + except.Message);
                    }


                    PaxInformation.isSelfServiceCI = PaxInformation.Informations.SelfCheckIn;
                    if (iIndexA != 0)
                    {
                        iIndexA = getIndexRow(sortedFPA, iIndexA);
                    }
                    else
                    {
                        iIndexA = -1;
                    }
                    if (iIndexD != 0)
                    {
                        iIndexD = getIndexRow(sortedFPD, iIndexD);
                    }
                    else
                    {
                        iIndexD = -1;
                    }
                    if ((iIndexA == -1) && (iIndexD == -1))
                    {
                        ErrorList.Add("Err00120 : The flights of the Pax " + PaxInformation.IdPax.ToString() + " does not exist in the flight plans.");
                        continue;
                    }
                    //A partir d'ici, nous avons les index des différentes positions des informations concernant notre
                    //Pax.
                    if (iIndexA >= 0)
                    {
                        PaxInformation.FPAInformations =
                                new PaxResultsStruct.FlightInformations(
                                        (Int32)sortedFPA.Rows[iIndexA][0],
                                        (DateTime)sortedFPA.Rows[iIndexA][1],
                                        (TimeSpan)sortedFPA.Rows[iIndexA][2],
                                        (String)sortedFPA.Rows[iIndexA][3],
                                        (String)sortedFPA.Rows[iIndexA][4],
                                        (String)sortedFPA.Rows[iIndexA][5],
                                        (String)sortedFPA.Rows[iIndexA][6]);
                    }
                    if (iIndexD >= 0)
                    {
                        PaxInformation.FPDInformations =
                                new PaxResultsStruct.FlightInformations(
                                        (Int32)sortedFPD.Rows[iIndexD][0],
                                        (DateTime)sortedFPD.Rows[iIndexD][1],
                                        (TimeSpan)sortedFPD.Rows[iIndexD][2],
                                        (String)sortedFPD.Rows[iIndexD][3],
                                        (String)sortedFPD.Rows[iIndexD][4],
                                        (String)sortedFPD.Rows[iIndexD][5],
                                        (String)sortedFPD.Rows[iIndexD][6]);
                    }
                }
            }
            /// <summary>
            /// Function which determine the row index of the selected key.
            /// Work only with integer keys in the first column.
            /// </summary>
            /// <param name="dtTable"></param>
            /// <param name="iIndex"></param>
            /// <returns></returns>
            private static int getIndexRow(DataTable dtTable, int iIndex)
            {
                if (dtTable == null)
                    return -1;
                int i = iIndex - 1;
                if (dtTable.Rows.Count > i)
                {
                    if ((int)dtTable.Rows[i][0] == iIndex)
                        return i;
                }
                else
                {
                    i = dtTable.Rows.Count - 1;
                }
                while ((i > 0) && ((int)dtTable.Rows[i][0] > iIndex))
                {
                    i--;
                }
                if (i == -1)
                    return -1;
                if ((int)dtTable.Rows[i][0] == iIndex)
                    return i;
                return -1;
            }
            #endregion

            #region Les classes utilisées pour l'analyse du PaxTrace.

            #region La classe pour les résultats pour les PAX ---PaxResultsStruct---
            public class PaxResultsStruct // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
            {
                // << Task #7949 Capacity Analysis - IST tables modification
                /// <summary>
                /// Holds the values regarding this pax for each user attribute.
                ///  Key: user attribute name (column name from the User Attributes table)
                ///  Value: the value of the user attribute related to this pax
                /// </summary>
                public Dictionary<String, String> paxUserAttributesDictionary = new Dictionary<String, String>();
                // >> Task #7949 Capacity Analysis - IST tables modification

                internal static Double dEndTime = -1;
                public class TraceFilter    // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                {
                    internal TraceFilter()
                    {
                    }
                    internal bool PaxIsValid(PaxResultsStruct pax)
                    {
                        return true;
                        /*if ((pax.FPAInformations != null) && (pax.FPAInformations.sAirline == "OA"))
                            return true;

                        if ((pax.FPDInformations != null) && (pax.FPDInformations.sAirline == "OA"))
                            return true;
                        return false;*/
                    }
                }

                #region Propriétés JNK pour LHR 2010
                public static String WesternMergeToBack = "T1L1_Security Check Group 1";
                public static String EasternMergeToBack = "T1L1_Security Check Group 2";

                public static String FrontWestHBS3 = "T4L2_Passport Check Group 5";
                public static String FrontEastHBS3 = "T4L2_Passport Check Group 6";

                public static String BackHBS3 = "T1L1_Passport Check Group 5";
                public static String FrontSorterMES = "T4L2_Passport Check Group 9";
                public static String BackTransferMES = "T1L1_Passport Check Group 6";
                public static String BackTransferMES2 = "T1L1_Passport Check Group 7";

                public static String WesternBackMES = "T2L1_Passport Check Group 3";
                public static String EasternBackMES = "T2L2_Passport Check Group 6";

                public static String FrontTSAHBS = "T4L2_Passport Check Group 7";
                public static String ManualTSAHBS = "T6L5_Passport Check Group 20";
                public static String WesternBackTSAHBS = "T2L1_Passport Check Group 2";
                public static String EasternBackTSAHBS = "T2L2_Passport Check Group 5";

                public static String BackTransferInfeed1 = "T2L5_Security Check Group 9";
                public static String BackTransferInfeed2 = "T2L5_Security Check Group 10";
                public static String BackTransferInfeed3 = "T2L5_Security Check Group 11";
                public static String BackTransferInfeed4 = "T2L5_Security Check Group 12";

                public static String BackTransferInfeedT1T3_1 = "T3L5_Security Check Group 2";
                public static String BackTransferInfeedT1T3_2 = "T3L5_Security Check Group 4";

                public static String FrontSorterInduction1 = "T3L4_Security Check Group 20";
                public static String FrontSorterInduction2 = "T1L2_Security Check Group 20";
                public static String FrontSorterInduction3 = "T3L2_Security Check Group 19";

                public static String BackSorterInduction1 = "T6L4_Passport Check Group 3";
                public static String BackSorterInduction2 = "T2L1_Passport Check Group 1";
                public static String BackSorterInduction3 = "T2L2_Security Check Group 6";
                public static String BackSorterInduction4 = "T2L2_Security Check Group 8";
                private bool HasGroup(String sGroup)
                {
                    foreach (paxTravelData paxTmp in alPaxTravel)
                    {
                        if (paxTmp.Desk == sGroup)
                        {
                            return true;
                        }
                    }
                    return false;
                }

                private paxTravelData GetGroup(String sGroup)
                {
                    foreach (paxTravelData paxTmp in alPaxTravel)
                    {
                        if (paxTmp.Desk == sGroup)
                        {
                            return paxTmp;
                        }
                    }
                    return null;
                }

                public bool isStandard
                {
                    get
                    {
                        return !(isHBS3 || isMES || isTSA);
                    }
                }

                public bool isBackTransfer
                {
                    get
                    {
                        return HasGroup(BackTransferInfeed1)
                            || HasGroup(BackTransferInfeed2)
                            || HasGroup(BackTransferInfeed3)
                            || HasGroup(BackTransferInfeed4)
                            || HasGroup(BackTransferInfeedT1T3_1)
                            || HasGroup(BackTransferInfeedT1T3_2);
                    }
                }

                private Int32 iRecirculation;

                public Int32 Recirculation
                {
                    get
                    {
                        if (iRecirculation == -1)
                            iRecirculation = getRecirculation();
                        return iRecirculation;
                    }
                }
                private Int32 getRecirculation()
                {
                    int iResult = -1;
                    int iFirst = 0;
                    foreach (paxTravelData paxTmp in alPaxTravel)
                    {
                        if (((iFirst == 0) || (iFirst == 1)) && (paxTmp.Desk == FrontSorterInduction1))
                        {
                            iFirst = 1;
                            iResult++;
                        }
                        else if (((iFirst == 0) || (iFirst == 2)) && (paxTmp.Desk == FrontSorterInduction2))
                        {
                            iFirst = 2;
                            iResult++;
                        }
                        else if (((iFirst == 0) || (iFirst == 3)) && (paxTmp.Desk == FrontSorterInduction3))
                        {
                            iFirst = 3;
                            iResult++;
                        }
                        else if (((iFirst == 0) || (iFirst == 4)) && (paxTmp.Desk == BackSorterInduction1))
                        {
                            iFirst = 4;
                            iResult++;
                        }
                        else if (((iFirst == 0) || (iFirst == 5)) && (paxTmp.Desk == BackSorterInduction2))
                        {
                            iFirst = 5;
                            iResult++;
                        }
                        else if (((iFirst == 0) || (iFirst == 6)) && (paxTmp.Desk == BackSorterInduction3))
                        {
                            iFirst = 6;
                            iResult++;
                        }
                        else if (((iFirst == 0) || (iFirst == 7)) && (paxTmp.Desk == BackSorterInduction4))
                        {
                            iFirst = 7;
                            iResult++;
                        }
                    }
                    return iResult;
                }
                #region MES
                public bool isMES
                {
                    get
                    {
                        return isFrontMES || isBackTransferMES || isWesternBackMES || isEasternBackMES;
                    }
                }
                public bool isFrontMES
                {
                    get
                    {
                        return HasGroup(FrontSorterMES);
                    }
                }
                public bool isBackTransferMES
                {
                    get
                    {
                        return HasGroup(BackTransferMES) || HasGroup(BackTransferMES2);
                    }
                }
                public bool isWesternBackMES
                {
                    get
                    {
                        return HasGroup(WesternBackMES);
                    }
                }
                public bool isEasternBackMES
                {
                    get
                    {
                        return HasGroup(EasternBackMES);
                    }
                }
                #endregion

                #region TSA
                public bool isTSA
                {
                    get
                    {
                        return isFrontTSA || isWesternTSA || isEasternTSA;
                    }
                }
                public bool isFrontTSA
                {
                    get
                    {
                        return HasGroup(FrontTSAHBS) || HasGroup(ManualTSAHBS);
                    }
                }
                public bool isWesternTSA
                {
                    get
                    {
                        return HasGroup(WesternBackTSAHBS);
                    }
                }
                public bool isEasternTSA
                {
                    get
                    {
                        return HasGroup(EasternBackTSAHBS);
                    }
                }
                #endregion

                public bool isBackWest
                {
                    get
                    {
                        return HasGroup(WesternMergeToBack);
                    }
                }
                public bool isBackEast
                {
                    get
                    {
                        return HasGroup(EasternMergeToBack);
                    }
                }

                #region HBS3
                public bool isHBS3
                {
                    get
                    {
                        return isBackHBS3 || isFrontWestHBS3 || isFrontEastHBS3;
                    }
                }
                public bool isFrontWestHBS3
                {
                    get
                    {
                        return HasGroup(FrontWestHBS3);
                    }
                }
                public bool isFrontEastHBS3
                {
                    get
                    {
                        return HasGroup(FrontEastHBS3);
                    }
                }
                public bool isBackHBS3
                {
                    get
                    {
                        return HasGroup(BackHBS3);
                    }
                }
                #endregion

                public bool isGate
                {
                    get
                    {
                        if (BoardingGate != null)
                            return true;
                        return false;
                    }
                }
                public int getBoardingGateNumber
                {
                    get
                    {
                        int iResult = -1;

                        paxTravelData BG = BoardingGate;
                        if (BG == null)
                            return -1;
                        int iIndex = BG.Desk.LastIndexOf(" ");
                        if (iIndex == -1)
                            return -1;
                        if (!Int32.TryParse(BG.Desk.Substring(iIndex + 1), out iResult))
                            return -1;
                        return iResult;
                    }
                }

                public int getArrivalgGateNumber
                {
                    get
                    {
                        int iResult = -1;

                        paxTravelData AG = ArrivalGate;
                        if (AG == null)
                            return -1;
                        int iIndex = AG.Desk.LastIndexOf(" ");
                        if (iIndex == -1)
                            return -1;
                        if (!Int32.TryParse(AG.Desk.Substring(iIndex + 1), out iResult))
                            return -1;
                        return iResult;
                    }
                }
                public int getTerminalBoardingGate
                {
                    get
                    {
                        paxTravelData BG = BoardingGate;
                        if (BG == null)
                            return -1;
                        int iResult;
                        if (Int32.TryParse(BG.Desk.Substring(1, 1), out iResult))
                            return iResult;
                        return -1;
                    }
                }
                public int getTerminalArrivalGate
                {
                    get
                    {
                        paxTravelData AG = ArrivalGate;
                        if (AG == null)
                            return -1;
                        int iResult;
                        if (Int32.TryParse(AG.Desk.Substring(1, 1), out iResult))
                            return iResult;
                        return -1;
                    }
                }

                public int getCheckIn
                {
                    get
                    {
                        paxTravelData CI = CheckIn;
                        if (CI == null)
                            return -1;
                        int iIndex = CI.Desk.LastIndexOf(" ");
                        if (iIndex == -1)
                            return -1;
                        int iResult;
                        if (Int32.TryParse(CI.Desk.Substring(iIndex + 1), out iResult))
                            return iResult;
                        return -1;
                    }
                }
                public int getTerminalReclaim
                {
                    get
                    {
                        paxTravelData RC = Reclaim;
                        if (RC == null)
                            return -1;
                        int iResult;
                        if (Int32.TryParse(RC.Desk.Substring(1, 1), out iResult))
                            return iResult;
                        return -1;
                    }
                }
                public int getReclaim
                {
                    get
                    {
                        paxTravelData RC = Reclaim;
                        if (RC == null)
                            return -1;
                        int iIndex = RC.Desk.LastIndexOf(" ");
                        if (iIndex == -1)
                            return -1;
                        int iResult;
                        if (Int32.TryParse(RC.Desk.Substring(iIndex + 1), out iResult))
                            return iResult;
                        return -1;
                    }
                }
                public int getTerminalCheckIn
                {
                    get

                    {
                        paxTravelData CI = CheckIn;
                        if (CI == null)
                            return -1;
                        int iResult;
                        if (Int32.TryParse(CI.Desk.Substring(1, 1), out iResult))
                            return iResult;
                        return -1;
                    }
                }
                public int getCheckInGroup
                {
                    get
                    {
                        paxTravelData CIG = CheckInGroup;
                        if (CIG == null)
                            return -1;
                        int iIndex = CIG.Desk.LastIndexOf(" ");
                        if (iIndex == -1)
                            return -1;
                        int iResult;
                        if (Int32.TryParse(CIG.Desk.Substring(iIndex + 1), out iResult))
                            return iResult;
                        return -1;
                    }
                }

                public Double TotalPresentTimeExclQ
                {
                    get
                    {
                        paxTravelData ptdInjPoint = CheckIn;
                        if (ptdInjPoint == null)
                            ptdInjPoint = ArrivalGate;
                        Double dDecalage = 0;
                        if (isBackTransfer)
                        {
                            ptdInjPoint = GetGroup(BackTransferInfeed1);
                            if (ptdInjPoint == null)
                                ptdInjPoint = GetGroup(BackTransferInfeed2);
                            if (ptdInjPoint == null)
                                ptdInjPoint = GetGroup(BackTransferInfeed3);
                            if (ptdInjPoint == null)
                                ptdInjPoint = GetGroup(BackTransferInfeed4);
                            if (ptdInjPoint == null)
                            {
                                ptdInjPoint = GetGroup(BackTransferInfeedT1T3_1);
                                if (ptdInjPoint != null)
                                    dDecalage = 36.0 / 60.0;
                                else
                                {
                                    ptdInjPoint = GetGroup(BackTransferInfeedT1T3_2);
                                    dDecalage = 70.0 / 60.0;
                                }
                            }
                        }
                        if (ptdInjPoint == null)
                            return -1;

                        paxTravelData ptdExitPoint = BoardingGateGroup;
                        if (ptdExitPoint == null)
                            ptdExitPoint = BaggageClaimGroup;
                        if (ptdExitPoint == null)
                            return -1;
                        return ptdExitPoint.ArrivalTime - (ptdInjPoint.LeavingTime - dDecalage);
                    }
                }
                public Object[] getPaxInformations(DateTime dtBegin)
                {
                    Object[] toResult = new object[53];
                    int i = 0;
                    toResult[i++] = iIdPax;
                    toResult[i++] = dtBegin.AddMinutes(ArrivalTime).ToLongTimeString();

                    toResult[i++] = Math.Round(TotalPresentTime * 60.0, 2);
                    toResult[i++] = Math.Round(TotalPresentTimeExclQ * 60.0, 2);
                    toResult[i++] = Recirculation;
                    toResult[i++] = isStandard;
                    toResult[i++] = !(isBackWest || isBackEast);
                    toResult[i++] = isBackWest || isBackEast;
                    toResult[i++] = isBackWest;
                    toResult[i++] = isBackEast;

                    toResult[i++] = isHBS3;
                    toResult[i++] = isFrontWestHBS3;
                    toResult[i++] = isFrontEastHBS3;
                    toResult[i++] = isBackHBS3;

                    toResult[i++] = isTSA;
                    toResult[i++] = isFrontTSA;
                    toResult[i++] = isWesternTSA;
                    toResult[i++] = isEasternTSA;

                    toResult[i++] = isMES;
                    toResult[i++] = isFrontMES;
                    toResult[i++] = isBackTransferMES;
                    toResult[i++] = isWesternBackMES;
                    toResult[i++] = isEasternBackMES;

                    toResult[i++] = getTerminalCheckIn;
                    toResult[i++] = getCheckInGroup;

                    toResult[i++] = getTerminalArrivalGate;
                    toResult[i++] = getTerminalBoardingGate;
                    toResult[i++] = getBoardingGateNumber;
                    bool bTRansferred = isTransferred;
                    toResult[i++] = bTRansferred;
                    toResult[i++] = (!bTRansferred) && (FPAInformations == null);
                    toResult[i++] = (!bTRansferred) && (FPDInformations == null);

                    toResult[i++] = Stopped;
                    toResult[i++] = HadMissed;
                    if (fiFPAInformations != null)
                    {
                        toResult[i++] = fiFPAInformations.iIdFlight;
                        toResult[i++] = fiFPAInformations.sAirline;
                        toResult[i++] = fiFPAInformations.sAirport;
                        toResult[i++] = fiFPAInformations.sFlightCategory;
                        toResult[i++] = fiFPAInformations.sFlightName;
                        toResult[i++] = fiFPAInformations.dtDate;
                        toResult[i++] = fiFPAInformations.tsTime;
                    }
                    else
                    {
                        toResult[i++] = 0;
                        toResult[i++] = "";
                        toResult[i++] = "";
                        toResult[i++] = "";
                        toResult[i++] = "";
                        toResult[i++] = new DateTime(0);
                        toResult[i++] = new TimeSpan(0, 0, 0);
                    }
                    if (fiFPDInformations != null)
                    {
                        toResult[i++] = fiFPDInformations.iIdFlight;
                        toResult[i++] = fiFPDInformations.sAirline;
                        toResult[i++] = fiFPDInformations.sAirport;
                        toResult[i++] = fiFPDInformations.sFlightCategory;
                        toResult[i++] = fiFPDInformations.sFlightName;
                        toResult[i++] = fiFPDInformations.dtDate;
                        toResult[i++] = fiFPDInformations.tsTime;
                    }
                    else
                    {
                        toResult[i++] = 0;
                        toResult[i++] = "";
                        toResult[i++] = "";
                        toResult[i++] = "";
                        toResult[i++] = "";
                        toResult[i++] = new DateTime(0);
                        toResult[i++] = new TimeSpan(0, 0, 0);
                    }
                    toResult[i++] = HasGroup(BackTransferInfeed1);
                    toResult[i++] = HasGroup(BackTransferInfeed2);
                    toResult[i++] = HasGroup(BackTransferInfeed3);
                    toResult[i++] = HasGroup(BackTransferInfeed4);
                    toResult[i++] = HasGroup(BackTransferInfeedT1T3_1);
                    toResult[i++] = HasGroup(BackTransferInfeedT1T3_2);
                    return toResult;
                }

                #endregion

                #region la classe PaxTravelData
                public class paxTravelData  // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                {
                    private String sDesk;
                    private Double dArrivalTime;
                    // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                    private Double dDelayTime;
                    // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                    private Double dWaitingTime;
                    private Double dProcessTime;
                    private bool bIsGroup;

                    #region Les accesseurs
                    public bool IsGroup
                    {
                        get
                        {
                            return bIsGroup;
                        }
                    }
                    public String Desk
                    {
                        get
                        {
                            return sDesk;
                        }
                    }
                    public Double ArrivalTime
                    {
                        get
                        {
                            return dArrivalTime;
                        }
                    }
                    public Double WaitingTime
                    {
                        get
                        {
                            return dWaitingTime;
                        }
                    }
                    public Double ProcessTime
                    {
                        get
                        {
                            return dProcessTime;
                        }
                    }
                    public Double LeavingTime
                    {
                        get
                        {
                            if (dWaitingTime < 0)
                                return dArrivalTime;
                            if (dProcessTime < 0)
                                return dArrivalTime + dWaitingTime;
                            return dArrivalTime + dWaitingTime + dProcessTime;
                        }
                    }
                    // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                    public Double DelayTime
                    {
                        get { return dDelayTime; }
                    }
                    // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                    #endregion

                    public paxTravelData(String Desk_, Double ArrivalTime_,
                        Double WaitingTime_, Double ProcessTime_, bool bIsGroup_, Double DelayTime_)
                    {
                        // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                        dDelayTime = DelayTime_;
                        // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                        sDesk = Desk_;
                        dArrivalTime = ArrivalTime_;
                        dWaitingTime = WaitingTime_;
                        dProcessTime = ProcessTime_;
                        bIsGroup = bIsGroup_;
                    }
                }
                #endregion

                #region La classe FlightInformations
                public class FlightInformations
                {
                    private Double dFlightTime_;
                    private int iIdFlight_;
                    private DateTime dtDate_;
                    private TimeSpan tsTime_;
                    private String sAirline_;
                    private String sFlightName_;
                    private String sAirport_;
                    private String sFlightCategory_;
                    private static DataTable dtOCT_BG;
                    static Hashtable htBoardingTimes = new Hashtable();

                    #region Les accesseurs de la classe.
                    public static Hashtable BoardingTimes
                    {
                        get
                        {
                            return htBoardingTimes;
                        }
                        set
                        {
                            htBoardingTimes = value;
                            if (htBoardingTimes == null)
                                htBoardingTimes = new Hashtable();
                        }
                    }
                    public static DataTable OCT_BooardingGate
                    {
                        get
                        {
                            return dtOCT_BG;
                        }
                        set
                        {
                            dtOCT_BG = value;
                        }
                    }

                    public Int32 iIdFlight
                    {
                        get
                        {
                            return iIdFlight_;
                        }
                    }
                    public DateTime dtDate
                    {
                        get
                        {
                            return dtDate_;
                        }
                    }
                    public TimeSpan tsTime
                    {
                        get
                        {
                            return tsTime_;
                        }
                    }
                    public String sAirline
                    {
                        get
                        {
                            return sAirline_;
                        }
                    }
                    public String sFlightName
                    {
                        get
                        {
                            return sFlightName_;
                        }
                    }
                    public String sAirport
                    {
                        get
                        {
                            return sAirport_;
                        }
                    }
                    public String sFlightCategory
                    {
                        get
                        {
                            return sFlightCategory_;
                        }
                    }
                    #endregion

                    #region Le constructeur de la classe.
                    public FlightInformations(int _iIdFlight, DateTime _dtDate, TimeSpan _tsTime, String _sAirline, String _sFlightName, String _sAirport, String _sFlightCategory)
                    {
                        iIdFlight_ = _iIdFlight;
                        dtDate_ = _dtDate;
                        tsTime_ = _tsTime;
                        sAirline_ = _sAirline;
                        sFlightName_ = _sFlightName;
                        sAirport_ = _sAirport;
                        sFlightCategory_ = _sFlightCategory;
                        dFlightTime_ = -1;
                    }
                    #endregion

                    #region Les fonctions utilisées pour calculer les heures de vol et de boarding
                    public Double getFlightTime(DateTime dtBeginDate)
                    {
                        if (dFlightTime_ == -1)
                        {
                            DateTime dtFlight = dtDate_.Add(tsTime_);
                            dFlightTime_ = OverallTools.DataFunctions.MinuteDifference(dtBeginDate, dtFlight);
                        }
                        return getFlightTime();
                    }
                    public Double getFlightTime()
                    {
                        return dFlightTime_;
                    }
                    public Double getBoardingTime(DateTime dtBeginDate)
                    {
                        if (htBoardingTimes.Contains(iIdFlight_))
                            return (Double)htBoardingTimes[iIdFlight_];


                        Double dFlight = getFlightTime(dtBeginDate);
                        int iIndexFC = dtOCT_BG.Columns.IndexOf(sFlightCategory_);
                        if (iIndexFC == -1)
                        {
                            htBoardingTimes.Add(iIdFlight_, dFlight);
                        }
                        else
                        {

                            Double iNbMinutes = OverallTools.DataFunctions.getMinValue(dtOCT_BG, iIndexFC);
                            htBoardingTimes.Add(iIdFlight_, dFlight - iNbMinutes);
                        }
                        return getBoardingTime();
                    }
                    public Double getBoardingTime()
                    {
                        if (htBoardingTimes.Contains(iIdFlight_))
                            return (Double)htBoardingTimes[iIdFlight_];
                        else
                            return getFlightTime();
                    }

                    #endregion
                }
                #endregion

                internal class PaxPlanInformations
                {
                    internal double dCreationTime;
                    internal int FPA_Class;
                    internal int FPD_Class;
                    internal bool SelfCheckIn;
                    internal int nbVisitors;
                    internal int nbBags;
                    internal int nbBagsOOG;
                    internal int nbTrolleys;
                    internal int Passport;
                    internal int Tranfer;
                }

                private Int32 iIdPax;
                private FlightInformations fiFPAInformations;
                private FlightInformations fiFPDInformations;
                private PaxPlanInformations ppiInformations;
                public List<paxTravelData> alPaxTravel;
                private bool bHadMissed;
                private bool bStopped;
                private bool bLost;
                private bool bSelfServiceCI;

                #region Les accesseurs
                public FlightInformations FPAInformations
                {
                    get
                    {
                        return fiFPAInformations;
                    }
                    set
                    {
                        fiFPAInformations = value;
                    }
                }
                public FlightInformations FPDInformations
                {
                    get
                    {
                        return fiFPDInformations;
                    }
                    set
                    {
                        fiFPDInformations = value;
                    }
                }
                internal PaxPlanInformations Informations
                {
                    get
                    {
                        return ppiInformations;
                    }
                    set
                    {
                        ppiInformations = value;
                    }
                }
                public Int32 FPAId
                {
                    get
                    {
                        if (fiFPAInformations == null)
                            return 0;
                        return fiFPAInformations.iIdFlight;
                    }
                }
                public Int32 FPDId
                {
                    get
                    {
                        if (fiFPDInformations == null)
                            return 0;
                        return fiFPDInformations.iIdFlight;
                    }
                }
                public Int32 IdPax
                {
                    get
                    {
                        return iIdPax;
                    }
                }
                public bool IsFPA
                {
                    get
                    {
                        if (fiFPAInformations == null)
                            return false;
                        return true;
                    }
                }
                public bool IsFPD
                {
                    get
                    {
                        if (fiFPDInformations == null)
                            return false;
                        return true;
                    }
                }
                public bool HadMissed
                {
                    get
                    {
                        return bHadMissed;
                    }
                    set
                    {
                        bHadMissed = value;
                    }
                }
                public bool Stopped
                {
                    get
                    {
                        return bStopped;
                    }
                    set
                    {
                        bStopped = value;
                    }
                }
                public bool Lost
                {
                    get
                    {
                        return bLost;
                    }
                    set
                    {
                        bLost = value;
                    }
                }
                public bool isTransferred
                {
                    get
                    {
                        return ((fiFPDInformations != null) && (fiFPAInformations != null));
                    }
                }
                public bool isSelfServiceCI
                {
                    set
                    {
                        bSelfServiceCI = value;
                    }
                    get
                    {
                        return bSelfServiceCI;
                    }
                }
                public List<paxTravelData> PaxTravel
                {
                    get
                    {
                        return alPaxTravel;
                    }
                }

                internal String getStatus(String Location)
                {
                    if (((paxTravelData)alPaxTravel[alPaxTravel.Count - 1]).Desk != Location)
                        return "";
                    if (bLost)
                        return "Lost";
                    if (bHadMissed)
                        return "Missed";
                    if (bStopped)
                        return "Stopped";
                    return "";
                }
                internal String getStatusGroup(String Location)
                {

                    if (((paxTravelData)alPaxTravel[alPaxTravel.Count - 1]).Desk != Location)
                    {
                        if (alPaxTravel.Count < 2)
                            return "";
                        if (((!Location.Contains("Group")) ||
                             (((paxTravelData)alPaxTravel[alPaxTravel.Count - 2]).Desk != Location)))
                            return "";
                    }
                    if (bLost)
                        return "Lost";
                    if (bHadMissed)
                        return "Missed";
                    if (bStopped)
                        return "Stopped";
                    return "";
                }

                #endregion

                public PaxResultsStruct(Int32 IdPax_)
                {
                    iIdPax = IdPax_;
                    alPaxTravel = new List<paxTravelData>();
                    bHadMissed = false;
                    bStopped = false;
                    bLost = false;
                    bSelfServiceCI = false;
                    fiFPAInformations = null;
                    fiFPDInformations = null;
                    iRecirculation = -1;
                    bCheckPaxIsValidForFilter = true;
                    tfOldConditions = null;
                }

                public void AddPaxTravel(String Desk, bool bIsGroup, Double ArrivalTime,
                    Double WaitingTime, Double ProcessTime, Double DelayTime)
                {
                    // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                    alPaxTravel.Add(new paxTravelData(Desk, ArrivalTime, WaitingTime, ProcessTime, bIsGroup, DelayTime));
                    // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)                    
                }


                #region Functions and variables used for filtering the passengers.
                /// <summary>
                /// The conditions that has been applied on the passenger the previous time.
                /// </summary>
                TraceFilter tfOldConditions;
                /// <summary>
                /// The result that the conditions returned the previous time.
                /// </summary>
                bool bCheckPaxIsValidForFilter;

                /// <summary>
                /// This function is used to know if the passenger is valid for the current filter that
                /// the user want to apply on his analysis. If the parameter is null, then the passenger
                /// is valid. In other case, the condition is checked.
                /// </summary>
                /// <param name="tfConditions"></param>
                /// <returns></returns>
                internal bool CheckPaxIsValidForFilter(TraceFilter tfConditions)
                {
                    if (tfConditions == null)
                    {
                        //If the current condition is null, that means all the passengers are expected.
                        tfOldConditions = null;
                        return true;
                    }
                    //If the current class is the same than the previous call for that function, that
                    //means that the result didn't change. So we return the result that it returned
                    //the previous time.
                    if (tfOldConditions == tfConditions)
                        return bCheckPaxIsValidForFilter;
                    tfOldConditions = tfConditions;
                    //We check the conditions stored in tfConditions in the current passenger.
                    bCheckPaxIsValidForFilter = tfConditions.PaxIsValid(this);
                    return bCheckPaxIsValidForFilter;
                }
                #endregion

                #region Les fonctions utilisées pour obtenir une partie des statistiques.
                public Double TotalPresentTime
                {
                    get
                    {
                        Double Arrival = ArrivalTime;
                        Double Leaving = LeavingTime;
                        if ((Arrival == -1) || (Leaving == -1))
                            return -1;
                        return Leaving - Arrival;
                    }
                }
                public Double ArrivalTime
                {
                    get
                    {
                        if (alPaxTravel.Count == 0)
                            return -1;
                        return Math.Round(((paxTravelData)alPaxTravel[0]).ArrivalTime, 2);
                    }
                }
                public Double LeavingTime
                {
                    get
                    {
                        if (alPaxTravel.Count == 0)
                            return -1;
                        if (bStopped)
                        {
                            return dEndTime;
                        }
                        paxTravelData tmp = (paxTravelData)alPaxTravel[alPaxTravel.Count - 1];
                        if (tmp.ProcessTime > 0)
                            return Math.Round(tmp.ArrivalTime + tmp.ProcessTime + tmp.WaitingTime, 2);
                        if (tmp.WaitingTime > 0)
                            return Math.Round(tmp.ArrivalTime + tmp.WaitingTime, 2);
                        return Math.Round(tmp.ArrivalTime, 2);

                    }
                }
                public Double TotalWaitingTime
                {
                    get
                    {
                        if (alPaxTravel.Count == 0)
                            return -1;
                        Double result = 0;
                        foreach (paxTravelData tmp in alPaxTravel)
                        {
                            result += tmp.WaitingTime;
                        }
                        return Math.Round(result, 2);
                    }
                }
                public Double TotalProcessTime
                {
                    get
                    {
                        if (alPaxTravel.Count == 0)
                            return -1;
                        Double result = 0;
                        foreach (paxTravelData tmp in alPaxTravel)
                        {
                            result += tmp.ProcessTime;
                        }
                        return Math.Round(result, 2);
                    }
                }
                public Double TotalTravelTime
                {
                    get
                    {
                        if (alPaxTravel.Count == 0)
                            return -1;
                        Double result = 0;
                        Double LastDeskTime = -1;
                        foreach (paxTravelData tmp in alPaxTravel)
                        {
                            if (LastDeskTime != -1)
                            {
                                result += tmp.ArrivalTime - LastDeskTime;
                            }
                            LastDeskTime = tmp.ArrivalTime + tmp.ProcessTime + tmp.WaitingTime;
                        }
                        return Math.Round(result, 2);
                    }
                }
                public Double TotalTransferTime
                {
                    get
                    {
                        if ((!isTransferred) && (!IsFPD))
                            return TotalPresentTime;
                        paxTravelData paxTmp = BoardingGateGroup;
                        if (paxTmp == null)
                            return TotalPresentTime;
                        Double Arrival = ArrivalTime;
                        Double Leaving = paxTmp.ArrivalTime;
                        if ((Arrival == -1) || (Leaving == -1))
                            return -1;
                        return Leaving - Arrival;
                    }
                }
                internal double totalWaitingTimeBeforeBoardingGate
                {
                    get
                    {
                        if (!IsFPD)
                        {
                            return -1;
                        }
                        if (BoardingGateGroup == null)
                        {
                            return -1;
                        }
                        double waitingTimeAtBoardingGateGroup = BoardingGateGroup.WaitingTime;
                        double waitingTimeAtBoardingGate = 0;
                        if (BoardingGate != null)
                        {
                            waitingTimeAtBoardingGate = BoardingGate.WaitingTime;
                        }
                        return TotalWaitingTime - waitingTimeAtBoardingGateGroup - waitingTimeAtBoardingGate;
                    }
                }

                internal paxTravelData CheckIn
                {
                    get
                    {
                        foreach (paxTravelData paxTmp in alPaxTravel)
                        {
                            if ((paxTmp.Desk.Contains("Check In")) && (!paxTmp.Desk.Contains(" Group")))
                            {
                                return paxTmp;
                            }
                        }
                        return null;
                    }
                }
                internal paxTravelData CheckInGroup
                {
                    get
                    {
                        foreach (paxTravelData paxTmp in alPaxTravel)
                        {
                            if (paxTmp.Desk.Contains("Check In Group"))
                            {
                                return paxTmp;
                            }
                        }
                        return null;
                    }
                }
                internal bool isCheckinLastTheGroupOrStationEntered
                {
                    get
                    {
                        if ((alPaxTravel == null) || (alPaxTravel.Count == 0))
                            return false;
                        return ((paxTravelData)alPaxTravel[alPaxTravel.Count - 1]).Desk.Contains("Check In");
                    }
                }
                /*
                switch (name)
                {
                    case PAX2SIM.sCheckInGroup:
                        return GestionDonneesHUB2SIM.CheckInGroup;
                    case "Passport Check Group":
                        return GestionDonneesHUB2SIM.PassportCheckGroup;
                    case "Security Check Group":
                        return GestionDonneesHUB2SIM.SecurityCheckGroup;
                    case "Arrival Gate Group":
                        return GestionDonneesHUB2SIM.ArrivalGateGroup;
                    case "Baggage Claim Group":
                        return GestionDonneesHUB2SIM.BaggageClaimGroup;
                    case "Transfer Group":
                        return GestionDonneesHUB2SIM.TransferGroup;
                    case "Shuttle Group":
                        return GestionDonneesHUB2SIM.ShuttleGroup;
                    case "Boarding Gate Group":
                        return GestionDonneesHUB2SIM.BoardingGateGroup;
                 * 
                    case "Check In":
                        return GestionDonneesHUB2SIM.CheckIn;
                    case "Passport Check":
                        return GestionDonneesHUB2SIM.PassportCheck;
                    case "Security Check":
                        return GestionDonneesHUB2SIM.SecurityCheck;
                    case "Arrival Gate":
                        return GestionDonneesHUB2SIM.ArrivalGate;
                    case "Baggage Claim":
                        return GestionDonneesHUB2SIM.BaggageClaim;
                    case "Transfer":
                        return GestionDonneesHUB2SIM.Transfer;
                    case "Shuttle":
                        return GestionDonneesHUB2SIM.Shuttle;
                    case "Boarding Gate":
                        return GestionDonneesHUB2SIM.BoardingGate;
*/
                internal paxTravelData BoardingGate
                {
                    get
                    {
                        foreach (paxTravelData paxTmp in alPaxTravel)
                        {
                            if ((paxTmp.Desk.Contains("Boarding Gate")) && (!paxTmp.Desk.Contains(" Group")))
                            {
                                return paxTmp;
                            }
                        }
                        return null;
                    }
                }
                internal paxTravelData Reclaim
                {
                    get
                    {
                        foreach (paxTravelData paxTmp in alPaxTravel)
                        {
                            if ((paxTmp.Desk.Contains("Baggage Claim")) && (!paxTmp.Desk.Contains(" Group")))
                            {
                                return paxTmp;
                            }
                        }
                        return null;
                    }
                }
                internal paxTravelData BoardingGateGroup
                {
                    get
                    {
                        foreach (paxTravelData paxTmp in alPaxTravel)
                        {
                            if (paxTmp.Desk.Contains("Boarding Gate Group"))
                            {
                                return paxTmp;
                            }
                        }
                        return null;
                    }
                }
                internal bool isBoardingGateTheLastGroupOrStationEntered
                {
                    get
                    {
                        if ((alPaxTravel == null) || (alPaxTravel.Count == 0))
                            return false;
                        return ((paxTravelData)alPaxTravel[alPaxTravel.Count - 1]).Desk.Contains("Boarding Gate");
                    }
                }
                internal paxTravelData ArrivalGate
                {
                    get
                    {
                        foreach (paxTravelData paxTmp in alPaxTravel)
                        {
                            if ((paxTmp.Desk.Contains("Arrival Gate")) && (!paxTmp.Desk.Contains(" Group")))
                            {
                                return paxTmp;
                            }
                        }
                        return null;
                    }
                }
                internal paxTravelData ArrivalGateGroup
                {
                    get
                    {
                        foreach (paxTravelData paxTmp in alPaxTravel)
                        {
                            if ((paxTmp.Desk.Contains("Arrival Gate Group")))
                            {
                                return paxTmp;
                            }
                        }
                        return null;
                    }
                }
                internal bool isArrivalGateTheLastGroupOrStationEntered
                {
                    get
                    {
                        if ((alPaxTravel == null) || (alPaxTravel.Count == 0))
                            return false;
                        return ((paxTravelData)alPaxTravel[alPaxTravel.Count - 1]).Desk.Contains("Arrival Gate");
                    }
                }
                internal bool isBaggageClaimTheLastGroupOrStationEntered
                {
                    get
                    {
                        if ((alPaxTravel == null) || (alPaxTravel.Count == 0))
                            return false;
                        return ((paxTravelData)alPaxTravel[alPaxTravel.Count - 1]).Desk.Contains("Baggage Claim");
                    }
                }
                internal paxTravelData BaggageClaimGroup
                {
                    get
                    {
                        foreach (paxTravelData paxTmp in alPaxTravel)
                        {
                            if ((paxTmp.Desk.Contains("Baggage Claim Group")))
                            {
                                return paxTmp;
                            }
                        }
                        return null;
                    }
                }
                public Int32 NombreDesk
                {
                    get
                    {
                        return alPaxTravel.Count;
                    }
                }
                #endregion

                #region Fonction pour le calcul de l'occupation du passager sur le lien choisit.
                public Double[] PlaceOccupation(String sLocation)
                {
                    bool bFind = false;
                    ArrayList alResult = new ArrayList();
                    int i;
                    paxTravelData PaxDeskTmp = null;
                    for (i = 0; i < alPaxTravel.Count; i++)
                    {
                        PaxDeskTmp = (paxTravelData)alPaxTravel[i];
                        if (PaxDeskTmp.Desk.IndexOf(sLocation) == 0)
                        {
                            if (!bFind)
                            {
                                alResult.Add(PaxDeskTmp.ArrivalTime);
                                //dSum = PaxDeskTmp.ArrivalTime;
                            }
                            //dSum += PaxDeskTmp.WaitingTime + PaxDeskTmp.ProcessTime;
                            bFind = true;
                        }
                        else
                        {
                            if (bFind)
                            {
                                alResult.Add(PaxDeskTmp.ArrivalTime);
                            }
                            bFind = false;
                        }
                    }
                    if (bFind && PaxDeskTmp != null)
                    {
                        alResult.Add(PaxDeskTmp.ArrivalTime + PaxDeskTmp.ProcessTime + PaxDeskTmp.WaitingTime);
                    }
                    if (alResult.Count == 0)
                        return null;
                    Double[] dtResult = new Double[alResult.Count];
                    for (i = 0; i < alResult.Count; i++)
                    {
                        dtResult[i] = (Double)alResult[i];
                    }
                    return dtResult;
                }

                internal List<PointF> getPaxOccupation(String sLocation)
                {
                    PointF pTmp = new PointF(-1, -1);
                    List<PointF> lpReturn = new List<PointF>();
                    paxTravelData PaxDeskTmp = null;
                    for (int i = 0; i < alPaxTravel.Count; i++)
                    {
                        PaxDeskTmp = (paxTravelData)alPaxTravel[i];
                        if (PaxDeskTmp.Desk.StartsWith(sLocation))
                        {
                            if (pTmp.X == -1)
                                pTmp.X = (float)PaxDeskTmp.ArrivalTime;
                            if ((bStopped) && (i == alPaxTravel.Count - 1))
                                pTmp.Y = (float)dEndTime;
                            else
                                pTmp.Y = (float)PaxDeskTmp.LeavingTime;
                        }
                        else
                        {
                            if (pTmp.X != -1)
                            {
                                pTmp.Y = pTmp.Y - pTmp.X;
                                lpReturn.Add(pTmp);
                            }
                            pTmp = new PointF(-1, -1);
                        }
                    }
                    if (pTmp.X != -1)
                    {
                        pTmp.Y = pTmp.Y - pTmp.X;
                        lpReturn.Add(pTmp);
                    }
                    return lpReturn;
                }
                #endregion

                #region Fonction pour le calcul de l'occupation du pax dans les couloirs.
                public void CorridorOccupation(DataTable TheOccupation, Double dPas, DateTime dtBeginTime)
                {
                    String OriginGroup = "";
                    String OriginDesk = "";
                    Double dLeavingTime = 0;
                    foreach (paxTravelData paxData in alPaxTravel)
                    {
                        if ((OriginDesk != "") && (paxData.IsGroup))
                        {
                            String PaxPosition = OriginGroup + "_" + paxData.Desk;
                            int iIndex = TheOccupation.Columns.IndexOf(PaxPosition);
                            if (iIndex == -1)
                            {
                                TheOccupation.Columns.Add(PaxPosition, typeof(Int32));
                                TheOccupation.Columns[TheOccupation.Columns.Count - 1].ExtendedProperties.Add("ToolTip", "(Number of pax)");
                                int iIndexColumn = TheOccupation.Columns.IndexOf(PaxPosition);
                                foreach (DataRow ligne in TheOccupation.Rows)
                                {
                                    ligne[iIndexColumn] = 0;
                                }
                                iIndex = TheOccupation.Columns.Count - 1;
                            }
                            setPax(TheOccupation, 0, dLeavingTime, paxData.ArrivalTime, iIndex, dPas, dtBeginTime);
                            OriginGroup = paxData.Desk;
                        }
                        OriginDesk = paxData.Desk;
                        if ((!paxData.IsGroup) || (OriginGroup == ""))
                            dLeavingTime = paxData.ArrivalTime + paxData.ProcessTime + paxData.WaitingTime;
                        if (OriginGroup == "")
                            OriginGroup = OriginDesk;
                    }
                }
                #endregion

                #region Fonction pour le calcul du temps restant avant le vol de chacun des passagers.

                public void getRemainingTime(Double dPas, DateTime dtBeginTime, Hashtable htRemainingTime)
                {
                    Double dFlight = 0;
                    if (fiFPDInformations == null)
                        //Si le passager a un vol départ.
                        return;

                    dFlight = fiFPDInformations.getBoardingTime(dtBeginTime);
                    foreach (paxTravelData paxData in alPaxTravel)
                    {
                        if (!paxData.IsGroup)
                        {
                            if (!htRemainingTime.ContainsKey(paxData.Desk))
                            {
                                htRemainingTime.Add(paxData.Desk, new ArrayList());
                            }
                            if (paxData.Desk.Contains("Boarding Gate"))
                            {
                                if ((alPaxTravel.Count >= 3) && (((paxTravelData)alPaxTravel[alPaxTravel.Count - 2]).IsGroup))
                                {
                                    paxTravelData tmp = ((paxTravelData)alPaxTravel[alPaxTravel.Count - 2]);
                                    ((ArrayList)htRemainingTime[paxData.Desk]).Add(dFlight - (tmp.ArrivalTime /*+ tmp.ProcessTime + tmp.WaitingTime*/));
                                }
                            }
                            else
                            {
                                ((ArrayList)htRemainingTime[paxData.Desk]).Add(dFlight - (paxData.ArrivalTime + paxData.ProcessTime + paxData.WaitingTime));
                            }
                        }
                    }
                }
                #endregion

                #region Fonction pour les statistiques générales des postes.
                public void setStatistics(Hashtable htStatistics)
                {
                    int i = 0;
                    for (i = 0; i < alPaxTravel.Count; i++)
                    {
                        paxTravelData ptdDesk = (paxTravelData)alPaxTravel[i];
                        if (htStatistics.ContainsKey(ptdDesk.Desk))
                        {
                            DeskReport di_Desk = (DeskReport)htStatistics[ptdDesk.Desk];
                            /*if (this.isTransferred)
                                di_Desk.setTransfer();
                            if (i == alPaxTravel.Count - 1)
                            {
                                if (this.HadMissed)
                                    di_Desk.setMissed();
                                else if (this.Stopped)
                                    di_Desk.setStopped();
                                else if (this.Lost)
                                    di_Desk.setLost();
                            }*/
                        }
                    }
                }
                #endregion

                #region Fonction pour le calcul des statistiques des groupes

                public static void setPaxInformation(Hashtable htStats, String Name, bool Group, bool transferred, bool missed, bool stopped, bool lost, Double dWaitingTime)
                {
                    DeskReport desk;
                    if (!htStats.ContainsKey(Name))
                    {
                        desk = new DeskReport(Name, Group);
                        htStats.Add(Name, desk);
                    }
                    else
                    {
                        desk = (DeskReport)htStats[Name];
                    }
                    desk.AddPax();
                    if (transferred)
                        desk.setTransfer();
                    if (missed)
                        desk.setMissed();
                    if (dWaitingTime != -1)
                        desk.AddWaitingTime(dWaitingTime);
                    if (stopped)
                        desk.setStopped();
                    if (lost)
                        desk.setLost();
                }
                public void setGroupStatistics(Hashtable htStats)
                {
                    int i;
                    ArrayList AlreadyMarked = new ArrayList();
                    setPaxInformation(htStats, "Airport Reports", true, this.isTransferred, this.HadMissed, this.Stopped, this.Lost, -1);
                    int o = 0;
                    int[] Localisation;
                    if (((paxTravelData)alPaxTravel[alPaxTravel.Count - 1]).Desk.Length < 4)
                        return;
                    String sLastDesk = ((paxTravelData)alPaxTravel[alPaxTravel.Count - 1]).Desk.Substring(0, 4);
                    bool bTerminalIsPassed = false;
                    bool bLevelIsPassed = false;
                    for (i = 0; i < alPaxTravel.Count; i++)
                    {
                        paxTravelData deskTmp = (paxTravelData)alPaxTravel[i];

                        Localisation = OverallTools.DataFunctions.AnalyzeGroupName(deskTmp.Desk);
                        if (Localisation != null)
                        {
                            String NameTmp = "T" + Localisation[0].ToString() + "L" + Localisation[1].ToString();
                            if (!AlreadyMarked.Contains(NameTmp))
                            {
                                o++;
                                AlreadyMarked.Add(NameTmp);
                                if ((NameTmp == sLastDesk) && (!bLevelIsPassed))
                                {
                                    bLevelIsPassed = true;
                                    setPaxInformation(htStats, NameTmp, true, this.isTransferred, this.HadMissed, this.Stopped, this.Lost, -1);
                                }
                                else
                                    setPaxInformation(htStats, NameTmp, true, this.isTransferred, false, false, false, -1);
                                NameTmp = "T" + Localisation[0].ToString();
                                if (!AlreadyMarked.Contains(NameTmp))
                                {
                                    AlreadyMarked.Add(NameTmp);
                                    if ((sLastDesk.StartsWith(NameTmp) && (!bTerminalIsPassed)))
                                    {
                                        setPaxInformation(htStats, NameTmp, true, this.isTransferred, this.HadMissed, this.Stopped, this.Lost, -1);
                                        bTerminalIsPassed = true;
                                    }
                                    else
                                        setPaxInformation(htStats, NameTmp, true, this.isTransferred, false, false, false, -1);
                                }
                            }
                            if (Localisation[2] == 0)
                                continue;
                        }
                        if (!deskTmp.IsGroup)
                            continue;
                        /*if ((alPaxTravel.Count - 1) == i)
                            setPaxInformation(htStats, deskTmp.Desk, false, this.isTransferred, this.HadMissed, this.Stopped, this.Lost, deskTmp.WaitingTime);
                        else
                            setPaxInformation(htStats, deskTmp.Desk, false, this.isTransferred, false, false, false, deskTmp.WaitingTime);*/
                    }
                    AlreadyMarked.Clear();
                    if ((o == 2) && (!this.isTransferred))
                    {
                    }
                }
                #endregion

            }
            #endregion

            #region La classe ObjectifsComparaison
            /// <summary>
            /// This class is used to calculate the table departure flight statistics (\ref dtDepartureFlightStatistics)
            /// This would contained the statistics of passengers that missed their flight and why they do missed their fligt.
            /// It is based on a millestone used that concern a number of minutes before closing.
            /// </summary>
            internal class ObjectifsComparaison
            {
                /// <summary>
                /// Statistics of a given flight for a given desk. (Check In or Boarding gate)
                /// Number of passagers arrived for the flight. Processed ...
                /// </summary>
                class DeskStatistics
                {
                    internal int iNbPaxArrived;
                    internal int iNbPaxProcessed;
                    internal int iNbPaxMissed;
                    internal int iNbPaxStopped;

                    internal int iNbPaxArrivedBeforeMillestone;
                    internal int iNbPaxArrivedBetweenMillestoneAndClosing;
                    internal int iNbPaxArrivedAfterClosing;

                    internal int iNbPaxProcessedBeforeMillestone;
                    internal int iNbPaxProcessedBetweenMillestoneAndClosing;

                    internal Double dMinProcessTime;
                    internal Double dAverageProcessTime;
                    internal Double dMaxProcessTime;

                    internal Double dMinWaitingTime;
                    internal Double dAverageWaitingTime;
                    internal Double dMaxWaitingTime;
                    internal Double dLastProcessedPax;
                    internal Double dLastPaxArrived;

                    internal DeskStatistics()
                    {
                        iNbPaxArrived = 0;
                        iNbPaxProcessed = 0;
                        iNbPaxMissed = 0;
                        iNbPaxStopped = 0;

                        iNbPaxArrivedBeforeMillestone = 0;
                        iNbPaxArrivedBetweenMillestoneAndClosing = 0;
                        iNbPaxArrivedAfterClosing = 0;

                        iNbPaxProcessedBeforeMillestone = 0;
                        iNbPaxProcessedBetweenMillestoneAndClosing = 0;

                        dMinProcessTime = -1;
                        dAverageProcessTime = 0;
                        dMaxProcessTime = 0;

                        dMinWaitingTime = -1;
                        dAverageWaitingTime = 0;
                        dMaxWaitingTime = 0;

                        dLastProcessedPax = -1;
                        dLastPaxArrived = 18000000;
                    }
                }


                int iTotalGeneratedPax;

                /// <summary>
                /// The pax for this flight.
                /// </summary>
                internal List<PaxResultsStruct> alPax;

                internal void AddPax(PaxResultsStruct prsPax)
                {
                    if (alPax == null)
                        alPax = new List<PaxResultsStruct>();
                    alPax.Add(prsPax);
                }
                internal Boolean ContainsPax(int iIdPax)
                {
                    if (alPax == null)
                        return false;
                    foreach (PaxResultsStruct prsPax in alPax)
                        if (iIdPax == prsPax.IdPax)
                            return true;
                    return false;
                }

                internal void AddMissingPax()
                {
                    iMissingPax++;
                }

                /// <summary>
                /// Pax that does not appears in the trace.
                /// </summary>
                private int iMissingPax;

                /// <summary>
                /// The number of passengers that missed their flights. The computing of the statistics will be done by the \ref Missed accessors.
                /// </summary>
                private int iMissed;
                internal int Missed
                {
                    get
                    {
                        if (iMissed != -1)
                            return iMissed;
                        iMissed = 0;
                        iStopped = 0;
                        foreach (PaxResultsStruct prsTmp in alPax)
                        {
                            if (prsTmp.HadMissed)
                                iMissed++;
                            if (prsTmp.Stopped)
                                iStopped++;
                        }
                        return iMissed;
                    }
                }
                /// <summary>
                /// The number of passengers that were stopped at the end of the simulation. The computing of the statistics will be done by the \ref Missed accessors.
                /// </summary>
                private int iStopped;
                internal int Stopped
                {
                    get
                    {
                        if (iStopped == -1)
                            iMissed = Missed;
                        return iStopped;
                    }
                }

                Double dMinTimeOriginating;
                Double dMaxTimeOriginating;
                Double dAverageTimeOriginating;
                Double dMinTimeTransfering;
                Double dMaxTimeTransfering;
                Double dAverageTimeTransfering;

                Double dMileStone;

                int iOriginating;
                int iTransferring;
                int iSelfServiceCI;




                #region For the Departure flights
                DeskStatistics dsCheckInStats;
                DeskStatistics dsBoardingStats;

                private PaxResultsStruct.FlightInformations fiFPInformations;
                internal PaxResultsStruct.FlightInformations FPInformations
                {
                    get
                    {
                        return fiFPInformations;
                    }
                    set
                    {
                        fiFPInformations = value;
                    }
                }

                internal double dOpeningCI;
                internal double dClosingCI;
                internal double dOpeningBG;
                internal double dClosingBG;
                #endregion

                internal ObjectifsComparaison()
                {
                    fiFPInformations = null;
                    iMissed = -1;
                    iStopped = -1;
                    iMissingPax = 0;
                    dMinTimeOriginating = -1;
                    dMaxTimeOriginating = 0;
                    dAverageTimeOriginating = 0;
                    dMinTimeTransfering = -1;
                    dMaxTimeTransfering = 0;
                    dAverageTimeTransfering = 0;
                    iOriginating = 0;
                    iTransferring = 0;
                    dMileStone = 0;
                    iSelfServiceCI = 0;
                }

                internal void CalcStatistics(Double dMileStone_)
                {
                    Double dTmp;
                    dMileStone = dMileStone_;
                    if (alPax == null)
                        return;
                    foreach (PaxResultsStruct prsTmp in alPax)
                    {
                        iTotalGeneratedPax++;
                        if (prsTmp.isSelfServiceCI)
                            iSelfServiceCI++;
                        if ((prsTmp.CheckInGroup != null) && (!prsTmp.isSelfServiceCI))
                        {
                            #region Partie pour le process d'enregistrement aux CI (Self service ne sont pas pris en compte)
                            if (dsCheckInStats == null)
                                dsCheckInStats = new DeskStatistics();

                            dsCheckInStats.iNbPaxArrived++;
                            Double dArrivalTime = prsTmp.CheckInGroup.ArrivalTime;
                            if (dArrivalTime >= dClosingCI)
                            {
                                dsCheckInStats.iNbPaxArrivedAfterClosing++;
                            }
                            else if ((dClosingCI - dArrivalTime) >= dMileStone)
                            {
                                dsCheckInStats.iNbPaxArrivedBeforeMillestone++;
                            }
                            else
                            {
                                dsCheckInStats.iNbPaxArrivedBetweenMillestoneAndClosing++;
                            }

                            if ((prsTmp.Stopped) && (prsTmp.isCheckinLastTheGroupOrStationEntered))
                            {
                                dsCheckInStats.iNbPaxStopped++;
                            }
                            else if ((prsTmp.HadMissed) && (prsTmp.isCheckinLastTheGroupOrStationEntered))
                            {
                                dsCheckInStats.iNbPaxMissed++;
                            }
                            else
                            {
                                dsCheckInStats.iNbPaxProcessed++;
                                Double dLeavingTime = prsTmp.CheckIn.LeavingTime;
                                if ((dClosingCI - dLeavingTime) >= dMileStone)
                                {
                                    dsCheckInStats.iNbPaxProcessedBeforeMillestone++;
                                }
                                else
                                {
                                    dsCheckInStats.iNbPaxProcessedBetweenMillestoneAndClosing++;
                                }
                                dTmp = prsTmp.CheckIn.ProcessTime;
                                if ((dsCheckInStats.dMinProcessTime == -1) || (dsCheckInStats.dMinProcessTime > dTmp))
                                    dsCheckInStats.dMinProcessTime = dTmp;
                                if (dsCheckInStats.dMaxProcessTime < dTmp)
                                    dsCheckInStats.dMaxProcessTime = dTmp;
                                dsCheckInStats.dAverageProcessTime += dTmp;

                            }
                            if (prsTmp.CheckIn != null)
                            {
                                dTmp = prsTmp.CheckIn.WaitingTime + prsTmp.CheckInGroup.WaitingTime;
                                if ((dsCheckInStats.dMinWaitingTime == -1) || (dsCheckInStats.dMinWaitingTime > dTmp))
                                    dsCheckInStats.dMinWaitingTime = dTmp;

                                if (dsCheckInStats.dMaxWaitingTime < dTmp)
                                    dsCheckInStats.dMaxWaitingTime = dTmp;
                                dsCheckInStats.dAverageWaitingTime += dTmp;
                            }
                            #endregion
                        }

                        if (prsTmp.BoardingGateGroup != null)
                        {
                            #region Partie pour le process d'enregistrement aux Boarding Gate
                            if (dsBoardingStats == null)
                                dsBoardingStats = new DeskStatistics();

                            dsBoardingStats.iNbPaxArrived++;
                            Double dArrivalTime = prsTmp.BoardingGateGroup.ArrivalTime;
                            if (dArrivalTime >= dClosingBG)
                            {
                                dsBoardingStats.iNbPaxArrivedAfterClosing++;
                            }
                            else if ((dClosingBG - dArrivalTime) >= dMileStone)
                            {
                                dsBoardingStats.iNbPaxArrivedBeforeMillestone++;
                            }
                            else
                            {
                                dsBoardingStats.iNbPaxArrivedBetweenMillestoneAndClosing++;
                            }

                            if (dClosingBG - dArrivalTime < dsBoardingStats.dLastPaxArrived)
                                dsBoardingStats.dLastPaxArrived = dClosingBG - dArrivalTime;
                            if ((prsTmp.Stopped) && (prsTmp.isBoardingGateTheLastGroupOrStationEntered))
                            {
                                dsBoardingStats.iNbPaxStopped++;
                            }
                            else if ((prsTmp.HadMissed) && (prsTmp.isBoardingGateTheLastGroupOrStationEntered))
                            {
                                dsBoardingStats.iNbPaxMissed++;
                            }
                            else
                            {
                                dsBoardingStats.iNbPaxProcessed++;
                                Double dLeavingTime = prsTmp.BoardingGate.LeavingTime;
                                if ((dsBoardingStats.dLastProcessedPax == -1) || (dClosingBG - dLeavingTime < dsBoardingStats.dLastProcessedPax))
                                    dsBoardingStats.dLastProcessedPax = dClosingBG - dLeavingTime;
                                if ((dClosingBG - dLeavingTime) >= dMileStone)
                                {
                                    dsBoardingStats.iNbPaxProcessedBeforeMillestone++;
                                }
                                else
                                {
                                    dsBoardingStats.iNbPaxProcessedBetweenMillestoneAndClosing++;
                                }
                                dTmp = prsTmp.BoardingGate.ProcessTime;
                                if ((dsBoardingStats.dMinProcessTime == -1) || (dsBoardingStats.dMinProcessTime > dTmp))
                                    dsBoardingStats.dMinProcessTime = dTmp;
                                if (dsBoardingStats.dMaxProcessTime < dTmp)
                                    dsBoardingStats.dMaxProcessTime = dTmp;
                                dsBoardingStats.dAverageProcessTime += dTmp;

                            }

                            if (prsTmp.BoardingGate != null)
                            {
                                dTmp = prsTmp.BoardingGate.WaitingTime + prsTmp.BoardingGateGroup.WaitingTime;
                                if ((dsBoardingStats.dMinWaitingTime == -1) || (dsBoardingStats.dMinWaitingTime > dTmp))
                                    dsBoardingStats.dMinWaitingTime = dTmp;

                                if (dsBoardingStats.dMaxWaitingTime < dTmp)
                                    dsBoardingStats.dMaxWaitingTime = dTmp;
                                dsBoardingStats.dAverageWaitingTime += dTmp;
                            }
                            #endregion
                        }

                        dTmp = prsTmp.TotalPresentTime;
                        if (prsTmp.isTransferred)
                        {
                            iTransferring++;
                            if ((dMinTimeTransfering == -1) || (dMinTimeTransfering > dTmp))
                                dMinTimeTransfering = dTmp;
                            if (dMaxTimeTransfering < dTmp)
                                dMaxTimeTransfering = dTmp;
                            dAverageTimeTransfering += dTmp;
                        }
                        else
                        {
                            iOriginating++;
                            if ((dMinTimeOriginating == -1) || (dMinTimeOriginating > dTmp))
                                dMinTimeOriginating = dTmp;
                            if (dMaxTimeOriginating < dTmp)
                                dMaxTimeOriginating = dTmp;
                            dAverageTimeOriginating += dTmp;
                        }


                    }
                    if (dsCheckInStats != null)
                    {
                        if (dsCheckInStats.iNbPaxProcessed > 0)
                            dsCheckInStats.dAverageProcessTime = dsCheckInStats.dAverageProcessTime / dsCheckInStats.iNbPaxProcessed;
                        if (dsCheckInStats.iNbPaxArrived > 0)
                            dsCheckInStats.dAverageWaitingTime = dsCheckInStats.dAverageWaitingTime / dsCheckInStats.iNbPaxArrived;
                    }
                    if (dsBoardingStats != null)
                    {
                        if (dsBoardingStats.iNbPaxProcessed > 0)
                            dsBoardingStats.dAverageProcessTime = dsBoardingStats.dAverageProcessTime / dsBoardingStats.iNbPaxProcessed;
                        if (dsBoardingStats.iNbPaxArrived > 0)
                            dsBoardingStats.dAverageWaitingTime = dsBoardingStats.dAverageWaitingTime / dsBoardingStats.iNbPaxArrived;
                    }
                    if (iTransferring > 0)
                        dAverageTimeTransfering = dAverageTimeTransfering / iTransferring;
                    if (iOriginating > 0)
                        dAverageTimeOriginating = dAverageTimeOriginating / iOriginating;
                }

                internal Object[] getResults(DateTime dtEndTime)
                {
                    Object[] objResult = new Object[28];
                    objResult[0] = dtEndTime;
                    objResult[1] = fiFPInformations.iIdFlight;
                    objResult[2] = fiFPInformations.sFlightName;
                    objResult[3] = fiFPInformations.sAirline;
                    objResult[4] = fiFPInformations.sFlightCategory;
                    objResult[5] = fiFPInformations.dtDate.Add(fiFPInformations.tsTime);

                    objResult[6] = iTotalGeneratedPax + iMissingPax;
                    objResult[7] = iOriginating;
                    objResult[8] = iTransferring;
                    objResult[9] = iSelfServiceCI;

                    if (dsCheckInStats != null)
                    {
                        objResult[10] = dsCheckInStats.iNbPaxProcessed;
                        objResult[11] = dsCheckInStats.iNbPaxMissed;
                        objResult[12] = dsCheckInStats.iNbPaxStopped;
                        objResult[13] = dsCheckInStats.iNbPaxArrivedBeforeMillestone;
                        objResult[14] = dsCheckInStats.iNbPaxArrivedBetweenMillestoneAndClosing;
                        objResult[15] = dsCheckInStats.iNbPaxArrivedAfterClosing;
                        objResult[16] = dsCheckInStats.iNbPaxProcessedBeforeMillestone;
                        objResult[17] = dsCheckInStats.iNbPaxProcessedBetweenMillestoneAndClosing;
                    }
                    else
                    {
                        objResult[10] = 0;
                        objResult[11] = 0;
                        objResult[12] = 0;
                        objResult[13] = 0;
                        objResult[14] = 0;
                        objResult[15] = 0;
                        objResult[16] = 0;
                        objResult[17] = 0;
                    }

                    if (dsBoardingStats != null)
                    {
                        objResult[18] = dsBoardingStats.iNbPaxProcessed;
                        objResult[19] = dsBoardingStats.iNbPaxMissed;
                        objResult[20] = dsBoardingStats.iNbPaxStopped;
                        objResult[21] = dsBoardingStats.iNbPaxArrivedBeforeMillestone;
                        objResult[22] = dsBoardingStats.iNbPaxArrivedBetweenMillestoneAndClosing;
                        objResult[23] = dsBoardingStats.iNbPaxArrivedAfterClosing;
                        objResult[24] = dsBoardingStats.iNbPaxProcessedBeforeMillestone;
                        objResult[25] = dsBoardingStats.iNbPaxProcessedBetweenMillestoneAndClosing;
                        objResult[26] = Math.Round(dsBoardingStats.dLastPaxArrived, 2);
                        objResult[27] = Math.Round(dsBoardingStats.dLastProcessedPax, 2);
                    }
                    else
                    {
                        objResult[18] = 0;
                        objResult[19] = 0;
                        objResult[20] = 0;
                        objResult[21] = 0;
                        objResult[22] = 0;
                        objResult[23] = 0;
                        objResult[24] = 0;
                        objResult[25] = 0;
                        objResult[26] = 0;
                        objResult[27] = 0;
                    }
                    return objResult;
                }
                static internal DataTable getResultTable(String sTableName, Double dMilleStone)
                {
                    DataTable dtResult = new DataTable(sTableName);
                    dtResult.Columns.Add("Simulation End Time", typeof(DateTime));
                    dtResult.Columns.Add("FPD_ID", typeof(int));
                    dtResult.Columns.Add("FlightNumber", typeof(String));
                    dtResult.Columns.Add("Airline", typeof(String));
                    dtResult.Columns.Add("FlightCategory", typeof(String));
                    dtResult.Columns.Add("STD", typeof(DateTime));

                    dtResult.Columns.Add("Nb Generated Pax", typeof(int));
                    dtResult.Columns.Add("Nb Originating Pax", typeof(int));
                    dtResult.Columns.Add("Nb Transfer Pax", typeof(int));
                    dtResult.Columns.Add("Nb Self Service CI Pax", typeof(int));

                    dtResult.Columns.Add("CI Processed Pax", typeof(int));
                    dtResult.Columns.Add("CI Missed Pax", typeof(int));
                    dtResult.Columns.Add("CI Stopped Pax", typeof(int));
                    dtResult.Columns.Add("CI Pax arrived between opening and " + dMilleStone.ToString() + " mn before closing", typeof(int));
                    dtResult.Columns.Add("CI Pax arrived between " + dMilleStone.ToString() + " mn before closing and closing", typeof(int));
                    dtResult.Columns.Add("CI Pax arrived after closing", typeof(int));
                    dtResult.Columns.Add("CI Pax processed between opening and " + dMilleStone.ToString() + " mn before closing", typeof(int));
                    dtResult.Columns.Add("CI Pax processed between " + dMilleStone.ToString() + " mn before closing and closing", typeof(int));

                    dtResult.Columns.Add("BG Processed Pax", typeof(int));
                    dtResult.Columns.Add("BG Missed Pax", typeof(int));
                    dtResult.Columns.Add("BG Stopped Pax", typeof(int));
                    dtResult.Columns.Add("BG Pax arrived between opening and " + dMilleStone.ToString() + " mn before closing", typeof(int));
                    dtResult.Columns.Add("BG Pax arrived between " + dMilleStone.ToString() + " mn before closing and closing", typeof(int));
                    dtResult.Columns.Add("BG Pax arrived after closing", typeof(int));

                    dtResult.Columns.Add("BG Pax processed between opening and " + dMilleStone.ToString() + " mn before closing", typeof(int));
                    dtResult.Columns.Add("BG Pax processed between " + dMilleStone.ToString() + " mn before closing and closing", typeof(int));

                    dtResult.Columns.Add("BG Last Pax arrived (min before closing)", typeof(Double));

                    dtResult.Columns.Add("BG Last Processed Pax (min before closing)", typeof(Double));
                    return dtResult;
                }
            }
            #endregion

            #region La classe pour les résultats pour les Postes et les groupes   ---DeskGroupResultsStruct---
            public class DeskGroupResultsStruct // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
            {
                private Double dAnalysisStep;
                private String sDeskName;
                private Int32 iNumberOfPax;
                private DateTime dtHeureDebutSimulation;

                private Double dTotalOpeningTime;
                private Double dTotalWorkingTime;

                private List<Double> alArrivingTimes;
                // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                private List<Double> alDelayTimes;
                // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                private List<Double> alProcessTimes;
                private List<Double> alWaitingTimesDesk;
                private List<Double> alWaitingTimesGroup;

                private List<PaxResultsStruct> lprsPassengers;

                //Données calculées par la suite.
                Double[][] tdTimes;

                PaxResultsStruct.TraceFilter tfConditions;


                #region La gestion des allocations
                private DataTable dtAllocationTable;
                private int iColumnIndex;
                private int iIndexDesk;

                public DataTable AllocationTable
                {
                    get
                    {
                        return dtAllocationTable;
                    }
                    set
                    {
                        dtAllocationTable = value;
                    }
                }

                public int ColumnIndex
                {
                    get
                    {
                        return iColumnIndex;
                    }
                    set
                    {
                        iColumnIndex = value;
                    }
                }
                public int IndexDesk
                {
                    get
                    {
                        return iIndexDesk;
                    }
                    set
                    {
                        iIndexDesk = value;
                    }
                }
                #endregion

                private DataTable dtOccupation;

                #region les accesseurs
                public String DeskName
                {
                    get
                    {
                        return sDeskName;
                    }
                }
                public Int32 NumberOfPax
                {
                    get
                    {
                        if (Ready)
                            return iNumberOfPax;
                        return 0;
                    }
                }
                public Double AnalysisStep
                {
                    get
                    {
                        return dAnalysisStep;
                    }
                    set
                    {
                        dAnalysisStep = value;
                    }
                }
                public Double TotalOpeningTime
                {
                    get
                    {
                        return Math.Round(dTotalOpeningTime, 2);
                    }
                    set
                    {
                        dTotalOpeningTime = value;
                    }
                }
                public Double TotalWorkingTime
                {
                    get
                    {
                        return Math.Round(dTotalWorkingTime, 2);
                    }
                }
                public Double TotalFreeTime
                {
                    get
                    {
                        if (dTotalOpeningTime == 0)
                            return 0;
                        return Math.Round(dTotalOpeningTime - dTotalWorkingTime, 2);
                    }
                }
                public Double Rate
                {
                    get
                    {
                        if (dTotalOpeningTime == 0)
                            return -1;
                        return Math.Round(dTotalWorkingTime / dTotalOpeningTime, 2);
                    }
                }

                public int NumberOfTransfer
                {
                    get
                    {
                        if (lprsPassengers == null)
                            return 0;
                        int iReturn = 0;
                        for (int i = 0; i < lprsPassengers.Count; i++)
                        {
                            if (lprsPassengers[i].isTransferred)
                                iReturn++;
                        }
                        return iReturn;
                    }
                }
                public int NumberOfProcessedPax
                {
                    get
                    {
                        if (alProcessTimes == null)
                            return 0;
                        int iReturn = 0;
                        for (int i = 0; i < alProcessTimes.Count; i++)
                        {
                            if (FonctionsType.getDouble(alProcessTimes[i]) >= 0)
                                iReturn++;
                        }
                        return iReturn;
                    }
                }

                // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                public List<PaxResultsStruct> listOfPassengers
                {
                    get { return lprsPassengers; }
                }
                // << Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent

                public int NumberOfLost
                {
                    get
                    {
                        if (lprsPassengers == null)
                            return 0;
                        int iReturn = 0;
                        for (int i = 0; i < lprsPassengers.Count; i++)
                        {
                            if (lprsPassengers[i].Lost)
                            {
                                if (lprsPassengers[i].getStatusGroup(DeskName) != "")
                                    iReturn++;
                            }
                        }
                        return iReturn;
                    }
                }
                public int NumberOfMissed
                {
                    get
                    {
                        if (lprsPassengers == null)
                            return 0;
                        int iReturn = 0;
                        for (int i = 0; i < lprsPassengers.Count; i++)
                        {
                            if (lprsPassengers[i].HadMissed)
                                if (lprsPassengers[i].getStatusGroup(DeskName) != "")
                                    iReturn++;
                        }
                        return iReturn;
                    }
                }
                public int NumberOfStopped
                {
                    get
                    {
                        if (lprsPassengers == null)
                            return 0;
                        int iReturn = 0;
                        for (int i = 0; i < lprsPassengers.Count; i++)
                        {
                            if (lprsPassengers[i].Stopped)
                                if (lprsPassengers[i].getStatusGroup(DeskName) !=
                            "")
                                    iReturn++;
                        }
                        return iReturn;
                    }
                }

                // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                public List<Double> DelayTimes
                {
                    get { return alDelayTimes; }
                }
                // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)

                public List<Double> ArrivingTimes
                {
                    get
                    {
                        return alArrivingTimes;
                    }
                }
                public List<Double> ProcessTimes
                {
                    get
                    {
                        return alProcessTimes;
                    }
                }
                public List<Double> WaitingTimesDesk
                {
                    get
                    {
                        return alWaitingTimesDesk;
                    }
                }
                public List<Double> WaitingTimesGroup
                {
                    get
                    {
                        return alWaitingTimesGroup;
                    }
                }

                #endregion

                // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                #region Total values for KPIs
                Double totalProcessTime_ = -1;
                public Double totalProcessTime
                {
                    get { return Math.Round(totalProcessTime_, 2); }
                }

                Double totalWaitingDeskAndGroupTime_ = -1;
                public Double totalWaitingDeskAndGroupTime
                {
                    get { return Math.Round(totalWaitingDeskAndGroupTime_, 2); }
                }

                Double totalWaitingGroupTime_ = -1;
                public Double totalWaitingGroupTime
                {
                    get { return Math.Round(totalWaitingGroupTime_, 2); }
                }

                Double totalWaitingDeskTime_ = -1;
                public Double totalWaitingDeskTime
                {
                    get { return Math.Round(totalWaitingDeskTime_, 2); }
                }

                Double totalDelayTime_ = -1;
                public Double totalDelayTime
                {
                    get { return Math.Round(totalDelayTime_, 2); }
                }

                Double totalOccupation_ = -1;
                public Double totalOccupation
                {
                    get { return Math.Round(totalOccupation_, 2); }
                }
                #endregion
                // << Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent

                #region les informations de min et de max
                public Double MeanProcessTime
                {
                    get
                    {
                        if (Ready)
                            return tdTimes[0][2];
                        return -1;
                    }
                }
                public Double MinProcessTime
                {
                    get
                    {
                        if (Ready)
                            return tdTimes[0][0];
                        return -1;
                    }
                }
                public Double MaxProcessTime
                {
                    get
                    {
                        if (Ready)
                            return tdTimes[0][1];
                        return -1;
                    }
                }

                public Double MeanWaitingTimeDesk
                {
                    get
                    {
                        if (Ready)
                            return tdTimes[1][2];
                        return -1;
                    }
                }
                public Double MinWaitingTimeDesk
                {
                    get
                    {
                        if (Ready)
                            return tdTimes[1][0];
                        return -1;
                    }
                }
                public Double MaxWaitingTimeDesk
                {
                    get
                    {
                        if (Ready)
                            return tdTimes[1][1];
                        return -1;
                    }
                }

                public Double MeanWaitingTimeGroup
                {
                    get
                    {
                        if (Ready)
                            return tdTimes[2][2];
                        return -1;
                    }
                }
                public Double MinWaitingTimeGroup
                {
                    get
                    {
                        if (Ready)
                            return tdTimes[2][0];
                        return -1;
                    }
                }
                public Double MaxWaitingTimeGroup
                {
                    get
                    {
                        if (Ready)
                            return tdTimes[2][1];
                        return -1;
                    }
                }

                public Double MeanWaitingTime
                {
                    get
                    {
                        if (Ready)
                            return tdTimes[3][2];
                        return -1;
                    }
                }
                public Double MinWaitingTime
                {
                    get
                    {
                        if (Ready)
                            return tdTimes[3][0];
                        return -1;
                    }
                }
                public Double MaxWaitingTime
                {
                    get
                    {
                        if (Ready)
                            return tdTimes[3][1];
                        return -1;
                    }
                }

                public Double MeanOccupationTime
                {
                    get
                    {
                        if (Ready)
                            return tdTimes[4][2];
                        return -1;
                    }
                }
                public Double MinOccupationTime
                {
                    get
                    {
                        if (Ready)
                            return tdTimes[4][0];
                        return -1;
                    }
                }
                public Double MaxOccupationTime
                {
                    get
                    {
                        if (Ready)
                            return tdTimes[4][1];
                        return -1;
                    }
                }
                // << Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                public Double MinDelayTime
                {
                    get
                    {
                        if (Ready)
                            return tdTimes[5][0];
                        return -1;
                    }
                }

                public Double MaxDelayTime
                {
                    get
                    {
                        if (Ready)
                            return tdTimes[5][1];
                        return -1;
                    }
                }

                public Double MeanDelayTime
                {
                    get
                    {
                        if (Ready)
                            return tdTimes[5][2];
                        return -1;
                    }
                }
                // >> Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                #region Fonction pour minimiser le nombre de parcours des listes

                private bool Ready
                {
                    get
                    {
                        if (!bMinMaxMeanCalculed)
                            calcMinMaxMeanValues();
                        return bMinMaxMeanCalculed;
                    }
                }

                bool bMinMaxMeanCalculed;

                private Double Min(Double Value1, Double Value2)
                {
                    if (Value1 > Value2)
                        return Value2;
                    return Value1;
                }
                private Double Max(Double Value1, Double Value2)
                {
                    if (Value1 > Value2)
                        return Value1;
                    return Value2;
                }
                private void calcMinMaxMeanValues()
                {
                    int i;
                    // << Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                    //tdTimes = new Double[5][];
                    tdTimes = new Double[6][];
                    // >> Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                    //0 ==>Process
                    //1 ==> WaitingDesk
                    //2 ==> WaitingGroup
                    //3 ==> Waiting
                    //4 ==> Occupation
                    // << Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                    //5 ==> Delay Time
                    // >> Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time

                    for (i = 0; i < tdTimes.Length; i++)
                    {
                        tdTimes[i] = new Double[4] { 0, 0, 0, 0 };
                    }
                    iNumberOfPax = 0;

                    for (i = 0; i < alProcessTimes.Count; i++)
                    {
                        if (!lprsPassengers[i].CheckPaxIsValidForFilter(tfConditions))
                            continue;
                        if (iNumberOfPax == 0)
                        {
                            iNumberOfPax++;
                            tdTimes[0][0] = (Double)alProcessTimes[i];
                            if (tdTimes[0][0] < 0)
                                tdTimes[0][0] = 0;
                            else
                            {
                                tdTimes[0][1] = tdTimes[0][0];
                                tdTimes[0][2] = tdTimes[0][0];
                                tdTimes[0][3] = 1;
                            }

                            tdTimes[1][0] = (Double)alWaitingTimesDesk[i];
                            if (tdTimes[1][0] < 0)
                                tdTimes[1][0] = 0;
                            else
                            {
                                tdTimes[1][1] = (Double)alWaitingTimesDesk[i];
                                tdTimes[1][2] = (Double)alWaitingTimesDesk[i];
                                tdTimes[1][3] = 1;
                            }

                            tdTimes[2][0] = (Double)alWaitingTimesGroup[i];
                            if (tdTimes[2][0] < 0)
                                tdTimes[2][0] = 0;
                            else
                            {
                                tdTimes[2][1] = (Double)alWaitingTimesGroup[i];
                                tdTimes[2][2] = (Double)alWaitingTimesGroup[i];
                                tdTimes[2][3] = 1;
                            }

                            tdTimes[3][0] = tdTimes[2][0] + tdTimes[1][0];
                            tdTimes[3][1] = tdTimes[2][1] + tdTimes[1][1];
                            tdTimes[3][2] = tdTimes[2][2] + tdTimes[1][2];
                            tdTimes[3][3] = Max(tdTimes[2][3], tdTimes[1][3]);

                            // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                            Double delayTime = 0;
                            if (alDelayTimes.Count > i && (Double)alDelayTimes[i] > 0)
                                delayTime = (Double)alDelayTimes[i];

                            tdTimes[4][0] = tdTimes[3][0] + tdTimes[0][0] + delayTime;
                            tdTimes[4][1] = tdTimes[3][1] + tdTimes[0][1] + delayTime;
                            tdTimes[4][2] = tdTimes[3][2] + tdTimes[0][2] + delayTime;
                            // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                            tdTimes[4][3] = Max(tdTimes[3][3], tdTimes[0][3]);

                            // << Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                            tdTimes[5][0] = delayTime;
                            if (tdTimes[5][0] < 0)
                                tdTimes[5][0] = 0;
                            else
                            {
                                tdTimes[5][1] = delayTime;
                                tdTimes[5][2] = delayTime;
                                tdTimes[5][3] = 1;
                            }
                            // >> Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                            continue;
                        }
                        iNumberOfPax++;
                        if ((Double)alProcessTimes[i] >= 0)
                        {
                            tdTimes[0][2] += (Double)alProcessTimes[i];
                            if (tdTimes[0][3] == 0)
                                tdTimes[0][0] = (Double)alProcessTimes[i];
                            tdTimes[0][0] = Min(tdTimes[0][0], (Double)alProcessTimes[i]);
                            tdTimes[0][1] = Max(tdTimes[0][1], (Double)alProcessTimes[i]);
                            tdTimes[0][3] += 1;
                        }
                        Double Waiting = 0;
                        if ((Double)alWaitingTimesDesk[i] >= 0)
                        {
                            tdTimes[1][2] += (Double)alWaitingTimesDesk[i];
                            Waiting += (Double)alWaitingTimesDesk[i];
                            if (tdTimes[1][3] == 0)
                                tdTimes[1][0] = (Double)alWaitingTimesDesk[i];
                            tdTimes[1][0] = Min(tdTimes[1][0], (Double)alWaitingTimesDesk[i]);
                            tdTimes[1][1] = Max(tdTimes[1][1], (Double)alWaitingTimesDesk[i]);
                            tdTimes[1][3] += 1;
                        }
                        else
                        {
                            Waiting = -1;
                        }
                        if ((Double)alWaitingTimesGroup[i] >= 0)
                        {
                            tdTimes[2][2] += (Double)alWaitingTimesGroup[i];
                            if (tdTimes[2][3] == 0)
                                tdTimes[2][0] = (Double)alWaitingTimesGroup[i];
                            tdTimes[2][0] = Min(tdTimes[2][0], (Double)alWaitingTimesGroup[i]);
                            tdTimes[2][1] = Max(tdTimes[2][1], (Double)alWaitingTimesGroup[i]);
                            if (Waiting >= 0)
                                Waiting += (Double)alWaitingTimesGroup[i];
                            tdTimes[2][3] += 1;
                        }
                        if (Waiting >= 0)
                        {
                            if (tdTimes[3][3] == 0)
                                tdTimes[3][0] = Waiting;
                            tdTimes[3][0] = Min(tdTimes[3][0], Waiting);
                            tdTimes[3][2] += Waiting;
                            tdTimes[3][1] = Max(tdTimes[3][1], Waiting);
                            tdTimes[3][3] += 1;

                            if ((Double)alProcessTimes[i] >= 0)
                            {
                                // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)                                
                                Double delayTime = 0;
                                if (alDelayTimes.Count > i && (Double)alDelayTimes[i] > 0)
                                    delayTime = (Double)alDelayTimes[i];
                                Double Occupation = delayTime + Waiting + (Double)alProcessTimes[i];
                                // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)                                

                                if (tdTimes[4][3] == 0)
                                    tdTimes[4][0] = Occupation;
                                tdTimes[4][0] = Min(tdTimes[4][0], Occupation);
                                tdTimes[4][1] = Max(tdTimes[4][1], Occupation);

                                tdTimes[4][2] += Occupation;
                                tdTimes[4][3] += 1;
                            }
                        }
                        // << Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                        if (alDelayTimes.Count > i && (Double)alDelayTimes[i] >= 0)
                        {
                            Double delayTime = (Double)alDelayTimes[i];

                            if (tdTimes[5][3] == 0)
                                tdTimes[5][0] = delayTime;
                            tdTimes[5][0] = Min(tdTimes[5][0], delayTime);
                            tdTimes[5][1] = Max(tdTimes[5][1], delayTime);
                            tdTimes[5][2] += delayTime;
                            tdTimes[5][3] += 1;
                        }
                        // >> Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                    }
                    if (alProcessTimes.Count != 0)
                    {
                        for (i = 0; i < tdTimes.Length; i++)
                        {
                            if (tdTimes[i][3] == 0)
                            {
                                // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                                totalProcessTime_ = 0;
                                totalWaitingDeskAndGroupTime_ = 0;
                                totalWaitingGroupTime_ = 0;
                                totalWaitingDeskTime_ = 0;
                                totalDelayTime_ = 0;
                                totalOccupation_ = 0;
                                // << Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                                continue;
                            }
                            // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                            if (i == 0)
                            {
                                totalProcessTime_ = tdTimes[i][2];
                            }
                            if (i == 1)
                            {
                                totalWaitingDeskTime_ = tdTimes[i][2];
                            }
                            if (i == 2)
                            {
                                totalWaitingGroupTime_ = tdTimes[i][2];
                            }
                            if (i == 3)
                            {
                                totalWaitingDeskAndGroupTime_ = tdTimes[i][2];
                            }
                            if (i == 4)
                            {
                                totalOccupation_ = tdTimes[i][2];
                            }
                            if (i == 5)
                            {
                                totalDelayTime_ = tdTimes[i][2];
                            }
                            // << Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                            tdTimes[i][0] = Math.Round(tdTimes[i][0], 2);
                            tdTimes[i][1] = Math.Round(tdTimes[i][1], 2);
                            tdTimes[i][2] = Math.Round(tdTimes[i][2] / /*(double)iNumberOfPax*/tdTimes[i][3], 2);
                        }
                    }
                    bMinMaxMeanCalculed = true;
                }
                #endregion


                #endregion

                public DeskReport getDeskInformations(PaxResultsStruct.TraceFilter Conditions)
                {
                    tfConditions = Conditions;

                    return new DeskReport(sDeskName, NumberOfPax, NumberOfProcessedPax,
                        NumberOfTransfer, NumberOfMissed, NumberOfStopped, NumberOfLost,
                        MinWaitingTime, MaxWaitingTime, MeanWaitingTime,
                        MinWaitingTimeGroup, MaxWaitingTimeGroup, MeanWaitingTimeGroup,
                        MinWaitingTimeDesk, MaxWaitingTimeDesk, MeanWaitingTimeDesk,
                        MinProcessTime, MaxProcessTime, MeanProcessTime,
                        2, 2, 2,
                        MinOccupationTime, MaxOccupationTime, MeanOccupationTime,
                        0, 0, 0,
                        dTotalOpeningTime, dTotalWorkingTime,
                        // << Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                        MinDelayTime, MaxDelayTime, MeanDelayTime
                        // >> Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                        );
                }


                public DeskGroupResultsStruct(String DeskName_, DateTime dtHeureSimulation)
                {
                    sDeskName = DeskName_;
                    iNumberOfPax = 0;
                    dTotalOpeningTime = 0;
                    dTotalWorkingTime = 0;
                    bMinMaxMeanCalculed = false;
                    // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                    alDelayTimes = new List<Double>();
                    // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                    alArrivingTimes = new List<Double>();
                    alProcessTimes = new List<Double>();
                    alWaitingTimesDesk = new List<Double>();
                    alWaitingTimesGroup = new List<Double>();
                    lprsPassengers = new List<PaxResultsStruct>();
                    dtHeureDebutSimulation = dtHeureSimulation;

                    AnalysisStep = 1; //Analyse toutes les minutes.

                    dtOccupation = null;
                    dtAllocationTable = null;
                    iIndexDesk = -1;
                    iColumnIndex = -1;
                    tfConditions = null;
                }
                #region Les fonctions pour ajouter des informations à propos des bureaux
                internal void AddPaxPassing(PaxResultsStruct prsPax, Double ArrivingTime,
                    Double ProcessTime, Double WaitingTimeDesk, Double WaitingTimeGroup, Double DelayTime)
                {
                    // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                    alDelayTimes.Add(DelayTime);
                    // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                    bMinMaxMeanCalculed = false;
                    iNumberOfPax++;
                    dTotalWorkingTime += ProcessTime;
                    alArrivingTimes.Add(ArrivingTime);
                    alProcessTimes.Add(ProcessTime);
                    alWaitingTimesDesk.Add(WaitingTimeDesk);
                    alWaitingTimesGroup.Add(WaitingTimeGroup);
                    lprsPassengers.Add(prsPax);
                }

                internal void AddPaxPassingMissedStopped(PaxResultsStruct prsPax, Double ArrivingTime,
                    Double WaitingTimeDesk, Double WaitingTimeGroup, Double DelayTime)
                {
                    // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                    if (DelayTime < 0)
                        alDelayTimes.Add(-1.0);
                    else
                        alDelayTimes.Add(DelayTime);
                    // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                    bMinMaxMeanCalculed = false;
                    iNumberOfPax++;

                    alArrivingTimes.Add(ArrivingTime);
                    if (WaitingTimeGroup < 0)
                        alWaitingTimesGroup.Add(-1.0);
                    else
                        alWaitingTimesGroup.Add(WaitingTimeGroup);
                    if (WaitingTimeDesk < 0)
                        alWaitingTimesDesk.Add(-1.0);
                    else
                        alWaitingTimesDesk.Add(WaitingTimeDesk);
                    alProcessTimes.Add(-1.0);
                    lprsPassengers.Add(prsPax);
                }

                #endregion

                #region Fonctions pour le calcul de l'occupation du bureau
                public DataTable getOccupation(DateTime dtBeginDate, DateTime dtEndDate, Double dStep, bool bSlidingHour,
                    Double analysisRange) // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                {

                    if ((dAnalysisStep != dStep) || (dtOccupation == null))
                    {
                        //CalcOccupationTable(dtBeginDate, dStep);
                        CalcQueueOccupation(dtBeginDate, dtEndDate, dStep, bSlidingHour,
                            analysisRange);  // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                    }
                    return dtOccupation;
                }
                public void CalcQueueOccupation(DateTime dtBeginDate, DateTime dtEndDate, Double dStep, bool bSlidingHour,
                    Double analysisRange)   // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                {
                    ///Toute la question est de savoir si l'occupation d'une zone passe par l'occupation du poste.
                    Double dEndDate = OverallTools.DataFunctions.MinuteDifference(dtBeginDate, dtEndDate);
                    ArrayList alQueueOccupation = new ArrayList();
                    bool bGroup = sDeskName.Contains("Group");
                    for (int i = 0; i < alArrivingTimes.Count; i++)
                    {
                        if (!lprsPassengers[i].CheckPaxIsValidForFilter(tfConditions))
                            continue;
                        Double dArriving = alArrivingTimes[i];
                        Double dDwellTime = 0;
                        if (!bGroup)
                        {
                            if (alWaitingTimesGroup[i] >= 0)
                            {
                                dArriving += alWaitingTimesGroup[i];
                                if (alWaitingTimesDesk[i] >= 0)
                                    dDwellTime += alWaitingTimesDesk[i];
                                if (alProcessTimes[i] >= 0)
                                    dDwellTime += alProcessTimes[i];
                            }
                            // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                            if (alDelayTimes[i] >= 0)
                                dDwellTime += alDelayTimes[i];
                            // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)                            

                            // << Task #9464 Bug - Analysis - Occupation Nb Pax out                            
                            /*if (lprsPassengers[i].Stopped)
                                dDwellTime = dEndDate - dArriving;*/
                            if (lprsPassengers[i].Stopped)
                            {
                                int lastResourceIndex = lprsPassengers[i].PaxTravel.Count;
                                if (lastResourceIndex > 0
                                    && lprsPassengers[i].PaxTravel[lastResourceIndex - 1].Desk.Equals(sDeskName))
                                {
                                    dDwellTime = -1;// dEndDate - dArriving;
                                }
                            }
                            // >> Task #9464 Bug - Analysis - Occupation Nb Pax out
                        }
                        else
                        {
                            if (alWaitingTimesGroup[i] >= 0)
                            {
                                dDwellTime += alWaitingTimesGroup[i];
                                if (alWaitingTimesDesk[i] >= 0)
                                    dDwellTime += alWaitingTimesDesk[i];
                                if (alProcessTimes[i] >= 0)
                                    dDwellTime += alProcessTimes[i];
                            }
                            // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                            if (alDelayTimes[i] >= 0)
                                dDwellTime += alDelayTimes[i];
                            // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)

                            // << Task #9464 Bug - Analysis - Occupation Nb Pax out                            
                            /*if (lprsPassengers[i].Stopped)
                                dDwellTime = dEndDate - dArriving;*/
                            if (lprsPassengers[i].Stopped)
                            {
                                int lastResourceIndex = lprsPassengers[i].PaxTravel.Count;
                                if (lastResourceIndex > 0
                                    && lprsPassengers[i].PaxTravel[lastResourceIndex - 1].Desk.Equals(sDeskName))
                                {
                                    dDwellTime = -1;//dEndDate - dArriving;
                                }
                            }
                            // >> Task #9464 Bug - Analysis - Occupation Nb Pax out
                        }
                        /*if (!bGroup)
                        {
                            alQueueOccupation.Add(new PointF(
                                    (float)((double)alArrivingTimes[i] + (double)alWaitingTimesGroup[i]),
                                    (float)((double)alWaitingTimesDesk[i]+ (double) alProcessTimes[i])
                                   ));
                        }
                        else
                        {
                            alQueueOccupation.Add(new PointF(
                                    (float)((double)alArrivingTimes[i]),
                                    (float)((double)alWaitingTimesGroup[i]+(double)alWaitingTimesDesk[i]+ (double) alProcessTimes[i])
                                   ));
                        }*/
                        alQueueOccupation.Add(new PointF((float)dArriving, (float)dDwellTime));
                    }
                    //new PointF(0.0f, 0.0f)
                    // >> 1 CalcQueueOccupation_V0 issue
                    /*
                    dtOccupation = ResultFunctions.CalcQueueOccupation_V0(sDeskName + "_Queue_Occupation",//CalcQueueOccupation(sDeskName + "_Queue_Occupation",
                        alQueueOccupation, dtBeginDate, dtEndDate, dStep, "Nb Pax", bSlidingHour, true,
                        analysisRange); // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                    */
                    dtOccupation = ResultFunctions.CalcQueueOccupation(sDeskName + "_Queue_Occupation",//CalcQueueOccupation(sDeskName + "_Queue_Occupation",
                        alQueueOccupation, dtBeginDate, dtEndDate, dStep, "Nb Pax", bSlidingHour, true,
                        analysisRange);
                }

                // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                public DataTable CalcQueueOccupationByDistributionLevel(Double distributionPercent, DateTime dtBeginDate, DateTime dtEndDate,
                    Double dStep, bool bSlidingHour, Double analysisRange)   // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                {
                    ///Toute la question est de savoir si l'occupation d'une zone passe par l'occupation du poste.
                    Double dEndDate = OverallTools.DataFunctions.MinuteDifference(dtBeginDate, dtEndDate);
                    ArrayList alQueueOccupation = new ArrayList();
                    bool bGroup = sDeskName.Contains("Group");
                    for (int i = 0; i < alArrivingTimes.Count; i++)
                    {
                        if (!lprsPassengers[i].CheckPaxIsValidForFilter(tfConditions))
                            continue;
                        Double dArriving = alArrivingTimes[i];
                        Double dDwellTime = 0;
                        if (!bGroup)
                        {
                            if (alWaitingTimesGroup[i] >= 0)
                            {
                                dArriving += alWaitingTimesGroup[i];
                                if (alWaitingTimesDesk[i] >= 0)
                                    dDwellTime += alWaitingTimesDesk[i];
                                if (alProcessTimes[i] >= 0)
                                    dDwellTime += alProcessTimes[i];
                            }
                            // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                            if (alDelayTimes[i] >= 0)
                                dDwellTime += alDelayTimes[i];
                            // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)                            

                            if (lprsPassengers[i].Stopped)
                            {
                                int lastResourceIndex = lprsPassengers[i].PaxTravel.Count;
                                if (lastResourceIndex > 0
                                    && lprsPassengers[i].PaxTravel[lastResourceIndex - 1].Desk.Equals(sDeskName))
                                {
                                    dDwellTime = -1;
                                }
                            }
                            // >> Task #9464 Bug - Analysis - Occupation Nb Pax out
                        }
                        else
                        {
                            if (alWaitingTimesGroup[i] >= 0)
                            {
                                dDwellTime += alWaitingTimesGroup[i];
                                if (alWaitingTimesDesk[i] >= 0)
                                    dDwellTime += alWaitingTimesDesk[i];
                                if (alProcessTimes[i] >= 0)
                                    dDwellTime += alProcessTimes[i];
                            }
                            // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                            if (alDelayTimes[i] >= 0)
                                dDwellTime += alDelayTimes[i];
                            // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)

                            // << Task #9464 Bug - Analysis - Occupation Nb Pax out
                            if (lprsPassengers[i].Stopped)
                            {
                                int lastResourceIndex = lprsPassengers[i].PaxTravel.Count;
                                if (lastResourceIndex > 0
                                    && lprsPassengers[i].PaxTravel[lastResourceIndex - 1].Desk.Equals(sDeskName))
                                {
                                    dDwellTime = -1;
                                }
                            }
                            // >> Task #9464 Bug - Analysis - Occupation Nb Pax out
                        }

                        alQueueOccupation.Add(new PointF((float)dArriving, (float)dDwellTime));
                    }

                    //use only the best x% passengers according to their dwell time
                    List<PointF> occupationList = new List<PointF>();
                    for (int i = 0; i < alQueueOccupation.Count; i++)
                    {
                        PointF p = (PointF)alQueueOccupation[i];
                        occupationList.Add(p);
                    }
                    ArrayList truncatedQueueOccupationList = ResultFunctions.getTruncatedListByPercent(occupationList, distributionPercent);

                    return ResultFunctions.CalcQueueOccupation(sDeskName + "_Queue_Occupation",
                        truncatedQueueOccupationList, dtBeginDate, dtEndDate, dStep, "Nb Pax", bSlidingHour, true,
                        analysisRange); // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation

                }
                // << Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                #endregion


                #region Fonction pour le calcul des répartitions des temps d'attente des passagers
                public DataTable calcPaxRepartition(Double dPas, int iNbClasses)
                {
                    DataTable dtResult;
                    bool bBaggageClaim = false;
                    if ((sDeskName.Contains("Baggage Claim")) && (!sDeskName.Contains(" Group")))
                    {
                        bBaggageClaim = true;
                        dtResult = ResultFunctions.BuildClassTable(sDeskName, dPas, iNbClasses, 0, "Minutes", new String[] { "TotalTime", "Process", "WaitingDesk", "WaitingGroup", "Remaining time at gate" });
                    }
                    else
                    {
                        dtResult = ResultFunctions.BuildClassTable(sDeskName, dPas, iNbClasses, 0, "Minutes", new String[] { "TotalTime", "Process", "WaitingDesk", "WaitingGroup" });
                    }
                    for (int i = 0; i < alArrivingTimes.Count; i++)
                    {
                        if (!lprsPassengers[i].CheckPaxIsValidForFilter(tfConditions))
                            continue;
                        int iCreneauTotal = ResultFunctions.DetermineClass(((Double)alProcessTimes[i] + (Double)alWaitingTimesDesk[i] + (Double)alWaitingTimesGroup[i]), dPas, iNbClasses);
                        int iCreneauProcess = ResultFunctions.DetermineClass((Double)alProcessTimes[i], dPas, iNbClasses);
                        int iCreneauWaitingDesk = ResultFunctions.DetermineClass((Double)alWaitingTimesDesk[i], dPas, iNbClasses);
                        int iCreneauWaitingGroup = ResultFunctions.DetermineClass((Double)alWaitingTimesGroup[i], dPas, iNbClasses);
                        if (bBaggageClaim)
                        {
                            int iCreneauRemaining = ResultFunctions.DetermineClass((Double)alWaitingTimesGroup[i], dPas, iNbClasses);
                            dtResult.Rows[iCreneauRemaining][5] = (int)dtResult.Rows[iCreneauRemaining][5] + 1;
                        }
                        dtResult.Rows[iCreneauTotal][1] = (int)dtResult.Rows[iCreneauTotal][1] + 1;
                        dtResult.Rows[iCreneauProcess][2] = (int)dtResult.Rows[iCreneauProcess][2] + 1;
                        dtResult.Rows[iCreneauWaitingDesk][3] = (int)dtResult.Rows[iCreneauWaitingDesk][3] + 1;
                        dtResult.Rows[iCreneauWaitingGroup][4] = (int)dtResult.Rows[iCreneauWaitingGroup][4] + 1;
                    }

                    ResultFunctions.GenerateRepartition(dtResult, 1, "TotalTime (%)", "TotalTime (Cumul)");
                    ResultFunctions.GenerateRepartition(dtResult, 2, "Process (%)", "Process (Cumul)");
                    ResultFunctions.GenerateRepartition(dtResult, 3, "WaitingDesk (%)", "WaitingDesk (Cumul)");
                    ResultFunctions.GenerateRepartition(dtResult, 4, "WaitingGroup (%)", "WaitingGroup (Cumul)");

                    return dtResult;
                }

                // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                public DataTable calcPaxRepartitionWithDelayTime(Double dPas, int iNbClasses)
                {
                    DataTable dtResult;
                    bool bBaggageClaim = false;
                    if ((sDeskName.Contains("Baggage Claim")) && (!sDeskName.Contains(" Group")))
                    {
                        bBaggageClaim = true;
                        dtResult = ResultFunctions.BuildClassTable(sDeskName, dPas, iNbClasses, 0, "Minutes", new String[] { "TotalTime", "Delay Time", "Process", "WaitingDesk", "WaitingGroup", "Remaining time at gate" });
                    }
                    else
                    {
                        dtResult = ResultFunctions.BuildClassTable(sDeskName, dPas, iNbClasses, 0, "Minutes", new String[] { "TotalTime", "Delay Time", "Process", "WaitingDesk", "WaitingGroup" });
                    }
                    for (int i = 0; i < alArrivingTimes.Count; i++)
                    {
                        if (!lprsPassengers[i].CheckPaxIsValidForFilter(tfConditions))
                            continue;

                        Double totalTime = (Double)alDelayTimes[i] + (Double)alWaitingTimesGroup[i]
                            + (Double)alWaitingTimesDesk[i] + (Double)alProcessTimes[i];

                        int iCreneauTotal = ResultFunctions.DetermineClass(totalTime, dPas, iNbClasses);
                        int iCreneauDelay = ResultFunctions.DetermineClass((Double)alDelayTimes[i], dPas, iNbClasses);
                        int iCreneauProcess = ResultFunctions.DetermineClass((Double)alProcessTimes[i], dPas, iNbClasses);
                        int iCreneauWaitingDesk = ResultFunctions.DetermineClass((Double)alWaitingTimesDesk[i], dPas, iNbClasses);
                        int iCreneauWaitingGroup = ResultFunctions.DetermineClass((Double)alWaitingTimesGroup[i], dPas, iNbClasses);
                        if (bBaggageClaim)
                        {
                            int iCreneauRemaining = ResultFunctions.DetermineClass((Double)alWaitingTimesGroup[i], dPas, iNbClasses);
                            dtResult.Rows[iCreneauRemaining][6] = (int)dtResult.Rows[iCreneauRemaining][6] + 1;
                        }
                        dtResult.Rows[iCreneauTotal][1] = (int)dtResult.Rows[iCreneauTotal][1] + 1;
                        dtResult.Rows[iCreneauDelay][2] = (int)dtResult.Rows[iCreneauDelay][2] + 1;
                        dtResult.Rows[iCreneauProcess][3] = (int)dtResult.Rows[iCreneauProcess][3] + 1;
                        dtResult.Rows[iCreneauWaitingDesk][4] = (int)dtResult.Rows[iCreneauWaitingDesk][4] + 1;
                        dtResult.Rows[iCreneauWaitingGroup][5] = (int)dtResult.Rows[iCreneauWaitingGroup][5] + 1;
                    }

                    ResultFunctions.GenerateRepartition(dtResult, 1, "TotalTime (%)", "TotalTime (Cumul)");
                    ResultFunctions.GenerateRepartition(dtResult, 2, "DelayTime (%)", "DelayTime (Cumul)");
                    ResultFunctions.GenerateRepartition(dtResult, 3, "Process (%)", "Process (Cumul)");
                    ResultFunctions.GenerateRepartition(dtResult, 4, "WaitingDesk (%)", "WaitingDesk (Cumul)");
                    ResultFunctions.GenerateRepartition(dtResult, 5, "WaitingGroup (%)", "WaitingGroup (Cumul)");

                    return dtResult;
                }
                // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                #endregion

                #region 2011.01.31 -> Fonction used to calculate the in system time for the passengers
                public DataTable calcPaxInDeskTime(DateTime dtStart, ArrayList alRemainingTimes)     // >> Task #10156 Pax2Sim - Statistic dev - Target
                {
                    DataTable dtResult = new DataTable(this.sDeskName + "_IST");
                    // << Task #8793 Pax2Sim - Statistics - _IST table modification                    
                    //dtResult.Columns.Add("Time", typeof(DateTime));
                    dtResult.Columns.Add(GlobalNames.IST_Column_EntryTime, typeof(DateTime));
                    dtResult.Columns.Add(GlobalNames.IST_Column_ExitTime, typeof(DateTime));
                    // >> Task #8793 Pax2Sim - Statistics - _IST table modification
                    dtResult.Columns.Add("PAX ID", typeof(String));
                    dtResult.Columns.Add("FPA " + GlobalNames.sFPD_A_Column_ID, typeof(String));
                    dtResult.Columns.Add("FPA " + GlobalNames.sFPD_A_Column_FlightN, typeof(String));
                    dtResult.Columns.Add("FPA " + GlobalNames.sFPD_A_Column_AirlineCode, typeof(String));
                    dtResult.Columns.Add("FPA " + GlobalNames.sFPD_A_Column_AirportCode, typeof(String));
                    dtResult.Columns.Add("FPA " + GlobalNames.sFPD_A_Column_FlightCategory, typeof(String));


                    dtResult.Columns.Add("FPA " + GlobalNames.sPaxPlan_FPAClass, typeof(String));
                    dtResult.Columns.Add("FPA " + GlobalNames.sFPD_A_Column_TerminalGate, typeof(Int32));
                    dtResult.Columns.Add("FPA " + GlobalNames.sFPA_Column_ArrivalGate, typeof(Int32));
                    dtResult.Columns.Add("FPA " + GlobalNames.sFPA_Column_TerminalReclaim, typeof(Int32));
                    dtResult.Columns.Add("FPA " + GlobalNames.sFPA_Column_ReclaimObject, typeof(Int32));

                    /*dtResult.Columns.Add("FPA "+ GlobalNames.sFPD_A_Column_AirportCode, typeof(String));
                    dtResult.Columns.Add("FPA "+ GlobalNames.sFPD_A_Column_FlightCategory, typeof(String));*/

                    dtResult.Columns.Add("FPD " + GlobalNames.sFPD_A_Column_ID, typeof(String));
                    dtResult.Columns.Add("FPD " + GlobalNames.sFPD_A_Column_FlightN, typeof(String));
                    dtResult.Columns.Add("FPD " + GlobalNames.sFPD_A_Column_AirlineCode, typeof(String));
                    dtResult.Columns.Add("FPD " + GlobalNames.sFPD_A_Column_AirportCode, typeof(String));
                    dtResult.Columns.Add("FPD " + GlobalNames.sFPD_A_Column_FlightCategory, typeof(String));

                    dtResult.Columns.Add("FPD " + GlobalNames.sPaxPlan_FPDClass, typeof(String));   // << Task #7949 Capacity Analysis - IST tables modification
                    dtResult.Columns.Add("FPD " + GlobalNames.sFPD_Column_TerminalCI, typeof(Int32));
                    dtResult.Columns.Add("FPD " + PAX2SIM.sCheckIn, typeof(Int32));
                    dtResult.Columns.Add("FPD " + GlobalNames.sFPD_A_Column_TerminalGate, typeof(Int32));
                    dtResult.Columns.Add("FPD " + GlobalNames.sFPD_Column_BoardingGate, typeof(Int32));

                    dtResult.Columns.Add("FPD " + GlobalNames.sPaxPlan_SelfCI, typeof(Boolean));
                    dtResult.Columns.Add("Passport Type", typeof(String));
                    dtResult.Columns.Add("Transfer Type", typeof(String));

                    dtResult.Columns.Add(GlobalNames.IST_TOTAL_TIME_COLUMN_NAME, typeof(Double));           // >> Task #10156 Pax2Sim - Statistic dev - Target
                    dtResult.Columns.Add(GlobalNames.IST_PROCESS_TIME_COLUMN_NAME, typeof(Double));         // >> Task #10156 Pax2Sim - Statistic dev - Target
                    dtResult.Columns.Add(GlobalNames.IST_WAITING_DESK_TIME_COLUMN_NAME, typeof(Double));    // >> Task #10156 Pax2Sim - Statistic dev - Target
                    dtResult.Columns.Add(GlobalNames.IST_WAITING_GROUP_TIME_COLUMN_NAME, typeof(Double));   // >> Task #10156 Pax2Sim - Statistic dev - Target
                    //dtResult.Columns.Add("Missed", typeof(Boolean));
                    //dtResult.Columns.Add("Stopped", typeof(Boolean));
                    //dtResult.Columns.Add("Lost", typeof(Boolean));
                    dtResult.Columns.Add("Status", typeof(String));
                    // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                    dtResult.Columns.Add(GlobalNames.sPaxPlan_DelayTime, typeof(Double));
                    // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                    dtResult.Columns.Add(GlobalNames.IST_REMAINING_TIME_COLUMN_NAME, typeof(Double));   // >> Task #10156 Pax2Sim - Statistic dev - Target



                    // << Task #7949 Capacity Analysis - IST tables modification
                    Dictionary<string, int> indexesForUserAttribColumnsDictionary = new Dictionary<string, int>();
                    if (userAttributesDistributionTables != null)
                    {
                        foreach (KeyValuePair<string, DataManagement.NormalTable> pair in userAttributesDistributionTables)
                        {
                            String userAttribute = pair.Key;
                            int columnIndex = dtResult.Columns.Count;
                            dtResult.Columns.Add(userAttribute, typeof(String));
                            if (columnIndex != -1)
                                indexesForUserAttribColumnsDictionary.Add(userAttribute, columnIndex);
                        }
                    }
                    // >> Task #7949 Capacity Analysis - IST tables modification

                    // << Task #7949 Capacity Analysis - IST tables modification                    
                    #region Column Indexes for the IST table
                    // << Task #8793 Pax2Sim - Statistics - _IST table modification
                    int index_EntryTime_Column = dtResult.Columns.IndexOf(GlobalNames.IST_Column_EntryTime);
                    int index_ExitTime_Column = dtResult.Columns.IndexOf(GlobalNames.IST_Column_ExitTime);
                    // >> Task #8793 Pax2Sim - Statistics - _IST table modification
                    int index_paxId_column = dtResult.Columns.IndexOf("PAX ID"); //added after the index change
                    int index_FPA_Column_ID = dtResult.Columns.IndexOf("FPA " + GlobalNames.sFPD_A_Column_ID);//1
                    int index_FPA_Column_FlightN = dtResult.Columns.IndexOf("FPA " + GlobalNames.sFPD_A_Column_FlightN);//2
                    int index_FPA_Column_AirlineCode = dtResult.Columns.IndexOf("FPA " + GlobalNames.sFPD_A_Column_AirlineCode);//3
                    int index_FPA_Column_AirportCode = dtResult.Columns.IndexOf("FPA " + GlobalNames.sFPD_A_Column_AirportCode);//4
                    int index_FPA_Column_FlightCategory = dtResult.Columns.IndexOf("FPA " + GlobalNames.sFPD_A_Column_FlightCategory);//5

                    int index_PaxPlan_FPAClass_Column = dtResult.Columns.IndexOf("FPA " + GlobalNames.sPaxPlan_FPAClass);//6
                    int index_FPA_Column_TerminalGate = dtResult.Columns.IndexOf("FPA " + GlobalNames.sFPD_A_Column_TerminalGate);//7
                    int index_FPA_Column_ArrivalGate = dtResult.Columns.IndexOf("FPA " + GlobalNames.sFPA_Column_ArrivalGate);//8
                    int index_FPA_Column_TerminalReclaim = dtResult.Columns.IndexOf("FPA " + GlobalNames.sFPA_Column_TerminalReclaim);//9
                    int index_FPA_Column_ReclaimObject = dtResult.Columns.IndexOf("FPA " + GlobalNames.sFPA_Column_ReclaimObject);//10

                    int index_FPD_Column_ID = dtResult.Columns.IndexOf("FPD " + GlobalNames.sFPD_A_Column_ID);//11
                    int index_FPD_Column_FlightN = dtResult.Columns.IndexOf("FPD " + GlobalNames.sFPD_A_Column_FlightN);//12
                    int index_FPD_Column_AirlineCode = dtResult.Columns.IndexOf("FPD " + GlobalNames.sFPD_A_Column_AirlineCode);//13
                    int index_FPD_Column_AirportCode = dtResult.Columns.IndexOf("FPD " + GlobalNames.sFPD_A_Column_AirportCode);//14
                    int index_FPD_Column_FlightCategory = dtResult.Columns.IndexOf("FPD " + GlobalNames.sFPD_A_Column_FlightCategory);//15

                    int index_FPD_Column_PaxPlan_FPDClass = dtResult.Columns.IndexOf("FPD " + GlobalNames.sPaxPlan_FPDClass);//16
                    int index_FPD_Column_TerminalCI = dtResult.Columns.IndexOf("FPD " + GlobalNames.sFPD_Column_TerminalCI);//17
                    int index_PAX2SIM_CheckIn_Column = dtResult.Columns.IndexOf("FPD " + PAX2SIM.sCheckIn);//18
                    int index_FPD_Column_TerminalGate = dtResult.Columns.IndexOf("FPD " + GlobalNames.sFPD_A_Column_TerminalGate);//19
                    int index_FPD_Column_BoardingGate = dtResult.Columns.IndexOf("FPD " + GlobalNames.sFPD_Column_BoardingGate);//20
                    int index_PaxPlan_SelfCI_Column = dtResult.Columns.IndexOf("FPD " + GlobalNames.sPaxPlan_SelfCI);//21
                    int index_PassportType_Column = dtResult.Columns.IndexOf("Passport Type");//22
                    int index_TransferType_Column = dtResult.Columns.IndexOf("Transfer Type");//23
                    int index_TotalTime_Column = dtResult.Columns.IndexOf(GlobalNames.IST_TOTAL_TIME_COLUMN_NAME);//24                  // >> Task #10156 Pax2Sim - Statistic dev - Target
                    int index_ProcessTime_Column = dtResult.Columns.IndexOf(GlobalNames.IST_PROCESS_TIME_COLUMN_NAME);//25              // >> Task #10156 Pax2Sim - Statistic dev - Target
                    int index_WaitingDeskTime_Column = dtResult.Columns.IndexOf(GlobalNames.IST_WAITING_DESK_TIME_COLUMN_NAME);//26     // >> Task #10156 Pax2Sim - Statistic dev - Target
                    int index_WaitingGroupTime_Column = dtResult.Columns.IndexOf(GlobalNames.IST_WAITING_GROUP_TIME_COLUMN_NAME);//27   // >> Task #10156 Pax2Sim - Statistic dev - Target
                    int index_Status_Column = dtResult.Columns.IndexOf("Status");//28
                    // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)                    
                    int index_DelayTime_Column = dtResult.Columns.IndexOf(GlobalNames.sPaxPlan_DelayTime);//28
                    // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                    int index_RemainingTime_Column = dtResult.Columns.IndexOf(GlobalNames.IST_REMAINING_TIME_COLUMN_NAME);  // >> Task #10156 Pax2Sim - Statistic dev - Target

                    #endregion
                    // >> Task #7949 Capacity Analysis - IST tables modification

                    for (int i = 0; i < alArrivingTimes.Count; i++)
                    {
                        if (!lprsPassengers[i].CheckPaxIsValidForFilter(tfConditions))
                            continue;
                        DataRow drRow = dtResult.NewRow();
                        // << Task #7949 Capacity Analysis - IST tables modification
                        drRow[index_EntryTime_Column] = dtStart.AddMinutes((Double)alArrivingTimes[i]);  // << Task #8793 Pax2Sim - Statistics - _IST table modification
                        drRow[index_paxId_column] = lprsPassengers[i].IdPax.ToString(); //passenger id
                        if (lprsPassengers[i].FPAInformations != null)
                        {
                            drRow[index_FPA_Column_ID] = lprsPassengers[i].FPAInformations.iIdFlight.ToString();
                            drRow[index_FPA_Column_FlightN] = lprsPassengers[i].FPAInformations.sFlightName;
                            drRow[index_FPA_Column_AirlineCode] = lprsPassengers[i].FPAInformations.sAirline.ToString();
                            drRow[index_FPA_Column_AirportCode] = lprsPassengers[i].FPAInformations.sAirport.ToString();
                            drRow[index_FPA_Column_FlightCategory] = lprsPassengers[i].FPAInformations.sFlightCategory.ToString();
                        }
                        else
                        {
                            drRow[index_FPA_Column_ID] = "";
                            drRow[index_FPA_Column_FlightN] = "";
                            drRow[index_FPA_Column_AirlineCode] = "";
                            drRow[index_FPA_Column_AirportCode] = "";
                            drRow[index_FPA_Column_FlightCategory] = "";
                        }
                        if (lprsPassengers[i].Informations != null)
                        {
                            drRow[index_PaxPlan_FPAClass_Column] = lprsPassengers[i].Informations.FPA_Class.ToString();
                            drRow[index_FPA_Column_TerminalGate] = lprsPassengers[i].getTerminalArrivalGate;
                            drRow[index_FPA_Column_ArrivalGate] = lprsPassengers[i].getArrivalgGateNumber;
                            drRow[index_FPA_Column_TerminalReclaim] = lprsPassengers[i].getTerminalReclaim;
                            drRow[index_FPA_Column_ReclaimObject] = lprsPassengers[i].getReclaim;

                            drRow[index_FPD_Column_PaxPlan_FPDClass] = lprsPassengers[i].Informations.FPD_Class.ToString();
                            drRow[index_FPD_Column_TerminalCI] = lprsPassengers[i].getTerminalCheckIn;
                            drRow[index_PAX2SIM_CheckIn_Column] = lprsPassengers[i].getCheckIn;
                            drRow[index_FPD_Column_TerminalGate] = lprsPassengers[i].getTerminalBoardingGate;
                            drRow[index_FPD_Column_BoardingGate] = lprsPassengers[i].getBoardingGateNumber;
                            drRow[index_PaxPlan_SelfCI_Column] = lprsPassengers[i].Informations.SelfCheckIn;

                            if ((lprsPassengers[i].Informations.Passport) == 1)
                            {
                                drRow[index_PassportType_Column] = "Local";
                            }
                            else
                            {
                                drRow[index_PassportType_Column] = "Not Local";
                            }
                            if ((lprsPassengers[i].Informations.Tranfer) == 1)
                            {
                                drRow[index_TransferType_Column] = "Transfer";
                            }
                            else if ((lprsPassengers[i].Informations.Tranfer) == 2)
                            {
                                drRow[index_TransferType_Column] = "ReCheck";
                            }
                            else if ((lprsPassengers[i].Informations.Tranfer) == 10)
                            {
                                drRow[index_TransferType_Column] = "Transfer Desk";
                            }
                            else
                            {
                                drRow[index_TransferType_Column] = "";
                            }
                        }
                        else
                        {
                            drRow[index_PaxPlan_FPAClass_Column] = "";
                            drRow[index_FPA_Column_TerminalGate] = 0;
                            drRow[index_FPA_Column_ArrivalGate] = 0;
                            drRow[index_FPA_Column_TerminalReclaim] = 0;
                            drRow[index_FPA_Column_ReclaimObject] = 0;

                            drRow[index_FPD_Column_PaxPlan_FPDClass] = "";
                            drRow[index_FPD_Column_TerminalCI] = 0;
                            drRow[index_PAX2SIM_CheckIn_Column] = 0;
                            drRow[index_FPD_Column_TerminalGate] = 0;
                            drRow[index_FPD_Column_BoardingGate] = 0;
                            drRow[index_PaxPlan_SelfCI_Column] = false;
                            drRow[index_PassportType_Column] = "";
                            drRow[index_TransferType_Column] = "";
                        }


                        if (lprsPassengers[i].FPDInformations != null)
                        {
                            drRow[index_FPD_Column_ID] = lprsPassengers[i].FPDInformations.iIdFlight.ToString();
                            drRow[index_FPD_Column_FlightN] = lprsPassengers[i].FPDInformations.sFlightName;
                            drRow[index_FPD_Column_AirlineCode] = lprsPassengers[i].FPDInformations.sAirline.ToString();
                            drRow[index_FPD_Column_AirportCode] = lprsPassengers[i].FPDInformations.sAirport.ToString();
                            drRow[index_FPD_Column_FlightCategory] = lprsPassengers[i].FPDInformations.sFlightCategory.ToString();
                        }
                        else
                        {
                            drRow[index_FPD_Column_ID] = "";
                            drRow[index_FPD_Column_FlightN] = "";
                            drRow[index_FPD_Column_AirlineCode] = "";
                            drRow[index_FPD_Column_AirportCode] = "";
                            drRow[index_FPD_Column_FlightCategory] = "";
                        }
                        Double dWaitingGroup = (Double)alWaitingTimesGroup[i];
                        Double dWaitingDesk = (Double)alWaitingTimesDesk[i];
                        Double dProcessTime = (Double)alProcessTimes[i];

                        if (dWaitingDesk < 0)
                            drRow[index_TotalTime_Column] = Math.Round(dWaitingGroup, 2);
                        else if (dProcessTime < 0)
                            drRow[index_TotalTime_Column] = Math.Round(dWaitingGroup + dWaitingDesk, 2);
                        else
                            drRow[index_TotalTime_Column] = Math.Round(dWaitingGroup + dWaitingDesk + dProcessTime, 2);
                        drRow[index_ProcessTime_Column] = Math.Round(dProcessTime, 2);
                        drRow[index_WaitingDeskTime_Column] = Math.Round(dWaitingDesk, 2);
                        drRow[index_WaitingGroupTime_Column] = Math.Round(dWaitingGroup, 2);

                        // << Task #8793 Pax2Sim - Statistics - _IST table modification
                        Double exitTime = (Double)alArrivingTimes[i];
                        Double delay = (Double)alDelayTimes[i];

                        if (exitTime >= 0)
                        {
                            if (dWaitingDesk < 0)
                                exitTime += dWaitingGroup;
                            else if (dProcessTime < 0)
                                exitTime += dWaitingGroup + dWaitingDesk;
                            else
                                exitTime += dWaitingGroup + dWaitingDesk + dProcessTime;
                            if (delay > 0)
                                exitTime += delay;
                        }
                        if (exitTime >= 0)
                            drRow[index_ExitTime_Column] = dtStart.AddMinutes(Math.Round(exitTime, 2));
                        // >> Task #8793 Pax2Sim - Statistics - _IST table modification

                        // >> Task #10156 Pax2Sim - Statistic dev - Target
                        if (i < alRemainingTimes.Count)
                        {
                            Double remainingTime = (Double)alRemainingTimes[i];
                            drRow[index_RemainingTime_Column] = Math.Round(remainingTime, 2);
                        }
                        else
                        {
                            if (alRemainingTimes.Count == 0)
                                drRow[index_RemainingTime_Column] = 0;
                        }
                        // << Task #10156 Pax2Sim - Statistic dev - Target

                        drRow[index_Status_Column] = lprsPassengers[i].getStatus(this.sDeskName);

                        // << Task #7949 Capacity Analysis - IST tables modification
                        if (userAttributesDistributionTables != null)
                        {
                            foreach (KeyValuePair<string, DataManagement.NormalTable> pair in userAttributesDistributionTables)
                            {
                                String distributionTableName = pair.Key;
                                int indexColumnPaxPlan = -1;

                                if (indexesForUserAttribColumnsDictionary.TryGetValue(distributionTableName, out indexColumnPaxPlan))
                                {
                                    String userAttributeValue = "";

                                    if (lprsPassengers[i].paxUserAttributesDictionary != null
                                        && lprsPassengers[i].paxUserAttributesDictionary.TryGetValue(distributionTableName, out userAttributeValue)
                                        && indexColumnPaxPlan != -1)
                                    {
                                        drRow[indexColumnPaxPlan] = userAttributeValue;
                                    }
                                }
                            }
                        }
                        // >> Task #7949 Capacity Analysis - IST tables modification

                        // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                        Double delayTime = (Double)alDelayTimes[i];
                        if (index_DelayTime_Column != -1)
                            drRow[index_DelayTime_Column] = Math.Round(delayTime, 2);
                        // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)

                        dtResult.Rows.Add(drRow);
                    }
                    // >> Task #7949 Capacity Analysis - IST tables modification
                    dtResult.AcceptChanges();

                    return dtResult;
                }
                #endregion

                #region Fonction pour le calcul de l'occupation du bureau.
                public DataTable DeskOccupation(Double dPas)
                {
                    //La définition de la table
                    DataTable dtResult = new DataTable(sDeskName);
                    dtResult.Columns.Add("Minutes", typeof(Double));
                    dtResult.Columns.Add("Occupation", typeof(Double));
                    dtResult.Columns.Add("OpeningTime", typeof(Double));

                    //Double dPas = dPasUtilisation;// 15;//minutes
                    int i;
                    ArrayList alStartResults = new ArrayList();
                    ArrayList alEndResults = new ArrayList();
                    int iIndexEnd;
                    int iIndexStart;
                    //On parcours dans un premier temps tous les Pax de ce desk et on ressort toutes les périodes d'occupation
                    for (i = 0; i < alArrivingTimes.Count; i++)
                    {

                        if (!lprsPassengers[i].CheckPaxIsValidForFilter(tfConditions))
                            continue;
                        if ((Double)alProcessTimes[i] < 0)
                            continue;
                        if ((Double)alWaitingTimesGroup[i] < 0)
                            continue;
                        if ((Double)alWaitingTimesDesk[i] < 0)
                            continue;

                        //L'heure de début d'occupation du poste pour ce pax
                        Double StartProcess = (Double)alArrivingTimes[i] + (Double)alWaitingTimesGroup[i] + (Double)alWaitingTimesDesk[i];
                        //L'heure de fin d'occupation du poste pour ce pax.
                        Double EndProcess = StartProcess + (Double)alProcessTimes[i];

                        //On recherche dans la table des débuts de process si la fin du process courant correspond au début d'un process
                        iIndexStart = alStartResults.IndexOf(EndProcess);
                        //Idem pour la table des fin de process avec le début du process courant
                        iIndexEnd = alEndResults.IndexOf(StartProcess);


                        if ((iIndexEnd < 0) && (iIndexStart < 0))
                        {
                            //Si aucun process ne correspond, on ajoute un nouveau process.
                            alStartResults.Add(StartProcess);
                            alEndResults.Add(EndProcess);
                        }
                        else if ((iIndexEnd >= 0) && (iIndexStart < 0))
                        {
                            //Si l'un des deux process correspond à quelque chose...
                            alEndResults[iIndexEnd] = EndProcess;
                        }
                        else if ((iIndexEnd < 0) && (iIndexStart >= 0))
                        {
                            //Si l'un des deux process correspond à quelque chose...
                            alStartResults[iIndexStart] = StartProcess;
                        }
                        else
                        {
                            //Si le process coincide avec deux process existant, on en supprime un.
                            alEndResults[iIndexEnd] = alEndResults[iIndexStart];
                            alEndResults.RemoveAt(iIndexStart);
                            alStartResults.RemoveAt(iIndexStart);
                        }
                    }
                    int j;
                    for (i = 0; i < alStartResults.Count; i++)
                    {
                        int iIndexDebut = (int)(((Double)alStartResults[i]) / dPas);
                        int iIndexFin = (int)(((Double)alEndResults[i]) / dPas);
                        /*if(((Double)iIndexFin !=(((Double)alEndResults[i]) / dPas)))
                            iIndexFin++;*/
                        while (dtResult.Rows.Count <= iIndexFin)
                        {
                            DataRow newLigne = dtResult.NewRow();
                            newLigne[0] = ((dtResult.Rows.Count + 1) * dPas);
                            newLigne[1] = 0;
                            newLigne[2] = 0;
                            dtResult.Rows.Add(newLigne);
                        }
                        for (j = iIndexDebut; j <= iIndexFin; j++)
                        {
                            if (j == iIndexDebut)
                            {
                                if (j == iIndexFin)
                                {
                                    dtResult.Rows[j][1] = (Double)dtResult.Rows[j][1] + ((Double)alEndResults[i] - (Double)alStartResults[i]);
                                }
                                else
                                {
                                    dtResult.Rows[j][1] = (Double)dtResult.Rows[j][1] + (Double)dtResult.Rows[j][0] - (Double)alStartResults[i];
                                }
                            }
                            else if (j == iIndexFin)
                            {
                                dtResult.Rows[j][1] = (Double)dtResult.Rows[j][1] + (Double)alEndResults[i] - ((Double)dtResult.Rows[j][0] - dPas);
                            }
                            else
                            {
                                dtResult.Rows[j][1] = dPas;
                            }
                        }
                    }
                    //Pour un calcul sur le temps réel d'ouverture, décommenter les / * --R*/
                    /*--R  CalcOpeningTime(sDeskName, dtResult, dPas, AllocationTable, iColumnIndex, iIndexDesk, dtHeureDebutSimulation);*/
                    DataTable dtResult2 = new DataTable(sDeskName);
                    dtResult2.Columns.Add("Start", typeof(DateTime));
                    dtResult2.Columns.Add("End", typeof(DateTime));
                    dtResult2.Columns.Add(GlobalNames.DESK_UTILIZATION_UTILIZATION_PERCENT_COLUMN_NAME, typeof(Double));     //.Add("% Utilization", typeof(Double));  // << Task #8137 Pax2Sim - Columns Names correction    // >> Task #10440 Pax2Sim - Pax analysis - missing KPIs part 1
                    foreach (DataRow Ligne in dtResult.Rows)
                    {
                        DataRow NewLigne = dtResult2.NewRow();
                        NewLigne[0] = dtHeureDebutSimulation.AddMinutes((Double)Ligne[0] - dPas);
                        NewLigne[1] = dtHeureDebutSimulation.AddMinutes((Double)Ligne[0]);
                        if ((((Double)Ligne[1]) != 0) /*--R  &&
                            (((Double)Ligne[2]) != 0)*/
                                                       )
                        {
                            /*--R  NewLigne[2] = Math.Round(((Double)Ligne[1]) / ((Double)Ligne[2]), 4) * 100;*/
                            NewLigne[2] = Math.Round((((Double)Ligne[1]) / dPas) * 100, 2);
                        }
                        else
                        {
                            NewLigne[2] = 0;
                        }
                        dtResult2.Rows.Add(NewLigne);
                    }
                    return dtResult2;
                }

                // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                public DataTable getUtilizationByDistributionLevel(Double dPas, Double distributionPercent)
                {
                    //La définition de la table
                    DataTable dtResult = new DataTable(sDeskName);
                    dtResult.Columns.Add("Minutes", typeof(Double));
                    dtResult.Columns.Add("Occupation", typeof(Double));
                    dtResult.Columns.Add("OpeningTime", typeof(Double));

                    //Double dPas = dPasUtilisation;// 15;//minutes
                    int i;
                    ArrayList alStartResults = new ArrayList();
                    ArrayList alEndResults = new ArrayList();
                    int iIndexEnd;
                    int iIndexStart;
                    //k: the index from the alProcessTimes list, v: the process time
                    Dictionary<int, double> paxProcessTimesDictionary = new Dictionary<int, double>();
                    List<double> dummyList = new List<double>();

                    //sort the process times using a dummy list so that the indexes are not changed in the alProcessTimes list
                    for (int k = 0; k < alProcessTimes.Count; k++)
                    {
                        paxProcessTimesDictionary.Add(k, (double)alProcessTimes[k]);
                        dummyList.Add((double)alProcessTimes[k]);
                    }
                    dummyList.Sort();
                    //obtain only the needed times according to the distribution level
                    List<double> truncatedDummyList = ResultFunctions.getTruncatedListByPercent(dummyList, distributionPercent);
                    /*
                    for (int h = 0; h < 7; h++)
                    {
                        if (h < dummyList.Count)
                            truncatedDummyList.Add((double)dummyList[h]);
                    }
                     */
                    //search in the dictionary for the indexes that correspond to the needed times
                    ArrayList neededIndexes = new ArrayList();
                    int nbOfNeededIndexes = truncatedDummyList.Count;
                    foreach (KeyValuePair<int, double> pair in paxProcessTimesDictionary)
                    {
                        if (truncatedDummyList.Contains(pair.Value))
                        {
                            neededIndexes.Add(pair.Key);
                            nbOfNeededIndexes--;
                        }
                        if (nbOfNeededIndexes == 0)
                            break;
                    }

                    //On parcours dans un premier temps tous les Pax de ce desk et on ressort toutes les périodes d'occupation
                    for (i = 0; i < alArrivingTimes.Count; i++)
                    {
                        //if we don't need this pax's times we skip it(the pax was outside the x% level)
                        if (!neededIndexes.Contains(i))
                            continue;

                        if (!lprsPassengers[i].CheckPaxIsValidForFilter(tfConditions))
                            continue;
                        if ((Double)alProcessTimes[i] < 0)
                            continue;
                        if ((Double)alWaitingTimesGroup[i] < 0)
                            continue;
                        if ((Double)alWaitingTimesDesk[i] < 0)
                            continue;

                        //L'heure de début d'occupation du poste pour ce pax
                        Double StartProcess = (Double)alArrivingTimes[i] + (Double)alWaitingTimesGroup[i] + (Double)alWaitingTimesDesk[i];
                        //L'heure de fin d'occupation du poste pour ce pax.
                        Double EndProcess = StartProcess + (Double)alProcessTimes[i];

                        //paxTimesList.Add(new PointF((double)alArrivingTimes[i], (double)alProcessTimes[i]));

                        //On recherche dans la table des débuts de process si la fin du process courant correspond au début d'un process
                        iIndexStart = alStartResults.IndexOf(EndProcess);
                        //Idem pour la table des fin de process avec le début du process courant
                        iIndexEnd = alEndResults.IndexOf(StartProcess);

                        if ((iIndexEnd < 0) && (iIndexStart < 0))
                        {
                            //Si aucun process ne correspond, on ajoute un nouveau process.
                            alStartResults.Add(StartProcess);
                            alEndResults.Add(EndProcess);
                        }
                        else if ((iIndexEnd >= 0) && (iIndexStart < 0))
                        {
                            //Si l'un des deux process correspond à quelque chose...
                            alEndResults[iIndexEnd] = EndProcess;
                        }
                        else if ((iIndexEnd < 0) && (iIndexStart >= 0))
                        {
                            //Si l'un des deux process correspond à quelque chose...
                            alStartResults[iIndexStart] = StartProcess;
                        }
                        else
                        {
                            //Si le process coincide avec deux process existant, on en supprime un.
                            alEndResults[iIndexEnd] = alEndResults[iIndexStart];
                            alEndResults.RemoveAt(iIndexStart);
                            alStartResults.RemoveAt(iIndexStart);
                        }
                    }
                    int j;
                    for (i = 0; i < alStartResults.Count; i++)
                    {
                        int iIndexDebut = (int)(((Double)alStartResults[i]) / dPas);
                        int iIndexFin = (int)(((Double)alEndResults[i]) / dPas);
                        /*if(((Double)iIndexFin !=(((Double)alEndResults[i]) / dPas)))
                            iIndexFin++;*/
                        while (dtResult.Rows.Count <= iIndexFin)
                        {
                            DataRow newLigne = dtResult.NewRow();
                            newLigne[0] = ((dtResult.Rows.Count + 1) * dPas);
                            newLigne[1] = 0;
                            newLigne[2] = 0;
                            dtResult.Rows.Add(newLigne);
                        }
                        for (j = iIndexDebut; j <= iIndexFin; j++)
                        {
                            if (j == iIndexDebut)
                            {
                                if (j == iIndexFin)
                                {
                                    dtResult.Rows[j][1] = (Double)dtResult.Rows[j][1] + ((Double)alEndResults[i] - (Double)alStartResults[i]);
                                }
                                else
                                {
                                    dtResult.Rows[j][1] = (Double)dtResult.Rows[j][1] + (Double)dtResult.Rows[j][0] - (Double)alStartResults[i];
                                }
                            }
                            else if (j == iIndexFin)
                            {
                                dtResult.Rows[j][1] = (Double)dtResult.Rows[j][1] + (Double)alEndResults[i] - ((Double)dtResult.Rows[j][0] - dPas);
                            }
                            else
                            {
                                dtResult.Rows[j][1] = dPas;
                            }
                        }
                    }
                    //Pour un calcul sur le temps réel d'ouverture, décommenter les / * --R*/
                    /*--R  CalcOpeningTime(sDeskName, dtResult, dPas, AllocationTable, iColumnIndex, iIndexDesk, dtHeureDebutSimulation);*/
                    DataTable dtResult2 = new DataTable(sDeskName);
                    dtResult2.Columns.Add("Start", typeof(DateTime));
                    dtResult2.Columns.Add("End", typeof(DateTime));
                    dtResult2.Columns.Add(GlobalNames.DESK_UTILIZATION_UTILIZATION_PERCENT_COLUMN_NAME, typeof(Double));     //.Add("% Utilization", typeof(Double));  // << Task #8137 Pax2Sim - Columns Names correction    // >> Task #10440 Pax2Sim - Pax analysis - missing KPIs part 1
                    foreach (DataRow Ligne in dtResult.Rows)
                    {
                        DataRow NewLigne = dtResult2.NewRow();
                        NewLigne[0] = dtHeureDebutSimulation.AddMinutes((Double)Ligne[0] - dPas);
                        NewLigne[1] = dtHeureDebutSimulation.AddMinutes((Double)Ligne[0]);
                        if ((((Double)Ligne[1]) != 0) /*--R  &&
                            (((Double)Ligne[2]) != 0)*/
                                                       )
                        {
                            /*--R  NewLigne[2] = Math.Round(((Double)Ligne[1]) / ((Double)Ligne[2]), 4) * 100;*/
                            NewLigne[2] = Math.Round((((Double)Ligne[1]) / dPas) * 100, 2);
                        }
                        else
                        {
                            NewLigne[2] = 0;
                        }
                        dtResult2.Rows.Add(NewLigne);
                    }
                    return dtResult2;
                }
                // << Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                #endregion

                #region Fonction pour le calcul des temps d'ouverture des postes
                public static void CalcOpeningTime(String sDesk, DataTable table, Double dPas, DataTable AllocationTable, int iColumn, int iIndex, DateTime dtAnalyseTime)
                {
                    if (AllocationTable == null)
                        return;
                    if (table == null)
                        return;
                    int[] tiDesk = DataFunctions.AnalyzeGroupName(sDesk);
                    if (tiDesk == null)
                        return;
                    if (AllocationTable.Columns.Count < iColumn)
                        return;
                    int j;

                    bool bPassport = (AllocationTable.Columns[iColumn].DataType == typeof(String));
                    if (AllocationTable.Rows.Count == 1)
                    {
                        if (iIndex != -1)
                            return;
                        //Nous sommes dans le cas où l'allocation est calculée et non pas fixée par l'utilisateur.
                        //Donc une colonne par groupe.
                        if (AllocationTable.Rows[0][iColumn].ToString().Length != 0)
                        {
                            foreach (DataRow ligne in table.Rows)
                            {
                                ligne[2] = dPas;
                            }
                        }
                        return;
                    }

                    //On détermine en premier lieu le pas contenu dans la table
                    Double dPasAllocation = DataFunctions.MinuteDifference((DateTime)AllocationTable.Rows[0][0], (DateTime)AllocationTable.Rows[1][0]);
                    double dDifferenceStart = DataFunctions.MinuteDifference((DateTime)AllocationTable.Rows[0][0], dtAnalyseTime);
                    for (int i = 0; i < AllocationTable.Rows.Count; i++)
                    {
                        String sValue = AllocationTable.Rows[i][iColumn].ToString();
                        if (sValue.Length == 0)
                            continue;

                        if (DataFunctions.MinuteDifference((DateTime)AllocationTable.Rows[i][0], dtAnalyseTime) >= dPas)
                            continue;
                        if (iIndex != -1)
                        {
                            int iNbBureaux = 0;
                            if (!bPassport)
                            {
                                iNbBureaux = (int)(Double)AllocationTable.Rows[i][iColumn];
                            }
                            else
                            {
                                String[] tsValue = sValue.Split(',');
                                if (tsValue.Length != 2)
                                    continue;
                                if (!Int32.TryParse(tsValue[1], out iNbBureaux))
                                    continue;
                            }
                            if (iNbBureaux < iIndex)
                                continue;

                        }

                        int iIndexDebut = (int)((dPasAllocation * i - dDifferenceStart) / dPas);
                        int iIndexFin = (int)((dPasAllocation * (i + 1) - dDifferenceStart) / dPas);
                        while (table.Rows.Count <= iIndexFin)
                        {
                            DataRow newLigne = table.NewRow();
                            newLigne[0] = ((table.Rows.Count + 1) * dPas);
                            newLigne[1] = 0;
                            newLigne[2] = 0;
                            table.Rows.Add(newLigne);
                        }
                        for (j = iIndexDebut; j <= iIndexFin; j++)
                        {
                            if (j == iIndexDebut)
                            {
                                if (j == iIndexFin)
                                {
                                    if ((dPasAllocation * i - dDifferenceStart) > 0)
                                        table.Rows[j][2] = (Double)table.Rows[j][2] + (dPasAllocation * (i + 1) - dDifferenceStart) - (dPasAllocation * i - dDifferenceStart);
                                    else
                                        table.Rows[j][2] = (Double)table.Rows[j][2] + (dPasAllocation * (i + 1) - dDifferenceStart);
                                }
                                else
                                {
                                    table.Rows[j][2] = (Double)table.Rows[j][2] + (Double)table.Rows[j][0] - (dPasAllocation * i - dDifferenceStart);
                                }
                            }
                            else if (j == iIndexFin)
                            {
                                // (Double)alEndResults[i] - ((Double)dtResult.Rows[j][0] - dPas);
                                table.Rows[j][2] = (Double)table.Rows[j][2] + (dPasAllocation * (i + 1) - dDifferenceStart) - ((Double)table.Rows[j][0] - dPas);
                            }
                            else
                            {
                                table.Rows[j][2] = dPas;
                            }
                        }
                    }
                }
                #endregion
            }
            #endregion

            #region La classe publique qui regroupe les informations sur les postes.
            /// <summary>
            /// Class that will be used to compile the different statistics of a (Desk / Group / Level / Terminal / Airport) and will
            /// generate a summary table with these informations.
            /// </summary>
            public class DeskReport
            {
                #region Les variables de la classe.
                String sDeskname;
                public String DeskName
                {
                    get
                    {
                        return sDeskname;
                    }
                }

                int iPaxNumber;
                public int PaxNumber
                {
                    get
                    {
                        return iPaxNumber;
                    }
                }

                int iProcessedPax;
                public int ProcessedPax { get { return iProcessedPax; } set { iProcessedPax = value; } }
                int iPaxTransfer;
                public int PaxTransfer
                {
                    get
                    {
                        return iPaxTransfer;
                    }
                }
                int iPaxMissed;
                public int PaxMissed
                {
                    get
                    {
                        return iPaxMissed;
                    }
                }
                int iPaxStopped;
                public int PaxStopped
                {
                    get
                    {
                        return iPaxStopped;
                    }
                }
                int iPaxLost;
                public int PaxLost
                {
                    get
                    {
                        return iPaxLost;
                    }
                }

                Double dMinWaiting;
                public Double MinWaiting
                {
                    get
                    {
                        return Math.Round(dMinWaiting, 2);
                    }
                }
                Double dMaxWaiting;
                public Double MaxWaiting
                {
                    get
                    {
                        return Math.Round(dMaxWaiting, 2);
                    }
                }
                Double dMeanWaiting;
                Double dMeanWaitingTmp;
                public Double MeanWaiting
                {
                    get
                    {
                        return Math.Round(dMeanWaiting, 2);
                    }
                }


                Double dMinWaitingGroup;
                public Double MinWaitingGroup
                {
                    get
                    {
                        return Math.Round(dMinWaitingGroup, 2);
                    }
                }
                Double dMaxWaitingGroup;
                public Double MaxWaitingGroup
                {
                    get
                    {
                        return Math.Round(dMaxWaitingGroup, 2);
                    }
                }
                Double dMeanWaitingGroup;
                public Double MeanWaitingGroup
                {
                    get
                    {
                        return Math.Round(dMeanWaitingGroup, 2);
                    }
                }


                Double dMinWaitingDesk;
                public Double MinWaitingDesk
                {
                    get
                    {
                        return Math.Round(dMinWaitingDesk, 2);
                    }
                }
                Double dMaxWaitingDesk;
                public Double MaxWaitingDesk
                {
                    get
                    {
                        return Math.Round(dMaxWaitingDesk, 2);
                    }
                }
                Double dMeanWaitingDesk;
                public Double MeanWaitingDesk
                {
                    get
                    {
                        return Math.Round(dMeanWaitingDesk, 2);
                    }
                }


                Double dMinProcess;
                public Double MinProcess
                {
                    get
                    {
                        return Math.Round(dMinProcess, 2);
                    }
                }
                Double dMaxProcess;
                public Double MaxProcess
                {
                    get
                    {
                        return Math.Round(dMaxProcess, 2);
                    }
                }
                Double dMeanProcess;
                public Double MeanProcess
                {
                    get
                    {
                        return Math.Round(dMeanProcess, 2);
                    }
                }


                Double dMinRemaining;
                public Double MinRemaining
                {
                    get
                    {
                        return Math.Round(dMinRemaining, 2);
                    }
                }
                Double dMaxRemaining;
                public Double MaxRemaining
                {
                    get
                    {
                        return Math.Round(dMaxRemaining, 2);
                    }
                }
                Double dMeanRemaining;
                public Double MeanRemaining
                {
                    get
                    {
                        return Math.Round(dMeanRemaining, 2);
                    }
                }


                Double dMinDwellTimeDesk;
                public Double MinDwellDesk
                {
                    get
                    {
                        return Math.Round(dMinDwellTimeDesk, 2);
                    }
                    set { dMinDwellTimeDesk = value; }
                }
                Double dMaxDwellDesk;
                public Double MaxDwellDesk
                {
                    get
                    {
                        return Math.Round(dMaxDwellDesk, 2);
                    }
                    set { dMaxDwellDesk = value; }
                }
                Double dMeanDwellDesk;
                public Double MeanDwellDesk
                {
                    get
                    {
                        return Math.Round(dMeanDwellDesk, 2);
                    }
                    set { dMeanDwellDesk = value; }
                }


                Double dMinQueueOccupation;
                public Double MinQueueOccupation
                {
                    get
                    {
                        return Math.Round(dMinQueueOccupation, 2);
                    }
                }
                Double dMaxQueueOccupation;
                public Double MaxQueueOccupation
                {
                    get
                    {
                        return Math.Round(dMaxQueueOccupation, 2);
                    }
                }

                int iNumberMean;
                Double dMeanQueueOccupation;
                public Double MeanQueueOccupation
                {
                    get
                    {
                        if (iNumberMean != 0)
                            return Math.Round(dMeanQueueOccupation / iNumberMean, 2);
                        return Math.Round(dMeanQueueOccupation, 2);
                    }
                }

                // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                Double totalOccupationPaxIn_;
                public Double totalOccupationPaxIn
                {
                    get { return Math.Round(totalOccupationPaxIn_, 2); }
                }
                Double minOccupationPaxIn_;
                public Double minOccupationPaxIn
                {
                    get { return Math.Round(minOccupationPaxIn_, 2); }
                }
                Double avgOccupationPaxIn_;
                public Double avgOccupationPaxIn
                {
                    get { return Math.Round(avgOccupationPaxIn_, 2); }
                }
                Double maxOccupationPaxIn_;
                public Double maxOccupationPaxIn
                {
                    get { return Math.Round(maxOccupationPaxIn_, 2); }
                }

                Double totalOccupationPaxOut_;
                public Double totalOccupationPaxOut
                {
                    get { return Math.Round(totalOccupationPaxOut_, 2); }
                }
                Double maxOccupationPaxOut_;
                public Double maxOccupationPaxOut
                {
                    get { return Math.Round(maxOccupationPaxOut_, 2); }
                }
                Double avgOccupationPaxOut_;
                public Double avgOccupationPaxOut
                {
                    get { return Math.Round(avgOccupationPaxOut_, 2); }
                }
                Double minOccupationPaxOut_;
                public Double minOccupationPaxOut
                {
                    get { return Math.Round(minOccupationPaxOut_, 2); }
                }
                // << Task #10615 Pax2Sim - Pax analysis - Summary - small changes

                // >> Task #10440 Pax2Sim - Pax analysis - missing KPIs part 1
                Double minThroughputIn_;
                public Double minThroughputIn
                {
                    get { return Math.Round(minThroughputIn_, 2); }
                }

                Double avgThroughputIn_;
                public Double avgThroughputIn
                {
                    get { return Math.Round(avgThroughputIn_, 2); }
                }

                Double maxThroughputIn_;
                public Double maxThroughputIn
                {
                    get { return Math.Round(maxThroughputIn_, 2); }
                }

                Double minThroughputInstantIn_;
                public Double minThroughputInstantIn
                {
                    get { return Math.Round(minThroughputInstantIn_, 2); }
                }

                Double avgThroughputInstantIn_;
                public Double avgThroughputInstantIn
                {
                    get { return Math.Round(avgThroughputInstantIn_, 2); }
                }

                Double maxThroughputInstantIn_;
                public Double maxThroughputInstantIn
                {
                    get { return Math.Round(maxThroughputInstantIn_, 2); }
                }

                Double minThroughputOut_;
                public Double minThroughputOut
                {
                    get { return Math.Round(minThroughputOut_, 2); }
                }

                Double avgThroughputOut_;
                public Double avgThroughputOut
                {
                    get { return Math.Round(avgThroughputOut_, 2); }
                }

                Double maxThroughputOut_;
                public Double maxThroughputOut
                {
                    get { return Math.Round(maxThroughputOut_, 2); }
                }

                Double minThroughputInstantOut_;
                public Double minThroughputInstantOut
                {
                    get { return Math.Round(minThroughputInstantOut_, 2); }
                }

                Double avgThroughputInstantOut_;
                public Double avgThroughputInstantOut
                {
                    get { return Math.Round(avgThroughputInstantOut_, 2); }
                }

                Double maxThroughputInstantOut_;
                public Double maxThroughputInstantOut
                {
                    get { return Math.Round(maxThroughputInstantOut_, 2); }
                }

                Double minRemainingTime_;
                public Double minRemainingTime
                {
                    get { return Math.Round(minRemainingTime_, 2); }
                }

                Double avgRemainingTime_;
                public Double avgRemainingTime
                {
                    get { return Math.Round(avgRemainingTime_, 2); }
                }

                Double maxRemainingTime_;
                public Double maxRemainingTime
                {
                    get { return Math.Round(maxRemainingTime_, 2); }
                }

                Double minUtilizationPercent_;
                public Double minUtilizationPercent
                {
                    get { return Math.Round(minUtilizationPercent_, 2); }
                }

                Double avgUtilizationPercent_;
                public Double avgUtilizationPercent
                {
                    get { return Math.Round(avgUtilizationPercent_, 2); }
                }

                Double maxUtiliaztionPercent_;
                public Double maxUtilizationPercent
                {
                    get { return Math.Round(maxUtiliaztionPercent_, 2); }
                }

                Double minDeskNeed_ = -1;
                public Double minDeskNeed
                {
                    get { return Math.Round(minDeskNeed_, 2); }
                }

                Double avgDeskNeed_ = -1;
                public Double avgDeskNeed
                {
                    get { return Math.Round(avgDeskNeed_, 2); }
                }

                Double maxDeskNeed_ = -1;
                public Double maxDeskNeed
                {
                    get { return Math.Round(maxDeskNeed_, 2); }
                }
                // << Task #10440 Pax2Sim - Pax analysis - missing KPIs part 1

                // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent

                Double totalTimeForAllPaxInStation_ = -1;
                public Double totalTimeForAllPaxInStation
                {
                    get { return Math.Round(totalTimeForAllPaxInStation_, 2); }
                    set { totalTimeForAllPaxInStation_ = value; }
                }

                Double minTotalTime_ = -1;
                public Double minTotalTime
                {
                    get { return Math.Round(minTotalTime_, 2); }
                    set { minTotalTime_ = value; }
                }
                Double avgTotalTime_ = -1;
                public Double avgTotalTime
                {
                    get { return Math.Round(avgTotalTime_, 2); }
                    set { avgTotalTime_ = value; }
                }
                Double maxTotalTime_ = -1;
                public Double maxTotalTime
                {
                    get { return Math.Round(maxTotalTime_, 2); }
                    set { maxTotalTime_ = value; }
                }


                Double totalProcessTime_ = -1;
                public Double totalProcessTime
                {
                    get { return Math.Round(totalProcessTime_, 2); }
                    set { totalProcessTime_ = value; }
                }

                Double totalWaitingDeskTime_ = -1;
                public Double totalWaitingDeskTime
                {
                    get { return Math.Round(totalWaitingDeskTime_, 2); }
                    set { totalWaitingDeskTime_ = value; }
                }

                Double totalWaitingGroupTime_ = -1;
                public Double totalWaitingGroupTime
                {
                    get { return Math.Round(totalWaitingGroupTime_, 2); }
                    set { totalWaitingGroupTime_ = value; }
                }

                Double totalWaitingDeskAndGroupTime_ = -1;
                public Double totalWaitingDeskAndGroupTime
                {
                    get { return Math.Round(totalWaitingDeskAndGroupTime_, 2); }
                    set { totalWaitingDeskAndGroupTime_ = value; }
                }

                Double totalOccupation_ = -1;
                public Double totalOccupation
                {
                    get { return Math.Round(totalOccupation_, 2); }
                    set { totalOccupation_ = value; }
                }

                Double totalDelayTime_ = -1;
                public Double totalDelayTime
                {
                    get { return Math.Round(totalDelayTime_, 2); }
                    set { totalDelayTime_ = value; }
                }

                Double totalDwellArea_ = -1;
                public Double totalDwellArea
                {
                    get { return Math.Round(totalDwellArea_, 2); }
                    set { totalDwellArea_ = value; }
                }

                Double totalThroughputInput_ = -1;
                public Double totalThroughputInput
                {
                    get { return Math.Round(totalThroughputInput_, 2); }
                    set { totalThroughputInput_ = value; }
                }

                Double totalThroughputOutput_ = -1;
                public Double totalThroughputOutput
                {
                    get { return Math.Round(totalThroughputOutput_, 2); }
                    set { totalThroughputOutput_ = value; }
                }

                Double totalRemainingTime_ = -1;
                public Double totalRemainingTime
                {
                    get { return Math.Round(totalRemainingTime_, 2); }
                    set { totalRemainingTime_ = value; }
                }

                Double totalUtilizationPercent_ = -1;
                public Double totalUtilizationPercent
                {
                    get { return Math.Round(totalUtilizationPercent_, 2); }
                    set { totalUtilizationPercent_ = value; }
                }

                Double totalDeskNeed_ = -1;
                public Double totalDeskNeed
                {
                    get { return Math.Round(totalDeskNeed_, 2); }
                    set { totalDeskNeed_ = value; }
                }

                private int numberOfPaxLevel1Value_ = -1;
                public int numberOfPaxLevel1Value
                {
                    get { return numberOfPaxLevel1Value_; }
                    set { numberOfPaxLevel1Value_ = value; }
                }
                private int numberOfPaxLevel2Value_ = -1;
                public int numberOfPaxLevel2Value
                {
                    get { return numberOfPaxLevel2Value_; }
                    set { numberOfPaxLevel2Value_ = value; }
                }
                private int numberOfPaxLevel3Value_ = -1;
                public int numberOfPaxLevel3Value
                {
                    get { return numberOfPaxLevel3Value_; }
                    set { numberOfPaxLevel3Value_ = value; }
                }

                private int numberOfProcessedPaxLevel1Value_ = -1;
                public int numberOfProcessedPaxLevel1Value
                {
                    get { return numberOfProcessedPaxLevel1Value_; }
                    set { numberOfProcessedPaxLevel1Value_ = value; }
                }
                private int numberOfProcessedPaxLevel2Value_ = -1;
                public int numberOfProcessedPaxLevel2Value
                {
                    get { return numberOfProcessedPaxLevel2Value_; }
                    set { numberOfProcessedPaxLevel2Value_ = value; }
                }
                private int numberOfProcessedPaxLevel3Value_ = -1;
                public int numberOfProcessedPaxLevel3Value
                {
                    get { return numberOfProcessedPaxLevel3Value_; }
                    set { numberOfProcessedPaxLevel3Value_ = value; }
                }

                private int numberOfTransferPaxLevel1Value_ = -1;
                public int numberOfTransferPaxLevel1Value
                {
                    get { return numberOfTransferPaxLevel1Value_; }
                    set { numberOfTransferPaxLevel1Value_ = value; }
                }
                private int numberOfTransferPaxLevel2Value_ = -1;
                public int numberOfTransferPaxLevel2Value
                {
                    get { return numberOfTransferPaxLevel2Value_; }
                    set { numberOfTransferPaxLevel2Value_ = value; }
                }
                private int numberOfTransferPaxLevel3Value_ = -1;
                public int numberOfTransferPaxLevel3Value
                {
                    get { return numberOfTransferPaxLevel3Value_; }
                    set { numberOfTransferPaxLevel3Value_ = value; }
                }

                private int numberOfMissedPaxLevel1Value_ = -1;
                public int numberOfMissedPaxLevel1Value
                {
                    get { return numberOfMissedPaxLevel1Value_; }
                    set { numberOfMissedPaxLevel1Value_ = value; }
                }
                private int numberOfMissedPaxLevel2Value_ = -1;
                public int numberOfMissedPaxLevel2Value
                {
                    get { return numberOfMissedPaxLevel2Value_; }
                    set { numberOfMissedPaxLevel2Value_ = value; }
                }
                private int numberOfMissedPaxLevel3Value_ = -1;
                public int numberOfMissedPaxLevel3Value
                {
                    get { return numberOfMissedPaxLevel3Value_; }
                    set { numberOfMissedPaxLevel3Value_ = value; }
                }

                private int numberOfStoppedPaxLevel1Value_ = -1;
                public int numberOfStoppedPaxLevel1Value
                {
                    get { return numberOfStoppedPaxLevel1Value_; }
                    set { numberOfStoppedPaxLevel1Value_ = value; }
                }
                private int numberOfStoppedPaxLevel2Value_ = -1;
                public int numberOfStoppedPaxLevel2Value
                {
                    get { return numberOfStoppedPaxLevel2Value_; }
                    set { numberOfStoppedPaxLevel2Value_ = value; }
                }
                private int numberOfStoppedPaxLevel3Value_ = -1;
                public int numberOfStoppedPaxLevel3Value
                {
                    get { return numberOfStoppedPaxLevel3Value_; }
                    set { numberOfStoppedPaxLevel3Value_ = value; }
                }

                private int numberOfLostPaxLevel1Value_ = -1;
                public int numberOfLostPaxLevel1Value
                {
                    get { return numberOfLostPaxLevel1Value_; }
                    set { numberOfLostPaxLevel1Value_ = value; }
                }
                private int numberOfLostPaxLevel2Value_ = -1;
                public int numberOfLostPaxLevel2Value
                {
                    get { return numberOfLostPaxLevel2Value_; }
                    set { numberOfLostPaxLevel2Value_ = value; }
                }
                private int numberOfLostPaxLevel3Value_ = -1;
                public int numberOfLostPaxLevel3Value
                {
                    get { return numberOfLostPaxLevel3Value_; }
                    set { numberOfLostPaxLevel3Value_ = value; }
                }

                Double minOccupationLevel1Value_ = -1;
                public Double minOccupationLevel1Value
                {
                    get { return Math.Round(minOccupationLevel1Value_, 2); }
                }
                Double minOccupationLevel2Value_ = -1;
                public Double minOccupationLevel2Value
                {
                    get { return Math.Round(minOccupationLevel2Value_, 2); }
                }
                Double minOccupationLevel3Value_ = -1;
                public Double minOccupationLevel3Value
                {
                    get { return Math.Round(minOccupationLevel3Value_, 2); }
                }

                Double avgOccupationLevel1Value_ = -1;
                public Double avgOccupationLevel1Value
                {
                    get { return Math.Round(avgOccupationLevel1Value_, 2); }
                }
                Double avgOccupationLevel2Value_ = -1;
                public Double avgOccupationLevel2Value
                {
                    get { return Math.Round(avgOccupationLevel2Value_, 2); }
                }
                Double avgOccupationLevel3Value_ = -1;
                public Double avgOccupationLevel3Value
                {
                    get { return Math.Round(avgOccupationLevel3Value_, 2); }
                }

                Double maxOccupationLevel1Value_ = -1;
                public Double maxOccupationLevel1Value
                {
                    get { return Math.Round(maxOccupationLevel1Value_, 2); }
                }
                Double maxOccupationLevel2Value_ = -1;
                public Double maxOccupationLevel2Value
                {
                    get { return Math.Round(maxOccupationLevel2Value_, 2); }
                }
                Double maxOccupationLevel3Value_ = -1;
                public Double maxOccupationLevel3Value
                {
                    get { return Math.Round(maxOccupationLevel3Value_, 2); }
                }

                Double minThroughputInLevel1Value_ = -1;
                public Double minThroughputInLevel1Value
                {
                    get { return Math.Round(minThroughputInLevel1Value_, 2); }
                }
                Double minThroughputInLevel2Value_ = -1;
                public Double minThroughputInLevel2Value
                {
                    get { return Math.Round(minThroughputInLevel2Value_, 2); }
                }
                Double minThroughputInLevel3Value_ = -1;
                public Double minThroughputInLevel3Value
                {
                    get { return Math.Round(minThroughputInLevel3Value_, 2); }
                }

                Double avgThroughputInLevel1Value_ = -1;
                public Double avgThroughputInLevel1Value
                {
                    get { return Math.Round(avgThroughputInLevel1Value_, 2); }
                }
                Double avgThroughputInLevel2Value_ = -1;
                public Double avgThroughputInLevel2Value
                {
                    get { return Math.Round(avgThroughputInLevel2Value_, 2); }
                }
                Double avgThroughputInLevel3Value_ = -1;
                public Double avgThroughputInLevel3Value
                {
                    get { return Math.Round(avgThroughputInLevel3Value_, 2); }
                }

                Double maxThroughputInLevel1Value_ = -1;
                public Double maxThroughputInLevel1Value
                {
                    get { return Math.Round(maxThroughputInLevel1Value_, 2); }
                }
                Double maxThroughputInLevel2Value_ = -1;
                public Double maxThroughputInLevel2Value
                {
                    get { return Math.Round(maxThroughputInLevel2Value_, 2); }
                }
                Double maxThroughputInLevel3Value_ = -1;
                public Double maxThroughputInLevel3Value
                {
                    get { return Math.Round(maxThroughputInLevel3Value_, 2); }
                }

                Double minThroughputOutLevel1Value_ = -1;
                public Double minThroughputOutLevel1Value
                {
                    get { return Math.Round(minThroughputOutLevel1Value_, 2); }
                }
                Double minThroughputOutLevel2Value_ = -1;
                public Double minThroughputOutLevel2Value
                {
                    get { return Math.Round(minThroughputOutLevel2Value_, 2); }
                }
                Double minThroughputOutLevel3Value_ = -1;
                public Double minThroughputOutLevel3Value
                {
                    get { return Math.Round(minThroughputOutLevel3Value_, 2); }
                }

                Double avgThroughputOutLevel1Value_ = -1;
                public Double avgThroughputOutLevel1Value
                {
                    get { return Math.Round(avgThroughputOutLevel1Value_, 2); }
                }
                Double avgThroughputOutLevel2Value_ = -1;
                public Double avgThroughputOutLevel2Value
                {
                    get { return Math.Round(avgThroughputOutLevel2Value_, 2); }
                }
                Double avgThroughputOutLevel3Value_ = -1;
                public Double avgThroughputOutLevel3Value
                {
                    get { return Math.Round(avgThroughputOutLevel3Value_, 2); }
                }

                Double maxThroughputOutLevel1Value_ = -1;
                public Double maxThroughputOutLevel1Value
                {
                    get { return Math.Round(maxThroughputOutLevel1Value_, 2); }
                }
                Double maxThroughputOutLevel2Value_ = -1;
                public Double maxThroughputOutLevel2Value
                {
                    get { return Math.Round(maxThroughputOutLevel2Value_, 2); }
                }
                Double maxThroughputOutLevel3Value_ = -1;
                public Double maxThroughputOutLevel3Value
                {
                    get { return Math.Round(maxThroughputOutLevel3Value_, 2); }
                }

                Double dwellAreaLevel1MinValue_ = -1;
                public Double dwellAreaLevel1MinValue
                {
                    get { return Math.Round(dwellAreaLevel1MinValue_, 2); }
                }
                Double dwellAreaLevel1AvgValue_ = -1;
                public Double dwellAreaLevel1AvgValue
                {
                    get { return Math.Round(dwellAreaLevel1AvgValue_, 2); }
                }
                Double dwellAreaLevel1MaxValue_ = -1;
                public Double dwellAreaLevel1MaxValue
                {
                    get { return Math.Round(dwellAreaLevel1MaxValue_, 2); }
                }

                Double dwellAreaLevel2MinValue_ = -1;
                public Double dwellAreaLevel2MinValue
                {
                    get { return Math.Round(dwellAreaLevel2MinValue_, 2); }
                }
                Double dwellAreaLevel2AvgValue_ = -1;
                public Double dwellAreaLevel2AvgValue
                {
                    get { return Math.Round(dwellAreaLevel2AvgValue_, 2); }
                }
                Double dwellAreaLevel2MaxValue_ = -1;
                public Double dwellAreaLevel2MaxValue
                {
                    get { return Math.Round(dwellAreaLevel2MaxValue_, 2); }
                }

                Double dwellAreaLevel3MinValue_ = -1;
                public Double dwellAreaLevel3MinValue
                {
                    get { return Math.Round(dwellAreaLevel3MinValue_, 2); }
                }
                Double dwellAreaLevel3AvgValue_ = -1;
                public Double dwellAreaLevel3AvgValue
                {
                    get { return Math.Round(dwellAreaLevel3AvgValue_, 2); }
                }
                Double dwellAreaLevel3MaxValue_ = -1;
                public Double dwellAreaLevel3MaxValue
                {
                    get { return Math.Round(dwellAreaLevel3MaxValue_, 2); }
                }

                #region total time max levels stats
                Double totalTimeLevel1MaxValue_ = -1;
                public Double totalTimeLevel1MaxValue
                {
                    get { return Math.Round(totalTimeLevel1MaxValue_, 2); }
                }
                Double totalTimeLevel2MaxValue_ = -1;
                public Double totalTimeLevel2MaxValue
                {
                    get { return Math.Round(totalTimeLevel2MaxValue_, 2); }
                }
                Double totalTimeLevel3MaxValue_ = -1;
                public Double totalTimeLevel3MaxValue
                {
                    get { return Math.Round(totalTimeLevel3MaxValue_, 2); }
                }
                #endregion

                Double delayTimeLevel1MinValue_ = -1;
                public Double delayTimeLevel1MinValue
                {
                    get { return Math.Round(delayTimeLevel1MinValue_, 2); }
                }
                Double delayTimeLevel1AvgValue_ = -1;
                public Double delayTimeLevel1AvgValue
                {
                    get { return Math.Round(delayTimeLevel1AvgValue_, 2); }
                }
                Double delayTimeLevel1MaxValue_ = -1;
                public Double delayTimeLevel1MaxValue
                {
                    get { return Math.Round(delayTimeLevel1MaxValue_, 2); }
                }

                Double delayTimeLevel2MinValue_ = -1;
                public Double delayTimeLevel2MinValue
                {
                    get { return Math.Round(delayTimeLevel2MinValue_, 2); }
                }
                Double delayTimeLevel2AvgValue_ = -1;
                public Double delayTimeLevel2AvgValue
                {
                    get { return Math.Round(delayTimeLevel2AvgValue_, 2); }
                }
                Double delayTimeLevel2MaxValue_ = -1;
                public Double delayTimeLevel2MaxValue
                {
                    get { return Math.Round(delayTimeLevel2MaxValue_, 2); }
                }

                Double delayTimeLevel3MinValue_ = -1;
                public Double delayTimeLevel3MinValue
                {
                    get { return Math.Round(delayTimeLevel3MinValue_, 2); }
                }
                Double delayTimeLevel3AvgValue_ = -1;
                public Double delayTimeLevel3AvgValue
                {
                    get { return Math.Round(delayTimeLevel3AvgValue_, 2); }
                }
                Double delayTimeLevel3MaxValue_ = -1;
                public Double delayTimeLevel3MaxValue
                {
                    get { return Math.Round(delayTimeLevel3MaxValue_, 2); }
                }

                Double waitingDeskTimeLevel1MinValue_ = -1;
                public Double waitingDeskTimeLevel1MinValue
                {
                    get { return Math.Round(waitingDeskTimeLevel1MinValue_, 2); }
                }
                Double waitingDeskTimeLevel1AvgValue_ = -1;
                public Double waitingDeskTimeLevel1AvgValue
                {
                    get { return Math.Round(waitingDeskTimeLevel1AvgValue_, 2); }
                }
                Double waitingDeskTimeLevel1MaxValue_ = -1;
                public Double waitingDeskTimeLevel1MaxValue
                {
                    get { return Math.Round(waitingDeskTimeLevel1MaxValue_, 2); }
                }

                Double waitingDeskTimeLevel2MinValue_ = -1;
                public Double waitingDeskTimeLevel2MinValue
                {
                    get { return Math.Round(waitingDeskTimeLevel2MinValue_, 2); }
                }
                Double waitingDeskTimeLevel2AvgValue_ = -1;
                public Double waitingDeskTimeLevel2AvgValue
                {
                    get { return Math.Round(waitingDeskTimeLevel2AvgValue_, 2); }
                }
                Double waitingDeskTimeLevel2MaxValue_ = -1;
                public Double waitingDeskTimeLevel2MaxValue
                {
                    get { return Math.Round(waitingDeskTimeLevel2MaxValue_, 2); }
                }

                Double waitingDeskTimeLevel3MinValue_ = -1;
                public Double waitingDeskTimeLevel3MinValue
                {
                    get { return Math.Round(waitingDeskTimeLevel3MinValue_); }
                }
                Double waitingDeskTimeLevel3AvgValue_ = -1;
                public Double waitingDeskTimeLevel3AvgValue
                {
                    get { return Math.Round(waitingDeskTimeLevel3AvgValue_); }
                }
                Double waitingDeskTimeLevel3MaxValue_ = -1;
                public Double waitingDeskTimeLevel3MaxValue
                {
                    get { return Math.Round(waitingDeskTimeLevel3MaxValue_); }
                }

                Double waitingGroupTimeLevel1MinValue_ = -1;
                public Double waitingGroupTimeLevel1MinValue
                {
                    get { return Math.Round(waitingGroupTimeLevel1MinValue_); }
                }
                Double waitingGroupTimeLevel1AvgValue_ = -1;
                public Double waitingGroupTimeLevel1AvgValue
                {
                    get { return Math.Round(waitingGroupTimeLevel1AvgValue_, 2); }
                }
                Double waitingGroupTimeLevel1MaxValue_ = -1;
                public Double waitingGroupTimeLevel1MaxValue
                {
                    get { return Math.Round(waitingGroupTimeLevel1MaxValue_, 2); }
                }

                Double waitingGroupTimeLevel2MinValue_ = -1;
                public Double waitingGroupTimeLevel2MinValue
                {
                    get { return Math.Round(waitingGroupTimeLevel2MinValue_, 2); }
                }
                Double waitingGroupTimeLevel2AvgValue_ = -1;
                public Double waitingGroupTimeLevel2AvgValue
                {
                    get { return Math.Round(waitingGroupTimeLevel2AvgValue_, 2); }
                }
                Double waitingGroupTimeLevel2MaxValue_ = -1;
                public Double waitingGroupTimeLevel2MaxValue
                {
                    get { return Math.Round(waitingGroupTimeLevel2MaxValue_, 2); }
                }

                Double waitingGroupTimeLevel3MinValue_ = -1;
                public Double waitingGroupTimeLevel3MinValue
                {
                    get { return Math.Round(waitingGroupTimeLevel3MinValue_, 2); }
                }
                Double waitingGroupTimeLevel3AvgValue_ = -1;
                public Double waitingGroupTimeLevel3AvgValue
                {
                    get { return Math.Round(waitingGroupTimeLevel3AvgValue_, 2); }
                }
                Double waitingGroupTimeLevel3MaxValue_ = -1;
                public Double waitingGroupTimeLevel3MaxValue
                {
                    get { return Math.Round(waitingGroupTimeLevel3MaxValue_, 2); }
                }

                Double processTimeLevel1MinValue_ = -1;
                public Double processTimeLevel1MinValue
                {
                    get { return Math.Round(processTimeLevel1MinValue_, 2); }
                }
                Double processTimeLevel1AvgValue_ = -1;
                public Double processTimeLevel1AvgValue
                {
                    get { return Math.Round(processTimeLevel1AvgValue_, 2); }
                }
                Double processTimeLevel1MaxValue_ = -1;
                public Double processTimeLevel1MaxValue
                {
                    get { return Math.Round(processTimeLevel1MaxValue_, 2); }
                }

                Double processTimeLevel2MinValue_ = -1;
                public Double processTimeLevel2MinValue
                {
                    get { return Math.Round(processTimeLevel2MinValue_, 2); }
                }
                Double processTimeLevel2AvgValue_ = -1;
                public Double processTimeLevel2AvgValue
                {
                    get { return Math.Round(processTimeLevel2AvgValue_, 2); }
                }
                Double processTimeLevel2MaxValue_ = -1;
                public Double processTimeLevel2MaxValue
                {
                    get { return Math.Round(processTimeLevel2MaxValue_, 2); }
                }

                Double processTimeLevel3MinValue_ = -1;
                public Double processTimeLevel3MinValue
                {
                    get { return Math.Round(processTimeLevel3MinValue_, 2); }
                }
                Double processTimeLevel3AvgValue_ = -1;
                public Double processTimeLevel3AvgValue
                {
                    get { return Math.Round(processTimeLevel3AvgValue_, 2); }
                }
                Double processTimeLevel3MaxValue_ = -1;
                public Double processTimeLevel3MaxValue
                {
                    get { return Math.Round(processTimeLevel3MaxValue_, 2); }
                }

                Double remainingTimeLevel1MinValue_ = -1;
                public Double remainingTimeLevel1MinValue
                {
                    get { return Math.Round(remainingTimeLevel1MinValue_, 2); }
                }
                Double remainingTimeLevel1AvgValue_ = -1;
                public Double remainingTimeLevel1AvgValue
                {
                    get { return Math.Round(remainingTimeLevel1AvgValue_, 2); }
                }
                Double remainingTimeLevel1MaxValue_ = -1;
                public Double remainingTimeLevel1MaxValue
                {
                    get { return Math.Round(remainingTimeLevel1MaxValue_, 2); }
                }

                Double remainingTimeLevel2MinValue_ = -1;
                public Double remainingTimeLevel2MinValue
                {
                    get { return Math.Round(remainingTimeLevel2MinValue_, 2); }
                }
                Double remainingTimeLevel2AvgValue_ = -1;
                public Double remainingTimeLevel2AvgValue
                {
                    get { return Math.Round(remainingTimeLevel2AvgValue_, 2); }
                }
                Double remainingTimeLevel2MaxValue_ = -1;
                public Double remainingTimeLevel2MaxValue
                {
                    get { return Math.Round(remainingTimeLevel2MaxValue_, 2); }
                }

                Double remainingTimeLevel3MinValue_ = -1;
                public Double remainingTimeLevel3MinValue
                {
                    get { return Math.Round(remainingTimeLevel3MinValue_, 2); }
                }
                Double remainingTimeLevel3AvgValue_ = -1;
                public Double remainingTimeLevel3AvgValue
                {
                    get { return Math.Round(remainingTimeLevel3AvgValue_, 2); }
                }
                Double remainingTimeLevel3MaxValue_ = -1;
                public Double remainingTimeLevel3MaxValue
                {
                    get { return Math.Round(remainingTimeLevel3MaxValue_, 2); }
                }

                Double waitingTimeLevel1MinValue_ = -1;
                public Double waitingTimeLevel1MinValue
                {
                    get { return Math.Round(waitingTimeLevel1MinValue_, 2); }
                }
                Double waitingTimeLevel1AvgValue_ = -1;
                public Double waitingTimeLevel1AvgValue
                {
                    get { return Math.Round(waitingTimeLevel1AvgValue_, 2); }
                }
                Double waitingTimeLevel1MaxValue_ = -1;
                public Double waitingTimeLevel1MaxValue
                {
                    get { return Math.Round(waitingTimeLevel1MaxValue_, 2); }
                }

                Double waitingTimeLevel2MinValue_ = -1;
                public Double waitingTimeLevel2MinValue
                {
                    get { return Math.Round(waitingTimeLevel2MinValue_, 2); }
                }
                Double waitingTimeLevel2AvgValue_ = -1;
                public Double waitingTimeLevel2AvgValue
                {
                    get { return Math.Round(waitingTimeLevel2AvgValue_, 2); }
                }
                Double waitingTimeLevel2MaxValue_ = -1;
                public Double waitingTimeLevel2MaxValue
                {
                    get { return Math.Round(waitingTimeLevel2MaxValue_, 2); }
                }

                Double waitingTimeLevel3MinValue_ = -1;
                public Double waitingTimeLevel3MinValue
                {
                    get { return Math.Round(waitingTimeLevel3MinValue_, 2); }
                }
                Double waitingTimeLevel3AvgValue_ = -1;
                public Double waitingTimeLevel3AvgValue
                {
                    get { return Math.Round(waitingTimeLevel3AvgValue_, 2); }
                }
                Double waitingTimeLevel3MaxValue_ = -1;
                public Double waitingTimeLevel3MaxValue
                {
                    get { return Math.Round(waitingTimeLevel3MaxValue_, 2); }
                }

                Double totalProcessTimeLevel1Value_ = -1;
                public Double totalProcessTimeLevel1Value
                {
                    get { return Math.Round(totalProcessTimeLevel1Value_, 2); }
                    set { totalProcessTimeLevel1Value_ = value; }
                }
                Double totalProcessTimeLevel2Value_ = -1;
                public Double totalProcessTimeLevel2Value
                {
                    get { return Math.Round(totalProcessTimeLevel2Value_, 2); }
                    set { totalProcessTimeLevel2Value_ = value; }
                }
                Double totalProcessTimeLevel3Value_ = -1;
                public Double totalProcessTimeLevel3Value
                {
                    get { return Math.Round(totalProcessTimeLevel3Value_, 2); }
                    set { totalProcessTimeLevel3Value_ = value; }
                }

                Double minUtilizationPercentLevel1Value_ = -1;
                public Double minUtilizationPercentLevel1Value
                {
                    get { return Math.Round(minUtilizationPercentLevel1Value_, 2); }
                }
                Double avgUtilizationPercentLevel1Value_ = -1;
                public Double avgUtilizationPercentLevel1Value
                {
                    get { return Math.Round(avgUtilizationPercentLevel1Value_, 2); }
                }
                Double maxUtilizationPercentLevel1Value_ = -1;
                public Double maxUtilizationPercentLevel1Value
                {
                    get { return Math.Round(maxUtilizationPercentLevel1Value_, 2); }
                }

                Double minUtilizationPercentLevel2Value_ = -1;
                public Double minUtilizationPercentLevel2Value
                {
                    get { return Math.Round(minUtilizationPercentLevel2Value_, 2); }
                }
                Double avgUtilizationPercentLevel2Value_ = -1;
                public Double avgUtilizationPercentLevel2Value
                {
                    get { return Math.Round(avgUtilizationPercentLevel2Value_, 2); }
                }
                Double maxUtilizationPercentLevel2Value_ = -1;
                public Double maxUtilizationPercentLevel2Value
                {
                    get { return Math.Round(maxUtilizationPercentLevel2Value_, 2); }
                }

                Double minUtilizationPercentLevel3Value_ = -1;
                public Double minUtilizationPercentLevel3Value
                {
                    get { return Math.Round(minUtilizationPercentLevel3Value_, 2); }
                }
                Double avgUtilizationPercentLevel3Value_ = -1;
                public Double avgUtilizationPercentLevel3Value
                {
                    get { return Math.Round(avgUtilizationPercentLevel3Value_, 2); }
                }
                Double maxUtilizationPercentLevel3Value_ = -1;
                public Double maxUtilizationPercentLevel3Value
                {
                    get { return Math.Round(maxUtilizationPercentLevel3Value_, 2); }
                }

                Double minDeskNeedLevel1Value_ = -1;
                public Double minDeskNeedLevel1Value
                {
                    get { return Math.Round(minDeskNeedLevel1Value_, 2); }
                }
                Double avgDeskNeedLevel1Value_ = -1;
                public Double avgDeskNeedLevel1Value
                {
                    get { return Math.Round(avgDeskNeedLevel1Value_, 2); }
                }
                Double maxDeskNeedLevel1Value_ = -1;
                public Double maxDeskNeedLevel1Value
                {
                    get { return Math.Round(maxDeskNeedLevel1Value_, 2); }
                }

                Double minDeskNeedLevel2Value_ = -1;
                public Double minDeskNeedLevel2Value
                {
                    get { return Math.Round(minDeskNeedLevel2Value_, 2); }
                }
                Double avgDeskNeedLevel2Value_ = -1;
                public Double avgDeskNeedLevel2Value
                {
                    get { return Math.Round(avgDeskNeedLevel2Value_, 2); }
                }
                Double maxDeskNeedLevel2Value_ = -1;
                public Double maxDeskNeedLevel2Value
                {
                    get { return Math.Round(maxDeskNeedLevel2Value_, 2); }
                }

                Double minDeskNeedLevel3Value_ = -1;
                public Double minDeskNeedLevel3Value
                {
                    get { return Math.Round(minDeskNeedLevel3Value_, 2); }
                }
                Double avgDeskNeedLevel3Value_ = -1;
                public Double avgDeskNeedLevel3Value
                {
                    get { return Math.Round(avgDeskNeedLevel3Value_, 2); }
                }
                Double maxDeskNeedLevel3Value_ = -1;
                public Double maxDeskNeedLevel3Value
                {
                    get { return Math.Round(maxDeskNeedLevel3Value_, 2); }
                }

                public Double rateLevel1Value
                {
                    get
                    {
                        if (dTotalOpeningTime == 0)
                            return 0;

                        return Math.Round(totalProcessTimeLevel1Value_ / dTotalOpeningTime, 4);
                    }
                }
                public Double rateLevel2Value
                {
                    get
                    {
                        if (dTotalOpeningTime == 0)
                            return 0;

                        return Math.Round(totalProcessTimeLevel2Value_ / dTotalOpeningTime, 4);
                    }
                }
                public Double rateLevel3Value
                {
                    get
                    {
                        if (dTotalOpeningTime == 0)
                            return 0;

                        return Math.Round(totalProcessTimeLevel3Value_ / dTotalOpeningTime, 4);
                    }
                }
                // << Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent

                // << Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                Double dMinDelayTime;
                public Double MinDelayTime
                {
                    get { return Math.Round(dMinDelayTime, 2); }
                }

                Double dMaxDelayTime;
                public Double MaxDelayTime
                {
                    get { return Math.Round(dMaxDelayTime, 2); }
                }

                Double dMeanDelayTime;
                public Double MeanDelayTime
                {
                    get { return Math.Round(dMeanDelayTime, 2); }
                }
                // >> Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time

                Double dTotalOpeningTime;
                public Double TotalOpeningTime
                {
                    get
                    {
                        return Math.Round(dTotalOpeningTime, 2);
                    }
                    set { dTotalOpeningTime = value; }  // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                }
                Double dTotalProcessTime;
                public Double TotalProcessTime
                {
                    get
                    {
                        return Math.Round(dTotalProcessTime, 2);
                    }
                }
                Double dRate;
                public Double Rate
                {
                    get
                    {
                        return Math.Round(dRate, 4);
                    }
                    set { dRate = value; }  // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                }

                bool bIsGroup;
                public bool IsGroup
                {
                    get
                    {
                        return bIsGroup;
                    }
                }
                bool bIsLevel;
                public bool IsLevel
                {
                    get
                    {
                        return bIsLevel;
                    }
                }

                #endregion

                #region Les constructeurs de la classe.
                private void InitClass(String DeskName_,
                                        int PaxNumber_,
                                        int iProcessedPax_,
                                        int PaxTransfer_,
                                        int PaxMissed_,
                                        int PaxStopped_,
                                        int PaxLost_,
                                        Double MinWaiting_,
                                        Double MaxWaiting_,
                                        Double MeanWaiting_,

                                        Double MinWaitingGroup_,
                                        Double MaxWaitingGroup_,
                                        Double MeanWaitingGroup_,

                                        Double MinWaitingDesk_,
                                        Double MaxWaitingDesk_,
                                        Double MeanWaitingDesk_,

                                        Double MinProcess_,
                                        Double MaxProcess_,
                                        Double MeanProcess_,

                                        Double MinRemaining_,
                                        Double MaxRemaining_,
                                        Double MeanRemaining_,

                                        Double MinDwellDesk_,
                                        Double MaxDwellDesk_,
                                        Double MeanDwellDesk_,

                                        Double MinQueueOccupation_,
                                        Double MaxQueueOccupation_,
                                        Double MeanQueueOccupation_,

                                        Double TotalOpeningTime_,
                                        Double TotalProcessTime_,
                                        bool IsGroup_,
                                        bool IsLevel_,
                                        // << Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                                        Double MinDelayTime_,
                                        Double MaxDelayTime_,
                                        Double MeanDelayTime_
                                        // >> Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                                        )
                {

                    bIsGroup = IsGroup_;
                    bIsLevel = IsLevel_;
                    sDeskname = DeskName_;
                    iPaxNumber = PaxNumber_;
                    ProcessedPax = iProcessedPax_;
                    iPaxTransfer = PaxTransfer_;
                    iPaxMissed = PaxMissed_;
                    iPaxStopped = PaxStopped_;
                    iPaxLost = PaxLost_;

                    dMinWaiting = MinWaiting_;
                    dMaxWaiting = MaxWaiting_;
                    dMeanWaiting = MeanWaiting_;

                    dMinWaitingGroup = MinWaitingGroup_;
                    dMaxWaitingGroup = MaxWaitingGroup_;
                    dMeanWaitingGroup = MeanWaitingGroup_;
                    dMeanWaitingTmp = 0;

                    dMinWaitingDesk = MinWaitingDesk_;
                    dMaxWaitingDesk = MaxWaitingDesk_;
                    dMeanWaitingDesk = MeanWaitingDesk_;

                    dMinProcess = MinProcess_;
                    dMaxProcess = MaxProcess_;
                    dMeanProcess = MeanProcess_;

                    dMinRemaining = MinRemaining_;
                    dMaxRemaining = MaxRemaining_;
                    dMeanRemaining = MeanRemaining_;

                    dMinDwellTimeDesk = MinDwellDesk_;
                    dMaxDwellDesk = MaxDwellDesk_;
                    dMeanDwellDesk = MeanDwellDesk_;

                    dMinQueueOccupation = MinQueueOccupation_;
                    dMaxQueueOccupation = MaxQueueOccupation_;
                    iNumberMean = 0;
                    dMeanQueueOccupation = MeanQueueOccupation_;

                    dTotalOpeningTime = TotalOpeningTime_;
                    dTotalProcessTime = TotalProcessTime_;
                    if (TotalOpeningTime_ != 0)
                        dRate = TotalProcessTime_ / TotalOpeningTime_;
                    else
                        dRate = 0;

                    // << Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                    dMinDelayTime = MinDelayTime_;
                    dMaxDelayTime = MaxDelayTime_;
                    dMeanDelayTime = MeanDelayTime_;
                    // >> Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                }

                public DeskReport(String DeskName_,
                                        int PaxNumber_,
                                        int iProcessedPax_,
                                        int PaxTransfer_,
                                        int PaxMissed_,
                                        int PaxStopped_,
                                        int PaxLost_,
                                        Double MinWaiting_,
                                        Double MaxWaiting_,
                                        Double MeanWaiting_,

                                        Double MinWaitingGroup_,
                                        Double MaxWaitingGroup_,
                                        Double MeanWaitingGroup_,

                                        Double MinWaitingDesk_,
                                        Double MaxWaitingDesk_,
                                        Double MeanWaitingDesk_,

                                        Double MinProcess_,
                                        Double MaxProcess_,
                                        Double MeanProcess_,

                                        Double MinRemaining_,
                                        Double MaxRemaining_,
                                        Double MeanRemaining_,

                                        Double MinDwellDesk_,
                                        Double MaxDwellDesk_,
                                        Double MeanDwellDesk_,

                                        Double MinQueueOccupation_,
                                        Double MaxQueueOccupation_,
                                        Double MeanQueueOccupation_,

                                        Double TotalOpeningTime_,
                                        Double TotalProcessTime_,
                                        // << Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                                        Double MinDelayTime_,
                                        Double MaxDelayTime_,
                                        Double MeanDelayTime_
                                        // >> Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                                        )
                {
                    InitClass(DeskName_, PaxNumber_, iProcessedPax_, PaxTransfer_, PaxMissed_, PaxStopped_, PaxLost_,
                                         MinWaiting_, MaxWaiting_, MeanWaiting_,
                                         MinWaitingGroup_, MaxWaitingGroup_, MeanWaitingGroup_,
                                         MinWaitingDesk_, MaxWaitingDesk_, MeanWaitingDesk_,
                                         MinProcess_, MaxProcess_, MeanProcess_,
                                         MinRemaining_, MaxRemaining_, MeanRemaining_,
                                         MinDwellDesk_, MaxDwellDesk_, MeanDwellDesk_,
                                         MinQueueOccupation_, MaxQueueOccupation_, MeanQueueOccupation_,
                                         TotalOpeningTime_, TotalProcessTime_, false, false,
                                         // << Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                                         MinDelayTime_, MaxDelayTime_, MeanDelayTime_
                                         // >> Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                                         );

                }

                public DeskReport(String GroupName_)
                {
                    InitClass(GroupName_, 0, 0, 0, 0, 0, 0, -1, -1, -1, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, true, false,
                        // << Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                        0, 0, 0
                        // >> Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                        );
                }

                public DeskReport(String GroupName_, bool IsLevel_)
                {
                    if (!IsLevel_)
                        InitClass(GroupName_, 0, 0, 0, 0, 0, 0, -1, -1, -1, 0, 0,
                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, true, false,
                            // << Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                            0, 0, 0
                            // >> Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                            );
                    else
                        InitClass(GroupName_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, false, true,
                            // << Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                            0, 0, 0
                            // >> Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                            );
                }
                #endregion

                #region Fonctions pour la gestion des différentes statistiques
                public void AddPax()
                {
                    iPaxNumber++;
                }
                public void setTransfer()
                {
                    iPaxTransfer++;
                }
                public void setMissed()
                {
                    //if (/*(!bIsGroup) &&*/ (!bIsLevel))
                    //iPaxNumber++;
                    iPaxMissed++;
                }
                public void setStopped()
                {
                    //if (/*(!bIsGroup) && */(!bIsLevel))
                    //iPaxNumber++;
                    iPaxStopped++;
                }
                public void setLost()
                {
                    iPaxLost++;
                }
                public void AddWaitingTime(Double WaitingTime_)
                {
                    if ((dMinWaiting > WaitingTime_) || (dMinWaiting == -1))
                        dMinWaiting = WaitingTime_;
                    if ((dMaxWaiting < WaitingTime_) || (dMaxWaiting == -1))
                        dMaxWaiting = WaitingTime_;
                    dMeanWaitingTmp += WaitingTime_;
                    dMeanWaiting = Math.Round(dMeanWaitingTmp / iPaxNumber, 2);
                }
                #endregion

                #region Fonctions pour mettre en forme les résultats



                public DataTable ToTable(double[] distributionLevels)  // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                {
                    DataTable laTable = new DataTable(sDeskname);//+ "_Results"
                    laTable.Columns.Add("Data", typeof(String));
                    laTable.Columns.Add("Value", typeof(Double));
                    laTable.Columns.Add("Unit", typeof(String));

                    // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                    // for groups and desks isGroup and isLevel are false(to be checked why isGroup is false for groups!)
                    if (!IsGroup && !IsLevel
                        && distributionLevels != null && distributionLevels.Length >= 3)
                    {
                        laTable.Columns.Add(distributionLevels[0].ToString() + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(Double));
                        laTable.Columns.Add(distributionLevels[1].ToString() + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(Double));
                        laTable.Columns.Add(distributionLevels[2].ToString() + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(Double));
                    }
                    // << Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent                      

                    if ((!IsGroup) && (!bIsLevel))
                    {
                        laTable.Rows.Add(new Object[6] { "Number of Pax", PaxNumber, "Passengers"
                            , numberOfPaxLevel1Value, numberOfPaxLevel2Value, numberOfPaxLevel3Value });    // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                        laTable.Rows.Add(new Object[6] { "Processed Pax", ProcessedPax, "Passengers"
                            , numberOfProcessedPaxLevel1Value, numberOfProcessedPaxLevel2Value, numberOfProcessedPaxLevel3Value });  // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent

                        laTable.Rows.Add(new Object[6] { "Pax Transfer", PaxTransfer, "Passengers"
                            , numberOfTransferPaxLevel1Value, numberOfTransferPaxLevel2Value, numberOfTransferPaxLevel3Value });    // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                        laTable.Rows.Add(new Object[6] { "Pax Missed", PaxMissed, "Passengers"
                            , numberOfMissedPaxLevel1Value, numberOfMissedPaxLevel2Value, numberOfMissedPaxLevel3Value });    // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                        laTable.Rows.Add(new Object[6] { "Pax Stopped", PaxStopped, "Passengers"
                            , numberOfStoppedPaxLevel1Value, numberOfStoppedPaxLevel2Value, numberOfStoppedPaxLevel3Value });    // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                        laTable.Rows.Add(new Object[6] { "Pax Lost", PaxLost, "Passengers"
                            , numberOfLostPaxLevel1Value, numberOfLostPaxLevel2Value, numberOfLostPaxLevel3Value });    // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                    }
                    else        // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                    {
                        laTable.Rows.Add(new Object[3] { "Number of Pax", PaxNumber, "Passengers" });
                        laTable.Rows.Add(new Object[3] { "Pax Transfer", PaxTransfer, "Passengers" });
                        laTable.Rows.Add(new Object[3] { "Pax Missed", PaxMissed, "Passengers" });
                        laTable.Rows.Add(new Object[3] { "Pax Stopped", PaxStopped, "Passengers" });
                        laTable.Rows.Add(new Object[3] { "Pax Lost", PaxLost, "Passengers" });
                    }

                    if ((bIsLevel) && (dMinQueueOccupation != -1))
                    {
                        laTable.Rows.Add(new Object[3] { "MinAreaOccupation", MinQueueOccupation, "Passengers" });
                        laTable.Rows.Add(new Object[3] { "MaxAreaOccupation", MaxQueueOccupation, "Passengers" });
                        laTable.Rows.Add(new Object[3] { "MeanAreaOccupation", MeanQueueOccupation, "Passengers" });
                    }
                    if ((IsGroup) || (!bIsLevel))
                    {
                        if (IsGroup)
                        {
                            laTable.Rows.Add(new Object[3] { "Pax Missed (Desk)", iPaxMissedDesk, "Passengers" });
                            laTable.Rows.Add(new Object[3] { "Pax Stopped (Desk)", iPaxStoppedDesk, "Passengers" });
                            laTable.Rows.Add(new Object[3] { "Pax Lost (Desk)", iPaxLostDesk, "Passengers" });
                        }
                        laTable.Rows.Add(new Object[6] { "MinWaiting", MinWaiting, "Minutes"
                            , waitingTimeLevel1MinValue, waitingTimeLevel2MinValue, waitingTimeLevel3MinValue });    // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                        laTable.Rows.Add(new Object[6] { "MaxWaiting", MaxWaiting, "Minutes"
                            , waitingTimeLevel1MaxValue, waitingTimeLevel2MaxValue, waitingTimeLevel3MaxValue });    // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                        laTable.Rows.Add(new Object[6] { "MeanWaiting", MeanWaiting, "Minutes"
                            , waitingTimeLevel1AvgValue, waitingTimeLevel2AvgValue, waitingTimeLevel3AvgValue });    // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                        if (IsGroup)
                        {
                            if (dWaitingDesk != null)
                            {
                                laTable.Rows.Add(new Object[3] { "MinWaiting (Desk)", dWaitingDesk[0], "Minutes" });
                                laTable.Rows.Add(new Object[3] { "MaxWaiting (Desk)", dWaitingDesk[1], "Minutes" });
                                laTable.Rows.Add(new Object[3] { "MeanWaiting (Desk)", Math.Round(dWaitingDesk[2] / iPaxDesk, 2), "Minutes" });

                                laTable.Rows.Add(new Object[3] { "MinProcess (Desk)", dProcess[0], "Minutes" });
                                laTable.Rows.Add(new Object[3] { "MaxProcess (Desk)", dProcess[1], "Minutes" });
                                laTable.Rows.Add(new Object[3] { "MeanProcess (Desk)", Math.Round(dProcess[2] / iPaxDesk, 2), "Minutes" });


                                laTable.Rows.Add(new Object[3] { "MinDwellArea (Desk)", dOccupation[0], "Minutes" });
                                laTable.Rows.Add(new Object[3] { "MaxDwellArea (Desk)", dOccupation[1], "Minutes" });
                                laTable.Rows.Add(new Object[3] { "MeanDwellArea (Desk)", Math.Round(dOccupation[2] / iPaxDesk, 2), "Minutes" });

                                if (MinQueueOccupation != -1)
                                {
                                    laTable.Rows.Add(new Object[3] { "MinQueueOccupation", MinQueueOccupation, "Passengers" });
                                    laTable.Rows.Add(new Object[3] { "MaxQueueOccupation", MaxQueueOccupation, "Passengers" });
                                    laTable.Rows.Add(new Object[3] { "MeanQueueOccupation", MeanQueueOccupation, "Passengers" });
                                }

                                // << Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                                laTable.Rows.Add(new Object[6] { "Min Delay Time (Desk)", dDelayTime[0], "Minutes"
                                    , delayTimeLevel1MinValue, delayTimeLevel2MinValue, delayTimeLevel3MinValue  });   // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                                laTable.Rows.Add(new Object[6] { "Max Delay Time (Desk)", dDelayTime[1], "Minutes"
                                    , delayTimeLevel1MaxValue, delayTimeLevel2MaxValue, delayTimeLevel3MaxValue });   // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                                laTable.Rows.Add(new Object[6] { "Mean Delay Time (Desk)", Math.Round(dDelayTime[2] / iPaxDesk, 2), "Minutes"
                                    , delayTimeLevel1AvgValue, delayTimeLevel2AvgValue, delayTimeLevel3AvgValue });   // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                                // >> Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                            }
                        }

                        if ((!IsGroup) && (!bIsLevel))
                        {
                            // << Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                            laTable.Rows.Add(new Object[6] { "Min Delay Time", MinDelayTime, "Minute(s)"
                                , delayTimeLevel1MinValue, delayTimeLevel2MinValue, delayTimeLevel3MinValue });   // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                            laTable.Rows.Add(new Object[6] { "Max Delay Time", MaxDelayTime, "Minute(s)"
                                , delayTimeLevel1MaxValue, delayTimeLevel2MaxValue, delayTimeLevel3MaxValue });   // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                            laTable.Rows.Add(new Object[6] { "Mean Delay Time", MeanDelayTime, "Minute(s)"
                                , delayTimeLevel1AvgValue, delayTimeLevel2AvgValue, delayTimeLevel3AvgValue });   // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                            // >> Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time

                            laTable.Rows.Add(new Object[6] { "MinWaitingDesk", MinWaitingDesk, "Minute(s)"
                                , waitingDeskTimeLevel1MinValue, waitingDeskTimeLevel2MinValue, waitingDeskTimeLevel3MinValue });   // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                            laTable.Rows.Add(new Object[6] { "MaxWaitingDesk", MaxWaitingDesk, "Minute(s)"
                                , waitingDeskTimeLevel1MaxValue, waitingDeskTimeLevel2MaxValue, waitingDeskTimeLevel3MaxValue });   // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                            laTable.Rows.Add(new Object[6] { "MeanWaitingDesk", MeanWaitingDesk, "Minute(s)"
                                , waitingDeskTimeLevel1AvgValue, waitingDeskTimeLevel2AvgValue, waitingDeskTimeLevel3AvgValue });   // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent

                            laTable.Rows.Add(new Object[6] { "MinWaitingGroup", MinWaitingGroup, "Minute(s)"
                                , waitingGroupTimeLevel1MinValue, waitingGroupTimeLevel2MinValue, waitingGroupTimeLevel3MinValue });  // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                            laTable.Rows.Add(new Object[6] { "MaxWaitingGroup", MaxWaitingGroup, "Minute(s)"
                                , waitingGroupTimeLevel1MaxValue, waitingGroupTimeLevel2MaxValue, waitingGroupTimeLevel3MaxValue });  // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent  
                            laTable.Rows.Add(new Object[6] { "MeanWaitingGroup", MeanWaitingGroup, "Minute(s)"
                                , waitingGroupTimeLevel1AvgValue, waitingGroupTimeLevel2AvgValue, waitingGroupTimeLevel3AvgValue });  // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent

                            laTable.Rows.Add(new Object[6] { "MinProcess", MinProcess, "Minute(s)"
                                , processTimeLevel1MinValue, processTimeLevel2MinValue, processTimeLevel3MinValue });   // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                            laTable.Rows.Add(new Object[6] { "MaxProcess", MaxProcess, "Minute(s)"
                                , processTimeLevel1MaxValue, processTimeLevel2MaxValue, processTimeLevel3MaxValue });   // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                            laTable.Rows.Add(new Object[6] { "MeanProcess", MeanProcess, "Minute(s)"
                                , processTimeLevel1AvgValue, processTimeLevel2AvgValue, processTimeLevel3AvgValue });   // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent

                            laTable.Rows.Add(new Object[6] { "MinDwellArea", MinDwellDesk, "Minute(s)"
                                , dwellAreaLevel1MinValue, dwellAreaLevel2MinValue, dwellAreaLevel3MinValue }); // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                            laTable.Rows.Add(new Object[6] { "MaxDwellArea", MaxDwellDesk, "Minute(s)"
                                , dwellAreaLevel1MaxValue, dwellAreaLevel2MaxValue, dwellAreaLevel3MaxValue }); // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                            laTable.Rows.Add(new Object[6] { "MeanDwellArea", MeanDwellDesk, "Minute(s)"
                                , dwellAreaLevel1AvgValue, dwellAreaLevel2AvgValue, dwellAreaLevel3AvgValue }); // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent

                            laTable.Rows.Add(new Object[6] { "MinQueueOccupation", MinQueueOccupation, "Passenger(s)",
                                minOccupationLevel1Value, minOccupationLevel2Value, minOccupationLevel3Value });    // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                            laTable.Rows.Add(new Object[6] { "MaxQueueOccupation", MaxQueueOccupation, "Passenger(s)",
                                maxOccupationLevel1Value, maxOccupationLevel2Value, maxOccupationLevel3Value });    // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                            laTable.Rows.Add(new Object[6] { "MeanQueueOccupation", MeanQueueOccupation, "Passenger(s)",
                                avgOccupationLevel1Value, avgOccupationLevel2Value, avgOccupationLevel3Value });    // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent

                            // >> Task #10440 Pax2Sim - Pax analysis - missing KPIs part 1
                            if (minThroughputIn != -1 && avgThroughputIn != -1 && maxThroughputIn != -1)
                            {
                                laTable.Rows.Add(new Object[6] { GlobalNames.MIN_THROUGHPUT_IN_SUMMARY_NAME, minThroughputIn, GlobalNames.SUMMARY_PASSENGER_UNIT_NAME,
                                    minThroughputInLevel1Value, minThroughputInLevel2Value, minThroughputInLevel3Value });
                                laTable.Rows.Add(new Object[6] { GlobalNames.AVG_THROUGHPUT_IN_SUMMARY_NAME, avgThroughputIn, GlobalNames.SUMMARY_PASSENGER_UNIT_NAME,
                                    avgThroughputInLevel1Value, avgThroughputInLevel2Value, avgThroughputInLevel3Value });
                                laTable.Rows.Add(new Object[6] { GlobalNames.MAX_THROUGHPUT_IN_SUMMARY_NAME, maxThroughputIn, GlobalNames.SUMMARY_PASSENGER_UNIT_NAME,
                                    maxThroughputInLevel1Value, maxThroughputInLevel2Value, maxThroughputInLevel3Value });
                            }

                            if (minThroughputOut != -1 && avgThroughputOut != -1 && maxThroughputOut != -1)
                            {
                                laTable.Rows.Add(new Object[6] { GlobalNames.MIN_THROUGHPUT_OUT_SUMMARY_NAME, minThroughputOut, GlobalNames.SUMMARY_PASSENGER_UNIT_NAME,
                                    minThroughputOutLevel1Value, minThroughputOutLevel2Value, minThroughputOutLevel3Value });
                                laTable.Rows.Add(new Object[6] { GlobalNames.AVG_THROUGHPUT_OUT_SUMMARY_NAME, avgThroughputOut, GlobalNames.SUMMARY_PASSENGER_UNIT_NAME,
                                    avgThroughputOutLevel1Value, avgThroughputOutLevel2Value, avgThroughputOutLevel3Value });
                                laTable.Rows.Add(new Object[6] { GlobalNames.MAX_THROUGHPUT_OUT_SUMMARY_NAME, maxThroughputOut, GlobalNames.SUMMARY_PASSENGER_UNIT_NAME,
                                    maxThroughputOutLevel1Value, maxThroughputOutLevel2Value, maxThroughputOutLevel3Value });
                            }

                            if (minRemainingTime != -1 && avgRemainingTime != -1 && maxRemainingTime != -1)
                            {
                                laTable.Rows.Add(new Object[6] { GlobalNames.MIN_REMAINING_TIME_SUMMARY_NAME, minRemainingTime, GlobalNames.SUMMARY_TIME_MINUTES_UNIT_NAME
                                    , remainingTimeLevel1MinValue, remainingTimeLevel2MinValue, remainingTimeLevel3MinValue }); // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                                laTable.Rows.Add(new Object[6] { GlobalNames.AVG_REMAINING_TIME_SUMMARY_NAME, avgRemainingTime, GlobalNames.SUMMARY_TIME_MINUTES_UNIT_NAME
                                    , remainingTimeLevel1AvgValue, remainingTimeLevel2AvgValue, remainingTimeLevel3AvgValue }); // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                                laTable.Rows.Add(new Object[6] { GlobalNames.MAX_REMAINING_TIME_SUMMARY_NAME, maxRemainingTime, GlobalNames.SUMMARY_TIME_MINUTES_UNIT_NAME
                                    , remainingTimeLevel1MaxValue, remainingTimeLevel2MaxValue, remainingTimeLevel3MaxValue }); // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                            }

                            if (minUtilizationPercent != -1 && avgUtilizationPercent != -1 && maxUtilizationPercent != -1)
                            {
                                laTable.Rows.Add(new Object[6] { GlobalNames.MIN_UTILIZATION_PERCENT_SUMMARY_NAME, minUtilizationPercent, GlobalNames.SUMMARY_PERCENT_UNIT_NAME,
                                    minUtilizationPercentLevel1Value, minUtilizationPercentLevel2Value, minUtilizationPercentLevel3Value });
                                laTable.Rows.Add(new Object[6] { GlobalNames.AVG_UTILIZATION_PERCENT_SUMMARY_NAME, avgUtilizationPercent, GlobalNames.SUMMARY_PERCENT_UNIT_NAME,
                                    avgUtilizationPercentLevel1Value, avgUtilizationPercentLevel2Value, avgUtilizationPercentLevel3Value });
                                laTable.Rows.Add(new Object[6] { GlobalNames.MAX_UTILIZATION_PERCENT_SUMMARY_NAME, maxUtilizationPercent, GlobalNames.SUMMARY_PERCENT_UNIT_NAME,
                                    maxUtilizationPercentLevel1Value, maxUtilizationPercentLevel2Value, maxUtilizationPercentLevel3Value });
                            }

                            if (minDeskNeed != -1 && avgDeskNeed != -1 && maxDeskNeed != -1)
                            {
                                laTable.Rows.Add(new Object[6] { GlobalNames.MIN_UTILIZATION_DESK_NEED_SUMMARY_NAME, minDeskNeed, GlobalNames.SUMMARY_DESK_UNIT_NAME,
                                    minDeskNeedLevel1Value, minDeskNeedLevel2Value, minDeskNeedLevel3Value });
                                laTable.Rows.Add(new Object[6] { GlobalNames.AVG_UTILIZATION_DESK_NEED_SUMMARY_NAME, avgDeskNeed, GlobalNames.SUMMARY_DESK_UNIT_NAME,
                                    avgDeskNeedLevel1Value, avgDeskNeedLevel2Value, avgDeskNeedLevel3Value });
                                laTable.Rows.Add(new Object[6] { GlobalNames.MAX_UTILIZATION_DESK_NEED_SUMMARY_NAME, maxDeskNeed, GlobalNames.SUMMARY_DESK_UNIT_NAME,
                                    maxDeskNeedLevel1Value, maxDeskNeedLevel2Value, maxDeskNeedLevel3Value });
                            }
                            // << Task #10440 Pax2Sim - Pax analysis - missing KPIs part 1

                            laTable.Rows.Add(new Object[6] { "TotalOpeningTime", TotalOpeningTime, "Minutes"
                                , TotalOpeningTime, TotalOpeningTime, TotalOpeningTime }); // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                            laTable.Rows.Add(new Object[6] { "TotalProcessTime", TotalProcessTime, "Minutes"
                                , totalProcessTimeLevel1Value, totalProcessTimeLevel2Value, totalProcessTimeLevel3Value }); // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                            laTable.Rows.Add(new Object[6] { "Rate", Rate, "", rateLevel1Value, rateLevel2Value, rateLevel3Value });    // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent

                        }
                    }
                    return laTable;
                }

                public override string ToString()
                {
                    return sDeskname;
                }
                #endregion

                // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                #region To summary table functions
                public DataTable toSummaryTable(double[] distributionLevels, String resourceTypeCode)
                {
                    DataTable summaryTable = new DataTable();

                    if (distributionLevels != null && distributionLevels.Length >= 3)
                    {
                        double distributionLevel1 = distributionLevels[0];
                        double distributionLevel2 = distributionLevels[1];
                        double distributionLevel3 = distributionLevels[2];

                        switch (resourceTypeCode)
                        {
                            case GlobalNames.AIRPORT_RESOURCE_TYPE_CODE:
                                {
                                    summaryTable = toAirportSummaryTable(distributionLevel1, distributionLevel2, distributionLevel3);
                                    break;
                                }
                            case GlobalNames.TERMINAL_RESOURCE_TYPE_CODE:
                                {
                                    summaryTable = toTerminalSummaryTable(distributionLevel1, distributionLevel2, distributionLevel3);
                                    break;
                                }
                            case GlobalNames.LEVEL_RESOURCE_TYPE_CODE:
                                {
                                    summaryTable = toLevelSummaryTable(distributionLevel1, distributionLevel2, distributionLevel3);
                                    break;
                                }
                            case GlobalNames.GROUP_RESOURCE_TYPE_CODE:
                                {
                                    summaryTable = toGroupSummaryTable(distributionLevel1, distributionLevel2, distributionLevel3);
                                    break;
                                }
                            case GlobalNames.DESK_RESOURCE_TYPE_CODE:
                                {
                                    summaryTable = toDeskSummaryTable(distributionLevel1, distributionLevel2, distributionLevel3);
                                    break;
                                }
                            default:
                                {
                                    break;
                                }
                        }
                    }
                    /*
                    summaryTable.TableName = GlobalNames.SUMMARY_TABLE_NAME_PREFIX 
                        + sDeskname + GlobalNames.SUMMARY_TABLE_NAME_SUFFIX;
                     */
                    summaryTable.TableName = sDeskname;

                    return summaryTable;
                }

                public DataTable toAirportSummaryTable(double distributionLevel1,
                    double distributionLevel2, double distributionLevel3)
                {
                    DataTable airportSummaryTable
                        = new DataTable(GlobalNames.SUMMARY_TABLE_NAME_PREFIX
                                        + sDeskname + GlobalNames.SUMMARY_TABLE_NAME_SUFFIX);

                    #region summary table structure
                    int kpiIdColumnIndex = airportSummaryTable.Columns.Count;
                    airportSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_KPI_ID_COLUMN_NAME, typeof(Int32));

                    int dataColumnIndex = airportSummaryTable.Columns.Count;
                    airportSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_DATA_COLUMN_NAME, typeof(String));

                    int valueColumnIndex = airportSummaryTable.Columns.Count;
                    airportSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_VALUE_COLUMN_NAME, typeof(Double));

                    int minValueColumnIndex = airportSummaryTable.Columns.Count;
                    airportSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_MIN_VALUE_COLUMN_NAME, typeof(Double));

                    int avgValueColumnIndex = airportSummaryTable.Columns.Count;
                    airportSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_AVG_VALUE_COLUMN_NAME, typeof(Double));

                    int maxValueColumnIndex = airportSummaryTable.Columns.Count;
                    airportSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_MAX_VALUE_COLUMN_NAME, typeof(Double));

                    int unitColumnIndex = airportSummaryTable.Columns.Count;
                    airportSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_UNIT_COLUMN_NAME, typeof(String));
                    #endregion

                    #region summary data
                    int kpiId = 0;
                    addNewRowToSummaryTable(airportSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_TOTAL_PAX_NB, PaxNumber,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(airportSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_TRANSFER_PAX_NB, PaxTransfer,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(airportSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_MISSED_PAX_NB, PaxMissed,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(airportSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_STOPPED_PAX_NB, PaxStopped,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(airportSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_LOST_PAX_NB, PaxLost,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(airportSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, -1,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_AREA_OCCUPATION, totalOccupation,
                                            MinQueueOccupation, MeanQueueOccupation, MaxQueueOccupation,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    #endregion

                    return airportSummaryTable;
                }
                public DataTable toTerminalSummaryTable(double distributionLevel1,
                    double distributionLevel2, double distributionLevel3)
                {
                    DataTable terminalSummaryTable
                        = new DataTable(GlobalNames.SUMMARY_TABLE_NAME_PREFIX
                                        + sDeskname + GlobalNames.SUMMARY_TABLE_NAME_SUFFIX);

                    #region summary table structure
                    int kpiIdColumnIndex = terminalSummaryTable.Columns.Count;
                    terminalSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_KPI_ID_COLUMN_NAME, typeof(Int32));

                    int dataColumnIndex = terminalSummaryTable.Columns.Count;
                    terminalSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_DATA_COLUMN_NAME, typeof(String));

                    int valueColumnIndex = terminalSummaryTable.Columns.Count;
                    terminalSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_VALUE_COLUMN_NAME, typeof(Double));

                    int minValueColumnIndex = terminalSummaryTable.Columns.Count;
                    terminalSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_MIN_VALUE_COLUMN_NAME, typeof(Double));

                    int avgValueColumnIndex = terminalSummaryTable.Columns.Count;
                    terminalSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_AVG_VALUE_COLUMN_NAME, typeof(Double));

                    int maxValueColumnIndex = terminalSummaryTable.Columns.Count;
                    terminalSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_MAX_VALUE_COLUMN_NAME, typeof(Double));

                    int unitColumnIndex = terminalSummaryTable.Columns.Count;
                    terminalSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_UNIT_COLUMN_NAME, typeof(String));
                    #endregion

                    #region summary data
                    int kpiId = 0;
                    addNewRowToSummaryTable(terminalSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_TOTAL_PAX_NB, PaxNumber,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(terminalSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_TRANSFER_PAX_NB, PaxTransfer,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(terminalSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_MISSED_PAX_NB, PaxMissed,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(terminalSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_STOPPED_PAX_NB, PaxStopped,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(terminalSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_LOST_PAX_NB, PaxLost,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(terminalSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, -1,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_AREA_OCCUPATION, 0,
                                            MinQueueOccupation, MeanQueueOccupation, MaxQueueOccupation,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    #endregion

                    return terminalSummaryTable;
                }
                public DataTable toLevelSummaryTable(double distributionLevel1,
                    double distributionLevel2, double distributionLevel3)
                {
                    DataTable levelSummaryTable
                        = new DataTable(GlobalNames.SUMMARY_TABLE_NAME_PREFIX
                                        + sDeskname + GlobalNames.SUMMARY_TABLE_NAME_SUFFIX);

                    #region summary table structure
                    int kpiIdColumnIndex = levelSummaryTable.Columns.Count;
                    levelSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_KPI_ID_COLUMN_NAME, typeof(Int32));

                    int dataColumnIndex = levelSummaryTable.Columns.Count;
                    levelSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_DATA_COLUMN_NAME, typeof(String));

                    int valueColumnIndex = levelSummaryTable.Columns.Count;
                    levelSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_VALUE_COLUMN_NAME, typeof(Double));

                    int minValueColumnIndex = levelSummaryTable.Columns.Count;
                    levelSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_MIN_VALUE_COLUMN_NAME, typeof(Double));

                    int avgValueColumnIndex = levelSummaryTable.Columns.Count;
                    levelSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_AVG_VALUE_COLUMN_NAME, typeof(Double));

                    int maxValueColumnIndex = levelSummaryTable.Columns.Count;
                    levelSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_MAX_VALUE_COLUMN_NAME, typeof(Double));

                    int unitColumnIndex = levelSummaryTable.Columns.Count;
                    levelSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_UNIT_COLUMN_NAME, typeof(String));
                    #endregion

                    #region summary data
                    int kpiId = 0;
                    addNewRowToSummaryTable(levelSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_TOTAL_PAX_NB, PaxNumber,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(levelSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_TRANSFER_PAX_NB, PaxTransfer,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(levelSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_MISSED_PAX_NB, PaxMissed,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(levelSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_STOPPED_PAX_NB, PaxStopped,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(levelSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_LOST_PAX_NB, PaxLost,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(levelSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, -1,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_AREA_OCCUPATION, 0,
                                            MinQueueOccupation, MeanQueueOccupation, MaxQueueOccupation,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    #endregion

                    return levelSummaryTable;
                }
                public DataTable toGroupSummaryTable(double distributionLevel1,
                    double distributionLevel2, double distributionLevel3)
                {
                    DataTable groupSummaryTable
                        = new DataTable(GlobalNames.SUMMARY_TABLE_NAME_PREFIX
                                        + sDeskname + GlobalNames.SUMMARY_TABLE_NAME_SUFFIX);

                    #region summary table structure
                    int kpiIdColumnIndex = groupSummaryTable.Columns.Count;
                    groupSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_KPI_ID_COLUMN_NAME, typeof(Int32));

                    int dataColumnIndex = groupSummaryTable.Columns.Count;
                    groupSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_DATA_COLUMN_NAME, typeof(String));

                    int valueColumnIndex = groupSummaryTable.Columns.Count;
                    groupSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_VALUE_COLUMN_NAME, typeof(Double));

                    int minValueColumnIndex = groupSummaryTable.Columns.Count;
                    groupSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_MIN_VALUE_COLUMN_NAME, typeof(Double));

                    int avgValueColumnIndex = groupSummaryTable.Columns.Count;
                    groupSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_AVG_VALUE_COLUMN_NAME, typeof(Double));

                    int maxValueColumnIndex = groupSummaryTable.Columns.Count;
                    groupSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_MAX_VALUE_COLUMN_NAME, typeof(Double));

                    int maxLevel1ValueColumnIndex = groupSummaryTable.Columns.Count;
                    groupSummaryTable.Columns
                        .Add(distributionLevel1 + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(Double));

                    int maxLevel2ValueColumnIndex = groupSummaryTable.Columns.Count;
                    groupSummaryTable.Columns
                        .Add(distributionLevel2 + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(Double));

                    int maxLevel3ValueColumnIndex = groupSummaryTable.Columns.Count;
                    groupSummaryTable.Columns
                        .Add(distributionLevel3 + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(Double));
                    /* // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                    int minLevel2ValueColumnIndex = groupSummaryTable.Columns.Count;
                    groupSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_MIN_VALUE_FOR_LEVEL_COLUMN_PARTIAL_NAME
                            + distributionLevel2 + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(Double));

                    int avgLevel2ValueColumnIndex = groupSummaryTable.Columns.Count;
                    groupSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_AVG_VALUE_FOR_LEVEL_COLUMN_PARTIAL_NAME
                            + distributionLevel2 + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(Double));

                    int maxLevel2ValueColumnIndex = groupSummaryTable.Columns.Count;
                    groupSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_MAX_VALUE_FOR_LEVEL_COLUMN_PARTIAL_NAME
                            + distributionLevel2 + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(Double));

                    int minLevel3ValueColumnIndex = groupSummaryTable.Columns.Count;
                    groupSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_MIN_VALUE_FOR_LEVEL_COLUMN_PARTIAL_NAME
                            + distributionLevel3 + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(Double));

                    int avgLevel3ValueColumnIndex = groupSummaryTable.Columns.Count;
                    groupSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_AVG_VALUE_FOR_LEVEL_COLUMN_PARTIAL_NAME
                            + distributionLevel3 + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(Double));

                    int maxLevel3ValueColumnIndex = groupSummaryTable.Columns.Count;
                    groupSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_MAX_VALUE_FOR_LEVEL_COLUMN_PARTIAL_NAME
                            + distributionLevel3 + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(Double));
                    */
                    int unitColumnIndex = groupSummaryTable.Columns.Count;
                    groupSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_UNIT_COLUMN_NAME, typeof(String));
                    #endregion

                    #region summary data
                    int kpiId = 0;
                    addNewRowToSummaryTable(groupSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_TOTAL_PAX_NB, PaxNumber,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(groupSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_TOTAL_PROCESSED_PAX_NB, ProcessedPax,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(groupSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_TRANSFER_PAX_NB, PaxTransfer,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(groupSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_MISSED_PAX_NB, PaxMissed,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(groupSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_STOPPED_PAX_NB, PaxStopped,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(groupSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_LOST_PAX_NB, PaxLost,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(groupSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            maxLevel1ValueColumnIndex, maxLevel2ValueColumnIndex, maxLevel3ValueColumnIndex,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_TOTAL_TIME, totalTimeForAllPaxInStation,
                                            minTotalTime, avgTotalTime, maxTotalTime,
                                            totalTimeLevel1MaxValue, totalTimeLevel2MaxValue, totalTimeLevel3MaxValue,
                                            GlobalNames.SUMMARY_TIME_MINUTES_UNIT_NAME);

                    addNewRowToSummaryTable(groupSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            maxLevel1ValueColumnIndex, maxLevel2ValueColumnIndex, maxLevel3ValueColumnIndex,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_WAITING, totalWaitingDeskAndGroupTime,
                                            MinWaiting, MeanWaiting, MaxWaiting,
                                            waitingTimeLevel1MaxValue, waitingTimeLevel2MaxValue, waitingTimeLevel3MaxValue,
                                            GlobalNames.SUMMARY_TIME_MINUTES_UNIT_NAME);

                    addNewRowToSummaryTable(groupSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            maxLevel1ValueColumnIndex, maxLevel2ValueColumnIndex, maxLevel3ValueColumnIndex,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_DELAY_TIME, totalDelayTime,
                                            MinDelayTime, MeanDelayTime, MaxDelayTime,
                                            delayTimeLevel1MaxValue, delayTimeLevel2MaxValue, delayTimeLevel3MaxValue,
                                            GlobalNames.SUMMARY_TIME_MINUTES_UNIT_NAME);

                    addNewRowToSummaryTable(groupSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            maxLevel1ValueColumnIndex, maxLevel2ValueColumnIndex, maxLevel3ValueColumnIndex,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_WAITING_DESK, totalWaitingDeskTime,
                                            MinWaitingDesk, MeanWaitingDesk, MaxWaitingDesk,
                                            waitingDeskTimeLevel1MaxValue, waitingDeskTimeLevel2MaxValue, waitingDeskTimeLevel3MaxValue,
                                            GlobalNames.SUMMARY_TIME_MINUTES_UNIT_NAME);

                    addNewRowToSummaryTable(groupSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            maxLevel1ValueColumnIndex, maxLevel2ValueColumnIndex, maxLevel3ValueColumnIndex,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_WAITING_GROUP, totalWaitingGroupTime,
                                            MinWaitingGroup, MeanWaitingGroup, MaxWaitingGroup,
                                            waitingGroupTimeLevel1MaxValue, waitingGroupTimeLevel2MaxValue, waitingGroupTimeLevel3MaxValue,
                                            GlobalNames.SUMMARY_TIME_MINUTES_UNIT_NAME);

                    addNewRowToSummaryTable(groupSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            maxLevel1ValueColumnIndex, maxLevel2ValueColumnIndex, maxLevel3ValueColumnIndex,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_PROCESS, totalProcessTime,
                                            MinProcess, MeanProcess, MaxProcess,
                                            processTimeLevel1MaxValue, processTimeLevel2MaxValue, processTimeLevel3MaxValue,
                                            GlobalNames.SUMMARY_TIME_MINUTES_UNIT_NAME);

                    addNewRowToSummaryTable(groupSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_DWELL_AREA, totalDwellArea,
                                            MinDwellDesk, MeanDwellDesk, MaxDwellDesk,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_TIME_MINUTES_UNIT_NAME);

                    addNewRowToSummaryTable(groupSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            maxLevel1ValueColumnIndex, maxLevel2ValueColumnIndex, maxLevel3ValueColumnIndex,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_REMAINING_TIME, totalRemainingTime,
                                            minRemainingTime, avgRemainingTime, maxRemainingTime,
                                            remainingTimeLevel1MaxValue, remainingTimeLevel2MaxValue, remainingTimeLevel3MaxValue,
                                            GlobalNames.SUMMARY_TIME_MINUTES_UNIT_NAME);

                    addNewRowToSummaryTable(groupSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, -1,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_QUEUE_OCCUPATION, 0,
                                            MinQueueOccupation, MeanQueueOccupation, MaxQueueOccupation,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(groupSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_THROUGHPUT_NB_PAX_IN, totalOccupationPaxIn,
                                            minOccupationPaxIn, avgOccupationPaxIn, maxOccupationPaxIn,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(groupSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_THROUGHPUT_NB_PAX_OUT, totalOccupationPaxOut,
                                            minOccupationPaxOut, avgOccupationPaxOut, maxOccupationPaxOut,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(groupSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, -1,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_THROUGHPUT_INPUT, 0,
                                            minThroughputIn, avgThroughputIn, maxThroughputIn,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PAX_PER_HOUR_UNIT_NAME);

                    // >> Task #13762 Pax2Sim - Dynamic Analysis - Occupation table
                    addNewRowToSummaryTable(groupSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, -1,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_THROUGHPUT_INSTANT_INPUT, 0,
                                            minThroughputInstantIn, avgThroughputInstantIn, maxThroughputInstantIn,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PAX_PER_HOUR_UNIT_NAME);

                    addNewRowToSummaryTable(groupSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, -1,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_THROUGHPUT_OUTPUT, 0,
                                            minThroughputOut, avgThroughputOut, maxThroughputOut,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PAX_PER_HOUR_UNIT_NAME);

                    // >> Task #13762 Pax2Sim - Dynamic Analysis - Occupation table
                    addNewRowToSummaryTable(groupSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, -1,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_THROUGHPUT_INSTANT_OUTPUT, 0,
                                            minThroughputInstantOut, avgThroughputInstantOut, maxThroughputInstantOut,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PAX_PER_HOUR_UNIT_NAME);

                    addNewRowToSummaryTable(groupSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, -1,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_UTILIZATION_PERCENT, 0,
                                            minUtilizationPercent, avgUtilizationPercent, maxUtilizationPercent,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PERCENT_UNIT_NAME);

                    addNewRowToSummaryTable(groupSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, -1,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_DESK_NEED, 0,
                                            minDeskNeed, avgDeskNeed, maxDeskNeed,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_DESK_UNIT_NAME);

                    addNewRowToSummaryTable(groupSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_TOTAL_OPENING_TIME, TotalOpeningTime,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_TIME_MINUTES_UNIT_NAME);

                    addNewRowToSummaryTable(groupSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_TOTAL_PROCESS_TIME, TotalProcessTime,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_TIME_MINUTES_UNIT_NAME);

                    addNewRowToSummaryTable(groupSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_RATE, Rate,
                                            0, 0, 0,
                                            0, 0, 0,
                                            "");
                    #endregion

                    return groupSummaryTable;
                }
                public DataTable toDeskSummaryTable(double distributionLevel1,
                    double distributionLevel2, double distributionLevel3)
                {
                    DataTable deskSummaryTable
                        = new DataTable(GlobalNames.SUMMARY_TABLE_NAME_PREFIX
                                        + sDeskname + GlobalNames.SUMMARY_TABLE_NAME_SUFFIX);

                    #region summary table structure
                    int kpiIdColumnIndex = deskSummaryTable.Columns.Count;
                    deskSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_KPI_ID_COLUMN_NAME, typeof(Int32));

                    int dataColumnIndex = deskSummaryTable.Columns.Count;
                    deskSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_DATA_COLUMN_NAME, typeof(String));

                    int valueColumnIndex = deskSummaryTable.Columns.Count;
                    deskSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_VALUE_COLUMN_NAME, typeof(Double));

                    int minValueColumnIndex = deskSummaryTable.Columns.Count;
                    deskSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_MIN_VALUE_COLUMN_NAME, typeof(Double));

                    int avgValueColumnIndex = deskSummaryTable.Columns.Count;
                    deskSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_AVG_VALUE_COLUMN_NAME, typeof(Double));

                    int maxValueColumnIndex = deskSummaryTable.Columns.Count;
                    deskSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_MAX_VALUE_COLUMN_NAME, typeof(Double));

                    // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes                    
                    int maxLevel1ValueColumnIndex = deskSummaryTable.Columns.Count;
                    deskSummaryTable.Columns
                        .Add(distributionLevel1 + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(Double));

                    int maxLevel2ValueColumnIndex = deskSummaryTable.Columns.Count;
                    deskSummaryTable.Columns
                        .Add(distributionLevel2 + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(Double));

                    int maxLevel3ValueColumnIndex = deskSummaryTable.Columns.Count;
                    deskSummaryTable.Columns
                        .Add(distributionLevel3 + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(Double));
                    // << Task #10615 Pax2Sim - Pax analysis - Summary - small changes

                    /*  // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                    int minLevel1ValueColumnIndex = deskSummaryTable.Columns.Count;
                    deskSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_MIN_VALUE_FOR_LEVEL_COLUMN_PARTIAL_NAME
                            + distributionLevel1 + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(Double));
                    
                    int avgLevel1ValueColumnIndex = deskSummaryTable.Columns.Count;
                    deskSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_AVG_VALUE_FOR_LEVEL_COLUMN_PARTIAL_NAME
                            + distributionLevel1 + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(Double));

                    int maxLevel1ValueColumnIndex = deskSummaryTable.Columns.Count;
                    deskSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_MAX_VALUE_FOR_LEVEL_COLUMN_PARTIAL_NAME
                            + distributionLevel1 + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(Double));
                    
                    int minLevel2ValueColumnIndex = deskSummaryTable.Columns.Count;
                    deskSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_MIN_VALUE_FOR_LEVEL_COLUMN_PARTIAL_NAME
                            + distributionLevel2 + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(Double));

                    int avgLevel2ValueColumnIndex = deskSummaryTable.Columns.Count;
                    deskSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_AVG_VALUE_FOR_LEVEL_COLUMN_PARTIAL_NAME
                            + distributionLevel2 + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(Double));

                    int maxLevel2ValueColumnIndex = deskSummaryTable.Columns.Count;
                    deskSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_MAX_VALUE_FOR_LEVEL_COLUMN_PARTIAL_NAME
                            + distributionLevel2 + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(Double));

                    int minLevel3ValueColumnIndex = deskSummaryTable.Columns.Count;
                    deskSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_MIN_VALUE_FOR_LEVEL_COLUMN_PARTIAL_NAME
                            + distributionLevel3 + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(Double));

                    int avgLevel3ValueColumnIndex = deskSummaryTable.Columns.Count;
                    deskSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_AVG_VALUE_FOR_LEVEL_COLUMN_PARTIAL_NAME
                            + distributionLevel3 + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(Double));

                    int maxLevel3ValueColumnIndex = deskSummaryTable.Columns.Count;
                    deskSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_MAX_VALUE_FOR_LEVEL_COLUMN_PARTIAL_NAME
                            + distributionLevel3 + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(Double));
                    */
                    int unitColumnIndex = deskSummaryTable.Columns.Count;
                    deskSummaryTable.Columns
                        .Add(GlobalNames.SUMMARY_TABLE_UNIT_COLUMN_NAME, typeof(String));
                    #endregion

                    #region summary data
                    int kpiId = 0;
                    addNewRowToSummaryTable(deskSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_TOTAL_PAX_NB, PaxNumber,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(deskSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_TOTAL_PROCESSED_PAX_NB, ProcessedPax,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(deskSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_TRANSFER_PAX_NB, PaxTransfer,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(deskSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_MISSED_PAX_NB, PaxMissed,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(deskSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_STOPPED_PAX_NB, PaxStopped,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(deskSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_LOST_PAX_NB, PaxLost,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(deskSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            maxLevel1ValueColumnIndex, maxLevel2ValueColumnIndex, maxLevel3ValueColumnIndex,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_TOTAL_TIME, totalTimeForAllPaxInStation,
                                            minTotalTime, avgTotalTime, maxTotalTime,
                                            totalTimeLevel1MaxValue, totalTimeLevel2MaxValue, totalTimeLevel3MaxValue,
                                            GlobalNames.SUMMARY_TIME_MINUTES_UNIT_NAME);

                    addNewRowToSummaryTable(deskSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            maxLevel1ValueColumnIndex, maxLevel2ValueColumnIndex, maxLevel3ValueColumnIndex,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_WAITING, totalWaitingDeskAndGroupTime,
                                            MinWaiting, MeanWaiting, MaxWaiting,
                                            waitingTimeLevel1MaxValue, waitingTimeLevel2MaxValue, waitingTimeLevel3MaxValue,
                                            GlobalNames.SUMMARY_TIME_MINUTES_UNIT_NAME);

                    addNewRowToSummaryTable(deskSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            maxLevel1ValueColumnIndex, maxLevel2ValueColumnIndex, maxLevel3ValueColumnIndex,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_DELAY_TIME, totalDelayTime,
                                            MinDelayTime, MeanDelayTime, MaxDelayTime,
                                            delayTimeLevel1MaxValue, delayTimeLevel2MaxValue, delayTimeLevel3MaxValue,
                                            GlobalNames.SUMMARY_TIME_MINUTES_UNIT_NAME);

                    addNewRowToSummaryTable(deskSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            maxLevel1ValueColumnIndex, maxLevel2ValueColumnIndex, maxLevel3ValueColumnIndex,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_WAITING_DESK, totalWaitingDeskTime,
                                            MinWaitingDesk, MeanWaitingDesk, MaxWaitingDesk,
                                            waitingDeskTimeLevel1MaxValue, waitingDeskTimeLevel2MaxValue, waitingDeskTimeLevel3MaxValue,
                                            GlobalNames.SUMMARY_TIME_MINUTES_UNIT_NAME);

                    addNewRowToSummaryTable(deskSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            maxLevel1ValueColumnIndex, maxLevel2ValueColumnIndex, maxLevel3ValueColumnIndex,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_WAITING_GROUP, totalWaitingGroupTime,
                                            MinWaitingGroup, MeanWaitingGroup, MaxWaitingGroup,
                                            waitingGroupTimeLevel1MaxValue, waitingGroupTimeLevel2MaxValue, waitingGroupTimeLevel3MaxValue,
                                            GlobalNames.SUMMARY_TIME_MINUTES_UNIT_NAME);

                    addNewRowToSummaryTable(deskSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            maxLevel1ValueColumnIndex, maxLevel2ValueColumnIndex, maxLevel3ValueColumnIndex,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_PROCESS, totalProcessTime,
                                            MinProcess, MeanProcess, MaxProcess,
                                            processTimeLevel1MaxValue, processTimeLevel2MaxValue, processTimeLevel3MaxValue,
                                            GlobalNames.SUMMARY_TIME_MINUTES_UNIT_NAME);

                    addNewRowToSummaryTable(deskSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_DWELL_AREA, totalDwellArea,
                                            MinDwellDesk, MeanDwellDesk, MaxDwellDesk,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_TIME_MINUTES_UNIT_NAME);

                    addNewRowToSummaryTable(deskSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            maxLevel1ValueColumnIndex, maxLevel2ValueColumnIndex, maxLevel3ValueColumnIndex,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_REMAINING_TIME, totalRemainingTime,
                                            minRemainingTime, avgRemainingTime, maxRemainingTime,
                                            remainingTimeLevel1MaxValue, remainingTimeLevel2MaxValue, remainingTimeLevel3MaxValue,
                                            GlobalNames.SUMMARY_TIME_MINUTES_UNIT_NAME);

                    addNewRowToSummaryTable(deskSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, -1,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_QUEUE_OCCUPATION, 0,
                                            MinQueueOccupation, MeanQueueOccupation, MaxQueueOccupation,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(deskSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_THROUGHPUT_NB_PAX_IN, totalOccupationPaxIn,
                                            minOccupationPaxIn, avgOccupationPaxIn, maxOccupationPaxIn,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(deskSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_THROUGHPUT_NB_PAX_OUT, totalOccupationPaxOut,
                                            minOccupationPaxOut, avgOccupationPaxOut, maxOccupationPaxOut,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PASSENGER_UNIT_NAME);

                    addNewRowToSummaryTable(deskSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, -1,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_THROUGHPUT_INPUT, 0,
                                            minThroughputIn, avgThroughputIn, maxThroughputIn,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PAX_PER_HOUR_UNIT_NAME);

                    // >> Task #13762 Pax2Sim - Dynamic Analysis - Occupation table
                    addNewRowToSummaryTable(deskSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, -1,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_THROUGHPUT_INSTANT_INPUT, 0,
                                            minThroughputInstantIn, avgThroughputInstantIn, maxThroughputInstantIn,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PAX_PER_HOUR_UNIT_NAME);

                    addNewRowToSummaryTable(deskSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, -1,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_THROUGHPUT_OUTPUT, 0,
                                            minThroughputOut, avgThroughputOut, maxThroughputOut,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PAX_PER_HOUR_UNIT_NAME);

                    // >> Task #13762 Pax2Sim - Dynamic Analysis - Occupation table
                    addNewRowToSummaryTable(deskSummaryTable,
                                         kpiIdColumnIndex, dataColumnIndex, -1,
                                         minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                         -1, -1, -1,
                                         unitColumnIndex,
                                         ++kpiId, GlobalNames.SUMMARY_KPI_NAME_THROUGHPUT_INSTANT_OUTPUT, 0,
                                         minThroughputInstantOut, avgThroughputInstantOut, maxThroughputInstantOut,
                                         0, 0, 0,
                                         GlobalNames.SUMMARY_PAX_PER_HOUR_UNIT_NAME);

                    addNewRowToSummaryTable(deskSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, -1,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_UTILIZATION_PERCENT, 0,
                                            minUtilizationPercent, avgUtilizationPercent, maxUtilizationPercent,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_PERCENT_UNIT_NAME);

                    addNewRowToSummaryTable(deskSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_TOTAL_OPENING_TIME, TotalOpeningTime,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_TIME_MINUTES_UNIT_NAME);

                    addNewRowToSummaryTable(deskSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_TOTAL_PROCESS_TIME, TotalProcessTime,
                                            0, 0, 0,
                                            0, 0, 0,
                                            GlobalNames.SUMMARY_TIME_MINUTES_UNIT_NAME);

                    addNewRowToSummaryTable(deskSummaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            -1, -1, -1,
                                            -1, -1, -1,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_RATE, Rate,
                                            0, 0, 0,
                                            0, 0, 0,
                                            "");
                    #endregion

                    return deskSummaryTable;
                }

                public static void addNewRowToSummaryTable(DataTable summaryTable,
                    int kpiIdColumnIndex, int dataColumnIndex, int valueColumnIndex,
                    int minValueColumnIndex, int avgValueColumnIndex, int maxValueColumnIndex,
                    int maxLevel1ValueColumnIndex, int maxLevel2ValueColumnIndex, int maxLevel3ValueColumnIndex,
                    //int minLevel2ValueColumnIndex, int avgLevel2ValueColumnIndex, int maxLevel2ValueColumnIndex,  // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                    //int minLevel3ValueColumnIndex, int avgLevel3ValueColumnIndex, int maxLevel3ValueColumnIndex,
                    int unitColumnIndex,
                    int kpiId, String dataName, double value, double minValue, double avgValue, double maxValue,
                    double maxLevel1Value, double maxLevel2Value, double maxLevel3Value,
                    //double minLevel2Value, double avgLevel2Value, double maxLevel2Value,  // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                    //double minLevel3Value, double avgLevel3Value, double maxLevel3Value,
                    String unitName)
                {
                    DataRow newRow = summaryTable.NewRow();
                    if (kpiIdColumnIndex != -1)
                        newRow[kpiIdColumnIndex] = kpiId;
                    if (dataColumnIndex != -1)
                        newRow[dataColumnIndex] = dataName;

                    if (valueColumnIndex != -1)
                        newRow[valueColumnIndex] = value;
                    if (minValueColumnIndex != -1)
                        newRow[minValueColumnIndex] = minValue;
                    if (avgValueColumnIndex != -1)
                        newRow[avgValueColumnIndex] = avgValue;
                    if (maxValueColumnIndex != -1)
                        newRow[maxValueColumnIndex] = maxValue;

                    /*if (minLevel1ValueColumnIndex != -1)
                        newRow[minLevel1ValueColumnIndex] = minLevel1Value;
                    if (avgLevel1ValueColumnIndex != -1)
                        newRow[avgLevel1ValueColumnIndex] = avgLevel1Value;*/
                    if (maxLevel1ValueColumnIndex != -1)
                        newRow[maxLevel1ValueColumnIndex] = maxLevel1Value;

                    /*if (minLevel2ValueColumnIndex != -1)
                        newRow[minLevel2ValueColumnIndex] = minLevel2Value;
                    if (avgLevel2ValueColumnIndex != -1)
                        newRow[avgLevel2ValueColumnIndex] = avgLevel2Value;*/
                    if (maxLevel2ValueColumnIndex != -1)
                        newRow[maxLevel2ValueColumnIndex] = maxLevel2Value;

                    /*if (minLevel3ValueColumnIndex != -1)
                        newRow[minLevel3ValueColumnIndex] = minLevel3Value;
                    if (avgLevel3ValueColumnIndex != -1)
                        newRow[avgLevel3ValueColumnIndex] = avgLevel3Value;*/
                    if (maxLevel3ValueColumnIndex != -1)
                        newRow[maxLevel3ValueColumnIndex] = maxLevel3Value;

                    if (unitColumnIndex != -1)
                        newRow[unitColumnIndex] = unitName;

                    summaryTable.Rows.Add(newRow);
                    summaryTable.AcceptChanges();
                }

                #endregion
                // << Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent

                // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                internal void addOccupationPaxInStats(Double pTotalValue, Double pMin,
                    Double pAvg, Double pMax)
                {
                    totalOccupationPaxIn_ = pTotalValue;
                    minOccupationPaxIn_ = pMin;
                    avgOccupationPaxIn_ = pAvg;
                    maxOccupationPaxIn_ = pMax;
                }
                internal void addOccupationPaxOutStats(Double pTotalValue, Double pMin,
                    Double pAvg, Double pMax)
                {
                    totalOccupationPaxOut_ = pTotalValue;
                    minOccupationPaxOut_ = pMin;
                    avgOccupationPaxOut_ = pAvg;
                    maxOccupationPaxOut_ = pMax;
                }
                // << Task #10615 Pax2Sim - Pax analysis - Summary - small changes

                // >> Task #10440 Pax2Sim - Pax analysis - missing KPIs part 1
                internal void addOccupationThroughputInStats(Double pMinThroughputIn,
                    Double pAvgThroughputIn, Double pMaxThroughputIn)
                {
                    minThroughputIn_ = pMinThroughputIn;
                    avgThroughputIn_ = pAvgThroughputIn;
                    maxThroughputIn_ = pMaxThroughputIn;
                }

                internal void addOccupationThroughputOutStats(Double pMinThroughputOut,
                    Double pAvgThroughputOut, Double pMaxThroughputOut)
                {
                    minThroughputOut_ = pMinThroughputOut;
                    avgThroughputOut_ = pAvgThroughputOut;
                    maxThroughputOut_ = pMaxThroughputOut;
                }

                internal void addOccupationThroughputInstantInStats(Double pMinThroughputIn,
                    Double pAvgThroughputIn, Double pMaxThroughputIn)
                {
                    minThroughputInstantIn_ = pMinThroughputIn;
                    avgThroughputInstantIn_ = pAvgThroughputIn;
                    maxThroughputInstantIn_ = pMaxThroughputIn;
                }

                internal void addOccupationThroughputInstantOutStats(Double pMinThroughputOut,
                    Double pAvgThroughputOut, Double pMaxThroughputOut)
                {
                    minThroughputInstantOut_ = pMinThroughputOut;
                    avgThroughputInstantOut_ = pAvgThroughputOut;
                    maxThroughputInstantOut_ = pMaxThroughputOut;
                }

                internal void addRemainingTimeStats(Double pMinRemainingTime,
                    Double pAvgRemainingTime, Double pMaxRemainingTime)
                {
                    minRemainingTime_ = pMinRemainingTime;
                    avgRemainingTime_ = pAvgRemainingTime;
                    maxRemainingTime_ = pMaxRemainingTime;
                }

                internal void addUtilizationPercentStats(Double pMinUtilizationPercent,
                    Double pAvgUtilizationPercent, Double pMaxUtilizationPercent)
                {
                    minUtilizationPercent_ = pMinUtilizationPercent;
                    avgUtilizationPercent_ = pAvgUtilizationPercent;
                    maxUtiliaztionPercent_ = pMaxUtilizationPercent;
                }

                internal void addDeskNeedStats(Double pMinDeskNeed, Double pAvgDeskNeed,
                    Double pMaxDeskNeed)
                {
                    minDeskNeed_ = pMinDeskNeed;
                    avgDeskNeed_ = pAvgDeskNeed;
                    maxDeskNeed_ = pMaxDeskNeed;
                }
                // << Task #10440 Pax2Sim - Pax analysis - missing KPIs part 1

                // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                internal void addTotalTimeMaxLevelsStats(Double pMaxTotalTimeLevel1,
                    Double pMaxTotalTimeLevel2, Double pMaxTotalTimeLevel3)
                {
                    totalTimeLevel1MaxValue_ = pMaxTotalTimeLevel1;
                    totalTimeLevel2MaxValue_ = pMaxTotalTimeLevel2;
                    totalTimeLevel3MaxValue_ = pMaxTotalTimeLevel3;
                }

                internal void addOccupationLevel1Stats(Double pMinOccupationLevel1, Double pAvgOccupationLevel1,
                    Double pMaxOccupationLevel1, Double pMinThroughputInLevel1, Double pAvgThroughputInLevel1,
                    Double pMaxThroughputInLevel1, Double pMinThroughputOutLevel1, Double pAvgThroughputOutLevel1,
                    Double pMaxThroughputOutLevel1)
                {
                    minOccupationLevel1Value_ = pMinOccupationLevel1;
                    avgOccupationLevel1Value_ = pAvgOccupationLevel1;
                    maxOccupationLevel1Value_ = pMaxOccupationLevel1;

                    minThroughputInLevel1Value_ = pMinThroughputInLevel1;
                    avgThroughputInLevel1Value_ = pAvgThroughputInLevel1;
                    maxThroughputInLevel1Value_ = pMaxThroughputInLevel1;

                    minThroughputOutLevel1Value_ = pMinThroughputOutLevel1;
                    avgThroughputOutLevel1Value_ = pAvgThroughputOutLevel1;
                    maxThroughputOutLevel1Value_ = pMaxThroughputOutLevel1;
                }

                internal void addOccupationLevel2Stats(Double pMinOccupationLevel2, Double pAvgOccupationLevel2,
                    Double pMaxOccupationLevel2, Double pMinThroughputInLevel2, Double pAvgThroughputInLevel2,
                    Double pMaxThroughputInLevel2, Double pMinThroughputOutLevel2, Double pAvgThroughputOutLevel2,
                    Double pMaxThroughputOutLevel2)
                {
                    minOccupationLevel2Value_ = pMinOccupationLevel2;
                    avgOccupationLevel2Value_ = pAvgOccupationLevel2;
                    maxOccupationLevel2Value_ = pMaxOccupationLevel2;

                    minThroughputInLevel2Value_ = pMinThroughputInLevel2;
                    avgThroughputInLevel2Value_ = pAvgThroughputInLevel2;
                    maxThroughputInLevel2Value_ = pMaxThroughputInLevel2;

                    minThroughputOutLevel2Value_ = pMinThroughputOutLevel2;
                    avgThroughputOutLevel2Value_ = pAvgThroughputOutLevel2;
                    maxThroughputOutLevel2Value_ = pMaxThroughputOutLevel2;
                }

                internal void addOccupationLevel3Stats(Double pMinOccupationLevel3, Double pAvgOccupationLevel3,
                    Double pMaxOccupationLevel3, Double pMinThroughputInLevel3, Double pAvgThroughputInLevel3,
                    Double pMaxThroughputInLevel3, Double pMinThroughputOutLevel3, Double pAvgThroughputOutLevel3,
                    Double pMaxThroughputOutLevel3)
                {
                    minOccupationLevel3Value_ = pMinOccupationLevel3;
                    avgOccupationLevel3Value_ = pAvgOccupationLevel3;
                    maxOccupationLevel3Value_ = pMaxOccupationLevel3;

                    minThroughputInLevel3Value_ = pMinThroughputInLevel3;
                    avgThroughputInLevel3Value_ = pAvgThroughputInLevel3;
                    maxThroughputInLevel3Value_ = pMaxThroughputInLevel3;

                    minThroughputOutLevel3Value_ = pMinThroughputOutLevel3;
                    avgThroughputOutLevel3Value_ = pAvgThroughputOutLevel3;
                    maxThroughputOutLevel3Value_ = pMaxThroughputOutLevel3;
                }

                internal void addDwellAreaLevel1Stats(Double pDwellAreaMinLevel1,
                    Double pDwellAreaAvgLevel1, Double pDwellAreaMaxLevel1)
                {
                    dwellAreaLevel1MinValue_ = pDwellAreaMinLevel1;
                    dwellAreaLevel1AvgValue_ = pDwellAreaAvgLevel1;
                    dwellAreaLevel1MaxValue_ = pDwellAreaMaxLevel1;
                }
                internal void addDwellAreaLevel2Stats(Double pDwellAreaMinLevel2,
                    Double pDwellAreaAvgLevel2, Double pDwellAreaMaxLevel2)
                {
                    dwellAreaLevel2MinValue_ = pDwellAreaMinLevel2;
                    dwellAreaLevel2AvgValue_ = pDwellAreaAvgLevel2;
                    dwellAreaLevel2MaxValue_ = pDwellAreaMaxLevel2;
                }
                internal void addDwellAreaLevel3Stats(Double pDwellAreaMinLevel3,
                    Double pDwellAreaAvgLevel3, Double pDwellAreaMaxLevel3)
                {
                    dwellAreaLevel3MinValue_ = pDwellAreaMinLevel3;
                    dwellAreaLevel3AvgValue_ = pDwellAreaAvgLevel3;
                    dwellAreaLevel3MaxValue_ = pDwellAreaMaxLevel3;
                }

                internal void addDelayTimeLevel1Stats(Double pDelayTimeMinLevel1,
                    Double pDelayTimeAvgLevel1, Double pDelayTimeMaxLevel1)
                {
                    delayTimeLevel1MinValue_ = pDelayTimeMinLevel1;
                    delayTimeLevel1AvgValue_ = pDelayTimeAvgLevel1;
                    delayTimeLevel1MaxValue_ = pDelayTimeMaxLevel1;
                }
                internal void addDelayTimeLevel2Stats(Double pDelayTimeMinLevel2,
                    Double pDelayTimeAvgLevel2, Double pDelayTimeMaxLevel2)
                {
                    delayTimeLevel2MinValue_ = pDelayTimeMinLevel2;
                    delayTimeLevel2AvgValue_ = pDelayTimeAvgLevel2;
                    delayTimeLevel2MaxValue_ = pDelayTimeMaxLevel2;
                }
                internal void addDelayTimeLevel3Stats(Double pDelayTimeMinLevel3,
                    Double pDelayTimeAvgLevel3, Double pDelayTimeMaxLevel3)
                {
                    delayTimeLevel3MinValue_ = pDelayTimeMinLevel3;
                    delayTimeLevel3AvgValue_ = pDelayTimeAvgLevel3;
                    delayTimeLevel3MaxValue_ = pDelayTimeMaxLevel3;
                }

                internal void addWaitingDeskTimeLevel1Stats(Double pWaitingDeskTimeLevel1MinValue,
                    Double pWaitingDeskTimeLevel1AvgValue, Double pWaitingDeskTimeLevel1MaxValue)
                {
                    waitingDeskTimeLevel1MinValue_ = pWaitingDeskTimeLevel1MinValue;
                    waitingDeskTimeLevel1AvgValue_ = pWaitingDeskTimeLevel1AvgValue;
                    waitingDeskTimeLevel1MaxValue_ = pWaitingDeskTimeLevel1MaxValue;
                }
                internal void addWaitingDeskTimeLevel2Stats(Double pWaitingDeskTimeLevel2MinValue,
                    Double pWaitingDeskTimeLevel2AvgValue, Double pWaitingDeskTimeLevel2MaxValue)
                {
                    waitingDeskTimeLevel2MinValue_ = pWaitingDeskTimeLevel2MinValue;
                    waitingDeskTimeLevel2AvgValue_ = pWaitingDeskTimeLevel2AvgValue;
                    waitingDeskTimeLevel2MaxValue_ = pWaitingDeskTimeLevel2MaxValue;
                }
                internal void addWaitingDeskTimeLevel3Stats(Double pWaitingDeskTimeLevel3MinValue,
                    Double pWaitingDeskTimeLevel3AvgValue, Double pWaitingDeskTimeLevel3MaxValue)
                {
                    waitingDeskTimeLevel3MinValue_ = pWaitingDeskTimeLevel3MinValue;
                    waitingDeskTimeLevel3AvgValue_ = pWaitingDeskTimeLevel3AvgValue;
                    waitingDeskTimeLevel3MaxValue_ = pWaitingDeskTimeLevel3MaxValue;
                }

                internal void addWaitingGroupTimeLevel1Stats(Double pWaitingGroupTimeLevel1MinValue,
                    Double pWaitingGroupTimeLevel1AvgValue, Double pWaitingGroupTimeLevel1MaxValue)
                {
                    waitingGroupTimeLevel1MinValue_ = pWaitingGroupTimeLevel1MinValue;
                    waitingGroupTimeLevel1AvgValue_ = pWaitingGroupTimeLevel1AvgValue;
                    waitingGroupTimeLevel1MaxValue_ = pWaitingGroupTimeLevel1MaxValue;
                }
                internal void addWaitingGroupTimeLevel2Stats(Double pWaitingGroupTimeLevel2MinValue,
                    Double pWaitingGroupTimeLevel2AvgValue, Double pWaitingGroupTimeLevel2MaxValue)
                {
                    waitingGroupTimeLevel2MinValue_ = pWaitingGroupTimeLevel2MinValue;
                    waitingGroupTimeLevel2AvgValue_ = pWaitingGroupTimeLevel2AvgValue;
                    waitingGroupTimeLevel2MaxValue_ = pWaitingGroupTimeLevel2MaxValue;
                }
                internal void addWaitingGroupTimeLevel3Stats(Double pWaitingGroupTimeLevel3MinValue,
                    Double pWaitingGroupTimeLevel3AvgValue, Double pWaitingGroupTimeLevel3MaxValue)
                {
                    waitingGroupTimeLevel3MinValue_ = pWaitingGroupTimeLevel3MinValue;
                    waitingGroupTimeLevel3AvgValue_ = pWaitingGroupTimeLevel3AvgValue;
                    waitingGroupTimeLevel3MaxValue_ = pWaitingGroupTimeLevel3MaxValue;
                }

                internal void addProcessTimeLevel1Stats(Double pProcessTimeLevel1MinValue,
                    Double pProcessTimeLevel1AvgValue, Double pProcessTimeLevel1MaxValue)
                {
                    processTimeLevel1MinValue_ = pProcessTimeLevel1MinValue;
                    processTimeLevel1AvgValue_ = pProcessTimeLevel1AvgValue;
                    processTimeLevel1MaxValue_ = pProcessTimeLevel1MaxValue;
                }
                internal void addProcessTimeLevel2Stats(Double pProcessTimeLevel2MinValue,
                    Double pProcessTimeLevel2AvgValue, Double pProcessTimeLevel2MaxValue)
                {
                    processTimeLevel2MinValue_ = pProcessTimeLevel2MinValue;
                    processTimeLevel2AvgValue_ = pProcessTimeLevel2AvgValue;
                    processTimeLevel2MaxValue_ = pProcessTimeLevel2MaxValue;
                }
                internal void addProcessTimeLevel3Stats(Double pProcessTimeLevel3MinValue,
                    Double pProcessTimeLevel3AvgValue, Double pProcessTimeLevel3MaxValue)
                {
                    processTimeLevel3MinValue_ = pProcessTimeLevel3MinValue;
                    processTimeLevel3AvgValue_ = pProcessTimeLevel3AvgValue;
                    processTimeLevel3MaxValue_ = pProcessTimeLevel3MaxValue;
                }

                internal void addRemainingTimeLevel1Stats(Double pRemainingTimeLevel1MinValue,
                    Double pRemainingTimeLevel1AvgValue, Double pRemainingTimeLevel1MaxValue)
                {
                    remainingTimeLevel1MinValue_ = pRemainingTimeLevel1MinValue;
                    remainingTimeLevel1AvgValue_ = pRemainingTimeLevel1AvgValue;
                    remainingTimeLevel1MaxValue_ = pRemainingTimeLevel1MaxValue;
                }
                internal void addRemainingTimeLevel2Stats(Double pRemainingTimeLevel2MinValue,
                    Double pRemainingTimeLevel2AvgValue, Double pRemainingTimeLevel2MaxValue)
                {
                    remainingTimeLevel2MinValue_ = pRemainingTimeLevel2MinValue;
                    remainingTimeLevel2AvgValue_ = pRemainingTimeLevel2AvgValue;
                    remainingTimeLevel2MaxValue_ = pRemainingTimeLevel2MaxValue;
                }
                internal void addRemainingTimeLevel3Stats(Double pRemainingTimeLevel3MinValue,
                    Double pRemainingTimeLevel3AvgValue, Double pRemainingTimeLevel3MaxValue)
                {
                    remainingTimeLevel3MinValue_ = pRemainingTimeLevel3MinValue;
                    remainingTimeLevel3AvgValue_ = pRemainingTimeLevel3AvgValue;
                    remainingTimeLevel3MaxValue_ = pRemainingTimeLevel3MaxValue;
                }

                internal void addWaitingTimeLevel1Stats(Double pWaitingTimeLevel1MinValue,
                    Double pWaitingTimeLevel1AvgValue, Double pWaitingTimeLevel1MaxValue)
                {
                    waitingTimeLevel1MinValue_ = pWaitingTimeLevel1MinValue;
                    waitingTimeLevel1AvgValue_ = pWaitingTimeLevel1AvgValue;
                    waitingTimeLevel1MaxValue_ = pWaitingTimeLevel1MaxValue;
                }
                internal void addWaitingTimeLevel2Stats(Double pWaitingTimeLevel2MinValue,
                   Double pWaitingTimeLevel2AvgValue, Double pWaitingTimeLevel2MaxValue)
                {
                    waitingTimeLevel2MinValue_ = pWaitingTimeLevel2MinValue;
                    waitingTimeLevel2AvgValue_ = pWaitingTimeLevel2AvgValue;
                    waitingTimeLevel2MaxValue_ = pWaitingTimeLevel2MaxValue;
                }
                internal void addWaitingTimeLevel3Stats(Double pWaitingTimeLevel3MinValue,
                   Double pWaitingTimeLevel3AvgValue, Double pWaitingTimeLevel3MaxValue)
                {
                    waitingTimeLevel3MinValue_ = pWaitingTimeLevel3MinValue;
                    waitingTimeLevel3AvgValue_ = pWaitingTimeLevel3AvgValue;
                    waitingTimeLevel3MaxValue_ = pWaitingTimeLevel3MaxValue;
                }

                internal void addUtilizationPercentLevel1Stats(Double pMinUtilizationPercentLevel1Value,
                    Double pAvgUtilizationPercentLevel1Value, Double pMaxUtilizationPercentLevel1Value)
                {
                    minUtilizationPercentLevel1Value_ = pMinUtilizationPercentLevel1Value;
                    avgUtilizationPercentLevel1Value_ = pAvgUtilizationPercentLevel1Value;
                    maxUtilizationPercentLevel1Value_ = pMaxUtilizationPercentLevel1Value;
                }
                internal void addUtilizationPercentLevel2Stats(Double pMinUtilizationPercentLevel2Value,
                    Double pAvgUtilizationPercentLevel2Value, Double pMaxUtilizationPercentLevel2Value)
                {
                    minUtilizationPercentLevel2Value_ = pMinUtilizationPercentLevel2Value;
                    avgUtilizationPercentLevel2Value_ = pAvgUtilizationPercentLevel2Value;
                    maxUtilizationPercentLevel2Value_ = pMaxUtilizationPercentLevel2Value;
                }
                internal void addUtilizationPercentLevel3Stats(Double pMinUtilizationPercentLevel3Value,
                    Double pAvgUtilizationPercentLevel3Value, Double pMaxUtilizationPercentLevel3Value)
                {
                    minUtilizationPercentLevel3Value_ = pMinUtilizationPercentLevel3Value;
                    avgUtilizationPercentLevel3Value_ = pAvgUtilizationPercentLevel3Value;
                    maxUtilizationPercentLevel3Value_ = pMaxUtilizationPercentLevel3Value;
                }

                internal void addDeskNeedLevel1Stats(Double pMinDeskNeedLevel1Value,
                    Double pAvgDeskNeedLevel1Value, Double pMaxDeskNeedLevel1Value)
                {
                    minDeskNeedLevel1Value_ = pMinDeskNeedLevel1Value;
                    avgDeskNeedLevel1Value_ = pAvgDeskNeedLevel1Value;
                    maxDeskNeedLevel1Value_ = pMaxDeskNeedLevel1Value;
                }
                internal void addDeskNeedLevel2Stats(Double pMinDeskNeedLevel2Value,
                    Double pAvgDeskNeedLevel2Value, Double pMaxDeskNeedLevel2Value)
                {
                    minDeskNeedLevel2Value_ = pMinDeskNeedLevel2Value;
                    avgDeskNeedLevel2Value_ = pAvgDeskNeedLevel2Value;
                    maxDeskNeedLevel2Value_ = pMaxDeskNeedLevel2Value;
                }
                internal void addDeskNeedLevel3Stats(Double pMinDeskNeedLevel3Value,
                    Double pAvgDeskNeedLevel3Value, Double pMaxDeskNeedLevel3Value)
                {
                    minDeskNeedLevel3Value_ = pMinDeskNeedLevel3Value;
                    avgDeskNeedLevel3Value_ = pAvgDeskNeedLevel3Value;
                    maxDeskNeedLevel3Value_ = pMaxDeskNeedLevel3Value;
                }
                // << Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent

                internal void AddQueueOccupation(Double dMin, Double dMax, Double dMean)
                {
                    dMaxQueueOccupation = dMax;
                    dMinQueueOccupation = dMin;
                    dMeanQueueOccupation = dMean;
                }
                internal void UpdateQueueOccupation(Double dMin, Double dMax, Double dMean)
                {
                    if ((dMin < dMinQueueOccupation) || (dMinQueueOccupation == -1))
                        dMinQueueOccupation = dMin;
                    if (dMax > dMaxQueueOccupation)
                        dMaxQueueOccupation = dMax;
                    iNumberMean++;
                    dMeanQueueOccupation += dMean;
                }

                Double[] dWaitingDesk = null;
                Double[] dProcess = null;
                Double[] dOccupation = null;
                // << Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                Double[] dDelayTime = null;
                // >> Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                int iPaxMissedDesk = 0;
                int iPaxStoppedDesk = 0;
                int iPaxLostDesk = 0;
                int iPaxDesk = 0;
                internal void SetDeskStatistics(DeskReport drDesk)
                {
                    if (dWaitingDesk == null)
                        dWaitingDesk = new double[3] { -1, 0, 0 };
                    if (dProcess == null)
                        dProcess = new double[3] { -1, 0, 0 };

                    if (dOccupation == null)
                        dOccupation = new double[3] { -1, 0, 0 };

                    // << Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                    if (dDelayTime == null)
                        dDelayTime = new double[3] { -1, 0, 0 };
                    // >> Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time

                    int iNbProcessedPax = (drDesk.PaxNumber - drDesk.PaxStopped - drDesk.PaxMissed);
                    iPaxDesk += iNbProcessedPax;
                    if ((dWaitingDesk[0] == -1) || (drDesk.dMinWaitingDesk < dWaitingDesk[0]))
                        dWaitingDesk[0] = drDesk.dMinWaitingDesk;
                    if (drDesk.dMaxWaitingDesk > dWaitingDesk[1])
                        dWaitingDesk[1] = drDesk.dMaxWaitingDesk;
                    dWaitingDesk[2] += drDesk.dMeanWaitingDesk * iNbProcessedPax;

                    if ((dProcess[0] == -1) || (drDesk.dMinProcess < dProcess[0]))
                        dProcess[0] = drDesk.dMinProcess;
                    if (drDesk.dMaxProcess > dProcess[1])
                        dProcess[1] = drDesk.dMaxProcess;
                    dProcess[2] += drDesk.dMeanProcess * iNbProcessedPax;

                    if ((dOccupation[0] == -1) || (drDesk.dMinDwellTimeDesk < dOccupation[0]))
                        dOccupation[0] = drDesk.dMinDwellTimeDesk;
                    if (drDesk.dMaxDwellDesk > dOccupation[1])
                        dOccupation[1] = drDesk.dMaxDwellDesk;
                    dOccupation[2] += drDesk.dMeanDwellDesk * iNbProcessedPax;

                    // << Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time
                    if ((dDelayTime[0] == -1) || (drDesk.dMinDelayTime < dDelayTime[0]))
                        dDelayTime[0] = drDesk.dMinDelayTime;
                    if (drDesk.dMaxDelayTime > dDelayTime[1])
                        dDelayTime[1] = drDesk.dMaxDelayTime;
                    dDelayTime[2] += drDesk.dMeanDelayTime * iNbProcessedPax;
                    // >> Task #8754 Pax2Sim - Groups and Desks Summaries will include Delay time

                    iPaxMissedDesk += drDesk.iPaxMissed;
                    iPaxStoppedDesk += drDesk.iPaxStopped;
                    iPaxLostDesk += drDesk.iPaxLost;
                }
            }
            #endregion
            #endregion

            #region Variables et leurs accesseurs de la classe contenant toutes les analyses du PaxTrace

            PaxResultsStruct.TraceFilter tfFilter;

            Dictionary<String, DataTable> dsdTable;

            /// <summary>
            /// Contient tous les résultats pour chaque passager.
            /// </summary>
            Dictionary<Int32, PaxResultsStruct> PaxResults = new Dictionary<Int32, PaxResultsStruct>();

            /// <summary>
            /// Contient toutes les informations pour chaque poste.
            /// </summary>
            Hashtable DeskResults = new Hashtable();

            /// <summary>
            /// Contient toutes les tables pour les occupations.
            /// </summary>
            Hashtable TablesOccupation_ = new Hashtable();

            /// <summary>
            /// Contient toutes les tables résultat pour les répartitions
            /// </summary>
            Hashtable TablesTime_ = new Hashtable();

            /// <summary>
            /// Contient toutes les tables pour les utilisations
            /// </summary>
            Hashtable TablesUtilization_ = new Hashtable();

            Hashtable _deskPlanInformationTables = new Hashtable(); // >> Task #13243 Pax2Sim - Dynamic simulation - Desk Plan Information

            /// <summary>
            /// Contient toutes les tables pour les temps restant avant embarquement.
            /// </summary>
            Hashtable TablesRemainingTimes_ = new Hashtable();

            // << Task #8589 Pax2Sim - Waiting Time Per Period of Time for PAX
            /// <summary>
            /// Holds all the tables for the waiting time per period of time
            /// </summary>
            Hashtable _dwellTimeTables = new Hashtable();
            // >> Task #8589 Pax2Sim - Waiting Time Per Period of Time for PAX

            Hashtable htRemainingTime_ = new Hashtable();
            Hashtable htCounterResults = new Hashtable();
            SortedList slResults;

            DataTable PaxTravelStats_;
            DataTable PaxInformations_;
            DataTable PaxDistribution_;
            DataTable PaxDistributionMissed_;
            DataTable PaxDistributionStopped_;
            DataTable PaxDistributionLost_;
            DataTable PaxDistributionArrival_;
            DataTable PaxDistributionDeparture_;
            DataTable PaxDistributionTransfer_;
            // << Task #8618 Pax2Sim - Dynamic Analysis - Pax - histograns and timeline tables for Dwell Area
            DataTable PaxDistributionOriginatingAndTransfer_;
            #region timeline tables
            DataTable PaxDistributionTimelineTotal_;
            DataTable PaxDistributionTimelineMissed_;
            DataTable PaxDistributionTimelineStopped_;
            DataTable PaxDistributionTimelineLost_;
            DataTable PaxDistributionTimelineTerminating_;
            DataTable PaxDistributionTimelineOriginatingAndTransfer_;
            DataTable PaxDistributionTimelineTransfer_;
            DataTable PaxDistributionTimelineOriginating_;
            #endregion

            #region summary tables
            DataTable paxDistributionGlobalSummary_;
            DataTable paxDistributionMissedSummary_;
            DataTable paxDistributionStoppedSummary_;
            DataTable paxDistributionLostSummary_;

            DataTable paxDistributionTerminatingSummary_;
            DataTable paxDistributionOriginatingAndTransferSummary_;
            DataTable paxDistributionTransferSummary_;
            DataTable paxDistributionOriginatingSummary_;
            #endregion
            // >> Task #8618 Pax2Sim - Dynamic Analysis - Pax - histograns and timeline tables for Dwell Area

            DataTable PaxGeneralIST_;

            Hashtable DeskInformations2_;

            DataTable dtBagPlan;

            DataTable dtAllocationResults;
            DataTable[] dtAllocationReclaim;
            VisualisationMode vmAllocationResults;
            VisualisationMode[] vmAllocationReclaim;
            DataTable dtAllocationMin;

            String sOutputsDirectory_;
            String sBGLocation_;
            ArrayList ErrorList_;
            DateTime dtBeginTime_;
            DateTime dtEndTime_;
            bool bSlidingHour_;
            double[] percentilesLevels_;

            // Les informations concernant les classes pour l'analyse du temps restant
            Double dPasRemaining;
            Double dWarmUp;
            int iNbClassesRemaining;
            //Les informations concernant les classes pour l'analyse de la répartition des temps des passagers
            Double dPasTime;
            int iNbClassesTime;
            //L'information sur le pas de l'analyse de l'occupation.
            Double dPasOccupation;

            //L'information sur le pas de l'analyse de l'utilisation.
            Double dPasUtilisation;

            Double dPasPaxDistribution;

            DataTable dtBagList;
            DataTable dtFPDTable_;

            DataTable dtPaxPlan;
            DataTable dtFPDTableNormal;
            DataTable dtFPATableNormal;
            DataTable dtSimpleFPDTable;
            DataTable dtSimpleFPATable;
            internal DataTable dtDepartureFlightStatistics;
            internal VisualisationMode vmDepartureFlightStatistics;

            // >> Task #13206 Pax2Sim - Dynamic Analysis - Arrival Flight Statistics
            internal DataTable arrivalStats;
            internal DataTable departureStats;
            // << Task #13206 Pax2Sim - Dynamic Analysis - Arrival Flight Statistics

            // >> Departure_Statistics, Arrival_Statistics segregate by Airline, Flight category
            internal List<DataTable> departureStatsByAirline = new List<DataTable>();
            internal List<DataTable> departureStatsByFlightCategories = new List<DataTable>();
            internal List<DataTable> departureStatsSegregated = new List<DataTable>();

            internal List<DataTable> arrivalStatsByAirline = new List<DataTable>();
            internal List<DataTable> arrivalStatsByFlightCategories = new List<DataTable>();
            internal List<DataTable> arrivalStatsSegregated = new List<DataTable>();
            // << Departure_Statistics, Arrival_Statistics segregate by Airline, Flight category

            // << Task #7949 Capacity Analysis - IST tables modification
            /// <summary>
            /// Stores the user attributes names taken from the names of the user attributes columns from the Pax Plan table.
            /// </summary>
            private static Dictionary<string, DataManagement.NormalTable> userAttributesDistributionTables;
            // >> Task #7949 Capacity Analysis - IST tables modification

            // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
            Double analysisRange;
            // >> Task #8775 Pax2Sim - Occupation stat - Throughput calculation

            #region Les accesseurs de la classe.

            internal PaxResultsStruct.TraceFilter Filter
            {
                get
                {
                    return tfFilter;
                }
                set
                {
                    tfFilter = value;
                }
            }

            public Dictionary<string, DataTable> IST
            {
                get
                {
                    return dsdTable;
                }
            }
            public DataTable PaxTravelStats
            {
                get
                {
                    return PaxTravelStats_;
                }
            }
            public DataTable PaxInformations
            {
                get
                {
                    if (PaxInformations_ == null)
                        extractInformations();
                    return PaxInformations_;
                }
            }
            public SortedList JNK_BHSUtilisation
            {
                get
                {
                    if (slResults == null)
                        extractPaxInformationsJNKForLHR();
                    return slResults;
                }
            }
            public DataTable PaxDistribution
            {
                get
                {
                    if (PaxDistribution_ == null)
                        extractInformations();
                    return PaxDistribution_;
                }
            }
            public DataTable PaxDistributionMissed
            {
                get
                {
                    if (PaxDistributionMissed_ == null)
                        extractInformations();
                    return PaxDistributionMissed_;
                }
            }
            public DataTable PaxDistributionStopped
            {
                get
                {
                    if (PaxDistributionStopped_ == null)
                        extractInformations();
                    return PaxDistributionStopped_;
                }
            }
            public DataTable PaxDistributionLost
            {
                get
                {
                    if (PaxDistributionLost_ == null)
                        extractInformations();
                    return PaxDistributionLost_;
                }
            }
            public DataTable PaxDistributionArrival
            {
                get
                {
                    if (PaxDistributionArrival_ == null)
                        extractInformations();
                    return PaxDistributionArrival_;
                }
            }
            public DataTable PaxDistributionDeparture
            {
                get
                {
                    if (PaxDistributionDeparture_ == null)
                        extractInformations();
                    return PaxDistributionDeparture_;
                }
            }
            public DataTable PaxGeneralIST
            {
                get
                {
                    if (PaxGeneralIST_ == null)
                        extractInformations();
                    return PaxGeneralIST_;
                }
            }
            public DataTable PaxDistributionTransfer
            {
                get
                {
                    if (PaxDistributionTransfer_ == null)
                        extractInformations();
                    return PaxDistributionTransfer_;
                }
            }

            // << Task #8618 Pax2Sim - Dynamic Analysis - Pax - histograns and timeline tables for Dwell Area
            public DataTable PaxDistributionOriginatingAndTransfer
            {
                get
                {
                    if (PaxDistributionOriginatingAndTransfer_ == null)
                        extractPaxInformations();
                    return PaxDistributionOriginatingAndTransfer_;
                }
            }

            #region timeline tables

            public DataTable PaxDistributionTimelineTotal
            {
                get
                {
                    if (PaxDistributionTimelineTotal_ == null)
                        extractPaxInformations();
                    return PaxDistributionTimelineTotal_;
                }
            }

            public DataTable PaxDistributionTimelineMissed
            {
                get
                {
                    if (PaxDistributionTimelineMissed_ == null)
                        extractPaxInformations();
                    return PaxDistributionTimelineMissed_;
                }
            }

            public DataTable PaxDistributionTimelineStopped
            {
                get
                {
                    if (PaxDistributionTimelineStopped_ == null)
                        extractPaxInformations();
                    return PaxDistributionTimelineStopped_;
                }
            }

            public DataTable PaxDistributionTimelineLost
            {
                get
                {
                    if (PaxDistributionTimelineLost_ == null)
                        extractPaxInformations();
                    return PaxDistributionTimelineLost_;
                }
            }

            public DataTable PaxDistributionTimelineTerminating
            {
                get
                {
                    if (PaxDistributionTimelineTerminating_ == null)
                        extractPaxInformations();
                    return PaxDistributionTimelineTerminating_;
                }
            }

            //Originating + Transfer = Departing
            public DataTable PaxDistributionTimelineOriginatingAndTransfer
            {
                get
                {
                    if (PaxDistributionTimelineOriginatingAndTransfer_ == null)
                        extractPaxInformations();
                    return PaxDistributionTimelineOriginatingAndTransfer_;
                }
            }

            public DataTable PaxDistributionTimelineTransfer
            {
                get
                {
                    if (PaxDistributionTimelineTransfer_ == null)
                        extractPaxInformations();
                    return PaxDistributionTimelineTransfer_;
                }
            }

            public DataTable PaxDistributionTimelineOriginating
            {
                get
                {
                    if (PaxDistributionTimelineOriginating_ == null)
                        extractPaxInformations();
                    return PaxDistributionTimelineOriginating_;
                }
            }
            #endregion

            #region summary tables
            public DataTable paxDistributionGlobalSummary
            {
                get
                {
                    if (paxDistributionGlobalSummary_ == null)
                        extractPaxInformations();
                    return paxDistributionGlobalSummary_;
                }
            }
            public DataTable paxDistributionMissedSummary
            {
                get
                {
                    if (paxDistributionMissedSummary_ == null)
                        extractPaxInformations();
                    return paxDistributionMissedSummary_;
                }
            }
            public DataTable paxDistributionStoppedSummary
            {
                get
                {
                    if (paxDistributionStoppedSummary_ == null)
                        extractPaxInformations();
                    return paxDistributionStoppedSummary_;
                }
            }
            public DataTable paxDistributionLostSummary
            {
                get
                {
                    if (paxDistributionLostSummary_ == null)
                        extractPaxInformations();
                    return paxDistributionLostSummary_;
                }
            }

            public DataTable paxDistributionOriginatingSummary
            {
                get
                {
                    if (paxDistributionOriginatingSummary_ == null)
                        extractPaxInformations();
                    return paxDistributionOriginatingSummary_;
                }
            }
            public DataTable paxDistributionOriginatingAndTransferSummary
            {
                get
                {
                    if (paxDistributionOriginatingAndTransferSummary_ == null)
                        extractPaxInformations();
                    return paxDistributionOriginatingAndTransferSummary_;
                }
            }
            public DataTable paxDistributionTransferSummary
            {
                get
                {
                    if (paxDistributionTransferSummary_ == null)
                        extractPaxInformations();
                    return paxDistributionTransferSummary_;
                }
            }
            public DataTable paxDistributionTerminatingSummary
            {
                get
                {
                    if (paxDistributionTerminatingSummary_ == null)
                        extractPaxInformations();
                    return paxDistributionTerminatingSummary_;
                }
            }
            #endregion
            // >> Task #8618 Pax2Sim - Dynamic Analysis - Pax - histograns and timeline tables for Dwell Area

            public Hashtable OccupationTables
            {
                get
                {
                    return TablesOccupation_;
                }
            }

            public Hashtable TimeTables
            {
                get
                {
                    return TablesTime_;
                }
            }

            public Hashtable RemainingTime
            {
                get
                {
                    return TablesRemainingTimes_;
                }
            }
            public Hashtable CounterResults
            {
                get
                {
                    return htCounterResults;
                }
            }

            public Hashtable UtilizationTables
            {
                get
                {
                    return TablesUtilization_;
                }
            }

            // >> Task #13243 Pax2Sim - Dynamic simulation - Desk Plan Information
            public Hashtable deskPlanInformationTables
            {
                get
                {
                    return _deskPlanInformationTables;
                }
            }
            // << Task #13243 Pax2Sim - Dynamic simulation - Desk Plan Information

            public Hashtable DeskInformations3
            {
                get
                {
                    if (DeskInformations2_ == null)
                        extractInformations();
                    return DeskInformations2_;
                }
            }

            // << Task #8589 Pax2Sim - Waiting Time Per Period of Time for PAX
            public Hashtable dwellTimeTables
            {
                get { return _dwellTimeTables; }
            }
            // >> Task #8589 Pax2Sim - Waiting Time Per Period of Time for PAX

            public DataTable BagList
            {
                get
                {
                    return dtBagList;
                }
            }
            public DataTable FPDTable
            {
                get
                {
                    return dtFPDTable_;
                }
            }

            public DataTable AllocationResults
            {
                get
                {
                    return dtAllocationResults;
                }
            }
            public VisualisationMode AllocationVisualisation
            {
                get
                {
                    return vmAllocationResults;
                }
            }
            public DataTable AllocationMin
            {
                get
                {
                    return dtAllocationMin;
                }
            }

            public DataTable[] AllocationReclaim
            {
                get
                {
                    return dtAllocationReclaim;
                }
            }
            public VisualisationMode[] AllocationReclaimVisualisation
            {
                get
                {
                    return vmAllocationReclaim;
                }
            }
            #endregion
            #endregion

            // << Task #8589 Pax2Sim - Waiting Time Per Period of Time for PAX
            #region Class and dictionary used to calculate the dwell time / period of time

            /// <summary>
            /// Holds the link between a pax's travel time info and the resource 
            /// that the pax traveled.
            /// </summary>
            public class PaxTravelInfoForResource   // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
            {
                private Int32 _paxId;
                private String _resourceName;
                private DateTime _arrivalTime;
                private DateTime _leavingTime;
                private Double _waitingTime;
                // << Task #8617 Pax2Sim - Dynamic Analysis - Pax - timeline tables for Groups and Desks based on total time
                private Double _dwellTime;
                // >> Task #8617 Pax2Sim - Dynamic Analysis - Pax - timeline tables for Groups and Desks based on total time

                public PaxTravelInfoForResource(Int32 pPaxId, String pResourceName, DateTime pArrivingTime,
                    DateTime pLeavingTime, Double pWaitingTime, Double pDwellTime)
                {
                    _paxId = pPaxId;
                    _resourceName = pResourceName;
                    _arrivalTime = pArrivingTime;
                    _leavingTime = pLeavingTime;
                    _waitingTime = pWaitingTime;
                    // << Task #8617 Pax2Sim - Dynamic Analysis - Pax - timeline tables for Groups and Desks based on total time                    
                    _dwellTime = pDwellTime;
                    // >> Task #8617 Pax2Sim - Dynamic Analysis - Pax - timeline tables for Groups and Desks based on total time
                }

                public Int32 paxId
                {
                    get
                    {
                        return _paxId;
                    }
                    set
                    {
                        _paxId = value;
                    }
                }
                public String resourceName
                {
                    get { return _resourceName; }
                    set { _resourceName = value; }
                }
                public DateTime arrivalTime
                {
                    get { return _arrivalTime; }
                    set { _arrivalTime = value; }
                }
                public DateTime leavingTime
                {
                    get { return _leavingTime; }
                    set { _leavingTime = value; }
                }
                public Double waitingTime
                {
                    get { return _waitingTime; }
                    set { _waitingTime = value; }
                }
                // << Task #8617 Pax2Sim - Dynamic Analysis - Pax - timeline tables for Groups and Desks based on total time                
                public Double dwellTime
                {
                    get { return _dwellTime; }
                    set { _dwellTime = value; }
                }
                // >> Task #8617 Pax2Sim - Dynamic Analysis - Pax - timeline tables for Groups and Desks based on total time
            }

            /// <summary>
            /// The dictionary with all the resources that the Paxes traveled through
            /// key = resoruce name / value = nb pax;
            /// </summary>
            Dictionary<String, Int32> traveledResources = new Dictionary<String, Int32>();

            /// <summary>
            /// The dictionary with all the resources traveled and for each resource we have the list with the pax and trave time info
            /// key = resource name / value = list of pax travel time info
            /// </summary>
            Dictionary<String, List<PaxTravelInfoForResource>> paxTravelInfomationForResources = new Dictionary<String, List<PaxTravelInfoForResource>>();
            #endregion

            #region Function used to fill the resource - list<pax travel times> dictionary with information

            public void getTraveledResources()
            {
                if (traveledResources == null)
                    traveledResources = new Dictionary<String, Int32>();
                else
                    traveledResources.Clear();

                if (PaxResults != null && PaxResults.Count > 0)
                {
                    foreach (PaxResultsStruct pax in PaxResults.Values)
                    {
                        if (pax.PaxTravel != null && pax.PaxTravel.Count > 0)
                        {
                            foreach (PaxResultsStruct.paxTravelData paxTravelData in pax.PaxTravel)
                            {
                                String resourceName = paxTravelData.Desk;
                                if (traveledResources.ContainsKey(resourceName))
                                {
                                    traveledResources[resourceName] = traveledResources[resourceName] + 1;
                                }
                                else
                                {
                                    traveledResources.Add(resourceName, 0);
                                }
                            }
                        }
                    }
                }
            }

            public void getPaxTravelInfoForResources()
            {
                Double dEndDate = OverallTools.DataFunctions.MinuteDifference(dtBeginTime_, dtEndTime_);

                if (paxTravelInfomationForResources == null)
                {
                    paxTravelInfomationForResources = new Dictionary<String, List<PaxTravelInfoForResource>>();
                }
                else
                {
                    paxTravelInfomationForResources.Clear();
                }

                getTraveledResources();

                if (PaxResults != null && PaxResults.Count > 0
                    && traveledResources != null && traveledResources.Count > 0)
                {
                    //for each resource possible we search the pax that went through and fill the dictionary's list of pax travel info
                    foreach (String traveledResourceName in traveledResources.Keys)
                    {
                        //search in the pax dictionary
                        foreach (PaxResultsStruct pax in PaxResults.Values)
                        {
                            if (pax.PaxTravel != null && pax.PaxTravel.Count > 0)
                            {
                                //search for the current pax in his list of travel places
                                foreach (PaxResultsStruct.paxTravelData paxTravelData in pax.PaxTravel)
                                {
                                    String resourceName = paxTravelData.Desk;

                                    //if the pax traveled through the current resource we add the info
                                    if (resourceName == traveledResourceName)
                                    {
                                        //create the object containing the travel info for pax-resource
                                        // << Task #8617 Pax2Sim - Dynamic Analysis - Pax - timeline tables for Groups and Desks based on total time
                                        Double waitingTime = 0;
                                        Double processTime = 0;
                                        Double dwellTime = 0;
                                        // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                                        Double delayTime = 0;
                                        // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)

                                        if (paxTravelData.WaitingTime > 0)
                                            waitingTime = paxTravelData.WaitingTime;
                                        if (paxTravelData.ProcessTime > 0)
                                            processTime = paxTravelData.ProcessTime;
                                        // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                                        if (paxTravelData.DelayTime > 0)
                                            delayTime = paxTravelData.DelayTime;
                                        // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)

                                        if (pax.Stopped
                                            && (pax.PaxTravel.IndexOf(paxTravelData) == (pax.PaxTravel.Count - 1)))
                                        {
                                            if (paxTravelData.LeavingTime >= paxTravelData.ArrivalTime && paxTravelData.LeavingTime < dEndDate)
                                                dwellTime = dwellTime + (paxTravelData.LeavingTime - paxTravelData.ArrivalTime);
                                            else
                                                dwellTime = dwellTime + (dEndDate - paxTravelData.ArrivalTime);
                                        }
                                        else
                                            // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                                            dwellTime = delayTime + waitingTime + processTime;
                                        // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)

                                        // << Task #8617 Pax2Sim - Dynamic Analysis - Pax - timeline tables for Groups and Desks based on total time                                        
                                        PaxResultsStruct.paxTravelData group = null;
                                        PaxResultsStruct.paxTravelData desk = null;

                                        //total time is calculated from the Group (or groups and desks.
                                        if (!paxTravelData.IsGroup)
                                        {
                                            group = getGroupTravelDataByDeskAndPaxTravelInfo(resourceName, pax.PaxTravel);
                                            if (group != null)
                                            {
                                                double groupWaitingTime = 0;
                                                double groupProcessTime = 0;
                                                if (group.WaitingTime > 0)
                                                    groupWaitingTime = group.WaitingTime;
                                                if (group.ProcessTime > 0)
                                                    groupProcessTime = group.ProcessTime;

                                                if (pax.Stopped && (pax.PaxTravel.IndexOf(group) == (pax.PaxTravel.Count - 1)))
                                                {
                                                    if (group.LeavingTime >= group.ArrivalTime && group.LeavingTime < dEndDate)
                                                        dwellTime = dwellTime + (group.LeavingTime - group.ArrivalTime);
                                                    else
                                                        dwellTime = dwellTime + (dEndDate - group.ArrivalTime);
                                                }
                                                else
                                                    dwellTime = dwellTime + groupWaitingTime + groupProcessTime;
                                            }
                                        }
                                        else
                                        {
                                            desk = getDeskTravelDataByGroupAndPaxTravelInfo(resourceName, pax.PaxTravel);
                                            if (desk != null)
                                            {
                                                double deskWaitingTime = 0;
                                                double deskProcessTime = 0;
                                                if (desk.WaitingTime > 0)
                                                    deskWaitingTime = desk.WaitingTime;
                                                if (desk.ProcessTime > 0)
                                                    deskProcessTime = desk.ProcessTime;

                                                if (pax.Stopped && (pax.PaxTravel.IndexOf(group) == (pax.PaxTravel.Count - 1)))
                                                {
                                                    if (desk.LeavingTime >= desk.ArrivalTime && desk.LeavingTime < dEndDate)
                                                        dwellTime = dwellTime + (desk.LeavingTime - desk.ArrivalTime);
                                                    else
                                                        dwellTime = dwellTime + (dEndDate - desk.ArrivalTime);
                                                }
                                                else
                                                    dwellTime = dwellTime + deskWaitingTime + deskProcessTime;
                                            }
                                        }
                                        // >> Task #8617 Pax2Sim - Dynamic Analysis - Pax - timeline tables for Groups and Desks based on total time

                                        PaxTravelInfoForResource paxResourceInfo = new PaxTravelInfoForResource(pax.IdPax,
                                            paxTravelData.Desk, dtBeginTime_.AddMinutes(paxTravelData.ArrivalTime),
                                            dtBeginTime_.AddMinutes(paxTravelData.LeavingTime),
                                            paxTravelData.WaitingTime, dwellTime);
                                        // >> Task #8617 Pax2Sim - Dynamic Analysis - Pax - timeline tables for Groups and Desks based on total time

                                        if (paxTravelInfomationForResources.ContainsKey(resourceName))
                                        {
                                            if (paxTravelInfomationForResources[resourceName] != null)
                                                paxTravelInfomationForResources[resourceName].Add(paxResourceInfo);
                                        }
                                        else
                                        {
                                            paxTravelInfomationForResources.Add(resourceName, new List<PaxTravelInfoForResource>());
                                            if (paxTravelInfomationForResources[resourceName] != null)
                                                paxTravelInfomationForResources[resourceName].Add(paxResourceInfo);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            private PaxResultsStruct.paxTravelData getGroupTravelDataByDeskAndPaxTravelInfo(String deskName,
                List<PaxResultsStruct.paxTravelData> paxTraveledResources)
            {
                PaxResultsStruct.paxTravelData group = null;
                int deskTagIndex = deskName.LastIndexOf(" ");
                if (deskTagIndex > 0)
                {
                    String deskPartialName = deskName.Substring(0, deskTagIndex);
                    foreach (PaxResultsStruct.paxTravelData paxTravelResourceData in paxTraveledResources)
                    {
                        if (paxTravelResourceData.Desk.Contains(deskPartialName) && paxTravelResourceData.Desk.Contains("Group"))
                            group = paxTravelResourceData;
                    }
                }
                return group;
            }

            private PaxResultsStruct.paxTravelData getDeskTravelDataByGroupAndPaxTravelInfo(String groupName,
                List<PaxResultsStruct.paxTravelData> paxTraveledResources)
            {
                PaxResultsStruct.paxTravelData desk = null;
                int groupTagIndex = groupName.IndexOf(" Group");

                if (groupTagIndex > 0)
                {
                    String groupPartialName = groupName.Substring(0, groupTagIndex);
                    foreach (PaxResultsStruct.paxTravelData paxTravelResourceData in paxTraveledResources)
                    {
                        if (paxTravelResourceData.Desk.Contains(groupPartialName) && !paxTravelResourceData.Desk.Contains("Group"))
                            desk = paxTravelResourceData;
                    }
                }
                return desk;
            }

            #endregion
            // >> Task #8589 Pax2Sim - Waiting Time Per Period of Time for PAX

            #region Fonctions pour le chargement et l'analyse du PaxTrace

            #region Calcul des statistiques générales sur les passagers et les postes.
            public void extractInformations()
            {
                extractDeskInformations();
                extractPaxInformations();
                if (PAX2SIM.bJNK)
                    extractPaxInformationsJNKForLHR();
            }




            private class FlightStatistics
            {
                private int _iFlightID;
                private int iNbGeneratedPax;

                private int iNbMissedPax;

                private int iNbStoppedPax;
                private int iNbLostPax;

                public FlightStatistics(int iFlightId)
                {
                    _iFlightID = iFlightId;
                    iNbGeneratedPax = 0;

                    iNbMissedPax = 0;
                    iNbLostPax = 0;
                    iNbStoppedPax = 0;
                }

                public void AddPax()
                {
                    iNbGeneratedPax++;
                }
                public void AddMissedPax()
                {
                    AddPax();
                    iNbMissedPax++;
                }
                public void AddStoppedPax()
                {
                    AddPax();
                    iNbStoppedPax++;
                }
                public void AddLostPax()
                {
                    AddPax();
                    iNbLostPax++;
                }
                #region Functions which return the informations about the flights generated in the paxplan.
                public Object[] getLine()
                {
                    return new Object[] { _iFlightID,
                                           iNbGeneratedPax,
                                           iNbMissedPax ,
                                           iNbStoppedPax,
                                           iNbLostPax};
                }
                #endregion
            }

            private void CalcAirportOccupation(Hashtable htResults,
                                                out double totalOccupation) // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
            {
                ArrayList alOccupationTime = new ArrayList();
                Hashtable htDFlightOccupation = new Hashtable();
                Hashtable htAFlightOccupation = new Hashtable();
                foreach (PaxResultsStruct paxtmp in PaxResults.Values)
                {
                    if (!paxtmp.CheckPaxIsValidForFilter(tfFilter))
                        continue;
                    if (paxtmp.LeavingTime != -1)
                    {
                        // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
                        //alOccupationTime.Add(new PointF((float)paxtmp.ArrivalTime, (float)paxtmp.LeavingTime));
                        alOccupationTime.Add(new PointF((float)paxtmp.ArrivalTime, (float)paxtmp.LeavingTime)); // >> 1 CalcQueueOccupation_V0 issue
                        /*
                        PointF paxOccupation = getPaxOccupationForAirport(paxtmp);
                        if (paxOccupation.X != -1 && paxOccupation.Y != -1)
                            alOccupationTime.Add(paxOccupation);
                        */
                        // << Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
                    }
                    #region Pour les vols (Depart / arrivés)
                    int iFPId = paxtmp.FPDId;
                    if (iFPId != 0)
                    {
                        if (!htDFlightOccupation.Contains(iFPId))
                        {
                            htDFlightOccupation.Add(iFPId, new FlightStatistics(iFPId));
                        }
                        FlightStatistics fsTmp = (FlightStatistics)htDFlightOccupation[iFPId];
                        if (paxtmp.HadMissed)
                        {
                            fsTmp.AddMissedPax();
                        }
                        else if (paxtmp.Stopped)
                        {
                            fsTmp.AddStoppedPax();
                        }
                        else if (paxtmp.Lost)
                        {
                            fsTmp.AddLostPax();
                        }
                        else
                        {
                            fsTmp.AddPax();
                        }
                    }
                    iFPId = paxtmp.FPAId;
                    if (iFPId != 0)
                    {
                        if (!htAFlightOccupation.Contains(iFPId))
                        {
                            htAFlightOccupation.Add(iFPId, new FlightStatistics(iFPId));
                        }
                        FlightStatistics fsTmp = (FlightStatistics)htAFlightOccupation[iFPId];
                        if (paxtmp.HadMissed)
                        {
                            fsTmp.AddMissedPax();
                        }
                        else if (paxtmp.Stopped)
                        {
                            fsTmp.AddStoppedPax();
                        }
                        else if (paxtmp.Lost)
                        {
                            fsTmp.AddLostPax();
                        }
                        else
                        {
                            fsTmp.AddPax();
                        }
                    }
                    #endregion
                }

                // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS)                
                //DataTable dtResult = ResultFunctions.CalcQueueOccupationWithLeavingTimes("Airport_Occupation",
                //    alOccupationTime, dtBeginTime_, dtEndTime_, dPasOccupation, "Nb Pax", bSlidingHour_, true,
                //    analysisRange, // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                //    out totalOccupation);   // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent

                totalOccupation = 0;
                foreach (PointF occupation in alOccupationTime)
                    totalOccupation += occupation.Y;

                // >> 2 CalcQueueOccupation_V0 issue
                /*
                DataTable dtResult = ResultFunctions.CalcQueueOccupation_V0("Airport_Occupation",
                    alOccupationTime, dtBeginTime_, dtEndTime_, dPasOccupation, "Nb Pax", bSlidingHour_, true,
                    analysisRange);
                */
                DataTable dtResult = ResultFunctions.CalcQueueOccupationWithLeavingTimes("Airport_Occupation",
                                alOccupationTime, dtBeginTime_, dtEndTime_, dPasOccupation, "Nb Pax", bSlidingHour_, true,
                                analysisRange);

                // << Task #14902 Improve Dynamic Occupation tables (PAX & BHS)

                htResults.Add(dtResult.TableName, dtResult);

                if (DeskInformations2_.ContainsKey("Airport Reports"))
                {
                    DeskReport drAirport = (DeskReport)DeskInformations2_["Airport Reports"];
                    Double[] tdStats = OverallTools.DataFunctions.GetStatColumn(dtResult, "Min Occupation");
                    Double[] tdStats2 = OverallTools.DataFunctions.GetStatColumn(dtResult, "Average Occupation");
                    Double[] tdStats3 = OverallTools.DataFunctions.GetStatColumn(dtResult, "Max Occupation");
                    if ((tdStats != null) && (tdStats2 != null) && (tdStats3 != null))
                    {
                        drAirport.AddQueueOccupation(tdStats[0], tdStats3[1], tdStats2[2]);
                    }
                }


                DataTable dtDFlightResults = new DataTable("DepartureFlightStatistics");
                dtDFlightResults.Columns.Add(GlobalNames.sFPD_A_Column_ID, typeof(Int32));
                dtDFlightResults.Columns.Add("Passengers", typeof(Int32));
                dtDFlightResults.Columns.Add("Missed", typeof(Int32));
                dtDFlightResults.Columns.Add("Stopped", typeof(Int32));
                dtDFlightResults.Columns.Add("Lost", typeof(Int32));
                foreach (FlightStatistics fsTmp in htDFlightOccupation.Values)
                {
                    dtDFlightResults.Rows.Add(fsTmp.getLine());
                }
                htResults.Add(dtDFlightResults.TableName, dtDFlightResults);
                DataTable dtAFlightResults = new DataTable("ArrivalFlightStatistics");
                dtAFlightResults.Columns.Add(GlobalNames.sFPD_A_Column_ID, typeof(Int32));
                dtAFlightResults.Columns.Add("Passengers", typeof(Int32));
                dtAFlightResults.Columns.Add("Missed", typeof(Int32));
                dtAFlightResults.Columns.Add("Stopped", typeof(Int32));
                dtAFlightResults.Columns.Add("Lost", typeof(Int32));
                foreach (FlightStatistics fsTmp in htAFlightOccupation.Values)
                {
                    dtAFlightResults.Rows.Add(fsTmp.getLine());
                }
                htResults.Add(dtAFlightResults.TableName, dtAFlightResults);
            }

            // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
            private PointF getPaxOccupationForAirport(PaxResultsStruct pax)
            {
                float entryTime = -1;
                float exitTime = -1;
                PointF paxOccupation = new PointF(entryTime, exitTime);

                if (pax.alPaxTravel.Count > 0)
                {
                    PaxResultsStruct.paxTravelData firstRecordedPoint = pax.alPaxTravel[0];
                    PaxResultsStruct.paxTravelData lastRecordedPoint = pax.alPaxTravel[pax.alPaxTravel.Count - 1];

                    entryTime = (float)firstRecordedPoint.ArrivalTime;
                    if (pax.Stopped)
                        exitTime = (float)PaxResultsStruct.dEndTime;
                    else
                        exitTime = (float)lastRecordedPoint.LeavingTime;
                    paxOccupation = new PointF(entryTime, exitTime - entryTime);
                }
                return paxOccupation;
            }
            // << Task #14902 Improve Dynamic Occupation tables (PAX & BHS)

            #region Partie de code pour JNK LHR 2010
            private enum TableType { Global, Originating, Terminating, Transferring, Missed, Stopped };
            private void extractPaxInformationsJNKForLHR()
            {
                int iNbClasses = (int)(60.0 / dPasPaxDistribution);
                if (iNbClasses < 5)
                    iNbClasses = 8;
                slResults = new SortedList();
                slResults.Add(TableType.Global.ToString(), extractInformationsN1(TableType.Global, dPasPaxDistribution, iNbClasses, false, -1));
                slResults.Add(TableType.Originating.ToString(), extractInformationsN1(TableType.Originating, dPasPaxDistribution, iNbClasses, false, -1));
                slResults.Add(TableType.Terminating.ToString(), extractInformationsN1(TableType.Terminating, dPasPaxDistribution, iNbClasses, false, -1));
                slResults.Add(TableType.Transferring.ToString(), extractInformationsN1(TableType.Transferring, dPasPaxDistribution, iNbClasses, false, -1));

                slResults.Add(TableType.Global.ToString() + "_T4", extractInformationsN1(TableType.Global, dPasPaxDistribution, iNbClasses, true, -1));
                slResults.Add(TableType.Originating.ToString() + "_T4", extractInformationsN1(TableType.Originating, dPasPaxDistribution, iNbClasses, true, -1));
                slResults.Add(TableType.Transferring.ToString() + "_T4", extractInformationsN1(TableType.Transferring, dPasPaxDistribution, iNbClasses, true, -1));

                slResults.Add(TableType.Global.ToString() + "_T4_MUP1", extractInformationsN1(TableType.Global, dPasPaxDistribution, iNbClasses, true, 1));
                slResults.Add(TableType.Global.ToString() + "_T4_MUP2", extractInformationsN1(TableType.Global, dPasPaxDistribution, iNbClasses, true, 2));
                slResults.Add(TableType.Global.ToString() + "_T4_MUP3", extractInformationsN1(TableType.Global, dPasPaxDistribution, iNbClasses, true, 3));
                slResults.Add(TableType.Global.ToString() + "_T4_MUP4", extractInformationsN1(TableType.Global, dPasPaxDistribution, iNbClasses, true, 4));
                slResults.Add(TableType.Originating.ToString() + "_T4_MUP1", extractInformationsN1(TableType.Originating, dPasPaxDistribution, iNbClasses, true, 1));
                slResults.Add(TableType.Originating.ToString() + "_T4_MUP2", extractInformationsN1(TableType.Originating, dPasPaxDistribution, iNbClasses, true, 2));
                slResults.Add(TableType.Originating.ToString() + "_T4_MUP3", extractInformationsN1(TableType.Originating, dPasPaxDistribution, iNbClasses, true, 3));
                slResults.Add(TableType.Originating.ToString() + "_T4_MUP4", extractInformationsN1(TableType.Originating, dPasPaxDistribution, iNbClasses, true, 4));
                slResults.Add(TableType.Transferring.ToString() + "_T4_MUP1", extractInformationsN1(TableType.Transferring, dPasPaxDistribution, iNbClasses, true, 1));
                slResults.Add(TableType.Transferring.ToString() + "_T4_MUP2", extractInformationsN1(TableType.Transferring, dPasPaxDistribution, iNbClasses, true, 2));
                slResults.Add(TableType.Transferring.ToString() + "_T4_MUP3", extractInformationsN1(TableType.Transferring, dPasPaxDistribution, iNbClasses, true, 3));
                slResults.Add(TableType.Transferring.ToString() + "_T4_MUP4", extractInformationsN1(TableType.Transferring, dPasPaxDistribution, iNbClasses, true, 4));

                try
                {
                    slResults.Add("PaxTime", getPaxInformation(PaxResults, dtBeginTime_));
                }
                catch (Exception exc)
                {
                    OverallTools.ExternFunctions.PrintLogFile("Except02024: " + this.GetType().ToString() + " throw an exception: " + exc.Message);
                }

            }
            private static DataTable getPaxInformation(Dictionary<Int32, PaxResultsStruct> htPax, DateTime dtBegin)
            {
                DataTable dtResults = new DataTable("PaxTime");
                dtResults.Columns.Add("PaxId", typeof(String));
                dtResults.Columns.Add("ArrivalTime", typeof(String));
                dtResults.Columns.Add("DwellTime (incl. Q) (s)", typeof(Double));
                dtResults.Columns.Add("DwellTime (excl. Q) (s)", typeof(Double));
                dtResults.Columns.Add("Recirculation (round)", typeof(Int32));
                dtResults.Columns.Add("Standard", typeof(Boolean));

                dtResults.Columns.Add("Front", typeof(Boolean));
                dtResults.Columns.Add("Back", typeof(Boolean));
                dtResults.Columns.Add("BackWest", typeof(Boolean));
                dtResults.Columns.Add("BackEast", typeof(Boolean));

                dtResults.Columns.Add("HBS3", typeof(Boolean));
                dtResults.Columns.Add("FrontWestHBS3", typeof(Boolean));
                dtResults.Columns.Add("FrontEastHBS3", typeof(Boolean));
                dtResults.Columns.Add("BackHBS3", typeof(Boolean));

                dtResults.Columns.Add("TSA", typeof(Boolean));
                dtResults.Columns.Add("FrontTSA", typeof(Boolean));
                dtResults.Columns.Add("WesternTSA", typeof(Boolean));
                dtResults.Columns.Add("EasternTSA", typeof(Boolean));

                dtResults.Columns.Add("MES", typeof(Boolean));
                dtResults.Columns.Add("FrontMES", typeof(Boolean));
                dtResults.Columns.Add("BackTransferMES", typeof(Boolean));
                dtResults.Columns.Add("WesternBackMES", typeof(Boolean));
                dtResults.Columns.Add("EasternBackMES", typeof(Boolean));

                dtResults.Columns.Add("Terminal Check In", typeof(Int32));
                dtResults.Columns.Add("Check In Group", typeof(Int32));
                dtResults.Columns.Add("Terminal Arrival", typeof(Int32));
                dtResults.Columns.Add("Terminal Boarding", typeof(Int32));
                dtResults.Columns.Add("Boarding Gate", typeof(Int32));

                dtResults.Columns.Add("Transferred", typeof(Boolean));
                dtResults.Columns.Add("Originating", typeof(Boolean));
                dtResults.Columns.Add("Terminating", typeof(Boolean));
                dtResults.Columns.Add("Stopped", typeof(Boolean));
                dtResults.Columns.Add("Missed", typeof(Boolean));

                dtResults.Columns.Add("FPAFlight", typeof(Int32));
                dtResults.Columns.Add("FPAAirline", typeof(String));
                dtResults.Columns.Add("FPAAirport", typeof(String));
                dtResults.Columns.Add("FPANumber", typeof(String));
                dtResults.Columns.Add("FPAFC", typeof(String));
                dtResults.Columns.Add("FPADate", typeof(DateTime));
                dtResults.Columns.Add("FPATime", typeof(TimeSpan));

                dtResults.Columns.Add("FPDFlight", typeof(Int32));
                dtResults.Columns.Add("FPDAirline", typeof(String));
                dtResults.Columns.Add("FPDAirport", typeof(String));
                dtResults.Columns.Add("FPDNumber", typeof(String));
                dtResults.Columns.Add("FPDFC", typeof(String));
                dtResults.Columns.Add("FPDDate", typeof(DateTime));
                dtResults.Columns.Add("FPDTime", typeof(TimeSpan));

                dtResults.Columns.Add("Back 1_T4T5", typeof(Boolean));
                dtResults.Columns.Add("Back 2_T4T5", typeof(Boolean));
                dtResults.Columns.Add("Back 3_T4T5", typeof(Boolean));
                dtResults.Columns.Add("Back 4_T4T5", typeof(Boolean));
                dtResults.Columns.Add("Back 1_T1T3", typeof(Boolean));
                dtResults.Columns.Add("Back 2_T1T3", typeof(Boolean));
                foreach (PaxResultsStruct prsTmp in htPax.Values)
                {
                    dtResults.Rows.Add(prsTmp.getPaxInformations(dtBegin));
                }
                return dtResults;
            }
            private SortedList extractInformationsN1(TableType ttResults, Double dPas, int iNbClasses, bool bT4, int bMakeUp)
            {
                Hashtable htConcernedPax = new Hashtable();
                bool bGlobal = ttResults == TableType.Global;
                bool bOriginating = ttResults == TableType.Originating;
                bool bTransferring = ttResults == TableType.Transferring;
                bool bTerminating = ttResults == TableType.Terminating;
                bool bMissed = ttResults == TableType.Missed;
                bool bStopped = ttResults == TableType.Stopped;
                foreach (PaxResultsStruct paxtmp in PaxResults.Values)
                {
                    if ((paxtmp.isGate) && bT4 && paxtmp.getTerminalBoardingGate != 4)
                        continue;
                    if ((bMakeUp != -1) && (paxtmp.getBoardingGateNumber != bMakeUp))
                        continue;
                    if (paxtmp.HadMissed || paxtmp.Stopped)
                    {
                        if (bMissed)
                            htConcernedPax.Add(paxtmp.IdPax, paxtmp);
                        else if (bStopped)
                            htConcernedPax.Add(paxtmp.IdPax, paxtmp);
                        continue;
                    }
                    if (bOriginating && paxtmp.IsFPD && (!paxtmp.isTransferred))
                        htConcernedPax.Add(paxtmp.IdPax, paxtmp);
                    else if (bTerminating && paxtmp.IsFPA && (!paxtmp.isTransferred))
                        htConcernedPax.Add(paxtmp.IdPax, paxtmp);
                    else if (bTransferring && paxtmp.isTransferred)
                        htConcernedPax.Add(paxtmp.IdPax, paxtmp);
                    else if (bGlobal)
                        htConcernedPax.Add(paxtmp.IdPax, paxtmp);
                }
                String sSuffixe = "_";
                if (bT4)
                    sSuffixe += "T4_";
                if (bMakeUp != -1)
                    sSuffixe += "MUP" + bMakeUp.ToString() + "_";
                return extractInformationsN2(ttResults.ToString() + sSuffixe, htConcernedPax, dPas, iNbClasses);
            }

            private static SortedList extractInformationsN2(String sTablesName, Hashtable htConcernedPax, Double dPas, int iNbClasses)
            {
                if ((htConcernedPax == null) || (htConcernedPax.Values.Count == 0))
                    return null;

                SortedList alResults = new SortedList();
                String sTableName = sTablesName + "All";
                DataTable dtTmp = extractInformations(sTableName, htConcernedPax, dPas, iNbClasses);
                if (dtTmp != null)
                    alResults.Add(sTableName, dtTmp);
                Hashtable htStandard = new Hashtable();
                Hashtable htStandardBackWest = new Hashtable();
                Hashtable htStandardBAckEast = new Hashtable();
                Hashtable htHBS3 = new Hashtable();
                Hashtable htHBS3Back = new Hashtable();

                Hashtable htTSA = new Hashtable();
                Hashtable htTSABackWest = new Hashtable();
                Hashtable htTSABackEast = new Hashtable();
                Hashtable htMES = new Hashtable();
                Hashtable htMESBackTransfer = new Hashtable();
                Hashtable htMESBackWest = new Hashtable();
                Hashtable htMESBackEast = new Hashtable();
                #region Séparations des différents groupes
                foreach (PaxResultsStruct paxtmp in htConcernedPax.Values)
                {
                    if (paxtmp.isStandard)
                    {
                        htStandard.Add(paxtmp.IdPax, paxtmp);
                        if (paxtmp.isBackWest)
                            htStandardBackWest.Add(paxtmp.IdPax, paxtmp);
                        else if (paxtmp.isBackEast)
                            htStandardBAckEast.Add(paxtmp.IdPax, paxtmp);
                    }
                    else
                    {
                        if (paxtmp.isHBS3)
                        {
                            htHBS3.Add(paxtmp.IdPax, paxtmp);
                            if (paxtmp.isBackHBS3)
                                htHBS3Back.Add(paxtmp.IdPax, paxtmp);
                        }
                        if (paxtmp.isTSA)
                        {
                            htTSA.Add(paxtmp.IdPax, paxtmp);
                            if (paxtmp.isWesternTSA)
                                htTSABackWest.Add(paxtmp.IdPax, paxtmp);
                            else if (paxtmp.isEasternTSA)
                                htTSABackEast.Add(paxtmp.IdPax, paxtmp);
                        }
                        if (paxtmp.isMES)
                        {
                            htMES.Add(paxtmp.IdPax, paxtmp);
                            if (paxtmp.isWesternBackMES)
                                htMESBackWest.Add(paxtmp.IdPax, paxtmp);
                            else if (paxtmp.isEasternBackMES)
                                htMESBackEast.Add(paxtmp.IdPax, paxtmp);
                            else if (paxtmp.isBackTransferMES)
                                htMESBackTransfer.Add(paxtmp.IdPax, paxtmp);
                        }
                    }
                }
                #endregion

                #region Calcul des différentes tables
                SortedList slStandard = new SortedList();
                sTableName = sTablesName + "Standard_All";
                dtTmp = extractInformations(sTableName, htStandard, dPas, iNbClasses);
                if (dtTmp != null)
                    slStandard.Add(sTableName, dtTmp);
                sTableName = sTablesName + "Standard_Back_West";
                dtTmp = extractInformations(sTableName, htStandardBackWest, dPas, iNbClasses);
                if (dtTmp != null)
                    slStandard.Add(sTableName, dtTmp);
                sTableName = sTablesName + "Standard_Back_East";
                dtTmp = extractInformations(sTableName, htStandardBAckEast, dPas, iNbClasses);
                if (dtTmp != null)
                    slStandard.Add(sTableName, dtTmp);
                if (slStandard.Values.Count != 0)
                    alResults.Add("Standard", slStandard);

                slStandard = new SortedList();
                sTableName = sTablesName + "HBS3_All";
                dtTmp = extractInformations(sTableName, htHBS3, dPas, iNbClasses);
                if (dtTmp != null)
                    slStandard.Add(sTableName, dtTmp);
                sTableName = sTablesName + "HBS3_Back";
                dtTmp = extractInformations(sTableName, htHBS3Back, dPas, iNbClasses);
                if (dtTmp != null)
                    slStandard.Add(sTableName, dtTmp);
                if (slStandard.Values.Count != 0)
                    alResults.Add("HBS3", slStandard);

                slStandard = new SortedList();
                sTableName = sTablesName + "TSA_All";
                dtTmp = extractInformations(sTableName, htTSA, dPas, iNbClasses);
                if (dtTmp != null)
                    slStandard.Add(sTableName, dtTmp);
                sTableName = sTablesName + "TSA_Back_West";
                dtTmp = extractInformations(sTableName, htTSABackWest, dPas, iNbClasses);
                if (dtTmp != null)
                    slStandard.Add(sTableName, dtTmp);
                sTableName = sTablesName + "TSA_Back_East";
                dtTmp = extractInformations(sTableName, htTSABackEast, dPas, iNbClasses);
                if (dtTmp != null)
                    slStandard.Add(sTableName, dtTmp);
                if (slStandard.Values.Count != 0)
                    alResults.Add("TSA", slStandard);

                slStandard = new SortedList();
                sTableName = sTablesName + "MES_All";
                dtTmp = extractInformations(sTableName, htMES, dPas, iNbClasses);
                if (dtTmp != null)
                    slStandard.Add(sTableName, dtTmp);
                sTableName = sTablesName + "MES_Back_Transfer";
                dtTmp = extractInformations(sTableName, htMESBackTransfer, dPas, iNbClasses);
                if (dtTmp != null)
                    slStandard.Add(sTableName, dtTmp);
                sTableName = sTablesName + "MES_Back_West";
                dtTmp = extractInformations(sTableName, htMESBackWest, dPas, iNbClasses);
                if (dtTmp != null)
                    slStandard.Add(sTableName, dtTmp);
                sTableName = sTablesName + "MES_Back_East";
                dtTmp = extractInformations(sTableName, htMESBackEast, dPas, iNbClasses);
                if (dtTmp != null)
                    slStandard.Add(sTableName, dtTmp);
                if (slStandard.Values.Count != 0)
                    alResults.Add("MES", slStandard);
                #endregion
                return alResults;
            }
            private static DataTable extractInformations(String sTableName, Hashtable htConcernedPax, Double dPas, int iNbClasses)
            {
                if ((htConcernedPax == null) || (htConcernedPax.Values.Count == 0))
                    return null;
                DataTable dtResult = ResultFunctions.BuildClassTable(sTableName,
                                                            dPas,
                                                            iNbClasses,
                                                            0,
                                                            "Minutes",
                                                            new string[] { "TotalTimeDistribution", "TotalWalkingTimeDistribution", "TotalWaitingTimeDistribution", "TotalProcessTimeDistribution" });
                foreach (PaxResultsStruct paxtmp in htConcernedPax.Values)
                {
                    int iIndexTime = ResultFunctions.DetermineClass(paxtmp.TotalPresentTime, dPas, iNbClasses);
                    int iIndexTravelTime = ResultFunctions.DetermineClass(paxtmp.TotalTravelTime, dPas, iNbClasses);
                    int iIndexWaitingTime = ResultFunctions.DetermineClass(paxtmp.TotalWaitingTime, dPas, iNbClasses);
                    int iIndexProcessingTime = ResultFunctions.DetermineClass(paxtmp.TotalProcessTime, dPas, iNbClasses);
                    if (iIndexTime != -1)
                        ResultFunctions.IncrementLine(dtResult, 1, iIndexTime);
                    if (iIndexTravelTime != -1)
                        ResultFunctions.IncrementLine(dtResult, 2, iIndexTravelTime);
                    if (iIndexWaitingTime != -1)
                        ResultFunctions.IncrementLine(dtResult, 3, iIndexWaitingTime);
                    if (iIndexProcessingTime != -1)
                        ResultFunctions.IncrementLine(dtResult, 4, iIndexProcessingTime);
                }
                ResultFunctions.GenerateRepartition(dtResult, 1, "TotalTimeDistribution (%)", "TotalTimeDistribution (Cumul)");
                ResultFunctions.GenerateRepartition(dtResult, 2, "TotalWalkingTimeDistribution (%)", "TotalWalkingTimeDistribution (Cumul)");
                ResultFunctions.GenerateRepartition(dtResult, 3, "TotalWaitingTimeDistribution (%)", "TotalWaitingTimeDistribution (Cumul)");
                ResultFunctions.GenerateRepartition(dtResult, 4, "TotalProcessTimeDistribution (%)", "TotalProcessTimeDistribution (Cumul)");

                return dtResult;
            }
            #endregion

            // << Task #8618 Pax2Sim - Dynamic Analysis - Pax - histograns and timeline tables for Dwell Area
            internal class PaxInfo
            {
                private int paxId_;
                private DateTime arrivalTime_;
                private double totalTime_;
                private double totalWalkingTime_;
                private double totalWaitingTime_;
                private double totalProcessTime_;
                private double totalTimeToBoardingGate_;

                public int paxId
                {
                    get { return paxId_; }
                    set { paxId_ = value; }
                }
                public DateTime arrivalTime
                {
                    get { return arrivalTime_; }
                    set { arrivalTime_ = value; }
                }
                public double totalTime
                {
                    get { return totalTime_; }
                    set { totalTime_ = value; }
                }
                public double totalWalkingTime
                {
                    get { return totalWalkingTime_; }
                    set { totalWalkingTime_ = value; }
                }
                public double totalWaitingTime
                {
                    get { return totalWaitingTime_; }
                    set { totalWaitingTime_ = value; }
                }
                public double totalProcessTime
                {
                    get { return totalProcessTime_; }
                    set { totalProcessTime_ = value; }
                }
                public double totalTimeToBoardingGate
                {
                    get { return totalTimeToBoardingGate_; }
                    set { totalTimeToBoardingGate_ = value; }
                }

                public bool isDeparture { get; set; }
                public bool isArrival { get; set; }

                public PaxInfo(int pPaxId, DateTime pArrivalTime, double pTotalTime, double pTotalWalkingTime,
                    double pTotalWaitingTime, double pTotalProcessTime, double pTotalTimeToBoardingGate,
                    bool pIsDeparture, bool pIsArrival)
                {
                    paxId_ = pPaxId;
                    arrivalTime_ = pArrivalTime;
                    totalTime_ = pTotalTime;
                    totalWalkingTime_ = pTotalWalkingTime;
                    totalWaitingTime_ = pTotalWaitingTime;
                    totalProcessTime_ = pTotalProcessTime;
                    totalTimeToBoardingGate_ = pTotalTimeToBoardingGate;
                    isDeparture = pIsDeparture;
                    isArrival = pIsArrival;
                }

            }

            List<PaxInfo> totalPaxList = new List<PaxInfo>();
            List<PaxInfo> missedPaxList = new List<PaxInfo>();
            List<PaxInfo> stoppedPaxList = new List<PaxInfo>();
            List<PaxInfo> lostPaxList = new List<PaxInfo>();
            List<PaxInfo> arrivalPaxList = new List<PaxInfo>();
            List<PaxInfo> originatingPaxList = new List<PaxInfo>();
            List<PaxInfo> transferPaxList = new List<PaxInfo>();
            List<PaxInfo> departurePaxList = new List<PaxInfo>();
            // >> Task #8618 Pax2Sim - Dynamic Analysis - Pax - histograns and timeline tables for Dwell Area

            /// <summary>
            /// Function that will calculate all the tables located in the directory Airport / Dwell times
            /// </summary>
            private void extractPaxInformations()
            {
                #region In system Time
                PaxGeneralIST_ = new DataTable("Passengers_IST");
                int iIndexTimeIST = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("Time", typeof(DateTime));

                // << Task #7570 new Desk and extra information for Pax -Phase I B                
                int iIndexPaxId_IST = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("PAX ID", typeof(String));
                // >> Task #7570 new Desk and extra information for Pax -Phase I B

                int iIndexTotalTime = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("Total Time", typeof(Double));
                int iIndexTotalTimeBoarding = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("Total Time To Boarding Gate", typeof(Double));
                int iIndexWaitingTimeIST = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("Total Waiting Time", typeof(Double));
                int iIndexWaitingTimeBoarding = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("Total Waiting Time Before Boarding Gate", typeof(Double));

                // << Task #7570 new Desk and extra information for Pax -Phase I B
                int iIndexFPA_ID_IST = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("FPA " + GlobalNames.sFPD_A_Column_ID, typeof(String));
                int iIndexFPA_FLIGHTN_IST = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("FPA " + GlobalNames.sFPD_A_Column_FlightN, typeof(String));
                int iIndexFPA_AIRLINECODE_IST = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("FPA " + GlobalNames.sFPD_A_Column_AirlineCode, typeof(String));
                int iIndexFPA_AIRPORTCODE_IST = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("FPA " + GlobalNames.sFPD_A_Column_AirportCode, typeof(String));
                int iIndexFPA_FLIGHTCATEGORY_IST = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("FPA " + GlobalNames.sFPD_A_Column_FlightCategory, typeof(String));

                int iIndexFPA_FPACLASS_IST = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("FPA " + GlobalNames.sPaxPlan_FPAClass, typeof(String));
                int iIndexFPA_TerminalGate_IST = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("FPA " + GlobalNames.sFPD_A_Column_TerminalGate, typeof(Int32));
                int iIndexFPA_ArrivalGate_IST = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("FPA " + GlobalNames.sFPA_Column_ArrivalGate, typeof(Int32));
                int iIndexFPA_TerminalReclaim_IST = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("FPA " + GlobalNames.sFPA_Column_TerminalReclaim, typeof(Int32));
                int iIndexFPA_ReclaimObject_IST = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("FPA " + GlobalNames.sFPA_Column_ReclaimObject, typeof(Int32));

                int iIndexFPD_ID_IST = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("FPD " + GlobalNames.sFPD_A_Column_ID, typeof(String));
                int iIndexFPD_FlightN_IST = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("FPD " + GlobalNames.sFPD_A_Column_FlightN, typeof(String));
                int iIndexFPD_AirlineCode_IST = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("FPD " + GlobalNames.sFPD_A_Column_AirlineCode, typeof(String));
                int iIndexFPD_AirportCode_IST = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("FPD " + GlobalNames.sFPD_A_Column_AirportCode, typeof(String));
                int iIndexFPD_FlightCategory_IST = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("FPD " + GlobalNames.sFPD_A_Column_FlightCategory, typeof(String));

                int iIndexFPD_FPDClass_IST = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("FPD " + GlobalNames.sPaxPlan_FPDClass, typeof(String));
                int iIndexFPD_TerminalCheckIn_IST = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("FPD " + GlobalNames.sFPD_Column_TerminalCI, typeof(Int32));
                int iIndexFPD_CheckIn_IST = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("FPD " + PAX2SIM.sCheckIn, typeof(Int32));
                int iIndexFPD_TerminalGate_IST = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("FPD " + GlobalNames.sFPD_A_Column_TerminalGate, typeof(Int32));
                int iIndexFPD_BoardingGate_IST = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("FPD " + GlobalNames.sFPD_Column_BoardingGate, typeof(Int32));

                int iIndex_SelfCI_IST = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("FPD " + GlobalNames.sPaxPlan_SelfCI, typeof(Boolean));
                int iIndex_PassportType_IST = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("Passport Type", typeof(String));
                int iIndex_TransferType_IST = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("Transfer Type", typeof(String));
                // >> Task #7570 new Desk and extra information for Pax -Phase I B

                int iIndexTerminating = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("Terminating", typeof(Boolean));
                int iIndexTransferring = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("Transferring", typeof(Boolean));
                int iIndexOriginating = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("Originating", typeof(Boolean));

                int iIndexMissed = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("Missed", typeof(Boolean));
                int iIndexStopped = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("Stopped", typeof(Boolean));
                int iIndexLost = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add("Lost", typeof(Boolean));

                // << Task #7570 new Desk and extra information for Pax -Phase I B
                int iIndexNbBags = PaxGeneralIST_.Columns.Count; ;
                PaxGeneralIST_.Columns.Add("Nb Bags", typeof(String));
                int iIndexNbOOGBags = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add(GlobalNames.sPaxPlan_BagsOOG, typeof(String));
                int iIndexNbTroleys = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add(GlobalNames.sPaxPlan_Trolleys, typeof(String));
                int iIndexNbVisitors = PaxGeneralIST_.Columns.Count;
                PaxGeneralIST_.Columns.Add(GlobalNames.sPaxPlan_Visitors, typeof(String));
                // >> Task #7570 new Desk and extra information for Pax -Phase I B

                // << Task #7949 Capacity Analysis - IST tables modification
                Dictionary<string, int> indexesForUserAttribColumnsDictionary = new Dictionary<string, int>();
                if (userAttributesDistributionTables != null && userAttributesDistributionTables.Count > 0)
                {
                    foreach (KeyValuePair<string, DataManagement.NormalTable> pair in userAttributesDistributionTables)
                    {
                        String userAttribute = pair.Key;
                        int columnIndex = PaxGeneralIST_.Columns.Count;
                        PaxGeneralIST_.Columns.Add(userAttribute, typeof(String));
                        if (columnIndex != -1)
                            indexesForUserAttribColumnsDictionary.Add(userAttribute, columnIndex);
                    }
                }
                // >> Task #7949 Capacity Analysis - IST tables modification
                /*Ici ajouter les informations concernant les vols.*/
                #endregion


                int iNbClasses = (int)(60.0 / dPasPaxDistribution);
                if (iNbClasses < 5)
                    iNbClasses = 8;

                // << Task #8069 Pax Capacity Analysis - statistics missing from the Pax_Time_Distrib tables 
                /*
                PaxDistribution_ = ResultFunctions.BuildClassTable("Pax_Time_Distrib_Global", dPasPaxDistribution,
                    iNbClasses, 0, "Minutes",
                    new string[] { "TotalTimeDistribution", "TotalWalkingTimeDistribution", "TotalWaitingTimeDistribution",
                        "TotalProcessTimeDistribution", GlobalNames.TotalTimeToBoardingGateDistributionColumnName, });
                 */
                // << Task #8618 Pax2Sim - Dynamic Analysis - Pax - histograns and timeline tables for Dwell Area                
                PaxDistribution_ = ResultFunctions.BuildClassTable("Pax_Time_Distrib_Global_BarChart", dPasPaxDistribution,
                    iNbClasses, 0, "Minutes",
                    new string[] { "TotalTimeDistribution", "TotalWalkingTimeDistribution", "TotalWaitingTimeDistribution",
                        "TotalProcessTimeDistribution", GlobalNames.TotalTimeToBoardingGateDistributionColumnName, });
                // >> Task #8618 Pax2Sim - Dynamic Analysis - Pax - histograns and timeline tables for Dwell Area
                // >> Task #8069 Pax Capacity Analysis - statistics missing from the Pax_Time_Distrib tables

                PaxDistribution_.PrimaryKey = new DataColumn[1] { PaxDistribution_.Columns[0] };

                /*                
                PaxDistributionArrival_ = ResultFunctions.BuildClassTable("Pax_Time_Distrib_Terminating", dPasPaxDistribution, iNbClasses, 0, "Minutes", new string[] { "TotalTimeDistribution", "TotalWalkingTimeDistribution", "TotalWaitingTimeDistribution", "TotalProcessTimeDistribution" });                
                // << Task #8069 Pax Capacity Analysis - statistics missing from the Pax_Time_Distrib tables                
                PaxDistributionDeparture_ = ResultFunctions.BuildClassTable("Pax_Time_Distrib_Originating",
                    dPasPaxDistribution, iNbClasses, 0, "Minutes",
                    new string[] { "TotalTimeDistribution", "TotalWalkingTimeDistribution", "TotalWaitingTimeDistribution",
                        "TotalProcessTimeDistribution", "TotalTimeToBoardingGate" });
                
                PaxDistributionTransfer_ = ResultFunctions.BuildClassTable("Pax_Time_Distrib_Transfer",
                    dPasPaxDistribution, iNbClasses, 0, "Minutes",
                    new string[] { "TotalTimeDistribution", "TotalWalkingTimeDistribution", "TotalWaitingTimeDistribution",
                        "TotalProcessTimeDistribution", "TotalTimeToBoardingGate" });
                
                PaxDistributionMissed_ = ResultFunctions.BuildClassTable("Pax_Time_Distrib_Missed",
                    dPasPaxDistribution, iNbClasses, 0, "Minutes",
                    new string[] { "TotalTimeDistribution", "TotalWalkingTimeDistribution", "TotalWaitingTimeDistribution",
                        "TotalProcessTimeDistribution", GlobalNames.TotalTimeToBoardingGateDistributionColumnName });
                
                PaxDistributionStopped_ = ResultFunctions.BuildClassTable("Pax_Time_Distrib_Stopped",
                    dPasPaxDistribution, iNbClasses, 0, "Minutes",
                    new string[] { "TotalTimeDistribution", "TotalWalkingTimeDistribution", "TotalWaitingTimeDistribution",
                        "TotalProcessTimeDistribution", GlobalNames.TotalTimeToBoardingGateDistributionColumnName });
                
                PaxDistributionLost_ = ResultFunctions.BuildClassTable("Pax_Time_Distrib_Lost",
                    dPasPaxDistribution, iNbClasses, 0, "Minutes",
                    new string[] { "TotalTimeDistribution", "TotalWalkingTimeDistribution", "TotalWaitingTimeDistribution",
                        "TotalProcessTimeDistribution", GlobalNames.TotalTimeToBoardingGateDistributionColumnName });
                // >> Task #8069 Pax Capacity Analysis - statistics missing from the Pax_Time_Distrib tables
                */

                // << Task #8618 Pax2Sim - Dynamic Analysis - Pax - histograns and timeline tables for Dwell Area
                PaxDistributionArrival_ = ResultFunctions.BuildClassTable("Pax_Time_Distrib_Terminating_BarChart",
                    dPasPaxDistribution, iNbClasses, 0, "Minutes",
                    new string[] { "TotalTimeDistribution", "TotalWalkingTimeDistribution", "TotalWaitingTimeDistribution",
                        "TotalProcessTimeDistribution" });
                PaxDistributionDeparture_ = ResultFunctions.BuildClassTable("Pax_Time_Distrib_Originating_BarChart",
                    dPasPaxDistribution, iNbClasses, 0, "Minutes",
                    new string[] { "TotalTimeDistribution", "TotalWalkingTimeDistribution", "TotalWaitingTimeDistribution",
                        "TotalProcessTimeDistribution", "TotalTimeToBoardingGate" });

                PaxDistributionTransfer_ = ResultFunctions.BuildClassTable("Pax_Time_Distrib_Transfer_BarChart",
                    dPasPaxDistribution, iNbClasses, 0, "Minutes",
                    new string[] { "TotalTimeDistribution", "TotalWalkingTimeDistribution", "TotalWaitingTimeDistribution",
                        "TotalProcessTimeDistribution", "TotalTimeToBoardingGate" });

                PaxDistributionMissed_ = ResultFunctions.BuildClassTable("Pax_Time_Distrib_Missed_BarChart",
                    dPasPaxDistribution, iNbClasses, 0, "Minutes",
                    new string[] { "TotalTimeDistribution", "TotalWalkingTimeDistribution", "TotalWaitingTimeDistribution",
                        "TotalProcessTimeDistribution", GlobalNames.TotalTimeToBoardingGateDistributionColumnName });

                PaxDistributionStopped_ = ResultFunctions.BuildClassTable("Pax_Time_Distrib_Stopped_BarChart",
                    dPasPaxDistribution, iNbClasses, 0, "Minutes",
                    new string[] { "TotalTimeDistribution", "TotalWalkingTimeDistribution", "TotalWaitingTimeDistribution",
                        "TotalProcessTimeDistribution", GlobalNames.TotalTimeToBoardingGateDistributionColumnName });

                PaxDistributionLost_ = ResultFunctions.BuildClassTable("Pax_Time_Distrib_Lost_BarChart",
                    dPasPaxDistribution, iNbClasses, 0, "Minutes",
                    new string[] { "TotalTimeDistribution", "TotalWalkingTimeDistribution", "TotalWaitingTimeDistribution",
                        "TotalProcessTimeDistribution", GlobalNames.TotalTimeToBoardingGateDistributionColumnName });

                PaxDistributionOriginatingAndTransfer_ = ResultFunctions.BuildClassTable("Pax_Time_Distrib_Departure_BarChart",
                    dPasPaxDistribution, iNbClasses, 0, "Minutes",
                    new string[] {"TotalTimeDistribution", "TotalWalkingTimeDistribution", "TotalWaitingTimeDistribution",
                        "TotalProcessTimeDistribution", "TotalTimeToBoardingGate"});

                // >> Task #8618 Pax2Sim - Dynamic Analysis - Pax - histograns and timeline tables for Dwell Area

                foreach (PaxResultsStruct paxtmp in PaxResults.Values)
                {
                    if (!paxtmp.CheckPaxIsValidForFilter(tfFilter))
                        continue;

                    DataRow drNewRow = PaxGeneralIST_.NewRow();
                    drNewRow[iIndexTimeIST] = dtBeginTime_.AddMinutes(paxtmp.ArrivalTime);

                    // << Task #7570 new Desk and extra information for Pax -Phase I B
                    drNewRow[iIndexPaxId_IST] = paxtmp.IdPax.ToString();
                    if (paxtmp.FPAInformations != null)
                    {
                        drNewRow[iIndexFPA_ID_IST] = paxtmp.FPAInformations.iIdFlight.ToString();
                        drNewRow[iIndexFPA_FLIGHTN_IST] = paxtmp.FPAInformations.sFlightName;
                        drNewRow[iIndexFPA_AIRLINECODE_IST] = paxtmp.FPAInformations.sAirline;
                        drNewRow[iIndexFPA_AIRPORTCODE_IST] = paxtmp.FPAInformations.sAirport;
                        drNewRow[iIndexFPA_FLIGHTCATEGORY_IST] = paxtmp.FPAInformations.sFlightCategory;
                    }
                    else
                    {
                        drNewRow[iIndexFPA_ID_IST] = "";
                        drNewRow[iIndexFPA_FLIGHTN_IST] = "";
                        drNewRow[iIndexFPA_AIRLINECODE_IST] = "";
                        drNewRow[iIndexFPA_AIRPORTCODE_IST] = "";
                        drNewRow[iIndexFPA_FLIGHTCATEGORY_IST] = "";
                    }
                    if (paxtmp.Informations != null)
                    {
                        drNewRow[iIndexFPA_FPACLASS_IST] = paxtmp.Informations.FPA_Class.ToString();
                        drNewRow[iIndexFPA_TerminalGate_IST] = paxtmp.getTerminalArrivalGate;
                        drNewRow[iIndexFPA_ArrivalGate_IST] = paxtmp.getArrivalgGateNumber;
                        drNewRow[iIndexFPA_TerminalReclaim_IST] = paxtmp.getTerminalReclaim;
                        drNewRow[iIndexFPA_ReclaimObject_IST] = paxtmp.getReclaim;

                        drNewRow[iIndexFPD_FPDClass_IST] = paxtmp.Informations.FPD_Class.ToString();
                        drNewRow[iIndexFPD_TerminalCheckIn_IST] = paxtmp.getTerminalCheckIn;
                        drNewRow[iIndexFPD_CheckIn_IST] = paxtmp.getCheckIn;
                        drNewRow[iIndexFPD_TerminalGate_IST] = paxtmp.getTerminalBoardingGate;
                        drNewRow[iIndexFPD_BoardingGate_IST] = paxtmp.getBoardingGateNumber;
                        drNewRow[iIndex_SelfCI_IST] = paxtmp.Informations.SelfCheckIn;

                        if ((paxtmp.Informations.Passport) == 1)
                            drNewRow[iIndex_PassportType_IST] = "Local";
                        else
                            drNewRow[iIndex_PassportType_IST] = "Not Local";

                        if (paxtmp.Informations.Tranfer == 1)
                            drNewRow[iIndex_TransferType_IST] = "Transfer";
                        else if (paxtmp.Informations.Tranfer == 2)
                            drNewRow[iIndex_TransferType_IST] = "ReCheck";
                        else if (paxtmp.Informations.Tranfer == 10)
                            drNewRow[iIndex_TransferType_IST] = "Transfer Desk";
                        else
                            drNewRow[iIndex_TransferType_IST] = "";

                        drNewRow[iIndexNbBags] = paxtmp.Informations.nbBags.ToString();
                        drNewRow[iIndexNbOOGBags] = paxtmp.Informations.nbBagsOOG.ToString();
                        drNewRow[iIndexNbTroleys] = paxtmp.Informations.nbTrolleys.ToString();
                        drNewRow[iIndexNbVisitors] = paxtmp.Informations.nbVisitors.ToString();
                    }
                    else
                    {
                        drNewRow[iIndexFPA_FPACLASS_IST] = "";
                        drNewRow[iIndexFPA_TerminalGate_IST] = 0;
                        drNewRow[iIndexFPA_ArrivalGate_IST] = 0;
                        drNewRow[iIndexFPA_TerminalReclaim_IST] = 0;
                        drNewRow[iIndexFPA_ReclaimObject_IST] = 0;

                        drNewRow[iIndexFPD_FPDClass_IST] = "";
                        drNewRow[iIndexFPD_TerminalCheckIn_IST] = 0;
                        drNewRow[iIndexFPD_CheckIn_IST] = 0;
                        drNewRow[iIndexFPD_TerminalGate_IST] = 0;
                        drNewRow[iIndexFPD_BoardingGate_IST] = 0;
                        drNewRow[iIndex_SelfCI_IST] = false;

                        drNewRow[iIndex_PassportType_IST] = "";
                        drNewRow[iIndex_TransferType_IST] = "";

                        // if no information exists about the bags/troleys/visitors we set the fields to "" not 0 or -1 !!!
                        drNewRow[iIndexNbBags] = "";
                        drNewRow[iIndexNbOOGBags] = "";
                        drNewRow[iIndexNbTroleys] = "";
                        drNewRow[iIndexNbVisitors] = "";
                    }

                    if (paxtmp.FPDInformations != null)
                    {
                        drNewRow[iIndexFPD_ID_IST] = paxtmp.FPDInformations.iIdFlight.ToString();
                        drNewRow[iIndexFPD_FlightN_IST] = paxtmp.FPDInformations.sFlightName;
                        drNewRow[iIndexFPD_AirlineCode_IST] = paxtmp.FPDInformations.sAirline;
                        drNewRow[iIndexFPD_AirportCode_IST] = paxtmp.FPDInformations.sAirport;
                        drNewRow[iIndexFPD_FlightCategory_IST] = paxtmp.FPDInformations.sFlightCategory;
                    }
                    else
                    {
                        drNewRow[iIndexFPD_ID_IST] = "";
                        drNewRow[iIndexFPD_FlightN_IST] = "";
                        drNewRow[iIndexFPD_AirlineCode_IST] = "";
                        drNewRow[iIndexFPD_AirportCode_IST] = "";
                        drNewRow[iIndexFPD_FlightCategory_IST] = "";
                    }
                    // >> Task #7570 new Desk and extra information for Pax -Phase I B

                    drNewRow[iIndexTotalTime] = Math.Round(paxtmp.TotalPresentTime, 2);
                    drNewRow[iIndexWaitingTimeIST] = Math.Round(paxtmp.TotalWaitingTime, 2);

                    drNewRow[iIndexTransferring] = false;
                    drNewRow[iIndexTerminating] = false;
                    drNewRow[iIndexOriginating] = false;
                    drNewRow[iIndexTotalTimeBoarding] = 0;
                    drNewRow[iIndexWaitingTimeBoarding] = paxtmp.totalWaitingTimeBeforeBoardingGate;    // >> Departure_Statistics Passengers_IST Total time to BG


                    drNewRow[iIndexStopped] = paxtmp.Stopped;
                    drNewRow[iIndexMissed] = paxtmp.HadMissed;
                    drNewRow[iIndexLost] = paxtmp.Lost;

                    int iIndexTime = ResultFunctions.DetermineClass(paxtmp.TotalPresentTime, dPasPaxDistribution, iNbClasses);
                    int iIndexTravelTime = ResultFunctions.DetermineClass(paxtmp.TotalTravelTime, dPasPaxDistribution, iNbClasses);
                    int iIndexWaitingTime = ResultFunctions.DetermineClass(paxtmp.TotalWaitingTime, dPasPaxDistribution, iNbClasses);
                    int iIndexProcessingTime = ResultFunctions.DetermineClass(paxtmp.TotalProcessTime, dPasPaxDistribution, iNbClasses);
                    // << Task #8069 Pax Capacity Analysis - statistics missing from the Pax_Time_Distrib tables
                    int iIndexTotalTimeToBoardingGate = -1;
                    double timeToBoardingGate = -1;
                    if (paxtmp.IsFPD || paxtmp.isTransferred || paxtmp.Lost || paxtmp.HadMissed || paxtmp.Stopped)
                    {
                        if (paxtmp.TotalTransferTime >= 0)
                        {
                            timeToBoardingGate = Math.Round(paxtmp.TotalTransferTime, 2);
                        }
                    }
                    iIndexTotalTimeToBoardingGate = ResultFunctions.DetermineClass(timeToBoardingGate, dPasPaxDistribution, iNbClasses);
                    // >> Task #8069 Pax Capacity Analysis - statistics missing from the Pax_Time_Distrib tables

                    if ((iIndexTime == -1) || (iIndexTravelTime == -1) || (iIndexWaitingTime == -1) || (iIndexProcessingTime == -1))
                        continue;

                    if ((paxtmp.HadMissed) || (paxtmp.Stopped) || (paxtmp.Lost))
                    {
                        DataTable dtTmp = null;
                        if (paxtmp.Stopped)
                            dtTmp = PaxDistributionStopped_;
                        else if (paxtmp.HadMissed)
                            dtTmp = PaxDistributionMissed_;
                        else
                            dtTmp = PaxDistributionLost_;
                        if (DeskInformations2_ != null)
                            paxtmp.setStatistics(DeskInformations2_);
                        ResultFunctions.IncrementLine(dtTmp, 1, iIndexTime);
                        ResultFunctions.IncrementLine(dtTmp, 2, iIndexTravelTime);
                        ResultFunctions.IncrementLine(dtTmp, 3, iIndexWaitingTime);
                        ResultFunctions.IncrementLine(dtTmp, 4, iIndexProcessingTime);
                        // << Task #8069 Pax Capacity Analysis - statistics missing from the Pax_Time_Distrib tables
                        if (iIndexTotalTimeToBoardingGate != -1)
                            ResultFunctions.IncrementLine(dtTmp, 5, iIndexTotalTimeToBoardingGate);
                        // >> Task #8069 Pax Capacity Analysis - statistics missing from the Pax_Time_Distrib tables                        
                        //continue;
                        // << Task #8618 Pax2Sim - Dynamic Analysis - Pax - histograns and timeline tables for Dwell Area
                        DateTime arrivalTime = dtBeginTime_.AddMinutes(paxtmp.ArrivalTime);
                        PaxInfo pax = new PaxInfo(paxtmp.IdPax, arrivalTime, paxtmp.TotalPresentTime, paxtmp.TotalTravelTime,
                            paxtmp.TotalWaitingTime, paxtmp.TotalProcessTime, paxtmp.TotalTransferTime, paxtmp.IsFPD, paxtmp.IsFPA);
                        if (paxtmp.Stopped)
                            stoppedPaxList.Add(pax);
                        else if (paxtmp.HadMissed)
                            missedPaxList.Add(pax);
                        else if (paxtmp.Lost)
                            lostPaxList.Add(pax);
                        // >> Task #8618 Pax2Sim - Dynamic Analysis - Pax - histograns and timeline tables for Dwell Area
                    }
                    if (paxtmp.isTransferred)
                    {
                        drNewRow[iIndexTransferring] = true;
                        if (DeskInformations2_ != null)
                            paxtmp.setStatistics(DeskInformations2_);
                        ResultFunctions.IncrementLine(PaxDistributionTransfer_, 1, iIndexTime);
                        ResultFunctions.IncrementLine(PaxDistributionTransfer_, 2, iIndexTravelTime);
                        ResultFunctions.IncrementLine(PaxDistributionTransfer_, 3, iIndexWaitingTime);
                        ResultFunctions.IncrementLine(PaxDistributionTransfer_, 4, iIndexProcessingTime);
                        // << Bug #9069 PAX2SIM crash with sample step 10, 12                        
                        int maxRowNb = PaxDistributionTransfer_.Rows.Count - 1;
                        int iIndexTransferTime = ResultFunctions.DetermineClass(paxtmp.TotalTransferTime, dPasPaxDistribution, maxRowNb);
                        //int iIndexTransferTime = ResultFunctions.DetermineClass(paxtmp.TotalTransferTime, dPasPaxDistribution, 8);
                        // >> Bug #9069 PAX2SIM crash with sample step 10, 12
                        if (iIndexTransferTime != -1)
                            ResultFunctions.IncrementLine(PaxDistributionTransfer_, 5, iIndexTransferTime);

                        drNewRow[iIndexTotalTimeBoarding] = Math.Round(paxtmp.TotalTransferTime, 2);
                        // << Task #8618 Pax2Sim - Dynamic Analysis - Pax - histograns and timeline tables for Dwell Area
                        DateTime arrivalTime = dtBeginTime_.AddMinutes(paxtmp.ArrivalTime);
                        PaxInfo transferPax = new PaxInfo(paxtmp.IdPax, arrivalTime, paxtmp.TotalPresentTime, paxtmp.TotalTravelTime,
                            paxtmp.TotalWaitingTime, paxtmp.TotalProcessTime, paxtmp.TotalTransferTime, paxtmp.IsFPD, paxtmp.IsFPA);
                        transferPaxList.Add(transferPax);
                        // >> Task #8618 Pax2Sim - Dynamic Analysis - Pax - histograns and timeline tables for Dwell Area
                    }
                    else if (paxtmp.IsFPA)
                    {
                        drNewRow[iIndexTerminating] = true;
                        ResultFunctions.IncrementLine(PaxDistributionArrival_, 1, iIndexTime);
                        ResultFunctions.IncrementLine(PaxDistributionArrival_, 2, iIndexTravelTime);
                        ResultFunctions.IncrementLine(PaxDistributionArrival_, 3, iIndexWaitingTime);
                        ResultFunctions.IncrementLine(PaxDistributionArrival_, 4, iIndexProcessingTime);
                        // << Task #8618 Pax2Sim - Dynamic Analysis - Pax - histograns and timeline tables for Dwell Area
                        DateTime arrivalTime = dtBeginTime_.AddMinutes(paxtmp.ArrivalTime);
                        PaxInfo arrivalPax = new PaxInfo(paxtmp.IdPax, arrivalTime, paxtmp.TotalPresentTime, paxtmp.TotalTravelTime,
                            paxtmp.TotalWaitingTime, paxtmp.TotalProcessTime, paxtmp.TotalTransferTime, paxtmp.IsFPD, paxtmp.IsFPA);
                        arrivalPaxList.Add(arrivalPax);
                        // >> Task #8618 Pax2Sim - Dynamic Analysis - Pax - histograns and timeline tables for Dwell Area
                    }
                    else if (paxtmp.IsFPD)
                    {
                        drNewRow[iIndexOriginating] = true;
                        ResultFunctions.IncrementLine(PaxDistributionDeparture_, 1, iIndexTime);
                        ResultFunctions.IncrementLine(PaxDistributionDeparture_, 2, iIndexTravelTime);
                        ResultFunctions.IncrementLine(PaxDistributionDeparture_, 3, iIndexWaitingTime);
                        ResultFunctions.IncrementLine(PaxDistributionDeparture_, 4, iIndexProcessingTime);
                        // << Bug #9069 PAX2SIM crash with sample step 10, 12
                        int maxRows = PaxDistributionDeparture_.Rows.Count - 1;
                        int iIndexTransferTime = ResultFunctions.DetermineClass(paxtmp.TotalTransferTime, dPasPaxDistribution, maxRows);
                        //int iIndexTransferTime = ResultFunctions.DetermineClass(paxtmp.TotalTransferTime, dPasPaxDistribution, 8);
                        // >> Bug #9069 PAX2SIM crash with sample step 10, 12
                        if (iIndexTransferTime != -1)
                            ResultFunctions.IncrementLine(PaxDistributionDeparture_, 5, iIndexTransferTime);
                        drNewRow[iIndexTotalTimeBoarding] = Math.Round(paxtmp.TotalTransferTime, 2);
                        // << Task #8618 Pax2Sim - Dynamic Analysis - Pax - histograns and timeline tables for Dwell Area
                        DateTime arrivalTime = dtBeginTime_.AddMinutes(paxtmp.ArrivalTime);
                        PaxInfo originatingPax = new PaxInfo(paxtmp.IdPax, arrivalTime, paxtmp.TotalPresentTime, paxtmp.TotalTravelTime,
                            paxtmp.TotalWaitingTime, paxtmp.TotalProcessTime, paxtmp.TotalTransferTime, paxtmp.IsFPD, paxtmp.IsFPA);
                        originatingPaxList.Add(originatingPax);
                        // >> Task #8618 Pax2Sim - Dynamic Analysis - Pax - histograns and timeline tables for Dwell Area
                    }

                    // << Task #8618 Pax2Sim - Dynamic Analysis - Pax - histograns and timeline tables for Dwell Area
                    if (paxtmp.IsFPD || paxtmp.isTransferred)
                    {
                        ResultFunctions.IncrementLine(PaxDistributionOriginatingAndTransfer_, 1, iIndexTime);
                        ResultFunctions.IncrementLine(PaxDistributionOriginatingAndTransfer_, 2, iIndexTravelTime);
                        ResultFunctions.IncrementLine(PaxDistributionOriginatingAndTransfer_, 3, iIndexWaitingTime);
                        ResultFunctions.IncrementLine(PaxDistributionOriginatingAndTransfer_, 4, iIndexProcessingTime);
                        // << Bug #9069 PAX2SIM crash with sample step 10, 12
                        int maxRowIndex = PaxDistributionOriginatingAndTransfer_.Rows.Count - 1;
                        int iIndexTransferTime = ResultFunctions.DetermineClass(paxtmp.TotalTransferTime, dPasPaxDistribution, maxRowIndex);
                        //int iIndexTransferTime = ResultFunctions.DetermineClass(paxtmp.TotalTransferTime, dPasPaxDistribution, 8);
                        // >> Bug #9069 PAX2SIM crash with sample step 10, 12
                        if (iIndexTransferTime != -1)
                            ResultFunctions.IncrementLine(PaxDistributionOriginatingAndTransfer_, 5, iIndexTransferTime);
                        // << Task #8618 Pax2Sim - Dynamic Analysis - Pax - histograns and timeline tables for Dwell Area
                        DateTime arrivalTime = dtBeginTime_.AddMinutes(paxtmp.ArrivalTime);
                        PaxInfo departurePax = new PaxInfo(paxtmp.IdPax, arrivalTime, paxtmp.TotalPresentTime, paxtmp.TotalTravelTime,
                            paxtmp.TotalWaitingTime, paxtmp.TotalProcessTime, paxtmp.TotalTransferTime, paxtmp.IsFPD, paxtmp.IsFPA);
                        departurePaxList.Add(departurePax);
                        // >> Task #8618 Pax2Sim - Dynamic Analysis - Pax - histograns and timeline tables for Dwell Area
                    }
                    // >> Task #8618 Pax2Sim - Dynamic Analysis - Pax - histograns and timeline tables for Dwell Area

                    ResultFunctions.IncrementLine(PaxDistribution_, 1, iIndexTime);
                    ResultFunctions.IncrementLine(PaxDistribution_, 2, iIndexTravelTime);
                    ResultFunctions.IncrementLine(PaxDistribution_, 3, iIndexWaitingTime);
                    ResultFunctions.IncrementLine(PaxDistribution_, 4, iIndexProcessingTime);
                    // << Task #8069 Pax Capacity Analysis - statistics missing from the Pax_Time_Distrib tables
                    if (iIndexTotalTimeToBoardingGate != -1)
                        ResultFunctions.IncrementLine(PaxDistribution_, 5, iIndexTotalTimeToBoardingGate);
                    // >> Task #8069 Pax Capacity Analysis - statistics missing from the Pax_Time_Distrib tables

                    // << Task #8618 Pax2Sim - Dynamic Analysis - Pax - histograns and timeline tables for Dwell Area
                    DateTime paxArrivalTime = dtBeginTime_.AddMinutes(paxtmp.ArrivalTime);
                    PaxInfo globalPax = new PaxInfo(paxtmp.IdPax, paxArrivalTime, paxtmp.TotalPresentTime, paxtmp.TotalTravelTime,
                        paxtmp.TotalWaitingTime, paxtmp.TotalProcessTime, paxtmp.TotalTransferTime, paxtmp.IsFPD, paxtmp.IsFPA);
                    totalPaxList.Add(globalPax);
                    // >> Task #8618 Pax2Sim - Dynamic Analysis - Pax - histograns and timeline tables for Dwell Area

                    // << Task #7949 Capacity Analysis - IST tables modification
                    if (userAttributesDistributionTables != null)
                    {
                        foreach (KeyValuePair<string, DataManagement.NormalTable> pair in userAttributesDistributionTables)
                        {
                            String distributionTableName = pair.Key;
                            int indexColumnPaxPlan = -1;

                            if (indexesForUserAttribColumnsDictionary.TryGetValue(distributionTableName, out indexColumnPaxPlan))
                            {
                                String userAttributeValue = "";

                                if (paxtmp.paxUserAttributesDictionary != null
                                    && paxtmp.paxUserAttributesDictionary.TryGetValue(distributionTableName, out userAttributeValue)
                                    && indexColumnPaxPlan != -1)
                                {
                                    drNewRow[indexColumnPaxPlan] = userAttributeValue;
                                }
                            }
                        }
                    }
                    // >> Task #7949 Capacity Analysis - IST tables modification
                    PaxGeneralIST_.Rows.Add(drNewRow);
                }

                ResultFunctions.GenerateRepartition(PaxDistribution_, 1, "TotalTimeDistribution (%)", "TotalTimeDistribution (Cumul)");
                ResultFunctions.GenerateRepartition(PaxDistribution_, 2, "TotalWalkingTimeDistribution (%)", "TotalWalkingTimeDistribution (Cumul)");
                ResultFunctions.GenerateRepartition(PaxDistribution_, 3, "TotalWaitingTimeDistribution (%)", "TotalWaitingTimeDistribution (Cumul)");
                ResultFunctions.GenerateRepartition(PaxDistribution_, 4, "TotalProcessTimeDistribution (%)", "TotalProcessTimeDistribution (Cumul)");
                // << Task #8069 Pax Capacity Analysis - statistics missing from the Pax_Time_Distrib tables
                ResultFunctions.GenerateRepartition(PaxDistribution_, 5, GlobalNames.TotalTimeToBoardingGateDistributionColumnName + " (%)", GlobalNames.TotalTimeToBoardingGateDistributionColumnName + " (Cumul)");
                // >> Task #8069 Pax Capacity Analysis - statistics missing from the Pax_Time_Distrib tables

                ResultFunctions.GenerateRepartition(PaxDistributionMissed_, 1, "TotalTimeDistribution (%)", "TotalTimeDistribution (Cumul)");
                ResultFunctions.GenerateRepartition(PaxDistributionMissed_, 2, "TotalWalkingTimeDistribution (%)", "TotalWalkingTimeDistribution (Cumul)");
                ResultFunctions.GenerateRepartition(PaxDistributionMissed_, 3, "TotalWaitingTimeDistribution (%)", "TotalWaitingTimeDistribution (Cumul)");
                ResultFunctions.GenerateRepartition(PaxDistributionMissed_, 4, "TotalProcessTimeDistribution (%)", "TotalProcessTimeDistribution (Cumul)");
                // << Task #8069 Pax Capacity Analysis - statistics missing from the Pax_Time_Distrib tables
                ResultFunctions.GenerateRepartition(PaxDistributionMissed_, 5, GlobalNames.TotalTimeToBoardingGateDistributionColumnName + " (%)", GlobalNames.TotalTimeToBoardingGateDistributionColumnName + " (Cumul)");
                // >> Task #8069 Pax Capacity Analysis - statistics missing from the Pax_Time_Distrib tables

                ResultFunctions.GenerateRepartition(PaxDistributionStopped_, 1, "TotalTimeDistribution (%)", "TotalTimeDistribution (Cumul)");
                ResultFunctions.GenerateRepartition(PaxDistributionStopped_, 2, "TotalWalkingTimeDistribution (%)", "TotalWalkingTimeDistribution (Cumul)");
                ResultFunctions.GenerateRepartition(PaxDistributionStopped_, 3, "TotalWaitingTimeDistribution (%)", "TotalWaitingTimeDistribution (Cumul)");
                ResultFunctions.GenerateRepartition(PaxDistributionStopped_, 4, "TotalProcessTimeDistribution (%)", "TotalProcessTimeDistribution (Cumul)");
                // << Task #8069 Pax Capacity Analysis - statistics missing from the Pax_Time_Distrib tables
                ResultFunctions.GenerateRepartition(PaxDistributionStopped_, 5, GlobalNames.TotalTimeToBoardingGateDistributionColumnName + " (%)", GlobalNames.TotalTimeToBoardingGateDistributionColumnName + " (Cumul)");
                // >> Task #8069 Pax Capacity Analysis - statistics missing from the Pax_Time_Distrib tables

                ResultFunctions.GenerateRepartition(PaxDistributionLost_, 1, "TotalTimeDistribution (%)", "TotalTimeDistribution (Cumul)");
                ResultFunctions.GenerateRepartition(PaxDistributionLost_, 2, "TotalWalkingTimeDistribution (%)", "TotalWalkingTimeDistribution (Cumul)");
                ResultFunctions.GenerateRepartition(PaxDistributionLost_, 3, "TotalWaitingTimeDistribution (%)", "TotalWaitingTimeDistribution (Cumul)");
                ResultFunctions.GenerateRepartition(PaxDistributionLost_, 4, "TotalProcessTimeDistribution (%)", "TotalProcessTimeDistribution (Cumul)");
                // << Task #8069 Pax Capacity Analysis - statistics missing from the Pax_Time_Distrib tables
                ResultFunctions.GenerateRepartition(PaxDistributionLost_, 5, GlobalNames.TotalTimeToBoardingGateDistributionColumnName + " (%)", GlobalNames.TotalTimeToBoardingGateDistributionColumnName + " (Cumul)");
                // >> Task #8069 Pax Capacity Analysis - statistics missing from the Pax_Time_Distrib tables

                ResultFunctions.GenerateRepartition(PaxDistributionTransfer_, 1, "TotalTimeDistribution (%)", "TotalTimeDistribution (Cumul)");
                ResultFunctions.GenerateRepartition(PaxDistributionTransfer_, 2, "TotalWalkingTimeDistribution (%)", "TotalWalkingTimeDistribution (Cumul)");
                ResultFunctions.GenerateRepartition(PaxDistributionTransfer_, 3, "TotalWaitingTimeDistribution (%)", "TotalWaitingTimeDistribution (Cumul)");
                ResultFunctions.GenerateRepartition(PaxDistributionTransfer_, 4, "TotalProcessTimeDistribution (%)", "TotalProcessTimeDistribution (Cumul)");
                ResultFunctions.GenerateRepartition(PaxDistributionTransfer_, 5, "TotalTimeToBoardingGate (%)", "TotalTimeToBoardingGate (Cumul)");

                ResultFunctions.GenerateRepartition(PaxDistributionArrival_, 1, "TotalTimeDistribution (%)", "TotalTimeDistribution (Cumul)");
                ResultFunctions.GenerateRepartition(PaxDistributionArrival_, 2, "TotalWalkingTimeDistribution (%)", "TotalWalkingTimeDistribution (Cumul)");
                ResultFunctions.GenerateRepartition(PaxDistributionArrival_, 3, "TotalWaitingTimeDistribution (%)", "TotalWaitingTimeDistribution (Cumul)");
                ResultFunctions.GenerateRepartition(PaxDistributionArrival_, 4, "TotalProcessTimeDistribution (%)", "TotalProcessTimeDistribution (Cumul)");

                ResultFunctions.GenerateRepartition(PaxDistributionDeparture_, 1, "TotalTimeDistribution (%)", "TotalTimeDistribution (Cumul)");
                ResultFunctions.GenerateRepartition(PaxDistributionDeparture_, 2, "TotalWalkingTimeDistribution (%)", "TotalWalkingTimeDistribution (Cumul)");
                ResultFunctions.GenerateRepartition(PaxDistributionDeparture_, 3, "TotalWaitingTimeDistribution (%)", "TotalWaitingTimeDistribution (Cumul)");
                ResultFunctions.GenerateRepartition(PaxDistributionDeparture_, 4, "TotalProcessTimeDistribution (%)", "TotalProcessTimeDistribution (Cumul)");
                ResultFunctions.GenerateRepartition(PaxDistributionDeparture_, 5, "TotalTimeToBoardingGate (%)", "TotalTimeToBoardingGate (Cumul)");

                // << Task #8618 Pax2Sim - Dynamic Analysis - Pax - histograns and timeline tables for Dwell Area
                ResultFunctions.GenerateRepartition(PaxDistributionOriginatingAndTransfer_, 1, "TotalTimeDistribution (%)", "TotalTimeDistribution (Cumul)");
                ResultFunctions.GenerateRepartition(PaxDistributionOriginatingAndTransfer_, 2, "TotalWalkingTimeDistribution (%)", "TotalWalkingTimeDistribution (Cumul)");
                ResultFunctions.GenerateRepartition(PaxDistributionOriginatingAndTransfer_, 3, "TotalWaitingTimeDistribution (%)", "TotalWaitingTimeDistribution (Cumul)");
                ResultFunctions.GenerateRepartition(PaxDistributionOriginatingAndTransfer_, 4, "TotalProcessTimeDistribution (%)", "TotalProcessTimeDistribution (Cumul)");
                ResultFunctions.GenerateRepartition(PaxDistributionOriginatingAndTransfer_, 5, "TotalTimeToBoardingGate (%)", "TotalTimeToBoardingGate (Cumul)");

                #region timeline tables
                PaxDistributionTimelineTotal_ = createTimelineTableForPaxDistribution(GlobalNames.GLOBAL_PAX_DISTRIBUTION_TIMELINE_TABLE_NAME,
                    GlobalNames.GLOBAL_PAX_TYPE, dtBeginTime_, dtEndTime_, dPasPaxDistribution, totalPaxList);
                PaxDistributionTimelineLost_ = createTimelineTableForPaxDistribution(GlobalNames.LOST_PAX_DISTRIBUTION_TIMELINE_TABLE_NAME,
                    GlobalNames.LOST_PAX_TYPE, dtBeginTime_, dtEndTime_, dPasPaxDistribution, lostPaxList);
                PaxDistributionTimelineMissed_ = createTimelineTableForPaxDistribution(GlobalNames.MISSED_PAX_DISTRIBUTION_TIMELINE_TABLE_NAME,
                    GlobalNames.MISSED_PAX_TYPE, dtBeginTime_, dtEndTime_, dPasPaxDistribution, missedPaxList);
                PaxDistributionTimelineStopped_ = createTimelineTableForPaxDistribution(GlobalNames.STOPPED_PAX_DISTRIBUTION_TIMELINE_TABLE_NAME,
                    GlobalNames.STOPPED_PAX_TYPE, dtBeginTime_, dtEndTime_, dPasPaxDistribution, stoppedPaxList);
                PaxDistributionTimelineTerminating_ = createTimelineTableForPaxDistribution(GlobalNames.TERMINATING_PAX_DISTRIBUTION_TIMELINE_TABLE_NAME,
                    GlobalNames.TERMINATING_PAX_TYPE, dtBeginTime_, dtEndTime_, dPasPaxDistribution, arrivalPaxList);
                PaxDistributionTimelineTransfer_ = createTimelineTableForPaxDistribution(GlobalNames.TRANSFER_PAX_DISTRIBUTION_TIMELINE_TABLE_NAME,
                    GlobalNames.TRANSFER_PAX_TYPE, dtBeginTime_, dtEndTime_, dPasPaxDistribution, transferPaxList);
                PaxDistributionTimelineOriginating_ = createTimelineTableForPaxDistribution(GlobalNames.ORIGINATING_PAX_DISTRIBUTION_TIMELINE_TABLE_NAME,
                    GlobalNames.ORIGINATING_PAX_TYPE, dtBeginTime_, dtEndTime_, dPasPaxDistribution, originatingPaxList);
                PaxDistributionTimelineOriginatingAndTransfer_ = createTimelineTableForPaxDistribution(GlobalNames.DEPARTURE_PAX_DISTRIBUTION_TIMELINE_TABLE_NAME,
                    GlobalNames.DEPARTURE_PAX_TYPE, dtBeginTime_, dtEndTime_, dPasPaxDistribution, departurePaxList);
                #endregion

                #region summary tables
                paxDistributionGlobalSummary_ = createSummaryTableForPaxDistribution(GlobalNames.PAX_DISTRIBUTION_TABLE_PREFIX + "Global"
                    + GlobalNames.PAX_SUMMARY_DISTRIBUTION_TABLE_SUFFIX, GlobalNames.GLOBAL_PAX_TYPE, dtBeginTime_, dtEndTime_, dPasPaxDistribution, totalPaxList);
                paxDistributionMissedSummary_ = createSummaryTableForPaxDistribution(GlobalNames.PAX_DISTRIBUTION_TABLE_PREFIX + "Missed"
                    + GlobalNames.PAX_SUMMARY_DISTRIBUTION_TABLE_SUFFIX, GlobalNames.MISSED_PAX_TYPE, dtBeginTime_, dtEndTime_, dPasPaxDistribution, missedPaxList);
                paxDistributionStoppedSummary_ = createSummaryTableForPaxDistribution(GlobalNames.PAX_DISTRIBUTION_TABLE_PREFIX + "Stopped"
                    + GlobalNames.PAX_SUMMARY_DISTRIBUTION_TABLE_SUFFIX, GlobalNames.STOPPED_PAX_TYPE, dtBeginTime_, dtEndTime_, dPasPaxDistribution, stoppedPaxList);
                paxDistributionLostSummary_ = createSummaryTableForPaxDistribution(GlobalNames.PAX_DISTRIBUTION_TABLE_PREFIX + "Lost"
                    + GlobalNames.PAX_SUMMARY_DISTRIBUTION_TABLE_SUFFIX, GlobalNames.LOST_PAX_TYPE, dtBeginTime_, dtEndTime_, dPasPaxDistribution, lostPaxList);

                paxDistributionOriginatingSummary_ = createSummaryTableForPaxDistribution(GlobalNames.PAX_DISTRIBUTION_TABLE_PREFIX + "Originating"
                    + GlobalNames.PAX_SUMMARY_DISTRIBUTION_TABLE_SUFFIX, GlobalNames.ORIGINATING_PAX_TYPE, dtBeginTime_, dtEndTime_, dPasPaxDistribution, originatingPaxList);
                paxDistributionTerminatingSummary_ = createSummaryTableForPaxDistribution(GlobalNames.PAX_DISTRIBUTION_TABLE_PREFIX + "Terminating"
                    + GlobalNames.PAX_SUMMARY_DISTRIBUTION_TABLE_SUFFIX, GlobalNames.TERMINATING_PAX_TYPE, dtBeginTime_, dtEndTime_, dPasPaxDistribution, arrivalPaxList);
                paxDistributionOriginatingAndTransferSummary_ = createSummaryTableForPaxDistribution(GlobalNames.PAX_DISTRIBUTION_TABLE_PREFIX + "Departure"
                    + GlobalNames.PAX_SUMMARY_DISTRIBUTION_TABLE_SUFFIX, GlobalNames.DEPARTURE_PAX_TYPE, dtBeginTime_, dtEndTime_, dPasPaxDistribution, departurePaxList);
                paxDistributionTransferSummary_ = createSummaryTableForPaxDistribution(GlobalNames.PAX_DISTRIBUTION_TABLE_PREFIX + "Transfer"
                    + GlobalNames.PAX_SUMMARY_DISTRIBUTION_TABLE_SUFFIX, GlobalNames.TRANSFER_PAX_TYPE, dtBeginTime_, dtEndTime_, dPasPaxDistribution, transferPaxList);
                #endregion
                // >> Task #8618 Pax2Sim - Dynamic Analysis - Pax - histograns and timeline tables for Dwell Area
                PaxGeneralIST_.AcceptChanges();
            }

            private DataTable createSummaryTableForPaxDistribution(String tableName, String paxType, DateTime dtBegin, DateTime dtEnd,
                double scenarioStep, List<PaxInfo> paxInfoList)
            {
                DataTable summaryTable = new DataTable(tableName);

                #region summary table structure
                int kpiIdColumnIndex = summaryTable.Columns.Count;
                summaryTable.Columns.Add(GlobalNames.SUMMARY_TABLE_KPI_ID_COLUMN_NAME, typeof(Int32));

                int dataColumnIndex = summaryTable.Columns.Count;
                summaryTable.Columns.Add(GlobalNames.SUMMARY_TABLE_DATA_COLUMN_NAME, typeof(String));

                int valueColumnIndex = summaryTable.Columns.Count;
                summaryTable.Columns.Add(GlobalNames.SUMMARY_TABLE_VALUE_COLUMN_NAME, typeof(Double));

                int minValueColumnIndex = summaryTable.Columns.Count;
                summaryTable.Columns.Add(GlobalNames.SUMMARY_TABLE_MIN_VALUE_COLUMN_NAME, typeof(Double));

                int avgValueColumnIndex = summaryTable.Columns.Count;
                summaryTable.Columns.Add(GlobalNames.SUMMARY_TABLE_AVG_VALUE_COLUMN_NAME, typeof(Double));

                int maxValueColumnIndex = summaryTable.Columns.Count;
                summaryTable.Columns.Add(GlobalNames.SUMMARY_TABLE_MAX_VALUE_COLUMN_NAME, typeof(Double));

                int maxLevel1ValueColumnIndex = summaryTable.Columns.Count;
                summaryTable.Columns.Add(percentilesLevels_[0] + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(Double));

                int maxLevel2ValueColumnIndex = summaryTable.Columns.Count;
                summaryTable.Columns.Add(percentilesLevels_[1] + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(Double));

                int maxLevel3ValueColumnIndex = summaryTable.Columns.Count;
                summaryTable.Columns.Add(percentilesLevels_[2] + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(Double));

                int unitColumnIndex = summaryTable.Columns.Count;
                summaryTable.Columns.Add(GlobalNames.SUMMARY_TABLE_UNIT_COLUMN_NAME, typeof(String));
                #endregion

                #region statistic variables intialization
                double totalTimeSum = 0;
                double totalWalkingTimeSum = 0;
                double totalWaitingTimeSum = 0;
                double totalProcessTimeSum = 0;
                double totalTimeToBGSum = 0;

                double minTotalTime = double.MaxValue;
                double minTotalWalkingTime = double.MaxValue;
                double minTotalWaitingTime = double.MaxValue;
                double minTotalProcessTime = double.MaxValue;
                double minTotalTimeToBG = double.MaxValue;
                double maxTotalTime = double.MinValue;
                double maxTotalWalkingTime = double.MinValue;
                double maxTotalWaitingTime = double.MinValue;
                double maxTotalProcessTime = double.MinValue;
                double maxTotalTimeToBG = double.MinValue;
                double avgTotalTime = 0;
                double avgTotalWalkingTime = 0;
                double avgTotalWaitingTime = 0;
                double avgTotalProcessTime = 0;
                double avgTotalTimeToBG = 0;
                int nbPax = 0;

                double level1TotalTime = 0;
                double level2TotalTime = 0;
                double level3TotalTime = 0;

                double level1TotalWalkingTime = 0;
                double level2TotalWalkingTime = 0;
                double level3TotalWalkingTime = 0;

                double level1TotalWaitingTime = 0;
                double level2TotalWaitingTime = 0;
                double level3TotalWaitingTime = 0;

                double level1TotalProcessTime = 0;
                double level2TotalProcessTime = 0;
                double level3TotalProcessTime = 0;

                double level1TimeToBG = 0;
                double level2TimeToBG = 0;
                double level3TimeToBG = 0;
                #endregion

                getTimelineInfoForTimeIntervalByPaxInfoList(dtBegin, dtEnd, paxInfoList,
                            out totalTimeSum, out minTotalTime, out avgTotalTime, out maxTotalTime, out level1TotalTime, out level2TotalTime, out level3TotalTime,
                            out totalWalkingTimeSum, out minTotalWalkingTime, out avgTotalWalkingTime, out maxTotalWalkingTime, out level1TotalWalkingTime, out level2TotalWalkingTime, out level3TotalWalkingTime,
                            out totalWaitingTimeSum, out minTotalWaitingTime, out avgTotalWaitingTime, out maxTotalWaitingTime, out level2TotalWaitingTime, out level2TotalWaitingTime, out level3TotalWaitingTime,
                            out totalProcessTimeSum, out minTotalProcessTime, out avgTotalProcessTime, out maxTotalProcessTime, out level1TotalProcessTime, out level2TotalProcessTime, out level3TotalProcessTime,
                            out totalTimeToBGSum, out minTotalTimeToBG, out avgTotalTimeToBG, out maxTotalTimeToBG, out level1TimeToBG, out level2TimeToBG, out level3TimeToBG,
                            out nbPax, false, percentilesLevels_);

                int kpiId = 0;
                DeskReport.addNewRowToSummaryTable(summaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            maxLevel1ValueColumnIndex, maxLevel2ValueColumnIndex, maxLevel3ValueColumnIndex,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_TOTAL_TIME, totalTimeSum,
                                            minTotalTime, avgTotalTime, maxTotalTime,
                                            level1TotalTime, level2TotalTime, level3TotalTime,
                                            GlobalNames.SUMMARY_TIME_MINUTES_UNIT_NAME);

                DeskReport.addNewRowToSummaryTable(summaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            maxLevel1ValueColumnIndex, maxLevel2ValueColumnIndex, maxLevel3ValueColumnIndex,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_TOTAL_WALKING_TIME, totalWalkingTimeSum,
                                            minTotalWalkingTime, avgTotalWalkingTime, maxTotalWalkingTime,
                                            level1TotalWalkingTime, level2TotalWalkingTime, level3TotalWalkingTime,
                                            GlobalNames.SUMMARY_TIME_MINUTES_UNIT_NAME);

                DeskReport.addNewRowToSummaryTable(summaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            maxLevel1ValueColumnIndex, maxLevel2ValueColumnIndex, maxLevel3ValueColumnIndex,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_TOTAL_WAITING_TIME, totalWaitingTimeSum,
                                            minTotalWaitingTime, avgTotalWaitingTime, maxTotalWaitingTime,
                                            level1TotalWaitingTime, level2TotalWaitingTime, level3TotalWaitingTime,
                                            GlobalNames.SUMMARY_TIME_MINUTES_UNIT_NAME);

                DeskReport.addNewRowToSummaryTable(summaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            maxLevel1ValueColumnIndex, maxLevel2ValueColumnIndex, maxLevel3ValueColumnIndex,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_TOTAL_PROCESS_TIME_PAX, totalProcessTimeSum,
                                            minTotalProcessTime, avgTotalProcessTime, maxTotalProcessTime,
                                            level1TotalProcessTime, level2TotalProcessTime, level3TotalProcessTime,
                                            GlobalNames.SUMMARY_TIME_MINUTES_UNIT_NAME);

                DeskReport.addNewRowToSummaryTable(summaryTable,
                                            kpiIdColumnIndex, dataColumnIndex, valueColumnIndex,
                                            minValueColumnIndex, avgValueColumnIndex, maxValueColumnIndex,
                                            maxLevel1ValueColumnIndex, maxLevel2ValueColumnIndex, maxLevel3ValueColumnIndex,
                                            unitColumnIndex,
                                            ++kpiId, GlobalNames.SUMMARY_KPI_NAME_TOTAL_TIME_TO_BG, totalTimeToBGSum,
                                            minTotalTimeToBG, avgTotalTimeToBG, maxTotalTimeToBG,
                                            level1TimeToBG, level2TimeToBG, level3TimeToBG,
                                            GlobalNames.SUMMARY_TIME_MINUTES_UNIT_NAME);

                return summaryTable;
            }

            // << Task #8618 Pax2Sim - Dynamic Analysis - Pax - histograns and timeline tables for Dwell Area
            private DataTable createTimelineTableForPaxDistribution(String tableName, String paxType, DateTime dtBegin, DateTime dtEnd,
                double scenarioStep, List<PaxInfo> paxInfoList)
            {
                #region timeline table columns and indexes
                DataTable timelineTable = new DataTable(tableName);

                int indexColumnTime = timelineTable.Columns.Count;
                timelineTable.Columns.Add("Time", typeof(DateTime));

                int indexColumnMinTotalTime = timelineTable.Columns.Count;
                timelineTable.Columns.Add("Min Total Time", typeof(Double));

                int indexColumnAvgTotalTime = timelineTable.Columns.Count;
                timelineTable.Columns.Add("Average Total Time", typeof(Double));

                int indexColumnMaxTotalTime = timelineTable.Columns.Count;
                timelineTable.Columns.Add("Max Total Time", typeof(Double));

                int indexColumnNbPax = timelineTable.Columns.Count;
                timelineTable.Columns.Add("Nb Pax", typeof(Int32));

                int indexColumnLevel1TotalTime = -1;
                int indexColumnLevel2TotalTime = -1;
                int indexColumnLevel3TotalTime = -1;
                if (percentilesLevels_ != null)    // >> Bug #14922 Pax2Sim - BHS trace - Time chute to Exit Segregation per line problem
                {
                    indexColumnLevel1TotalTime = timelineTable.Columns.Count;
                    timelineTable.Columns.Add("Total Time " + percentilesLevels_[0] + "%", typeof(Double));
                    indexColumnLevel2TotalTime = timelineTable.Columns.Count;
                    timelineTable.Columns.Add("Total Time " + percentilesLevels_[1] + "%", typeof(Double));
                    indexColumnLevel3TotalTime = timelineTable.Columns.Count;
                    timelineTable.Columns.Add("Total Time " + percentilesLevels_[2] + "%", typeof(Double));
                }

                int indexColumnMinWalkingTime = timelineTable.Columns.Count;
                timelineTable.Columns.Add("Min Walking Time", typeof(Double));

                int indexColumnAvgWalkingTime = timelineTable.Columns.Count;
                timelineTable.Columns.Add("Average Walking Time", typeof(Double));

                int indexColumnMaxWalkingTime = timelineTable.Columns.Count;
                timelineTable.Columns.Add("Max Walking Time", typeof(Double));

                int indexColumnLevel1TotalWalkingTime = -1;
                int indexColumnLevel2TotalWalkingTime = -1;
                int indexColumnLevel3TotalWalkingTime = -1;
                if (percentilesLevels_ != null)    // >> Bug #14922 Pax2Sim - BHS trace - Time chute to Exit Segregation per line problem
                {
                    indexColumnLevel1TotalWalkingTime = timelineTable.Columns.Count;
                    timelineTable.Columns.Add("Total Walking Time " + percentilesLevels_[0] + "%", typeof(Double));
                    indexColumnLevel2TotalWalkingTime = timelineTable.Columns.Count;
                    timelineTable.Columns.Add("Total Walking Time " + percentilesLevels_[1] + "%", typeof(Double));
                    indexColumnLevel3TotalWalkingTime = timelineTable.Columns.Count;
                    timelineTable.Columns.Add("Total Walking Time " + percentilesLevels_[2] + "%", typeof(Double));
                }

                int indexColumnMinWaitingTime = timelineTable.Columns.Count;
                timelineTable.Columns.Add("Min Waiting Time", typeof(Double));

                int indexColumnAvgWaitingTime = timelineTable.Columns.Count;
                timelineTable.Columns.Add("Average Waiting Time", typeof(Double));

                int indexColumnMaxWaitingTime = timelineTable.Columns.Count;
                timelineTable.Columns.Add("Max Waiting Time", typeof(Double));

                int indexColumnLevel1TotalWaitingTime = -1;
                int indexColumnLevel2TotalWaitingTime = -1;
                int indexColumnLevel3TotalWaitingTime = -1;
                if (percentilesLevels_ != null)    // >> Bug #14922 Pax2Sim - BHS trace - Time chute to Exit Segregation per line problem
                {
                    indexColumnLevel1TotalWaitingTime = timelineTable.Columns.Count;
                    timelineTable.Columns.Add("Total Waiting Time " + percentilesLevels_[0] + "%", typeof(Double));
                    indexColumnLevel2TotalWaitingTime = timelineTable.Columns.Count;
                    timelineTable.Columns.Add("Total Waiting Time " + percentilesLevels_[1] + "%", typeof(Double));
                    indexColumnLevel3TotalWaitingTime = timelineTable.Columns.Count;
                    timelineTable.Columns.Add("Total Waiting Time " + percentilesLevels_[2] + "%", typeof(Double));
                }

                int indexColumnMinProcessTime = timelineTable.Columns.Count;
                timelineTable.Columns.Add("Min Process Time", typeof(Double));

                int indexColumnAvgProcessTime = timelineTable.Columns.Count;
                timelineTable.Columns.Add("Average Process Time", typeof(Double));

                int indexColumnMaxProcessTime = timelineTable.Columns.Count;
                timelineTable.Columns.Add("Max Process Time", typeof(Double));

                int indexColumnLevel1TotalProcessTime = -1;
                int indexColumnLevel2TotalProcessTime = -1;
                int indexColumnLevel3TotalProcessTime = -1;
                if (percentilesLevels_ != null)    // >> Bug #14922 Pax2Sim - BHS trace - Time chute to Exit Segregation per line problem
                {
                    indexColumnLevel1TotalProcessTime = timelineTable.Columns.Count;
                    timelineTable.Columns.Add("Total Process Time " + percentilesLevels_[0] + "%", typeof(Double));
                    indexColumnLevel2TotalProcessTime = timelineTable.Columns.Count;
                    timelineTable.Columns.Add("Total Process Time " + percentilesLevels_[1] + "%", typeof(Double));
                    indexColumnLevel3TotalProcessTime = timelineTable.Columns.Count;
                    timelineTable.Columns.Add("Total Process Time " + percentilesLevels_[2] + "%", typeof(Double));
                }

                int indexColumnMinTimeToBoardingGate = -1;
                int indexColumnAvgTimeToBoardingGate = -1;
                int indexColumnMaxTimeToBoardingGate = -1;
                int indexColumnLevel1TimeToBoardingGate = -1;
                int indexColumnLevel2TimeToBoardingGate = -1;
                int indexColumnLevel3TimeToBoardingGate = -1;
                if (paxType != GlobalNames.TERMINATING_PAX_TYPE)
                {
                    indexColumnMinTimeToBoardingGate = timelineTable.Columns.Count;
                    timelineTable.Columns.Add("Min Time To Boarding Gate", typeof(Double));
                    indexColumnAvgTimeToBoardingGate = timelineTable.Columns.Count;
                    timelineTable.Columns.Add("Average Time To Boarding Gate", typeof(Double));
                    indexColumnMaxTimeToBoardingGate = timelineTable.Columns.Count;
                    timelineTable.Columns.Add("Max Time To Boarding Gate", typeof(Double));

                    if (percentilesLevels_ != null)    // >> Bug #14922 Pax2Sim - BHS trace - Time chute to Exit Segregation per line problem
                    {
                        indexColumnLevel1TimeToBoardingGate = timelineTable.Columns.Count;
                        timelineTable.Columns.Add("Time To Boarding Gate " + percentilesLevels_[0] + "%", typeof(Double));
                        indexColumnLevel2TimeToBoardingGate = timelineTable.Columns.Count;
                        timelineTable.Columns.Add("Time To Boarding Gate " + percentilesLevels_[1] + "%", typeof(Double));
                        indexColumnLevel3TimeToBoardingGate = timelineTable.Columns.Count;
                        timelineTable.Columns.Add("Time To Boarding Gate " + percentilesLevels_[2] + "%", typeof(Double));
                    }
                }
                #endregion

                #region column indexes check
                if (indexColumnMinTotalTime == -1 || indexColumnMinWalkingTime == -1 || indexColumnMinWaitingTime == -1 || indexColumnMinProcessTime == -1
                    || indexColumnMaxTotalTime == -1 || indexColumnMaxWalkingTime == -1 || indexColumnMaxWaitingTime == -1 || indexColumnMaxProcessTime == -1
                    || indexColumnAvgTotalTime == -1 || indexColumnAvgWalkingTime == -1 || indexColumnAvgWaitingTime == -1 || indexColumnAvgProcessTime == -1
                    || indexColumnNbPax == -1 || indexColumnTime == -1)
                    return timelineTable;

                if (paxType != GlobalNames.TERMINATING_PAX_TYPE
                    && (indexColumnMinTimeToBoardingGate == -1 || indexColumnMaxTimeToBoardingGate == -1 || indexColumnAvgTimeToBoardingGate == -1))
                    return timelineTable;
                #endregion

                #region timeline table initialization
                OverallTools.DataFunctions.initialiserLignes(timelineTable, dtBegin, dtEnd, scenarioStep);
                foreach (DataRow row in timelineTable.Rows)
                {
                    row[indexColumnNbPax] = 0;
                    row[indexColumnMinTotalTime] = 0.0d;
                    row[indexColumnAvgTotalTime] = 0.0d;
                    row[indexColumnMaxTotalTime] = 0.0d;
                    row[indexColumnMinWalkingTime] = 0.0d;
                    row[indexColumnAvgWalkingTime] = 0.0d;
                    row[indexColumnMaxWalkingTime] = 0.0d;
                    row[indexColumnMinWaitingTime] = 0.0d;
                    row[indexColumnAvgWaitingTime] = 0.0d;
                    row[indexColumnMaxWaitingTime] = 0.0d;
                    row[indexColumnMinProcessTime] = 0.0d;
                    row[indexColumnAvgProcessTime] = 0.0d;
                    row[indexColumnMaxProcessTime] = 0.0d;
                    if (paxType != GlobalNames.TERMINATING_PAX_TYPE && indexColumnMinTimeToBoardingGate != -1
                        && indexColumnAvgTimeToBoardingGate != -1 && indexColumnMaxTimeToBoardingGate != -1)
                    {
                        row[indexColumnMinTimeToBoardingGate] = 0.0d;
                        row[indexColumnAvgTimeToBoardingGate] = 0.0d;
                        row[indexColumnMaxTimeToBoardingGate] = 0.0d;
                    }
                }
                #endregion

                int rowIndex = 0;
                bool lastRow = false;

                foreach (DataRow row in timelineTable.Rows)
                {
                    DateTime referenceBeginTime = (DateTime)row[indexColumnTime];
                    DateTime referenceEndTime = DateTime.MinValue;
                    if (rowIndex + 1 < timelineTable.Rows.Count)
                        referenceEndTime = (DateTime)timelineTable.Rows[rowIndex + 1][indexColumnTime];
                    else
                    {
                        DateTime finalTime = (DateTime)row[indexColumnTime];
                        referenceEndTime = finalTime.AddMinutes(scenarioStep);
                        lastRow = true;
                    }

                    rowIndex = rowIndex + 1;
                    if (referenceBeginTime != null && referenceEndTime != DateTime.MinValue)
                    {
                        #region statistic variables intialization
                        double totalTimeSum = 0;
                        double totalWalkingTimeSum = 0;
                        double totalWaitingTimeSum = 0;
                        double totalProcessTimeSum = 0;
                        double totalTimeToBGSum = 0;

                        double minTotalTime = double.MaxValue;
                        double minTotalWalkingTime = double.MaxValue;
                        double minTotalWaitingTime = double.MaxValue;
                        double minTotalProcessTime = double.MaxValue;
                        double minTotalTimeToBG = double.MaxValue;
                        double maxTotalTime = double.MinValue;
                        double maxTotalWalkingTime = double.MinValue;
                        double maxTotalWaitingTime = double.MinValue;
                        double maxTotalProcessTime = double.MinValue;
                        double maxTotalTimeToBG = double.MinValue;
                        double avgTotalTime = 0;
                        double avgTotalWalkingTime = 0;
                        double avgTotalWaitingTime = 0;
                        double avgTotalProcessTime = 0;
                        double avgTotalTimeToBG = 0;
                        int nbPax = 0;

                        double level1TotalTime = 0;
                        double level2TotalTime = 0;
                        double level3TotalTime = 0;

                        double level1TotalWalkingTime = 0;
                        double level2TotalWalkingTime = 0;
                        double level3TotalWalkingTime = 0;

                        double level1TotalWaitingTime = 0;
                        double level2TotalWaitingTime = 0;
                        double level3TotalWaitingTime = 0;

                        double level1TotalProcessTime = 0;
                        double level2TotalProcessTime = 0;
                        double level3TotalProcessTime = 0;

                        double level1TimeToBG = 0;
                        double level2TimeToBG = 0;
                        double level3TimeToBG = 0;
                        #endregion

                        getTimelineInfoForTimeIntervalByPaxInfoList(referenceBeginTime, referenceEndTime, paxInfoList,
                            out totalTimeSum, out minTotalTime, out avgTotalTime, out maxTotalTime, out level1TotalTime, out level2TotalTime, out level3TotalTime,
                            out totalWalkingTimeSum, out minTotalWalkingTime, out avgTotalWalkingTime, out maxTotalWalkingTime, out level1TotalWalkingTime, out level2TotalWalkingTime, out level3TotalWalkingTime,
                            out totalWaitingTimeSum, out minTotalWaitingTime, out avgTotalWaitingTime, out maxTotalWaitingTime, out level2TotalWaitingTime, out level2TotalWaitingTime, out level3TotalWaitingTime,
                            out totalProcessTimeSum, out minTotalProcessTime, out avgTotalProcessTime, out maxTotalProcessTime, out level1TotalProcessTime, out level2TotalProcessTime, out level3TotalProcessTime,
                            out totalTimeToBGSum, out minTotalTimeToBG, out avgTotalTimeToBG, out maxTotalTimeToBG, out level1TimeToBG, out level2TimeToBG, out level3TimeToBG,
                            out nbPax, lastRow, percentilesLevels_);

                        if (minTotalTime != double.MaxValue && maxTotalTime != double.MinValue && avgTotalTime >= 0)
                        {
                            row[indexColumnMinTotalTime] = minTotalTime;
                            row[indexColumnAvgTotalTime] = avgTotalTime;
                            row[indexColumnMaxTotalTime] = maxTotalTime;
                        }
                        if (indexColumnLevel1TotalTime != -1 && indexColumnLevel2TotalTime != -1 && indexColumnLevel3TotalTime != -1)
                        {
                            row[indexColumnLevel1TotalTime] = level1TotalTime;
                            row[indexColumnLevel2TotalTime] = level2TotalTime;
                            row[indexColumnLevel3TotalTime] = level3TotalTime;
                        }

                        if (minTotalWalkingTime != double.MaxValue && maxTotalWalkingTime != double.MinValue && avgTotalWalkingTime >= 0)
                        {
                            row[indexColumnMinWalkingTime] = minTotalWalkingTime;
                            row[indexColumnAvgWalkingTime] = avgTotalWalkingTime;
                            row[indexColumnMaxWalkingTime] = maxTotalWalkingTime;
                        }
                        if (indexColumnLevel1TotalWalkingTime != -1 && indexColumnLevel2TotalWalkingTime != -1 && indexColumnLevel3TotalWalkingTime != -1)
                        {
                            row[indexColumnLevel1TotalWalkingTime] = level1TotalWalkingTime;
                            row[indexColumnLevel2TotalWalkingTime] = level2TotalWalkingTime;
                            row[indexColumnLevel3TotalWalkingTime] = level3TotalWalkingTime;
                        }

                        if (minTotalWaitingTime != double.MaxValue && maxTotalWaitingTime != double.MinValue && avgTotalWaitingTime >= 0)
                        {
                            row[indexColumnMinWaitingTime] = minTotalWaitingTime;
                            row[indexColumnAvgWaitingTime] = avgTotalWaitingTime;
                            row[indexColumnMaxWaitingTime] = maxTotalWaitingTime;
                        }
                        if (indexColumnLevel1TotalWaitingTime != -1 && indexColumnLevel2TotalWaitingTime != -1 && indexColumnLevel3TotalWaitingTime != -1)
                        {
                            row[indexColumnLevel1TotalWaitingTime] = level1TotalWaitingTime;
                            row[indexColumnLevel2TotalWaitingTime] = level2TotalWaitingTime;
                            row[indexColumnLevel3TotalWaitingTime] = level3TotalWaitingTime;
                        }

                        if (minTotalProcessTime != double.MaxValue && maxTotalProcessTime != double.MinValue && avgTotalProcessTime >= 0)
                        {
                            row[indexColumnMinProcessTime] = minTotalProcessTime;
                            row[indexColumnAvgProcessTime] = avgTotalProcessTime;
                            row[indexColumnMaxProcessTime] = maxTotalProcessTime;
                        }
                        if (indexColumnLevel1TotalProcessTime != -1 && indexColumnLevel2TotalProcessTime != -1 && indexColumnLevel3TotalProcessTime != -1)
                        {
                            row[indexColumnLevel1TotalProcessTime] = level1TotalProcessTime;
                            row[indexColumnLevel2TotalProcessTime] = level2TotalProcessTime;
                            row[indexColumnLevel3TotalProcessTime] = level3TotalProcessTime;
                        }

                        if (paxType != GlobalNames.TERMINATING_PAX_TYPE && indexColumnMaxTimeToBoardingGate != -1
                            && indexColumnMinTimeToBoardingGate != -1 && indexColumnAvgTimeToBoardingGate != -1)
                        {
                            if (minTotalTimeToBG != double.MaxValue && maxTotalTimeToBG != double.MinValue && avgTotalTimeToBG >= 0)
                            {
                                row[indexColumnMinTimeToBoardingGate] = minTotalTimeToBG;
                                row[indexColumnAvgTimeToBoardingGate] = avgTotalTimeToBG;
                                row[indexColumnMaxTimeToBoardingGate] = maxTotalTimeToBG;
                            }
                            if (indexColumnLevel1TimeToBoardingGate != -1 && indexColumnLevel2TimeToBoardingGate != -1 && indexColumnLevel3TimeToBoardingGate != -1)
                            {
                                row[indexColumnLevel1TimeToBoardingGate] = level1TimeToBG;
                                row[indexColumnLevel2TimeToBoardingGate] = level2TimeToBG;
                                row[indexColumnLevel3TimeToBoardingGate] = level3TimeToBG;
                            }
                        }
                        row[indexColumnNbPax] = nbPax;
                    }
                }
                timelineTable.AcceptChanges();
                return timelineTable;
            }

            private void getTimelineInfoForTimeIntervalByPaxInfoList(DateTime referenceBeginTime, DateTime referenceEndTime, List<PaxInfo> paxInfoList,
                out double totalTimeSum, out double minTotalTime, out double avgTotalTime, out double maxTotalTime, out double level1TotalTime, out double level2TotalTime, out double level3TotalTime,
                out double totalWalkingTimeSum, out double minTotalWalkingTime, out double avgTotalWalkingTime, out double maxTotalWalkingTime, out double level1TotalWalkingTime, out double level2TotalWalkingTime, out double level3TotalWalkingTime,
                out double totalWaitingTimeSum, out double minTotalWaitingTime, out double avgTotalWaitingTime, out double maxTotalWaitingTime, out double level1TotalWaitingTime, out double level2TotalWaitingTime, out double level3TotalWaitingTime,
                out double totalProcessTimeSum, out double minTotalProcessTime, out double avgTotalProcessTime, out double maxTotalProcessTime, out double level1TotalProcessTime, out double level2TotalProcessTime, out double level3TotalProcessTime,
                out double totalTimeToBGSum, out double minTotalTimeToBG, out double avgTotalTimeToBG, out double maxTotalTimeToBG, out double level1TotalTimeToBG, out double level2TotalTimeToBG, out double level3TotalTimeToBG,
                out int nbPax, bool lastRow, double[] percentileLevels)
            {
                totalTimeSum = 0;
                totalWalkingTimeSum = 0;
                totalWaitingTimeSum = 0;
                totalProcessTimeSum = 0;
                totalTimeToBGSum = 0;
                minTotalTime = minTotalWalkingTime = minTotalWaitingTime = minTotalProcessTime = minTotalTimeToBG = double.MaxValue;
                maxTotalTime = maxTotalWalkingTime = maxTotalWaitingTime = maxTotalProcessTime = maxTotalTimeToBG = double.MinValue;
                nbPax = 0;

                List<double> totalTimeList = new List<double>();
                level1TotalTime = 0;
                level2TotalTime = 0;
                level3TotalTime = 0;
                List<double> totalWalkingTimeList = new List<double>();
                level1TotalWalkingTime = 0;
                level2TotalWalkingTime = 0;
                level3TotalWalkingTime = 0;
                List<double> totalWaitingTimeList = new List<double>();
                level1TotalWaitingTime = 0;
                level2TotalWaitingTime = 0;
                level3TotalWaitingTime = 0;
                List<double> totalProcessTimeList = new List<double>();
                level1TotalProcessTime = 0;
                level2TotalProcessTime = 0;
                level3TotalProcessTime = 0;
                List<double> totalTimeToBGList = new List<double>();
                level1TotalTimeToBG = 0;
                level2TotalTimeToBG = 0;
                level3TotalTimeToBG = 0;

                foreach (PaxInfo paxInfo in paxInfoList)
                {
                    if (paxInfo.arrivalTime >= referenceBeginTime
                        && ((!lastRow && paxInfo.arrivalTime < referenceEndTime) || (lastRow && paxInfo.arrivalTime <= referenceEndTime)))
                    {
                        if (paxInfo.totalTime < minTotalTime)
                            minTotalTime = paxInfo.totalTime;
                        if (paxInfo.totalTime > maxTotalTime)
                            maxTotalTime = paxInfo.totalTime;
                        totalTimeSum += paxInfo.totalTime;
                        totalTimeList.Add(paxInfo.totalTime);

                        if (paxInfo.totalWalkingTime < minTotalWalkingTime)
                            minTotalWalkingTime = paxInfo.totalWalkingTime;
                        if (paxInfo.totalWalkingTime > maxTotalWalkingTime)
                            maxTotalWalkingTime = paxInfo.totalWalkingTime;
                        totalWalkingTimeSum += paxInfo.totalWalkingTime;
                        totalWalkingTimeList.Add(paxInfo.totalWalkingTime);

                        if (paxInfo.totalWaitingTime < minTotalWaitingTime)
                            minTotalWaitingTime = paxInfo.totalWaitingTime;
                        if (paxInfo.totalWaitingTime > maxTotalWaitingTime)
                            maxTotalWaitingTime = paxInfo.totalWaitingTime;
                        totalWaitingTimeSum += paxInfo.totalWaitingTime;
                        totalWaitingTimeList.Add(paxInfo.totalWaitingTime);

                        if (paxInfo.totalProcessTime < minTotalProcessTime)
                            minTotalProcessTime = paxInfo.totalProcessTime;
                        if (paxInfo.totalProcessTime > maxTotalProcessTime)
                            maxTotalProcessTime = paxInfo.totalProcessTime;
                        totalProcessTimeSum += paxInfo.totalProcessTime;
                        totalProcessTimeList.Add(paxInfo.totalProcessTime);

                        if (paxInfo.isDeparture)
                        {
                            if (paxInfo.totalTimeToBoardingGate < minTotalTimeToBG)
                                minTotalTimeToBG = paxInfo.totalTimeToBoardingGate;
                            if (paxInfo.totalTimeToBoardingGate > maxTotalTimeToBG)
                                maxTotalTimeToBG = paxInfo.totalTimeToBoardingGate;
                            totalTimeToBGSum += paxInfo.totalTimeToBoardingGate;
                            totalTimeToBGList.Add(paxInfo.totalTimeToBoardingGate);
                        }

                        nbPax = nbPax + 1;
                    }
                }
                if (totalTimeList.Count > 0)
                {
                    minTotalTime = Math.Round(minTotalTime, 2);
                    avgTotalTime = Math.Round((double)totalTimeSum / (double)totalTimeList.Count, 2);
                    maxTotalTime = Math.Round(maxTotalTime, 2);
                }
                else
                {
                    minTotalTime = 0;
                    avgTotalTime = 0;
                    maxTotalTime = 0;
                }

                if (totalWalkingTimeList.Count > 0)
                {
                    minTotalWalkingTime = Math.Round(minTotalWalkingTime, 2);
                    avgTotalWalkingTime = Math.Round((double)totalWalkingTimeSum / (double)totalWalkingTimeList.Count, 2);
                    maxTotalWalkingTime = Math.Round(maxTotalWalkingTime, 2);
                }
                else
                {
                    minTotalWalkingTime = 0;
                    avgTotalWalkingTime = 0;
                    maxTotalWalkingTime = 0;
                }

                if (totalWaitingTimeList.Count > 0)
                {
                    minTotalWaitingTime = Math.Round(minTotalWaitingTime, 2);
                    avgTotalWaitingTime = Math.Round((double)totalWaitingTimeSum / (double)totalWaitingTimeList.Count, 2);
                    maxTotalWaitingTime = Math.Round(maxTotalWaitingTime, 2);
                }
                else
                {
                    minTotalWaitingTime = 0;
                    avgTotalWaitingTime = 0;
                    maxTotalWaitingTime = 0;
                }

                if (totalProcessTimeList.Count > 0)
                {
                    minTotalProcessTime = Math.Round(minTotalProcessTime, 2);
                    avgTotalProcessTime = Math.Round((double)totalProcessTimeSum / (double)totalProcessTimeList.Count, 2);
                    maxTotalProcessTime = Math.Round(maxTotalProcessTime, 2);
                }
                else
                {
                    minTotalProcessTime = 0;
                    avgTotalProcessTime = 0;
                    maxTotalProcessTime = 0;
                }

                if (totalTimeToBGList.Count > 0)
                {
                    minTotalTimeToBG = Math.Round(minTotalTimeToBG, 2);
                    avgTotalTimeToBG = Math.Round((double)totalTimeToBGSum / (double)totalTimeToBGList.Count, 2);
                    maxTotalTimeToBG = Math.Round(maxTotalTimeToBG, 2);
                }
                else
                {
                    minTotalTimeToBG = 0;
                    avgTotalTimeToBG = 0;
                    maxTotalTimeToBG = 0;
                }

                if (percentileLevels != null)
                {
                    if (totalTimeList.Count > 0)
                    {
                        totalTimeList.Sort();
                        level1TotalTime = Math.Round(ResultFunctions.getLevelValue(totalTimeList, percentilesLevels_[0]), 2);
                        level2TotalTime = Math.Round(ResultFunctions.getLevelValue(totalTimeList, percentilesLevels_[1]), 2);
                        level3TotalTime = Math.Round(ResultFunctions.getLevelValue(totalTimeList, percentilesLevels_[2]), 2);
                    }
                    if (totalWalkingTimeList.Count > 0)
                    {
                        totalWalkingTimeList.Sort();
                        level1TotalWalkingTime = Math.Round(ResultFunctions.getLevelValue(totalWalkingTimeList, percentilesLevels_[0]), 2);
                        level2TotalWalkingTime = Math.Round(ResultFunctions.getLevelValue(totalWalkingTimeList, percentilesLevels_[1]), 2);
                        level3TotalWalkingTime = Math.Round(ResultFunctions.getLevelValue(totalWalkingTimeList, percentilesLevels_[2]), 2);
                    }
                    if (totalWaitingTimeList.Count > 0)
                    {
                        totalWaitingTimeList.Sort();
                        level1TotalWaitingTime = Math.Round(ResultFunctions.getLevelValue(totalWaitingTimeList, percentilesLevels_[0]), 2);
                        level2TotalWaitingTime = Math.Round(ResultFunctions.getLevelValue(totalWaitingTimeList, percentilesLevels_[1]), 2);
                        level3TotalWaitingTime = Math.Round(ResultFunctions.getLevelValue(totalWaitingTimeList, percentilesLevels_[2]), 2);
                    }
                    if (totalProcessTimeList.Count > 0)
                    {
                        totalProcessTimeList.Sort();
                        level1TotalProcessTime = Math.Round(ResultFunctions.getLevelValue(totalProcessTimeList, percentilesLevels_[0]), 2);
                        level2TotalProcessTime = Math.Round(ResultFunctions.getLevelValue(totalProcessTimeList, percentilesLevels_[1]), 2);
                        level3TotalProcessTime = Math.Round(ResultFunctions.getLevelValue(totalProcessTimeList, percentilesLevels_[2]), 2);
                    }
                    if (totalTimeToBGList.Count > 0)
                    {
                        totalTimeToBGList.Sort();
                        level1TotalTimeToBG = Math.Round(ResultFunctions.getLevelValue(totalTimeToBGList, percentilesLevels_[0]), 2);
                        level2TotalTimeToBG = Math.Round(ResultFunctions.getLevelValue(totalTimeToBGList, percentilesLevels_[1]), 2);
                        level3TotalTimeToBG = Math.Round(ResultFunctions.getLevelValue(totalTimeToBGList, percentilesLevels_[2]), 2);
                    }
                }
                totalTimeSum = Math.Round(totalTimeSum, 2);
                totalWaitingTimeSum = Math.Round(totalWaitingTimeSum, 2);
                totalWalkingTimeSum = Math.Round(totalWalkingTimeSum, 2);
                totalProcessTimeSum = Math.Round(totalProcessTimeSum, 2);
                totalTimeToBGSum = Math.Round(totalTimeToBGSum, 2);
            }
            // >> Task #8618 Pax2Sim - Dynamic Analysis - Pax - histograns and timeline tables for Dwell Area

            private void extractDeskInformations()
            {
                DeskInformations2_ = new Hashtable();
                foreach (DeskGroupResultsStruct Desktmp in DeskResults.Values)
                {
                    //On ignore les groupes car le "DeskGroupResultsStruct"  des groupes est 
                    //utilisée uniquement pour calculé l'occupation des groupes, les stats sont
                    //elles calculées d'une manière différente.
                    /*if (Desktmp.DeskName.Contains("Group"))
                        continue;*/
                    DeskInformations2_.Add(Desktmp.DeskName, Desktmp.getDeskInformations(tfFilter));
                }
            }

            #endregion

            #region Fonction pour récupérer les statistiques d'un bureau en particulier.
            public DataTable getDeskStatistics(String sDeskName)
            {
                if (!DeskResults.ContainsKey(sDeskName))
                {
                    return null;
                }
                DeskGroupResultsStruct DeskTmp = (DeskGroupResultsStruct)DeskResults[sDeskName];

                return DeskTmp.getOccupation(dtBeginTime_, dtEndTime_, dPasOccupation, bSlidingHour_,
                                                analysisRange);   // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation                
            }
            #endregion

            #region Fonction pour récupérer les statistiques d'un Terminal en particulier
            public DataTable getTerminalStatistics(Int32 iIndexTerminal)
            {
                DataTable ResultTable = getStatisticsFromPax2("T" + iIndexTerminal);
                return ResultTable;
            }
            #endregion

            #region Fonction pour récupérer les statistiques d'un Level en particulier
            public DataTable getLevelStatistics(Int32 iIndexTerminal, Int32 iLevel)
            {
                DataTable ResultTable = getStatisticsFromPax2("T" + iIndexTerminal.ToString() + "L" + iLevel.ToString());
                return ResultTable;
            }
            #endregion

            #region Fonction pour analyser les statistiques d'un type particulier.

            internal DataTable getStatisticsFromPax2(String sSearched)
            {
                ArrayList alQueueOccupation = new ArrayList();
                foreach (PaxResultsStruct PaxTmp in PaxResults.Values)
                {
                    if (!PaxTmp.CheckPaxIsValidForFilter(tfFilter))
                        continue;
                    List<PointF> lpTmp = PaxTmp.getPaxOccupation(sSearched);
                    alQueueOccupation.AddRange(lpTmp.ToArray());
                }
                // >> 1 CalcQueueOccupation_V0 issue

                return ResultFunctions.CalcQueueOccupation(sSearched + "_Occupation", alQueueOccupation,//CalcQueueOccupation(sSearched + "_Occupation", alQueueOccupation,
                    dtBeginTime_, dtEndTime_, dPasOccupation, "Nb Pax", bSlidingHour_, true,
                    analysisRange); // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation

            }

            public static void setStatistics(DataTable laTable, Int32 iIndexTime, Double[] PaxOccupation, Int32 iIndexColumn, Int32 iIndexOccupation, Double dPas, DateTime dtDateBegin)
            {
                if (laTable == null)
                    return;
                if (laTable.Columns.Count < iIndexTime)
                    return;
                if (laTable.Columns.Count < iIndexColumn)
                    return;
                if (PaxOccupation == null)
                    return;
                if (PaxOccupation.Length == 0)
                    return;
                if (PaxOccupation.Length % 2 != 0)
                    return;
                for (int i = 0; i < PaxOccupation.Length; i += 2)
                {
                    setPax(laTable, iIndexTime, PaxOccupation[i], PaxOccupation[i + 1], iIndexColumn, iIndexOccupation, dPas, dtDateBegin);
                }
            }

            #endregion

            #region Fonction pour obtenir les occupations des couloirs.
            public DataTable getCorridorOccupation()
            {
                DataTable CorridorOccupation = new DataTable("Airport_Flow");
                CorridorOccupation.Columns.Add("Time", typeof(DateTime));
                foreach (PaxResultsStruct PaxTmp in PaxResults.Values)
                {
                    if (!PaxTmp.CheckPaxIsValidForFilter(tfFilter))
                        continue;
                    PaxTmp.CorridorOccupation(CorridorOccupation, dPasOccupation, dtBeginTime_);
                }
                for (int i = 1; i < CorridorOccupation.Columns.Count; i++)
                {
                    // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation                    
                    //ResultFunctions.AnalyzePeak_SlidingHour(CorridorOccupation, i, i, dPasOccupation, bSlidingHour_);
                    ResultFunctions.calculateThroughputSliding(CorridorOccupation, i, i, dPasOccupation, analysisRange);
                    // >> Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                }
                return CorridorOccupation;
            }
            #endregion

            #region Fonction pour le temps restant avant le vol départ.
            private void getRemainingTimes(Double dPas, int iNbClasses, DateTime dtBeginTime_)
            {
                ArrayList tmp;
                DataTable table;
                foreach (PaxResultsStruct pax in PaxResults.Values)
                {
                    if (!pax.CheckPaxIsValidForFilter(tfFilter))
                        continue;
                    pax.getRemainingTime(dPas, dtBeginTime_, htRemainingTime_);
                }

                //Analyse des contenus des tables dans la htRemainingTime.
                foreach (String key in htRemainingTime_.Keys)
                {
                    table = BuildClassRemainingTable(key + "_Remaining", dPas, iNbClasses);
                    tmp = (ArrayList)htRemainingTime_[key];
                    foreach (Double Result in tmp)
                    {
                        int iIndex = ResultFunctions.DetermineClass(Result, dPas, iNbClasses);
                        table.Rows[iIndex][1] = (int)table.Rows[iIndex][1] + 1;
                    }
                    TablesRemainingTimes_.Add(table.TableName, table);
                }
            }
            #endregion


            #region Fonction qui se charge de générer une table sur l'occupation de l'aéroport en global
            public DataTable getAirportStatistics(DateTime dtBeginDate)
            {
                DataTable ResultTable = new DataTable("Airport_Occupation");
                ResultTable.Columns.Add("Time", typeof(DateTime));
                ResultTable.Columns.Add("Occupation", typeof(Int32));
                ResultTable.Columns[ResultTable.Columns.Count - 1].ExtendedProperties.Add("ToolTip", "(Number of pax)");
                ResultTable.Columns.Add("Occupation2", typeof(Int32));
                foreach (PaxResultsStruct PaxTmp in PaxResults.Values)
                {
                    setPax(ResultTable, 0, PaxTmp.ArrivalTime, PaxTmp.LeavingTime, 1, 2, dPasOccupation, dtBeginDate);
                }
                ResultTable.Columns.RemoveAt(2);
                return ResultTable;
            }
            #endregion

            #region Fonction qui se charge de compiler les distributions des desks au niveaux des groupes
            private static void AddDeskRepartition(DataTable dtGroupTable, DataTable dtDeskTable, String sDeskName, DateTime dtStartTime, Double dPas)
            {
                if (dtDeskTable.Columns.Count == 0)
                    return;
                if (dtGroupTable.Columns.Count == 0)
                {
                    dtGroupTable.Columns.Add(dtDeskTable.Columns[0].ColumnName, dtDeskTable.Columns[0].DataType);
                    dtGroupTable.Columns.Add(dtDeskTable.Columns[1].ColumnName, dtDeskTable.Columns[1].DataType);
                    dtGroupTable.Columns.Add("Total", typeof(Double));
                    dtGroupTable.Columns[2].ExtendedProperties.Add("ToolTip", "(%)");
                    dtGroupTable.Columns.Add(GlobalNames.GROUP_UTILIZATION_DESK_NEED_COLUMN_NAME, typeof(Int32));    //.Add("Desks Need", typeof(Int32));  // >> Task #10440 Pax2Sim - Pax analysis - missing KPIs part 1
                    dtGroupTable.Columns[3].ExtendedProperties.Add("ToolTip", "Number of Stations");
                    dtGroupTable.Columns.Add(GlobalNames.GROUP_UTILIZATION_AVERAGE_COLUMN_NAME, typeof(Double));    //.Add("Average", typeof(Double));    // >> Task #10440 Pax2Sim - Pax analysis - missing KPIs part 1
                    dtGroupTable.Columns[4].ExtendedProperties.Add("ToolTip", "(%)");
                }
                if (!dtGroupTable.Columns.Contains(sDeskName))
                {
                    dtGroupTable.Columns.Add(sDeskName, typeof(Double));
                    dtGroupTable.Columns[dtGroupTable.Columns.Count - 1].ExtendedProperties.Add("ToolTip", "(%)");
                }
                int iIndex = dtGroupTable.Columns.IndexOf(sDeskName);
                int i;
                for (i = 0; i < dtDeskTable.Rows.Count; i++)
                {
                    if (dtGroupTable.Rows.Count <= i)
                    {
                        DataRow newLine = dtGroupTable.NewRow();
                        newLine[0] = dtStartTime.AddMinutes(i * dPas);
                        newLine[1] = dtStartTime.AddMinutes((i + 1) * dPas);
                        for (int j = 2; j < dtGroupTable.Columns.Count; j++)
                        {
                            newLine[j] = 0;
                        }
                        dtGroupTable.Rows.Add(newLine);
                    }
                    dtGroupTable.Rows[i][iIndex] = dtDeskTable.Rows[i][2];
                    dtGroupTable.Rows[i][2] = (Double)dtGroupTable.Rows[i][2] + (Double)dtDeskTable.Rows[i][2];
                }
                for (; i < dtGroupTable.Rows.Count; i++)
                {
                    dtGroupTable.Rows[i][iIndex] = 0;
                }
            }
            #endregion

            private void CalcGroupStatistics()
            {
                foreach (PaxResultsStruct Paxtmp in PaxResults.Values)
                {
                    if (!Paxtmp.CheckPaxIsValidForFilter(tfFilter))
                        continue;
                    Paxtmp.setGroupStatistics(DeskInformations2_);
                }
            }

            // << Task #8589 Pax2Sim - Waiting Time Per Period of Time for PAX
            #region Function that is used to create the waiting time tables
            private DataTable createDwellTimeTable(String resourceName,
                out double totalDwellArea)  // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
            {
                DataTable dwellTimeTable = new DataTable(resourceName + GlobalNames.DWELL_TIME_TABLE_NAME_SUFIX);

                dwellTimeTable.Columns.Add("Time", typeof(DateTime));
                dwellTimeTable.Columns.Add(GlobalNames.DWELL_AREA_MIN_COLUMN_NAME, typeof(Double));
                dwellTimeTable.Columns.Add(GlobalNames.DWELL_AREA_AVG_COLUMN_NAME, typeof(Double));
                dwellTimeTable.Columns.Add(GlobalNames.DWELL_AREA_MAX_COLUMN_NAME, typeof(Double));
                dwellTimeTable.Columns.Add("Nb Pax", typeof(Int32));

                OverallTools.DataFunctions.initialiserLignes(dwellTimeTable, dtBeginTime_, dtEndTime_, dPasOccupation);
                foreach (DataRow row in dwellTimeTable.Rows)
                {
                    row[1] = 0.0d;
                    row[2] = 0.0d;
                    row[3] = 0.0d;
                    row[4] = 0;
                }
                totalDwellArea = 0; // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent

                List<PaxTravelInfoForResource> paxList = new List<PaxTravelInfoForResource>();
                if (paxTravelInfomationForResources.ContainsKey(resourceName))
                    paxList = paxTravelInfomationForResources[resourceName];

                if (paxList != null && paxList.Count > 0)
                {
                    int rowIndex = 0;
                    foreach (DataRow row in dwellTimeTable.Rows)
                    {
                        DateTime referenceBeginTime = (DateTime)row[0];
                        DateTime referenceEndTime = DateTime.MinValue;

                        if (rowIndex + 1 < dwellTimeTable.Rows.Count)
                            referenceEndTime = (DateTime)dwellTimeTable.Rows[rowIndex + 1][0];
                        else
                        {
                            DateTime finalTime = (DateTime)row[0];
                            referenceEndTime = finalTime.AddMinutes(dPasOccupation);
                        }

                        rowIndex = rowIndex + 1;

                        if (referenceBeginTime != null && referenceEndTime != DateTime.MinValue)
                        {
                            double min = double.MaxValue;
                            double max = double.MinValue;
                            int nbPax = 0;
                            double total = 0;

                            foreach (PaxTravelInfoForResource paxTravelInfo in paxList)
                            {
                                if (paxTravelInfo.arrivalTime >= referenceBeginTime && paxTravelInfo.arrivalTime < referenceEndTime)
                                {
                                    if (paxTravelInfo.dwellTime < min)
                                        min = paxTravelInfo.dwellTime;
                                    if (paxTravelInfo.dwellTime > max)
                                        max = paxTravelInfo.dwellTime;
                                    total += paxTravelInfo.dwellTime;
                                    nbPax++;
                                }
                            }
                            if (min != double.MaxValue && max != double.MinValue)
                            {
                                row[1] = Math.Round(min, 2);
                                row[2] = Math.Round((double)total / (double)nbPax, 2);
                                row[3] = Math.Round(max, 2);
                                row[4] = nbPax;

                                totalDwellArea += total; // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                            }
                        }
                    }
                    dwellTimeTable.AcceptChanges();
                }

                return dwellTimeTable;
            }
            #endregion
            // >> Task #8589 Pax2Sim - Waiting Time Per Period of Time for PAX

            // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
            private DataTable createDwellTimeTable(String resourceName, Double distributionPercent)
            {
                DataTable dwellTimeTable = new DataTable(resourceName + GlobalNames.DWELL_TIME_TABLE_NAME_SUFIX);

                dwellTimeTable.Columns.Add("Time", typeof(DateTime));
                dwellTimeTable.Columns.Add(GlobalNames.DWELL_AREA_MIN_COLUMN_NAME, typeof(Double));
                dwellTimeTable.Columns.Add(GlobalNames.DWELL_AREA_AVG_COLUMN_NAME, typeof(Double));
                dwellTimeTable.Columns.Add(GlobalNames.DWELL_AREA_MAX_COLUMN_NAME, typeof(Double));
                dwellTimeTable.Columns.Add("Nb Pax", typeof(Int32));

                OverallTools.DataFunctions.initialiserLignes(dwellTimeTable, dtBeginTime_, dtEndTime_, dPasOccupation);
                foreach (DataRow row in dwellTimeTable.Rows)
                {
                    row[1] = 0.0d;
                    row[2] = 0.0d;
                    row[3] = 0.0d;
                    row[4] = 0;
                }

                List<PaxTravelInfoForResource> paxList = new List<PaxTravelInfoForResource>();
                if (paxTravelInfomationForResources.ContainsKey(resourceName))
                    paxList = paxTravelInfomationForResources[resourceName];

                if (paxList != null && paxList.Count > 0)
                {
                    List<PaxTravelInfoForResource> truncatedPaxList
                        = ResultFunctions.getTruncatedListByPercent(paxList, distributionPercent);

                    if (truncatedPaxList != null)
                    {

                        int rowIndex = 0;
                        foreach (DataRow row in dwellTimeTable.Rows)
                        {
                            DateTime referenceBeginTime = (DateTime)row[0];
                            DateTime referenceEndTime = DateTime.MinValue;

                            if (rowIndex + 1 < dwellTimeTable.Rows.Count)
                                referenceEndTime = (DateTime)dwellTimeTable.Rows[rowIndex + 1][0];
                            else
                            {
                                DateTime finalTime = (DateTime)row[0];
                                referenceEndTime = finalTime.AddMinutes(dPasOccupation);
                            }

                            rowIndex = rowIndex + 1;

                            if (referenceBeginTime != null && referenceEndTime != DateTime.MinValue)
                            {
                                double min = double.MaxValue;
                                double max = double.MinValue;
                                int nbPax = 0;
                                double total = 0;

                                foreach (PaxTravelInfoForResource paxTravelInfo in truncatedPaxList)
                                {
                                    if (paxTravelInfo.arrivalTime >= referenceBeginTime && paxTravelInfo.arrivalTime < referenceEndTime)
                                    {
                                        if (paxTravelInfo.dwellTime < min)
                                            min = paxTravelInfo.dwellTime;
                                        if (paxTravelInfo.dwellTime > max)
                                            max = paxTravelInfo.dwellTime;
                                        total += paxTravelInfo.dwellTime;
                                        nbPax++;
                                    }
                                }
                                if (min != double.MaxValue && max != double.MinValue)
                                {
                                    row[1] = Math.Round(min, 2);
                                    row[2] = Math.Round((double)total / (double)nbPax, 2);
                                    row[3] = Math.Round(max, 2);
                                    row[4] = nbPax;
                                }
                            }
                        }
                        dwellTimeTable.AcceptChanges();
                    }
                }
                return dwellTimeTable;
            }
            // << Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
            #region #### Fonction qui va s'occuper de générer toutes les tables ####

            /// <summary>
            /// Main function that will calculate all the statistics for the passengers.
            /// </summary>
            /// <param name="AirportRoot">Airport structure of the current projet that will be needed to generate the statistics.</param>
            public void GenerateAllTable(TreeNode AirportRoot,
                GestionDonneesHUB2SIM donnees,  // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                string scenarioName, double samplingStep, List<double> scenarioPercentiles)    // >> Task #13206 Pax2Sim - Dynamic Analysis - Arrival Flight Statistics
            {

                // >> Task #9936 Pax2Sim - project properties saved specifically for each scenario + Times stats Spec
                double[] percentiles = new double[3];
                if (scenarioPercentiles == null || scenarioPercentiles.Count == 0)
                {
                    percentiles = donnees.Levels;
                }
                else if (scenarioPercentiles.Count == 3)
                {
                    percentiles[0] = scenarioPercentiles[0];
                    percentiles[1] = scenarioPercentiles[1];
                    percentiles[2] = scenarioPercentiles[2];
                }
                // << Task #9936 Pax2Sim - project properties saved specifically for each scenario + Times stats Spec

                PaxResultsStruct.dEndTime = OverallTools.DataFunctions.MinuteDifference(dtBeginTime_, dtEndTime_);
                dsdTable = new Dictionary<string, DataTable>();
                extractInformations();

                CalcGroupStatistics();
                dtDepartureFlightStatistics = AnalyseObjectives(dtPaxPlan, PaxResults, dtFPDTableNormal, dtSimpleFPDTable, dtEndTime_, samplingStep, out vmDepartureFlightStatistics);  //5, out vmDepartureFlightStatistics);
                // >> Task #13206 Pax2Sim - Dynamic Analysis - Arrival Flight Statistics
                DataTable fpdPax = donnees.getTable(scenarioName, GlobalNames.FPD_PAX_TABLE_NAME);
                if (fpdPax != null)
                {
                    Dictionary<int, List<double>> entryToGateByFlightId = new Dictionary<int, List<double>>();
                    departureStats = getDepartureFlightStats(dtFPDTableNormal, fpdPax,
                                        dtDepartureFlightStatistics, dtSimpleFPDTable, dtPaxPlan,
                                        PaxResults, samplingStep, percentiles, null, null, out entryToGateByFlightId);
                    // >> Departure_Statistics, Arrival_Statistics segregate by Airline, Flight category
                    List<string> allAirlineCodes = DataFunctions.getUniqueValuesFromColumn(dtFPDTableNormal, GlobalNames.sFPD_A_Column_AirlineCode);
                    Dictionary<string, DataTable> segregatioSource = new Dictionary<string, DataTable>();
                    foreach (string airlineCode in allAirlineCodes)
                    {
                        DataTable segregatedDepartureStats = getSegregatedTableByColumnIndexAndTargetValue(departureStats, GlobalNames.sFPD_A_Column_AirlineCode, airlineCode);
                        if (segregatedDepartureStats != null)
                        {
                            departureStatsByAirline.Add(segregatedDepartureStats);
                            if (!segregatioSource.ContainsKey(airlineCode))
                            {
                                segregatioSource.Add(airlineCode, segregatedDepartureStats);
                            }
                        }
                    }
                    DataTable segregationStatsTable = getSegregatedStatisticTable(segregatioSource, departureStats, "Airline", entryToGateByFlightId);
                    departureStatsSegregated.Add(segregationStatsTable);

                    List<string> allFlightCategories = DataFunctions.getUniqueValuesFromColumn(dtFPDTableNormal, GlobalNames.sFPD_A_Column_FlightCategory);
                    segregatioSource.Clear();
                    foreach (string flightCategory in allFlightCategories)
                    {
                        DataTable segregatedDepartureStats = getSegregatedTableByColumnIndexAndTargetValue(departureStats, GlobalNames.sFPD_A_Column_FlightCategory, flightCategory);
                        if (segregatedDepartureStats != null)
                        {
                            departureStatsByFlightCategories.Add(segregatedDepartureStats);
                            if (!segregatioSource.ContainsKey(flightCategory))
                            {
                                segregatioSource.Add(flightCategory, segregatedDepartureStats);
                            }
                        }
                    }
                    segregationStatsTable = getSegregatedStatisticTable(segregatioSource, departureStats, "Flight category", entryToGateByFlightId);
                    departureStatsSegregated.Add(segregationStatsTable);
                    // << Departure_Statistics, Arrival_Statistics segregate by Airline, Flight category
                }
                DataTable fpaPax = donnees.getTable(scenarioName, GlobalNames.FPA_PAX_TABLE_NAME);
                if (fpaPax != null)
                {
                    Dictionary<int, List<double>> gateToReclaimByFlightId = new Dictionary<int, List<double>>();
                    arrivalStats = getArrivalFlightStats(dtFPATableNormal, fpaPax, dtSimpleFPATable,
                        dtPaxPlan, PaxResults, samplingStep, percentiles, out gateToReclaimByFlightId);

                    // >> Departure_Statistics, Arrival_Statistics segregate by Airline, Flight category                    
                    List<string> allAirlineCodes = DataFunctions.getUniqueValuesFromColumn(dtFPATableNormal, GlobalNames.sFPD_A_Column_AirlineCode);
                    Dictionary<string, DataTable> segregatioSource = new Dictionary<string, DataTable>();
                    foreach (string airlineCode in allAirlineCodes)
                    {
                        DataTable segregatedArrivalStats = getSegregatedTableByColumnIndexAndTargetValue(arrivalStats, GlobalNames.sFPD_A_Column_AirlineCode, airlineCode);
                        if (segregatedArrivalStats != null)
                        {
                            arrivalStatsByAirline.Add(segregatedArrivalStats);
                            if (!segregatioSource.ContainsKey(airlineCode))
                            {
                                segregatioSource.Add(airlineCode, segregatedArrivalStats);
                            }
                        }
                    }
                    DataTable segregationStatsTable = getSegregatedStatisticTable(segregatioSource, arrivalStats, "Airline", gateToReclaimByFlightId);
                    arrivalStatsSegregated.Add(segregationStatsTable);

                    List<string> allFlightCategories = DataFunctions.getUniqueValuesFromColumn(dtFPATableNormal, GlobalNames.sFPD_A_Column_FlightCategory);
                    segregatioSource.Clear();
                    foreach (string flightCategory in allFlightCategories)
                    {
                        DataTable segregatedArrivalStats = getSegregatedTableByColumnIndexAndTargetValue(arrivalStats, GlobalNames.sFPD_A_Column_FlightCategory, flightCategory);
                        if (segregatedArrivalStats != null)
                        {
                            arrivalStatsByFlightCategories.Add(segregatedArrivalStats);
                            if (!segregatioSource.ContainsKey(flightCategory))
                            {
                                segregatioSource.Add(flightCategory, segregatedArrivalStats);
                            }
                        }
                    }
                    segregationStatsTable = getSegregatedStatisticTable(segregatioSource, arrivalStats, "Flight category", gateToReclaimByFlightId);
                    arrivalStatsSegregated.Add(segregationStatsTable);
                    // << Departure_Statistics, Arrival_Statistics segregate by Airline, Flight category
                }
                // << Task #13206 Pax2Sim - Dynamic Analysis - Arrival Flight Statistics

                AnalyseCounters();
                PaxTravelStats_ = getCorridorOccupation();
                getRemainingTimes(dPasRemaining, iNbClassesRemaining, dtBeginTime_);
                //DataTable tableOccupation = getAirportStatistics(dtBeginTime_);
                DataTable tableOccupation;
                //TablesOccupation_.Add(tableOccupation.TableName, tableOccupation);

                // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                //CalcAirportOccupation(TablesOccupation_);
                double totalOccupation = 0;
                CalcAirportOccupation(TablesOccupation_, out totalOccupation);

                if (DeskInformations2_.ContainsKey(GlobalNames.AIRPORT_REPORTS_NODE_NAME))
                {
                    DeskReport drAirportReports = (DeskReport)DeskInformations2_[GlobalNames.AIRPORT_REPORTS_NODE_NAME];
                    if (drAirportReports != null)
                    {
                        drAirportReports.totalOccupation = totalOccupation;
                    }
                }
                // << Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent

                // << Task #8589 Pax2Sim - Waiting Time Per Period of Time for PAX
                getPaxTravelInfoForResources();
                // >> Task #8589 Pax2Sim - Waiting Time Per Period of Time for PAX

                foreach (TreeNode tnTerminal in AirportRoot.Nodes)
                {
                    if (((TreeViewTag)tnTerminal.Tag).AirportObjectType != PAX2SIM.sTerminalName)
                        continue;
                    String sTerminal = "T" + ((TreeViewTag)tnTerminal.Tag).Index.ToString();
                    tableOccupation = getTerminalStatistics(((TreeViewTag)tnTerminal.Tag).Index);
                    tableOccupation.TableName = tableOccupation.TableName /*+ "_Occupation"*/;
                    TablesOccupation_.Add(tableOccupation.TableName, tableOccupation);

                    if (DeskInformations2_.ContainsKey(sTerminal))
                    {
                        DeskReport drTerminal = (DeskReport)DeskInformations2_[sTerminal];
                        Double[] tdStats = OverallTools.DataFunctions.GetStatColumn(tableOccupation, "Min Occupation");
                        Double[] tdStats2 = OverallTools.DataFunctions.GetStatColumn(tableOccupation, "Average Occupation");
                        Double[] tdStats3 = OverallTools.DataFunctions.GetStatColumn(tableOccupation, "Max Occupation");
                        if ((tdStats != null) && (tdStats2 != null) && (tdStats3 != null))
                        {
                            drTerminal.AddQueueOccupation(tdStats[0], tdStats3[1], tdStats2[2]);
                        }
                    }

                    foreach (TreeNode tnLevel in tnTerminal.Nodes)
                    {
                        if (((TreeViewTag)tnLevel.Tag).AirportObjectType != PAX2SIM.sLevelName)
                            continue;
                        String sLevel = sTerminal + "L" + ((TreeViewTag)tnLevel.Tag).Index.ToString();
                        tableOccupation = getLevelStatistics(((TreeViewTag)tnTerminal.Tag).Index, ((TreeViewTag)tnLevel.Tag).Index);
                        tableOccupation.TableName = tableOccupation.TableName /*+ "_Occupation"*/;
                        TablesOccupation_.Add(tableOccupation.TableName, tableOccupation);


                        if (DeskInformations2_.ContainsKey(sLevel))
                        {
                            DeskReport drLevel = (DeskReport)DeskInformations2_[sLevel];
                            Double[] tdStats = OverallTools.DataFunctions.GetStatColumn(tableOccupation, "Min Occupation");
                            Double[] tdStats2 = OverallTools.DataFunctions.GetStatColumn(tableOccupation, "Average Occupation");
                            Double[] tdStats3 = OverallTools.DataFunctions.GetStatColumn(tableOccupation, "Max Occupation");
                            if ((tdStats != null) && (tdStats2 != null) && (tdStats3 != null))
                            {
                                drLevel.AddQueueOccupation(tdStats[0], tdStats3[1], tdStats2[2]);
                            }
                        }


                        foreach (TreeNode tnGroups in tnLevel.Nodes)
                        {

                            TreeViewTag aoGroup = (TreeViewTag)tnGroups.Tag;
                            String sGroup = sLevel + "_" + aoGroup.AirportObjectType + " " + aoGroup.Index;
                            DeskReport drGroup = null;
                            if (DeskInformations2_.ContainsKey(sGroup))
                                drGroup = (DeskReport)DeskInformations2_[sGroup];
                            DataTable GroupUtilization = new DataTable(sGroup + "_Utilization");

                            DataTable GroupRemaining = BuildClassRemainingTable(sGroup + "_Remaining", dPasRemaining,
                                                                                iNbClassesRemaining);
                            DataTable GroupTime = ResultFunctions.BuildClassTable(sGroup + "_Time", dPasTime,
                                                                                  iNbClassesTime, 0, "Minutes",
                                                                                  new String[]
                                                                                      {
                                                                                          "TotalTime", "DelayTime", "Process",
                                                                                          "WaitingDesk", "WaitingGroup"
                                                                                      });

                            DataTable dtGroupIST = null;

                            // << Task #8589 Pax2Sim - Waiting Time Per Period of Time for PAX
                            List<PaxTravelInfoForResource> paxList = new List<PaxTravelInfoForResource>();
                            // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                            double totalDwellArea = 0;
                            DataTable dwellTimeTable = createDwellTimeTable(sGroup, out totalDwellArea);    // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent                            
                            if (drGroup != null)
                            {
                                drGroup.totalDwellArea = totalDwellArea;
                            }
                            // << Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent

                            if (paxTravelInfomationForResources.ContainsKey(sGroup))
                                paxList = paxTravelInfomationForResources[sGroup];
                            if (paxList != null && paxList.Count > 0)
                                _dwellTimeTables.Add(dwellTimeTable.TableName, dwellTimeTable);
                            // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                            if (drGroup != null)
                            {
                                int minDwellAreaColumnIndex = dwellTimeTable.Columns.IndexOf(GlobalNames.DWELL_AREA_MIN_COLUMN_NAME);
                                int avgDwellAreaColumnIndex = dwellTimeTable.Columns.IndexOf(GlobalNames.DWELL_AREA_AVG_COLUMN_NAME);
                                int maxDwellAreaColumnIndex = dwellTimeTable.Columns.IndexOf(GlobalNames.DWELL_AREA_MAX_COLUMN_NAME);
                                int nbPaxDwellAreaColumnIndex = dwellTimeTable.Columns.IndexOf(GlobalNames.DWELL_AREA_NB_PAX_COLUMN_NAME);

                                if (minDwellAreaColumnIndex != -1 && nbPaxDwellAreaColumnIndex != -1)
                                {
                                    Double[] statsGr = DataFunctions.GetStatColumnIgnoreZeros(dwellTimeTable, minDwellAreaColumnIndex, nbPaxDwellAreaColumnIndex);
                                    drGroup.MinDwellDesk = statsGr[0];
                                }
                                if (avgDwellAreaColumnIndex != -1 && nbPaxDwellAreaColumnIndex != -1)
                                {
                                    Double[] statsGr = DataFunctions.GetStatColumnIgnoreZeros(dwellTimeTable, avgDwellAreaColumnIndex, nbPaxDwellAreaColumnIndex);
                                    drGroup.MeanDwellDesk = statsGr[2];
                                }
                                if (maxDwellAreaColumnIndex != -1 && nbPaxDwellAreaColumnIndex != -1)
                                {
                                    Double[] statsGr = DataFunctions.GetStatColumnIgnoreZeros(dwellTimeTable, maxDwellAreaColumnIndex, nbPaxDwellAreaColumnIndex);
                                    drGroup.MaxDwellDesk = statsGr[1];
                                }
                            }
                            // << Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                            // >> Task #8589 Pax2Sim - Waiting Time Per Period of Time for PAX

                            //DeskReport drGroup = ((DeskReport) DeskInformations2_[sGroup]);
                            DataTable allocationTableFromChildDesk = null;    // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent

                            foreach (TreeNode tnDesk in tnGroups.Nodes)
                            {
                                TreeViewTag aoDesk = (TreeViewTag)tnDesk.Tag;
                                String sDesk = sLevel + "_" + aoDesk.AirportObjectType + " " + aoDesk.Index;
                                if (!DeskResults.ContainsKey(sDesk))
                                    continue;
                                DeskReport drDesk = null;
                                if (DeskInformations2_.ContainsKey(sDesk))
                                    drDesk = ((DeskReport)DeskInformations2_[sDesk]);
                                if (drGroup == null)
                                    break;
                                if (drDesk == null)
                                    return;

                                drGroup.SetDeskStatistics(drDesk);
                                tableOccupation = getDeskStatistics(sDesk);
                                /* if (!DeskResults.ContainsKey(sDeskName))
                                {
                                    return null;
                                }
                                DeskGroupResultsStruct DeskTmp = (DeskGroupResultsStruct)DeskResults[sDeskName];*/
                                tableOccupation.TableName = sDesk + "_Occupation";
                                Double[] tdStats = OverallTools.DataFunctions.GetStatColumn(tableOccupation,
                                                                                            "Min Occupation");
                                Double[] tdStats2 = OverallTools.DataFunctions.GetStatColumn(tableOccupation,
                                                                                             "Average Occupation");
                                Double[] tdStats3 = OverallTools.DataFunctions.GetStatColumn(tableOccupation,
                                                                                             "Max Occupation");
                                if ((tdStats != null) && (tdStats2 != null) && (tdStats3 != null))
                                {
                                    drDesk.AddQueueOccupation(tdStats[0], tdStats3[1], tdStats2[2]);
                                    //drGroup.UpdateQueueOccupation(tdStats[0], tdStats3[1], tdStats2[2]);// >> Task #10441 Pax analysis - Summary - QueueOccupation for Groups
                                }
                                TablesOccupation_.Add(tableOccupation.TableName, tableOccupation);

                                // >> Task #10440 Pax2Sim - Pax analysis - missing KPIs part 1
                                Double[] deskThroughputInputStats = OverallTools.DataFunctions
                                            .GetStatColumn(tableOccupation, GlobalNames.OCCUPATION_TABLE_THROUGHPUT_IN_COLUMN_NAME);
                                Double[] deskThroughputOutputStats = OverallTools.DataFunctions
                                                .GetStatColumn(tableOccupation, GlobalNames.OCCUPATION_TABLE_THROUGHPUT_OUT_COLUMN_NAME);
                                if (deskThroughputInputStats != null && deskThroughputOutputStats != null)
                                {
                                    double minThroughputIn = deskThroughputInputStats[0];
                                    double maxThroughputIn = deskThroughputInputStats[1];
                                    double avgThroughputIn = deskThroughputInputStats[2];

                                    drDesk.addOccupationThroughputInStats(minThroughputIn,
                                                    avgThroughputIn, maxThroughputIn);

                                    double minThroughputOut = deskThroughputOutputStats[0];
                                    double maxThroughputOut = deskThroughputOutputStats[1];
                                    double avgThroughputOut = deskThroughputOutputStats[2];

                                    drDesk.addOccupationThroughputOutStats(minThroughputOut,
                                                    avgThroughputOut, maxThroughputOut);
                                }
                                // << Task #10440 Pax2Sim - Pax analysis - missing KPIs part 1

                                // >> Task #13762 Pax2Sim - Dynamic Analysis - Occupation table
                                Double[] deskThroughputInstantInputStats = OverallTools.DataFunctions
                                                .GetStatColumn(tableOccupation, GlobalNames.OCCUPATION_TABLE_THROUGHPUT_INSTANT_IN_COLUMN_NAME);
                                Double[] deskThroughputInstantOutputStats = OverallTools.DataFunctions
                                                .GetStatColumn(tableOccupation, GlobalNames.OCCUPATION_TABLE_THROUGHPUT_INSTANT_OUT_COLUMN_NAME);
                                if (deskThroughputInstantInputStats != null && deskThroughputInstantOutputStats != null)
                                {
                                    double minThroughputIn = deskThroughputInstantInputStats[0];
                                    double maxThroughputIn = deskThroughputInstantInputStats[1];
                                    double avgThroughputIn = deskThroughputInstantInputStats[2];

                                    drDesk.addOccupationThroughputInstantInStats(minThroughputIn,
                                                    avgThroughputIn, maxThroughputIn);

                                    double minThroughputOut = deskThroughputInstantOutputStats[0];
                                    double maxThroughputOut = deskThroughputInstantOutputStats[1];
                                    double avgThroughputOut = deskThroughputInstantOutputStats[2];

                                    drDesk.addOccupationThroughputInstantOutStats(minThroughputOut,
                                                    avgThroughputOut, maxThroughputOut);
                                }
                                // << Task #13762 Pax2Sim - Dynamic Analysis - Occupation table

                                // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                if (tableOccupation != null && tableOccupation.Columns.IndexOf(GlobalNames.OCCUPATION_TABLE_PAX_IN_COLUMN_NAME) != -1
                                    && tableOccupation.Columns.IndexOf(GlobalNames.OCCUPATION_TABLE_PAX_OUT_COLUMN_NAME) != -1)
                                {
                                    double totalPaxIn = -1;
                                    double minPaxIn = -1;
                                    double maxPaxIn = -1;
                                    double avgPaxIn = -1;

                                    double totalPaxOut = -1;
                                    double minPaxOut = -1;
                                    double maxPaxOut = -1;
                                    double avgPaxOut = -1;

                                    Double[] deskOccupationPaxInStats
                                        = DataFunctions.GetStatColumn(tableOccupation, GlobalNames.OCCUPATION_TABLE_PAX_IN_COLUMN_NAME);
                                    Double[] deskOccupationPaxOutStats
                                        = DataFunctions.GetStatColumn(tableOccupation, GlobalNames.OCCUPATION_TABLE_PAX_OUT_COLUMN_NAME);

                                    if (deskOccupationPaxInStats != null && deskOccupationPaxOutStats != null
                                        && deskOccupationPaxInStats.Length >= 3 && deskOccupationPaxOutStats.Length >= 3)
                                    {
                                        minPaxIn = deskOccupationPaxInStats[0];
                                        maxPaxIn = deskOccupationPaxInStats[1];
                                        avgPaxIn = deskOccupationPaxInStats[2];

                                        minPaxOut = deskOccupationPaxOutStats[0];
                                        maxPaxOut = deskOccupationPaxOutStats[1];
                                        avgPaxOut = deskOccupationPaxOutStats[2];
                                    }

                                    totalPaxIn = DataFunctions.SumColumn(tableOccupation, GlobalNames.OCCUPATION_TABLE_PAX_IN_COLUMN_NAME);
                                    totalPaxOut = DataFunctions.SumColumn(tableOccupation, GlobalNames.OCCUPATION_TABLE_PAX_OUT_COLUMN_NAME);

                                    if (totalPaxIn != -1 && minPaxIn != -1 && avgPaxIn != -1 && maxPaxIn != -1)
                                    {
                                        drDesk.addOccupationPaxInStats(totalPaxIn, minPaxIn, avgPaxIn, maxPaxIn);
                                    }

                                    if (totalPaxOut != -1 && minPaxOut != -1 && avgPaxOut != -1 && maxPaxOut != -1)
                                    {
                                        drDesk.addOccupationPaxOutStats(totalPaxOut, minPaxOut, avgPaxOut, maxPaxOut);
                                    }
                                }
                                // << Task #10615 Pax2Sim - Pax analysis - Summary - small changes

                                DataTable tableUtilization =
                                    ((DeskGroupResultsStruct)DeskResults[sDesk]).DeskOccupation(dPasUtilisation);

                                // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)
                                /*
                                DataTable tableTime = ((DeskGroupResultsStruct)DeskResults[sDesk])
                                    .calcPaxRepartition(dPasTime, iNbClassesTime);
                                 */
                                DataTable tableTime = ((DeskGroupResultsStruct)DeskResults[sDesk])
                                    .calcPaxRepartitionWithDelayTime(dPasTime, iNbClassesTime);
                                // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)

                                // >> Task #10156 Pax2Sim - Statistic dev - Target
                                ArrayList alRemainingTimes = new ArrayList();
                                if (htRemainingTime_.ContainsKey(sDesk))
                                    alRemainingTimes = (ArrayList)htRemainingTime_[sDesk];
                                // << Task #10156 Pax2Sim - Statistic dev - Target

                                // >> Task #10440 Pax2Sim - Pax analysis - missing KPIs part 1
                                if (htRemainingTime_.ContainsKey(sDesk))
                                {
                                    //ArrayList remainingTimesList = (ArrayList)htRemainingTime_[sDesk];    // IST Remaining times bug
                                    ArrayList remainingTimesList = new ArrayList();
                                    foreach (double time in (ArrayList)htRemainingTime_[sDesk])
                                        remainingTimesList.Add(time);

                                    remainingTimesList.Sort();

                                    double minDeskRemainingTime = 0;
                                    double avgDeskRemainingTime = 0;
                                    double maxDeskRemainingTime = 0;

                                    if (remainingTimesList.Count > 0)
                                    {
                                        minDeskRemainingTime = (double)remainingTimesList[0];
                                        maxDeskRemainingTime = (double)remainingTimesList[remainingTimesList.Count - 1];
                                        avgDeskRemainingTime = FonctionUtiles.getAverageValueFromListOfNumbers(remainingTimesList);

                                        drDesk.addRemainingTimeStats(minDeskRemainingTime,
                                                    avgDeskRemainingTime, maxDeskRemainingTime);
                                    }
                                }
                                // << Task #10440 Pax2Sim - Pax analysis - missing KPIs part 1

                                DataTable IST_Pax =
                                    ((DeskGroupResultsStruct)DeskResults[sDesk]).calcPaxInDeskTime(dtBeginTime_, alRemainingTimes);  // >> Task #10156 Pax2Sim - Statistic dev - Target
                                if (IST_Pax != null)
                                {
                                    dsdTable.Add(IST_Pax.TableName, IST_Pax);
                                    if (dtGroupIST == null)
                                    {
                                        dtGroupIST = IST_Pax.Copy();
                                        dtGroupIST.TableName = sGroup + "_IST";
                                    }
                                    else
                                    {
                                        foreach (DataRow drRow in IST_Pax.Rows)
                                        {
                                            DataRow drNewRow = dtGroupIST.NewRow();
                                            for (int i = 0; i < dtGroupIST.Columns.Count; i++)
                                                drNewRow[i] = drRow[i];
                                            dtGroupIST.Rows.Add(drNewRow);
                                        }
                                    }
                                }
                                tableTime.TableName = tableTime.TableName + "_Time";
                                tableUtilization.TableName = tableUtilization.TableName + "_Utilization";
                                TablesTime_.Add(tableTime.TableName, tableTime);
                                TablesUtilization_.Add(tableUtilization.TableName, tableUtilization);

                                // >> Task #13243 Pax2Sim - Dynamic simulation - Desk Plan Information
                                if (tableUtilization != null)
                                {
                                    DataTable deskPlanInformationTable = tableUtilization.Copy();
                                    deskPlanInformationTable.TableName = sDesk + VinciTools.DESK_PLAN_INFORMATION_TABLE_NAME_SUFFIX;
                                    if (deskPlanInformationTable != null
                                        && !_deskPlanInformationTables.ContainsKey(deskPlanInformationTable.TableName))
                                    {
                                        _deskPlanInformationTables.Add(deskPlanInformationTable.TableName, deskPlanInformationTable);
                                    }
                                }
                                // << Task #13243 Pax2Sim - Dynamic simulation - Desk Plan Information

                                // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent                                                                
                                if (drDesk != null)
                                {
                                    drDesk.totalUtilizationPercent = DataFunctions.SumColumn(tableUtilization, GlobalNames.DESK_UTILIZATION_UTILIZATION_PERCENT_COLUMN_NAME);
                                    if (IST_Pax != null)
                                    {
                                        drDesk.totalRemainingTime = DataFunctions.SumColumn(IST_Pax, GlobalNames.IST_REMAINING_TIME_COLUMN_NAME);
                                    }
                                }
                                // << Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent

                                // >> Task #10440 Pax2Sim - Pax analysis - missing KPIs part 1
                                Double[] deskUtilizationPercentStats = OverallTools.DataFunctions
                                            .GetStatColumn(tableUtilization, GlobalNames.DESK_UTILIZATION_UTILIZATION_PERCENT_COLUMN_NAME);
                                if (deskUtilizationPercentStats != null)
                                {
                                    double minUtilizationPercent = (double)deskUtilizationPercentStats[0];
                                    double maxUtilizationPercent = (double)deskUtilizationPercentStats[1];
                                    double avgUtilizationPercent = (double)deskUtilizationPercentStats[2];

                                    drDesk.addUtilizationPercentStats(minUtilizationPercent,
                                        avgUtilizationPercent, maxUtilizationPercent);
                                }
                                // << Task #10440 Pax2Sim - Pax analysis - missing KPIs part 1

                                // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                                double level1 = percentiles[0];
                                double level2 = percentiles[1];
                                double level3 = percentiles[2];

                                // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes                                
                                AddDeskRepartition(GroupUtilization, tableUtilization, sDesk, dtBeginTime_,
                                                   dPasUtilisation /*15.0f*/);

                                CompileData(GroupRemaining, (DataTable)TablesRemainingTimes_[sDesk + "_Remaining"]);
                                ResultFunctions.GenerateRepartition(
                                    (DataTable)TablesRemainingTimes_[sDesk + "_Remaining"], 1, "%_Nb Pax",
                                    "%Cumul_Nb Pax");

                                // << Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)                                
                                CompileData(GroupTime, tableTime, 5);
                                // >> Task #8647 Pax2Sim - Adapt to PaxTrace modification (a new delay(waiting) time is added for each Group)

                                // << Task #8589 Pax2Sim - Waiting Time Per Period of Time for PAX
                                double totalDeskDwellArea = 0;                                              // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                                dwellTimeTable = createDwellTimeTable(sDesk, out totalDeskDwellArea);       // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                                if (drDesk != null)
                                {
                                    drDesk.totalDwellArea = totalDeskDwellArea;                                 // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                                }
                                if (paxTravelInfomationForResources.ContainsKey(sDesk))
                                    paxList = paxTravelInfomationForResources[sDesk];
                                if (paxList != null && paxList.Count > 0)
                                    _dwellTimeTables.Add(dwellTimeTable.TableName, dwellTimeTable);
                                // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                                //set the min,avg,max dwell area in summary according to the dwell area table
                                int minDwellAreaDeskColumnIndex = dwellTimeTable.Columns.IndexOf(GlobalNames.DWELL_AREA_MIN_COLUMN_NAME);
                                int avgDwellAreaDeskColumnIndex = dwellTimeTable.Columns.IndexOf(GlobalNames.DWELL_AREA_AVG_COLUMN_NAME);
                                int maxDwellAreaDeskColumnIndex = dwellTimeTable.Columns.IndexOf(GlobalNames.DWELL_AREA_MAX_COLUMN_NAME);
                                int nbPaxDeskColumnIndex = dwellTimeTable.Columns.IndexOf(GlobalNames.DWELL_AREA_NB_PAX_COLUMN_NAME);

                                if (minDwellAreaDeskColumnIndex != -1 && nbPaxDeskColumnIndex != -1)
                                {
                                    Double[] stat = DataFunctions.GetStatColumnIgnoreZeros(dwellTimeTable, minDwellAreaDeskColumnIndex, nbPaxDeskColumnIndex);
                                    drDesk.MinDwellDesk = stat[0];
                                }
                                if (avgDwellAreaDeskColumnIndex != -1 && nbPaxDeskColumnIndex != -1)
                                {
                                    Double[] stat = DataFunctions.GetStatColumnIgnoreZeros(dwellTimeTable, avgDwellAreaDeskColumnIndex, nbPaxDeskColumnIndex);
                                    drDesk.MeanDwellDesk = stat[2];
                                }
                                if (maxDwellAreaDeskColumnIndex != -1 && nbPaxDeskColumnIndex != -1)
                                {
                                    Double[] stat = DataFunctions.GetStatColumnIgnoreZeros(dwellTimeTable, maxDwellAreaDeskColumnIndex, nbPaxDeskColumnIndex);
                                    drDesk.MaxDwellDesk = stat[1];
                                }
                                // << Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                                // >> Task #8589 Pax2Sim - Waiting Time Per Period of Time for PAX

                                // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                                DeskGroupResultsStruct deskResultStruct = (DeskGroupResultsStruct)DeskResults[sDesk];

                                allocationTableFromChildDesk = deskResultStruct.AllocationTable;

                                if (deskResultStruct != null)
                                {
                                    double distributionLevel1 = percentiles[0];
                                    double distributionLevel2 = percentiles[1];
                                    double distributionLevel3 = percentiles[2];
                                    // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes                                    
                                    if (deskResultStruct.DelayTimes != null)
                                    {
                                        double minDelayTimeLevel = -1;
                                        double maxDelayTimeLevel = -1;
                                        double avgDelayTimeLevel = -1;

                                        getStatsForListOfValuesByDistributionLevel(deskResultStruct.DelayTimes, distributionLevel1,
                                            out minDelayTimeLevel, out avgDelayTimeLevel, out maxDelayTimeLevel);

                                        // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                        //drDesk.addDelayTimeLevel1Stats(minDelayTimeLevel, avgDelayTimeLevel, maxDelayTimeLevel);
                                        drDesk.addDelayTimeLevel1Stats(-1, -1, maxDelayTimeLevel);

                                        getStatsForListOfValuesByDistributionLevel(deskResultStruct.DelayTimes, distributionLevel2,
                                            out minDelayTimeLevel, out avgDelayTimeLevel, out maxDelayTimeLevel);

                                        // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                        //drDesk.addDelayTimeLevel2Stats(minDelayTimeLevel, avgDelayTimeLevel, maxDelayTimeLevel);
                                        drDesk.addDelayTimeLevel2Stats(-1, -1, maxDelayTimeLevel);

                                        getStatsForListOfValuesByDistributionLevel(deskResultStruct.DelayTimes, distributionLevel3,
                                            out minDelayTimeLevel, out avgDelayTimeLevel, out maxDelayTimeLevel);

                                        // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                        //drDesk.addDelayTimeLevel3Stats(minDelayTimeLevel, avgDelayTimeLevel, maxDelayTimeLevel);
                                        drDesk.addDelayTimeLevel3Stats(-1, -1, maxDelayTimeLevel);
                                    }

                                    if (IST_Pax != null)
                                    {
                                        List<double> waitingTimesList = new List<double>();
                                        List<String> waitingColumnNames
                                            = new List<string>() { GlobalNames.IST_WAITING_DESK_TIME_COLUMN_NAME, GlobalNames.IST_WAITING_GROUP_TIME_COLUMN_NAME };
                                        if (DataFunctions.getSumOfTableColumnsAsListOfDouble(IST_Pax, waitingColumnNames, out waitingTimesList)
                                            && waitingTimesList != null)
                                        {
                                            double minWaitingTimeLevel = -1;
                                            double avgWaitingTimeLevel = -1;
                                            double maxWaitingTimeLevel = -1;

                                            getStatsForListOfValuesByDistributionLevel(waitingTimesList, distributionLevel1,
                                                out minWaitingTimeLevel, out avgWaitingTimeLevel, out maxWaitingTimeLevel);

                                            // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                            //drDesk.addWaitingTimeLevel1Stats(minWaitingTimeLevel, avgWaitingTimeLevel, maxWaitingTimeLevel);
                                            drDesk.addWaitingTimeLevel1Stats(-1, -1, maxWaitingTimeLevel);

                                            getStatsForListOfValuesByDistributionLevel(waitingTimesList, distributionLevel2,
                                                out minWaitingTimeLevel, out avgWaitingTimeLevel, out maxWaitingTimeLevel);

                                            // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                            //drDesk.addWaitingTimeLevel2Stats(minWaitingTimeLevel, avgWaitingTimeLevel, maxWaitingTimeLevel);
                                            drDesk.addWaitingTimeLevel2Stats(-1, -1, maxWaitingTimeLevel);

                                            getStatsForListOfValuesByDistributionLevel(waitingTimesList, distributionLevel3,
                                                out minWaitingTimeLevel, out avgWaitingTimeLevel, out maxWaitingTimeLevel);

                                            // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                            //drDesk.addWaitingTimeLevel3Stats(minWaitingTimeLevel, avgWaitingTimeLevel, maxWaitingTimeLevel);
                                            drDesk.addWaitingTimeLevel3Stats(-1, -1, maxWaitingTimeLevel);
                                        }

                                        #region total time from IST (Group)
                                        if (IST_Pax.Columns.IndexOf(GlobalNames.IST_TOTAL_TIME_COLUMN_NAME) != -1)
                                        {
                                            drDesk.totalTimeForAllPaxInStation = DataFunctions.SumColumn(IST_Pax, GlobalNames.IST_TOTAL_TIME_COLUMN_NAME);

                                            Double[] deskTotalTimeStats = OverallTools.DataFunctions
                                                .GetStatColumn(IST_Pax, GlobalNames.IST_TOTAL_TIME_COLUMN_NAME);

                                            if (deskTotalTimeStats != null)
                                            {
                                                drDesk.minTotalTime = deskTotalTimeStats[0];
                                                drDesk.maxTotalTime = deskTotalTimeStats[1];
                                                drDesk.avgTotalTime = deskTotalTimeStats[2];
                                            }

                                            List<double> deskTotalTimesList = new List<double>();
                                            if (DataFunctions.fromTableColumnToListOfDouble(IST_Pax, GlobalNames.IST_TOTAL_TIME_COLUMN_NAME
                                                                                            , out deskTotalTimesList)
                                                && deskTotalTimesList != null)
                                            {
                                                double min = -1;
                                                double avg = -1;
                                                double maxLevel1 = -1;
                                                double maxLevel2 = -1;
                                                double maxLevel3 = -1;

                                                getStatsForListOfValuesByDistributionLevel(deskTotalTimesList, distributionLevel1,
                                                    out min, out avg, out maxLevel1, false);
                                                getStatsForListOfValuesByDistributionLevel(deskTotalTimesList, distributionLevel2,
                                                    out min, out avg, out maxLevel2, false);
                                                getStatsForListOfValuesByDistributionLevel(deskTotalTimesList, distributionLevel3,
                                                    out min, out avg, out maxLevel3, false);

                                                drDesk.addTotalTimeMaxLevelsStats(maxLevel1, maxLevel2, maxLevel3);
                                            }
                                        }
                                        #endregion
                                    }

                                    if (deskResultStruct.WaitingTimesDesk != null)
                                    {
                                        double minWaitingDeskTimeLevel = -1;
                                        double maxWaitingDeskTimeLevel = -1;
                                        double avgWaitingDeskTimeLevel = -1;

                                        getStatsForListOfValuesByDistributionLevel(deskResultStruct.WaitingTimesDesk, distributionLevel1,
                                            out minWaitingDeskTimeLevel, out avgWaitingDeskTimeLevel, out maxWaitingDeskTimeLevel);

                                        // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                        //drDesk.addWaitingDeskTimeLevel1Stats(minWaitingDeskTimeLevel, avgWaitingDeskTimeLevel, maxWaitingDeskTimeLevel);
                                        drDesk.addWaitingDeskTimeLevel1Stats(-1, -1, maxWaitingDeskTimeLevel);

                                        getStatsForListOfValuesByDistributionLevel(deskResultStruct.WaitingTimesDesk, distributionLevel2,
                                            out minWaitingDeskTimeLevel, out avgWaitingDeskTimeLevel, out maxWaitingDeskTimeLevel);

                                        // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                        //drDesk.addWaitingDeskTimeLevel2Stats(minWaitingDeskTimeLevel, avgWaitingDeskTimeLevel, maxWaitingDeskTimeLevel);
                                        drDesk.addWaitingDeskTimeLevel2Stats(-1, -1, maxWaitingDeskTimeLevel);

                                        getStatsForListOfValuesByDistributionLevel(deskResultStruct.WaitingTimesDesk, distributionLevel3,
                                            out minWaitingDeskTimeLevel, out avgWaitingDeskTimeLevel, out maxWaitingDeskTimeLevel);

                                        // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                        //drDesk.addWaitingDeskTimeLevel3Stats(minWaitingDeskTimeLevel, avgWaitingDeskTimeLevel, maxWaitingDeskTimeLevel);
                                        drDesk.addWaitingDeskTimeLevel3Stats(-1, -1, maxWaitingDeskTimeLevel);
                                    }

                                    if (deskResultStruct.WaitingTimesGroup != null)
                                    {
                                        double minWaitingGroupTimeLevel = -1;
                                        double maxWaitingGroupTimeLevel = -1;
                                        double avgWaitingGroupTimeLevel = -1;

                                        getStatsForListOfValuesByDistributionLevel(deskResultStruct.WaitingTimesGroup, distributionLevel1,
                                            out minWaitingGroupTimeLevel, out avgWaitingGroupTimeLevel, out maxWaitingGroupTimeLevel);

                                        // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                        //                                        drDesk.addWaitingGroupTimeLevel1Stats(minWaitingGroupTimeLevel, avgWaitingGroupTimeLevel, maxWaitingGroupTimeLevel);
                                        drDesk.addWaitingGroupTimeLevel1Stats(-1, -1, maxWaitingGroupTimeLevel);

                                        getStatsForListOfValuesByDistributionLevel(deskResultStruct.WaitingTimesGroup, distributionLevel2,
                                            out minWaitingGroupTimeLevel, out avgWaitingGroupTimeLevel, out maxWaitingGroupTimeLevel);

                                        // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                        //drDesk.addWaitingGroupTimeLevel2Stats(minWaitingGroupTimeLevel, avgWaitingGroupTimeLevel, maxWaitingGroupTimeLevel);
                                        drDesk.addWaitingGroupTimeLevel2Stats(-1, -1, maxWaitingGroupTimeLevel);

                                        getStatsForListOfValuesByDistributionLevel(deskResultStruct.WaitingTimesGroup, distributionLevel3,
                                            out minWaitingGroupTimeLevel, out avgWaitingGroupTimeLevel, out maxWaitingGroupTimeLevel);

                                        // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                        //drDesk.addWaitingGroupTimeLevel3Stats(minWaitingGroupTimeLevel, avgWaitingGroupTimeLevel, maxWaitingGroupTimeLevel);
                                        drDesk.addWaitingGroupTimeLevel3Stats(-1, -1, maxWaitingGroupTimeLevel);
                                    }

                                    if (deskResultStruct.ProcessTimes != null)
                                    {
                                        // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes                                        
                                        //min, avg, max process times
                                        double minProcessTimeLevel = -1;
                                        double maxProcessTimeLevel = -1;
                                        double avgProcessTimeLevel = -1;

                                        getStatsForListOfValuesByDistributionLevel(deskResultStruct.ProcessTimes, distributionLevel1,
                                            out minProcessTimeLevel, out avgProcessTimeLevel, out maxProcessTimeLevel);

                                        // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                        //drDesk.addProcessTimeLevel1Stats(minProcessTimeLevel, avgProcessTimeLevel, maxProcessTimeLevel);
                                        drDesk.addProcessTimeLevel1Stats(-1, -1, maxProcessTimeLevel);

                                        getStatsForListOfValuesByDistributionLevel(deskResultStruct.ProcessTimes, distributionLevel2,
                                            out minProcessTimeLevel, out avgProcessTimeLevel, out maxProcessTimeLevel);

                                        // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                        //drDesk.addProcessTimeLevel2Stats(minProcessTimeLevel, avgProcessTimeLevel, maxProcessTimeLevel);
                                        drDesk.addProcessTimeLevel2Stats(-1, -1, maxProcessTimeLevel);

                                        getStatsForListOfValuesByDistributionLevel(deskResultStruct.ProcessTimes, distributionLevel3,
                                            out minProcessTimeLevel, out avgProcessTimeLevel, out maxProcessTimeLevel);

                                        // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                        //drDesk.addProcessTimeLevel3Stats(minProcessTimeLevel, avgProcessTimeLevel, maxProcessTimeLevel);
                                        drDesk.addProcessTimeLevel3Stats(-1, -1, maxProcessTimeLevel);

                                    }

                                    List<double> remainingTimesList = new List<double>();
                                    if (htRemainingTime_.ContainsKey(sDesk))
                                    {
                                        ArrayList remainingTimesArrayList = (ArrayList)htRemainingTime_[sDesk];

                                        if (DataFunctions.fromArrayListToListOfDouble(remainingTimesArrayList, out remainingTimesList)
                                            && remainingTimesList != null)
                                        {
                                            double minRemainingTimeLevel = -1;
                                            double maxRemainingTimeLevel = -1;
                                            double avgRemainingTimeLevel = -1;

                                            getStatsForListOfValuesByDistributionLevel(remainingTimesList, distributionLevel1,
                                                out minRemainingTimeLevel, out avgRemainingTimeLevel, out maxRemainingTimeLevel, true);
                                            // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                            //drDesk.addRemainingTimeLevel1Stats(minRemainingTimeLevel, avgRemainingTimeLevel, maxRemainingTimeLevel);
                                            drDesk.addRemainingTimeLevel1Stats(-1, -1, maxRemainingTimeLevel);

                                            getStatsForListOfValuesByDistributionLevel(remainingTimesList, distributionLevel2,
                                                out minRemainingTimeLevel, out avgRemainingTimeLevel, out maxRemainingTimeLevel, true);
                                            // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                            //drDesk.addRemainingTimeLevel2Stats(minRemainingTimeLevel, avgRemainingTimeLevel, maxRemainingTimeLevel);
                                            drDesk.addRemainingTimeLevel2Stats(-1, -1, maxRemainingTimeLevel);

                                            getStatsForListOfValuesByDistributionLevel(remainingTimesList, distributionLevel3,
                                                out minRemainingTimeLevel, out avgRemainingTimeLevel, out maxRemainingTimeLevel, true);
                                            // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                            //drDesk.addRemainingTimeLevel3Stats(minRemainingTimeLevel, avgRemainingTimeLevel, maxRemainingTimeLevel);
                                            drDesk.addRemainingTimeLevel3Stats(-1, -1, maxRemainingTimeLevel);
                                        }
                                    }
                                    //add the total values
                                    drDesk.totalProcessTime = deskResultStruct.totalProcessTime;
                                    drDesk.totalWaitingDeskTime = deskResultStruct.totalWaitingDeskTime;
                                    drDesk.totalWaitingGroupTime = deskResultStruct.totalWaitingGroupTime;
                                    drDesk.totalWaitingDeskAndGroupTime = deskResultStruct.totalWaitingDeskAndGroupTime;
                                    //drDesk.totalOccupation = deskResultStruct.totalOccupation;    // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                    drDesk.totalDelayTime = deskResultStruct.totalDelayTime;
                                }
                                // << Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                            }
                            tableOccupation = getDeskStatistics(sGroup);
                            //tableOccupation = getGroupStatistics(sGroup, AirportRoot);
                            if (tableOccupation == null)
                                continue;
                            tableOccupation.TableName = sGroup + "_Occupation";
                            TablesOccupation_.Add(tableOccupation.TableName, tableOccupation);

                            // >> Task #10441 Pax analysis - Summary - QueueOccupation for Groups
                            Double[] stats = OverallTools.DataFunctions.GetStatColumn(tableOccupation,
                                                                                            "Min Occupation");
                            Double[] stats2 = OverallTools.DataFunctions.GetStatColumn(tableOccupation,
                                                                                         "Average Occupation");
                            Double[] stats3 = OverallTools.DataFunctions.GetStatColumn(tableOccupation,
                                                                                         "Max Occupation");
                            if ((stats != null) && (stats2 != null) && (stats3 != null))
                            {
                                drGroup.AddQueueOccupation(stats[0], stats3[1], stats2[2]);
                            }
                            // << Task #10441 Pax analysis - Summary - QueueOccupation for Groups

                            // >> Task #10440 Pax2Sim - Pax analysis - missing KPIs part 1
                            Double[] groupThroughputInputStats = OverallTools.DataFunctions
                                            .GetStatColumn(tableOccupation, GlobalNames.OCCUPATION_TABLE_THROUGHPUT_IN_COLUMN_NAME);
                            Double[] groupThroughputOutputStats = OverallTools.DataFunctions
                                            .GetStatColumn(tableOccupation, GlobalNames.OCCUPATION_TABLE_THROUGHPUT_OUT_COLUMN_NAME);
                            if (groupThroughputInputStats != null && groupThroughputOutputStats != null)
                            {
                                double minThroughputIn = groupThroughputInputStats[0];
                                double maxThroughputIn = groupThroughputInputStats[1];
                                double avgThroughputIn = groupThroughputInputStats[2];

                                drGroup.addOccupationThroughputInStats(minThroughputIn,
                                                avgThroughputIn, maxThroughputIn);

                                double minThroughputOut = groupThroughputOutputStats[0];
                                double maxThroughputOut = groupThroughputOutputStats[1];
                                double avgThroughputOut = groupThroughputOutputStats[2];

                                drGroup.addOccupationThroughputOutStats(minThroughputOut,
                                                avgThroughputOut, maxThroughputOut);
                            }
                            // << Task #10440 Pax2Sim - Pax analysis - missing KPIs part 1

                            // >> Task #13762 Pax2Sim - Dynamic Analysis - Occupation table
                            Double[] groupThroughputInstantInputStats = OverallTools.DataFunctions
                                            .GetStatColumn(tableOccupation, GlobalNames.OCCUPATION_TABLE_THROUGHPUT_INSTANT_IN_COLUMN_NAME);
                            Double[] groupThroughputInstantOutputStats = OverallTools.DataFunctions
                                            .GetStatColumn(tableOccupation, GlobalNames.OCCUPATION_TABLE_THROUGHPUT_INSTANT_OUT_COLUMN_NAME);
                            if (groupThroughputInstantInputStats != null && groupThroughputInstantOutputStats != null)
                            {
                                double minThroughputIn = groupThroughputInstantInputStats[0];
                                double maxThroughputIn = groupThroughputInstantInputStats[1];
                                double avgThroughputIn = groupThroughputInstantInputStats[2];

                                drGroup.addOccupationThroughputInstantInStats(minThroughputIn,
                                                avgThroughputIn, maxThroughputIn);

                                double minThroughputOut = groupThroughputInstantOutputStats[0];
                                double maxThroughputOut = groupThroughputInstantOutputStats[1];
                                double avgThroughputOut = groupThroughputInstantOutputStats[2];

                                drGroup.addOccupationThroughputInstantOutStats(minThroughputOut,
                                                avgThroughputOut, maxThroughputOut);
                            }
                            // << Task #13762 Pax2Sim - Dynamic Analysis - Occupation table

                            // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                            if (tableOccupation != null && tableOccupation.Columns.IndexOf(GlobalNames.OCCUPATION_TABLE_PAX_IN_COLUMN_NAME) != -1
                                   && tableOccupation.Columns.IndexOf(GlobalNames.OCCUPATION_TABLE_PAX_OUT_COLUMN_NAME) != -1)
                            {
                                double totalPaxIn = -1;
                                double minPaxIn = -1;
                                double maxPaxIn = -1;
                                double avgPaxIn = -1;

                                double totalPaxOut = -1;
                                double minPaxOut = -1;
                                double maxPaxOut = -1;
                                double avgPaxOut = -1;

                                Double[] groupOccupationPaxInStats
                                    = DataFunctions.GetStatColumn(tableOccupation, GlobalNames.OCCUPATION_TABLE_PAX_IN_COLUMN_NAME);
                                Double[] groupOccupationPaxOutStats
                                    = DataFunctions.GetStatColumn(tableOccupation, GlobalNames.OCCUPATION_TABLE_PAX_OUT_COLUMN_NAME);

                                if (groupOccupationPaxInStats != null && groupOccupationPaxOutStats != null
                                    && groupOccupationPaxInStats.Length >= 3 && groupOccupationPaxOutStats.Length >= 3)
                                {
                                    minPaxIn = groupOccupationPaxInStats[0];
                                    maxPaxIn = groupOccupationPaxInStats[1];
                                    avgPaxIn = groupOccupationPaxInStats[2];

                                    minPaxOut = groupOccupationPaxOutStats[0];
                                    maxPaxOut = groupOccupationPaxOutStats[1];
                                    avgPaxOut = groupOccupationPaxOutStats[2];
                                }

                                totalPaxIn = DataFunctions.SumColumn(tableOccupation, GlobalNames.OCCUPATION_TABLE_PAX_IN_COLUMN_NAME);
                                totalPaxOut = DataFunctions.SumColumn(tableOccupation, GlobalNames.OCCUPATION_TABLE_PAX_OUT_COLUMN_NAME);

                                if (totalPaxIn != -1 && minPaxIn != -1 && avgPaxIn != -1 && maxPaxIn != -1)
                                {
                                    drGroup.addOccupationPaxInStats(totalPaxIn, minPaxIn, avgPaxIn, maxPaxIn);
                                }

                                if (totalPaxOut != -1 && minPaxOut != -1 && avgPaxOut != -1 && maxPaxOut != -1)
                                {
                                    drGroup.addOccupationPaxOutStats(totalPaxOut, minPaxOut, avgPaxOut, maxPaxOut);
                                }
                            }
                            // << Task #10615 Pax2Sim - Pax analysis - Summary - small changes

                            CompileUtilisation(GroupUtilization);
                            TablesUtilization_.Add(GroupUtilization.TableName, GroupUtilization);

                            // >> Task #13243 Pax2Sim - Dynamic simulation - Desk Plan Information
                            if (GroupUtilization != null)
                            {
                                DataTable deskPlanInformationTable = GroupUtilization.Copy();
                                deskPlanInformationTable.TableName = sGroup + VinciTools.DESK_PLAN_INFORMATION_TABLE_NAME_SUFFIX;
                                if (deskPlanInformationTable != null
                                    && !_deskPlanInformationTables.ContainsKey(deskPlanInformationTable.TableName))
                                {
                                    _deskPlanInformationTables.Add(deskPlanInformationTable.TableName, deskPlanInformationTable);
                                }
                            }
                            // << Task #13243 Pax2Sim - Dynamic simulation - Desk Plan Information


                            // >> Task #10440 Pax2Sim - Pax analysis - missing KPIs part 1
                            Double[] groupUtilizationPercentStats = OverallTools.DataFunctions
                                            .GetStatColumn(GroupUtilization, GlobalNames.GROUP_UTILIZATION_AVERAGE_COLUMN_NAME);
                            if (groupUtilizationPercentStats != null)
                            {
                                double minUtiliaztionPercent = groupUtilizationPercentStats[0];
                                double maxUtiliaztionPercent = groupUtilizationPercentStats[1];
                                double avgUtiliaztionPercent = groupUtilizationPercentStats[2];

                                drGroup.addUtilizationPercentStats(minUtiliaztionPercent,
                                                avgUtiliaztionPercent, maxUtiliaztionPercent);
                            }

                            Double[] groupDeskNeedStats = OverallTools.DataFunctions
                                            .GetStatColumn(GroupUtilization, GlobalNames.GROUP_UTILIZATION_DESK_NEED_COLUMN_NAME);
                            if (groupDeskNeedStats != null)
                            {
                                double minDeskNeedPercent = groupDeskNeedStats[0];
                                double maxDeskNeedPercent = groupDeskNeedStats[1];
                                double avgDeskNeedPercent = groupDeskNeedStats[2];

                                drGroup.addDeskNeedStats(minDeskNeedPercent,
                                                avgDeskNeedPercent, maxDeskNeedPercent);
                            }
                            // << Task #10440 Pax2Sim - Pax analysis - missing KPIs part 1

                            ResultFunctions.GenerateRepartition(GroupRemaining, 1, "%_Nb Pax", "%Cumul_Nb Pax");
                            //TablesRemainingTimes_[GroupRemaining.TableName]
                            TablesRemainingTimes_.Add(GroupRemaining.TableName, GroupRemaining);
                            if ((dtGroupIST == null) && (DeskResults.ContainsKey(sGroup)))
                            {
                                // >> Task #10156 Pax2Sim - Statistic dev - Target
                                ArrayList alRemainingTimes = new ArrayList();
                                if (htRemainingTime_.ContainsKey(sGroup))
                                    alRemainingTimes = (ArrayList)htRemainingTime_[sGroup];
                                // << Task #10156 Pax2Sim - Statistic dev - Target

                                dtGroupIST =
                                    ((DeskGroupResultsStruct)DeskResults[sGroup]).calcPaxInDeskTime(dtBeginTime_, alRemainingTimes);   // >> Task #10156 Pax2Sim - Statistic dev - Target
                            }
                            if (dtGroupIST != null)
                            {
                                dtGroupIST.AcceptChanges();
                                dsdTable.Add(dtGroupIST.TableName, dtGroupIST);

                                // >> Task #10440 Pax2Sim - Pax analysis - missing KPIs part 1
                                Double[] groupRemainingTimeStats = OverallTools.DataFunctions
                                            .GetStatColumn(dtGroupIST, GlobalNames.IST_REMAINING_TIME_COLUMN_NAME);

                                if (groupRemainingTimeStats != null)
                                {
                                    double minRemainingTime = groupRemainingTimeStats[0];
                                    double maxRemainingTime = groupRemainingTimeStats[1];
                                    double avgRemainingTime = groupRemainingTimeStats[2];

                                    drGroup.addRemainingTimeStats(minRemainingTime,
                                                    avgRemainingTime, maxRemainingTime);
                                }
                                // << Task #10440 Pax2Sim - Pax analysis - missing KPIs part 1
                            }
                            ResultFunctions.GenerateRepartition(GroupTime, 1, "%_" + GroupTime.Columns[1].ColumnName,
                                                                "%Cumul" + GroupTime.Columns[1].ColumnName);
                            ResultFunctions.GenerateRepartition(GroupTime, 2, "%_" + GroupTime.Columns[2].ColumnName,
                                                                "%Cumul" + GroupTime.Columns[2].ColumnName);
                            ResultFunctions.GenerateRepartition(GroupTime, 3, "%_" + GroupTime.Columns[3].ColumnName,
                                                                "%Cumul" + GroupTime.Columns[3].ColumnName);
                            ResultFunctions.GenerateRepartition(GroupTime, 4, "%_" + GroupTime.Columns[4].ColumnName,
                                                                "%Cumul" + GroupTime.Columns[4].ColumnName);
                            TablesTime_.Add(GroupTime.TableName, GroupTime);

                            // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                            if (drGroup != null && dtGroupIST != null)
                            {
                                drGroup.totalRemainingTime = DataFunctions.SumColumn(dtGroupIST, GlobalNames.IST_REMAINING_TIME_COLUMN_NAME);
                            }
                            // << Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent

                            // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                            DeskGroupResultsStruct groupResultStruct = (DeskGroupResultsStruct)DeskResults[sGroup];

                            if (allocationTableFromChildDesk != null)
                            {
                                if (groupHasAllocationTable(sGroup))
                                {
                                    double groupOpeningTime = AnalyseGroupOpeningTime(allocationTableFromChildDesk, dtBeginTime_, dtEndTime_);
                                    if (groupOpeningTime >= 0)
                                        drGroup.TotalOpeningTime = groupOpeningTime;
                                }
                                else if (groupHasPlanningTable(sGroup))
                                {
                                    int columnIndex = allocationTableFromChildDesk.Columns.IndexOf(sGroup);
                                    drGroup.TotalOpeningTime = AnalyseGroupOpeningTimeUsingPlanningTable(allocationTableFromChildDesk,
                                                                                    dtBeginTime_, dtEndTime_, columnIndex);
                                }

                                if (drGroup.TotalOpeningTime == 0)
                                    drGroup.Rate = 0;
                                else
                                    drGroup.Rate = drGroup.TotalProcessTime / drGroup.TotalOpeningTime;
                            }

                            if (groupResultStruct != null)
                            {
                                double distributionLevel1 = percentiles[0];
                                double distributionLevel2 = percentiles[1];
                                double distributionLevel3 = percentiles[2];

                                if (groupResultStruct.DelayTimes != null)
                                {
                                    double minDelayTimeLevel = -1;
                                    double maxDelayTimeLevel = -1;
                                    double avgDelayTimeLevel = -1;

                                    getStatsForListOfValuesByDistributionLevel(groupResultStruct.DelayTimes, distributionLevel1,
                                        out minDelayTimeLevel, out avgDelayTimeLevel, out maxDelayTimeLevel);
                                    // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                    //drGroup.addDelayTimeLevel1Stats(minDelayTimeLevel, avgDelayTimeLevel, maxDelayTimeLevel);
                                    drGroup.addDelayTimeLevel1Stats(-1, -1, maxDelayTimeLevel);

                                    getStatsForListOfValuesByDistributionLevel(groupResultStruct.DelayTimes, distributionLevel2,
                                        out minDelayTimeLevel, out avgDelayTimeLevel, out maxDelayTimeLevel);
                                    // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                    //drGroup.addDelayTimeLevel2Stats(minDelayTimeLevel, avgDelayTimeLevel, maxDelayTimeLevel);
                                    drGroup.addDelayTimeLevel2Stats(-1, -1, maxDelayTimeLevel);

                                    getStatsForListOfValuesByDistributionLevel(groupResultStruct.DelayTimes, distributionLevel3,
                                        out minDelayTimeLevel, out avgDelayTimeLevel, out maxDelayTimeLevel);
                                    // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                    //drGroup.addDelayTimeLevel3Stats(minDelayTimeLevel, avgDelayTimeLevel, maxDelayTimeLevel);
                                    drGroup.addDelayTimeLevel3Stats(-1, -1, maxDelayTimeLevel);
                                }

                                if (dtGroupIST != null)
                                {
                                    List<double> waitingTimesList = new List<double>();
                                    List<String> waitingColumnNames
                                        = new List<string>() { GlobalNames.IST_WAITING_DESK_TIME_COLUMN_NAME, GlobalNames.IST_WAITING_GROUP_TIME_COLUMN_NAME };
                                    if (DataFunctions.getSumOfTableColumnsAsListOfDouble(dtGroupIST, waitingColumnNames, out waitingTimesList)
                                        && waitingTimesList != null)
                                    {
                                        double minWaitingTimeLevel = -1;
                                        double avgWaitingTimeLevel = -1;
                                        double maxWaitingTimeLevel = -1;

                                        getStatsForListOfValuesByDistributionLevel(waitingTimesList, distributionLevel1,
                                            out minWaitingTimeLevel, out avgWaitingTimeLevel, out maxWaitingTimeLevel);
                                        // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                        //drGroup.addWaitingTimeLevel1Stats(minWaitingTimeLevel, avgWaitingTimeLevel, maxWaitingTimeLevel);
                                        drGroup.addWaitingTimeLevel1Stats(-1, -1, maxWaitingTimeLevel);

                                        getStatsForListOfValuesByDistributionLevel(waitingTimesList, distributionLevel2,
                                            out minWaitingTimeLevel, out avgWaitingTimeLevel, out maxWaitingTimeLevel);
                                        // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                        //drGroup.addWaitingTimeLevel2Stats(minWaitingTimeLevel, avgWaitingTimeLevel, maxWaitingTimeLevel);
                                        drGroup.addWaitingTimeLevel2Stats(-1, -1, maxWaitingTimeLevel);

                                        getStatsForListOfValuesByDistributionLevel(waitingTimesList, distributionLevel3,
                                            out minWaitingTimeLevel, out avgWaitingTimeLevel, out maxWaitingTimeLevel);
                                        // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                        //drGroup.addWaitingTimeLevel3Stats(minWaitingTimeLevel, avgWaitingTimeLevel, maxWaitingTimeLevel);
                                        drGroup.addWaitingTimeLevel3Stats(-1, -1, maxWaitingTimeLevel);
                                    }
                                }

                                if (groupResultStruct.WaitingTimesDesk != null)
                                {
                                    double minWaitingDeskTimeLevel = -1;
                                    double maxWaitingDeskTimeLevel = -1;
                                    double avgWaitingDeskTimeLevel = -1;

                                    getStatsForListOfValuesByDistributionLevel(groupResultStruct.WaitingTimesDesk, distributionLevel1,
                                        out minWaitingDeskTimeLevel, out avgWaitingDeskTimeLevel, out maxWaitingDeskTimeLevel);
                                    // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                    //drGroup.addWaitingDeskTimeLevel1Stats(minWaitingDeskTimeLevel, avgWaitingDeskTimeLevel, maxWaitingDeskTimeLevel);
                                    drGroup.addWaitingDeskTimeLevel1Stats(-1, -1, maxWaitingDeskTimeLevel);

                                    getStatsForListOfValuesByDistributionLevel(groupResultStruct.WaitingTimesDesk, distributionLevel2,
                                        out minWaitingDeskTimeLevel, out avgWaitingDeskTimeLevel, out maxWaitingDeskTimeLevel);
                                    // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                    //drGroup.addWaitingDeskTimeLevel2Stats(minWaitingDeskTimeLevel, avgWaitingDeskTimeLevel, maxWaitingDeskTimeLevel);
                                    drGroup.addWaitingDeskTimeLevel2Stats(-1, -1, maxWaitingDeskTimeLevel);

                                    getStatsForListOfValuesByDistributionLevel(groupResultStruct.WaitingTimesDesk, distributionLevel3,
                                        out minWaitingDeskTimeLevel, out avgWaitingDeskTimeLevel, out maxWaitingDeskTimeLevel);
                                    // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                    //drGroup.addWaitingDeskTimeLevel3Stats(minWaitingDeskTimeLevel, avgWaitingDeskTimeLevel, maxWaitingDeskTimeLevel);
                                    drGroup.addWaitingDeskTimeLevel3Stats(-1, -1, maxWaitingDeskTimeLevel);
                                }

                                if (groupResultStruct.WaitingTimesGroup != null)
                                {
                                    double minWaitingGroupTimeLevel = -1;
                                    double maxWaitingGroupTimeLevel = -1;
                                    double avgWaitingGroupTimeLevel = -1;

                                    getStatsForListOfValuesByDistributionLevel(groupResultStruct.WaitingTimesGroup, distributionLevel1,
                                        out minWaitingGroupTimeLevel, out avgWaitingGroupTimeLevel, out maxWaitingGroupTimeLevel);
                                    // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                    //drGroup.addWaitingGroupTimeLevel1Stats(minWaitingGroupTimeLevel, avgWaitingGroupTimeLevel, maxWaitingGroupTimeLevel);
                                    drGroup.addWaitingGroupTimeLevel1Stats(-1, -1, maxWaitingGroupTimeLevel);

                                    getStatsForListOfValuesByDistributionLevel(groupResultStruct.WaitingTimesGroup, distributionLevel2,
                                        out minWaitingGroupTimeLevel, out avgWaitingGroupTimeLevel, out maxWaitingGroupTimeLevel);
                                    // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                    //drGroup.addWaitingGroupTimeLevel2Stats(minWaitingGroupTimeLevel, avgWaitingGroupTimeLevel, maxWaitingGroupTimeLevel);
                                    drGroup.addWaitingGroupTimeLevel2Stats(-1, -1, maxWaitingGroupTimeLevel);

                                    getStatsForListOfValuesByDistributionLevel(groupResultStruct.WaitingTimesGroup, distributionLevel3,
                                        out minWaitingGroupTimeLevel, out avgWaitingGroupTimeLevel, out maxWaitingGroupTimeLevel);
                                    // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                    //drGroup.addWaitingGroupTimeLevel3Stats(minWaitingGroupTimeLevel, avgWaitingGroupTimeLevel, maxWaitingGroupTimeLevel);
                                    drGroup.addWaitingGroupTimeLevel3Stats(-1, -1, maxWaitingGroupTimeLevel);
                                }

                                if (groupResultStruct.ProcessTimes != null)
                                {
                                    // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                    /*
                                    //number of processed pax
                                    int nbOfProcessedPax = -1;
                                    getNbOfProcessedPaxByDistributionLevel(groupResultStruct.ProcessTimes, distributionLevel1,
                                        out nbOfProcessedPax);
                                    if (nbOfProcessedPax != -1)
                                        drGroup.numberOfProcessedPaxLevel1Value = nbOfProcessedPax;

                                    getNbOfProcessedPaxByDistributionLevel(groupResultStruct.ProcessTimes, distributionLevel2,
                                        out nbOfProcessedPax);
                                    if (nbOfProcessedPax != -1)
                                        drGroup.numberOfProcessedPaxLevel2Value = nbOfProcessedPax;

                                    getNbOfProcessedPaxByDistributionLevel(groupResultStruct.ProcessTimes, distributionLevel3,
                                        out nbOfProcessedPax);
                                    if (nbOfProcessedPax != -1)
                                        drGroup.numberOfProcessedPaxLevel3Value = nbOfProcessedPax;
                                    */
                                    //min, avg, max process times
                                    double minProcessTimeLevel = -1;
                                    double maxProcessTimeLevel = -1;
                                    double avgProcessTimeLevel = -1;

                                    getStatsForListOfValuesByDistributionLevel(groupResultStruct.ProcessTimes, distributionLevel1,
                                        out minProcessTimeLevel, out avgProcessTimeLevel, out maxProcessTimeLevel);
                                    // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                    //drGroup.addProcessTimeLevel1Stats(minProcessTimeLevel, avgProcessTimeLevel, maxProcessTimeLevel);
                                    drGroup.addProcessTimeLevel1Stats(-1, -1, maxProcessTimeLevel);

                                    getStatsForListOfValuesByDistributionLevel(groupResultStruct.ProcessTimes, distributionLevel2,
                                        out minProcessTimeLevel, out avgProcessTimeLevel, out maxProcessTimeLevel);
                                    // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                    //drGroup.addProcessTimeLevel2Stats(minProcessTimeLevel, avgProcessTimeLevel, maxProcessTimeLevel);
                                    drGroup.addProcessTimeLevel2Stats(-1, -1, maxProcessTimeLevel);

                                    getStatsForListOfValuesByDistributionLevel(groupResultStruct.ProcessTimes, distributionLevel3,
                                        out minProcessTimeLevel, out avgProcessTimeLevel, out maxProcessTimeLevel);
                                    // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                    //drGroup.addProcessTimeLevel3Stats(minProcessTimeLevel, avgProcessTimeLevel, maxProcessTimeLevel);
                                    drGroup.addProcessTimeLevel3Stats(-1, -1, maxProcessTimeLevel);

                                    /* // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                    //total process time
                                    double totalProcessTimeLevelValue 
                                        = getSumOfListValuesByDistributionLevel(groupResultStruct.ProcessTimes, distributionLevel1);
                                    
                                    if (totalProcessTimeLevelValue != -1)
                                        drGroup.totalProcessTimeLevel1Value = totalProcessTimeLevelValue;
                                    
                                    totalProcessTimeLevelValue 
                                        = getSumOfListValuesByDistributionLevel(groupResultStruct.ProcessTimes, distributionLevel2);
                                    
                                    if (totalProcessTimeLevelValue != -1)
                                        drGroup.totalProcessTimeLevel2Value = totalProcessTimeLevelValue;
                                    
                                    totalProcessTimeLevelValue 
                                        = getSumOfListValuesByDistributionLevel(groupResultStruct.ProcessTimes, distributionLevel3);
                                    
                                    if (totalProcessTimeLevelValue != -1)
                                        drGroup.totalProcessTimeLevel3Value = totalProcessTimeLevelValue;
                                     */
                                }

                                if (dtGroupIST != null)
                                {
                                    List<double> groupRemainingTimesList = new List<double>();
                                    if (DataFunctions.fromTableColumnToListOfDouble(dtGroupIST, GlobalNames.IST_REMAINING_TIME_COLUMN_NAME
                                                                                    , out groupRemainingTimesList)
                                        && groupRemainingTimesList != null)
                                    {
                                        double minRemainingTimeLevel = -1;
                                        double maxRemainingTimeLevel = -1;
                                        double avgRemainingTimeLevel = -1;

                                        getStatsForListOfValuesByDistributionLevel(groupRemainingTimesList, distributionLevel1,
                                            out minRemainingTimeLevel, out avgRemainingTimeLevel, out maxRemainingTimeLevel, true);
                                        // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                        //drGroup.addRemainingTimeLevel1Stats(minRemainingTimeLevel, avgRemainingTimeLevel, maxRemainingTimeLevel);
                                        drGroup.addRemainingTimeLevel1Stats(-1, -1, maxRemainingTimeLevel);

                                        getStatsForListOfValuesByDistributionLevel(groupRemainingTimesList, distributionLevel2,
                                            out minRemainingTimeLevel, out avgRemainingTimeLevel, out maxRemainingTimeLevel, true);
                                        // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                        //drGroup.addRemainingTimeLevel2Stats(minRemainingTimeLevel, avgRemainingTimeLevel, maxRemainingTimeLevel);
                                        drGroup.addRemainingTimeLevel2Stats(-1, -1, maxRemainingTimeLevel);

                                        getStatsForListOfValuesByDistributionLevel(groupRemainingTimesList, distributionLevel3,
                                            out minRemainingTimeLevel, out avgRemainingTimeLevel, out maxRemainingTimeLevel, true);
                                        // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                        //drGroup.addRemainingTimeLevel3Stats(minRemainingTimeLevel, avgRemainingTimeLevel, maxRemainingTimeLevel);
                                        drGroup.addRemainingTimeLevel3Stats(-1, -1, maxRemainingTimeLevel);
                                    }

                                    #region total time from IST (Group)
                                    if (dtGroupIST.Columns.IndexOf(GlobalNames.IST_TOTAL_TIME_COLUMN_NAME) != -1)
                                    {
                                        drGroup.totalTimeForAllPaxInStation = DataFunctions.SumColumn(dtGroupIST, GlobalNames.IST_TOTAL_TIME_COLUMN_NAME);

                                        Double[] groupTotalTimeStats = OverallTools.DataFunctions
                                            .GetStatColumn(dtGroupIST, GlobalNames.IST_TOTAL_TIME_COLUMN_NAME);

                                        if (groupTotalTimeStats != null)
                                        {
                                            drGroup.minTotalTime = groupTotalTimeStats[0];
                                            drGroup.maxTotalTime = groupTotalTimeStats[1];
                                            drGroup.avgTotalTime = groupTotalTimeStats[2];
                                        }

                                        List<double> totalTimesList = new List<double>();
                                        if (DataFunctions.fromTableColumnToListOfDouble(dtGroupIST, GlobalNames.IST_TOTAL_TIME_COLUMN_NAME
                                                                                        , out totalTimesList)
                                            && totalTimesList != null)
                                        {
                                            double min = -1;
                                            double avg = -1;
                                            double maxLevel1 = -1;
                                            double maxLevel2 = -1;
                                            double maxLevel3 = -1;

                                            getStatsForListOfValuesByDistributionLevel(totalTimesList, distributionLevel1,
                                                out min, out avg, out maxLevel1, false);
                                            getStatsForListOfValuesByDistributionLevel(totalTimesList, distributionLevel2,
                                                out min, out avg, out maxLevel2, false);
                                            getStatsForListOfValuesByDistributionLevel(totalTimesList, distributionLevel3,
                                                out min, out avg, out maxLevel3, false);

                                            drGroup.addTotalTimeMaxLevelsStats(maxLevel1, maxLevel2, maxLevel3);
                                        }
                                    }
                                    #endregion
                                }
                                //add the total values
                                drGroup.totalProcessTime = groupResultStruct.totalProcessTime;
                                drGroup.totalWaitingDeskTime = groupResultStruct.totalWaitingDeskTime;
                                drGroup.totalWaitingGroupTime = groupResultStruct.totalWaitingGroupTime;
                                drGroup.totalWaitingDeskAndGroupTime = groupResultStruct.totalWaitingDeskAndGroupTime;
                                //drGroup.totalOccupation = groupResultStruct.totalOccupation;  // >> Task #10615 Pax2Sim - Pax analysis - Summary - small changes
                                drGroup.totalDelayTime = groupResultStruct.totalDelayTime;
                            }
                            // << Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
                        }
                    }
                }
            }

            // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
            public int getNbOfProcessedPaxByDistributionLevel(List<double> timesList, Double distributionLevel,
                out int nbOfPax)
            {
                nbOfPax = 0;
                if (timesList == null)
                    return nbOfPax;

                List<Double> timesTruncatedListLevel
                    = OverallTools.ResultFunctions.getTruncatedListByPercent(timesList, distributionLevel);
                timesTruncatedListLevel.Sort();

                if (timesTruncatedListLevel == null
                    || timesTruncatedListLevel.Count == 0)
                {
                    return nbOfPax;
                }

                for (int i = 0; i < timesTruncatedListLevel.Count; i++)
                {
                    if (FonctionsType.getDouble(timesTruncatedListLevel[i]) >= 0)
                        nbOfPax++;
                }
                return nbOfPax;
            }

            public int getNbOfTransferPaxByDistributionLevel(List<PaxTraceAnalysis.PaxResultsStruct> paxList,
                Double distributionLevel, String deskName)
            {
                int nbTransferPax = 0;
                if (paxList == null)
                    return nbTransferPax;

                List<PaxTraceAnalysis.PaxResultsStruct> paxTruncatedListLevel
                    = OverallTools.ResultFunctions.getTruncatedListByPercent(paxList, distributionLevel, deskName);

                if (paxTruncatedListLevel == null
                    || paxTruncatedListLevel.Count == 0)
                {
                    return nbTransferPax;
                }

                for (int i = 0; i < paxTruncatedListLevel.Count; i++)
                {
                    if (paxTruncatedListLevel[i].isTransferred)
                        nbTransferPax++;
                }
                return nbTransferPax;
            }

            public int getNbOfMissedPaxByDistributionLevel(List<PaxTraceAnalysis.PaxResultsStruct> paxList,
                Double distributionLevel, String deskName)
            {
                int nbMissedPax = 0;
                if (paxList == null)
                    return nbMissedPax;

                List<PaxTraceAnalysis.PaxResultsStruct> paxTruncatedListLevel
                    = OverallTools.ResultFunctions.getTruncatedListByPercent(paxList, distributionLevel, deskName);

                if (paxTruncatedListLevel == null
                    || paxTruncatedListLevel.Count == 0)
                {
                    return nbMissedPax;
                }

                for (int i = 0; i < paxTruncatedListLevel.Count; i++)
                {
                    if (paxTruncatedListLevel[i].HadMissed
                        && paxTruncatedListLevel[i].getStatusGroup(deskName) != "")
                        nbMissedPax++;
                }
                return nbMissedPax;
            }

            public int getNbOfStoppedPaxByDistributionLevel(List<PaxTraceAnalysis.PaxResultsStruct> paxList,
                Double distributionLevel, String deskName)
            {
                int nbStoppedPax = 0;
                if (paxList == null)
                    return nbStoppedPax;

                List<PaxTraceAnalysis.PaxResultsStruct> paxTruncatedListLevel
                    = OverallTools.ResultFunctions.getTruncatedListByPercent(paxList, distributionLevel, deskName);

                if (paxTruncatedListLevel == null
                    || paxTruncatedListLevel.Count == 0)
                {
                    return nbStoppedPax;
                }

                for (int i = 0; i < paxTruncatedListLevel.Count; i++)
                {
                    if (paxTruncatedListLevel[i].Stopped
                        && paxTruncatedListLevel[i].getStatusGroup(deskName) != "")
                    {
                        nbStoppedPax++;
                    }
                }
                return nbStoppedPax;
            }

            public int getNbOfLostPaxByDistributionLevel(List<PaxTraceAnalysis.PaxResultsStruct> paxList,
                Double distributionLevel, String deskName)
            {
                int nbLostPax = 0;
                if (paxList == null)
                    return nbLostPax;

                List<PaxTraceAnalysis.PaxResultsStruct> paxTruncatedListLevel
                    = OverallTools.ResultFunctions.getTruncatedListByPercent(paxList, distributionLevel, deskName);

                if (paxTruncatedListLevel == null
                    || paxTruncatedListLevel.Count == 0)
                {
                    return nbLostPax;
                }

                for (int i = 0; i < paxTruncatedListLevel.Count; i++)
                {
                    if (paxTruncatedListLevel[i].Lost
                        && paxTruncatedListLevel[i].getStatusGroup(deskName) != "")
                    {
                        nbLostPax++;
                    }
                }
                return nbLostPax;
            }

            public void getStatsForListOfValuesByDistributionLevel(List<Double> valuesList, Double distributionLevel,
                out Double minTimeLevel, out Double avgTimeLevel, out Double maxTimeLevel)
            {
                List<Double> timesTruncatedListLevel = OverallTools.ResultFunctions.getTruncatedListByPercent(valuesList, distributionLevel);
                timesTruncatedListLevel.Sort();

                if (timesTruncatedListLevel == null
                    || timesTruncatedListLevel.Count == 0)
                {
                    minTimeLevel = 0;
                    avgTimeLevel = 0;
                    maxTimeLevel = 0;

                    return;
                }

                minTimeLevel = timesTruncatedListLevel[0];
                maxTimeLevel = timesTruncatedListLevel[timesTruncatedListLevel.Count - 1];

                double sum = 0;
                for (int i = 0; i < timesTruncatedListLevel.Count; i++)
                {
                    sum += (double)timesTruncatedListLevel[i];
                }
                avgTimeLevel = 0;
                if (timesTruncatedListLevel.Count > 0)
                    avgTimeLevel = sum / timesTruncatedListLevel.Count;
            }

            /// <summary>
            /// For the remaining times it is considered a good case the one when 
            /// the pax has a high value for the remaining time until departure. 
            /// This can be specified using the highValuesAreGoodCases parameter. 
            /// In general low values are preferable.
            /// </summary>
            /// <param name="valuesList"></param>
            /// <param name="distributionLevel"></param>
            /// <param name="minTimeLevel"></param>
            /// <param name="avgTimeLevel"></param>
            /// <param name="maxTimeLevel"></param>
            /// <param name="highValuesAreGoodCases"></param>
            public void getStatsForListOfValuesByDistributionLevel(List<Double> valuesList, Double distributionLevel,
                out Double minTimeLevel, out Double avgTimeLevel, out Double maxTimeLevel, bool highValuesAreGoodCases)
            {
                List<Double> timesTruncatedListLevel = new List<Double>();
                if (highValuesAreGoodCases)
                {
                    timesTruncatedListLevel = ResultFunctions.truncateHighestValuesFromListByPercent(valuesList, distributionLevel);
                }
                else
                {
                    timesTruncatedListLevel = ResultFunctions.getTruncatedListByPercent(valuesList, distributionLevel);
                }
                timesTruncatedListLevel.Sort();

                if (timesTruncatedListLevel == null
                    || timesTruncatedListLevel.Count == 0)
                {
                    minTimeLevel = 0;
                    avgTimeLevel = 0;
                    maxTimeLevel = 0;

                    return;
                }

                minTimeLevel = timesTruncatedListLevel[0];
                maxTimeLevel = timesTruncatedListLevel[timesTruncatedListLevel.Count - 1];

                double sum = 0;
                for (int i = 0; i < timesTruncatedListLevel.Count; i++)
                {
                    sum += (double)timesTruncatedListLevel[i];
                }
                avgTimeLevel = 0;
                if (timesTruncatedListLevel.Count > 0)
                    avgTimeLevel = sum / timesTruncatedListLevel.Count;
            }

            public Double getSumOfListValuesByDistributionLevel(List<Double> valuesList, Double distributionLevel)
            {
                Double sum = -1;

                if (valuesList == null)
                    return sum;

                List<double> truncatedValuesList
                    = ResultFunctions.getTruncatedListByPercent(valuesList, distributionLevel);

                if (truncatedValuesList == null)
                    return sum;

                sum = 0;

                for (int i = 0; i < truncatedValuesList.Count; i++)
                {
                    sum += (double)truncatedValuesList[i];
                }

                return sum;
            }

            public bool groupHasPlanningTable(String groupName)
            {
                if (groupName.Contains(GlobalNames.PASSPORT_GROUP_TYPE_IDENTIFIER)
                    || groupName.Contains(GlobalNames.SECURITY_GROUP_TYPE_IDENTIFIER)
                    || groupName.Contains(GlobalNames.TRANSFER_GROUP_TYPE_IDENTIFIER)
                    || groupName.Contains(GlobalNames.USER_PROCESS_GROUP_TYPE_IDENTIFIER))
                {
                    return true;
                }
                return false;
            }

            public bool groupHasAllocationTable(String groupName)
            {
                if (groupName.Contains(GlobalNames.BOARDING_GATE_GROUP_TYPE_IDENTIFIER)
                    || groupName.Contains(GlobalNames.CHECK_IN_GROUP_TYPE_IDENTIFIER)
                    || groupName.Contains(GlobalNames.BAGGAGE_CLAIM_GROUP_TYPE_IDENTIFIER))
                {
                    return true;
                }
                return false;
            }

            public void getDwellAreaStatsByDistributionLevel(String resourceName, Double distributionPercent,
                out double minDwellArea, out double avgDwellArea, out double maxDwellArea)
            {
                DataTable dwellTimeTableByLevel = createDwellTimeTable(resourceName, distributionPercent);
                int minDwellAreacolumnIndex = dwellTimeTableByLevel.Columns.IndexOf(GlobalNames.DWELL_AREA_MIN_COLUMN_NAME);
                int avgDwellAreacolumnIndex = dwellTimeTableByLevel.Columns.IndexOf(GlobalNames.DWELL_AREA_AVG_COLUMN_NAME);
                int maxDwellAreacolumnIndex = dwellTimeTableByLevel.Columns.IndexOf(GlobalNames.DWELL_AREA_MAX_COLUMN_NAME);
                int nbPaxDwellAreaColumnIndex = dwellTimeTableByLevel.Columns.IndexOf(GlobalNames.DWELL_AREA_NB_PAX_COLUMN_NAME);

                minDwellArea = 0;
                avgDwellArea = 0;
                maxDwellArea = 0;

                if (minDwellAreacolumnIndex != -1 && nbPaxDwellAreaColumnIndex != -1)
                {
                    Double[] dwellAreaStats = OverallTools.DataFunctions
                                    .GetStatColumnIgnoreZeros(dwellTimeTableByLevel, minDwellAreacolumnIndex, nbPaxDwellAreaColumnIndex);
                    if (dwellAreaStats != null)
                    {
                        minDwellArea = (double)dwellAreaStats[0];
                    }
                }
                if (avgDwellAreacolumnIndex != -1 && nbPaxDwellAreaColumnIndex != -1)
                {
                    Double[] dwellAreaStats = OverallTools.DataFunctions
                                    .GetStatColumnIgnoreZeros(dwellTimeTableByLevel, avgDwellAreacolumnIndex, nbPaxDwellAreaColumnIndex);
                    if (dwellAreaStats != null)
                    {
                        avgDwellArea = (double)dwellAreaStats[2];
                    }
                }
                if (maxDwellAreacolumnIndex != -1 && nbPaxDwellAreaColumnIndex != -1)
                {
                    Double[] dwellAreaStats = OverallTools.DataFunctions
                                    .GetStatColumnIgnoreZeros(dwellTimeTableByLevel, maxDwellAreacolumnIndex, nbPaxDwellAreaColumnIndex);
                    if (dwellAreaStats != null)
                    {
                        maxDwellArea = (double)dwellAreaStats[1];
                    }
                }
            }

            public void getOccupationStatsByDistributionLevel(DeskGroupResultsStruct deskGroupResultStruct,
                Double distributionLevel,
                out double minOccupation, out double avgOccupation, out double maxOccupation,
                out double minThroughputIn, out double avgThroughputIn, out double maxThroughputIn,
                out double minThroughputOut, out double avgThroughputOut, out double maxThroughputOut)
            {
                minOccupation = 0;
                avgOccupation = 0;
                maxOccupation = 0;

                minThroughputIn = 0;
                avgThroughputIn = 0;
                maxThroughputIn = 0;

                minThroughputOut = 0;
                avgThroughputOut = 0;
                maxThroughputOut = 0;

                DataTable occupationTableByLevel
                    = deskGroupResultStruct
                        .CalcQueueOccupationByDistributionLevel(distributionLevel, dtBeginTime_, dtEndTime_,
                                                                 dPasOccupation, bSlidingHour_, analysisRange);

                int minOccupationColumnIndex = occupationTableByLevel.Columns.IndexOf(GlobalNames.OCCUPATION_TABLE_MIN_OCCUPATION_COLUMN_NAME);
                int avgOccupationColumnIndex = occupationTableByLevel.Columns.IndexOf(GlobalNames.OCCUPATION_TABLE_AVG_OCCUPATION_COLUMN_NAME);
                int maxOccupationColumnIndex = occupationTableByLevel.Columns.IndexOf(GlobalNames.OCCUPATION_TABLE_MAX_OCCUPATION_COLUMN_NAME);
                int throughputInputColumnIndex = occupationTableByLevel.Columns.IndexOf(GlobalNames.OCCUPATION_TABLE_THROUGHPUT_IN_COLUMN_NAME);
                int throughputOutputColumnIndex = occupationTableByLevel.Columns.IndexOf(GlobalNames.OCCUPATION_TABLE_THROUGHPUT_OUT_COLUMN_NAME);

                if (minOccupationColumnIndex != -1)
                {
                    Double[] minOccupationColumnStats = OverallTools.DataFunctions
                                    .GetStatColumn(occupationTableByLevel, minOccupationColumnIndex);
                    if (minOccupationColumnStats != null)
                    {
                        minOccupation = (double)minOccupationColumnStats[0];
                    }
                }
                if (avgOccupationColumnIndex != -1)
                {
                    Double[] avgOccupationColumnStats = OverallTools.DataFunctions
                                    .GetStatColumn(occupationTableByLevel, avgOccupationColumnIndex);
                    if (avgOccupationColumnStats != null)
                    {
                        avgOccupation = (double)avgOccupationColumnStats[2];
                    }
                }
                if (maxOccupationColumnIndex != -1)
                {
                    Double[] maxOccupationColumnStats = OverallTools.DataFunctions
                                    .GetStatColumn(occupationTableByLevel, maxOccupationColumnIndex);
                    if (maxOccupationColumnStats != null)
                    {
                        maxOccupation = (double)maxOccupationColumnStats[1];
                    }
                }
                if (throughputInputColumnIndex != -1)
                {
                    Double[] throughputInColumnStats = OverallTools.DataFunctions
                                    .GetStatColumn(occupationTableByLevel, throughputInputColumnIndex);
                    if (throughputInColumnStats != null)
                    {
                        minThroughputIn = (double)throughputInColumnStats[0];
                        avgThroughputIn = (double)throughputInColumnStats[2];
                        maxThroughputIn = (double)throughputInColumnStats[1];
                    }
                }
                if (throughputOutputColumnIndex != -1)
                {
                    Double[] throughputOutColumnStats = OverallTools.DataFunctions
                                    .GetStatColumn(occupationTableByLevel, throughputOutputColumnIndex);
                    if (throughputOutColumnStats != null)
                    {
                        minThroughputOut = (double)throughputOutColumnStats[0];
                        avgThroughputOut = (double)throughputOutColumnStats[2];
                        maxThroughputOut = (double)throughputOutColumnStats[1];
                    }
                }
            }
            // << Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent

            public void CompileUtilisation(DataTable laTable)
            {
                if (laTable.Rows.Count == 0)
                    return;
                Double Result = 0;
                foreach (DataRow row in laTable.Rows)
                {
                    Result = ((Double)row[2]) / 100.0f;
                    row[2] = Math.Round((Double)row[2], 2);
                    //row[laTable.Columns.Count - 2] = 
                    row[3] = Math.Truncate(Result);
                    if (Result > Math.Truncate(Result))
                        row[3] = Math.Truncate(Result) + 1;
                    row[4] = 0;
                    if ((laTable.Columns.Count - 4) > 0)
                        row[4] = Math.Round((Double)row[2] / (laTable.Columns.Count - 5), 2);
                }
            }
            #endregion

            #region Fonction pour la génération des statistiques des compteurs
            private void AnalyseCounters()
            {
                if ((sBGLocation_ == null) || (sBGLocation_ == ""))
                    return;
                if (!System.IO.File.Exists(sBGLocation_))
                    return;
                DataTable dtBGTable = AutomodFiles.openAutomodGraphic(sBGLocation_, dtBeginTime_, ErrorList_);
                if (dtBGTable == null)
                    return;
                if (dtBGTable.Columns.Count - 1 != (GestionDonneesHUB2SIM.NbTerminaux * GestionDonneesHUB2SIM.NbGroupes * GestionDonneesHUB2SIM.NbTypes))
                    return;
                //                DataTable dtResultsGlobal;
                int iIndexColumn = 1;
                for (int i = 0; i < GestionDonneesHUB2SIM.NbTerminaux; i++)
                {
                    //                    dtResultsGlobal = new DataTable("T" + (i + 1).ToString() + "_Max_Occupation");
                    //                    dtResultsGlobal.Columns.Add("Max % occupation");
                    for (int j = 0; j < GestionDonneesHUB2SIM.NbTypes; j++)
                    {

                        String sGroup = PAX2SIM.ListeNomObjetGroup[j + 2];
                        DataTable dtTmp = new DataTable("T" + (i + 1).ToString() + "_Capacity" + "_" + sGroup);
                        dtTmp.Columns.Add(dtBGTable.Columns[0].ColumnName, dtBGTable.Columns[0].DataType);
                        for (int k = 0; k < GestionDonneesHUB2SIM.NbGroupes; k++)
                        {
                            dtTmp.Columns.Add(sGroup + "_" + (k + 1).ToString(), dtBGTable.Columns[1].DataType);
                        }
                        foreach (DataRow drOldRow in dtBGTable.Rows)
                        {
                            DataRow drNewRow = dtTmp.NewRow();
                            drNewRow[0] = drOldRow[0];
                            for (int l = 0; l < GestionDonneesHUB2SIM.NbGroupes; l++)
                            {
                                drNewRow[l + 1] = drOldRow[iIndexColumn + l];
                            }
                            dtTmp.Rows.Add(drNewRow);
                        }
                        dtTmp.AcceptChanges();
                        iIndexColumn += GestionDonneesHUB2SIM.NbGroupes;
                        if (!htCounterResults.ContainsKey(dtTmp.TableName))
                            htCounterResults.Add(dtTmp.TableName, dtTmp);
                        else
                            htCounterResults[dtTmp.TableName] = dtTmp;
                    }
                }
                //GestionDonneesHUB2SIM.htSizeAutomodModel
            }
            #endregion

            #region Fonction qui se charge de renseigner les créneaux pour lequel le passager était présent.

            public static Double BorneInferieure(Double Nombre)
            {
                return Math.Truncate(Nombre);
            }
            public static Double BorneSuperieure(Double Nombre)
            {
                if (Nombre == Math.Truncate(Nombre))
                    return Math.Truncate(Nombre) - 1;
                return Math.Truncate(Nombre);
            }
            private static int setPaxArrival(DataTable laTable, DateTime dtBeginDate, Int32 iIndexTime, Double iIndexArrivalTime, int iColumnPosition, Double dPas)
            {
                int iIndexRow = (int)(iIndexArrivalTime / dPas);
                if (laTable.Rows.Count <= iIndexRow)
                {
                    for (int i = laTable.Rows.Count; i <= iIndexRow; i++)
                    {
                        DataRow newRow = laTable.NewRow();
                        newRow[iIndexTime] = dtBeginDate.AddMinutes(dPas * i);
                        for (int j = 0; j < newRow.ItemArray.Length; j++)
                        {
                            if (j != iIndexTime)
                                newRow[j] = 0;
                        }
                        laTable.Rows.Add(newRow);
                    }
                }

                laTable.Rows[iIndexRow][iColumnPosition] = ((Int32)laTable.Rows[iIndexRow][iColumnPosition]) + 1;
                return iIndexRow;
            }
            private static void setPax(DataTable laTable,
                                        Int32 iIndexTime,
                                        Double iArrivingPax,
                                        Double iLeavingPax,
                                        Int32 iColumnPosition,
                                        Int32 iColumnOccupation,
                                        Double dPas,
                                        DateTime dtBeginDate)
            {
                if (iArrivingPax > iLeavingPax)
                    return;
                Int32 InfPosition = (Int32)(BorneInferieure(iArrivingPax / dPas));
                Int32 SupPosition = (Int32)(BorneSuperieure(iLeavingPax / dPas));
                if (InfPosition > SupPosition)
                    SupPosition = InfPosition;

                Int32 InfOccupation = (Int32)Math.Round(iArrivingPax / dPas);
                Int32 SupOccupation = (Int32)Math.Round(iLeavingPax / dPas);
                Int32 Max = Math.Max(SupPosition, SupOccupation);
                Int32 Min = Math.Min(InfPosition, InfOccupation);
                if (laTable.Rows.Count <= Max)
                {
                    for (int i = laTable.Rows.Count; i <= Max; i++)
                    {
                        DataRow newRow = laTable.NewRow();
                        newRow[iIndexTime] = dtBeginDate.AddMinutes(dPas * i);
                        for (int j = 0; j < newRow.ItemArray.Length; j++)
                        {
                            if (j != iIndexTime)
                                newRow[j] = 0;
                        }
                        laTable.Rows.Add(newRow);
                    }
                }
                for (int i = Min; i <= Max; i++)
                {
                    if ((i >= InfPosition) && (i <= SupPosition))
                        laTable.Rows[i][iColumnPosition] = ((Int32)laTable.Rows[i].ItemArray[iColumnPosition]) + 1;
                    if ((i >= InfOccupation) && (i <= SupOccupation))
                        laTable.Rows[i][iColumnOccupation] = ((Int32)laTable.Rows[i].ItemArray[iColumnOccupation]) + 1;
                }
            }
            private static void setPax(DataTable laTable,
                                        Int32 iIndexTime,
                                        Double iArrivingPax,
                                        Double iLeavingPax,
                                        Int32 iColumnPosition,
                                        Double dPas,
                                        DateTime dtBeginDate)
            {
                if (iArrivingPax > iLeavingPax)
                    return;
                Int32 InfPosition = (Int32)(BorneInferieure(iArrivingPax / dPas));
                Int32 SupPosition = (Int32)(BorneSuperieure(iLeavingPax / dPas));
                if (InfPosition > SupPosition)
                    SupPosition = InfPosition;
                if (laTable.Rows.Count <= SupPosition)
                {
                    for (int i = laTable.Rows.Count; i <= SupPosition; i++)
                    {
                        DataRow newRow = laTable.NewRow();
                        newRow[iIndexTime] = dtBeginDate.AddMinutes(dPas * i);
                        for (int j = 0; j < newRow.ItemArray.Length; j++)
                        {
                            if (j != iIndexTime)
                                newRow[j] = 0;
                        }
                        laTable.Rows.Add(newRow);
                    }
                }
                for (int i = InfPosition; i <= SupPosition; i++)
                {
                    if (i >= 0 && iColumnPosition >= 0) // << Bug #9069 PAX2SIM crash with sample step 10, 12
                        laTable.Rows[i][iColumnPosition] = ((Int32)laTable.Rows[i].ItemArray[iColumnPosition]) + 1;
                }
            }
            #endregion

            #endregion

            #region fonctions statiques à extraire de la classe.

            private static void CompileData(DataTable dtResult, DataTable dtDesk)
            {
                if ((dtResult == null) || (dtDesk == null))
                    return;
                if (dtResult.Columns.Count == 0)
                    return;
                if (dtDesk.Columns.Count == 0)
                    return;
                if (dtDesk.Rows.Count != dtResult.Rows.Count)
                    return;
                for (int i = 0; i < dtDesk.Rows.Count; i++)
                {
                    dtResult.Rows[i][1] = (int)dtResult.Rows[i][1] + (int)dtDesk.Rows[i][1];
                }
            }
            private static void CompileData(DataTable dtResult, DataTable dtDesk, int iNbColumns)
            {
                if ((dtResult == null) || (dtDesk == null))
                    return;
                if (iNbColumns <= 0)
                    return;
                if (dtResult.Columns.Count == 0)
                    return;
                if (dtDesk.Columns.Count == 0)
                    return;
                if (iNbColumns >= dtDesk.Columns.Count)
                    return;
                if (dtResult.Columns.Count <= iNbColumns)
                    return;

                if (dtDesk.Rows.Count != dtResult.Rows.Count)
                    return;
                for (int j = 1; j <= iNbColumns; j++)
                {
                    for (int i = 0; i < dtDesk.Rows.Count; i++)
                    {
                        dtResult.Rows[i][j] = (int)dtResult.Rows[i][j] + (int)dtDesk.Rows[i][j];
                    }
                }
            }
            /// <summary>
            /// Fonction qui créer la table utilisée pour compiler les distributions des 
            /// </summary>
            /// <param name="sName"></param>
            /// <param name="dPas"></param>
            /// <param name="iNbMaxClass"></param>
            /// <returns></returns>
            private static DataTable BuildClassRemainingTable(String sName, Double dPas, int iNbMaxClass)
            {
                return ResultFunctions.BuildClassTable(sName, dPas, iNbMaxClass, 0, "RemainingTime", new String[] { "Nb Pax" });
            }
            #endregion

            #region Reclaim allocation tools for JNK.
            /*
            private class ArrivalFlightInformation
            {

                public class ArrivalFlightInformationComparer : IComparer
                {
                    public int Compare(Object x, Object y)
                    {
                        if (x.GetType() != typeof(ArrivalFlightInformation))
                            return 0;
                        if (y.GetType() != typeof(ArrivalFlightInformation))
                            return 0;
                        ArrivalFlightInformation xo = (ArrivalFlightInformation)x;
                        ArrivalFlightInformation yo = (ArrivalFlightInformation)y;
                        if (xo.dtTime > yo.dtTime)
                            return 1;
                        if (xo.dtTime < yo.dtTime)
                            return -1;
                        return 0;
                    }
                }
                public const String sFirstBag = "FIRST Bag Entry:";
                public const String sLastBag = "LAST Bag Entry:";
                public const String sFirstPaxEntry = "FIRST Pax Entry:";
                public const String sLastPaxEntry = "LAST Pax Entry:";

                public const String sFirstPaxLeaving = "FIRST Pax Leaving:";
                public const String sLastPaxLeaving = "LAST Pax Leaving:";

                public int iID;
                public DateTime dtTime;
                public String sFlightCategory;
                public String sFlightN;
                public Int32 iTerminalReclaim;
                public Int32 iReclaim;
                public Double dSTA;
                public Double dOCTOpening;
                public Double dOCTClosing;

                public Double dFirstBag;
                public Double dLastBag;
                public Double dFirstPaxEntry;
                public Double dLastPaxEntry;
                public Double dFirstPaxLeaving;
                public Double dLastPaxLeaving;
                public bool bValid;
                public ArrivalFlightInformation()
                {
                    iID = 0;
                    dSTA = 0;
                    dOCTOpening = -1;
                    dOCTClosing = -1;

                    dFirstBag = -1;
                    dLastBag = -1;
                    dFirstPaxEntry = -1;
                    dLastPaxEntry = -1;

                    dFirstPaxLeaving = -1;
                    dLastPaxLeaving = -1;
                    bValid = true;
                }
                public Object[] AllocationLigne(DateTime dtBegin)
                {
                    if (!bValid)
                        return null;
                    Object[] oResult = new object[21];
                    oResult[0] = iID;
                    oResult[1] = dtTime;
                    oResult[2] = sFlightN;
                    oResult[3] = sFlightCategory;
                    oResult[4] = FirstBagString;
                    oResult[5] = LastBagString;
                    oResult[6] = OccupationBag;
                    oResult[7] = FirstPaxEntryString;
                    oResult[8] = LastPaxEntryString;
                    oResult[9] = OccupationPaxEntry;

                    oResult[10] = FirstPaxLeavingString;
                    oResult[11] = LastPaxLeavingString;
                    oResult[12] = OccupationPaxLeaving;

                    oResult[13] = FirstBagString;
                    oResult[14] = LastPaxLeavingString;
                    oResult[15] = OccupationOptimized;

                    oResult[16] = dtBegin.AddMinutes(dOCTOpening);
                    oResult[17] = dtBegin.AddMinutes(dOCTClosing);
                    oResult[18] = OccupationSceduled;
                    oResult[19] = iTerminalReclaim;
                    oResult[20] = iReclaim;
                    return oResult;
                }
                public DateTime FirstBag
                {
                    get
                    {
                        return dtTime.AddMinutes(dFirstBag);
                    }
                }
                public String FirstBagString
                {
                    get
                    {
                        if (dFirstBag == -1)
                            return "";
                        return dtTime.AddMinutes(dFirstBag).ToString();
                    }
                }
                public DateTime LastBag
                {
                    get
                    {
                        return dtTime.AddMinutes(dLastBag);
                    }
                }
                public String LastBagString
                {
                    get
                    {
                        if (dLastBag == -1)
                            return "";
                        return dtTime.AddMinutes(dLastBag).ToString();
                    }
                }
                public Double OccupationBag
                {
                    get
                    {
                        if ((dFirstBag == -1) || (dLastBag == -1))
                            return -1;
                        return Math.Round(DataFunctions.MinuteDifference(FirstBag, LastBag), 2);
                    }
                }
                public DateTime FirstPaxEntry
                {
                    get
                    {
                        return dtTime.AddMinutes(dFirstPaxEntry);
                    }
                }
                public String FirstPaxEntryString
                {
                    get
                    {
                        if (dFirstPaxEntry == -1)
                            return "";
                        return dtTime.AddMinutes(dFirstPaxEntry).ToString();
                    }
                }
                public DateTime LastPaxEntry
                {
                    get
                    {
                        return dtTime.AddMinutes(dLastPaxEntry);
                    }
                }
                public String LastPaxEntryString
                {
                    get
                    {
                        if (dLastPaxEntry == -1)
                            return "";
                        return dtTime.AddMinutes(dLastPaxEntry).ToString();
                    }
                }
                public Double OccupationPaxEntry
                {
                    get
                    {
                        if ((dFirstPaxEntry == -1) || (dFirstPaxEntry == -1))
                            return -1;
                        return Math.Round(DataFunctions.MinuteDifference(FirstPaxEntry, LastPaxEntry), 2);
                    }
                }
                public DateTime FirstPaxLeaving
                {
                    get
                    {
                        return dtTime.AddMinutes(dFirstPaxLeaving);
                    }
                }
                public String FirstPaxLeavingString
                {
                    get
                    {
                        if (dFirstPaxLeaving == -1)
                            return "";
                        return dtTime.AddMinutes(dFirstPaxLeaving).ToString();
                    }
                }
                public DateTime LastPaxLeaving
                {
                    get
                    {
                        return dtTime.AddMinutes(dLastPaxLeaving);
                    }
                }
                public String LastPaxLeavingString
                {
                    get
                    {
                        if (dLastPaxLeaving == -1)
                            return "";
                        return dtTime.AddMinutes(dLastPaxLeaving).ToString();
                    }
                }
                public Double OccupationPaxLeaving
                {
                    get
                    {
                        if ((dFirstPaxLeaving == -1) || (dLastPaxLeaving == -1))
                            return -1;
                        return Math.Round(DataFunctions.MinuteDifference(FirstPaxLeaving, LastPaxLeaving), 2);
                    }
                }
                public Double OccupationOptimized
                {
                    get
                    {
                        if ((dFirstBag == -1) || (dLastPaxLeaving == -1))
                            return -1;
                        return Math.Round(DataFunctions.MinuteDifference(FirstBag, LastPaxLeaving), 2);
                    }
                }
                public Double OccupationSceduled
                {
                    get
                    {
                        if ((dOCTClosing == -1) || (dOCTOpening == -1))
                            return -1;
                        return Math.Round(dOCTClosing - dOCTOpening, 2);
                    }
                }
            }
            private DataTable getPassengerOccupation(String sReclaimLogLocation,
                DateTime dtBegin,
                DateTime dtEnd,
                DataTable dtFPA,
                DataTable dtBaggageClaimUtilisation,
                out VisualisationMode vmAllocationVisualisation,
                double dStep)
            {
                vmAllocationVisualisation = null;
                if (!File.Exists(sReclaimLogLocation))
                    return null;
                DataTable dtOrigin = new DataTable("ReclaimLog");
                if (!OverallTools.FonctionUtiles.LectureFichier(dtOrigin, sReclaimLogLocation, "\t", ErrorList_))
                {
                    ErrorList_.Add("Err00166 : Unable to load ReclaimLog.txt.");
                    return null;
                }

                int iIndexFPAID = dtOrigin.Columns.IndexOf("FPA ID");
                int iIndexSTA = dtOrigin.Columns.IndexOf("STA");
                int iIndexOCT = dtOrigin.Columns.IndexOf("OCT");
                int iIndexEvent = dtOrigin.Columns.IndexOf("Event");
                int iIndexValue = dtOrigin.Columns.IndexOf("Minutes after STA");
                if ((iIndexFPAID == -1) ||
                    (iIndexSTA == -1) ||
                    (iIndexOCT == -1) ||
                    (iIndexEvent == -1) ||
                    (iIndexValue == -1))
                {
                    ErrorList_.Add("Err00167 : Wrong format for ReclaimLog.txt.");
                    return null;
                }

                int iIndexFPATableID = dtFPA.Columns.IndexOf("ID");
                int iIndexFPATableDATE = dtFPA.Columns.IndexOf("DATE");
                int iIndexFPATableSTA = dtFPA.Columns.IndexOf("STA");
                int iIndexFPATableFC = dtFPA.Columns.IndexOf("FLIGHT CATEGORY");
                int iIndexFPATableTerminal = dtFPA.Columns.IndexOf("Reclaim Terminal");
                int iIndexFPATableBaggageClaim = dtFPA.Columns.IndexOf(GlobalNames.sFPA_Column_ReclaimObject);
                int iIndexFPATableFlightN = dtFPA.Columns.IndexOf("FLIGHT N");
                if ((iIndexFPATableID == -1) ||
                    (iIndexFPATableDATE == -1) ||
                    (iIndexFPATableSTA == -1) ||
                    (iIndexFPATableFC == -1) ||
                    (iIndexFPATableTerminal == -1) ||
                    (iIndexFPATableBaggageClaim == -1) ||
                    (iIndexFPATableFlightN == -1))
                {
                    ErrorList_.Add("Err00181 : Wrong format for FPATable for the calc for reclaim allocation.");
                    return null;
                }
                #region foreach (DataRow drRow in dtOrigin.Rows)
                Hashtable htList = new Hashtable();
                foreach (DataRow drRow in dtOrigin.Rows)
                {
                    int iFPAID;
                    if (!Int32.TryParse(drRow[iIndexFPAID].ToString(), out iFPAID))
                    {
                        ErrorList_.Add("Err00168 : Unable to interpret the FPA ID " + drRow[iIndexFPAID].ToString() + ".");
                        continue;
                    }
                    ArrivalFlightInformation afiTmp;
                    if (htList.ContainsKey(iFPAID))
                    {
                        afiTmp = (ArrivalFlightInformation)htList[iFPAID];
                    }
                    else
                    {
                        afiTmp = new ArrivalFlightInformation();
                        afiTmp.iID = iFPAID;
                        htList.Add(iFPAID, afiTmp);

                        if (!Double.TryParse(drRow[iIndexSTA].ToString(), out afiTmp.dSTA))
                        {
                            afiTmp.bValid = false;
                            ErrorList_.Add("Err00172 : Unable to interpret the STA " + drRow[iIndexSTA].ToString() + ".");
                            continue;
                        }
                    }
                    #region switch (drRow[iIndexEvent].ToString())
                    switch (drRow[iIndexEvent].ToString())
                    {
                        case ArrivalFlightInformation.sFirstBag:
                            if (!Double.TryParse(drRow[iIndexValue].ToString(), out afiTmp.dFirstBag))
                            {
                                afiTmp.bValid = false;
                                ErrorList_.Add("Err00169 : Unable to interpret the time for the First Baggage for the flight " + iFPAID.ToString() + ".");
                                continue;
                            }

                            if (!Double.TryParse(drRow[iIndexOCT].ToString(), out afiTmp.dOCTOpening))
                            {
                                afiTmp.bValid = false;
                                ErrorList_.Add("Err00170 : Unable to interpret the time for the opening time for the flight " + iFPAID.ToString() + ".");
                                continue;
                            }
                            break;
                        case ArrivalFlightInformation.sFirstPaxEntry:
                            if (!Double.TryParse(drRow[iIndexValue].ToString(), out afiTmp.dFirstPaxEntry))
                            {
                                afiTmp.bValid = false;
                                ErrorList_.Add("Err00173 : Unable to interpret the time for the First passenger for the flight " + iFPAID.ToString() + ".");
                                continue;
                            }

                            if (!Double.TryParse(drRow[iIndexOCT].ToString(), out afiTmp.dOCTOpening))
                            {
                                afiTmp.bValid = false;
                                ErrorList_.Add("Err00174 : Unable to interpret the time for the opening time for the flight " + iFPAID.ToString() + ".");
                                continue;
                            }
                            break;
                        case ArrivalFlightInformation.sLastBag:
                            if (!Double.TryParse(drRow[iIndexValue].ToString(), out afiTmp.dLastBag))
                            {
                                afiTmp.bValid = false;
                                ErrorList_.Add("Err00175 : Unable to interpret the time for the last baggage for the flight " + iFPAID.ToString() + ".");
                                continue;
                            }

                            if (!Double.TryParse(drRow[iIndexOCT].ToString(), out afiTmp.dOCTClosing))
                            {
                                afiTmp.bValid = false;
                                ErrorList_.Add("Err00176 : Unable to interpret the time for the closing time for the flight " + iFPAID.ToString() + ".");
                                continue;
                            }
                            break;
                        case ArrivalFlightInformation.sLastPaxEntry:
                            if (!Double.TryParse(drRow[iIndexValue].ToString(), out afiTmp.dLastPaxEntry))
                            {
                                afiTmp.bValid = false;
                                ErrorList_.Add("Err00177 : Unable to interpret the time for the last passenger for the flight " + iFPAID.ToString() + ".");
                                continue;
                            }

                            if (!Double.TryParse(drRow[iIndexOCT].ToString(), out afiTmp.dOCTClosing))
                            {
                                afiTmp.bValid = false;
                                ErrorList_.Add("Err00178 : Unable to interpret the time for the closing time for the flight " + iFPAID.ToString() + ".");
                                continue;
                            }
                            break;
                        case ArrivalFlightInformation.sFirstPaxLeaving:
                            if (!Double.TryParse(drRow[iIndexValue].ToString(), out afiTmp.dFirstPaxLeaving))
                            {
                                afiTmp.bValid = false;
                                ErrorList_.Add("Err00179 : Unable to interpret the time for the first passenger leaving the baggage claim for the flight " + iFPAID.ToString() + ".");
                                continue;
                            }
                            break;
                        case ArrivalFlightInformation.sLastPaxLeaving:
                            if (!Double.TryParse(drRow[iIndexValue].ToString(), out afiTmp.dLastPaxLeaving))
                            {
                                afiTmp.bValid = false;
                                ErrorList_.Add("Err00180 : Unable to interpret the time for the last passenger leaving the baggage claim for the flight " + iFPAID.ToString() + ".");
                                continue;
                            }
                            break;
                        default:
                            break;
                    }
                    #endregion
                }
                #endregion


                DataTable dtResult = new DataTable("Baggage claim occupation");
                dtResult.Columns.Add("FPA ID", typeof(Int32));
                dtResult.Columns.Add("STA", typeof(DateTime));
                dtResult.Columns.Add("Flight N", typeof(String));
                dtResult.Columns.Add("Flight category", typeof(String));
                dtResult.Columns.Add("First Bag Entry", typeof(String));
                dtResult.Columns.Add("Last Bag Entry", typeof(String));
                dtResult.Columns.Add("Occupation Bag Entry (min)", typeof(Double));
                dtResult.Columns.Add("First Pax Entry", typeof(String));
                dtResult.Columns.Add("Last Pax Entry", typeof(String));
                dtResult.Columns.Add("Occupation Pax Entry (min)", typeof(Double));
                dtResult.Columns.Add("First Pax Leaving", typeof(String));
                dtResult.Columns.Add("Last Pax Leaving", typeof(String));
                dtResult.Columns.Add("Occupation Pax Leaving (min)", typeof(Double));

                dtResult.Columns.Add("Optimized Openning", typeof(String));
                dtResult.Columns.Add("Optimized Closing", typeof(String));
                dtResult.Columns.Add("Occupation Optimized (min)", typeof(Double));

                dtResult.Columns.Add("Scheduled Opening", typeof(DateTime));
                dtResult.Columns.Add("Scheduled Closing", typeof(DateTime));
                dtResult.Columns.Add("Occupation Scheduled (min)", typeof(Double));

                dtResult.Columns.Add("Reclaim Terminal", typeof(Int32));
                dtResult.Columns.Add("Index Reclaim", typeof(Int32));

                foreach (ArrivalFlightInformation afiTmp2 in htList.Values)
                {
                    if (!afiTmp2.bValid)
                        continue;
                    int iIndexLigneFPA = OverallTools.DataFunctions.indexLigne(dtFPA, iIndexFPATableID, afiTmp2.iID.ToString());
                    if (iIndexLigneFPA == -1)
                    {
                        ErrorList_.Add("Err00182 : Unable to find arrival flight " + afiTmp2.ToString() + " in the FPA table.");
                        continue;
                    }

                    afiTmp2.dtTime = OverallTools.DataFunctions.toDateTime(dtFPA.Rows[iIndexLigneFPA][iIndexFPATableDATE],
                                                                            dtFPA.Rows[iIndexLigneFPA][iIndexFPATableSTA]);
                    afiTmp2.sFlightN = dtFPA.Rows[iIndexLigneFPA][iIndexFPATableFlightN].ToString();
                    afiTmp2.sFlightCategory = dtFPA.Rows[iIndexLigneFPA][iIndexFPATableFC].ToString();

                    //Modification liée au mode alphanumérique du plan de vol.
                    Int32.TryParse(dtFPA.Rows[iIndexLigneFPA][iIndexFPATableTerminal].ToString(), out afiTmp2.iTerminalReclaim);
                    Int32.TryParse(dtFPA.Rows[iIndexLigneFPA][iIndexFPATableBaggageClaim].ToString(), out afiTmp2.iReclaim);

                    //afiTmp2.iTerminalReclaim = (Int32)dtFPA.Rows[iIndexLigneFPA][iIndexFPATableTerminal];
                    //afiTmp2.iReclaim = (Int32)dtFPA.Rows[iIndexLigneFPA][iIndexFPATableBaggageClaim];
                    Object[] oTmp = afiTmp2.AllocationLigne(dtBegin);
                    if (oTmp == null)
                    {
                        ErrorList_.Add("Err00183 : Unable to generate the results for the arrival flight " + afiTmp2.ToString());
                        continue;
                    }
                    dtResult.Rows.Add(oTmp);
                }
                dtBaggageClaimUtilisation.TableName = "Optimized Baggage Claim Allocation";
                dtBaggageClaimUtilisation.Rows.Clear();
                DataFunctions.initialiserLignes(dtBaggageClaimUtilisation, dtBegin, dtEnd, dStep);
                int i;

                //We remove all the columns (except the first one (time)) Because there are no longer usefull.
                while (dtBaggageClaimUtilisation.Columns.Count > 1)
                    dtBaggageClaimUtilisation.Columns.RemoveAt(1);
                String sRessourceName = "Baggage Claim";

                dtBaggageClaimUtilisation.Columns.Add("Legend", typeof(String));
                dtBaggageClaimUtilisation.Columns.Add(sRessourceName + " Number of flights Optimized", typeof(Int32));
                Int32 iIndexOptimizedColumn = dtBaggageClaimUtilisation.Columns.Count - 1;
                String sBagEntry = "Bag Entry";
                String sPaxEntry = "Pax Entry";
                String sOptimized = "Optimized";


                // Suppression de toutes les données contenues dans la table d'allocation.
                //    On supprime toutes les informations contenues dans les colonnes ayant un
                //    index supérieur à 0 (colonne avec les heures conservée)
                foreach (DataRow ligne in dtBaggageClaimUtilisation.Rows)
                {
                    ligne[1] = "";
                    ligne[iIndexOptimizedColumn] = 0;
                }
                dtBaggageClaimUtilisation.AcceptChanges();

                vmAllocationVisualisation = new VisualisationMode(false, false, false, null, new int[] { 0 });
                vmAllocationVisualisation.ShowRowHeader = true;
                vmAllocationVisualisation.FirstColumnInHeader = true;
                ConditionnalFormatErrors cfeErrors = new ConditionnalFormatErrors();
                vmAllocationVisualisation.ConditionnalFormatClass = new VisualisationMode.ConditionnalFormat[] { cfeErrors };

                ArrayList alFlightCategories = new ArrayList();
                foreach (ArrivalFlightInformation afiTmp2 in htList.Values)
                {
                    if (!alFlightCategories.Contains(afiTmp2.sFlightCategory))
                        alFlightCategories.Add(afiTmp2.sFlightCategory);
                }
                alFlightCategories.Sort(new FonctionUtiles.ColumnsComparer());
                for (i = 0; i < alFlightCategories.Count; i++)
                {
                    dtBaggageClaimUtilisation.Rows[i][1] = alFlightCategories[i].ToString();
                    ((ConditionnalFormatErrors)vmAllocationVisualisation.ConditionnalFormatClass[0]).setCondition(1, i, FonctionUtiles.getColor(i));
                }

                i++;
                dtBaggageClaimUtilisation.Rows[i][1] = "Bag entry";
                ((ConditionnalFormatErrors)vmAllocationVisualisation.ConditionnalFormatClass[0]).setCondition(1, i, Color.Orange);

                i++;
                dtBaggageClaimUtilisation.Rows[i][1] = "Pax entry";
                ((ConditionnalFormatErrors)vmAllocationVisualisation.ConditionnalFormatClass[0]).setCondition(1, i, Color.LightSalmon);

                i++;
                dtBaggageClaimUtilisation.Rows[i][1] = "Optimized";
                ((ConditionnalFormatErrors)vmAllocationVisualisation.ConditionnalFormatClass[0]).setCondition(1, i, Color.LightBlue);

                ArrayList alResults = new ArrayList();
                foreach (ArrivalFlightInformation afiTmp2 in htList.Values)
                {
                    if (!afiTmp2.bValid)
                        continue;
                    alResults.Add(afiTmp2);
                }
                alResults.Sort(new ArrivalFlightInformation.ArrivalFlightInformationComparer());
                foreach (ArrivalFlightInformation afiTmp2 in alResults)
                {
                    String nomBaseColonne = afiTmp2.sFlightN + "_";
                    int iIndexBagEntry = dtBaggageClaimUtilisation.Columns.IndexOf(nomBaseColonne + sBagEntry);
                    int iIndexPaxEntry = -1;
                    int iIndexOptimized = -1;
                    if (iIndexBagEntry == -1)
                    {
                        // We have to had the columns for that flight.
                        dtBaggageClaimUtilisation.Columns.Add(nomBaseColonne + sBagEntry, typeof(String));
                        dtBaggageClaimUtilisation.Columns.Add(nomBaseColonne + sPaxEntry, typeof(String));
                        dtBaggageClaimUtilisation.Columns.Add(nomBaseColonne + sOptimized, typeof(String));
                        iIndexBagEntry = dtBaggageClaimUtilisation.Columns.Count - 3;
                        iIndexPaxEntry = dtBaggageClaimUtilisation.Columns.Count - 2;
                        iIndexOptimized = dtBaggageClaimUtilisation.Columns.Count - 1;
                        for (i = 0; i < dtBaggageClaimUtilisation.Rows.Count; i++)
                        {
                            dtBaggageClaimUtilisation.Rows[i][iIndexBagEntry] = "";
                            dtBaggageClaimUtilisation.Rows[i][iIndexPaxEntry] = "";
                            dtBaggageClaimUtilisation.Rows[i][iIndexOptimized] = "";
                            ((ConditionnalFormatErrors)vmAllocationVisualisation.ConditionnalFormatClass[0]).setCondition(iIndexBagEntry, i, FonctionUtiles.getColor(alFlightCategories.IndexOf(afiTmp2.sFlightCategory)));
                            ((ConditionnalFormatErrors)vmAllocationVisualisation.ConditionnalFormatClass[0]).setCondition(iIndexPaxEntry, i, FonctionUtiles.getColor(alFlightCategories.IndexOf(afiTmp2.sFlightCategory)));
                            ((ConditionnalFormatErrors)vmAllocationVisualisation.ConditionnalFormatClass[0]).setCondition(iIndexOptimized, i, FonctionUtiles.getColor(alFlightCategories.IndexOf(afiTmp2.sFlightCategory)));
                        }
                    }
                    else
                    {
                        iIndexBagEntry = dtBaggageClaimUtilisation.Columns.IndexOf(nomBaseColonne + sBagEntry);
                        iIndexPaxEntry = dtBaggageClaimUtilisation.Columns.IndexOf(nomBaseColonne + sPaxEntry);
                        iIndexOptimized = dtBaggageClaimUtilisation.Columns.IndexOf(nomBaseColonne + sOptimized);
                    }
                    int iIndexOpening = (int)((OverallTools.DataFunctions.MinuteDifference(dtBegin, afiTmp2.FirstBag)) / dStep);
                    int iIndexClosing = (int)((OverallTools.DataFunctions.MinuteDifference(dtBegin, afiTmp2.LastBag)) / dStep);
                    int iClosingTmp = (int)((OverallTools.DataFunctions.MinuteDifference(dtBegin, afiTmp2.LastBag) - 0.01) / dStep);
                    if (iIndexOpening >= dtBaggageClaimUtilisation.Rows.Count)
                        continue;
                    if ((iClosingTmp != iIndexClosing) && (iIndexOpening != iIndexClosing))
                        iIndexClosing = iClosingTmp;
                    if (iIndexClosing >= dtBaggageClaimUtilisation.Rows.Count)
                        iIndexClosing = dtBaggageClaimUtilisation.Rows.Count - 1;
                    for (i = iIndexOpening; i <= iIndexClosing; i++)
                    {
                        String sAncienneValeur = dtBaggageClaimUtilisation.Rows[i][iIndexBagEntry].ToString();
                        dtBaggageClaimUtilisation.Rows[i][iIndexBagEntry] = OverallTools.UpdateAllocation.traitementAllocation(sAncienneValeur, afiTmp2.sFlightN, false, "");
                        ((ConditionnalFormatErrors)vmAllocationVisualisation.ConditionnalFormatClass[0]).setCondition(iIndexBagEntry, i, Color.Orange);
                    }


                    iIndexOpening = (int)((OverallTools.DataFunctions.MinuteDifference(dtBegin, afiTmp2.FirstPaxEntry)) / dStep);
                    iIndexClosing = (int)((OverallTools.DataFunctions.MinuteDifference(dtBegin, afiTmp2.LastPaxEntry)) / dStep);
                    iClosingTmp = (int)((OverallTools.DataFunctions.MinuteDifference(dtBegin, afiTmp2.LastPaxEntry) - 0.01) / dStep);
                    if (iIndexOpening >= dtBaggageClaimUtilisation.Rows.Count)
                        continue;
                    if ((iClosingTmp != iIndexClosing) && (iIndexOpening != iIndexClosing))
                        iIndexClosing = iClosingTmp;
                    if (iIndexClosing >= dtBaggageClaimUtilisation.Rows.Count)
                        iIndexClosing = dtBaggageClaimUtilisation.Rows.Count - 1;
                    for (i = iIndexOpening; i <= iIndexClosing; i++)
                    {
                        String sAncienneValeur = dtBaggageClaimUtilisation.Rows[i][iIndexPaxEntry].ToString();
                        dtBaggageClaimUtilisation.Rows[i][iIndexPaxEntry] = OverallTools.UpdateAllocation.traitementAllocation(sAncienneValeur, afiTmp2.sFlightN, false, "");
                        ((ConditionnalFormatErrors)vmAllocationVisualisation.ConditionnalFormatClass[0]).setCondition(iIndexPaxEntry, i, Color.LightSalmon);
                    }

                    iIndexOpening = (int)((OverallTools.DataFunctions.MinuteDifference(dtBegin, afiTmp2.FirstBag)) / dStep);
                    iIndexClosing = (int)((OverallTools.DataFunctions.MinuteDifference(dtBegin, afiTmp2.LastPaxLeaving)) / dStep);
                    iClosingTmp = (int)((OverallTools.DataFunctions.MinuteDifference(dtBegin, afiTmp2.LastPaxLeaving) - 0.01) / dStep);
                    if (iIndexOpening >= dtBaggageClaimUtilisation.Rows.Count)
                        continue;
                    if ((iClosingTmp != iIndexClosing) && (iIndexOpening != iIndexClosing))
                        iIndexClosing = iClosingTmp;
                    if (iIndexClosing >= dtBaggageClaimUtilisation.Rows.Count)
                        iIndexClosing = dtBaggageClaimUtilisation.Rows.Count - 1;
                    for (i = iIndexOpening; i <= iIndexClosing; i++)
                    {
                        String sAncienneValeur = dtBaggageClaimUtilisation.Rows[i][iIndexOptimized].ToString();
                        dtBaggageClaimUtilisation.Rows[i][iIndexOptimized] = OverallTools.UpdateAllocation.traitementAllocation(sAncienneValeur, afiTmp2.sFlightN, false, "");
                        dtBaggageClaimUtilisation.Rows[i][iIndexOptimizedColumn] = (Int32)dtBaggageClaimUtilisation.Rows[i][iIndexOptimizedColumn] + 1;
                        ((ConditionnalFormatErrors)vmAllocationVisualisation.ConditionnalFormatClass[0]).setCondition(iIndexOptimized, i, Color.LightBlue);
                    }
                }
                dtBaggageClaimUtilisation.AcceptChanges();
                return dtResult;
            }

            */
            #endregion

            #region Reclaim allocation tools for JNK.
            private class ArrivalFlightInformation
            {

                public class ArrivalFlightInformationComparer : IComparer
                {
                    public int Compare(Object x, Object y)
                    {
                        if (x.GetType() != typeof(ArrivalFlightInformation))
                            return 0;
                        if (y.GetType() != typeof(ArrivalFlightInformation))
                            return 0;
                        ArrivalFlightInformation xo = (ArrivalFlightInformation)x;
                        ArrivalFlightInformation yo = (ArrivalFlightInformation)y;
                        if (xo.dtTime > yo.dtTime)
                            return 1;
                        if (xo.dtTime < yo.dtTime)
                            return -1;
                        return 0;
                    }
                }
                public class ArrivalFlightInformationComparerType/*<ArrivalFlightInformationComparer>*/ : IComparer<ArrivalFlightInformation>
                {
                    public int Compare(ArrivalFlightInformation x, ArrivalFlightInformation y)
                    {
                        ArrivalFlightInformationComparer comparer = new ArrivalFlightInformationComparer();
                        return comparer.Compare(x, y);
                    }
                }
                public const String sFirstBag = "FIRST Bag Entry:";
                public const String sLastBag = "LAST Bag Entry:";
                public const String sFirstPaxEntry = "FIRST Pax Entry:";
                public const String sLastPaxEntry = "LAST Pax Entry:";

                public const String sFirstPaxLeaving = "FIRST Pax Leaving:";
                public const String sLastPaxLeaving = "LAST Pax Leaving:";

                public const String sPartialBagEntry = "LAST-";
                public const String sPartialBagEntryEnd = " Bag Entry:";

                public int iID;
                public DateTime dtTime;
                public Double dAllocatedTime;
                public String sFlightCategory;
                public String sFlightN;
                public Int32 iTerminalReclaim;
                public Int32 iReclaim;
                public Double dSTA;
                public Double dOCTOpening;
                public Double dOCTClosing;
                private SortedList<Int32, double> slPartialLeaving;

                public Double dFirstBag;
                public Double dLastBag;
                public Double dFirstPaxEntry;
                public Double dLastPaxEntry;
                public Double dFirstPaxLeaving;
                public Double dLastPaxLeaving;
                public bool bValid;
                public int bagLimitNb;

                public ArrivalFlightInformation()
                {
                    iID = 0;
                    dSTA = 0;
                    dOCTOpening = -1;
                    dOCTClosing = -1;

                    dFirstBag = -1;
                    dLastBag = -1;
                    dFirstPaxEntry = -1;
                    dLastPaxEntry = -1;

                    dFirstPaxLeaving = -1;
                    dLastPaxLeaving = -1;
                    bValid = true;
                    slPartialLeaving = new SortedList<int, double>();
                }
                public Object[] AllocationLigne(DateTime dtBegin)
                {
                    if (!bValid)
                        return null;
                    Object[] oResult = new object[22];
                    oResult[0] = iID;
                    oResult[1] = dtTime;
                    oResult[2] = sFlightN;
                    oResult[3] = sFlightCategory;
                    oResult[4] = FirstBagString;
                    oResult[5] = LastBagString;
                    oResult[6] = OccupationBag;
                    oResult[7] = FirstPaxEntryString;
                    oResult[8] = LastPaxEntryString;
                    oResult[9] = OccupationPaxEntry;

                    oResult[10] = FirstPaxLeavingString;
                    oResult[11] = LastPaxLeavingString;
                    oResult[12] = OccupationPaxLeaving;

                    oResult[13] = FirstBagString;
                    oResult[14] = LastPaxLeavingString;
                    oResult[15] = OccupationOptimized;

                    oResult[16] = dtBegin.AddMinutes(dOCTOpening);
                    oResult[17] = dtBegin.AddMinutes(dOCTClosing);
                    oResult[18] = OccupationSceduled;

                    //if (reclaimLogDistribution != null) // >> Task #8958 Reclaim Synchronisation mode Gantt

                    //if (sFlightCategory == "LH")
                    //    oResult[19] = PartialLeavingDateString(30);
                    //else
                    //    oResult[19] = PartialLeavingDateString(15);
                    oResult[19] = PartialLeavingDateString(bagLimitNb);

                    oResult[20] = iTerminalReclaim;
                    oResult[21] = iReclaim;
                    return oResult;
                }
                public DateTime FirstBag
                {
                    get
                    {
                        return dtTime.AddMinutes(dFirstBag);
                    }
                }
                public String FirstBagString
                {
                    get
                    {
                        if (dFirstBag == -1)
                            return "";
                        return dtTime.AddMinutes(dFirstBag).ToString();
                    }
                }
                public DateTime LastBag
                {
                    get
                    {
                        return dtTime.AddMinutes(dLastBag);
                    }
                }
                public String LastBagString
                {
                    get
                    {
                        if (dLastBag == -1)
                            return "";
                        return dtTime.AddMinutes(dLastBag).ToString();
                    }
                }
                public Double OccupationBag
                {
                    get
                    {
                        if ((dFirstBag == -1) || (dLastBag == -1))
                            return -1;
                        return Math.Round(DataFunctions.MinuteDifference(FirstBag, LastBag), 2);
                    }
                }
                public DateTime FirstPaxEntry
                {
                    get
                    {
                        return dtTime.AddMinutes(dFirstPaxEntry);
                    }
                }
                public String FirstPaxEntryString
                {
                    get
                    {
                        if (dFirstPaxEntry == -1)
                            return "";
                        return FirstPaxEntry.ToString();
                    }
                }
                public DateTime LastPaxEntry
                {
                    get
                    {
                        return dtTime.AddMinutes(dLastPaxEntry);
                    }
                }
                public String LastPaxEntryString
                {
                    get
                    {
                        if (dLastPaxEntry == -1)
                            return "";
                        return dtTime.AddMinutes(dLastPaxEntry).ToString();
                    }
                }
                public Double OccupationPaxEntry
                {
                    get
                    {
                        if ((dFirstPaxEntry == -1) || (dFirstPaxEntry == -1))
                            return -1;
                        return Math.Round(DataFunctions.MinuteDifference(FirstPaxEntry, LastPaxEntry), 2);
                    }
                }
                public DateTime FirstPaxLeaving
                {
                    get
                    {
                        return dtTime.AddMinutes(dFirstPaxLeaving);
                    }
                }
                public String FirstPaxLeavingString
                {
                    get
                    {
                        if (dFirstPaxLeaving == -1)
                            return "";
                        return dtTime.AddMinutes(dFirstPaxLeaving).ToString();
                    }
                }
                public DateTime LastPaxLeaving
                {
                    get
                    {
                        return dtTime.AddMinutes(dLastPaxLeaving);
                    }
                }
                public String LastPaxLeavingString
                {
                    get
                    {
                        if (dLastPaxLeaving == -1)
                            return "";
                        return dtTime.AddMinutes(dLastPaxLeaving).ToString();
                    }
                }
                public Double OccupationPaxLeaving
                {
                    get
                    {
                        if ((dFirstPaxLeaving == -1) || (dLastPaxLeaving == -1))
                            return -1;
                        return Math.Round(DataFunctions.MinuteDifference(FirstPaxLeaving, LastPaxLeaving), 2);
                    }
                }
                public Double OccupationOptimized
                {
                    get
                    {
                        if ((dFirstBag == -1) || (dLastPaxLeaving == -1))
                            return -1;
                        return Math.Round(DataFunctions.MinuteDifference(FirstBag, LastPaxLeaving), 2);
                    }
                }
                public Double OccupationSceduled
                {
                    get
                    {
                        if ((dOCTClosing == -1) || (dOCTOpening == -1))
                            return -1;
                        return Math.Round(dOCTClosing - dOCTOpening, 2);
                    }
                }

                public Double AllocationTimeAfterSTA
                {
                    get
                    {
                        return dAllocatedTime - dSTA;
                    }
                }

                public Double dPartialLeaving(int iValue)
                {
                    if (slPartialLeaving.ContainsKey(iValue))
                        return slPartialLeaving[iValue];
                    int iClosestKey = -1;
                    foreach (int iKey in slPartialLeaving.Keys)
                    {
                        if ((iKey < iClosestKey) && (iKey > iValue))
                            iClosestKey = iKey;
                    }
                    if (iClosestKey == -1)
                        return -1.0;
                    return slPartialLeaving[iClosestKey];
                }
                public DateTime PartialLeavingDate(int iValue)
                {
                    Double dValue = dPartialLeaving(iValue);
                    if (dValue == -1.0)
                        return dtTime;
                    return dtTime.AddMinutes(dValue);
                }
                public String PartialLeavingDateString(int iValue)
                {
                    Double dValue = dPartialLeaving(iValue);
                    if (dValue == -1.0)
                        return "";
                    return dtTime.AddMinutes(dValue).ToString();
                }
                public void addPartialLeaving(int iIndex, double dValue)
                {
                    if (slPartialLeaving.ContainsKey(iIndex))
                        slPartialLeaving[iIndex] = dValue;
                    else
                        slPartialLeaving.Add(iIndex, dValue);
                }
            }

            private DataTable getPassengerOccupation(String sReclaimLogLocation,
                String sAllocationDelays,
                DateTime dtBegin,
                DateTime dtEnd,
                DataTable dtFPA,
                DataTable dtBaggageClaimUtilisation,
                DataTable reclaimLogDistribution,
                int seed,
                out DataTable[] dtAllocation,
                out VisualisationMode vmAllocationVisualisation, /*dtBaggageClaimUtilisation*/
                out VisualisationMode[] vmBaggageClaimVisualisation, /*dtAllocation*/
                double dStep)
            {
                String sTmp;

                vmAllocationVisualisation = null;
                vmBaggageClaimVisualisation = null;
                dtAllocation = null;
                if (!File.Exists(sReclaimLogLocation))
                    return null;
                DataTable dtOrigin = new DataTable("ReclaimLog");
                if (!OverallTools.FonctionUtiles.LectureFichier(dtOrigin, sReclaimLogLocation, "\t", ErrorList_))
                {
                    ErrorList_.Add("Err00166 : Unable to load ReclaimLog.txt.");

                    return null;
                }
                if ((dtOrigin == null) || (dtOrigin.Rows.Count == 0))
                {
                    return null;
                }

                SortedList<Int32, Double> slAllocatedTime = null;
                if (File.Exists(sAllocationDelays))
                {
                    DataTable dtTimeAllocation = new DataTable("Allocation");
                    if (OverallTools.FonctionUtiles.LectureFichier(dtTimeAllocation, sAllocationDelays, "\t", ErrorList_) &&
                        (dtTimeAllocation.Columns.Count == 2))
                    {
                        int iTmp;
                        Double dTmp;
                        slAllocatedTime = new SortedList<int, double>();
                        foreach (DataRow drLine in dtTimeAllocation.Rows)
                        {
                            if (!Int32.TryParse(drLine[0].ToString(), out iTmp))
                                continue;
                            if (!Double.TryParse(drLine[1].ToString(), out dTmp))
                                continue;
                            slAllocatedTime.Add(iTmp, dTmp);
                        }
                    }
                }
                int iIndexFPAID = dtOrigin.Columns.IndexOf("FPA ID");
                int iIndexSTA = dtOrigin.Columns.IndexOf("STA");
                int iIndexOCT = dtOrigin.Columns.IndexOf("OCT");
                int iIndexEvent = dtOrigin.Columns.IndexOf("Event");
                int iIndexValue = dtOrigin.Columns.IndexOf("Minutes after STA");
                int iIndexReclaim = dtOrigin.Columns.IndexOf("#Reclaim");
                if ((iIndexFPAID == -1) ||
                    (iIndexSTA == -1) ||
                    (iIndexOCT == -1) ||
                    (iIndexEvent == -1) ||
                    (iIndexValue == -1))
                {
                    ErrorList_.Add("Err00167 : Wrong format for ReclaimLog.txt.");
                    return null;
                }

                int iIndexFPATableID = dtFPA.Columns.IndexOf("ID");
                int iIndexFPATableDATE = dtFPA.Columns.IndexOf("DATE");
                int iIndexFPATableSTA = dtFPA.Columns.IndexOf("STA");
                int iIndexFPATableFC = dtFPA.Columns.IndexOf("FLIGHT CATEGORY");
                int iIndexFPATableTerminal = dtFPA.Columns.IndexOf("Reclaim Terminal");
                int iIndexFPATableBaggageClaim = dtFPA.Columns.IndexOf(GlobalNames.sFPA_Column_ReclaimObject);
                int iIndexFPATableFlightN = dtFPA.Columns.IndexOf("FLIGHT N");
                if ((iIndexFPATableID == -1) ||
                    (iIndexFPATableDATE == -1) ||
                    (iIndexFPATableSTA == -1) ||
                    (iIndexFPATableFC == -1) ||
                    (iIndexFPATableTerminal == -1) ||
                    (iIndexFPATableBaggageClaim == -1) ||
                    (iIndexFPATableFlightN == -1))
                {
                    ErrorList_.Add("Err00181 : Wrong format for FPATable for the calc for reclaim allocation.");
                    return null;
                }
                #region foreach (DataRow drRow in dtOrigin.Rows)
                Hashtable htList = new Hashtable();
                foreach (DataRow drRow in dtOrigin.Rows)
                {
                    int iFPAID;
                    if (!Int32.TryParse(drRow[iIndexFPAID].ToString(), out iFPAID))
                    {
                        ErrorList_.Add("Err00168 : Unable to interpret the FPA ID " + drRow[iIndexFPAID].ToString() + ".");
                        continue;
                    }
                    ArrivalFlightInformation afiTmp;
                    if (htList.ContainsKey(iFPAID))
                    {
                        afiTmp = (ArrivalFlightInformation)htList[iFPAID];
                    }
                    else
                    {
                        afiTmp = new ArrivalFlightInformation();
                        afiTmp.iID = iFPAID;
                        if ((slAllocatedTime != null) && (slAllocatedTime.ContainsKey(iFPAID)))
                            afiTmp.dAllocatedTime = slAllocatedTime[iFPAID];
                        htList.Add(iFPAID, afiTmp);

                        if (!Double.TryParse(drRow[iIndexSTA].ToString(), out afiTmp.dSTA))
                        {
                            afiTmp.bValid = false;
                            ErrorList_.Add("Err00172 : Unable to interpret the STA " + drRow[iIndexSTA].ToString() + ".");
                            continue;
                        }
                    }
                    #region switch (drRow[iIndexEvent].ToString())
                    String sValue = drRow[iIndexEvent].ToString();
                    switch (sValue)
                    {
                        case ArrivalFlightInformation.sFirstBag:
                            if (!Double.TryParse(drRow[iIndexValue].ToString(), out afiTmp.dFirstBag))
                            {
                                afiTmp.bValid = false;
                                ErrorList_.Add("Err00169 : Unable to interpret the time for the First Baggage for the flight " + iFPAID.ToString() + ".");
                                continue;
                            }

                            if (!Double.TryParse(drRow[iIndexOCT].ToString(), out afiTmp.dOCTOpening))
                            {
                                afiTmp.bValid = false;
                                ErrorList_.Add("Err00170 : Unable to interpret the time for the opening time for the flight " + iFPAID.ToString() + ".");
                                continue;
                            }
                            if (iIndexReclaim != -1)
                            {
                                if (!Int32.TryParse(drRow[iIndexReclaim].ToString(), out afiTmp.iReclaim))
                                {
                                }
                            }

                            break;
                        case ArrivalFlightInformation.sFirstPaxEntry:
                            if (!Double.TryParse(drRow[iIndexValue].ToString(), out afiTmp.dFirstPaxEntry))
                            {
                                afiTmp.bValid = false;
                                ErrorList_.Add("Err00173 : Unable to interpret the time for the First passenger for the flight " + iFPAID.ToString() + ".");
                                continue;
                            }

                            if (!Double.TryParse(drRow[iIndexOCT].ToString(), out afiTmp.dOCTOpening))
                            {
                                afiTmp.bValid = false;
                                ErrorList_.Add("Err00174 : Unable to interpret the time for the opening time for the flight " + iFPAID.ToString() + ".");
                                continue;
                            }
                            break;
                        case ArrivalFlightInformation.sLastBag:
                            if (!Double.TryParse(drRow[iIndexValue].ToString(), out afiTmp.dLastBag))
                            {
                                afiTmp.bValid = false;
                                ErrorList_.Add("Err00175 : Unable to interpret the time for the last baggage for the flight " + iFPAID.ToString() + ".");
                                continue;
                            }

                            if (!Double.TryParse(drRow[iIndexOCT].ToString(), out afiTmp.dOCTClosing))
                            {
                                afiTmp.bValid = false;
                                ErrorList_.Add("Err00176 : Unable to interpret the time for the closing time for the flight " + iFPAID.ToString() + ".");
                                continue;
                            }
                            break;
                        case ArrivalFlightInformation.sLastPaxEntry:
                            if (!Double.TryParse(drRow[iIndexValue].ToString(), out afiTmp.dLastPaxEntry))
                            {
                                afiTmp.bValid = false;
                                ErrorList_.Add("Err00177 : Unable to interpret the time for the last passenger for the flight " + iFPAID.ToString() + ".");
                                continue;
                            }

                            if (!Double.TryParse(drRow[iIndexOCT].ToString(), out afiTmp.dOCTClosing))
                            {
                                afiTmp.bValid = false;
                                ErrorList_.Add("Err00178 : Unable to interpret the time for the closing time for the flight " + iFPAID.ToString() + ".");
                                continue;
                            }
                            break;
                        case ArrivalFlightInformation.sFirstPaxLeaving:
                            if (!Double.TryParse(drRow[iIndexValue].ToString(), out afiTmp.dFirstPaxLeaving))
                            {
                                afiTmp.bValid = false;
                                ErrorList_.Add("Err00179 : Unable to interpret the time for the first passenger leaving the baggage claim for the flight " + iFPAID.ToString() + ".");
                                continue;
                            }
                            break;
                        case ArrivalFlightInformation.sLastPaxLeaving:
                            if (!Double.TryParse(drRow[iIndexValue].ToString(), out afiTmp.dLastPaxLeaving))
                            {
                                afiTmp.bValid = false;
                                ErrorList_.Add("Err00180 : Unable to interpret the time for the last passenger leaving the baggage claim for the flight " + iFPAID.ToString() + ".");
                                continue;
                            }
                            break;
                        default:
                            if (sValue.StartsWith(ArrivalFlightInformation.sPartialBagEntry) &&
                               sValue.EndsWith(ArrivalFlightInformation.sPartialBagEntryEnd))
                            {
                                int iIndexBegin = ArrivalFlightInformation.sPartialBagEntry.Length;
                                int iFirstIndexOfEnd = sValue.LastIndexOf(ArrivalFlightInformation.sPartialBagEntryEnd);
                                String sIndex = sValue.Substring(iIndexBegin, iFirstIndexOfEnd - iIndexBegin);
                                int iValue;
                                if (!Int32.TryParse(sIndex, out iValue))
                                {
                                    afiTmp.bValid = false;
                                    ErrorList_.Add("Err00188 : Unable to interpret the remaining number of bags for the flight " + iFPAID.ToString() + ".");
                                    continue;
                                }
                                Double dValue;
                                if (!Double.TryParse(drRow[iIndexValue].ToString(), out dValue))
                                {
                                    afiTmp.bValid = false;
                                    ErrorList_.Add("Err00189 : Unable to interpret the time for the moment when there is only " + iValue + " baggage left on the baggage claim for the flight " + iFPAID.ToString() + ".");
                                    continue;
                                }
                                afiTmp.addPartialLeaving(iValue, dValue);
                            }
                            break;
                    }
                    #endregion
                }
                #endregion


                DataTable dtResult = new DataTable("Baggage claim occupation");
                dtResult.Columns.Add("FPA ID", typeof(Int32));
                dtResult.Columns.Add("STA", typeof(DateTime));
                dtResult.Columns.Add("Flight N", typeof(String));
                dtResult.Columns.Add("Flight category", typeof(String));
                dtResult.Columns.Add("First Bag Entry", typeof(String));
                dtResult.Columns.Add("Last Bag Entry", typeof(String));
                dtResult.Columns.Add("Occupation Bag Entry (min)", typeof(Double));
                dtResult.Columns.Add("First Pax Entry", typeof(String));
                dtResult.Columns.Add("Last Pax Entry", typeof(String));
                dtResult.Columns.Add("Occupation Pax Entry (min)", typeof(Double));
                dtResult.Columns.Add("First Pax Leaving", typeof(String));
                dtResult.Columns.Add("Last Pax Leaving", typeof(String));
                dtResult.Columns.Add("Occupation Pax Leaving (min)", typeof(Double));

                dtResult.Columns.Add("Optimized Openning", typeof(String));
                dtResult.Columns.Add("Optimized Closing", typeof(String));
                dtResult.Columns.Add("Occupation Optimized (min)", typeof(Double));

                dtResult.Columns.Add("Scheduled Opening", typeof(DateTime));
                dtResult.Columns.Add("Scheduled Closing", typeof(DateTime));
                dtResult.Columns.Add("Occupation Scheduled (min)", typeof(Double));
                dtResult.Columns.Add("Time of the last tracked bag on the belt", typeof(String));   //("Last-30 (-15) Bags left on the Belt(min)", typeof(String));

                dtResult.Columns.Add("Reclaim Terminal", typeof(Int32));
                dtResult.Columns.Add("Index Reclaim", typeof(Int32));

                Random randomGenerator = new Random(seed * 11);
                foreach (ArrivalFlightInformation afiTmp2 in htList.Values)
                {
                    if (!afiTmp2.bValid)
                        continue;
                    int iIndexLigneFPA = OverallTools.DataFunctions.indexLigne(dtFPA, iIndexFPATableID, afiTmp2.iID.ToString());
                    if (iIndexLigneFPA == -1)
                    {
                        ErrorList_.Add("Err00182 : Unable to find arrival flight " + afiTmp2.ToString() + " in the FPA table.");
                        continue;
                    }

                    afiTmp2.dtTime = OverallTools.DataFunctions.toDateTime(dtFPA.Rows[iIndexLigneFPA][iIndexFPATableDATE],
                                                                            dtFPA.Rows[iIndexLigneFPA][iIndexFPATableSTA]);
                    afiTmp2.sFlightN = dtFPA.Rows[iIndexLigneFPA][iIndexFPATableFlightN].ToString();
                    afiTmp2.sFlightCategory = dtFPA.Rows[iIndexLigneFPA][iIndexFPATableFC].ToString();
                    afiTmp2.iTerminalReclaim = FonctionsType.getInt(dtFPA.Rows[iIndexLigneFPA][iIndexFPATableTerminal]);
                    if (afiTmp2.iReclaim == 0)
                    {
                        afiTmp2.iReclaim = FonctionsType.getInt(dtFPA.Rows[iIndexLigneFPA][iIndexFPATableBaggageClaim]);
                    }

                    double randomNb = randomGenerator.NextDouble();
                    afiTmp2.bagLimitNb = getReclaimBagLimitNb(reclaimLogDistribution, afiTmp2.sFlightCategory, randomNb); // >> Task #8958 Reclaim Synchronisation mode Gantt
                    Object[] oTmp = afiTmp2.AllocationLigne(dtBegin);
                    if (oTmp == null)
                    {
                        ErrorList_.Add("Err00183 : Unable to generate the results for the arrival flight " + afiTmp2.ToString());
                        continue;
                    }
                    dtResult.Rows.Add(oTmp);
                }
                dtBaggageClaimUtilisation.TableName = "Optimized Baggage Claim Allocation";
                dtBaggageClaimUtilisation.Rows.Clear();
                DataFunctions.initialiserLignes(dtBaggageClaimUtilisation, dtBegin, dtEnd, dStep);
                int i;

                //We remove all the columns (except the first one (time)) Because there are no longer usefull.
                while (dtBaggageClaimUtilisation.Columns.Count > 1)
                    dtBaggageClaimUtilisation.Columns.RemoveAt(1);
                String sRessourceName = "Baggage Claim";

                dtBaggageClaimUtilisation.Columns.Add("Legend", typeof(String));


                if (slAllocatedTime != null)
                {
                    dtAllocation = new DataTable[3];
                    dtAllocation[2] = new DataTable("Wait times for allocation");
                    dtAllocation[2].Columns.Add("ID", typeof(Int32));
                    dtAllocation[2].Columns.Add("Name", typeof(String));
                    dtAllocation[2].Columns.Add("STA", typeof(DateTime));
                    dtAllocation[2].Columns.Add("AllocatedTime (min after STA)", typeof(Double));
                    vmBaggageClaimVisualisation = new VisualisationMode[3];
                }
                else
                {
                    dtAllocation = new DataTable[2];
                    vmBaggageClaimVisualisation = new VisualisationMode[2];
                }
                dtAllocation[0] = dtBaggageClaimUtilisation.Copy();
                /*dtAllocation[1] = dtBaggageClaimUtilisation.Copy();
                dtAllocation[2] = dtBaggageClaimUtilisation.Copy();*/
                dtAllocation[0].TableName = "Gantt";
                /*dtAllocation[1].TableName = "Gantt_Pax";
                dtAllocation[2].TableName = "Gantt_Occupied";*/

                dtBaggageClaimUtilisation.Columns.Add(sRessourceName + " Number of flights Optimized", typeof(Int32));
                Int32 iIndexOptimizedColumn = dtBaggageClaimUtilisation.Columns.Count - 1;
                String sBagEntry = "Bag Entry";
                String sPaxEntry = "Pax Entry";
                String sOptimized = "Optimized";


                // Suppression de toutes les données contenues dans la table d'allocation.
                //    On supprime toutes les informations contenues dans les colonnes ayant un
                //    index supérieur à 0 (colonne avec les heures conservée)
                foreach (DataRow ligne in dtBaggageClaimUtilisation.Rows)
                {
                    ligne[1] = "";
                    ligne[iIndexOptimizedColumn] = 0;
                }
                foreach (DataRow ligne in dtAllocation[0].Rows)
                {
                    ligne[1] = "";
                }/*
                foreach (DataRow ligne in dtAllocation[1].Rows)
                {
                    ligne[1] = "";
                }
                foreach (DataRow ligne in dtAllocation[2].Rows)
                {
                    ligne[1] = "";
                }*/

                dtBaggageClaimUtilisation.AcceptChanges();
                vmBaggageClaimVisualisation[0] = new VisualisationMode(false, false, false, null, new int[] { 0 });
                vmBaggageClaimVisualisation[1] = new VisualisationMode(false, false, false, null, new int[] { 0 });
                if (vmBaggageClaimVisualisation.Length > 2)
                    vmBaggageClaimVisualisation[2] = null;/*/*
                vmBaggageClaimVisualisation[2] = new VisualisationMode(false, false, false, null, new int[] { 0 });*/
                vmBaggageClaimVisualisation[0].ShowRowHeader = true;
                vmBaggageClaimVisualisation[1].ShowRowHeader = true;/*
                vmBaggageClaimVisualisation[2].ShowRowHeader = true;*/
                vmBaggageClaimVisualisation[0].FirstColumnInHeader = true;
                vmBaggageClaimVisualisation[1].FirstColumnInHeader = true;/*
                vmBaggageClaimVisualisation[2].FirstColumnInHeader = true;*/
                ConditionnalFormatErrors cfeErrors = new ConditionnalFormatErrors();
                vmBaggageClaimVisualisation[0].ConditionnalFormatClass = new VisualisationMode.ConditionnalFormat[] { cfeErrors };
                cfeErrors = new ConditionnalFormatErrors();
                vmBaggageClaimVisualisation[1].ConditionnalFormatClass = new VisualisationMode.ConditionnalFormat[] { cfeErrors };/*
                cfeErrors = new ConditionnalFormatErrors();
                vmBaggageClaimVisualisation[2].ConditionnalFormatClass = new VisualisationMode.ConditionnalFormat[] { cfeErrors };*/

                vmAllocationVisualisation = new VisualisationMode(false, false, false, null, new int[] { 0 });
                vmAllocationVisualisation.ShowRowHeader = true;
                vmAllocationVisualisation.FirstColumnInHeader = true;
                cfeErrors = new ConditionnalFormatErrors();
                vmAllocationVisualisation.ConditionnalFormatClass = new VisualisationMode.ConditionnalFormat[] { cfeErrors };

                ArrayList alFlightCategories = new ArrayList();
                foreach (ArrivalFlightInformation afiTmp2 in htList.Values)
                {
                    if (!alFlightCategories.Contains(afiTmp2.sFlightCategory))
                        alFlightCategories.Add(afiTmp2.sFlightCategory);
                }
                alFlightCategories.Sort(new FonctionUtiles.ColumnsComparer());
                for (i = 0; i < alFlightCategories.Count; i++)
                {
                    dtBaggageClaimUtilisation.Rows[i][1] = alFlightCategories[i].ToString();
                    dtAllocation[0].Rows[i][1] = alFlightCategories[i].ToString();/*
                    dtAllocation[1].Rows[i][1] = alFlightCategories[i].ToString();
                    dtAllocation[2].Rows[i][1] = alFlightCategories[i].ToString();*/
                    ((ConditionnalFormatErrors)vmAllocationVisualisation.ConditionnalFormatClass[0]).setCondition(1, i, FonctionUtiles.getColor(i));
                    ((ConditionnalFormatErrors)vmBaggageClaimVisualisation[0].ConditionnalFormatClass[0]).setCondition(1, i, FonctionUtiles.getColor(i));
                    ((ConditionnalFormatErrors)vmBaggageClaimVisualisation[1].ConditionnalFormatClass[0]).setCondition(i + 1, 0, FonctionUtiles.getColor(i));/*
                    ((ConditionnalFormatErrors)vmBaggageClaimVisualisation[2].ConditionnalFormatClass[0]).setCondition(1, i, FonctionUtiles.getColor(i));*/
                }

                i++;
                dtBaggageClaimUtilisation.Rows[i][1] = "Bag entry";
                ((ConditionnalFormatErrors)vmAllocationVisualisation.ConditionnalFormatClass[0]).setCondition(1, i, Color.Orange);

                i++;
                dtBaggageClaimUtilisation.Rows[i][1] = "Pax entry";
                ((ConditionnalFormatErrors)vmAllocationVisualisation.ConditionnalFormatClass[0]).setCondition(1, i, Color.LightSalmon);

                i++;
                dtBaggageClaimUtilisation.Rows[i][1] = "Optimized";
                ((ConditionnalFormatErrors)vmAllocationVisualisation.ConditionnalFormatClass[0]).setCondition(1, i, Color.LightBlue);

                ArrayList alResults = new ArrayList();
                foreach (ArrivalFlightInformation afiTmp2 in htList.Values)
                {
                    if (!afiTmp2.bValid)
                        continue;
                    alResults.Add(afiTmp2);
                }
                alResults.Sort(new ArrivalFlightInformation.ArrivalFlightInformationComparer());
                foreach (ArrivalFlightInformation afiTmp2 in alResults)
                {
                    if (slAllocatedTime != null)
                        dtAllocation[2].Rows.Add(new Object[] { afiTmp2.iID, afiTmp2.sFlightN, afiTmp2.dtTime, afiTmp2.AllocationTimeAfterSTA });
                    String nomBaseColonne = afiTmp2.sFlightN + "_";
                    int iIndexBagEntry = dtBaggageClaimUtilisation.Columns.IndexOf(nomBaseColonne + sBagEntry);
                    int iIndexPaxEntry = -1;
                    int iIndexOptimized = -1;
                    if (iIndexBagEntry == -1)
                    {
                        // We have to had the columns for that flight.
                        dtBaggageClaimUtilisation.Columns.Add(nomBaseColonne + sBagEntry, typeof(String));
                        dtBaggageClaimUtilisation.Columns.Add(nomBaseColonne + sPaxEntry, typeof(String));
                        dtBaggageClaimUtilisation.Columns.Add(nomBaseColonne + sOptimized, typeof(String));
                        iIndexBagEntry = dtBaggageClaimUtilisation.Columns.Count - 3;
                        iIndexPaxEntry = dtBaggageClaimUtilisation.Columns.Count - 2;
                        iIndexOptimized = dtBaggageClaimUtilisation.Columns.Count - 1;
                        for (i = 0; i < dtBaggageClaimUtilisation.Rows.Count; i++)
                        {
                            dtBaggageClaimUtilisation.Rows[i][iIndexBagEntry] = "";
                            dtBaggageClaimUtilisation.Rows[i][iIndexPaxEntry] = "";
                            dtBaggageClaimUtilisation.Rows[i][iIndexOptimized] = "";
                            ((ConditionnalFormatErrors)vmAllocationVisualisation.ConditionnalFormatClass[0]).setCondition(iIndexBagEntry, i, FonctionUtiles.getColor(alFlightCategories.IndexOf(afiTmp2.sFlightCategory)));
                            ((ConditionnalFormatErrors)vmAllocationVisualisation.ConditionnalFormatClass[0]).setCondition(iIndexPaxEntry, i, FonctionUtiles.getColor(alFlightCategories.IndexOf(afiTmp2.sFlightCategory)));
                            ((ConditionnalFormatErrors)vmAllocationVisualisation.ConditionnalFormatClass[0]).setCondition(iIndexOptimized, i, FonctionUtiles.getColor(alFlightCategories.IndexOf(afiTmp2.sFlightCategory)));
                        }
                    }
                    else
                    {
                        iIndexBagEntry = dtBaggageClaimUtilisation.Columns.IndexOf(nomBaseColonne + sBagEntry);
                        iIndexPaxEntry = dtBaggageClaimUtilisation.Columns.IndexOf(nomBaseColonne + sPaxEntry);
                        iIndexOptimized = dtBaggageClaimUtilisation.Columns.IndexOf(nomBaseColonne + sOptimized);
                    }
                    int iIndexOpening = (int)((OverallTools.DataFunctions.MinuteDifference(dtBegin, afiTmp2.FirstBag)) / dStep);
                    int iIndexClosing = (int)((OverallTools.DataFunctions.MinuteDifference(dtBegin, afiTmp2.LastBag)) / dStep);
                    int iClosingTmp = (int)((OverallTools.DataFunctions.MinuteDifference(dtBegin, afiTmp2.LastBag) - 0.01) / dStep);
                    if (iIndexOpening >= dtBaggageClaimUtilisation.Rows.Count)
                        continue;
                    if (iIndexOpening < 0)
                        iIndexOpening = 0;
                    if ((iClosingTmp != iIndexClosing) && (iIndexOpening != iIndexClosing))
                        iIndexClosing = iClosingTmp;
                    if (iIndexClosing >= dtBaggageClaimUtilisation.Rows.Count)
                        iIndexClosing = dtBaggageClaimUtilisation.Rows.Count - 1;
                    for (i = iIndexOpening; i <= iIndexClosing; i++)
                    {
                        String sAncienneValeur = dtBaggageClaimUtilisation.Rows[i][iIndexBagEntry].ToString();
                        dtBaggageClaimUtilisation.Rows[i][iIndexBagEntry] = OverallTools.UpdateAllocation.traitementAllocation(sAncienneValeur, afiTmp2.sFlightN, false, "");
                        ((ConditionnalFormatErrors)vmAllocationVisualisation.ConditionnalFormatClass[0]).setCondition(iIndexBagEntry, i, Color.Orange);
                    }

                    /*Bag Claim Visu*/
                    if ((afiTmp2.iReclaim != -1) && (dtAllocation[0].Columns.Count <= afiTmp2.iReclaim * 12 - 10))
                        AddReclaim(dtAllocation[0], afiTmp2.iReclaim);

                    int iPartialClosing = (int)(OverallTools.DataFunctions.MinuteDifference(dtBegin, afiTmp2.PartialLeavingDate(30)) / dStep);
                    if (afiTmp2.sFlightCategory == "SH")
                        iPartialClosing = (int)(OverallTools.DataFunctions.MinuteDifference(dtBegin, afiTmp2.PartialLeavingDate(15)) / dStep);
                    Int32[] tiBegin = new Int32[3];
                    Int32[] tiEnd = new Int32[3];
                    tiBegin[0] = iIndexOpening;
                    tiEnd[0] = iIndexClosing;
                    //AddReclaimUsage(dtAllocation[0], 0, vmBaggageClaimVisualisation/*((ConditionnalFormatErrors)vmBaggageClaimVisualisation/*[0]* /.ConditionnalFormatClass[0])*/, afiTmp2.sFlightN, afiTmp2.iReclaim, iIndexOpening, iIndexClosing, iPartialClosing, alFlightCategories.IndexOf(afiTmp2.sFlightCategory));

                    /*End Bag Claim Visu*/


                    iIndexOpening = (int)((OverallTools.DataFunctions.MinuteDifference(dtBegin, afiTmp2.FirstPaxEntry)) / dStep);
                    iIndexClosing = (int)((OverallTools.DataFunctions.MinuteDifference(dtBegin, afiTmp2.LastPaxEntry)) / dStep);
                    iClosingTmp = (int)((OverallTools.DataFunctions.MinuteDifference(dtBegin, afiTmp2.LastPaxEntry) - 0.01) / dStep);
                    if (iIndexOpening >= dtBaggageClaimUtilisation.Rows.Count)
                        continue;
                    if ((iClosingTmp != iIndexClosing) && (iIndexOpening != iIndexClosing))
                        iIndexClosing = iClosingTmp;
                    if (iIndexClosing >= dtBaggageClaimUtilisation.Rows.Count)
                        iIndexClosing = dtBaggageClaimUtilisation.Rows.Count - 1;
                    for (i = iIndexOpening; i <= iIndexClosing; i++)
                    {
                        String sAncienneValeur = dtBaggageClaimUtilisation.Rows[i][iIndexPaxEntry].ToString();
                        dtBaggageClaimUtilisation.Rows[i][iIndexPaxEntry] = OverallTools.UpdateAllocation.traitementAllocation(sAncienneValeur, afiTmp2.sFlightN, false, "");
                        ((ConditionnalFormatErrors)vmAllocationVisualisation.ConditionnalFormatClass[0]).setCondition(iIndexPaxEntry, i, Color.LightSalmon);
                    }

                    /*Bag Claim Visu*/
                    /*if ((afiTmp2.iReclaim != -1) && (dtAllocation[1].Columns.Count <= afiTmp2.iReclaim * 4 - 2))
                        AddReclaim(dtAllocation[1], afiTmp2.iReclaim);*/
                    //AddReclaimUsage(dtAllocation[1], ((ConditionnalFormatErrors)vmBaggageClaimVisualisation[1].ConditionnalFormatClass[0]), afiTmp2.sFlightN, afiTmp2.iReclaim, iIndexOpening, iIndexClosing, iPartialClosing, alFlightCategories.IndexOf(afiTmp2.sFlightCategory));
                    tiBegin[1] = iIndexOpening;
                    tiEnd[1] = iIndexClosing;
                    //AddReclaimUsage(dtAllocation[0], 1, vmBaggageClaimVisualisation/*((ConditionnalFormatErrors)vmBaggageClaimVisualisation/*[0]* /.ConditionnalFormatClass[0])*/, afiTmp2.sFlightN, afiTmp2.iReclaim, iIndexOpening, iIndexClosing, iPartialClosing, alFlightCategories.IndexOf(afiTmp2.sFlightCategory));

                    /*End Bag Claim Visu*/

                    iIndexOpening = (int)((OverallTools.DataFunctions.MinuteDifference(dtBegin, afiTmp2.FirstBag)) / dStep);
                    iIndexClosing = (int)((OverallTools.DataFunctions.MinuteDifference(dtBegin, afiTmp2.LastPaxLeaving)) / dStep);
                    iClosingTmp = (int)((OverallTools.DataFunctions.MinuteDifference(dtBegin, afiTmp2.LastPaxLeaving) - 0.01) / dStep);
                    if (iIndexOpening >= dtBaggageClaimUtilisation.Rows.Count)
                        continue;
                    if (iIndexOpening < 0)
                        iIndexOpening = 0;
                    if ((iClosingTmp != iIndexClosing) && (iIndexOpening != iIndexClosing))
                        iIndexClosing = iClosingTmp;
                    if (iIndexClosing >= dtBaggageClaimUtilisation.Rows.Count)
                        iIndexClosing = dtBaggageClaimUtilisation.Rows.Count - 1;
                    for (i = iIndexOpening; i <= iIndexClosing; i++)
                    {
                        String sAncienneValeur = dtBaggageClaimUtilisation.Rows[i][iIndexOptimized].ToString();
                        dtBaggageClaimUtilisation.Rows[i][iIndexOptimized] = OverallTools.UpdateAllocation.traitementAllocation(sAncienneValeur, afiTmp2.sFlightN, false, "");
                        dtBaggageClaimUtilisation.Rows[i][iIndexOptimizedColumn] = (Int32)dtBaggageClaimUtilisation.Rows[i][iIndexOptimizedColumn] + 1;
                        ((ConditionnalFormatErrors)vmAllocationVisualisation.ConditionnalFormatClass[0]).setCondition(iIndexOptimized, i, Color.LightBlue);
                    }
                    /*Bag Claim Visu*/

                    /*if ((afiTmp2.iReclaim != -1) && (dtAllocation[2].Columns.Count <= afiTmp2.iReclaim * 4 - 2))
                        AddReclaim(dtAllocation[2], afiTmp2.iReclaim);*/
                    //AddReclaimUsage(dtAllocation[2], ((ConditionnalFormatErrors)vmBaggageClaimVisualisation[2].ConditionnalFormatClass[0]), afiTmp2.sFlightN, afiTmp2.iReclaim, iIndexOpening, iIndexClosing, iPartialClosing, alFlightCategories.IndexOf(afiTmp2.sFlightCategory));

                    tiBegin[2] = iIndexOpening;
                    tiEnd[2] = iIndexClosing;
                    AddReclaimUsage(dtAllocation[0],
                        vmBaggageClaimVisualisation/*((ConditionnalFormatErrors)vmBaggageClaimVisualisation/*[0]* /.ConditionnalFormatClass[0])*/,
                        afiTmp2.sFlightCategory + "_" + afiTmp2.sFlightN,
                        afiTmp2.iReclaim,
                        tiBegin,
                        tiEnd,
                        iPartialClosing,
                        alFlightCategories.IndexOf(afiTmp2.sFlightCategory));

                    iIndexOpening = (int)(afiTmp2.dSTA / dStep);

                    sTmp = dtAllocation[0].Rows[iIndexOpening][1].ToString();
                    if (sTmp.Length > 0)
                    {
                        sTmp = sTmp.Substring(0, sTmp.Length - 1);
                        sTmp += ",";
                    }
                    else
                    {
                        sTmp = "(";
                    }
                    sTmp += afiTmp2.sFlightN;
                    sTmp += ")";
                    dtAllocation[0].Rows[iIndexOpening][1] = sTmp;
                    //
                    /*End Bag Claim Visu*/
                }
                dtBaggageClaimUtilisation.AcceptChanges();
                dtAllocation[0].AcceptChanges();
                dtAllocation[1] = TransposeTable(dtAllocation[0]);
                dtAllocation[1].TableName = "Gantt_Transp";
                dtAllocation[1].AcceptChanges();
                return dtResult;
            }

            private int getReclaimBagLimitNb(DataTable reclaimLogDistribution,
                string flightCategory, double randomNb)
            {
                int limitNb = 0;
                if (reclaimLogDistribution != null
                    && reclaimLogDistribution.Columns.Contains(flightCategory)
                    && reclaimLogDistribution.Columns.Contains(GlobalNames.userAttributesReclaimLogValueColumnName))
                {
                    int flightCategoryColumnIndex = reclaimLogDistribution.Columns.IndexOf(flightCategory);
                    int valueColumnIndex = reclaimLogDistribution.Columns.IndexOf(GlobalNames.userAttributesReclaimLogValueColumnName);

                    List<DistributionValuePercentage> valuePercents = new List<DistributionValuePercentage>();
                    foreach (DataRow row in reclaimLogDistribution.Rows)
                    {
                        string value = row[valueColumnIndex].ToString();
                        double percentage = 0;
                        Double.TryParse(row[flightCategoryColumnIndex].ToString(), out percentage);
                        DistributionValuePercentage dvp = new DistributionValuePercentage(value, percentage);
                        valuePercents.Add(dvp);
                    }
                    valuePercents = valuePercents.OrderByDescending(o => o.percent).ToList();

                    string aquiredValue = "";
                    for (int i = 0; i < valuePercents.Count; i++)
                    {
                        DistributionValuePercentage dvp = valuePercents[i];
                        if (randomNb < (dvp.percent / 100))
                        {
                            aquiredValue = dvp.value;
                            break;
                        }
                    }
                    if (aquiredValue.Contains("-"))
                        aquiredValue = aquiredValue.Replace("-", "");
                    Int32.TryParse(aquiredValue, out limitNb);
                }
                return limitNb;
            }

            private class DistributionValuePercentage
            {
                public string value { get; set; }
                public double percent { get; set; }

                public DistributionValuePercentage(string _value, double _percent)
                {
                    value = _value;
                    percent = _percent;
                }
                public override string ToString()
                {
                    return "Value: " + value + "; Percent: " + percent;
                }
            }


            public static DataTable TransposeTable(DataTable dtTable)
            {
                DataTable dtResult = new DataTable(dtTable.TableName);
                dtResult.Columns.Add(dtTable.Columns[0].ColumnName, typeof(String));
                int i;
                for (i = 1; i < dtTable.Columns.Count; i++)
                {
                    dtResult.Rows.Add(new Object[] { dtTable.Columns[i].ColumnName });
                }
                foreach (DataRow drRow in dtTable.Rows)
                {
                    dtResult.Columns.Add(drRow[0].ToString(), typeof(String));
                    int iIndexColumn = dtResult.Columns.Count - 1;
                    for (i = 1; i < dtTable.Columns.Count; i++)
                    {
                        dtResult.Rows[i - 1][iIndexColumn] = drRow[i];
                    }
                }
                return dtResult;
            }
            private static void AddReclaim(DataTable dtTable, int iIndexReclaim)
            {
                char[] tcSuffixe = new char[] { 'a', 'b', 'c', 'd' };
                String[] tsSuffixe = new String[] { "Bag", "Pax", "Occupied" };
                int iStart = 1;
                if (!dtTable.Columns.Contains("Reclaim_" + iIndexReclaim.ToString() + "_" + tcSuffixe[0]))
                {
                    if (dtTable.Columns.Count < 2)
                        return;
                    if (dtTable.Columns.Count != 2)
                    {
                        String sTmp = dtTable.Columns[dtTable.Columns.Count - 1].ColumnName;
                        sTmp = sTmp.Substring(8, sTmp.Length - 8 - 2 - 9);
                        if (!Int32.TryParse(sTmp, out iStart))
                            return;
                        iStart++;
                    }
                    for (; iStart <= iIndexReclaim; iStart++)
                    {
                        for (int i = 0; i < tcSuffixe.Length; i++)
                        {
                            for (int j = 0; j < tsSuffixe.Length; j++)
                            {
                                dtTable.Columns.Add("Reclaim_" + iStart.ToString("00") + "_" + tcSuffixe[i] + "_" + tsSuffixe[j]);
                            }
                        }
                    }
                    return;
                }
            }



            private static void AddReclaimUsage(DataTable dtTable,
                VisualisationMode[] cfeErrors,
                String sFlightNumber,
                int iIndexReclaim,
                int[] tiStart,
                int[] tiEnd,
                int iMinus30,
                int iColor)
            {
                Color[][] tcCouleur = new Color[3][] {new Color[]{Color.FromArgb(0,176,240),Color.FromArgb(129,222,255)},
                                                       new Color[]{ Color.FromArgb(150,150,150),Color.FromArgb(150,150,150)},
                                                       new Color[] {Color.FromArgb(0,255,0),Color.FromArgb(204,255,204)}};
                int i;
                int k, j; int l;
                int iIndex = (iIndexReclaim - 1) * 12 + 2;
                for (i = 0; i < 4; i++)
                {
                    /*For each location available for each reclaim (4) we look if their is one totally empty on the area of the new flight.*/
                    for (j = 0; j < tiStart.Length; j++)
                    {
                        /*We check each of the 3 allocation, Pax, bag and total.*/
                        for (k = tiStart[j]; k <= tiEnd[j]; k++)
                        {
                            /*We start watching at the beginning of the allocation to the end of the allocation,
                             for each of the 3 types.*/
                            for (l = 0; l < 3; l++)
                            {
                                if (dtTable.Rows[k][iIndex + i * 3 + l].ToString() != "")
                                {
                                    break;
                                }
                            }
                            if (l < 3)
                                break;
                        }
                        if (k <= tiEnd[j])
                            break;
                    }
                    if (j == tiStart.Length)
                        break;
                }
                AddReclaimUsage(dtTable, iIndex + i * 3, cfeErrors, sFlightNumber, tiStart[0], tiEnd[0], iMinus30, tcCouleur[0]);
                AddReclaimUsage(dtTable, iIndex + i * 3 + 1, cfeErrors, sFlightNumber, tiStart[1], tiEnd[1], iMinus30, tcCouleur[1]);
                AddReclaimUsage(dtTable, iIndex + i * 3 + 2, cfeErrors, sFlightNumber, tiStart[2], tiEnd[2], iMinus30, tcCouleur[2]);
            }

            private static void AddReclaimUsage(DataTable dtTable,
                int iIndex,/*index in the table*/
                VisualisationMode[] cfeErrors,
                String sFlightNumber,
                int iIndexOpening,
                int iIndexClosing,
                int iMinus30,
                Color[] cColor)
            {
                int i;
                String sTmp;
                //int iIndex = iIndexReclaim * 12 - 10 + 4 * iIndexType;
                //int iIndexMax = iIndex + 3;
                /*for (i = iIndexOpening; i <= iIndexClosing; i++)
                {
                    sTmp = dtTable.Rows[i][iIndex].ToString();
                    if (sTmp != "")
                    {
                        if (iIndex >= dtTable.Columns.Count)
                            break;
                        if (iIndex == iIndexMax)
                            break;
                        iIndex++;
                        i = iIndexOpening;
                    }
                }*/
                /*if (iIndex >= dtTable.Columns.Count)
                    return;*/
                for (i = iIndexOpening; i <= iIndexClosing; i++)
                {
                    if ((i == iIndexOpening) || (i == iIndexClosing))
                    {
                        sTmp = dtTable.Rows[i][iIndex].ToString();
                        if (sTmp.Length > 0)
                        {
                            sTmp = sTmp.Substring(0, sTmp.Length - 1);
                            sTmp += ",";
                        }
                        else
                        {
                            if (i == iIndexOpening)
                                sTmp = "(";
                        }
                        sTmp += sFlightNumber;
                        if (i == iIndexClosing)
                            sTmp += ")";
                        dtTable.Rows[i][iIndex] = sTmp;
                    }
                    if (iMinus30 == i)
                    {
                        ((ConditionnalFormatErrors)cfeErrors[0].ConditionnalFormatClass[0]).setCondition(iIndex, i, cColor[1]);
                        ((ConditionnalFormatErrors)cfeErrors[1].ConditionnalFormatClass[0]).setCondition(i + 1, iIndex - 1, cColor[1]);
                        //cfeErrors.setCondition(i + 1, iIndex - 1, Color.Pink);
                    }
                    else
                    {
                        if (((ConditionnalFormatErrors)cfeErrors[1].ConditionnalFormatClass[0]).getColor(i + 1, iIndex - 1) == Color.White)
                        {
                            ((ConditionnalFormatErrors)cfeErrors[0].ConditionnalFormatClass[0]).setCondition(iIndex, i, cColor[0]);
                            ((ConditionnalFormatErrors)cfeErrors[1].ConditionnalFormatClass[0]).setCondition(i + 1, iIndex - 1, cColor[0]);
                            //                            cfeErrors.setCondition(i + 1, iIndex - 1, FonctionUtiles.getColor(iColor));
                        }
                    }
                }
            }

            #region Fonctions pour la génération du gantt en Xml
            public static void TestGenerateGanttXML(DataTable dtFPA, String sReclaimLogLocation, String sAllocationDelays, ArrayList ErrorList_)
            {
                // Ouverture du fichier de reclaim
                if (!File.Exists(sReclaimLogLocation))
                    return;
                DataTable dtOrigin = new DataTable("ReclaimLog");
                if (!OverallTools.FonctionUtiles.LectureFichier(dtOrigin, sReclaimLogLocation, "\t", ErrorList_))
                {
                    ErrorList_.Add("Err00166 : Unable to load ReclaimLog.txt.");
                    return;
                }

                // recherche des indexes de la table
                int iIndexFPAID = dtOrigin.Columns.IndexOf("FPA ID");
                int iIndexSTA = dtOrigin.Columns.IndexOf("STA");
                int iIndexOCT = dtOrigin.Columns.IndexOf("OCT");
                int iIndexEvent = dtOrigin.Columns.IndexOf("Event");
                int iIndexValue = dtOrigin.Columns.IndexOf("Minutes after STA");
                int iIndexReclaim = dtOrigin.Columns.IndexOf("#Reclaim");
                if ((iIndexFPAID == -1) ||
                    (iIndexSTA == -1) ||
                    (iIndexOCT == -1) ||
                    (iIndexEvent == -1) ||
                    (iIndexValue == -1))
                {
                    ErrorList_.Add("Err00167 : Wrong format for ReclaimLog.txt.");
                    return;
                }


                int iIndexFPATableID = dtFPA.Columns.IndexOf("ID");
                int iIndexFPATableDATE = dtFPA.Columns.IndexOf("DATE");
                int iIndexFPATableSTA = dtFPA.Columns.IndexOf("STA");
                int iIndexFPATableFC = dtFPA.Columns.IndexOf("FLIGHT CATEGORY");
                int iIndexFPATableTerminal = dtFPA.Columns.IndexOf("Reclaim Terminal");
                int iIndexFPATableBaggageClaim = dtFPA.Columns.IndexOf(GlobalNames.sFPA_Column_ReclaimObject);
                int iIndexFPATableFlightN = dtFPA.Columns.IndexOf("FLIGHT N");
                if ((iIndexFPATableID == -1) ||
                    (iIndexFPATableDATE == -1) ||
                    (iIndexFPATableSTA == -1) ||
                    (iIndexFPATableFC == -1) ||
                    (iIndexFPATableTerminal == -1) ||
                    (iIndexFPATableBaggageClaim == -1) ||
                    (iIndexFPATableFlightN == -1))
                {
                    ErrorList_.Add("Err00181 : Wrong format for FPATable for the calc for reclaim allocation.");
                    return;
                }




                SortedList<Int32, Double> slAllocatedTime = null;
                if (File.Exists(sAllocationDelays))
                {
                    DataTable dtTimeAllocation = new DataTable("Allocation");
                    if (OverallTools.FonctionUtiles.LectureFichier(dtTimeAllocation, sAllocationDelays, "\t", ErrorList_) &&
                        (dtTimeAllocation.Columns.Count == 2))
                    {
                        int iTmp;
                        Double dTmp;
                        slAllocatedTime = new SortedList<int, double>();
                        foreach (DataRow drLine in dtTimeAllocation.Rows)
                        {
                            if (!Int32.TryParse(drLine[0].ToString(), out iTmp))
                                continue;
                            if (!Double.TryParse(drLine[1].ToString(), out dTmp))
                                continue;
                            slAllocatedTime.Add(iTmp, dTmp);
                        }
                    }
                }







                #region foreach (DataRow drRow in dtOrigin.Rows)
                Hashtable htList = new Hashtable();
                foreach (DataRow drRow in dtOrigin.Rows)
                {
                    int iFPAID;
                    if (!Int32.TryParse(drRow[iIndexFPAID].ToString(), out iFPAID))
                    {
                        ErrorList_.Add("Err00168 : Unable to interpret the FPA ID " + drRow[iIndexFPAID].ToString() + ".");
                        continue;
                    }
                    ArrivalFlightInformation afiTmp;
                    if (htList.ContainsKey(iFPAID))
                    {
                        afiTmp = (ArrivalFlightInformation)htList[iFPAID];
                    }
                    else
                    {
                        afiTmp = new ArrivalFlightInformation();
                        afiTmp.iID = iFPAID;
                        if ((slAllocatedTime != null) && (slAllocatedTime.ContainsKey(iFPAID)))
                            afiTmp.dAllocatedTime = slAllocatedTime[iFPAID];
                        htList.Add(iFPAID, afiTmp);

                        if (!Double.TryParse(drRow[iIndexSTA].ToString(), out afiTmp.dSTA))
                        {
                            afiTmp.bValid = false;
                            ErrorList_.Add("Err00172 : Unable to interpret the STA " + drRow[iIndexSTA].ToString() + ".");
                            continue;
                        }
                    }
                    #region switch (drRow[iIndexEvent].ToString())
                    String sValue = drRow[iIndexEvent].ToString();
                    switch (sValue)
                    {
                        case ArrivalFlightInformation.sFirstBag:
                            if (!Double.TryParse(drRow[iIndexValue].ToString(), out afiTmp.dFirstBag))
                            {
                                afiTmp.bValid = false;
                                ErrorList_.Add("Err00169 : Unable to interpret the time for the First Baggage for the flight " + iFPAID.ToString() + ".");
                                continue;
                            }

                            if (!Double.TryParse(drRow[iIndexOCT].ToString(), out afiTmp.dOCTOpening))
                            {
                                afiTmp.bValid = false;
                                ErrorList_.Add("Err00170 : Unable to interpret the time for the opening time for the flight " + iFPAID.ToString() + ".");
                                continue;
                            }
                            if (iIndexReclaim != -1)
                            {
                                if (!Int32.TryParse(drRow[iIndexReclaim].ToString(), out afiTmp.iReclaim))
                                {
                                }
                            }

                            break;
                        case ArrivalFlightInformation.sFirstPaxEntry:
                            if (!Double.TryParse(drRow[iIndexValue].ToString(), out afiTmp.dFirstPaxEntry))
                            {
                                afiTmp.bValid = false;
                                ErrorList_.Add("Err00173 : Unable to interpret the time for the First passenger for the flight " + iFPAID.ToString() + ".");
                                continue;
                            }

                            if (!Double.TryParse(drRow[iIndexOCT].ToString(), out afiTmp.dOCTOpening))
                            {
                                afiTmp.bValid = false;
                                ErrorList_.Add("Err00174 : Unable to interpret the time for the opening time for the flight " + iFPAID.ToString() + ".");
                                continue;
                            }
                            break;
                        case ArrivalFlightInformation.sLastBag:
                            if (!Double.TryParse(drRow[iIndexValue].ToString(), out afiTmp.dLastBag))
                            {
                                afiTmp.bValid = false;
                                ErrorList_.Add("Err00175 : Unable to interpret the time for the last baggage for the flight " + iFPAID.ToString() + ".");
                                continue;
                            }

                            if (!Double.TryParse(drRow[iIndexOCT].ToString(), out afiTmp.dOCTClosing))
                            {
                                afiTmp.bValid = false;
                                ErrorList_.Add("Err00176 : Unable to interpret the time for the closing time for the flight " + iFPAID.ToString() + ".");
                                continue;
                            }
                            break;
                        case ArrivalFlightInformation.sLastPaxEntry:
                            if (!Double.TryParse(drRow[iIndexValue].ToString(), out afiTmp.dLastPaxEntry))
                            {
                                afiTmp.bValid = false;
                                ErrorList_.Add("Err00177 : Unable to interpret the time for the last passenger for the flight " + iFPAID.ToString() + ".");
                                continue;
                            }

                            if (!Double.TryParse(drRow[iIndexOCT].ToString(), out afiTmp.dOCTClosing))
                            {
                                afiTmp.bValid = false;
                                ErrorList_.Add("Err00178 : Unable to interpret the time for the closing time for the flight " + iFPAID.ToString() + ".");
                                continue;
                            }
                            break;
                        case ArrivalFlightInformation.sFirstPaxLeaving:
                            if (!Double.TryParse(drRow[iIndexValue].ToString(), out afiTmp.dFirstPaxLeaving))
                            {
                                afiTmp.bValid = false;
                                ErrorList_.Add("Err00179 : Unable to interpret the time for the first passenger leaving the baggage claim for the flight " + iFPAID.ToString() + ".");
                                continue;
                            }
                            break;
                        case ArrivalFlightInformation.sLastPaxLeaving:
                            if (!Double.TryParse(drRow[iIndexValue].ToString(), out afiTmp.dLastPaxLeaving))
                            {
                                afiTmp.bValid = false;
                                ErrorList_.Add("Err00180 : Unable to interpret the time for the last passenger leaving the baggage claim for the flight " + iFPAID.ToString() + ".");
                                continue;
                            }
                            break;
                        default:
                            if (sValue.StartsWith(ArrivalFlightInformation.sPartialBagEntry) &&
                               sValue.EndsWith(ArrivalFlightInformation.sPartialBagEntryEnd))
                            {
                                int iIndexBegin = ArrivalFlightInformation.sPartialBagEntry.Length;
                                int iFirstIndexOfEnd = sValue.LastIndexOf(ArrivalFlightInformation.sPartialBagEntryEnd);
                                String sIndex = sValue.Substring(iIndexBegin, iFirstIndexOfEnd - iIndexBegin);
                                int iValue;
                                if (!Int32.TryParse(sIndex, out iValue))
                                {
                                    afiTmp.bValid = false;
                                    ErrorList_.Add("Err00188 : Unable to interpret the remaining number of bags for the flight " + iFPAID.ToString() + ".");
                                    continue;
                                }
                                Double dValue;
                                if (!Double.TryParse(drRow[iIndexValue].ToString(), out dValue))
                                {
                                    afiTmp.bValid = false;
                                    ErrorList_.Add("Err00189 : Unable to interpret the time for the moment when there is only " + iValue + " baggage left on the baggage claim for the flight " + iFPAID.ToString() + ".");
                                    continue;
                                }
                                afiTmp.addPartialLeaving(iValue, dValue);
                            }
                            break;
                    }
                    #endregion
                }
                #endregion



                foreach (ArrivalFlightInformation afiTmp2 in htList.Values)
                {
                    if (!afiTmp2.bValid)
                        continue;
                    int iIndexLigneFPA = OverallTools.DataFunctions.indexLigne(dtFPA, iIndexFPATableID, afiTmp2.iID.ToString());
                    if (iIndexLigneFPA == -1)
                    {
                        ErrorList_.Add("Err00182 : Unable to find arrival flight " + afiTmp2.ToString() + " in the FPA table.");
                        continue;
                    }

                    afiTmp2.dtTime = OverallTools.DataFunctions.toDateTime(dtFPA.Rows[iIndexLigneFPA][iIndexFPATableDATE],
                                                                            dtFPA.Rows[iIndexLigneFPA][iIndexFPATableSTA]);
                    afiTmp2.sFlightN = dtFPA.Rows[iIndexLigneFPA][iIndexFPATableFlightN].ToString();
                    afiTmp2.sFlightCategory = dtFPA.Rows[iIndexLigneFPA][iIndexFPATableFC].ToString();
                    if (!Int32.TryParse(dtFPA.Rows[iIndexLigneFPA][iIndexFPATableTerminal].ToString(), out afiTmp2.iTerminalReclaim))
                    {
                        ErrorList_.Add("Err00183b : Unable to generate the results for the arrival flight " + afiTmp2.ToString());
                        continue;
                    }
                    if (afiTmp2.iReclaim == 0)
                    {
                        if (!Int32.TryParse(dtFPA.Rows[iIndexLigneFPA][iIndexFPATableBaggageClaim].ToString(), out afiTmp2.iReclaim))
                        {
                            ErrorList_.Add("Err00183c : Unable to generate the results for the arrival flight " + afiTmp2.ToString());
                            continue;
                        }
                        //                        afiTmp2.iReclaim = (Int32)dtFPA.Rows[iIndexLigneFPA][iIndexFPATableBaggageClaim];
                    }
                }

                XmlDocument xDoc = new XmlDocument();
                XmlNode xeRoot = GenerateReclaimGanttXML(htList, xDoc);
                xDoc.AppendChild(xeRoot);
                XmlWriter xr = new XmlTextWriter(@"C:\Documents and Settings\FLE\Mes documents\Projets\Gantt\input.xml", null);
                xDoc.WriteTo(xr);
                xr.Close();

            }
            public static XmlNode GenerateReclaimGanttXML(Hashtable htData, XmlDocument xDoc)
            {
                // xml main nodes
                XmlElement xeRoot = xDoc.CreateElement("root");
                xDoc.AppendChild(xeRoot);
                XmlElement xeTasks = xDoc.CreateElement("tasks");
                xeRoot.AppendChild(xeTasks);

                //Dictionary<int, ReclaimGanttXml> dReclaim = new Dictionary<int, ReclaimGanttXml>();
                SortedList<int, ReclaimGanttXml> sReclaim = new SortedList<int, ReclaimGanttXml>();

                // add all flight to the XmlReclaim obj
                foreach (ArrivalFlightInformation afiTmp in htData.Values)
                {
                    if (afiTmp.dLastBag == -1 || afiTmp.dLastPaxEntry == -1)
                        continue;

                    // create the reclaim element if doesn't exists
                    if (!sReclaim.ContainsKey(afiTmp.iReclaim))
                    {
                        ReclaimGanttXml afiToGantt = new ReclaimGanttXml(
                            xDoc,
                            GlobalNames.sFPA_Column_ReclaimObject + afiTmp.iReclaim);
                        sReclaim.Add(afiTmp.iReclaim, afiToGantt);
                    }
                    sReclaim[afiTmp.iReclaim].AddArrivalFlight(afiTmp);
                }

                // Convert all reclaim flight information to xml
                List<int> key = new List<int>(sReclaim.Keys);
                key.Sort();
                foreach (int itmp in key)
                //foreach (ReclaimGanttXml reclaim in sReclaim.Values)
                {
                    XmlElement xeReclaim = sReclaim[itmp].GetXmlGantt();
                    xeTasks.AppendChild(xeReclaim);
                }

                return xeRoot;
            }
            /// <summary>
            /// Class used to build the a reclaim task segment of a Gantt diagram in XML
            /// </summary>
            private class ReclaimGanttXml
            {
                /// <summary>
                /// Constructor
                /// </summary>
                /// <param name="xDoc"></param>
                /// <param name="name">Reclaim name in the Gantt diagram</param>
                public ReclaimGanttXml(XmlDocument xDoc, String name)
                {
                    this.xDoc = xDoc;
                    this.name = name;
                }

                /// <summary>
                /// Reclaim name in the Gantt diagram
                /// </summary>
                private String name;
                /// <summary>
                /// Reference document to create the Xml element
                /// </summary>
                private XmlDocument xDoc;
                /// <summary>
                /// Xml element that contain the subtasks element
                /// </summary>
                private XmlElement reclaimElt;
                /// <summary>
                /// Xml element that will contain all the pax, bag and optimization task
                /// </summary>
                private XmlElement subtasksElt;
                /// <summary>
                /// Xml element that will contain the optimization segment for preview when the reclaim is collapsed.
                /// </summary>
                private XmlElement segmentsElt;
                /// <summary>
                /// List of Arrival Flight Information
                /// </summary>
                private List<ArrivalFlightInformation> afis = new List<ArrivalFlightInformation>();

                /// <summary>
                /// Last date of the last entry in each segment doubloon
                /// </summary>

                #region XML elements name for Gantt diagram
                // name of the xml elements
                //String tasksName = "tasks";
                String taskName = "task";
                String subtasksName = "subtasks";
                String segmentsName = "segments";
                String segmentName = "segment";
                String startName = "start";
                String endName = "end";
                String colorName = "color";
                String leftTextName = "leftText";
                String middleTextName = "middleText";
                String drawComposedName = "drawComposed";

                // colors
                String paxColor = "00FF00";
                String bagColor = "AFEEEE";
                String optimisationColor = "BDBDBD";
                String reclaimColor = "FF8C00";

                // task name
                String paxTaskName = "Pax";
                String bagTaskName = "Bag";
                String optimizedTaskName = "Optimized";
                #endregion XML elements name

                /// <summary>
                /// Function to create the XML element according to the reclaim Gantt task
                /// </summary>
                private void CreateReclaimTask()
                {
                    // create task tag
                    reclaimElt = xDoc.CreateElement(taskName);
                    reclaimElt.SetAttribute("name", name);
                    // create subtasks tag
                    subtasksElt = xDoc.CreateElement(subtasksName);
                    reclaimElt.AppendChild(subtasksElt);
                    // create segments tag
                    segmentsElt = xDoc.CreateElement(segmentsName);
                    reclaimElt.AppendChild(segmentsElt);
                }

                /// <summary>
                /// Function to add a flight in the reclaim flight list
                /// </summary>
                /// <param name="afi"></param>
                internal void AddArrivalFlight(ArrivalFlightInformation afi)
                {
                    afis.Add(afi);
                }

                /// <summary>
                /// Create some list of 
                /// </summary>
                /// <returns></returns>
                private List<List<ArrivalFlightInformation>> DistributeFlight()
                {
                    // init list
                    afis.Sort(new PaxTraceAnalysis.ArrivalFlightInformation.ArrivalFlightInformationComparerType());
                    List<List<ArrivalFlightInformation>> flightDistri = new List<List<ArrivalFlightInformation>>();
                    flightDistri.Add(new List<ArrivalFlightInformation>());

                    // add each flight in one of the list
                    foreach (ArrivalFlightInformation afiTmp in afis)
                    {
                        bool isPlaced = false;
                        // try to add it in the existing list
                        foreach (List<ArrivalFlightInformation> flightList in flightDistri)
                        {
                            if (isPlaced)
                                continue;
                            ArrivalFlightInformation lastAfi;
                            if (flightList.Count == 0)
                            {
                                lastAfi = new ArrivalFlightInformation();
                                lastAfi.dtTime = DateTime.MinValue;
                                lastAfi.dLastPaxLeaving = 0;
                            }
                            else
                                lastAfi = flightList[flightList.Count - 1];
                            if (lastAfi.LastPaxLeaving < afiTmp.dtTime)
                            {
                                flightList.Add(afiTmp);
                                isPlaced = true;
                                continue;
                            }
                        }
                        // if there is no possible place, add a list
                        if (!isPlaced)
                        {
                            List<ArrivalFlightInformation> lst = new List<ArrivalFlightInformation>();
                            lst.Add(afiTmp);
                            flightDistri.Add(lst);
                        }
                    }

                    return flightDistri;
                }

                /// <summary>
                /// Create and return a Gantt diagram for the reclaim
                /// </summary>
                /// <param name="doc"></param>
                /// <returns>Created xml element</returns>
                internal XmlElement GetXmlGantt()
                {
                    CreateReclaimTask();
                    List<List<ArrivalFlightInformation>> flightDistrib = DistributeFlight();
                    foreach (List<ArrivalFlightInformation> flightList in flightDistrib)
                    {
                        if (flightList.Count == 0)
                            continue;

                        // create optimization "task" tag
                        XmlElement optimisationTask = xDoc.CreateElement(taskName);
                        optimisationTask.SetAttribute("name", optimizedTaskName);
                        subtasksElt.AppendChild(optimisationTask);
                        XmlElement optimisationSegs = xDoc.CreateElement(segmentsName);
                        optimisationTask.AppendChild(optimisationSegs);

                        // create the optgimization "subtasks" tag
                        XmlElement optiSubTask = xDoc.CreateElement(subtasksName);
                        optimisationTask.AppendChild(optiSubTask);

                        // create the pax "task" and "segments" tags
                        XmlElement paxTask = xDoc.CreateElement(taskName);
                        paxTask.SetAttribute("name", paxTaskName);
                        optiSubTask.AppendChild(paxTask);
                        XmlElement paxSeg = xDoc.CreateElement(segmentsName);
                        paxTask.AppendChild(paxSeg);

                        // create the bag "task" and "segments" tags
                        XmlElement bagTask = xDoc.CreateElement(taskName);
                        bagTask.SetAttribute("name", bagTaskName);
                        optiSubTask.AppendChild(bagTask);
                        XmlElement bagSeg = xDoc.CreateElement(segmentsName);
                        bagTask.AppendChild(bagSeg);

                        foreach (ArrivalFlightInformation afiTmp in flightList)
                        {
                            // add pax info to the found segment
                            XmlElement pax = xDoc.CreateElement(segmentName);
                            pax.SetAttribute(startName, afiTmp.FirstPaxEntryString);
                            pax.SetAttribute(endName, afiTmp.LastPaxEntryString);
                            pax.SetAttribute(colorName, paxColor);
                            pax.SetAttribute(leftTextName,
                                afiTmp.sFlightCategory + "_" + afiTmp.sFlightN);
                            paxSeg.AppendChild(pax);

                            // add bag info to the found segment
                            XmlElement bag = xDoc.CreateElement(segmentName);
                            bag.SetAttribute(startName, afiTmp.FirstBagString);
                            bag.SetAttribute(endName, afiTmp.LastBagString);
                            bag.SetAttribute(colorName, bagColor);
                            bag.SetAttribute(leftTextName,
                                afiTmp.sFlightCategory + "_" + afiTmp.sFlightN);
                            bagSeg.AppendChild(bag);

                            // add optimization info to the found segment
                            XmlElement optimisation = xDoc.CreateElement(segmentName);
                            optimisation.SetAttribute(startName, afiTmp.FirstBagString);
                            optimisation.SetAttribute(endName, afiTmp.LastPaxLeavingString);
                            optimisation.SetAttribute(colorName, optimisationColor);
                            optimisation.SetAttribute(drawComposedName, "true");
                            optimisation.SetAttribute(middleTextName, afiTmp.OccupationOptimized.ToString("F"));
                            optimisation.SetAttribute(leftTextName,
                                afiTmp.sFlightCategory + "_" + afiTmp.sFlightN);
                            optimisationSegs.AppendChild(optimisation);

                            // add optimization info to reclaim segments
                            XmlElement optimisation2 = optimisation.CloneNode(false) as XmlElement;
                            optimisation2.Attributes[colorName].Value = reclaimColor;
                            optimisation2.Attributes.Remove(optimisation2.Attributes[drawComposedName]);
                            optimisation2.Attributes.Remove(optimisation2.Attributes[middleTextName]);
                            optimisation2.Attributes.Remove(optimisation2.Attributes[leftTextName]);
                            segmentsElt.AppendChild(optimisation2);
                        }
                    }
                    return reclaimElt;
                }
            }
            #endregion Fonctions pour la génération du gantt en Xml

            #endregion

            #region Comparaison des objectifs et du réalisé.
            // >> Task #13206 Pax2Sim - Dynamic Analysis - Arrival Flight Statistics
            internal static Dictionary<int, ObjectifsComparaison> getArrivalStatisticsDictionary(Dictionary<Int32, PaxResultsStruct> htPax)
            {
                Dictionary<int, ObjectifsComparaison> results = new Dictionary<int, ObjectifsComparaison>();
                ObjectifsComparaison objectives;
                foreach (PaxResultsStruct paxResult in htPax.Values)
                {
                    if (paxResult.FPAId == 0)
                        continue;
                    objectives = null;
                    if (!results.ContainsKey(paxResult.FPAId))
                    {
                        objectives = new ObjectifsComparaison();
                        objectives.FPInformations = paxResult.FPAInformations;
                        results.Add(paxResult.FPAId, objectives);
                    }
                    else
                    {
                        objectives = results[paxResult.FPAId];
                    }
                    objectives.AddPax(paxResult);
                }
                return results;
            }

            private static int AddMissedArrivalPax(Dictionary<int, ObjectifsComparaison> arrivalStatsDictionary,
                DataTable dtPaxPlan, DataTable dtFPATable)
            {
                if (dtPaxPlan == null)
                    return -1;
                int iResult = 0;

                int iTransferValue, iFPA, PaxID;

                int iIndexPAXID = dtPaxPlan.Columns.IndexOf("PAX_ID");
                int iIndexFPA = dtPaxPlan.Columns.IndexOf("FPA_ID");
                int iIndexTransfer = dtPaxPlan.Columns.IndexOf("Transfer");

                if (iIndexPAXID == -1)
                    return -1;
                if (iIndexFPA == -1)
                    return -1;
                if (iIndexTransfer == -1)
                    return -1;

                ObjectifsComparaison objective;
                #region Boucle de parcours du Paxplan
                foreach (DataRow drLine in dtPaxPlan.Rows)
                {
                    PaxID = (int)drLine[iIndexPAXID];
                    iTransferValue = (int)drLine[iIndexTransfer];
                    iFPA = (int)drLine[iIndexFPA];
                    if (iFPA == 0)
                        continue;
                    if (arrivalStatsDictionary.ContainsKey(iFPA))
                    {
                        objective = arrivalStatsDictionary[iFPA];
                        if (!objective.ContainsPax(PaxID))
                        {
                            objective.AddMissingPax();
                            iResult++;
                        }
                    }
                    else
                    {
                        objective = new ObjectifsComparaison();
                        int iIndexD = getIndexRow(dtFPATable, iFPA);
                        if (iIndexD != -1)
                        {
                            objective.FPInformations = new PaxResultsStruct.FlightInformations(iFPA,
                                                                                (DateTime)dtFPATable.Rows[iIndexD][1],
                                                                                (TimeSpan)dtFPATable.Rows[iIndexD][2],
                                                                                dtFPATable.Rows[iIndexD][3].ToString(),
                                                                                dtFPATable.Rows[iIndexD][4].ToString(),
                                                                                dtFPATable.Rows[iIndexD][5].ToString(),
                                                                                dtFPATable.Rows[iIndexD][6].ToString());
                            arrivalStatsDictionary.Add(iFPA, objective);
                            objective.AddMissingPax();
                            iResult++;
                        }
                    }
                }
                #endregion

                return iResult;
            }
            // << Task #13206 Pax2Sim - Dynamic Analysis - Arrival Flight Statistics

            internal static Dictionary<int, ObjectifsComparaison> getDepartureStatistics(Dictionary<Int32, PaxResultsStruct> htPax/*, PaxResultsStruct.TraceFilter tfFilter*/)
            {
                Dictionary<int, ObjectifsComparaison> locResults = new Dictionary<int, ObjectifsComparaison>();
                ObjectifsComparaison ocComparaison;
                foreach (PaxResultsStruct prsTmp in htPax.Values)
                {/*
                    if (!prsTmp.CheckPaxIsValidForFilter(tfFilter))
                        continue;*/
                    if (prsTmp.FPDId == 0)
                        continue;
                    ocComparaison = null;
                    if (!locResults.ContainsKey(prsTmp.FPDId))
                    {
                        ocComparaison = new ObjectifsComparaison();
                        ocComparaison.FPInformations = prsTmp.FPDInformations;
                        locResults.Add(prsTmp.FPDId, ocComparaison);
                    }
                    else
                    {
                        ocComparaison = locResults[prsTmp.FPDId];
                    }
                    ocComparaison.AddPax(prsTmp);
                }
                return locResults;
            }

            //Dictionary<int,FPDObjectifsComparaison> 

            /// <summary>
            /// Add to the Dictionnary the passenger that appears in the paxplan, but that does not appears in the paxtrace.
            /// </summary>
            /// <param name="diocFlights"></param>
            /// <param name="dtPaxPlan"></param>
            /// <param name="dtFPDTable"></param>
            /// <returns></returns>
            private static int AddMissedPax(Dictionary<int, ObjectifsComparaison> diocFlights,
                                             DataTable dtPaxPlan,
                                             DataTable dtFPDTable)
            {
                if (dtPaxPlan == null)
                    return -1;
                int iResult = 0;

                int iTransferValue,/* iNbBags, iNbVisitors,*/ iFPD, /*iFPA,*/ iSelfCheckIn, PaxID;
                /*FlightStatistics fsTmp;*/


                int iIndexPAXID = dtPaxPlan.Columns.IndexOf("PAX_ID");
                int iIndexFPD = dtPaxPlan.Columns.IndexOf("FPD_ID");
                int iIndexTransfer = dtPaxPlan.Columns.IndexOf("Transfer");
                int iIndexSelfCheckIn = dtPaxPlan.Columns.IndexOf("Self CheckIn");
                if (iIndexPAXID == -1)
                    return -1;
                if (iIndexFPD == -1)
                    return -1;
                if (iIndexTransfer == -1)
                    return -1;
                if (iIndexSelfCheckIn == -1)
                    return -1;

                ObjectifsComparaison ocTmp;
                #region Boucle de parcours du Paxplan
                foreach (DataRow drLine in dtPaxPlan.Rows)
                {
                    PaxID = (int)drLine[iIndexPAXID];
                    iTransferValue = (int)drLine[iIndexTransfer];
                    iFPD = (int)drLine[iIndexFPD];
                    if (iFPD == 0)
                        continue;
                    iSelfCheckIn = (int)drLine[iIndexSelfCheckIn];
                    if (diocFlights.ContainsKey(iFPD))
                    {
                        ocTmp = diocFlights[iFPD];
                        if (!ocTmp.ContainsPax(PaxID))
                        {
                            ocTmp.AddMissingPax();
                            iResult++;
                        }
                    }
                    else
                    {
                        ocTmp = new ObjectifsComparaison();

                        int iIndexD = getIndexRow(dtFPDTable, iFPD);
                        if (iIndexD != -1)
                        {
                            ocTmp.FPInformations = new PaxResultsStruct.FlightInformations(iFPD,
                                                                                (DateTime)dtFPDTable.Rows[iIndexD][1],
                                                                                (TimeSpan)dtFPDTable.Rows[iIndexD][2],
                                                                                dtFPDTable.Rows[iIndexD][3].ToString(),
                                                                                dtFPDTable.Rows[iIndexD][4].ToString(),
                                                                                dtFPDTable.Rows[iIndexD][5].ToString(),
                                                                                dtFPDTable.Rows[iIndexD][6].ToString());
                            diocFlights.Add(iFPD, ocTmp);
                            ocTmp.AddMissingPax();
                            iResult++;
                        }
                    }
                }
                #endregion

                return iResult;
            }

            private static void AddOpeningClosingTimes(Dictionary<int, ObjectifsComparaison> diocFlights,
                                                      DataTable dtSimpleFPD)
            {
                int iIndexId = dtSimpleFPD.Columns.IndexOf("Id");
                int iIndexOpeningCI = dtSimpleFPD.Columns.IndexOf("OpeningCI");
                int iIndexClosingCI = dtSimpleFPD.Columns.IndexOf("ClosingCI");
                int iIndexOpeningBoardingGate = dtSimpleFPD.Columns.IndexOf("OpeningBoardGate");
                int iIndexClosingBoardingGate = dtSimpleFPD.Columns.IndexOf("ClosingBoardGate");

                if (iIndexId == -1)
                    return;
                if (iIndexOpeningCI == -1)
                    return;
                if (iIndexClosingCI == -1)
                    return;
                if (iIndexOpeningBoardingGate == -1)
                    return;
                if (iIndexClosingBoardingGate == -1)
                    return;

                ObjectifsComparaison ocTmp;

                foreach (DataRow drRow in dtSimpleFPD.Rows)
                {
                    int iKey = (int)drRow[iIndexId];
                    if (!diocFlights.ContainsKey(iKey))
                        continue;
                    ocTmp = diocFlights[iKey];
                    ocTmp.dOpeningCI = (int)drRow[iIndexOpeningCI];
                    ocTmp.dClosingCI = (int)drRow[iIndexClosingCI];
                    ocTmp.dOpeningBG = (int)drRow[iIndexOpeningBoardingGate];
                    ocTmp.dClosingBG = (int)drRow[iIndexClosingBoardingGate];
                }
            }

            private static void CalcStatistics(Dictionary<int, ObjectifsComparaison> diocFlights,
                                                    Double dMilleStone)
            {
                foreach (int iKey in diocFlights.Keys)
                {
                    diocFlights[iKey].CalcStatistics(dMilleStone);
                }
            }

            private static DataTable AnalyseObjectives(DataTable dtPaxPlan,
                                                    Dictionary<Int32, PaxResultsStruct> htPax,
                                                    DataTable dtFPD,
                                                    DataTable dtSimpleFPD,
                                                    DateTime dtEndSimulation,
                                                    Double dMilleStone,
                                                    out VisualisationMode vmAllocationVisualisation)
            {
                //vmAllocationVisualisation = new VisualisationMode(
                Dictionary<int, ObjectifsComparaison> locResults = getDepartureStatistics(htPax);
                AddMissedPax(locResults, dtPaxPlan, dtFPD);
                AddOpeningClosingTimes(locResults, dtSimpleFPD);
                CalcStatistics(locResults, dMilleStone);
                DataTable dtTable = ObjectifsComparaison.getResultTable("Departure Flight Statistics", dMilleStone);
                foreach (int iKey in locResults.Keys)
                {
                    dtTable.Rows.Add(locResults[iKey].getResults(dtEndSimulation));
                }
                dtTable = OverallTools.DataFunctions.sortTable(dtTable, dtTable.Columns[0].ColumnName);
                vmAllocationVisualisation = getVisualisationModeForObjectives(dtTable, dMilleStone);
                return dtTable;
            }
            private static VisualisationMode getVisualisationModeForObjectives(DataTable dtTable, Double dMilleStone)
            {
                VisualisationMode vmAllocationVisualisation = new VisualisationMode(false, false, false, null, new int[] { 0 });
                vmAllocationVisualisation.ShowRowHeader = true;
                vmAllocationVisualisation.FirstColumnInHeader = true;
                ConditionnalFormatErrors cfeErrors = new ConditionnalFormatErrors();
                vmAllocationVisualisation.ConditionnalFormatClass = new VisualisationMode.ConditionnalFormat[] { cfeErrors };
                List<int> alIndex = new List<int>();
                alIndex.Add(dtTable.Columns.IndexOf("CI Missed Pax"));
                alIndex.Add(dtTable.Columns.IndexOf("CI Stopped Pax"));
                alIndex.Add(dtTable.Columns.IndexOf("CI Pax arrived between " + dMilleStone.ToString() + " mn before closing and closing"));
                alIndex.Add(dtTable.Columns.IndexOf("CI Pax arrived after closing"));
                alIndex.Add(dtTable.Columns.IndexOf("CI Pax processed between " + dMilleStone.ToString() + " mn before closing and closing"));
                alIndex.Add(dtTable.Columns.IndexOf("BG Missed Pax"));
                alIndex.Add(dtTable.Columns.IndexOf("BG Stopped Pax"));
                alIndex.Add(dtTable.Columns.IndexOf("BG Pax arrived between " + dMilleStone.ToString() + " mn before closing and closing"));
                alIndex.Add(dtTable.Columns.IndexOf("BG Pax arrived after closing"));
                alIndex.Add(dtTable.Columns.IndexOf("BG Pax processed between " + dMilleStone.ToString() + " mn before closing and closing"));

                int iLastProcessedPax = dtTable.Columns.IndexOf("BG Last Processed Pax (min before closing)");

                for (int j = 0; j < alIndex.Count; j++)
                {
                    if (alIndex[j] == -1)
                    {
                        alIndex.RemoveAt(j);
                        j--;
                    }

                }
                for (int i = 0; i < dtTable.Rows.Count; i++)
                {
                    for (int j = 0; j < alIndex.Count; j++)
                    {
                        if ((int)dtTable.Rows[i][alIndex[j]] > 0)
                            cfeErrors.setCondition(alIndex[j], i, Color.Red);
                    }
                    if ((Double)dtTable.Rows[i][iLastProcessedPax] > dMilleStone)
                        cfeErrors.setCondition(iLastProcessedPax, i, Color.Green);
                    else if ((Double)dtTable.Rows[i][iLastProcessedPax] > 0)
                        cfeErrors.setCondition(iLastProcessedPax, i, Color.Orange);
                    else
                        cfeErrors.setCondition(iLastProcessedPax, i, Color.Red);
                }

                /*
                ArrayList alFlightCategories = new ArrayList();
                foreach (ArrivalFlightInformation afiTmp2 in htList.Values)
                {
                    if (!alFlightCategories.Contains(afiTmp2.sFlightCategory))
                        alFlightCategories.Add(afiTmp2.sFlightCategory);
                }
                alFlightCategories.Sort(new FonctionUtiles.ColumnsComparer());
                for (i = 0; i < alFlightCategories.Count; i++)
                {
                    dtBaggageClaimUtilisation.Rows[i][1] = alFlightCategories[i].ToString();
                    dtAllocation[0].Rows[i][1] = alFlightCategories[i].ToString();
                    ((ConditionnalFormatErrors)vmAllocationVisualisation.ConditionnalFormatClass[0]).setCondition(1, i, FonctionUtiles.getColor(i));
                    ((ConditionnalFormatErrors)vmBaggageClaimVisualisation[0].ConditionnalFormatClass[0]).setCondition(1, i, FonctionUtiles.getColor(i));
                    ((ConditionnalFormatErrors)vmBaggageClaimVisualisation[1].ConditionnalFormatClass[0]).setCondition(i + 1, 0, FonctionUtiles.getColor(i));
                }*/
                return vmAllocationVisualisation;
            }

            // >> Task #13206 Pax2Sim - Dynamic Analysis - Arrival Flight Statistics
            private DataTable getDepartureFlightStats(DataTable dtFPD, DataTable fpdPax, DataTable oldDepartureFlightStatistics,
                                                      DataTable dtSimpleFPD,
                                                      DataTable dtPaxPlan, Dictionary<Int32, PaxResultsStruct> htPax,
                                                      Double samplingStep, double[] levels,
                                                      string byAirline, string byFlightCategory, out Dictionary<int, List<double>> entryToGateTimesByFlightId)
            {
                entryToGateTimesByFlightId = new Dictionary<int, List<double>>();
                // >> Departure_Statistics, Arrival_Statistics segregate by Airline, Flight category               
                string tableName = VinciTools.DEPARTURE_STATS_TABLE_NAME;
                if (byAirline != null)
                {
                    tableName += "_" + byAirline;
                }
                if (byFlightCategory != null)
                {
                    tableName += "_" + byFlightCategory;
                }
                // << Departure_Statistics, Arrival_Statistics segregate by Airline, Flight category

                Dictionary<int, ObjectifsComparaison> locResults = getDepartureStatistics(htPax);
                AddMissedPax(locResults, dtPaxPlan, dtFPD);
                AddOpeningClosingTimes(locResults, dtSimpleFPD);
                CalcStatistics(locResults, samplingStep);

                DataTable departureStats = dtFPD.Copy();

                Dictionary<int, FlightPlanPax> flightPlanPaxDictionary = VinciTools.getDepartureFlightPlanPaxDictionary(fpdPax);

                #region column indexes
                // >> Departure_Statistics, Arrival_Statistics segregate by Airline, Flight category
                int airlineColumnIndex = departureStats.Columns.IndexOf(GlobalNames.sFPD_A_Column_AirlineCode);
                int flightCategoryColumnIndex = departureStats.Columns.IndexOf(GlobalNames.sFPD_A_Column_FlightCategory);
                // << Departure_Statistics, Arrival_Statistics segregate by Airline, Flight category

                int flightIdColumnIndex = departureStats.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID);
                int expectedPaxColumnIndex = departureStats.Columns.Count;
                departureStats.Columns.Add(FlightPlanPax.EXPECTED_PAX_PAX_COLUMN_NAME, typeof(Double));
                int generatedPaxColumnIndex = departureStats.Columns.Count;
                departureStats.Columns.Add(FlightPlanPax.GENERATED_PAX_PAX_COLUMN_NAME, typeof(Double));
                int originatingPaxColumnIndex = departureStats.Columns.Count;
                departureStats.Columns.Add(FlightPlanPax.ORIGINATING_PAX_PAX_COLUMN_NAME, typeof(Double));
                int transferringPaxColumnIndex = departureStats.Columns.Count;
                departureStats.Columns.Add(FlightPlanPax.TRANSFERRING_PAX_PAX_COLUMN_NAME, typeof(Double));
                int selfCIPaxColumnIndex = departureStats.Columns.Count;
                departureStats.Columns.Add(FlightPlanPax.SELF_CI_PAX_FPD_PAX_COLUMN_NAME, typeof(Double));

                int ciProcessedColumnIndex = departureStats.Columns.Count;
                departureStats.Columns.Add(VinciTools.CI_PROCESSED_PAX_DEPARTURE_STATS_COLUMN_NAME, typeof(Int32));
                int ciMissedPaxColumnIndex = departureStats.Columns.Count;
                departureStats.Columns.Add(VinciTools.CI_MISSED_PAX_DEPARTURE_STATS_COLUMN_NAME, typeof(Int32));
                int ciStoppedPaxColumnIndex = departureStats.Columns.Count;
                departureStats.Columns.Add(VinciTools.CI_STOPPED_PAX_DEPARTURE_STATS_COLUMN_NAME, typeof(Int32));
                int bgProcessedPaxColumnIndex = departureStats.Columns.Count;
                departureStats.Columns.Add(VinciTools.BG_PROCESSED_PAX_DEPARTURE_STATS_COLUMN_NAME, typeof(Int32));
                int bgMissedPaxColumnIndex = departureStats.Columns.Count;
                departureStats.Columns.Add(VinciTools.BG_MISSED_PAX_DEPARTURE_STATS_COLUMN_NAME, typeof(Int32));
                int bgStoppedPaxColumnIndex = departureStats.Columns.Count;
                departureStats.Columns.Add(VinciTools.BG_STOPPED_PAX_DEPARTURE_STATS_COLUMN_NAME, typeof(Int32));
                int sumOfMissedPaxColumnIndex = departureStats.Columns.Count;

                departureStats.Columns.Add(VinciTools.SUM_OF_MISSED_STATS_COLUMN_NAME, typeof(Int32));
                int percOfMissedPaxColumnIndex = departureStats.Columns.Count;
                departureStats.Columns.Add(VinciTools.PERC_OF_MISSED_STATS_COLUMN_NAME, typeof(Double));
                int sumOfStoppedPaxColumnIndex = departureStats.Columns.Count;
                departureStats.Columns.Add(VinciTools.SUM_OF_STOPPED_STATS_COLUMN_NAME, typeof(Int32));
                int percOfStoppedPaxColumnIndex = departureStats.Columns.Count;
                departureStats.Columns.Add(VinciTools.PERC_OF_STOPPED_STATS_COLUMN_NAME, typeof(Double));

                int istToBGMinValueColumnIndex = departureStats.Columns.Count;
                departureStats.Columns.Add(VinciTools.IST_TO_BG_MIN_VALUE_DEPARTURE_STATS_COLUMN_NAME, typeof(Double));
                int istToBGAvgValueColumnIndex = departureStats.Columns.Count;
                departureStats.Columns.Add(VinciTools.IST_TO_BG_AVG_VALUE_DEPARTURE_STATS_COLUMN_NAME, typeof(Double));
                int istToBGMaxValueColumnIndex = departureStats.Columns.Count;
                departureStats.Columns.Add(VinciTools.IST_TO_BG_MAX_VALUE_DEPARTURE_STATS_COLUMN_NAME, typeof(Double));

                int istToBGLevel1ValueColumnIndex = -1;
                int istToBGLevel2ValueColumnIndex = -1;
                int istToBGLevel3ValueColumnIndex = -1;
                if (levels.Length == 3)
                {
                    istToBGLevel1ValueColumnIndex = departureStats.Columns.Count;
                    departureStats.Columns.Add(levels[0] + VinciTools.PERC_VALUE_STATS_COLUMN_NAME_SUFFIX, typeof(Double));
                    istToBGLevel2ValueColumnIndex = departureStats.Columns.Count;
                    departureStats.Columns.Add(levels[1] + VinciTools.PERC_VALUE_STATS_COLUMN_NAME_SUFFIX, typeof(Double));
                    istToBGLevel3ValueColumnIndex = departureStats.Columns.Count;
                    departureStats.Columns.Add(levels[2] + VinciTools.PERC_VALUE_STATS_COLUMN_NAME_SUFFIX, typeof(Double));
                }
                #endregion

                Dictionary<int, FlightResourcesStats> flightResourcesStatsDictionary
                    = VinciTools.getDepartureFlightResourcesStatsDictionary(locResults, levels);

                if ((byAirline != null && airlineColumnIndex == -1)
                    || (byFlightCategory != null && flightCategoryColumnIndex == -1))
                {
                    departureStats.TableName = tableName;
                    departureStats.AcceptChanges();
                    return departureStats;
                }
                List<DataRow> rowsToRemove = new List<DataRow>();
                if (flightIdColumnIndex != -1)
                {
                    foreach (DataRow row in departureStats.Rows)
                    {
                        // >> Departure_Statistics, Arrival_Statistics segregate by Airline, Flight category                       
                        if (byAirline != null && (row[airlineColumnIndex] == null || byAirline != row[airlineColumnIndex].ToString()))
                        {
                            rowsToRemove.Add(row);
                            continue;
                        }
                        if (byFlightCategory != null && (row[flightCategoryColumnIndex] == null || byFlightCategory != row[flightCategoryColumnIndex].ToString()))
                        {
                            rowsToRemove.Add(row);
                            continue;
                        }
                        // << Departure_Statistics, Arrival_Statistics segregate by Airline, Flight category
                        int flightId = -1;
                        if (row[flightIdColumnIndex] != null
                            && Int32.TryParse(row[flightIdColumnIndex].ToString(), out flightId))
                        {
                            double nbPaxGenerated = -1;
                            if (flightPlanPaxDictionary.ContainsKey(flightId))
                            {
                                FlightPlanPax flightPlanPax = flightPlanPaxDictionary[flightId];
                                row[expectedPaxColumnIndex] = flightPlanPax.expectedPax;
                                row[generatedPaxColumnIndex] = flightPlanPax.generatedPax;
                                row[originatingPaxColumnIndex] = flightPlanPax.originatingPax;
                                row[transferringPaxColumnIndex] = flightPlanPax.transferringPax;
                                row[selfCIPaxColumnIndex] = flightPlanPax.selfCheckInPax;
                                nbPaxGenerated = flightPlanPax.generatedPax;
                            }
                            if (flightResourcesStatsDictionary.ContainsKey(flightId))
                            {
                                FlightResourcesStats flightResourcesStats
                                    = flightResourcesStatsDictionary[flightId];
                                row[ciProcessedColumnIndex] = flightResourcesStats.nbPaxProcessedAtCheckIn;
                                row[ciMissedPaxColumnIndex] = flightResourcesStats.nbPaxMissedAtCheckIn;
                                row[ciStoppedPaxColumnIndex] = flightResourcesStats.nbPaxStoppedAtCheckIn;

                                row[bgProcessedPaxColumnIndex] = flightResourcesStats.nbPaxProcessedAtBoardingGate;
                                row[bgMissedPaxColumnIndex] = flightResourcesStats.nbPaxMissedAtBoardingGate;
                                row[bgStoppedPaxColumnIndex] = flightResourcesStats.nbPaxStoppedAtBoardingGate;

                                row[sumOfMissedPaxColumnIndex] = flightResourcesStats.sumOfMissed;
                                row[sumOfStoppedPaxColumnIndex] = flightResourcesStats.sumOfStopped;
                                if (nbPaxGenerated > 0)
                                {
                                    row[percOfMissedPaxColumnIndex] = Math.Round(((double)flightResourcesStats.sumOfMissed / (double)nbPaxGenerated) * 100, 2);
                                    row[percOfStoppedPaxColumnIndex] = Math.Round(((double)flightResourcesStats.sumOfStopped / (double)nbPaxGenerated) * 100, 2);
                                }

                                row[istToBGMinValueColumnIndex] = Math.Round(flightResourcesStats.minutesFromEntryToBgMinValue, 2);
                                row[istToBGAvgValueColumnIndex] = Math.Round(flightResourcesStats.minutesFromEntryToBgAvgValue, 2);
                                row[istToBGMaxValueColumnIndex] = Math.Round(flightResourcesStats.minutesFromEntryToBgMaxValue, 2);

                                if (istToBGLevel1ValueColumnIndex != -1)
                                    row[istToBGLevel1ValueColumnIndex] = Math.Round(flightResourcesStats.minutesFromEntryToBgLevel1Value, 2);
                                if (istToBGLevel2ValueColumnIndex != -1)
                                    row[istToBGLevel2ValueColumnIndex] = Math.Round(flightResourcesStats.minutesFromEntryToBgLevel2Value, 2);
                                if (istToBGLevel3ValueColumnIndex != -1)
                                    row[istToBGLevel3ValueColumnIndex] = Math.Round(flightResourcesStats.minutesFromEntryToBgLevel3Value, 2);

                                if (!entryToGateTimesByFlightId.ContainsKey(flightId))
                                {
                                    entryToGateTimesByFlightId.Add(flightId, flightResourcesStats.minutesFromEntryToBg);
                                }
                            }
                        }
                    }
                }
                // >> Departure_Statistics, Arrival_Statistics segregate by Airline, Flight category
                foreach (DataRow row in rowsToRemove)
                {
                    departureStats.Rows.Remove(row);
                }
                // << Departure_Statistics, Arrival_Statistics segregate by Airline, Flight category
                departureStats.TableName = tableName;
                departureStats.AcceptChanges();
                return departureStats;
            }

            private DataTable getSegregatedTableByColumnIndexAndTargetValue(DataTable sourceTable, string columnName, string targetValue)
            {
                DataTable segregatedTable = null;
                if (sourceTable == null || sourceTable.Columns == null || sourceTable.Columns.IndexOf(columnName) == -1)
                {
                    return segregatedTable;
                }
                int columnIndex = sourceTable.Columns.IndexOf(columnName);
                segregatedTable = sourceTable.Copy();
                List<DataRow> rowsToDelete = new List<DataRow>();
                foreach (DataRow row in segregatedTable.Rows)
                {
                    if (row[columnIndex] == null || row[columnIndex].ToString() != targetValue)
                    {
                        rowsToDelete.Add(row);
                    }
                }
                foreach (DataRow row in rowsToDelete)
                {
                    segregatedTable.Rows.Remove(row);
                }
                segregatedTable.TableName += "_" + targetValue;
                segregatedTable.AcceptChanges();
                return segregatedTable;
            }

            private DataTable getArrivalFlightStats(DataTable dtFPA, DataTable fpaPax, DataTable dtSimpleFPD, DataTable dtPaxPlan,
                Dictionary<Int32, PaxResultsStruct> htPax, double samplingStep, double[] levels, out Dictionary<int, List<double>> gateToReclaimTimesByFlightId)
            {
                gateToReclaimTimesByFlightId = new Dictionary<int, List<double>>();

                DataTable arrivalStats = dtFPA.Copy();

                int flightIdColumnIndex = arrivalStats.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID);
                if (flightIdColumnIndex == -1)
                    return null;

                #region column indexes
                int expectedPaxColumnIndex = arrivalStats.Columns.Count;
                arrivalStats.Columns.Add(FlightPlanPax.EXPECTED_PAX_PAX_COLUMN_NAME, typeof(Double));
                int generatedPaxColumnIndex = arrivalStats.Columns.Count;
                arrivalStats.Columns.Add(FlightPlanPax.GENERATED_PAX_PAX_COLUMN_NAME, typeof(Double));
                int terminatingPaxColumnIndex = arrivalStats.Columns.Count;
                arrivalStats.Columns.Add(FlightPlanPax.TERMINATING_PAX_PAX_COLUMN_NAME, typeof(Double));
                int transferringPaxColumnIndex = arrivalStats.Columns.Count;
                arrivalStats.Columns.Add(FlightPlanPax.TRANSFERRING_PAX_PAX_COLUMN_NAME, typeof(Double));

                int arrGateProcessedColumnIndex = arrivalStats.Columns.Count;
                arrivalStats.Columns.Add(VinciTools.ARR_GATE_PROCESSED_PAX_STATS_COLUMN_NAME, typeof(Int32));
                int arrGateMissedPaxColumnIndex = arrivalStats.Columns.Count;
                arrivalStats.Columns.Add(VinciTools.ARR_GATE_MISSED_PAX_STATS_COLUMN_NAME, typeof(Int32));
                int arrGateStoppedPaxColumnIndex = arrivalStats.Columns.Count;
                arrivalStats.Columns.Add(VinciTools.ARR_GATE_STOPPED_PAX_STATS_COLUMN_NAME, typeof(Int32));
                int bagClaimProcessedPaxColumnIndex = arrivalStats.Columns.Count;
                arrivalStats.Columns.Add(VinciTools.BAG_CLAIM_PROCESSED_PAX_STATS_COLUMN_NAME, typeof(Int32));
                int bagClaimMissedPaxColumnIndex = arrivalStats.Columns.Count;
                arrivalStats.Columns.Add(VinciTools.BAG_CLAIM_MISSED_PAX_STATS_COLUMN_NAME, typeof(Int32));
                int bagClaimStoppedPaxColumnIndex = arrivalStats.Columns.Count;
                arrivalStats.Columns.Add(VinciTools.BAG_CLAIM_STOPPED_PAX_STATS_COLUMN_NAME, typeof(Int32));

                int sumOfMissedPaxColumnIndex = arrivalStats.Columns.Count;
                arrivalStats.Columns.Add(VinciTools.SUM_OF_MISSED_STATS_COLUMN_NAME, typeof(Int32));
                int percOfMissedPaxColumnIndex = arrivalStats.Columns.Count;
                arrivalStats.Columns.Add(VinciTools.PERC_OF_MISSED_STATS_COLUMN_NAME, typeof(Double));
                int sumOfStoppedPaxColumnIndex = arrivalStats.Columns.Count;
                arrivalStats.Columns.Add(VinciTools.SUM_OF_STOPPED_STATS_COLUMN_NAME, typeof(Int32));
                int percOfStoppedPaxColumnIndex = arrivalStats.Columns.Count;
                arrivalStats.Columns.Add(VinciTools.PERC_OF_STOPPED_STATS_COLUMN_NAME, typeof(Double));

                int istToBagClaimMinValueColumnIndex = arrivalStats.Columns.Count;
                arrivalStats.Columns.Add(VinciTools.IST_TO_BAG_CLAIM_MIN_VALUE_STATS_COLUMN_NAME, typeof(Double));
                int istToBagClaimAvgValueColumnIndex = arrivalStats.Columns.Count;
                arrivalStats.Columns.Add(VinciTools.IST_TO_BAG_CLAIM_AVG_VALUE_STATS_COLUMN_NAME, typeof(Double));
                int istToBagClaimMaxValueColumnIndex = arrivalStats.Columns.Count;
                arrivalStats.Columns.Add(VinciTools.IST_TO_BAG_CLAIM_MAX_VALUE_STATS_COLUMN_NAME, typeof(Double));

                int istToBagClaimLevel1ValueColumnIndex = -1;
                int istToBagClaimLevel2ValueColumnIndex = -1;
                int istToBagClaimLevel3ValueColumnIndex = -1;
                if (levels.Length == 3)
                {
                    istToBagClaimLevel1ValueColumnIndex = arrivalStats.Columns.Count;
                    arrivalStats.Columns.Add(levels[0] + VinciTools.PERC_VALUE_STATS_COLUMN_NAME_SUFFIX, typeof(Double));
                    istToBagClaimLevel2ValueColumnIndex = arrivalStats.Columns.Count;
                    arrivalStats.Columns.Add(levels[1] + VinciTools.PERC_VALUE_STATS_COLUMN_NAME_SUFFIX, typeof(Double));
                    istToBagClaimLevel3ValueColumnIndex = arrivalStats.Columns.Count;
                    arrivalStats.Columns.Add(levels[2] + VinciTools.PERC_VALUE_STATS_COLUMN_NAME_SUFFIX, typeof(Double));
                }
                #endregion

                Dictionary<int, ObjectifsComparaison> arrivalStatisticsDictionary = getArrivalStatisticsDictionary(htPax);
                AddMissedPax(arrivalStatisticsDictionary, dtPaxPlan, dtFPA);
                Dictionary<int, FlightPlanPax> flightPlanPaxDictionary = VinciTools.getArrivalFlightPlanPaxDictionary(fpaPax);
                Dictionary<int, FlightResourcesStats> flightResourcesStatsDictionary
                    = VinciTools.getArrivalFlightResourcesStatsDictionary(arrivalStatisticsDictionary, levels);

                foreach (DataRow row in arrivalStats.Rows)
                {
                    int flightId = -1;
                    if (row[flightIdColumnIndex] != null
                        && Int32.TryParse(row[flightIdColumnIndex].ToString(), out flightId))
                    {
                        double nbPaxGenerated = -1;
                        if (flightPlanPaxDictionary.ContainsKey(flightId))
                        {
                            FlightPlanPax flightPlanPax = flightPlanPaxDictionary[flightId];
                            row[expectedPaxColumnIndex] = flightPlanPax.expectedPax;
                            row[generatedPaxColumnIndex] = flightPlanPax.generatedPax;
                            row[transferringPaxColumnIndex] = flightPlanPax.transferringPax;
                            row[terminatingPaxColumnIndex] = flightPlanPax.terminatingPax;
                            nbPaxGenerated = flightPlanPax.generatedPax;
                        }
                        if (flightResourcesStatsDictionary.ContainsKey(flightId))
                        {
                            FlightResourcesStats flightResourcesStats
                                = flightResourcesStatsDictionary[flightId];
                            row[arrGateProcessedColumnIndex] = flightResourcesStats.nbPaxProcessedAtArrivalGate;
                            row[arrGateMissedPaxColumnIndex] = flightResourcesStats.nbPaxMissedAtArrivalGate;
                            row[arrGateStoppedPaxColumnIndex] = flightResourcesStats.nbPaxStoppedAtArrivalGate;

                            row[bagClaimProcessedPaxColumnIndex] = flightResourcesStats.nbPaxProcessedAtReclaim;
                            row[bagClaimMissedPaxColumnIndex] = flightResourcesStats.nbPaxMissedAtReclaim;
                            row[bagClaimStoppedPaxColumnIndex] = flightResourcesStats.nbPaxStoppedAtReclaim;

                            row[sumOfMissedPaxColumnIndex] = flightResourcesStats.sumOfMissed;
                            row[sumOfStoppedPaxColumnIndex] = flightResourcesStats.sumOfStopped;
                            if (nbPaxGenerated > 0)
                            {
                                row[percOfMissedPaxColumnIndex] = Math.Round(((double)flightResourcesStats.sumOfMissed / (double)nbPaxGenerated) * 100, 2);
                                row[percOfStoppedPaxColumnIndex] = Math.Round(((double)flightResourcesStats.sumOfStopped / (double)nbPaxGenerated) * 100, 2);
                            }

                            row[istToBagClaimMinValueColumnIndex] = Math.Round(flightResourcesStats.minutesFromArrGateToBagClaimMinValue, 2);
                            row[istToBagClaimAvgValueColumnIndex] = Math.Round(flightResourcesStats.minutesFromArrGateToBagClaimAvgValue, 2);
                            row[istToBagClaimMaxValueColumnIndex] = Math.Round(flightResourcesStats.minutesFromArrGateToBagClaimMaxValue, 2);

                            if (istToBagClaimLevel1ValueColumnIndex != -1)
                                row[istToBagClaimLevel1ValueColumnIndex] = Math.Round(flightResourcesStats.minutesFromArrGateToBagClaimLevel1Value, 2);
                            if (istToBagClaimLevel2ValueColumnIndex != -1)
                                row[istToBagClaimLevel2ValueColumnIndex] = Math.Round(flightResourcesStats.minutesFromArrGateToBagClaimLevel2Value, 2);
                            if (istToBagClaimLevel3ValueColumnIndex != -1)
                                row[istToBagClaimLevel3ValueColumnIndex] = Math.Round(flightResourcesStats.minutesFromArrGateToBagClaimLevel3Value, 2);

                            if (!gateToReclaimTimesByFlightId.ContainsKey(flightId))
                            {
                                gateToReclaimTimesByFlightId.Add(flightId, flightResourcesStats.minutesFromArrGateToBagClaim);
                            }
                        }
                    }
                }

                arrivalStats.TableName = VinciTools.ARRIVAL_STATS_TABLE_NAME;
                return arrivalStats;
            }
            // << Task #13206 Pax2Sim - Dynamic Analysis - Arrival Flight Statistics

            // >> Departure_Statistics, Arrival_Statistics segregate by Airline, Flight category
            private DataTable getSegregatedStatisticTable(Dictionary<string, DataTable> source, DataTable mainStatisticsTable, string segregationCode,
                Dictionary<int, List<double>> timesByFlightId)
            {
                if (mainStatisticsTable == null)
                {
                    return null;
                }
                int flightIdColumnIndex = mainStatisticsTable.Columns.IndexOf(GlobalNames.sFPD_A_Column_ID);
                int startSourceColumnIndex = mainStatisticsTable.Columns.IndexOf(FlightPlanPax.EXPECTED_PAX_PAX_COLUMN_NAME);//"Expected Pax");
                int endSourceColumnIndex = mainStatisticsTable.Columns.Count - 3;
                if (startSourceColumnIndex == -1 || startSourceColumnIndex > endSourceColumnIndex
                    || flightIdColumnIndex == -1)
                {
                    return null;
                }
                string tableName = mainStatisticsTable.TableName + "_by " + segregationCode;
                DataTable segregatedStatisticsTable = new DataTable(tableName);
                segregatedStatisticsTable.Columns.Add("Segregate by", typeof(String));
                for (int i = startSourceColumnIndex; i < endSourceColumnIndex; i++)
                {
                    DataColumn sourceColumn = mainStatisticsTable.Columns[i];
                    segregatedStatisticsTable.Columns.Add(sourceColumn.ColumnName, typeof(Double));
                }
                foreach (KeyValuePair<string, DataTable> pair in source)
                {
                    DataRow row = segregatedStatisticsTable.NewRow();
                    row["Segregate by"] = pair.Key;
                    DataTable segregatedTable = pair.Value;
                    for (int i = startSourceColumnIndex; i < endSourceColumnIndex; i++)
                    {
                        string columnName = segregatedTable.Columns[i].ColumnName;
                        int resultTableColumnIndex = segregatedStatisticsTable.Columns.IndexOf(columnName);
                        if (resultTableColumnIndex == -1)
                        {
                            continue;
                        }
                        if (columnName == VinciTools.PERC_OF_MISSED_STATS_COLUMN_NAME || columnName == VinciTools.PERC_OF_STOPPED_STATS_COLUMN_NAME)//"% of Missed" || columnName == "% of Stopped")
                        {
                            continue;
                        }
                        if (columnName == VinciTools.IST_TO_BG_MIN_VALUE_DEPARTURE_STATS_COLUMN_NAME//"IST to Boarding Gate Min Value (min)"
                            || columnName == VinciTools.IST_TO_BAG_CLAIM_MIN_VALUE_STATS_COLUMN_NAME)//"IST to Bagage Claim Min Value (min)")
                        {
                            double min = DataFunctions.getMinValue(segregatedTable, i);
                            row[resultTableColumnIndex] = min;
                        }
                        else if (columnName == VinciTools.IST_TO_BG_AVG_VALUE_DEPARTURE_STATS_COLUMN_NAME//"IST to Boarding Gate Avg Value (min)"
                            || columnName == VinciTools.IST_TO_BAG_CLAIM_AVG_VALUE_STATS_COLUMN_NAME)//"IST to Bagage Claim Avg Value (min)")
                        {
                            double avg = DataFunctions.getAvgValue(segregatedTable, i);
                            row[resultTableColumnIndex] = avg;
                        }
                        else if (columnName == VinciTools.IST_TO_BG_MAX_VALUE_DEPARTURE_STATS_COLUMN_NAME//"IST to Boarding Gate Max Value (min)"
                            || columnName == VinciTools.IST_TO_BAG_CLAIM_MAX_VALUE_STATS_COLUMN_NAME)//"IST to Bagage Claim Max Value (min)")
                        {
                            double max = DataFunctions.getMaxValue(segregatedTable, i);
                            row[resultTableColumnIndex] = max;
                        }
                        else
                        {
                            double sum = DataFunctions.getSumByTableColumn(segregatedTable, i);
                            row[resultTableColumnIndex] = sum;
                        }
                    }
                    /*
                    List<double> timesBySegregationCategory = new List<double>();
                    foreach (DataRow sourceRow in segregatedTable.Rows)
                    {
                        int flightId = -1;
                        if (row[flightIdColumnIndex] == null || !Int32.TryParse(row[flightIdColumnIndex].ToString(), out flightId))
                        {
                            continue;
                        }
                        if (timesByFlightId.ContainsKey(flightId))
                        {
                            timesBySegregationCategory.AddRange(timesByFlightId[flightId]);
                        }
                    }
                    timesBySegregationCategory.Sort();
                    */
                    segregatedStatisticsTable.Rows.Add(row);
                }
                int generatedColumnIndex = segregatedStatisticsTable.Columns.IndexOf(FlightPlanPax.GENERATED_PAX_PAX_COLUMN_NAME);//"Generated Pax");
                int missedColumnIndex = segregatedStatisticsTable.Columns.IndexOf(VinciTools.SUM_OF_MISSED_STATS_COLUMN_NAME);//"Sum of Missed");
                int stoppedColumnIndex = segregatedStatisticsTable.Columns.IndexOf(VinciTools.SUM_OF_STOPPED_STATS_COLUMN_NAME);//"Sum of Stopped");

                int percMissedColumnIndex = segregatedStatisticsTable.Columns.IndexOf(VinciTools.PERC_OF_MISSED_STATS_COLUMN_NAME);//"% of Missed");
                int percStoppedColumnIndex = segregatedStatisticsTable.Columns.IndexOf(VinciTools.PERC_OF_STOPPED_STATS_COLUMN_NAME);//"% of Stopped");
                if (generatedColumnIndex != -1 && missedColumnIndex != -1 && stoppedColumnIndex != -1
                    && percMissedColumnIndex != -1 && percStoppedColumnIndex != -1)
                {
                    foreach (DataRow row in segregatedStatisticsTable.Rows)
                    {
                        double generatedPax = -1;
                        double missedPax = -1;
                        double stoppedPax = -1;
                        if (row[generatedColumnIndex] != null && Double.TryParse(row[generatedColumnIndex].ToString(), out generatedPax))
                        {
                            if (generatedPax == 0)
                            {
                                row[percMissedColumnIndex] = 0;
                                row[percStoppedColumnIndex] = 0;
                            }
                            else
                            {
                                if (row[missedColumnIndex] != null && Double.TryParse(row[missedColumnIndex].ToString(), out missedPax))
                                {
                                    row[percMissedColumnIndex] = Math.Round((missedPax / generatedPax) * 100, 2);
                                }
                                if (row[stoppedColumnIndex] != null && Double.TryParse(row[stoppedColumnIndex].ToString(), out stoppedPax))
                                {
                                    row[percStoppedColumnIndex] = Math.Round((stoppedPax / generatedPax) * 100, 2);
                                }
                            }
                        }

                    }
                }
                return segregatedStatisticsTable;
            }
            // << Departure_Statistics, Arrival_Statistics segregate by Airline, Flight category
            #endregion
        }
        #endregion

        #region La classe ResultFunctions
        public class ResultFunctions
        {
            #region La fonction GenerateDistribution)
            /// <summary>
            /// Function which analyse the content of the Hashtable and return a table with the distribution
            /// of the values.
            /// </summary>
            /// <param name="NameResult">The return table name</param>
            /// <param name="alValues">The values to analyse</param>
            /// <param name="dStep">The analyse step</param>
            /// <param name="iNbClasses">The number of rows</param>
            /// <param name="sUnit">The name of the first column</param>
            /// <param name="Columns">The names of the columns</param>
            /// <param name="dtStatistics">A datable where store the statistics of the distribution</param>
            /// <returns>Return a table which contain the distribution</returns>
            public static DataTable GenerateDistribution(String NameResult,
                                                         ArrayList alValues,
                                                         Double dStep,
                                                         int iNbClasses,
                                                         Double dStart,
                                                         String sUnit,
                                                         String[] Columns,
                                                         Double[] tdLevels,
                                                         DataTable dtStatistics)
            {
                DataTable dtResult = BuildClassTable(NameResult, dStep, iNbClasses, dStart, sUnit, Columns);
                if (dtResult == null)
                    return null;
                Double dMin = 0, dMax = 0, dMean = 0;
                // << Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                //Remove the negative values: negative values might occur when doing the stat to Chute
                /*
                ArrayList negativeValuesList = new ArrayList();
                foreach (Double value in alValues)
                {
                    if (value < 0)
                        negativeValuesList.Add(value);
                }
                foreach (Double negativeValue in negativeValuesList)
                {
                    if (alValues.Contains(negativeValue))
                        alValues.Remove(negativeValue);
                }*/
                // >> Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                if (alValues.Count > 0)
                    dMin = (Double)alValues[0];
                foreach (Double dValue in alValues)
                {
                    dMean += dValue;
                    if (dMin > dValue)
                        dMin = dValue;
                    if (dMax < dValue)
                        dMax = dValue;

                    int iIndex = DetermineClass(dValue, dStep, iNbClasses);
                    if (iIndex < 0)
                        continue;
                    dtResult.Rows[iIndex][1] = (int)dtResult.Rows[iIndex][1] + 1;
                }

                if (dtStatistics != null)// && !NameResult.Contains("Recirculation")) //???   // << Task #7530 Analyze Bag Trace module - Recirculation statistics
                {
                    int percentOfGlobalColumnIndex = dtStatistics.Columns.IndexOf(GlobalNames.BHS_STATISTICS_TABLE_PERCENT_OF_GLOBAL_COLUMN_NAME);

                    if (percentOfGlobalColumnIndex == -1)
                    {
                        if (alValues.Count > 0)
                            dMean = dMean / alValues.Count;
                        double dFirstLevel = 0, dSecondLevel = 0, dThirdLevel = 0;
                        if (tdLevels != null)
                        {
                            if (alValues.Count >= 2)
                            {
                                alValues.Sort();
                                dFirstLevel = getLevelValue(alValues, tdLevels[0]);
                                dSecondLevel = getLevelValue(alValues, tdLevels[1]);
                                dThirdLevel = getLevelValue(alValues, tdLevels[2]);
                            }
                        }
                        dtStatistics.Rows.Add(new Object[] { NameResult, alValues.Count, Math.Round(dMin, 1), Math.Round(dMean, 1), Math.Round(dMax, 1), Math.Round(dFirstLevel, 2), Math.Round(dSecondLevel, 2), Math.Round(dThirdLevel, 2) });
                    }
                    else
                    {
                        // >> Task #11030 Pax2Sim - BHS analysis - HBS extended statistics
                        if (alValues.Count > 0)
                            dMean = dMean / alValues.Count;

                        double dFirstLevel = 0, dSecondLevel = 0, dThirdLevel = 0;
                        double totalBags = 0;
                        double percentOfGlobal = -1;

                        if (tdLevels != null)
                        {
                            if (alValues.Count >= 2)
                            {
                                alValues.Sort();
                                dFirstLevel = getLevelValue(alValues, tdLevels[0]);
                                dSecondLevel = getLevelValue(alValues, tdLevels[1]);
                                dThirdLevel = getLevelValue(alValues, tdLevels[2]);
                            }
                        }

                        if (NameResult.EndsWith(GlobalNames.BHS_STATISTICS_GLOBAL_RESULTS_TAG_NAME))    // >> _Times statistics - standard including MES
                        {
                            percentOfGlobal = 100;
                        }
                        else
                        {
                            totalBags = getGlobalBagsNumberFromBHSStatisticTable(dtStatistics);

                            if (totalBags != -1)
                            {
                                if (alValues.Count == 0)
                                {
                                    percentOfGlobal = 0;
                                }
                                else
                                {
                                    if (totalBags > 0)
                                    {
                                        double currentNbOfBags = (double)alValues.Count;
                                        percentOfGlobal = (currentNbOfBags / totalBags) * 100;
                                    }
                                }
                            }
                        }

                        dtStatistics.Rows
                            .Add(new Object[] { NameResult, alValues.Count, Math.Round(percentOfGlobal, 2),
                                Math.Round(dMin, 1), Math.Round(dMean, 1), Math.Round(dMax, 1),
                                Math.Round(dFirstLevel, 2), Math.Round(dSecondLevel, 2), Math.Round(dThirdLevel, 2) });
                        // << Task #11030 Pax2Sim - BHS analysis - HBS extended statistics
                    }
                }
                //On calcul les pourcentages et le cumul des pourcentages.
                dtResult.Columns.Add("%_" + dtResult.Columns[1].ColumnName, typeof(Double));
                dtResult.Columns.Add("%Cumul_" + dtResult.Columns[1].ColumnName, typeof(Double));
                int iNbBaggage = alValues.Count;
                Double cumul = 0;
                foreach (DataRow drTheLine in dtResult.Rows)
                {
                    if (iNbBaggage == 0)
                    {
                        drTheLine[2] = 0;
                        drTheLine[3] = 0;
                    }
                    else
                    {
                        drTheLine[2] = Math.Round(((float)((int)drTheLine[1]) / (float)(iNbBaggage)) * 100, 3);
                        cumul += (Double)drTheLine[2];
                        drTheLine[2] = Math.Round((Double)drTheLine[2], 2);
                        drTheLine[3] = Math.Round(cumul, 2);
                    }
                }
                dtResult.AcceptChanges();
                return dtResult;
            }

            // >> Task #11030 Pax2Sim - BHS analysis - HBS extended statistics
            public static double getGlobalBagsNumberFromBHSStatisticTable(DataTable statisticTable)
            {
                double totalBags = -1;

                if (statisticTable != null && statisticTable.Rows != null && statisticTable.Columns != null)
                {
                    int typeColumnIndex = statisticTable.Columns.IndexOf(GlobalNames.BHS_STATISTICS_TABLE_TYPE_COLUMN_NAME);
                    int nbBagsColumnIndex = statisticTable.Columns.IndexOf(GlobalNames.BHS_STATISTICS_TABLE_NB_BAGS_COLUMN_NAME);

                    if (typeColumnIndex != -1 && nbBagsColumnIndex != -1)
                    {
                        for (int i = statisticTable.Rows.Count - 1; i >= 0; i--)
                        {
                            DataRow row = statisticTable.Rows[i];

                            if (row[typeColumnIndex] != null
                                && row[typeColumnIndex].ToString().EndsWith(GlobalNames.BHS_STATISTICS_GLOBAL_RESULTS_TAG_NAME))    // >> _Times statistics - standard including MES
                            {
                                if (row[nbBagsColumnIndex] != null
                                    && Double.TryParse(row[nbBagsColumnIndex].ToString(), out totalBags))
                                {
                                    return totalBags;
                                }
                            }
                        }
                    }
                }

                return totalBags;
            }
            // << Task #11030 Pax2Sim - BHS analysis - HBS extended statistics

            public static int DetermineClass(Double dValue, Double dPas, int iNbMaxClass)
            {
                //05/11/2009 - Modification orientation des inclusions/exclusions ([...[ ==> ]...])
                /*int iClass = (int)((dValue + dPas) / dPas);
                if (iClass < 0)
                    return 0;
                if (iClass > iNbMaxClass)
                    return iNbMaxClass;
                return iClass;*/
                if (dPas == 0)
                    return 0;
                Double dClass = (dValue + dPas) / dPas;
                if (dClass <= 0)
                    return 0;
                if (dClass > iNbMaxClass)
                    return iNbMaxClass;
                if (((int)dClass) == dClass)
                    return (int)dClass - 1;
                return (int)dClass;
            }

            // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
            public static List<Double> truncateHighestValuesFromListByPercent(List<Double> list, Double percent)
            {
                List<Double> truncatedList = new List<Double>();

                if (list == null || list.Count == 0 || percent < 0)
                    return truncatedList;

                list.Sort();
                list.Reverse();

                if (percent > 100)
                    return list;

                int index = (int)(list.Count * percent / 100.0f);
                if (index >= list.Count)
                    return list;

                for (int i = 0; i < index; i++)
                    truncatedList.Add(list[i]);

                return truncatedList;
            }

            public static List<Double> getTruncatedListByPercent(List<Double> list, Double percent)
            {
                List<Double> truncatedList = new List<Double>();

                if (list == null || list.Count == 0 || percent < 0)
                    return truncatedList;

                list.Sort();

                if (percent > 100)
                    return list;

                int index = (int)(list.Count * percent / 100.0f);
                if (index >= list.Count)
                    return list;

                for (int i = 0; i < index; i++)
                    truncatedList.Add(list[i]);

                return truncatedList;
            }
            public static List<PaxTraceAnalysis.PaxResultsStruct> getTruncatedListByPercent(List<PaxTraceAnalysis.PaxResultsStruct> list,
                Double percent, String deskName)
            {
                List<PaxTraceAnalysis.PaxResultsStruct> truncatedList = new List<PaxTraceAnalysis.PaxResultsStruct>();

                if (list == null || list.Count == 0 || percent < 0)
                    return truncatedList;

                list.Sort(
                    delegate (PaxTraceAnalysis.PaxResultsStruct p1, PaxTraceAnalysis.PaxResultsStruct p2)
                    {
                        double p1DeskArrivalTime = 0;
                        double p2DeskArrivalTime = 0;

                        foreach (PaxTraceAnalysis.PaxResultsStruct.paxTravelData p1TravelData in p1.PaxTravel)
                        {
                            if (p1TravelData.Desk.Equals(deskName))
                            {
                                p1DeskArrivalTime = p1TravelData.ArrivalTime;
                                break;
                            }
                        }
                        foreach (PaxTraceAnalysis.PaxResultsStruct.paxTravelData p2TravelData in p2.PaxTravel)
                        {
                            if (p2TravelData.Desk.Equals(deskName))
                            {
                                p2DeskArrivalTime = p2TravelData.ArrivalTime;
                                break;
                            }
                        }
                        return p1DeskArrivalTime.CompareTo(p2DeskArrivalTime);
                    }
                );

                if (percent > 100)
                    return list;

                int index = (int)(list.Count * percent / 100.0f);
                if (index >= list.Count)
                    return list;

                for (int i = 0; i < index; i++)
                    truncatedList.Add(list[i]);

                return truncatedList;
            }
            public static List<PaxTraceAnalysis.PaxTravelInfoForResource> getTruncatedListByPercent(List<PaxTraceAnalysis.PaxTravelInfoForResource> list,
                Double percent)
            {
                List<PaxTraceAnalysis.PaxTravelInfoForResource> truncatedList = new List<PaxTraceAnalysis.PaxTravelInfoForResource>();

                if (list == null || list.Count == 0 || percent < 0)
                    return truncatedList;

                list.Sort(
                    delegate (PaxTraceAnalysis.PaxTravelInfoForResource p1, PaxTraceAnalysis.PaxTravelInfoForResource p2)
                    {
                        return p1.dwellTime.CompareTo(p2.dwellTime);
                    }
                );

                if (percent > 100)
                    return list;

                int index = (int)(list.Count * percent / 100.0f);
                if (index >= list.Count)
                    return list;

                for (int i = 0; i < index; i++)
                    truncatedList.Add(list[i]);

                return truncatedList;
            }
            /// <summary>
            /// Only for arraylists containing Points
            /// </summary>            
            public static ArrayList getTruncatedListByPercent(List<PointF> list, Double percent)
            {
                ArrayList truncatedList = new ArrayList();

                if (list == null || list.Count == 0 || percent < 0)
                    return truncatedList;

                list.Sort(
                    delegate (PointF p1, PointF p2)
                    {
                        return p1.Y.CompareTo(p2.Y);
                    });

                int index = (int)(list.Count * percent / 100.0f);
                if (index >= list.Count)
                    index = list.Count;

                for (int i = 0; i < index; i++)
                    truncatedList.Add(list[i]);

                return truncatedList;
            }
            // << Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent

            public static Double getLevelValue(List<Double> ldList, Double dPercent)
            {
                if (ldList.Count == 0)
                    return 0;
                if (dPercent <= 0)
                    return ldList[0];
                int iIndex = (int)Math.Round(ldList.Count * dPercent / 100.0f);
                if (iIndex >= ldList.Count)
                    iIndex = ldList.Count - 1;
                return ldList[iIndex];
            }
            public static Double getLevelValue(ArrayList alTimes, Double dPercent)
            {
                double value;
                if (dPercent <= 0)
                {
                    Double.TryParse(alTimes[0].ToString(), out value);
                    return value;
                }
                int iIndex = (int)Math.Round(alTimes.Count * dPercent / 100.0f);
                if (iIndex >= alTimes.Count)
                    Double.TryParse(alTimes[alTimes.Count - 1].ToString(), out value);
                else
                    Double.TryParse(alTimes[iIndex].ToString(), out value);
                return value;
            }

            /// <summary>
            /// Fonction qui permet de connaître l'index de la première valeur non égale à 0 de la liste.
            /// </summary>
            /// <param name="alTimes"></param>
            /// <param name="dPercent"></param>
            /// <returns></returns>
            public static int getLowLevelValue(ArrayList alTimes, Double dPercent)
            {
                double value = 0;
                if (dPercent == 0)
                    return 0;
                for (int i = 0; i < alTimes.Count; i++)
                {
                    Double.TryParse(alTimes[i].ToString(), out value);
                    if (value != 0)
                        return i;
                }
                return 0;

            }
            //<<Statistic tables 
            public static void GenerateRepartition(DataTable laTable, int iColumn, string sNomNewColumn, String sNomAccumulation)
            {
                GenerateRepartition(laTable, iColumn, sNomNewColumn, sNomAccumulation, -1, -1);
            }
            //>>Statistic tables 
            public static void GenerateRepartition(DataTable laTable, int iColumn, string sNomNewColumn, String sNomAccumulation, int startRow, int endRow)
            {
                if (laTable == null)
                    return;
                if (laTable.Columns.Count <= iColumn)
                    return;
                if ((laTable.Columns[iColumn].DataType != typeof(int)) &&
                    (laTable.Columns[iColumn].DataType != typeof(Int32)) &&
                    (laTable.Columns[iColumn].DataType != typeof(Int16)) &&
                    (laTable.Columns[iColumn].DataType != typeof(Int64)))
                    return;
                int iIndexPoucentage = laTable.Columns.IndexOf(sNomNewColumn);
                if (iIndexPoucentage == -1)
                {
                    laTable.Columns.Add(sNomNewColumn, typeof(Double));
                    iIndexPoucentage = laTable.Columns.Count - 1;
                }
                else
                {
                    if ((laTable.Columns[iIndexPoucentage].DataType != typeof(Double)) &&
                        (laTable.Columns[iIndexPoucentage].DataType != typeof(double)))
                        return;
                }
                int iAccumulation = -1;
                if (sNomAccumulation != null)
                {
                    iAccumulation = laTable.Columns.IndexOf(sNomAccumulation);
                    if (iAccumulation == -1)
                    {
                        laTable.Columns.Add(sNomAccumulation, typeof(Double));
                        iAccumulation = laTable.Columns.Count - 1;
                    }
                    else
                    {
                        if ((laTable.Columns[iAccumulation].DataType != typeof(Double)) &&
                            (laTable.Columns[iAccumulation].DataType != typeof(double)))
                            return;
                    }
                }
                if (startRow == -1 && endRow == -1) //<<Statistic tables 
                {
                    int iTotal = 0;
                    foreach (DataRow ligne in laTable.Rows)
                    {
                        iTotal += (int)ligne[iColumn];
                    }
                    Double dAccumulation = 0;
                    Double dValue = 0;
                    foreach (DataRow ligne in laTable.Rows)
                    {
                        if (iTotal != 0)
                        {
                            dValue = ((Double)((int)ligne[iColumn])) / (Double)iTotal;
                            dAccumulation += dValue;
                            ligne[iIndexPoucentage] = Math.Round(dValue * 100, 2);
                        }
                        else
                            ligne[iIndexPoucentage] = 0;
                        if (iAccumulation != -1)
                            ligne[iAccumulation] = Math.Round(dAccumulation * 100, 2);
                    }
                }
                else
                {
                    int iTotal = 0;
                    for (int i = startRow; i <= endRow; i++)
                    {
                        iTotal += (int)laTable.Rows[i][iColumn];
                    }
                    Double dAccumulation = 0;
                    Double dValue = 0;

                    for (int i = startRow; i <= endRow; i++)
                    {
                        if (iTotal != 0)
                        {
                            dValue = ((Double)((int)laTable.Rows[i][iColumn])) / (Double)iTotal;
                            dAccumulation += dValue;
                            laTable.Rows[i][iIndexPoucentage] = Math.Round(dValue * 100, 2);
                        }
                        else
                            laTable.Rows[i][iIndexPoucentage] = 0;
                        if (iAccumulation != -1)
                            laTable.Rows[i][iAccumulation] = Math.Round(dAccumulation * 100, 2);
                    }
                }
            }

            public static int getHighLevelValue(ArrayList alTimes, Double dPercent)
            {
                double maxValue;
                Double.TryParse(alTimes[alTimes.Count - 1].ToString(), out maxValue);
                double value = 0;
                if (dPercent == 100)
                    return alTimes.Count - 1;
                for (int i = 0; i < alTimes.Count; i++)
                {
                    Double.TryParse(alTimes[i].ToString(), out value);
                    if (value == maxValue)
                        return i - 1;
                }
                return 0;

            }
            #endregion

            #region La fonction pour le calcul de l'occupation des queues


            public static DataTable CalcQueueOccupation(String sTableName,
                                                        List<PointF> alTimes,
                                                        DateTime dtBegin,
                                                        DateTime dtEnd,
                                                        Double dStep,
                                                        String sColumn,
                                                        bool bUseSlidingHours,
                                                        bool bLeavingStat)
            {
                ArrayList alList = new ArrayList();
                foreach (PointF pf in alTimes)
                    alList.Add(pf);
                return CalcQueueOccupation(sTableName, alList, dtBegin, dtEnd, dStep, sColumn, bUseSlidingHours, bLeavingStat);
            }

            // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
            public static DataTable CalcQueueOccupation(String sTableName, ArrayList alTimes, DateTime dtBegin,
                DateTime dtEnd, Double dStep, String sColumn, bool bUseSlidingHours, bool bLeavingStat)
            {
                return CalcQueueOccupation(sTableName, alTimes, dtBegin, dtEnd, dStep, sColumn, bUseSlidingHours,
                    bLeavingStat, -1);
            }
            // >> Task #8775 Pax2Sim - Occupation stat - Throughput calculation

            /// <summary>
            /// Function which permits to determine the queue occupation of a desk with only 
            /// the information about the occupation times of all the process which had passed
            /// by this desk.
            /// </summary>
            /// <param name="sTableName">The name of the return table</param>
            /// <param name="alTimes">The list of the times</param>
            /// <param name="dtBegin">The time of begining</param>
            /// <param name="dtEnd">The time of endind</param>
            /// <param name="dStep">The step analysis</param>
            /// <returns>Return a table with all the informations about the occupation</returns>
            public static DataTable CalcQueueOccupation(String sTableName,
                                                        ArrayList alTimes,
                                                        DateTime dtBegin,
                                                        DateTime dtEnd,
                                                        Double dStep,
                                                        String sColumn,
                                                        bool bUseSlidingHours,
                                                        bool bLeavingStat,
                                                        Double analysisRange)   // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
            {
                //  = false;
                ArrayList alData = new ArrayList();
                alData.Add(new PointF(0.0f, 0.0f));
                int iIndex = 0;
                int iIndexFin = 0;


                DataTable dtTmp = new DataTable(sTableName);
                int timeColumnIndex = dtTmp.Columns.Count;
                dtTmp.Columns.Add("Time", typeof(DateTime));

                int minOccupationColumnIndex = dtTmp.Columns.Count;
                dtTmp.Columns.Add("Min Occupation", typeof(Int32));

                int avgOccupationColumnIndex = dtTmp.Columns.Count;
                dtTmp.Columns.Add("Average Occupation", typeof(Double));

                int maxOccupationColumnIndex = dtTmp.Columns.Count;
                dtTmp.Columns.Add("Max Occupation", typeof(Int32));

                // >> Task #13762 Pax2Sim - Dynamic Analysis - Occupation table
                int nbInColumnIndex = -1;
                int throughputInColumnIndex = -1;
                int throughputInstantInColumnIndex = -1;
                int nbOutColumnIndex = -1;
                int throughputOutColumnIndex = -1;
                int throughputInstantOutColumnIndex = -1;
                // << Task #13762 Pax2Sim - Dynamic Analysis - Occupation table

                if (!bLeavingStat)
                {
                    nbInColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add(sColumn, typeof(Int32));

                    throughputInColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add("Throughput (Input)", typeof(Int32));

                    throughputInstantInColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add(GlobalNames.OCCUPATION_TABLE_THROUGHPUT_INSTANT_IN_COLUMN_NAME, typeof(Int32)); // >> Task #13762 Pax2Sim - Dynamic Analysis - Occupation table
                }
                else
                {
                    nbInColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add(sColumn + " (Input)", typeof(Int32));

                    throughputInColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add("Throughput (Input)", typeof(Int32));

                    throughputInstantInColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add(GlobalNames.OCCUPATION_TABLE_THROUGHPUT_INSTANT_IN_COLUMN_NAME, typeof(Int32)); // >> Task #13762 Pax2Sim - Dynamic Analysis - Occupation table

                    nbOutColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add(sColumn + " (Output)", typeof(Int32));

                    throughputOutColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add("Throughput (Output)", typeof(Int32));

                    throughputInstantOutColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add(GlobalNames.OCCUPATION_TABLE_THROUGHPUT_INSTANT_OUT_COLUMN_NAME, typeof(Int32)); // >> Task #13762 Pax2Sim - Dynamic Analysis - Occupation table
                }

                OverallTools.DataFunctions.initialiserLignes(dtTmp, dtBegin, dtEnd, dStep);
                foreach (DataRow Row in dtTmp.Rows)
                {
                    Row[minOccupationColumnIndex] = 0;//Row[1] = 0;
                    Row[avgOccupationColumnIndex] = 0.0d;//Row[2] = 0.0d;
                    Row[maxOccupationColumnIndex] = 0;//Row[3] = 0;
                    Row[nbInColumnIndex] = 0;//Row[4] = 0;
                    Row[throughputInColumnIndex] = 0;//Row[5] = 0;
                    Row[throughputInstantInColumnIndex] = 0;
                    if (bLeavingStat)
                    {
                        Row[nbOutColumnIndex] = 0;//    Row[6] = 0;
                        Row[throughputOutColumnIndex] = 0;//    Row[7] = 0;
                        Row[throughputInstantOutColumnIndex] = 0;
                    }
                }
                foreach (PointF pValue in alTimes)
                {
                    //Traitement du flux arrivé.
                    iIndex = (int)(pValue.X / dStep);
                    Double dEndTime = Math.Round(pValue.X + pValue.Y, 2);
                    if ((iIndex < dtTmp.Rows.Count) && (iIndex >= 0))
                    {
                        //dtTmp.Rows[iIndex][4] = (int)dtTmp.Rows[iIndex][4] + 1;
                        dtTmp.Rows[iIndex][nbInColumnIndex] = (int)dtTmp.Rows[iIndex][nbInColumnIndex] + 1;
                    }
                    //Traitement du flux sortie.
                    if (bLeavingStat
                        && pValue.Y != -1)     // << Task #9464 Bug - Analysis - Occupation Nb Pax out
                    {
                        iIndex = (int)(dEndTime / dStep);
                        if ((iIndex < dtTmp.Rows.Count) && (iIndex >= 0))
                        {
                            //dtTmp.Rows[iIndex][6] = (int)dtTmp.Rows[iIndex][6] + 1;
                            dtTmp.Rows[iIndex][nbOutColumnIndex] = (int)dtTmp.Rows[iIndex][nbOutColumnIndex] + 1;
                        }
                    }
                    //Traitement pour avoir l'occupation maximale de la file d'attente.
                    if (pValue.Y == 0)
                        continue;
                    iIndex = RechercheIndex(alData, pValue.X);
                    if (((PointF)alData[iIndex]).X != pValue.X)
                    {
                        PointF pNewValue = new PointF(pValue.X, ((PointF)alData[iIndex]).Y);
                        if (alData.Count == iIndex + 1)
                            alData.Add(pNewValue);
                        else
                            alData.Insert(iIndex + 1, pNewValue);
                        iIndex++;
                    }
                    iIndexFin = RechercheIndex(alData, dEndTime);
                    if ((iIndexFin == iIndex) || (((PointF)alData[iIndexFin]).X != ((float)dEndTime)))
                    {
                        PointF pNewValue = new PointF((float)dEndTime, ((PointF)alData[iIndexFin]).Y);
                        if (alData.Count == iIndexFin + 1)
                            alData.Add(pNewValue);
                        else
                            alData.Insert(iIndexFin + 1, pNewValue);
                        iIndexFin++;
                    }
                    /* //Seb-08-01-2010*/
                    for (int i = iIndex; i < iIndexFin; i++)
                    {
                        PointF tmp = (PointF)alData[i];
                        tmp.Y++;
                        alData[i] = tmp;
                    }
                }


                int iIndexStart = -1;
                int iMin = 0, iMax = 0;
                Double dIndex;
                Double DMean = 0;
                Double dOldXValue = 0;
                Double dOldYValue = 0;

                foreach (PointF pValue in alData)
                {
                    // << Task #9464 Bug - Analysis - Occupation Nb Pax out
                    if (pValue.Y == -1)
                        continue;
                    // >> Task #9464 Bug - Analysis - Occupation Nb Pax out

                    dIndex = (pValue.X / dStep);
                    iIndex = (int)(pValue.X / dStep);
                    if (iIndexStart >= dtTmp.Rows.Count)
                        continue;
                    if (iIndex >= dtTmp.Rows.Count)
                        iIndex = dtTmp.Rows.Count - 1;
                    if (iIndex != iIndexStart)
                    {
                        if (iIndexStart != -1)
                        {
                            DMean += dOldYValue * ((dStep * (iIndexStart + 1)) - dOldXValue);

                            dtTmp.Rows[iIndexStart][minOccupationColumnIndex] = iMin;//dtTmp.Rows[iIndexStart][1] = iMin;
                            dtTmp.Rows[iIndexStart][avgOccupationColumnIndex] = Math.Round(DMean / dStep, 2);//dtTmp.Rows[iIndexStart][2] = Math.Round(DMean / dStep, 2);
                            dtTmp.Rows[iIndexStart][maxOccupationColumnIndex] = iMax;//dtTmp.Rows[iIndexStart][3] = iMax;
                        }
                        for (iIndexStart++; iIndexStart < iIndex; iIndexStart++)
                        {
                            dtTmp.Rows[iIndexStart][minOccupationColumnIndex] = dOldYValue; //dtTmp.Rows[iIndexStart][1] = dOldYValue;
                            dtTmp.Rows[iIndexStart][avgOccupationColumnIndex] = dOldYValue; //dtTmp.Rows[iIndexStart][2] = dOldYValue;
                            dtTmp.Rows[iIndexStart][maxOccupationColumnIndex] = dOldYValue; //dtTmp.Rows[iIndexStart][3] = dOldYValue;
                        }
                        iMin = (int)pValue.Y;
                        iMax = iMin;
                        iIndexStart = iIndex;
                        dOldXValue = dStep * iIndex;
                        DMean = dOldYValue * (pValue.X - dOldXValue);
                    }
                    else
                    {
                        if (iMin > pValue.Y)
                            iMin = (int)pValue.Y;
                        if (iMax < pValue.Y)
                            iMax = (int)pValue.Y;
                        DMean += dOldYValue * (pValue.X - dOldXValue);
                    }
                    dOldXValue = pValue.X;
                    dOldYValue = pValue.Y;
                }
                if (iIndex == iIndexStart)
                {
                    if (iIndexStart != -1)
                    {
                        DMean += dOldYValue * ((dStep * (iIndexStart + 1)) - dOldXValue);

                        dtTmp.Rows[iIndexStart][minOccupationColumnIndex] = iMin;                           //dtTmp.Rows[iIndexStart][1] = iMin;
                        dtTmp.Rows[iIndexStart][avgOccupationColumnIndex] = Math.Round(DMean / dStep, 2);   //dtTmp.Rows[iIndexStart][2] = Math.Round(DMean / dStep, 2);
                        dtTmp.Rows[iIndexStart][maxOccupationColumnIndex] = iMax;                           //dtTmp.Rows[iIndexStart][3] = iMax;
                    }
                }
                // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation                
                if (analysisRange == -1)
                {
                    ResultFunctions.AnalyzePeak_SlidingHour(dtTmp, nbInColumnIndex, throughputInColumnIndex, dStep, bUseSlidingHours);//ResultFunctions.AnalyzePeak_SlidingHour(dtTmp, 4, 5, dStep, bUseSlidingHours);
                    calculateThroughputInstantaneous(dtTmp, nbInColumnIndex, throughputInstantInColumnIndex, dStep);// >> Task #13762 Pax2Sim - Dynamic Analysis - Occupation table

                    if (bLeavingStat)
                    {
                        ResultFunctions.AnalyzePeak_SlidingHour(dtTmp, nbOutColumnIndex, throughputOutColumnIndex, dStep, bUseSlidingHours);//ResultFunctions.AnalyzePeak_SlidingHour(dtTmp, 6, 7, dStep, bUseSlidingHours);
                        calculateThroughputInstantaneous(dtTmp, nbOutColumnIndex, throughputInstantOutColumnIndex, dStep);// >> Task #13762 Pax2Sim - Dynamic Analysis - Occupation table
                    }
                }
                else
                {
                    calculateThroughputSliding(dtTmp, nbInColumnIndex, throughputInColumnIndex, dStep, analysisRange);//calculateThroughputSliding(dtTmp, 4, 5, dStep, analysisRange);
                    calculateThroughputInstantaneous(dtTmp, nbInColumnIndex, throughputInstantInColumnIndex, dStep);// >> Task #13762 Pax2Sim - Dynamic Analysis - Occupation table

                    if (bLeavingStat)
                    {
                        calculateThroughputSliding(dtTmp, nbOutColumnIndex, throughputOutColumnIndex, dStep, analysisRange);//calculateThroughputSliding(dtTmp, 6, 7, dStep, analysisRange);
                        calculateThroughputInstantaneous(dtTmp, nbOutColumnIndex, throughputInstantOutColumnIndex, dStep);// >> Task #13762 Pax2Sim - Dynamic Analysis - Occupation table
                    }
                }
                // >> Task #8775 Pax2Sim - Occupation stat - Throughput calculation

                dtTmp.AcceptChanges();
                return dtTmp;
            }

            internal class OccupationMinutes
            {
                public double startMinute { get; set; }
                public double endMinute { get; set; }
                public double durationInMinutes { get; set; }
                public double nbItems { get; set; }
                public OccupationMinutes(double pStartMinute, double pEndMinute)
                {
                    startMinute = pStartMinute;
                    endMinute = pEndMinute;
                    durationInMinutes = endMinute - startMinute;
                    nbItems = 0;
                }

                public double getOccupationDurationByOccupiedInterval(double occupiedIntervalStartMinute,
                    double occupiedIntervalEndMintue)
                {
                    double occupationStart = startMinute;
                    double occupationEnd = endMinute;

                    if (occupiedIntervalStartMinute > occupationStart)
                        occupationStart = occupiedIntervalStartMinute;
                    if (occupiedIntervalEndMintue < occupationEnd)
                        occupationEnd = occupiedIntervalEndMintue;

                    return occupationEnd - occupationStart;
                }

                public override string ToString()
                {
                    return "{" + startMinute + ", " + endMinute + "}";
                }
            }

            // >> #13391 IST Tables standardization - sorter occupation
            public static DataTable CalcQueueOccupation_V0(String sTableName,
                                                        ArrayList alTimes,
                                                        DateTime dtBegin,
                                                        DateTime dtEnd,
                                                        Double dStep,
                                                        String sColumn,
                                                        bool bUseSlidingHours,
                                                        bool bLeavingStat,
                                                        Double analysisRange)   // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
            {
                Dictionary<int, List<OccupationMinutes>> timeSlotIndexesDictionary
                    = new Dictionary<int, List<OccupationMinutes>>();
                List<OccupationMinutes> alData = new List<OccupationMinutes>();
                alData.Add(new OccupationMinutes(0, 0));
                int iIndex = 0;

                DataTable dtTmp = new DataTable(sTableName);
                int timeColumnIndex = dtTmp.Columns.Count;
                dtTmp.Columns.Add("Time", typeof(DateTime));

                int minOccupationColumnIndex = dtTmp.Columns.Count;
                dtTmp.Columns.Add("Min Occupation", typeof(Int32));

                int avgOccupationColumnIndex = dtTmp.Columns.Count;
                dtTmp.Columns.Add("Average Occupation", typeof(Double));

                int maxOccupationColumnIndex = dtTmp.Columns.Count;
                dtTmp.Columns.Add("Max Occupation", typeof(Int32));

                // >> Task #13762 Pax2Sim - Dynamic Analysis - Occupation table
                int nbInColumnIndex = -1;
                int throughputInColumnIndex = -1;
                int throughputInstantInColumnIndex = -1;
                int nbOutColumnIndex = -1;
                int throughputOutColumnIndex = -1;
                int throughputInstantOutColumnIndex = -1;
                // << Task #13762 Pax2Sim - Dynamic Analysis - Occupation table

                if (!bLeavingStat)
                {
                    nbInColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add(sColumn, typeof(Int32));

                    throughputInColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add("Throughput (Input)", typeof(Int32));

                    throughputInstantInColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add(GlobalNames.OCCUPATION_TABLE_THROUGHPUT_INSTANT_IN_COLUMN_NAME, typeof(Int32)); // >> Task #13762 Pax2Sim - Dynamic Analysis - Occupation table
                }
                else
                {
                    nbInColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add(sColumn + " (Input)", typeof(Int32));

                    throughputInColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add("Throughput (Input)", typeof(Int32));

                    throughputInstantInColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add(GlobalNames.OCCUPATION_TABLE_THROUGHPUT_INSTANT_IN_COLUMN_NAME, typeof(Int32)); // >> Task #13762 Pax2Sim - Dynamic Analysis - Occupation table

                    nbOutColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add(sColumn + " (Output)", typeof(Int32));

                    throughputOutColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add("Throughput (Output)", typeof(Int32));

                    throughputInstantOutColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add(GlobalNames.OCCUPATION_TABLE_THROUGHPUT_INSTANT_OUT_COLUMN_NAME, typeof(Int32)); // >> Task #13762 Pax2Sim - Dynamic Analysis - Occupation table
                }

                OverallTools.DataFunctions.initialiserLignes(dtTmp, dtBegin, dtEnd, dStep);
                foreach (DataRow Row in dtTmp.Rows)
                {
                    Row[minOccupationColumnIndex] = 0;//Row[1] = 0;
                    Row[avgOccupationColumnIndex] = 0.0d;//Row[2] = 0.0d;
                    Row[maxOccupationColumnIndex] = 0;//Row[3] = 0;
                    Row[nbInColumnIndex] = 0;//Row[4] = 0;
                    Row[throughputInColumnIndex] = 0;//Row[5] = 0;
                    Row[throughputInstantInColumnIndex] = 0;
                    if (bLeavingStat)
                    {
                        Row[nbOutColumnIndex] = 0;//    Row[6] = 0;
                        Row[throughputOutColumnIndex] = 0;//    Row[7] = 0;
                        Row[throughputInstantOutColumnIndex] = 0;
                    }
                }
                foreach (PointF pValue in alTimes)
                {
                    //Traitement du flux arrivé.
                    iIndex = (int)(pValue.X / dStep);
                    Double dEndTime = Math.Round(pValue.X + pValue.Y, 2);
                    if ((iIndex < dtTmp.Rows.Count) && (iIndex >= 0))
                    {
                        //dtTmp.Rows[iIndex][4] = (int)dtTmp.Rows[iIndex][4] + 1;
                        dtTmp.Rows[iIndex][nbInColumnIndex] = (int)dtTmp.Rows[iIndex][nbInColumnIndex] + 1;
                    }
                    //Traitement du flux sortie.
                    if (bLeavingStat
                        && pValue.Y != -1)     // << Task #9464 Bug - Analysis - Occupation Nb Pax out
                    {
                        iIndex = (int)(dEndTime / dStep);
                        if ((iIndex < dtTmp.Rows.Count) && (iIndex >= 0))
                        {
                            //dtTmp.Rows[iIndex][6] = (int)dtTmp.Rows[iIndex][6] + 1;
                            dtTmp.Rows[iIndex][nbOutColumnIndex] = (int)dtTmp.Rows[iIndex][nbOutColumnIndex] + 1;
                        }
                    }
                    //Traitement pour avoir l'occupation maximale de la file d'attente.
                    if (pValue.Y == 0)
                        continue;
                    Double dStartTime = Math.Round(pValue.X, 2);
                    OccupationMinutes occupation = new OccupationMinutes(dStartTime, dEndTime);
                    alData.Add(occupation);

                    int startTimeSlotIndex = (int)(dStartTime / dStep);
                    int endTimeSlotIndex = (int)(dEndTime / dStep);

                    if (startTimeSlotIndex == endTimeSlotIndex)
                    {
                        if (startTimeSlotIndex < dtTmp.Rows.Count)
                        {
                            if (!timeSlotIndexesDictionary.ContainsKey(startTimeSlotIndex))
                                timeSlotIndexesDictionary.Add(startTimeSlotIndex, new List<OccupationMinutes>());
                            timeSlotIndexesDictionary[startTimeSlotIndex].Add(occupation);
                        }
                    }
                    else
                    {
                        if (startTimeSlotIndex < dtTmp.Rows.Count)
                        {
                            if (!timeSlotIndexesDictionary.ContainsKey(startTimeSlotIndex))
                                timeSlotIndexesDictionary.Add(startTimeSlotIndex, new List<OccupationMinutes>());
                            timeSlotIndexesDictionary[startTimeSlotIndex].Add(occupation);
                        }
                        if (endTimeSlotIndex < dtTmp.Rows.Count)
                        {
                            if (!timeSlotIndexesDictionary.ContainsKey(endTimeSlotIndex))
                                timeSlotIndexesDictionary.Add(endTimeSlotIndex, new List<OccupationMinutes>());
                            timeSlotIndexesDictionary[endTimeSlotIndex].Add(occupation);
                        }
                    }
                }
                alData = alData.OrderBy(o => o.startMinute).ToList();

                foreach (KeyValuePair<int, List<OccupationMinutes>> pair in timeSlotIndexesDictionary)
                {
                    int timeSlotIndex = pair.Key;
                    List<OccupationMinutes> occupations = pair.Value;
                    occupations = occupations.OrderBy(o => o.startMinute).ToList();

                    double timeSlotStartMinute = dStep * timeSlotIndex;
                    double timeSlotEndMinute = dStep * (timeSlotIndex + 1);

                    List<double> allEnterExitMinutes = new List<double>();
                    foreach (OccupationMinutes occupation in occupations)
                    {
                        if (occupation.startMinute < timeSlotStartMinute || occupation.endMinute > timeSlotEndMinute)
                        {
                            if (occupation.startMinute < timeSlotStartMinute)
                            {
                                if (!allEnterExitMinutes.Contains(timeSlotStartMinute))
                                    allEnterExitMinutes.Add(timeSlotStartMinute);
                                allEnterExitMinutes.Add(occupation.endMinute);
                            }
                            if (occupation.endMinute > timeSlotEndMinute)
                            {
                                allEnterExitMinutes.Add(occupation.startMinute);
                                if (!allEnterExitMinutes.Contains(timeSlotEndMinute))
                                    allEnterExitMinutes.Add(timeSlotEndMinute);
                            }
                        }
                        else
                        {
                            allEnterExitMinutes.Add(occupation.startMinute);
                            allEnterExitMinutes.Add(occupation.endMinute);
                        }
                    }
                    allEnterExitMinutes.Sort();
                    List<OccupationMinutes> subOccupations = new List<OccupationMinutes>();
                    for (int i = 0; i < allEnterExitMinutes.Count - 1; i++)
                    {
                        OccupationMinutes subOccupation = new OccupationMinutes(allEnterExitMinutes[i], allEnterExitMinutes[i + 1]);
                        subOccupations.Add(subOccupation);
                    }
                    foreach (OccupationMinutes occupation in occupations)
                    {
                        foreach (OccupationMinutes subOcc in subOccupations)
                        {
                            if ((subOcc.startMinute == occupation.startMinute && subOcc.endMinute == occupation.endMinute)
                                || (subOcc.startMinute < occupation.endMinute && subOcc.endMinute > occupation.startMinute))
                            {
                                subOcc.nbItems++;
                            }
                        }
                    }

                    double minOccupation = Int32.MaxValue;
                    double maxOccupation = Int32.MinValue;
                    double weightedSubOccSum = 0;
                    foreach (OccupationMinutes subOcc in subOccupations)
                    {
                        if (subOcc.nbItems < minOccupation)
                            minOccupation = subOcc.nbItems;
                        if (subOcc.nbItems > maxOccupation)
                            maxOccupation = subOcc.nbItems;
                        weightedSubOccSum = weightedSubOccSum + subOcc.nbItems * subOcc.durationInMinutes;
                    }
                    bool hasEmptyOccupationAtStartOrEnd = false;
                    if (subOccupations.Count > 0)
                    {
                        OccupationMinutes firstSubOcc = subOccupations[0];
                        OccupationMinutes lastSubOcc = subOccupations[subOccupations.Count - 1];
                        if (firstSubOcc.startMinute > timeSlotStartMinute
                            || lastSubOcc.endMinute < timeSlotEndMinute)
                        {
                            hasEmptyOccupationAtStartOrEnd = true;
                        }
                    }

                    //int[] timeSlotSubDivisionOccupation = new int[(int)dStep];
                    //foreach (OccupationMinutes occupation in occupations)
                    //{
                    //    int subDivisionStartIndex = 0;
                    //    if (occupation.startMinute > timeSlotStartMinute)
                    //        subDivisionStartIndex = (int)(occupation.startMinute - timeSlotStartMinute);
                    //    int subDivisionEndIndex = timeSlotSubDivisionOccupation.Length - 1;
                    //    if (occupation.endMinute < timeSlotEndMinute)
                    //        subDivisionEndIndex = (int)(occupation.endMinute - timeSlotStartMinute);
                    //    for (int i = subDivisionStartIndex; i <= subDivisionEndIndex; i++)                        
                    //        timeSlotSubDivisionOccupation[i] += 1;
                    //}

                    //for (int i = 0; i < timeSlotSubDivisionOccupation.Length; i++)
                    //{
                    //    if (minOccupation > timeSlotSubDivisionOccupation[i])
                    //        minOccupation = timeSlotSubDivisionOccupation[i];
                    //    if (maxOccupation < timeSlotSubDivisionOccupation[i])
                    //        maxOccupation = timeSlotSubDivisionOccupation[i];
                    //}


                    if (hasEmptyOccupationAtStartOrEnd)
                        dtTmp.Rows[timeSlotIndex][minOccupationColumnIndex] = 0;
                    else
                        dtTmp.Rows[timeSlotIndex][minOccupationColumnIndex] = minOccupation;
                    dtTmp.Rows[timeSlotIndex][avgOccupationColumnIndex] = Math.Round(weightedSubOccSum / dStep, 2);
                    dtTmp.Rows[timeSlotIndex][maxOccupationColumnIndex] = maxOccupation;
                }

                // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation                
                if (analysisRange == -1)
                {
                    ResultFunctions.AnalyzePeak_SlidingHour(dtTmp, nbInColumnIndex, throughputInColumnIndex, dStep, bUseSlidingHours);//ResultFunctions.AnalyzePeak_SlidingHour(dtTmp, 4, 5, dStep, bUseSlidingHours);
                    calculateThroughputInstantaneous(dtTmp, nbInColumnIndex, throughputInstantInColumnIndex, dStep);// >> Task #13762 Pax2Sim - Dynamic Analysis - Occupation table

                    if (bLeavingStat)
                    {
                        ResultFunctions.AnalyzePeak_SlidingHour(dtTmp, nbOutColumnIndex, throughputOutColumnIndex, dStep, bUseSlidingHours);//ResultFunctions.AnalyzePeak_SlidingHour(dtTmp, 6, 7, dStep, bUseSlidingHours);
                        calculateThroughputInstantaneous(dtTmp, nbOutColumnIndex, throughputInstantOutColumnIndex, dStep);// >> Task #13762 Pax2Sim - Dynamic Analysis - Occupation table
                    }
                }
                else
                {
                    calculateThroughputSliding(dtTmp, nbInColumnIndex, throughputInColumnIndex, dStep, analysisRange);//calculateThroughputSliding(dtTmp, 4, 5, dStep, analysisRange);
                    calculateThroughputInstantaneous(dtTmp, nbInColumnIndex, throughputInstantInColumnIndex, dStep);// >> Task #13762 Pax2Sim - Dynamic Analysis - Occupation table

                    if (bLeavingStat)
                    {
                        calculateThroughputSliding(dtTmp, nbOutColumnIndex, throughputOutColumnIndex, dStep, analysisRange);//calculateThroughputSliding(dtTmp, 6, 7, dStep, analysisRange);
                        calculateThroughputInstantaneous(dtTmp, nbOutColumnIndex, throughputInstantOutColumnIndex, dStep);// >> Task #13762 Pax2Sim - Dynamic Analysis - Occupation table
                    }
                }
                // >> Task #8775 Pax2Sim - Occupation stat - Throughput calculation

                dtTmp.AcceptChanges();
                return dtTmp;
            }


            // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
            public static DataTable CalcQueueOccupationWithLeavingTimes(String sTableName, ArrayList alTimes,
                DateTime dtBegin, DateTime dtEnd, Double dStep, String sColumn, bool bUseSlidingHours,
                bool bLeavingStat)
            {
                return CalcQueueOccupationWithLeavingTimes(sTableName, alTimes, dtBegin, dtEnd, dStep, sColumn,
                    bUseSlidingHours, bLeavingStat, -1);
            }
            // >> Task #8775 Pax2Sim - Occupation stat - Throughput calculation

            // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
            public static DataTable CalcQueueOccupationWithLeavingTimes(String sTableName,
                                                        ArrayList alTimes,
                                                        DateTime dtBegin,
                                                        DateTime dtEnd,
                                                        Double dStep,
                                                        String sColumn,
                                                        bool bUseSlidingHours,
                                                        bool bLeavingStat,
                                                        Double analysisRange,   // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                                                        out double totalOccupation) // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent
            {
                ArrayList alData = new ArrayList();
                alData.Add(new PointF(0.0f, 0.0f));
                int iIndex = 0;
                int iIndexFin = 0;
                int iPrecisionCalculDecimal = 2;
                totalOccupation = 0;    // >> Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent

                DataTable dtTmp = new DataTable(sTableName);
                int timeColumnIndex = dtTmp.Columns.Count;
                dtTmp.Columns.Add("Time", typeof(DateTime));

                int minOccupationColumnIndex = dtTmp.Columns.Count;
                dtTmp.Columns.Add("Min Occupation", typeof(Int32));

                int avgOccupationColumnIndex = dtTmp.Columns.Count;
                dtTmp.Columns.Add("Average Occupation", typeof(Double));

                int maxOccupationColumnIndex = dtTmp.Columns.Count;
                dtTmp.Columns.Add("Max Occupation", typeof(Int32));

                // >> Task #13762 Pax2Sim - Dynamic Analysis - Occupation table
                int nbInColumnIndex = -1;
                int throughputInColumnIndex = -1;
                int throughputInstantInColumnIndex = -1;
                int nbOutColumnIndex = -1;
                int throughputOutColumnIndex = -1;
                int throughputInstantOutColumnIndex = -1;
                // << Task #13762 Pax2Sim - Dynamic Analysis - Occupation table

                if (!bLeavingStat)
                {
                    nbInColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add(sColumn, typeof(Int32));
                    throughputInColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add("Throughput (Input)", typeof(Int32));

                    throughputInstantInColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add(GlobalNames.OCCUPATION_TABLE_THROUGHPUT_INSTANT_IN_COLUMN_NAME, typeof(Int32)); // >> Task #13762 Pax2Sim - Dynamic Analysis - Occupation table
                }
                else
                {
                    nbInColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add(sColumn + " (Input)", typeof(Int32));
                    throughputInColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add("Throughput (Input)", typeof(Int32));

                    throughputInstantInColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add(GlobalNames.OCCUPATION_TABLE_THROUGHPUT_INSTANT_IN_COLUMN_NAME, typeof(Int32)); // >> Task #13762 Pax2Sim - Dynamic Analysis - Occupation table

                    nbOutColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add(sColumn + " (Output)", typeof(Int32));

                    throughputOutColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add("Throughput (Output)", typeof(Int32));

                    throughputInstantOutColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add(GlobalNames.OCCUPATION_TABLE_THROUGHPUT_INSTANT_OUT_COLUMN_NAME, typeof(Int32)); // >> Task #13762 Pax2Sim - Dynamic Analysis - Occupation table
                }

                OverallTools.DataFunctions.initialiserLignes(dtTmp, dtBegin, dtEnd, dStep);
                foreach (DataRow Row in dtTmp.Rows)
                {
                    Row[minOccupationColumnIndex] = 0;
                    Row[avgOccupationColumnIndex] = 0.0d;
                    Row[maxOccupationColumnIndex] = 0;
                    Row[nbInColumnIndex] = 0;
                    Row[throughputInColumnIndex] = 0;
                    Row[throughputInstantInColumnIndex] = 0;

                    if (bLeavingStat)
                    {
                        Row[nbOutColumnIndex] = 0;
                        Row[throughputOutColumnIndex] = 0;
                        Row[throughputInstantOutColumnIndex] = 0;
                    }
                }
                float fXValue;
                foreach (PointF pValue in alTimes)
                {
                    //Traitement du flux arrivé.
                    iIndex = (int)(pValue.X / dStep);
                    fXValue = (float)Math.Round(pValue.X, iPrecisionCalculDecimal);
                    float dEndTime = (float)Math.Round(pValue.Y, iPrecisionCalculDecimal);
                    if ((iIndex < dtTmp.Rows.Count) && (iIndex >= 0))
                    {
                        dtTmp.Rows[iIndex][nbInColumnIndex] = (int)dtTmp.Rows[iIndex][nbInColumnIndex] + 1;
                    }
                    //Traitement du flux sortie.
                    if (bLeavingStat)
                    {
                        iIndex = (int)(dEndTime / dStep);
                        if ((iIndex < dtTmp.Rows.Count) && (iIndex >= 0))
                        {
                            dtTmp.Rows[iIndex][nbOutColumnIndex] = (int)dtTmp.Rows[iIndex][nbOutColumnIndex] + 1;
                        }
                    }
                    //Traitement pour avoir l'occupation maximale de la file d'attente.
                    iIndex = RechercheIndex(alData, fXValue);
                    if (((PointF)alData[iIndex]).X != fXValue)
                    {
                        PointF pNewValue = new PointF(fXValue, ((PointF)alData[iIndex]).Y);
                        if (alData.Count == iIndex + 1)
                            alData.Add(pNewValue);
                        else
                            alData.Insert(iIndex + 1, pNewValue);
                        iIndex++;
                    }
                    iIndexFin = RechercheIndex(alData, dEndTime);

                    if ((iIndexFin == iIndex) || (((PointF)alData[iIndexFin]).X != ((float)dEndTime)))
                    {
                        PointF pNewValue = new PointF((float)dEndTime, ((PointF)alData[iIndexFin]).Y);
                        if (alData.Count == iIndexFin + 1)
                            alData.Add(pNewValue);
                        else
                            alData.Insert(iIndexFin + 1, pNewValue);
                        iIndexFin++;
                    }
                    for (int i = iIndex; i < iIndexFin; i++)
                    {
                        PointF tmp = (PointF)alData[i];
                        tmp.Y++;
                        alData[i] = tmp;
                    }
                }


                int iIndexStart = -1;
                int iMin = 0, iMax = 0;
                Double DMean = 0;
                Double dOldXValue = 0;
                Double dOldYValue = 0;

                foreach (PointF pValue in alData)
                {
                    iIndex = (int)(pValue.X / dStep);
                    if (iIndexStart >= dtTmp.Rows.Count)
                        continue;
                    if (iIndex >= dtTmp.Rows.Count)
                        iIndex = dtTmp.Rows.Count - 1;
                    if (iIndex != iIndexStart)
                    {
                        if (iIndexStart != -1)
                        {
                            DMean += dOldYValue * ((dStep * (iIndexStart + 1)) - dOldXValue);

                            dtTmp.Rows[iIndexStart][minOccupationColumnIndex] = iMin;
                            dtTmp.Rows[iIndexStart][avgOccupationColumnIndex] = Math.Round(DMean / dStep, 2);
                            dtTmp.Rows[iIndexStart][maxOccupationColumnIndex] = iMax;
                        }
                        for (iIndexStart++; iIndexStart < iIndex; iIndexStart++)
                        {
                            dtTmp.Rows[iIndexStart][minOccupationColumnIndex] = dOldYValue;
                            dtTmp.Rows[iIndexStart][avgOccupationColumnIndex] = dOldYValue;
                            dtTmp.Rows[iIndexStart][maxOccupationColumnIndex] = dOldYValue;
                        }
                        iMin = (int)pValue.Y;
                        iMax = iMin;
                        iIndexStart = iIndex;
                        dOldXValue = dStep * iIndex;
                        DMean = dOldYValue * (pValue.X - dOldXValue);
                    }
                    else
                    {
                        if (iMin > pValue.Y)
                            iMin = (int)pValue.Y;
                        if (iMax < pValue.Y)
                            iMax = (int)pValue.Y;
                        DMean += dOldYValue * (pValue.X - dOldXValue);
                    }

                    dOldXValue = pValue.X;
                    dOldYValue = pValue.Y;
                }
                if (iIndex == iIndexStart)
                {
                    if (iIndexStart != -1)
                    {
                        DMean += dOldYValue * ((dStep * (iIndexStart + 1)) - dOldXValue);

                        dtTmp.Rows[iIndexStart][minOccupationColumnIndex] = iMin;
                        dtTmp.Rows[iIndexStart][avgOccupationColumnIndex] = Math.Round(DMean / dStep, 2);
                        dtTmp.Rows[iIndexStart][maxOccupationColumnIndex] = iMax;
                    }
                }

                // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                if (analysisRange == -1)
                {
                    ResultFunctions.AnalyzePeak_SlidingHour(dtTmp, nbInColumnIndex, throughputInColumnIndex, dStep, bUseSlidingHours);
                    calculateThroughputInstantaneous(dtTmp, nbInColumnIndex, throughputInstantInColumnIndex, dStep);

                    if (bLeavingStat)
                    {
                        ResultFunctions.AnalyzePeak_SlidingHour(dtTmp, nbOutColumnIndex, throughputOutColumnIndex, dStep, bUseSlidingHours);
                        calculateThroughputInstantaneous(dtTmp, nbOutColumnIndex, throughputInstantOutColumnIndex, dStep);
                    }
                }
                else
                {
                    calculateThroughputSliding(dtTmp, nbInColumnIndex, throughputInColumnIndex, dStep, analysisRange);
                    calculateThroughputInstantaneous(dtTmp, nbInColumnIndex, throughputInstantInColumnIndex, dStep);

                    if (bLeavingStat)
                    {
                        calculateThroughputSliding(dtTmp, nbOutColumnIndex, throughputOutColumnIndex, dStep, analysisRange);
                        calculateThroughputInstantaneous(dtTmp, nbOutColumnIndex, throughputInstantOutColumnIndex, dStep);
                    }
                }
                // >> Task #8775 Pax2Sim - Occupation stat - Throughput calculation

                dtTmp.AcceptChanges();
                return dtTmp;
            }
            // << Task #10484 Pax2Sim - Pax analysis - Summary with distribution levels percent

            public static DataTable CalcQueueOccupationWithLeavingTimes(String sTableName,
                                                        ArrayList alTimes,
                                                        DateTime dtBegin,
                                                        DateTime dtEnd,
                                                        Double dStep,
                                                        String sColumn,
                                                        bool bUseSlidingHours,
                                                        bool bLeavingStat,
                                                        Double analysisRange)   // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
            {
                ArrayList alData = new ArrayList();
                alData.Add(new PointF(0.0f, 0.0f));
                int iIndex = 0;
                int iIndexFin = 0;
                int iPrecisionCalculDecimal = 2;

                // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS)                                
                int nbInColumnIndex = -1;
                int throughputInColumnIndex = -1;
                int throughputInstantInColumnIndex = -1;
                int nbOutColumnIndex = -1;
                int throughputOutColumnIndex = -1;
                int throughputInstantOutColumnIndex = -1;
                // << Task #14902 Improve Dynamic Occupation tables (PAX & BHS)

                DataTable dtTmp = new DataTable(sTableName);
                dtTmp.Columns.Add("Time", typeof(DateTime));
                dtTmp.Columns.Add("Min Occupation", typeof(Int32));
                dtTmp.Columns.Add("Average Occupation", typeof(Double));
                dtTmp.Columns.Add("Max Occupation", typeof(Int32));
                if (!bLeavingStat)
                {
                    nbInColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add(sColumn, typeof(Int32));

                    throughputInColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add("Throughput (Input)", typeof(Int32));

                    throughputInstantInColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add(GlobalNames.OCCUPATION_TABLE_THROUGHPUT_INSTANT_IN_COLUMN_NAME, typeof(Int32));
                }
                else
                {
                    nbInColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add(sColumn + " (Input)", typeof(Int32));

                    throughputInColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add("Throughput (Input)", typeof(Int32));

                    throughputInstantInColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add(GlobalNames.OCCUPATION_TABLE_THROUGHPUT_INSTANT_IN_COLUMN_NAME, typeof(Int32));

                    nbOutColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add(sColumn + " (Output)", typeof(Int32));

                    throughputOutColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add("Throughput (Output)", typeof(Int32));

                    throughputInstantOutColumnIndex = dtTmp.Columns.Count;
                    dtTmp.Columns.Add(GlobalNames.OCCUPATION_TABLE_THROUGHPUT_INSTANT_OUT_COLUMN_NAME, typeof(Int32));
                }

                OverallTools.DataFunctions.initialiserLignes(dtTmp, dtBegin, dtEnd, dStep);
                foreach (DataRow Row in dtTmp.Rows)
                {
                    Row[1] = 0;
                    Row[2] = 0.0d;
                    Row[3] = 0;
                    Row[nbInColumnIndex] = 0;
                    Row[throughputInColumnIndex] = 0;
                    Row[throughputInstantInColumnIndex] = 0;
                    if (bLeavingStat)
                    {
                        Row[nbOutColumnIndex] = 0;
                        Row[throughputOutColumnIndex] = 0;
                        Row[throughputInstantOutColumnIndex] = 0;
                    }
                }
                float fXValue;
                foreach (PointF pValue in alTimes)
                {
                    //Traitement du flux arrivé.
                    iIndex = (int)(pValue.X / dStep);
                    fXValue = (float)Math.Round(pValue.X, iPrecisionCalculDecimal);
                    float dEndTime = (float)Math.Round(pValue.Y, iPrecisionCalculDecimal);
                    if ((iIndex < dtTmp.Rows.Count) && (iIndex >= 0))
                    {
                        dtTmp.Rows[iIndex][nbInColumnIndex] = (int)dtTmp.Rows[iIndex][nbInColumnIndex] + 1;
                    }
                    //Traitement du flux sortie.
                    if (bLeavingStat)
                    {
                        iIndex = (int)(dEndTime / dStep);
                        if ((iIndex < dtTmp.Rows.Count) && (iIndex >= 0))
                        {
                            dtTmp.Rows[iIndex][nbOutColumnIndex] = (int)dtTmp.Rows[iIndex][nbOutColumnIndex] + 1;
                        }
                    }
                    //Traitement pour avoir l'occupation maximale de la file d'attente.
                    iIndex = RechercheIndex(alData, fXValue);
                    if (((PointF)alData[iIndex]).X != fXValue)
                    {
                        PointF pNewValue = new PointF(fXValue, ((PointF)alData[iIndex]).Y);
                        if (alData.Count == iIndex + 1)
                            alData.Add(pNewValue);
                        else
                            alData.Insert(iIndex + 1, pNewValue);
                        iIndex++;
                    }
                    iIndexFin = RechercheIndex(alData, dEndTime);

                    if ((iIndexFin == iIndex) || (((PointF)alData[iIndexFin]).X != ((float)dEndTime)))
                    {
                        PointF pNewValue = new PointF((float)dEndTime, ((PointF)alData[iIndexFin]).Y);
                        if (alData.Count == iIndexFin + 1)
                            alData.Add(pNewValue);
                        else
                            alData.Insert(iIndexFin + 1, pNewValue);
                        iIndexFin++;
                    }
                    for (int i = iIndex; i < iIndexFin; i++)
                    {
                        PointF tmp = (PointF)alData[i];
                        tmp.Y++;
                        alData[i] = tmp;
                    }
                }


                int iIndexStart = -1;
                int iMin = 0, iMax = 0;
                Double DMean = 0;
                Double dOldXValue = 0;
                Double dOldYValue = 0;
                /*String value="";
                foreach (PointF pf in alTmp)
                {
                     value+= pf.X.ToString() + ";"+pf.Y.ToString()+"\r\n";
                }
                Clipboard.SetText(value);*/
                foreach (PointF pValue in alData)
                {
                    iIndex = (int)(pValue.X / dStep);
                    if (iIndexStart >= dtTmp.Rows.Count)
                        continue;
                    if (iIndex >= dtTmp.Rows.Count)
                        iIndex = dtTmp.Rows.Count - 1;
                    if (iIndex != iIndexStart)
                    {
                        if (iIndexStart != -1)
                        {
                            DMean += dOldYValue * ((dStep * (iIndexStart + 1)) - dOldXValue);

                            dtTmp.Rows[iIndexStart][1] = iMin;
                            dtTmp.Rows[iIndexStart][2] = Math.Round(DMean / dStep, 2);
                            dtTmp.Rows[iIndexStart][3] = iMax;
                        }
                        for (iIndexStart++; iIndexStart < iIndex; iIndexStart++)
                        {
                            dtTmp.Rows[iIndexStart][1] = dOldYValue;
                            dtTmp.Rows[iIndexStart][2] = dOldYValue;
                            dtTmp.Rows[iIndexStart][3] = dOldYValue;
                        }
                        iMin = (int)pValue.Y;
                        iMax = iMin;
                        iIndexStart = iIndex;
                        dOldXValue = dStep * iIndex;
                        DMean = dOldYValue * (pValue.X - dOldXValue);
                    }
                    else
                    {
                        if (iMin > pValue.Y)
                            iMin = (int)pValue.Y;
                        if (iMax < pValue.Y)
                            iMax = (int)pValue.Y;
                        DMean += dOldYValue * (pValue.X - dOldXValue);
                    }
                    dOldXValue = pValue.X;
                    dOldYValue = pValue.Y;
                }
                if (iIndex == iIndexStart)
                {
                    if (iIndexStart != -1)
                    {
                        DMean += dOldYValue * ((dStep * (iIndexStart + 1)) - dOldXValue);

                        dtTmp.Rows[iIndexStart][1] = iMin;
                        dtTmp.Rows[iIndexStart][2] = Math.Round(DMean / dStep, 2);
                        dtTmp.Rows[iIndexStart][3] = iMax;
                    }
                }

                if (analysisRange == -1)
                {
                    ResultFunctions.AnalyzePeak_SlidingHour(dtTmp, nbInColumnIndex, throughputInColumnIndex, dStep, bUseSlidingHours);
                    calculateThroughputInstantaneous(dtTmp, nbInColumnIndex, throughputInstantInColumnIndex, dStep);

                    if (bLeavingStat)
                    {
                        ResultFunctions.AnalyzePeak_SlidingHour(dtTmp, nbOutColumnIndex, throughputOutColumnIndex, dStep, bUseSlidingHours);
                        calculateThroughputInstantaneous(dtTmp, nbOutColumnIndex, throughputInstantOutColumnIndex, dStep);
                    }
                }
                else
                {
                    calculateThroughputSliding(dtTmp, nbInColumnIndex, throughputInColumnIndex, dStep, analysisRange);
                    calculateThroughputInstantaneous(dtTmp, nbInColumnIndex, throughputInstantInColumnIndex, dStep);

                    if (bLeavingStat)
                    {
                        calculateThroughputSliding(dtTmp, nbOutColumnIndex, throughputOutColumnIndex, dStep, analysisRange);
                        calculateThroughputInstantaneous(dtTmp, nbOutColumnIndex, throughputInstantOutColumnIndex, dStep);
                    }
                }

                dtTmp.AcceptChanges();
                return dtTmp;
            }
            private static int RechercheIndex(ArrayList alData, Double dValue)
            {
                float fValue = (float)dValue;
                int iIndex = alData.Count / 2;
                int iIndexMin = 0;
                int iIndexMax = alData.Count;
                while (true)
                {
                    if (((PointF)alData[iIndex]).X <= fValue)
                    {
                        if (iIndexMax == (iIndex + 1))
                            return iIndex;
                        iIndexMin = iIndex;
                        iIndex = (iIndexMax + iIndex) / 2;
                    }
                    else
                    {
                        if (iIndexMin == iIndex)
                            return iIndex;
                        iIndexMax = iIndex;
                        iIndex = (iIndexMin + iIndex) / 2;
                    }
                }
            }

            // >> #13391 IST Tables standardization - sorter occupation
            private static int RechercheIndexInTypedList(List<PointF> alData, Double dValue)
            {
                float fValue = (float)dValue;
                int iIndex = alData.Count / 2;
                int iIndexMin = 0;
                int iIndexMax = alData.Count;
                while (true)
                {
                    if (((PointF)alData[iIndex]).X <= fValue)
                    {
                        if (iIndexMax == (iIndex + 1))
                            return iIndex;
                        iIndexMin = iIndex;
                        iIndex = (iIndexMax + iIndex) / 2;
                    }
                    else
                    {
                        if (iIndexMin == iIndex)
                            return iIndex;
                        iIndexMax = iIndex;
                        iIndex = (iIndexMin + iIndex) / 2;
                    }
                }
            }
            #endregion

            #region Les fonctions BuildClassTable et associées
            public static DataTable BuildClassTable(String sName, Double dPas, int iNbMaxClass, Double dStart, String sFirstColumn, String[] sColumns)
            {
                DataTable table = new DataTable(sName);
                table.Columns.Add(sFirstColumn, typeof(String));
                table.Columns[table.Columns.Count - 1].ExtendedProperties.Add("ToolTip", "(" + sFirstColumn + ")");
                int i, j;
                for (i = 0; i < sColumns.Length; i++)
                {
                    table.Columns.Add(sColumns[i], typeof(Int32));
                    table.Columns[table.Columns.Count - 1].ExtendedProperties.Add("ToolTip", "(Number of " + sColumns[i] + ")");
                }
                DataRow newLigne = table.NewRow();
                newLigne[0] = "<=" + dStart.ToString();
                for (j = 1; j <= sColumns.Length; j++)
                {
                    newLigne[j] = 0;
                }
                table.Rows.Add(newLigne);
                for (i = 0; i < iNbMaxClass; i++)
                {
                    newLigne = table.NewRow();
                    newLigne[0] = "]" + ((Double)(dPas * i) + dStart).ToString() + ";" + ((Double)(dPas * (i + 1)) + dStart).ToString() + "]";
                    for (j = 1; j <= sColumns.Length; j++)
                    {
                        newLigne[j] = 0;
                    }
                    table.Rows.Add(newLigne);
                }
                table.Rows[table.Rows.Count - 1][0] = "]" + ((Double)(dPas * (table.Rows.Count - 2)) + dStart).ToString() + ";...[";
                return table;
            }

            public static void IncrementLine(DataTable dtTable, int iIndexColumn, int iIndex)
            {
                if ((iIndex == -1) || (iIndexColumn == -1) &&
                    (iIndex > dtTable.Rows.Count) && (iIndexColumn > dtTable.Columns.Count))
                    return;
                dtTable.Rows[iIndex][iIndexColumn] = (int)dtTable.Rows[iIndex][iIndexColumn] + 1;
            }
            #endregion

            private static void MultiplyColumn(DataTable dtOriginTable, int iIndexColumn, int iIndexAccumulationColumn, double dPas)
            {
                if (dPas == 0)
                    return;
                double dCoeff = 60.0 / dPas;
                for (int i = 0; i < dtOriginTable.Rows.Count; i++)
                {
                    dtOriginTable.Rows[i][iIndexAccumulationColumn] = ((Double)dtOriginTable.Rows[i][iIndexColumn]) * dCoeff;
                }
                dtOriginTable.AcceptChanges();
            }

            #region public static void analyzeEnHoraireGlissant(...)

            public static void AnalyzePeak_SlidingHour(DataTable dtOriginTable,
                                                       int iIndexColumn,
                                                       int iIndexAccumulationColumn,
                                                       double dPas,
                                                       bool bSliddingHour)
            {
                if (bSliddingHour)
                {
                    analyzeEnHoraireGlissant(dtOriginTable, iIndexColumn, iIndexAccumulationColumn, dPas);
                }
                else
                {
                    //calculateThroughputSliding(dtOriginTable, iIndexColumn, iIndexAccumulationColumn, dPas, 12);

                    Double dCoeff = (60 / dPas);
                    for (int i = 0; i < dtOriginTable.Rows.Count; i++)
                    {
                        dtOriginTable.Rows[i][iIndexAccumulationColumn] = ((int)dtOriginTable.Rows[i][iIndexColumn]) * dCoeff;
                    }

                }
                dtOriginTable.AcceptChanges();
            }
            public static void AnalyzePeak_SlidingHourDouble(DataTable dtOriginTable,
                                           int iIndexColumn,
                                           int iIndexAccumulationColumn,
                                           double dPas,
                                           bool bSliddingHour)
            {
                if (bSliddingHour)
                {
                    AnalyzePeak_SlidingHourDouble(dtOriginTable, iIndexColumn, iIndexAccumulationColumn, dPas, 60);
                    //analyzeEnHoraireGlissantDouble(dtOriginTable, iIndexColumn, iIndexAccumulationColumn, dPas,60);
                }
                else
                {
                    AnalyzePeak_SlidingHourDouble(dtOriginTable, iIndexColumn, iIndexAccumulationColumn, dPas, dPas);
                    //MultiplyColumn(dtOriginTable, iIndexColumn, iIndexAccumulationColumn, dPas);
                }
                dtOriginTable.AcceptChanges();
            }

            public static void AnalyzePeak_SlidingHourDouble(DataTable dtOriginTable,
                                           int iIndexColumn,
                                           int iIndexAccumulationColumn,
                                           double dPas,         //sampling step
                                           double dCumulStep)   // analysis range
            {
                if (dPas >= dCumulStep)
                {
                    MultiplyColumn(dtOriginTable, iIndexColumn, iIndexAccumulationColumn, dPas);
                }
                else if (dPas < dCumulStep)
                {
                    analyzeEnHoraireGlissantDouble(dtOriginTable, iIndexColumn, iIndexAccumulationColumn, dPas, dCumulStep);
                    if (dCumulStep < 60)
                        MultiplyColumn(dtOriginTable, iIndexAccumulationColumn, iIndexAccumulationColumn, dCumulStep);
                }
                dtOriginTable.AcceptChanges();
            }

            // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
            /// <summary>
            /// Calculates the Throughput for the Occupation table from statistics
            /// </summary>
            /// <param name="occupationTable">The Occupation table for which the throughput has to be calculated </param>
            /// <param name="indexColumn">The index of the column that contains the source values(ex.: NbPax(Input))</param>
            /// <param name="indexAccumulationColumn">The index of the corresponding Throughput column</param>
            /// <param name="samplingStep">The scenario's sampling step</param>
            /// <param name="analysisRange">The scenario's analysis range</param>
            public static void calculateThroughputSliding(DataTable occupationTable, int indexColumn,
                int indexAccumulationColumn, double samplingStep, double analysisRange)
            {
                if (samplingStep >= analysisRange)
                {
                    multiplyThroughputByCoefficient(occupationTable, indexColumn, indexAccumulationColumn, samplingStep);
                }
                else if (samplingStep < analysisRange)
                {
                    sumThroughputValues(occupationTable, indexColumn, indexAccumulationColumn,
                        samplingStep, analysisRange);
                    if (analysisRange < 60)
                        multiplyThroughputByCoefficient(occupationTable, indexAccumulationColumn, indexAccumulationColumn,
                            analysisRange);
                }
                occupationTable.AcceptChanges();
            }
            // >> Task #13762 Pax2Sim - Dynamic Analysis - Occupation table
            public static void calculateThroughputInstantaneous(DataTable occupationTable, int sourceColumnIndex,
                int accumulationColumnIndex, double samplingStep)
            {
                if (samplingStep > 0)
                    multiplyThroughputByCoefficient(occupationTable, sourceColumnIndex, accumulationColumnIndex, samplingStep);
            }
            // << Task #13762 Pax2Sim - Dynamic Analysis - Occupation table
            private static void multiplyThroughputByCoefficient(DataTable occupationTable, int indexColumn,
                int indexAccumulationColumn, double hourlyDivisor)
            {
                if (hourlyDivisor == 0)
                    return;

                double coefficient = 60.0 / hourlyDivisor;

                for (int i = 0; i < occupationTable.Rows.Count; i++)
                {
                    occupationTable.Rows[i][indexAccumulationColumn] = ((Int32)occupationTable.Rows[i][indexColumn]) * coefficient;
                }

                occupationTable.AcceptChanges();
            }

            private static void sumThroughputValues(DataTable occupationTable, int indexColumn,
                int indexAccumulation, double samplingStep, double analysisRange)
            {
                int iLowerStep, iUpperStep;
                if (!DeterminePas(analysisRange, samplingStep, out iLowerStep, out iUpperStep))
                    return;

                occupationTable.Columns.Add("Tmp", typeof(Double));
                int iIndex = occupationTable.Columns.Count - 1;

                for (int i = 0; i < occupationTable.Rows.Count; i++)
                {
                    Int32 temp = 0;
                    for (int j = -iLowerStep; j <= iUpperStep; j++)
                    {
                        if ((j + i) < 0)
                            continue;
                        if ((j + i) >= occupationTable.Rows.Count)
                            break;
                        temp += ((Int32)occupationTable.Rows[i + j][indexColumn]);
                    }
                    occupationTable.Rows[i][iIndex] = temp;
                }

                for (int i = 0; i < occupationTable.Rows.Count; i++)
                {
                    occupationTable.Rows[i][indexAccumulation] = occupationTable.Rows[i][iIndex];
                }
                occupationTable.Columns.Remove("Tmp");
                return;
            }
            // >> Task #8775 Pax2Sim - Occupation stat - Throughput calculation


            /// <summary>
            /// Fonction qui calcule l'horaire glissant de la colonne passée en paramètre.
            /// </summary>
            /// <param name="dtOriginTable">Table à analyser</param>
            /// <param name="iIndexColumn">Colonne à analyser</param>
            /// <param name="iIndexAccumulationColumn">Colonne où stocker les résultats</param>
            /// <param name="dPas">Pas des colonnes (en mn). Si par exemple la table est toutes les 15 mn, alors le pas est 15</param>
            /// <returns>Retourne les valeurs Moyenne et max du flux</returns>
            private static void analyzeEnHoraireGlissant(DataTable dtOriginTable, int iIndexColumn, int iIndexAccumulationColumn, double dPas)
            {
                int iLowerStep, iUpperStep;
                if (!DeterminePas(60, dPas, out iLowerStep, out iUpperStep))
                    return;
                dtOriginTable.Columns.Add("Tmp", typeof(Double));
                int iIndex = dtOriginTable.Columns.Count - 1;
                for (int i = 0; i < dtOriginTable.Rows.Count; i++)
                {
                    Int32 temp = 0;
                    for (int j = -iLowerStep; j <= iUpperStep; j++)
                    {
                        if ((j + i) < 0)
                            continue;
                        if ((j + i) >= dtOriginTable.Rows.Count)
                            break;
                        temp += ((Int32)dtOriginTable.Rows[i + j][iIndexColumn]);
                    }
                    dtOriginTable.Rows[i][iIndex] = temp;
                }
                for (int i = 0; i < dtOriginTable.Rows.Count; i++)
                {
                    dtOriginTable.Rows[i][iIndexAccumulationColumn] = dtOriginTable.Rows[i][iIndex];
                }
                dtOriginTable.Columns.Remove("Tmp");
                return;
            }
            private static void analyzeEnHoraireGlissantDouble(DataTable dtOriginTable, int iIndexColumn, int iIndexAccumulationColumn, double dPas, Double dLargeurCumul)
            {
                int iLowerStep, iUpperStep;
                if (!DeterminePas(dLargeurCumul, dPas, out iLowerStep, out iUpperStep))
                    return;
                dtOriginTable.Columns.Add("Tmp", typeof(Double));
                int iIndex = dtOriginTable.Columns.Count - 1;
                for (int i = 0; i < dtOriginTable.Rows.Count; i++)
                {
                    Double temp = 0;
                    for (int j = -iLowerStep; j <= iUpperStep; j++)
                    {
                        if ((j + i) < 0)
                            continue;
                        if ((j + i) >= dtOriginTable.Rows.Count)
                            break;
                        temp += ((Double)dtOriginTable.Rows[i + j][iIndexColumn]);
                    }
                    dtOriginTable.Rows[i][iIndex] = temp;
                }
                for (int i = 0; i < dtOriginTable.Rows.Count; i++)
                {
                    dtOriginTable.Rows[i][iIndexAccumulationColumn] = dtOriginTable.Rows[i][iIndex];
                }
                dtOriginTable.Columns.Remove("Tmp");
            }
            private static bool DeterminePas(Double BandWidth, Double dStep, out int iLowerStep, out int iUpperStep)
            {
                iLowerStep = 0;
                iUpperStep = 0;
                if (dStep >= BandWidth)
                    return true;
                if (dStep <= 0)
                    return false;
                Double dStepTmp = BandWidth / dStep;
                if (dStepTmp <= 2)
                {
                    if (dStepTmp > 1)
                        iLowerStep = 1;
                    return true;
                }
                if (Math.Truncate(dStepTmp) != dStepTmp)
                {
                    dStepTmp = Math.Truncate(dStepTmp) + 1;
                }
                else
                {
                    dStepTmp = Math.Truncate(dStepTmp);
                }
                dStepTmp = (dStepTmp - 1) / 2;
                iUpperStep = (int)(dStepTmp);
                iLowerStep = iUpperStep;
                if (Math.Truncate(dStepTmp) != dStepTmp)
                    iLowerStep++;
                return true;
            }
            #endregion

            /// <summary>
            /// Fonction qui permet de calculer les statistiques d'une colonne d'une table (min/Mean/Max) en ignorant l'intégralité
            /// 
            /// </summary>
            /// <param name="dtTable"></param>
            /// <param name="sColumn"></param>
            /// <param name="dWarmUp"></param>
            /// <returns></returns>
            public static Double[] GetStatColumn(DataTable dtTable, String sColumn, Double dWarmUp)
            {
                if (dtTable == null)
                    return null;
                if (!dtTable.Columns.Contains(sColumn))
                    return null;
                return GetStatColumn(dtTable, dtTable.Columns.IndexOf(sColumn), dWarmUp);
            }
            public static Double[] GetStatColumn(DataTable dtTable, int iNumColumn, Double dWarmUp)
            {
                if (dtTable == null)
                    return null;
                if (iNumColumn > dtTable.Columns.Count)
                    return null;
                if (iNumColumn < 0)
                    return null;
                Type type = dtTable.Columns[iNumColumn].DataType;
                if ((type != typeof(Double)) &&
                    (type != typeof(double)) &&
                    (type != typeof(int)) &&
                    (type != typeof(Int32)) &&
                    (type != typeof(Int16)) &&
                    (type != typeof(Int64)))
                {
                    return null;
                }
                bool bDouble = ((type == typeof(Double)) ||
                                (type == typeof(double)));
                if (dtTable.Columns[0].DataType != typeof(DateTime))
                    return null;
                Double[] Result = new Double[3] { -1, 0, 0 };
                int iNbLines = 0;
                if (dtTable.Rows.Count == 0)
                {
                    Result[0] = 0;
                    return Result;
                }
                DateTime dtIgnored = (DateTime)dtTable.Rows[0][0];
                dtIgnored = dtIgnored.AddMinutes(dWarmUp);
                foreach (DataRow line in dtTable.Rows)
                {
                    if ((DateTime)line[0] < dtIgnored)
                        continue;
                    iNbLines++;
                    Double dValue = 0;
                    if (bDouble)
                    {
                        dValue = (Double)line[iNumColumn];
                    }
                    else
                    {
                        dValue = (Int32)line[iNumColumn];
                    }
                    if (dValue > Result[1])
                        Result[1] = dValue;
                    if ((Result[0] == -1) || (dValue < Result[0]))
                        Result[0] = dValue;
                    Result[2] += dValue;
                }
                if (Result[0] == -1)
                    Result[0] = 0;
                if (iNbLines > 0)
                    Result[2] = Result[2] / iNbLines;
                return Result;
            }


            #region Fonction pour le calcul de l'occupation du bureau.
            public static DataTable DeskOccupation(String sTableName,
                                                    DateTime dtBegin,
                                                    DateTime dtEnd,
                                                    Double dStep,
                                                    List<PointF> lpPoints,
                                                    bool forGroups) // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
            {
                //La définition de la table
                DataTable dtResult = new DataTable(sTableName);
                dtResult.Columns.Add("Minutes", typeof(Double));
                dtResult.Columns.Add("Occupation", typeof(Double));
                dtResult.Columns.Add("OpeningTime", typeof(Double));

                //Double dPas = dPasUtilisation;// 15;//minutes
                int i;
                List<Double> alStartResults = new List<Double>();
                List<Double> alEndResults = new List<Double>();
                int iIndexEnd;
                int iIndexStart;
                //On parcours dans un premier temps tous les Pax de ce desk et on ressort toutes les périodes d'occupation
                for (i = 0; i < lpPoints.Count; i++)
                {
                    //L'heure de début d'occupation du poste pour ce pax
                    Double StartProcess = lpPoints[i].X;
                    //L'heure de fin d'occupation du poste pour ce pax.
                    Double EndProcess = lpPoints[i].Y;

                    //On recherche dans la table des débuts de process si la fin du process courant correspond au début d'un process
                    iIndexStart = alStartResults.IndexOf(EndProcess);
                    //Idem pour la table des fin de process avec le début du process courant
                    iIndexEnd = alEndResults.IndexOf(StartProcess);


                    if ((iIndexEnd < 0) && (iIndexStart < 0))
                    {
                        //Si aucun process ne correspond, on ajoute un nouveau process.
                        alStartResults.Add(StartProcess);
                        alEndResults.Add(EndProcess);
                    }
                    else if ((iIndexEnd >= 0) && (iIndexStart < 0))
                    {
                        //Si l'un des deux process correspond à quelque chose...
                        alEndResults[iIndexEnd] = EndProcess;
                    }
                    else if ((iIndexEnd < 0) && (iIndexStart >= 0))
                    {
                        //Si l'un des deux process correspond à quelque chose...
                        alStartResults[iIndexStart] = StartProcess;
                    }
                    else
                    {
                        //Si le process coincide avec deux process existant, on en supprime un.
                        alEndResults[iIndexEnd] = alEndResults[iIndexStart];
                        alEndResults.RemoveAt(iIndexStart);
                        alStartResults.RemoveAt(iIndexStart);
                    }
                }
                int j;
                for (i = 0; i < alStartResults.Count; i++)
                {
                    int iIndexDebut = (int)(((Double)alStartResults[i]) / dStep);
                    int iIndexFin = (int)(((Double)alEndResults[i]) / dStep);
                    /*if(((Double)iIndexFin !=(((Double)alEndResults[i]) / dPas)))
                        iIndexFin++;*/
                    while (dtResult.Rows.Count <= iIndexFin)
                    {
                        DataRow newLigne = dtResult.NewRow();
                        newLigne[0] = ((dtResult.Rows.Count + 1) * dStep);
                        newLigne[1] = 0;
                        newLigne[2] = 0;
                        dtResult.Rows.Add(newLigne);
                    }
                    for (j = iIndexDebut; j <= iIndexFin; j++)
                    {
                        if (j == iIndexDebut)
                        {
                            if (j == iIndexFin)
                            {
                                dtResult.Rows[j][1] = (Double)dtResult.Rows[j][1] + ((Double)alEndResults[i] - (Double)alStartResults[i]);
                            }
                            else
                            {
                                dtResult.Rows[j][1] = (Double)dtResult.Rows[j][1] + (Double)dtResult.Rows[j][0] - (Double)alStartResults[i];
                            }
                        }
                        else if (j == iIndexFin)
                        {
                            dtResult.Rows[j][1] = (Double)dtResult.Rows[j][1] + (Double)alEndResults[i] - ((Double)dtResult.Rows[j][0] - dStep);
                        }
                        else
                        {
                            dtResult.Rows[j][1] = dStep;
                        }
                    }
                }
                DataTable dtResult2 = new DataTable(sTableName);
                dtResult2.Columns.Add("Start", typeof(DateTime));
                OverallTools.DataFunctions.initialiserLignes(dtResult2, dtBegin, dtEnd, dStep);
                dtResult2.Columns.Add("End", typeof(DateTime));
                dtResult2.Columns.Add("% Occupation", typeof(Double));
                // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard                
                if (forGroups)
                {
                    dtResult2.Columns.Add(GlobalNames.BHS_UTILIZATION_STATION_NEED_COLUMN_NAME, typeof(Int32));
                    dtResult2.Columns.Add(GlobalNames.BHS_UTILIZATION_AVERAGE_COLUMN_NAME, typeof(Double));
                }
                // << Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard

                foreach (DataRow drRow in dtResult2.Rows)
                {
                    drRow[1] = FonctionsType.getDate(drRow[0]).AddMinutes(dStep);
                    drRow[2] = 0.0;
                    // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                    if (forGroups && dtResult2.Columns.Count >= 5)
                    {
                        drRow[3] = 0.0;
                        drRow[4] = 0;
                    }
                    // << Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                }
                for (i = 0; i < dtResult.Rows.Count; i++)
                {
                    DataRow Ligne = dtResult.Rows[i];
                    if (i >= dtResult2.Rows.Count)
                        break;
                    DataRow newLigne = dtResult2.Rows[i];

                    if ((((Double)Ligne[1]) != 0)
                                                   )
                    {
                        newLigne[2] = Math.Round((FonctionsType.getDouble(Ligne[1]) / dStep) * 100, 2);
                    }
                }
                return dtResult2;
            }
            #endregion

            /*public static DataTable DeskOccupation(String sName,List<PointF> lsOccupation, Double dPas)
            {
                //La définition de la table
                DataTable dtResult = new DataTable(sName);
                dtResult.Columns.Add("Minutes", typeof(Double));
                dtResult.Columns.Add("Occupation", typeof(Double));
                dtResult.Columns.Add("OpeningTime", typeof(Double));

                int i;
                ArrayList alStartResults = new ArrayList();
                ArrayList alEndResults = new ArrayList();
                int iIndexEnd;
                int iIndexStart;
                //On parcours dans un premier temps tous les Pax de ce desk et on ressort toutes les périodes d'occupation
                for (i = 0; i < lsOccupation.Count; i++)
                {

                    //On recherche dans la table des débuts de process si la fin du process courant correspond au début d'un process
                    iIndexStart = alStartResults.IndexOf(lsOccupation[0]);
                    //Idem pour la table des fin de process avec le début du process courant
                    iIndexEnd = alEndResults.IndexOf(lsOccupation[1]);


                    if ((iIndexEnd < 0) && (iIndexStart < 0))
                    {
                        //Si aucun process ne correspond, on ajoute un nouveau process.
                        alStartResults.Add(StartProcess);
                        alEndResults.Add(EndProcess);
                    }
                    else if ((iIndexEnd >= 0) && (iIndexStart < 0))
                    {
                        //Si l'un des deux process correspond à quelque chose...
                        alEndResults[iIndexEnd] = EndProcess;
                    }
                    else if ((iIndexEnd < 0) && (iIndexStart >= 0))
                    {
                        //Si l'un des deux process correspond à quelque chose...
                        alStartResults[iIndexStart] = StartProcess;
                    }
                    else
                    {
                        //Si le process coincide avec deux process existant, on en supprime un.
                        alEndResults[iIndexEnd] = alEndResults[iIndexStart];
                        alEndResults.RemoveAt(iIndexStart);
                        alStartResults.RemoveAt(iIndexStart);
                    }
                }
                int j;
                for (i = 0; i < alStartResults.Count; i++)
                {
                    int iIndexDebut = (int)(((Double)alStartResults[i]) / dPas);
                    int iIndexFin = (int)(((Double)alEndResults[i]) / dPas);
                    while (dtResult.Rows.Count <= iIndexFin)
                    {
                        DataRow newLigne = dtResult.NewRow();
                        newLigne[0] = ((dtResult.Rows.Count + 1) * dPas);
                        newLigne[1] = 0;
                        newLigne[2] = 0;
                        dtResult.Rows.Add(newLigne);
                    }
                    for (j = iIndexDebut; j <= iIndexFin; j++)
                    {
                        if (j == iIndexDebut)
                        {
                            if (j == iIndexFin)
                            {
                                dtResult.Rows[j][1] = (Double)dtResult.Rows[j][1] + ((Double)alEndResults[i] - (Double)alStartResults[i]);
                            }
                            else
                            {
                                dtResult.Rows[j][1] = (Double)dtResult.Rows[j][1] + (Double)dtResult.Rows[j][0] - (Double)alStartResults[i];
                            }
                        }
                        else if (j == iIndexFin)
                        {
                            dtResult.Rows[j][1] = (Double)dtResult.Rows[j][1] + (Double)alEndResults[i] - ((Double)dtResult.Rows[j][0] - dPas);
                        }
                        else
                        {
                            dtResult.Rows[j][1] = dPas;
                        }
                    }
                }
                //Pour un calcul sur le temps réel d'ouverture, décommenter les 
                DataTable dtResult2 = new DataTable(sDeskName);
                dtResult2.Columns.Add("Start", typeof(DateTime));
                dtResult2.Columns.Add("End", typeof(DateTime));
                dtResult2.Columns.Add("% Occupation", typeof(Double));
                foreach (DataRow Ligne in dtResult.Rows)
                {
                    DataRow NewLigne = dtResult2.NewRow();
                    NewLigne[0] = dtHeureDebutSimulation.AddMinutes((Double)Ligne[0] - dPas);
                    NewLigne[1] = dtHeureDebutSimulation.AddMinutes((Double)Ligne[0]);
                    if ((((Double)Ligne[1]) != 0) 
                                                   )
                    {
                        NewLigne[2] = Math.Round((((Double)Ligne[1]) / dPas) * 100, 2);
                    }
                    else
                    {
                        NewLigne[2] = 0;
                    }
                    dtResult2.Rows.Add(NewLigne);
                }
                return dtResult2;
            }*/
        }
        #endregion

        #region Classe pour analyser le BAGTRACE.
        public class BagTraceAnalysis
        {

            #region Pour la gestion de Delhi
            private static bool bDelhi = false;
            public static void SetDelhiMode()
            {
                OriginatingTransferHBS4 = "HBS3M";
                OriginatingTransferHBS5 = "HBS4";
                bDelhi = true;
            }
            #endregion

            #region Les différents noms utilisés dans le bagTrace.
            private static String TerminatingQueue = "ArrQ";
            private static String TerminatingInfeed = "ArrIF";
            private static String TerminatingHBS = "ArrHBS";
            private static String TerminatingCustom = "ArrCust";
            private static String TerminatingReclaim = "ArrRecl";
            private static String TerminatingABS = "ABS";
            private bool bHasABS = false;

            private static String TransferringQueue = "TrQ";
            private static String TransferringInfeed = "TrIF";

            private static String OriginatingQueue = "CIQ";
            private static String Originating = "CI";
            private static String OriginatingCollector = "CIcoll";

            // >> Task #15087 Pax2Sim - BHS Analysis - Collector
            private static string ArrivingCollector = "ArrColl";
            private static string TransferringCollector = "TrColl";
            // << Task #15087 Pax2Sim - BHS Analysis - Collector

            private static String OriginatingTransferHBS1 = "HBS1";
            private static String OriginatingTransferHBS2 = "HBS2";
            private static String OriginatingTransferHBS3 = "HBS3";
            private static String OriginatingTransferHBS4 = "HBS4";
            private static String OriginatingTransferHBS5 = "HBS5";
            private static String OriginatingTransferSorterInduction = "SortInd";
            private static String OriginatingTransferInterLink = "IntLnk";
            private static String OriginatingTransferChute = "Chute";
            private static String OriginatingTransferMES = "MES";
            private static String OriginatingTransferEBS = "EBS";
            private bool bHasEBS = false;
            private static String OriginatingTransferBuffer = "Buffer";
            private static String OriginatingTransferMU = "MU";
            //            private static String OriginatingTransferMakeUp = "MakeUp"; // ADPi Chute

            private static String OriginatingTransferPBC_Early = "PBC-Early";
            private static String OriginatingTransferPBC_Late = "PBC-Late";
            private static String OriginatingTransferPBC_Recirc = "PBC-Recirc";
            private static String OriginatingTransferPBC_TSA = "PBC-TSA";

            private static String OriginatingTransferRecirculation = "RecircSort";
            private static String OriginatingTransferRecirculationHBS3 = "RecircHBS3";

            internal static String OriginatingTransferSorterName = "Sorters";    // >> #13391 IST Tables standardization - sorter occupation
            internal static String BHS_KEYWORD_SORTER = "Sorter";    // >> #13391 IST Tables standardization - sorter occupation

            private static String sPersonalTermTimeStamp = "Term-TimeStamp";
            private static String sPersonalTransfTimeStamp = "Transf-TimeStamp";
            private static String sPersonalOrigTimeStamp = "Orig-TimeStamp";
            private static String sPersonalDepTimeStamp = "Dep-TimeStamp";

            private static String sPersonalTermQueue = "Term-Queue";
            private static String sPersonalTransfQueue = "Transf-Queue";
            private static String sPersonalOrigQueue = "Orig-Queue";
            private static String sPersonalDepQueue = "Dep-Queue";

            private static String sPersonalTermConv = "Term-Conv";
            private static String sPersonalTransfConv = "Transf-Conv";
            private static String sPersonalOrigConv = "Orig-Conv";
            private static String sPersonalDepConv = "Dep-Conv";

            private static String sPersonalTermVeh = "Term-Veh";
            private static String sPersonalTransfVeh = "Transf-Veh";
            private static String sPersonalOrigVeh = "Orig-Veh";
            private static String sPersonalDepVeh = "Dep-Veh";

            private static String sPersonalTermWorkCenter = "Term-WorkCenter";
            private static String sPersonalTransfWorkCenter = "Transf-WorkCenter";
            private static String sPersonalOrigWorkCenter = "Orig-WorkCenter";
            private static String sPersonalDepWorkCenter = "Dep-WorkCenter";

            private static String sPersonalArrSecu = "Term-Secu";
            private static String sPersonalDepSecu = "Dep-Secu";
            private static String sPersonalArrPass = "Term-Pass";
            private static String sPersonalDepPass = "Dep-Pass";
            private static String sPersonalTrans = "Trans";
            private static String sPersonalArrGate = "ArrGate";
            private static String sPersonalDepGate = "DepGate";
            internal static String sPersonalParking = "PRK";

            public static String StoppedKeyWord = "STOPPED";
            public static String MissedKeyWord = "MISSED";
            //<< New Objects - Task#7228
            public static String sTermStorage = "Term-Storage";
            public static String sTransfStorage = "Transf-Storage";
            public static String sOrigStorage = "Orig-Storage";
            public static String sDepStorage = "Dep-Storage";

            public static String sTermStorage1 = "Term-Storage-1";
            public static String sTransfStorage1 = "Transf-Storage-1";
            public static String sOrigStorage1 = "Orig-Storage-1";
            public static String sDepStorage1 = "Dep-Storage-1";

            public static String sTermStorage2 = "Term-Storage-2";
            public static String sTransfStorage2 = "Transf-Storage-2";
            public static String sOrigStorage2 = "Orig-Storage-2";
            public static String sDepStorage2 = "Dep-Storage-2";

            public static String sTermULDMUInUsed = "Term-ULD-MU-InUsed";
            public static String sTransfULDMUInUsed = "Transf-ULD-MU-InUsed";
            public static String sOrigULDMUInUsed = "Orig-ULD-MU-InUsed";
            public static String sDepULDMUInUsed = "Dep-ULD-MU-InUsed";

            public static String sTermULDFullStorage = "Term-ULD-Full-Storage";
            public static String sTransfULDFullStorage = "Transf-ULD-Full-Storage";
            public static String sOrigULDFullStorage = "Orig-ULD-Full-Storage";
            public static String sDepULDFullStorage = "Dep-ULD-Full-Storage";

            public static String sTermULDEmptyStorage = "Term-ULD-Empty-Storage";
            public static String sTransfULDEmptyStorage = "Transf-ULD-Empty-Storage";
            public static String sOrigULDEmptyStorage = "Orig-ULD-Empty-Storage";
            public static String sDepULDEmptyStorage = "Dep-ULD-Empty-Storage";

            public static String sTermSlugs = "Term-Slugs";
            public static String sTransfSlugs = "Transf-Slugs";
            public static String sOrigSlugs = "Orig-Slugs";
            public static String sDepSlugs = "Dep-Slugs";

            public static String sTermWindow = "Term-Window";
            public static String sTransfWindow = "Transf-Window";
            public static String sOrigWindow = "Orig-Window";
            public static String sDepWindow = "Dep-Window";

            public static String sTermFlow = "Term-Flow";
            public static String sTransfFlow = "Transf-Flow";
            public static String sOrigFlow = "Orig-Flow";
            public static String sDepFlow = "Dep-Flow";

            #region Sodexi objects
            public static String sADCustomQueue = "AD-Custom-Queue";
            public static String sADOOGQueue = "AD-OOG-Queue";
            public static String sADOutputBuffer = "AD-Output-Buffer";
            public static String sADInputBuffer = "AD-Input-Buffer";
            public static String sADBagsInUsed = "AD-BagsInUsed";
            public static String sADPositionInUsed = "AD-PositionInUsed";
            public static String sADEarlyStorage = "AD-Early-Storage";
            public static String sADInfeed = "AD-Infeed";

            public static String sAAInputBuffer = "AA-Input-Buffer";
            public static String sAAInfeed = "AA-Infeed";
            public static String sAAEarlyStorage = "AA-Early-Storage";
            public static String sAAMUExport = "AA-MU-Export";
            public static String sAAMUCloserHub = "AA-MU-CloserHub";
            public static String sAAMUVrac = "AA-MU-Vrac";
            public static String sAAMUULD = "AA-MU-ULD";
            public static String sAAExportG02Early = "AA-Export-G02-Early";

            public static String sAAImport = "AA-Import";
            public static String sAAImportPoste = "AA-Import-Poste";
            public static String sAAImportPosteCHR = "AA-Import-Poste-CHR";
            public static String sAAImportPosteCYM = "AA-Import-Poste-CYM";
            #endregion
            //>> New Objects - Task#7228

            //<< New Objects(II) - Task#7367
            public static String sEBSToploader = "EBS-Toploader";
            public static String sEBSUnloader = "EBS-Unloader";

            public static String sTermVSUInputDn = "Term-VSU-Input-Dn";
            public static String sTermVSUInputUp = "Term-VSU-Input-Up";
            public static String sTermVSUOutputDn = "Term-VSU-Output-Dn";
            public static String sTermVSUOutputUp = "Term-VSU-Output-Up";

            public static String sTransfVSUInputDn = "Transf-VSU-Input-Dn";
            public static String sTransfVSUInputUp = "Transf-VSU-Input-Up";
            public static String sTransfVSUOutputDn = "Transf-VSU-Output-Dn";
            public static String sTransfVSUOutputUp = "Transf-VSU-Output-Up";

            public static String sDepVSUInputDn = "Dep-VSU-Input-Dn";
            public static String sDepVSUInputUp = "Dep-VSU-Input-Up";
            public static String sDepVSUOutputDn = "Dep-VSU-Output-Dn";
            public static String sDepVSUOutputUp = "Dep-VSU-Output-Up";

            public static String sOrigVSUInputDn = "Orig-VSU-Input-Dn";
            public static String sOrigVSUInputUp = "Orig-VSU-Input-Up";
            public static String sOrigVSUOutputDn = "Orig-VSU-Output-Dn";
            public static String sOrigVSUOutputUp = "Orig-VSU-Output-Up";

            public static List<String> OLD_VSU_BHS_TRACE_KEYWORDS = new List<String>(new String[]
                {
                    sTermVSUInputDn, sTermVSUInputUp, sTermVSUOutputDn, sTermVSUOutputUp,
                    sTransfVSUInputDn, sTransfVSUInputUp, sTransfVSUOutputDn, sTransfVSUOutputDn,
                    sDepVSUInputDn, sDepVSUInputUp, sDepVSUOutputDn, sDepVSUOutputUp,
                    sOrigVSUInputDn, sOrigVSUInputUp, sOrigVSUOutputDn, sOrigVSUOutputUp
                });

            //>> New Objects(II) - Task#7367

            // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
            public static String sICSToploader = "ICS-Toploader";
            public static String sNewICSToploader = "ICS-Loader";// >> Task #13422 Keywords improvement
            public static String sICSUnloader = "ICS-Unloader";
            // >> #13391 IST Tables standardization - sorter occupation
            public static String sICS = "ICSs"; //"ICS";
            public static String BHS_KEYWORD_ICS = "ICS";
            // << #13391 IST Tables standardization - sorter occupation
            public static String sDepReaderTimeStamp = "Dep-Reader-TimeStamp";
            public static String sICSRecirc = "ICS-Recirc";
            // >> Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader

            // >> Task #13422 Keywords improvement
            public static string BHS_KEYWORD_USER_TIMESTAMP = "User-TimeStamp";
            public static string BHS_KEYWORD_USER_QUEUE = "User-Queue";
            public static string BHS_KEYWORD_USER_CONV = "User-Conv";
            public static string BHS_KEYWORD_USER_VEH = "User-Veh";
            public static string BHS_KEYWORD_USER_WORKCENTER = "User-WorkCenter";
            public static string BHS_KEYWORD_USER_SECURITY = "User-Secu";
            public static string BHS_KEYWORD_USER_PASSPORT = "User-Pass";
            public static string BHS_KEYWORD_USER_GATE = "User-Gate";
            // << Task #13422 Keywords improvement

            // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2
            public static string BHS_TRACE_KEYWORD_ORIG_VSU = "Orig-VSU";
            public static string BHS_TRACE_KEYWORD_ORIG_VMU = "Orig-VMU";
            public static string BHS_TRACE_KEYWORD_ORIG_DIVERT = "Orig-Divert";
            public static string BHS_TRACE_KEYWORD_ORIG_MERGE = "Orig-Merge";

            public static string BHS_TRACE_KEYWORD_TRANSFER_VSU = "Transf-VSU";
            public static string BHS_TRACE_KEYWORD_TRANSFER_VMU = "Transf-VMU";
            public static string BHS_TRACE_KEYWORD_TRANSFER_DIVERT = "Transf-Divert";
            public static string BHS_TRACE_KEYWORD_TRANSFER_MERGE = "Transf-Merge";

            public static string BHS_TRACE_KEYWORD_DEP_VSU = "Dep-VSU";
            public static string BHS_TRACE_KEYWORD_DEP_VMU = "Dep-VMU";
            public static string BHS_TRACE_KEYWORD_DEP_DIVERT = "Dep-Divert";
            public static string BHS_TRACE_KEYWORD_DEP_MERGE = "Dep-Merge";

            public static string BHS_TRACE_KEYWORD_TERM_VSU = "Term-VSU";
            public static string BHS_TRACE_KEYWORD_TERM_VMU = "Term-VMU";
            public static string BHS_TRACE_KEYWORD_TERM_DIVERT = "Term-Divert";
            public static string BHS_TRACE_KEYWORD_TERM_MERGE = "Term-Merge";

            public static string BHS_TRACE_KEYWORD_ORIG_PRESORT = "Orig-Presort";
            public static string BHS_TRACE_KEYWORD_TRANSF_PRESORT = "Transf-Presort";
            public static string BHS_TRACE_KEYWORD_DEP_PRESORT = "Dep-Presort";
            public static string BHS_TRACE_KEYWORD_TERM_PRESORT = "Term-Presort";

            public static List<String> BHS_KEYWORDS_LIST_PRESORTATION
                = new List<String>(new String[] { BHS_TRACE_KEYWORD_ORIG_PRESORT, BHS_TRACE_KEYWORD_TRANSF_PRESORT,
                    BHS_TRACE_KEYWORD_DEP_PRESORT, BHS_TRACE_KEYWORD_TERM_PRESORT });
            // << Task #10316 Pax2Sim - BHS - Presortation keyword C#2

            // >> Task #13422 Keywords improvement C#24
            #region EXIT_ON_TIME
            public static string BHS_TRACE_KEYWORD_ORIG_EXIT_ON_TIME = "Orig-Exit-OnTime";
            public static string BHS_TRACE_KEYWORD_TRANSF_EXIT_ON_TIME = "Transf-Exit-OnTime";
            public static string BHS_TRACE_KEYWORD_DEP_EXIT_ON_TIME = "Dep-Exit-OnTime";
            public static string BHS_TRACE_KEYWORD_TERM_EXIT_ON_TIME = "Term-Exit-OnTime";
            #endregion

            #region EXIT_EARLY
            public static string BHS_TRACE_KEYWORD_ORIG_EXIT_EARLY = "Orig-Exit-Early";
            public static string BHS_TRACE_KEYWORD_TRANSF_EXIT_EARLY = "Transf-Exit-Early";
            public static string BHS_TRACE_KEYWORD_DEP_EXIT_EARLY = "Dep-Exit-Early";
            public static string BHS_TRACE_KEYWORD_TERM_EXIT_EARLY = "Term-Exit-Early";
            #endregion

            #region EXIT_LATE
            public static string BHS_TRACE_KEYWORD_ORIG_EXIT_LATE = "Orig-Exit-Late";
            public static string BHS_TRACE_KEYWORD_TRANSF_EXIT_LATE = "Transf-Exit-Late";
            public static string BHS_TRACE_KEYWORD_DEP_EXIT_LATE = "Dep-Exit-Late";
            public static string BHS_TRACE_KEYWORD_TERM_EXIT_LATE = "Term-Exit-Late";
            #endregion

            #region EXIT_RECIRC
            public static string BHS_TRACE_KEYWORD_ORIG_EXIT_RECIRC = "Orig-Exit-Recirc";
            public static string BHS_TRACE_KEYWORD_TRANSF_EXIT_RECIRC = "Transf-Exit-Recirc";
            public static string BHS_TRACE_KEYWORD_DEP_EXIT_RECIRC = "Dep-Exit-Recirc";
            public static string BHS_TRACE_KEYWORD_TERM_EXIT_RECIRC = "Term-Exit-Recirc";
            #endregion
            // << Task #13422 Keywords improvement C#24
            #endregion

            // >> Task #10877 Pax2Sim - BHS analysis - local IST tables for all the objects
            #region BHS objects categorized by Terminating, Departing, Originating and Transferring
            public static List<String> BHS_OBJECTS_LIST_ORIGINATING
                = new List<String>(new String[] {OriginatingQueue, Originating, OriginatingCollector, sPersonalOrigQueue, sOrigStorage, sOrigStorage1,
                                                 sOrigStorage2, sOrigULDMUInUsed, sOrigULDEmptyStorage, sOrigULDFullStorage, sOrigSlugs, sOrigFlow, sOrigWindow,
                                                 sOrigVSUInputDn, sOrigVSUInputUp, sOrigVSUOutputDn, sOrigVSUOutputUp, sPersonalOrigTimeStamp, sPersonalOrigConv,
                                                 sPersonalOrigVeh, sPersonalOrigWorkCenter, BHS_TRACE_KEYWORD_ORIG_VSU, BHS_TRACE_KEYWORD_ORIG_VMU, BHS_TRACE_KEYWORD_ORIG_DIVERT, BHS_TRACE_KEYWORD_ORIG_MERGE});

            public static List<String> BHS_OBJECTS_LIST_DEPARTING
                = new List<String>(new String[] {OriginatingTransferHBS1, OriginatingTransferHBS2, OriginatingTransferHBS3, OriginatingTransferHBS4, OriginatingTransferHBS5,
                                                 OriginatingTransferInterLink,
                                                 OriginatingTransferSorterInduction, OriginatingTransferChute, OriginatingTransferPBC_Early,
                                                 OriginatingTransferPBC_Late, OriginatingTransferPBC_TSA, OriginatingTransferMES, OriginatingTransferEBS, OriginatingTransferBuffer,
                                                 OriginatingTransferMU, sICSToploader, sNewICSToploader, sICSUnloader, sDepReaderTimeStamp, sPersonalDepQueue, sDepStorage, sDepStorage1, sDepStorage2,
                                                 sDepULDMUInUsed, sDepULDEmptyStorage, sDepULDFullStorage, sDepSlugs, sDepWindow, sDepFlow, sDepVSUInputDn, sDepVSUInputUp,
                                                 sDepVSUOutputDn, sDepVSUOutputUp, sPersonalDepTimeStamp, sPersonalDepConv, sPersonalDepVeh, sPersonalDepWorkCenter, sPersonalDepPass,
                                                 sPersonalDepSecu, sPersonalDepGate, BHS_TRACE_KEYWORD_DEP_VSU, BHS_TRACE_KEYWORD_DEP_VMU, BHS_TRACE_KEYWORD_DEP_DIVERT, BHS_TRACE_KEYWORD_DEP_MERGE});
            //OriginatingTransferMakeUp});   // ADPi Chute

            public static List<String> BHS_OBJECTS_LIST_TERMINATING
                = new List<String>(new String[] {TerminatingQueue, TerminatingInfeed, TerminatingHBS, TerminatingCustom, TerminatingABS, TerminatingReclaim, sPersonalTermQueue,
                                                 sTermStorage, sTermStorage1, sTermStorage2, sTermULDMUInUsed, sTermULDEmptyStorage, sTermULDFullStorage,
                                                 sTermSlugs, sTermFlow, sTermWindow, sTermVSUInputDn, sTermVSUInputUp, sTermVSUOutputDn, sTermVSUOutputUp, sPersonalTermTimeStamp,
                                                 sPersonalTermConv, sPersonalTermVeh, sPersonalTermWorkCenter, sPersonalArrPass, sPersonalArrSecu, sPersonalArrGate,
                                                 BHS_TRACE_KEYWORD_TERM_VSU, BHS_TRACE_KEYWORD_TERM_VMU, BHS_TRACE_KEYWORD_TERM_DIVERT, BHS_TRACE_KEYWORD_TERM_MERGE});

            public static List<String> BHS_OBJECTS_LIST_TRANSFERRING
                = new List<String>(new String[] {TransferringQueue, TransferringInfeed, sPersonalTransfQueue, sTransfStorage, sTransfStorage1, sTransfStorage2,
                                                 sTransfULDMUInUsed, sTransfULDEmptyStorage, sTransfULDFullStorage, sTransfSlugs, sTransfWindow, sTransfFlow,
                                                 sTransfVSUInputDn, sTransfVSUInputUp, sTransfVSUOutputDn, sTransfVSUOutputUp, sPersonalTransfTimeStamp,
                                                 sPersonalTransfConv, sPersonalTransfVeh, sPersonalTransfWorkCenter,
                                                 BHS_TRACE_KEYWORD_TRANSFER_VSU, BHS_TRACE_KEYWORD_TRANSFER_VMU, BHS_TRACE_KEYWORD_TRANSFER_DIVERT, BHS_TRACE_KEYWORD_TRANSFER_MERGE});

            // >> Task #13422 Keywords improvement
            public static List<string> BHS_USER_OBJECTS_LIST
                = new List<string>(new string[] { BHS_KEYWORD_USER_TIMESTAMP, BHS_KEYWORD_USER_QUEUE, BHS_KEYWORD_USER_CONV, BHS_KEYWORD_USER_VEH,
                                                    BHS_KEYWORD_USER_WORKCENTER, BHS_KEYWORD_USER_SECURITY,BHS_KEYWORD_USER_PASSPORT, BHS_KEYWORD_USER_GATE });

            public static List<string> BHS_OBJECTS_ON_3_INDEXES_LIST
                = new List<string>(new string[] { BHS_KEYWORD_USER_TIMESTAMP, BHS_KEYWORD_USER_QUEUE, BHS_KEYWORD_USER_CONV, BHS_KEYWORD_USER_VEH,
                                                    BHS_KEYWORD_USER_WORKCENTER, BHS_KEYWORD_USER_SECURITY,BHS_KEYWORD_USER_PASSPORT, BHS_KEYWORD_USER_GATE,
                                                    BHS_TRACE_KEYWORD_ORIG_VSU, BHS_TRACE_KEYWORD_ORIG_VMU, BHS_TRACE_KEYWORD_ORIG_DIVERT, BHS_TRACE_KEYWORD_ORIG_MERGE,
                                                    BHS_TRACE_KEYWORD_TRANSFER_VSU, BHS_TRACE_KEYWORD_TRANSFER_VMU, BHS_TRACE_KEYWORD_TRANSFER_DIVERT, BHS_TRACE_KEYWORD_TRANSFER_MERGE,
                                                    BHS_TRACE_KEYWORD_DEP_VSU, BHS_TRACE_KEYWORD_DEP_VMU, BHS_TRACE_KEYWORD_DEP_DIVERT, BHS_TRACE_KEYWORD_DEP_MERGE,
                                                    BHS_TRACE_KEYWORD_TERM_VSU, BHS_TRACE_KEYWORD_TERM_VMU, BHS_TRACE_KEYWORD_TERM_DIVERT, BHS_TRACE_KEYWORD_TERM_MERGE,
                                                    // >> Task #13422 Keywords improvement C#24
                                                    BHS_TRACE_KEYWORD_ORIG_EXIT_ON_TIME, BHS_TRACE_KEYWORD_TRANSF_EXIT_ON_TIME, BHS_TRACE_KEYWORD_DEP_EXIT_ON_TIME, BHS_TRACE_KEYWORD_TERM_EXIT_ON_TIME,
                                                    BHS_TRACE_KEYWORD_ORIG_EXIT_LATE, BHS_TRACE_KEYWORD_TRANSF_EXIT_LATE, BHS_TRACE_KEYWORD_DEP_EXIT_LATE, BHS_TRACE_KEYWORD_TERM_EXIT_LATE,
                                                    BHS_TRACE_KEYWORD_ORIG_EXIT_EARLY, BHS_TRACE_KEYWORD_TRANSF_EXIT_EARLY, BHS_TRACE_KEYWORD_DEP_EXIT_EARLY, BHS_TRACE_KEYWORD_TERM_EXIT_EARLY,
                                                    BHS_TRACE_KEYWORD_ORIG_EXIT_RECIRC, BHS_TRACE_KEYWORD_TRANSF_EXIT_RECIRC, BHS_TRACE_KEYWORD_DEP_EXIT_RECIRC, BHS_TRACE_KEYWORD_TERM_EXIT_RECIRC,
                                                    // << Task #13422 Keywords improvement C#24
                                                    });
            // OriginatingTransferMakeUp });   // ADPi Chute
            // << Task #13422 Keywords improvement

            public static List<string> BHS_ULD_OBJECTS_LIST
                = new List<string>(new string[] { sTermULDMUInUsed, sTransfULDMUInUsed, sOrigULDMUInUsed, sDepULDMUInUsed,
                                                  sTermULDFullStorage, sTransfULDFullStorage,sOrigULDFullStorage, sDepULDFullStorage,
                                                  sTermULDEmptyStorage, sTransfULDEmptyStorage, sOrigULDEmptyStorage, sDepULDEmptyStorage });

            #endregion

            public static String ORIGINATING_GLOBAL_IST_TABLE_NAME = "Originating_IST";
            public static String DEPARTING_GLOBAL_IST_TABLE_NAME = "Departing_IST";
            public static String TERMINATING_GLOBAL_IST_TABLE_NAME = "Terminating_IST";
            public static String TRANSFERRING_GLOBAL_IST_TABLE_NAME = "Transferring_IST";

            public static String ORIGINATING_GLOBAL_IST_BHS_TABLE_NAME = "Originating_IST_BHS";
            public static String DEPARTING_GLOBAL_IST_BHS_TABLE_NAME = "Departing_IST_BHS";
            public static String TERMINATING_GLOBAL_IST_BHS_TABLE_NAME = "Terminating_IST_BHS";
            public static String TRANSFERRING_GLOBAL_IST_BHS_TABLE_NAME = "Transferring_IST_BHS";

            #region IST Columns names (only those already existing) - when filtering for the local IST we must use this names
            public static String DEP_PRESORTATION_VSU_INPUT_DN_INDEX_IST_COLUMN_NAME = "Presortation_Index";
            public static String HBS1_INDEX_IST_COLUMN_NAME = "HBS_1_Index";
            public static String HBS2_INDEX_IST_COLUMN_NAME = "HBS_2_Index";
            public static String HBS3_INDEX_IST_COLUMN_NAME = "HBS_3_Index";
            public static String HBS4_INDEX_IST_COLUMN_NAME = "HBS_4_Index";
            public static String HBS5_INDEX_IST_COLUMN_NAME = "HBS_5_Index";

            public static String CHECK_IN_QUEUE_INDEX_IST_COLUMN_NAME = "CheckInQueue";
            public static String CHECK_IN_INDEX_IST_COLUMN_NAME = "CheckIn";
            public static String CHECK_IN_COLL_INDEX_IST_COLUMN_NAME = "CheckInCollector";
            public static String MAKE_UP_INDEX_IST_COLUMN_NAME = "MakeUp";
            public static String MES_INDEX_IST_COLUMN_NAME = "MES_Index";
            public static String EBS_INDEX_IST_COLUMN_NAME = "EBS_Index";

            public static Dictionary<String, String> BHS_STATION_TYPE_IST_COLUMN_CORRESPONDENCE_DICTIONARY
                = new Dictionary<String, String> { { OriginatingTransferHBS1, HBS1_INDEX_IST_COLUMN_NAME }, { OriginatingTransferHBS2, HBS2_INDEX_IST_COLUMN_NAME },
                                                    {OriginatingTransferHBS3, HBS3_INDEX_IST_COLUMN_NAME}, {OriginatingTransferHBS4, HBS4_INDEX_IST_COLUMN_NAME},
                                                    {OriginatingTransferHBS5, HBS5_INDEX_IST_COLUMN_NAME}, {OriginatingTransferMES, MES_INDEX_IST_COLUMN_NAME},
                                                    {OriginatingTransferEBS, EBS_INDEX_IST_COLUMN_NAME}, {OriginatingQueue, CHECK_IN_QUEUE_INDEX_IST_COLUMN_NAME},
                                                    {Originating, CHECK_IN_INDEX_IST_COLUMN_NAME}, {OriginatingCollector, CHECK_IN_COLL_INDEX_IST_COLUMN_NAME},
                                                    {OriginatingTransferMU, MAKE_UP_INDEX_IST_COLUMN_NAME},
                                                    {sDepVSUInputDn, DEP_PRESORTATION_VSU_INPUT_DN_INDEX_IST_COLUMN_NAME}};
            #endregion
            // << Task #10877 Pax2Sim - BHS analysis - local IST tables for all the objects

            // >> Task #11602 Pax2Sim - BHS analysis - Global stats not showing the child stats for DepReaderTimestamp
            public static List<String> BHS_STATIONS_WITH_TWO_INDEXES_LIST
                = new List<String>(new string[] { sDepReaderTimeStamp, OriginatingTransferSorterInduction, OriginatingTransferChute, sICSUnloader, sICSToploader, sNewICSToploader });
            // << Task #11602 Pax2Sim - BHS analysis - Global stats not showing the child stats for DepReaderTimestamp

            public static bool hasOldICSLoaderKeyword = false;  // >> Task #13422 Keywords improvement

            public static bool isOldVSUFormat = false;  // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2

            // >> Task #15087 Pax2Sim - BHS Analysis - Collector - C#8            
            public static bool foundTransferCollectorInTrace = false;
            public static bool foundTransferInfeedInTrace = false;
            // << Task #15087 Pax2Sim - BHS Analysis - Collector - C#8

            /// <summary>
            /// Number of minutes that will be below 0 for the different distributions.
            /// </summary>
            private static Double dDecallage = 20;

            #region Fonction statique qui génère l'arborescence visualisée dans le TreeView.
            public static TreeNode GenerateDirectories(ContextMenuStrip cmsDirectorysMenu)
            {
                TreeNode tnRacine = OverallTools.TreeViewFunctions.CreateDirectory(GestionDonneesHUB2SIM.sBHSAnalysis, cmsDirectorysMenu);
                return tnRacine;
            }

            public static void UpdateDirectories(TreeNode tnRacine, List<String> lsNames, String sName, String sDisplayedName, ContextMenuStrip cmsDirectorysMenu)
            {
                if ((lsNames) == null)
                    return;
                if (!lsNames.Contains(sName))
                    return;
                TreeNode tnNode = OverallTools.TreeViewFunctions.CreateDirectory(sName, sDisplayedName, cmsDirectorysMenu);
                tnRacine.Nodes.Add(tnNode);
            }
            public const string MAKE_UP_GROUP_DIRECTORY_PREFIX_NAME = "MU_g";
            public static void GenerateDirectories_old(TreeNode tnRacine, List<String> lsNames, ContextMenuStrip cmsDirectorysMenu
                                                    , Hashtable htMaxNbRecirc, bool generateMUPSegregation) // >> Task #14280 Bag Trace Loading time too long
            {
                if (tnRacine == null)
                    return;

                //<< New Objects - Task#7228
                #region Check for Sodexi objects
                bool allowCreationSodexiDirectory = false;
                bool hasADAreaObjects = false;
                bool hasAAAreaObjects = false;
                bool hasAAExportObjects = false;
                bool hasAAImportObjects = false;

                if (lsNames.Contains(sADCustomQueue) || lsNames.Contains(sADOOGQueue) || lsNames.Contains(sADOutputBuffer)
                    || lsNames.Contains(sADInputBuffer) || lsNames.Contains(sADBagsInUsed) || lsNames.Contains(sADPositionInUsed)
                    || lsNames.Contains(sADEarlyStorage) || lsNames.Contains(sADInfeed))
                    hasADAreaObjects = true;
                if (lsNames.Contains(sAAInputBuffer) || lsNames.Contains(sAAInfeed) || lsNames.Contains(sAAEarlyStorage)
                    || lsNames.Contains(sAAMUExport) || lsNames.Contains(sAAMUCloserHub) || lsNames.Contains(sAAMUVrac)
                    || lsNames.Contains(sAAMUULD) || lsNames.Contains(sAAExportG02Early))
                    hasAAExportObjects = true;
                if (lsNames.Contains(sAAImport) || lsNames.Contains(sAAImportPoste)
                    || lsNames.Contains(sAAImportPosteCHR) || lsNames.Contains(sAAImportPosteCYM))
                    hasAAImportObjects = true;

                if (hasAAImportObjects || hasAAExportObjects)
                    hasAAAreaObjects = true;
                if (hasAAAreaObjects || hasADAreaObjects)
                    allowCreationSodexiDirectory = true;
                #endregion
                //>> New Objects - Task#7228

                #region Les noeuds affichés à la racine.
                TreeNode tnTerminating = OverallTools.TreeViewFunctions.CreateDirectory("Terminating", cmsDirectorysMenu);
                TreeNode tnTransferring = OverallTools.TreeViewFunctions.CreateDirectory("Transferring", cmsDirectorysMenu);
                TreeNode tnOriginating = OverallTools.TreeViewFunctions.CreateDirectory("Originating", cmsDirectorysMenu);
                TreeNode tnDeparting = OverallTools.TreeViewFunctions.CreateDirectory("Departing", cmsDirectorysMenu);
                TreeNode tnUser = OverallTools.TreeViewFunctions.CreateDirectory(GlobalNames.BHS_USER_DIRECTORY_NAME, cmsDirectorysMenu);    // >> Task #13422 Keywords improvement
                TreeNode tnSodexiDirectory = null;
                tnRacine.Nodes.Add(tnTerminating);
                tnRacine.Nodes.Add(tnTransferring);
                tnRacine.Nodes.Add(tnOriginating);
                tnRacine.Nodes.Add(tnDeparting);
                tnRacine.Nodes.Add(tnUser);     // >> Task #13422 Keywords improvement

                if (allowCreationSodexiDirectory)
                {
                    tnSodexiDirectory = OverallTools.TreeViewFunctions.CreateDirectory("Sodexi", cmsDirectorysMenu);
                    tnRacine.Nodes.Add(tnSodexiDirectory);
                }

                // >> Task #13390 Targets for BHS Analysis output tables                
                String sTarget = GlobalNames.TARGET_DIRECTORY_NAME;
                TreeNode tnTarget = OverallTools.TreeViewFunctions.RechercherNomEnfants(sTarget, tnRacine);
                if (tnTarget == null)
                {
                    tnTarget = OverallTools.TreeViewFunctions.createBranch(sTarget, sTarget, TreeViewTag.getDirectoryNode(sTarget), null);
                    tnRacine.Nodes.Add(tnTarget);
                }
                // << Task #13390 Targets for BHS Analysis output tables

                UpdateDirectories(tnRacine, lsNames, sPersonalParking, "Car park", cmsDirectorysMenu);
                #endregion

                #region nodes declarations
                TreeNode tnFromQueueToDepReaderTimeStamp = null;
                TreeNode tnFromCIToDepReaderTimeStamp = null;
                TreeNode tnFromCollectorToDepReaderTimeStamp = null;
                TreeNode tnFromDepReaderTimeStampToLastChute = null;
                TreeNode tnFromDepReaderTimeStampToExit = null;
                TreeNode tnRecirculationTimesToLastChute = null;
                TreeNode tnRecirculationTimesToExit = null;
                TreeNode tnReaderChuteSegregationByLine = null;
                TreeNode tnReaderExitSegregationByLine = null;
                TreeNode tnReaderSegregationByLineQueue = null;
                TreeNode tnReaderSegregationByLineCI = null;
                TreeNode tnReaderSegregationByLineColl = null;
                TreeNode tnFromQueueToPresortation = null;
                TreeNode tnFromCIToPresortation = null;
                TreeNode tnFromCollectorToPresortation = null;
                TreeNode tnFromLastChuteToMakeUp = null;
                TreeNode tnFromLastChuteToExit = null;
                TreeNode tnRecirculationTimesChuteToMakeUp = null;
                TreeNode tnRecirculationTimesChuteToExit = null;
                TreeNode tnChuteExitSegregationByLine = null;
                #endregion

                #region Les noeuds affichés dans le noeud Terminating
                TreeNode tnTime = OverallTools.TreeViewFunctions.CreateDirectory("Terminating", "_Times", cmsDirectorysMenu);
                TreeNode tnFromCollector = OverallTools.TreeViewFunctions.CreateDirectory("TermColl", "From Collector", cmsDirectorysMenu);
                TreeNode tnFromCI = OverallTools.TreeViewFunctions.CreateDirectory("TermCI", "From CheckIn", cmsDirectorysMenu);
                TreeNode tnFromQueue = OverallTools.TreeViewFunctions.CreateDirectory("Term", "From Queue", cmsDirectorysMenu);
                TreeNode tnArrivalQueues = OverallTools.TreeViewFunctions.CreateDirectory(TerminatingQueue, "Arrival Queues", cmsDirectorysMenu);
                TreeNode tnArrivalInfeed = OverallTools.TreeViewFunctions.CreateDirectory(TerminatingInfeed, "Arrival Infeed", cmsDirectorysMenu);
                TreeNode tnArrivalHBS = OverallTools.TreeViewFunctions.CreateDirectory(TerminatingHBS, "Arrival HBS", cmsDirectorysMenu);
                TreeNode tnArrivalCustom = OverallTools.TreeViewFunctions.CreateDirectory(TerminatingCustom, "Arrival Custom", cmsDirectorysMenu);
                TreeNode tnArrivalABS = OverallTools.TreeViewFunctions.CreateDirectory(TerminatingABS, "Arrival ABS", cmsDirectorysMenu);
                TreeNode tnArrivalReclaim = OverallTools.TreeViewFunctions.CreateDirectory(TerminatingReclaim, "Arrival Reclaim", cmsDirectorysMenu);
                TreeNode tnArrivalCollector = OverallTools.TreeViewFunctions.CreateDirectory(ArrivingCollector, "Arrival Collector", cmsDirectorysMenu);// >> Task #15087 Pax2Sim - BHS Analysis - Collector
                // << Task #7530 Analyze Bag Trace module - Recirculation statistics
                String directoryTagForColl = "TermCollRec";
                String directoryTagForCI = "TermCIRec";
                String directoryTagForNormal = "TermRec";
                TreeNode tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                tnFromQueue.Nodes.Add(tnRecirculationTimes);
                TreeNode tnRecirculationTimesCI = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI, "Recirculation Times", cmsDirectorysMenu);
                tnFromCI.Nodes.Add(tnRecirculationTimes);
                TreeNode tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                tnFromCollector.Nodes.Add(tnRecirculationTimesColl);

                TreeNode tnRecirculations = new TreeNode();
                int maxNbRecirc = 0;
                if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsTerm].ToString(), out maxNbRecirc))
                {
                    for (int i = 0; i <= maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                    }
                    for (int i = 0; i <= maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimesCI.Nodes.Add(tnRecirculations);
                    }
                    for (int i = 0; i <= maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimes.Nodes.Add(tnRecirculations);
                    }
                }
                // >> Task #7530 Analyze Bag Trace module - Recirculation statistics
                tnTerminating.Nodes.Add(tnTime);
                tnTime.Nodes.Add(tnFromQueue);
                tnTime.Nodes.Add(tnFromCI);
                tnTime.Nodes.Add(tnFromCollector);

                tnTerminating.Nodes.Add(tnArrivalQueues);
                tnTerminating.Nodes.Add(tnArrivalInfeed);
                //tnTerminating.Nodes.Add(tnArrivalCollector);    // >> Task #15087 Pax2Sim - BHS Analysis - Collector
                tnTerminating.Nodes.Add(tnArrivalHBS);
                tnTerminating.Nodes.Add(tnArrivalCustom);
                if (!bDelhi)
                    tnTerminating.Nodes.Add(tnArrivalABS);
                tnTerminating.Nodes.Add(tnArrivalReclaim);
                UpdateDirectories(tnTerminating, lsNames, sPersonalTermQueue, "Terminating Queue", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sPersonalTermConv, "Terminating Conveyor", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sPersonalTermVeh, "Terminating Vehicle", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sPersonalTermWorkCenter, "Terminating WorkCenter", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sPersonalArrGate, "Terminating Arrival Gate", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sPersonalTermTimeStamp, "Terminating TimeStamp", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sPersonalArrSecu, "Arriving Security", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sPersonalArrPass, "Arriving Passport", cmsDirectorysMenu);
                //<< New Objects - Task#7228
                UpdateDirectories(tnTerminating, lsNames, sTermStorage, "Terminating Storage", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sTermStorage1, "Terminating Storage 1", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sTermStorage2, "Terminating Storage 2", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sTermULDMUInUsed, "Terminating ULD MU InUsed", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sTermULDFullStorage, "Terminating ULD Full Storage", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sTermULDEmptyStorage, "Terminating ULD Empty Storage", cmsDirectorysMenu);

                UpdateDirectories(tnTerminating, lsNames, sTermSlugs, "Terminating Slugs", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sTermWindow, "Terminating Window", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sTermFlow, "Terminating Flow", cmsDirectorysMenu);
                //>> New Objects - Task#7228
                //<< New Objects(II) - Task#7367
                UpdateDirectories(tnTerminating, lsNames, sTermVSUInputDn, "Terminating VSU Input Dn", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sTermVSUInputUp, "Terminating VSU Input Up", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sTermVSUOutputDn, "Terminating VSU Output Dn", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sTermVSUOutputUp, "Terminating VSU Output Up", cmsDirectorysMenu);
                //>> New Objects(II) - Task#7367
                #endregion

                #region Les noeuds affichés dans le noeud Transferring
                TreeNode tnTransferQueues = OverallTools.TreeViewFunctions.CreateDirectory(TransferringQueue, "Transfer Queues", cmsDirectorysMenu);
                TreeNode tnTransferInfeed = OverallTools.TreeViewFunctions.CreateDirectory(TransferringInfeed, "Transfer Infeed", cmsDirectorysMenu);
                TreeNode tnTransferringCollector = OverallTools.TreeViewFunctions.CreateDirectory(TransferringCollector, "Transfer Collector", cmsDirectorysMenu);  // >> Task #15087 Pax2Sim - BHS Analysis - Collector
                //TreeNode tnTransferMU = OverallTools.TreeViewFunctions.CreateDirectory("Make-Up", "Make-Up", cmsDirectorysMenu);

                #region _Times
                tnTime = OverallTools.TreeViewFunctions.CreateDirectory("Transferring", "_Times", cmsDirectorysMenu);
                // << Task #8223 Pax2Sim - BHS mode - baggs IST statistic change                
                tnFromCollector = OverallTools.TreeViewFunctions.CreateDirectory("TransfColl", "From Collector To Exit", cmsDirectorysMenu);
                tnFromCI = OverallTools.TreeViewFunctions.CreateDirectory("TransfCI", "From CheckIn To Exit", cmsDirectorysMenu);
                tnFromQueue = OverallTools.TreeViewFunctions.CreateDirectory("Transf", "From Queue To Exit", cmsDirectorysMenu);
                // >> Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                // << Task #7530 Analyze Bag Trace module - Recirculation statistics
                directoryTagForNormal = "TransfRec";
                directoryTagForCI = "TransfCIRec";
                directoryTagForColl = "TransfCollRec";
                tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                tnFromQueue.Nodes.Add(tnRecirculationTimes);
                tnRecirculationTimesCI = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI, "Recirculation Times", cmsDirectorysMenu);
                tnFromCI.Nodes.Add(tnRecirculationTimesCI);
                tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                tnFromCollector.Nodes.Add(tnRecirculationTimesColl);

                maxNbRecirc = 0;
                if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsTransf].ToString(), out maxNbRecirc))
                {
                    tnRecirculations = new TreeNode();
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                    }
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimesCI.Nodes.Add(tnRecirculations);
                    }
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimes.Nodes.Add(tnRecirculations);
                    }
                }
                // >> Task #7530 Analyze Bag Trace module - Recirculation statistics
                tnTransferring.Nodes.Add(tnTime);
                tnTime.Nodes.Add(tnFromQueue);
                tnTime.Nodes.Add(tnFromCI);
                tnTime.Nodes.Add(tnFromCollector);

                // >> Task #10026 Pax2Sim - Bag trace analysis - Originating&Transferring
                #region From Queue / CI / Collector to DepReaderTimeStamp
                TreeNode tnTransf_FromQueueToDepReaderTimeStamp = OverallTools.TreeViewFunctions.CreateDirectory("TransfReaderTimeStamp", "From Queue To Dep-Reader-TimeStamp", cmsDirectorysMenu);
                TreeNode tnTransf_FromCIToDepReaderTimeStamp = OverallTools.TreeViewFunctions.CreateDirectory("TransfCIReaderTimeStamp", "From CheckIn To Dep-Reader-TimeStamp", cmsDirectorysMenu);
                TreeNode tnTransf_FromCollectorToDepReaderTimeStamp = OverallTools.TreeViewFunctions.CreateDirectory("TransfCollReaderTimeStamp", "From Collector To Dep-Reader-TimeStamp", cmsDirectorysMenu);

                directoryTagForNormal = "TransfReaderTimeStampRec";
                directoryTagForCI = "TransfCIReaderTimeStampRec";
                directoryTagForColl = "TransfCollReaderTimeStampRec";

                tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                tnTransf_FromQueueToDepReaderTimeStamp.Nodes.Add(tnRecirculationTimes);
                tnRecirculationTimesCI = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI, "Recirculation Times", cmsDirectorysMenu);
                tnTransf_FromCIToDepReaderTimeStamp.Nodes.Add(tnRecirculationTimesCI);
                tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                tnTransf_FromCollectorToDepReaderTimeStamp.Nodes.Add(tnRecirculationTimesColl);

                maxNbRecirc = 0;
                if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                {
                    tnRecirculations = new TreeNode();
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                    }
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimesCI.Nodes.Add(tnRecirculations);
                    }
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimes.Nodes.Add(tnRecirculations);
                    }
                }

                directoryTagForNormal = "TransfReaderTimeStampSegr";
                directoryTagForCI = "TransfCIReaderTimeStampSegr";
                directoryTagForColl = "TransfCollReaderTimeStampSegr";

                TreeNode tnTransfReaderSegregationByLineQueue = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                tnTransf_FromQueueToDepReaderTimeStamp.Nodes.Add(tnTransfReaderSegregationByLineQueue);
                TreeNode tnTransfReaderSegregationByLineCI = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI, "Segregation By Line", cmsDirectorysMenu);
                tnTransf_FromCIToDepReaderTimeStamp.Nodes.Add(tnTransfReaderSegregationByLineCI);
                TreeNode tnTransfReaderSegregationByLineColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                tnTransf_FromCollectorToDepReaderTimeStamp.Nodes.Add(tnTransfReaderSegregationByLineColl);

                int nbOfReaderLines = 6;
                TreeNode tnReaderLine = new TreeNode();
                for (int i = 1; i <= nbOfReaderLines; i++)
                {
                    tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                    tnTransfReaderSegregationByLineQueue.Nodes.Add(tnReaderLine);
                }
                for (int i = 1; i <= nbOfReaderLines; i++)
                {
                    tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI + i, "Line_" + i, cmsDirectorysMenu);
                    tnTransfReaderSegregationByLineCI.Nodes.Add(tnReaderLine);
                }
                for (int i = 1; i <= nbOfReaderLines; i++)
                {
                    tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                    tnTransfReaderSegregationByLineColl.Nodes.Add(tnReaderLine);
                }

                tnTime.Nodes.Add(tnTransf_FromQueueToDepReaderTimeStamp);
                tnTime.Nodes.Add(tnTransf_FromCIToDepReaderTimeStamp);
                tnTime.Nodes.Add(tnTransf_FromCollectorToDepReaderTimeStamp);
                #endregion

                #region From DepReaderTimeStamp to LastChute and DepReaderTimeStamp to Exit
                TreeNode tnTransf_FromDepReaderTimeStampToLastChute = OverallTools.TreeViewFunctions.CreateDirectory("TransfReaderChute", "From Dep-Reader-TimeStamp To Last Chute", cmsDirectorysMenu);
                TreeNode tnTransf_FromDepReaderTimeStampToExit = OverallTools.TreeViewFunctions.CreateDirectory("TransfReaderExit", "From Dep-Reader-TimeStamp To Exit", cmsDirectorysMenu);

                directoryTagForNormal = "TransfReaderChuteRec";
                directoryTagForColl = "TransfReaderExitRec";

                TreeNode tnTransfRecirculationTimesToLastChute = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                tnTransf_FromDepReaderTimeStampToLastChute.Nodes.Add(tnTransfRecirculationTimesToLastChute);
                TreeNode tnTransfRecirculationTimesToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                tnTransf_FromDepReaderTimeStampToExit.Nodes.Add(tnTransfRecirculationTimesToExit);

                maxNbRecirc = 0;
                if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                {
                    tnRecirculations = new TreeNode();
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnTransfRecirculationTimesToExit.Nodes.Add(tnRecirculations);
                    }
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnTransfRecirculationTimesToLastChute.Nodes.Add(tnRecirculations);
                    }
                }

                directoryTagForNormal = "TransfReaderChuteSegr";
                directoryTagForColl = "TransfReaderExitSegr";

                TreeNode tnTransfReaderChuteSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                tnTransf_FromDepReaderTimeStampToLastChute.Nodes.Add(tnTransfReaderChuteSegregationByLine);
                TreeNode tnTransfReaderExitSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                tnTransf_FromDepReaderTimeStampToExit.Nodes.Add(tnTransfReaderExitSegregationByLine);

                nbOfReaderLines = 6;
                tnReaderLine = new TreeNode();
                for (int i = 1; i <= nbOfReaderLines; i++)
                {
                    tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                    tnTransfReaderChuteSegregationByLine.Nodes.Add(tnReaderLine);
                }
                for (int i = 1; i <= nbOfReaderLines; i++)
                {
                    tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                    tnTransfReaderExitSegregationByLine.Nodes.Add(tnReaderLine);
                }

                tnTime.Nodes.Add(tnTransf_FromDepReaderTimeStampToLastChute);
                tnTime.Nodes.Add(tnTransf_FromDepReaderTimeStampToExit);
                #endregion
                // << Task #10026 Pax2Sim - Bag trace analysis - Originating&Transferring

                // >> Task #15042 Pax2Sim - BHS Analysis - new EBS stats
                #region From Queue / Collector to EBS
                TreeNode tnFromQueueToEBS = OverallTools.TreeViewFunctions.CreateDirectory("TransfEBS", "From Queue To EBS", cmsDirectorysMenu);
                TreeNode tnFromCollectorToEBS = OverallTools.TreeViewFunctions.CreateDirectory("TransfCollEBS", "From Collector To EBS", cmsDirectorysMenu);

                directoryTagForNormal = "TransfEBSRec";
                directoryTagForColl = "TransfCollEBSRec";
                tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                tnFromQueueToEBS.Nodes.Add(tnRecirculationTimes);
                tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                tnFromCollectorToEBS.Nodes.Add(tnRecirculationTimesColl);

                maxNbRecirc = 0;
                if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsTransf].ToString(), out maxNbRecirc))
                {
                    tnRecirculations = new TreeNode();
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                    }
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimes.Nodes.Add(tnRecirculations);
                    }
                }

                tnTime.Nodes.Add(tnFromQueueToEBS);
                tnTime.Nodes.Add(tnFromCollectorToEBS);
                #endregion
                // << Task #15042 Pax2Sim - BHS Analysis - new EBS stats

                #region From Queue / CI / Collector to Last Chute
                // << Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                TreeNode tnFromQueueToChute = OverallTools.TreeViewFunctions.CreateDirectory("TransfChute", "From Queue To Last Chute", cmsDirectorysMenu);
                TreeNode tnFromCIToChute = OverallTools.TreeViewFunctions.CreateDirectory("TransfCIChute", "From CheckIn To Last Chute", cmsDirectorysMenu);
                TreeNode tnFromCollectorToChute = OverallTools.TreeViewFunctions.CreateDirectory("TransfCollChute", "From Collector To Last Chute", cmsDirectorysMenu);

                directoryTagForNormal = "TransfChuteRec";
                directoryTagForCI = "TransfCIChuteRec";
                directoryTagForColl = "TransfCollChuteRec";
                tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                tnFromQueueToChute.Nodes.Add(tnRecirculationTimes);
                tnRecirculationTimesCI = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI, "Recirculation Times", cmsDirectorysMenu);
                tnFromCIToChute.Nodes.Add(tnRecirculationTimesCI);
                tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                tnFromCollectorToChute.Nodes.Add(tnRecirculationTimesColl);

                maxNbRecirc = 0;
                if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsTransf].ToString(), out maxNbRecirc))
                {
                    tnRecirculations = new TreeNode();
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                    }
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimesCI.Nodes.Add(tnRecirculations);
                    }
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimes.Nodes.Add(tnRecirculations);
                    }
                }

                tnTime.Nodes.Add(tnFromQueueToChute);
                tnTime.Nodes.Add(tnFromCIToChute);
                tnTime.Nodes.Add(tnFromCollectorToChute);
                // >> Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                #endregion

                // >> Task #10026 Pax2Sim - Bag trace analysis - Originating&Transferring
                #region From Queue / CI / Collector to Presortation
                TreeNode tnTransf_FromQueueToPresortation = OverallTools.TreeViewFunctions.CreateDirectory("TransfPresortation", "From Queue To Presortation", cmsDirectorysMenu);
                TreeNode tnTransf_FromCIToPresortation = OverallTools.TreeViewFunctions.CreateDirectory("TransfCIPresortation", "From CheckIn To Presortation", cmsDirectorysMenu);
                TreeNode tnTransf_FromCollectorToPresortation = OverallTools.TreeViewFunctions.CreateDirectory("TransfCollPresortation", "From Collector To Presortation", cmsDirectorysMenu);

                directoryTagForNormal = "TransfPresortationSegr";
                directoryTagForCI = "TransfCIPresortationSegr";
                directoryTagForColl = "TransfCollPresortationSegr";

                TreeNode tnSegregationByLineQueue = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                tnTransf_FromQueueToPresortation.Nodes.Add(tnSegregationByLineQueue);
                TreeNode tnSegregationByLineCI = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI, "Segregation By Line", cmsDirectorysMenu);
                tnTransf_FromCIToPresortation.Nodes.Add(tnSegregationByLineCI);
                TreeNode tnSegregationByLineColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                tnTransf_FromCollectorToPresortation.Nodes.Add(tnSegregationByLineColl);

                int nbOfLines = 4;
                TreeNode tnLine = new TreeNode();
                for (int i = 1; i <= nbOfLines; i++)
                {
                    tnLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                    tnSegregationByLineQueue.Nodes.Add(tnLine);
                }
                for (int i = 1; i <= nbOfLines; i++)
                {
                    tnLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI + i, "Line_" + i, cmsDirectorysMenu);
                    tnSegregationByLineCI.Nodes.Add(tnLine);
                }
                for (int i = 1; i <= nbOfLines; i++)
                {
                    tnLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                    tnSegregationByLineColl.Nodes.Add(tnLine);
                }

                tnTime.Nodes.Add(tnTransf_FromQueueToPresortation);
                tnTime.Nodes.Add(tnTransf_FromCIToPresortation);
                tnTime.Nodes.Add(tnTransf_FromCollectorToPresortation);
                #endregion

                // >> Task #15042 Pax2Sim - BHS Analysis - new EBS stats
                #region From EBS to Last Chute
                TreeNode tnTransf_FromEBSToLastChute = OverallTools.TreeViewFunctions.CreateDirectory("TransfEBSChute", "From EBS To LastChute", cmsDirectorysMenu);

                directoryTagForColl = "TransfEBSChuteRec";
                TreeNode tnTransfRecirculationTimesEBSToChute = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                tnTransf_FromEBSToLastChute.Nodes.Add(tnTransfRecirculationTimesEBSToChute);

                maxNbRecirc = 0;
                if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                {
                    tnRecirculations = new TreeNode();
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnTransfRecirculationTimesEBSToChute.Nodes.Add(tnRecirculations);
                    }
                }

                tnTime.Nodes.Add(tnTransf_FromEBSToLastChute);
                #endregion

                TreeNode tnFromEBSToExit = null;
                TreeNode tnRecircFromEBSToExit = null;
                TreeNode tnSegregationByLineFromEBSToExit = null;
                TreeNode tnEBSLine = null;

                #region From EBS to Exit
                tnFromEBSToExit = OverallTools.TreeViewFunctions.CreateDirectory("TransfEBSExit", "From EBS To Exit", cmsDirectorysMenu);

                directoryTagForColl = "TransfEBSExitRec";

                tnRecircFromEBSToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                tnFromEBSToExit.Nodes.Add(tnRecircFromEBSToExit);

                maxNbRecirc = 0;
                if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                {
                    tnRecirculations = new TreeNode();
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecircFromEBSToExit.Nodes.Add(tnRecirculations);
                    }
                }

                directoryTagForColl = "TransfEBSExitSegr";

                tnSegregationByLineFromEBSToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                tnFromEBSToExit.Nodes.Add(tnSegregationByLineFromEBSToExit);

                int nbOfEBSLines = maxMakeUpStationIndex;//100;   // >> Bug #14922 Pax2Sim - BHS trace - Time chute to Exit Segregation per line problem
                tnEBSLine = new TreeNode();

                for (int i = 1; i <= nbOfEBSLines; i++)
                {
                    tnEBSLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                    tnSegregationByLineFromEBSToExit.Nodes.Add(tnEBSLine);
                }

                tnTime.Nodes.Add(tnFromEBSToExit);
                #endregion
                // << Task #15042 Pax2Sim - BHS Analysis - new EBS stats

                #region From LastChute to MakeUp
                TreeNode tnTransf_FromLastChuteToMakeUp = OverallTools.TreeViewFunctions.CreateDirectory("TransfChuteMakeUp", "From LastChute To MakeUp", cmsDirectorysMenu);

                directoryTagForColl = "TransfChuteMakeUpRec";

                TreeNode tnTransfRecirculationTimesChuteToMakeUp = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                tnTransf_FromLastChuteToMakeUp.Nodes.Add(tnTransfRecirculationTimesChuteToMakeUp);

                maxNbRecirc = 0;
                if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                {
                    tnRecirculations = new TreeNode();
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnTransfRecirculationTimesChuteToMakeUp.Nodes.Add(tnRecirculations);
                    }
                }

                tnTime.Nodes.Add(tnTransf_FromLastChuteToMakeUp);
                #endregion

                #region From LastChute to Exit
                TreeNode tnTransf_FromLastChuteToExit = OverallTools.TreeViewFunctions.CreateDirectory("TransfChuteExit", "From LastChute To Exit", cmsDirectorysMenu);

                directoryTagForColl = "TransfChuteExitRec";

                TreeNode tnTransfRecirculationTimesChuteToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                tnTransf_FromLastChuteToExit.Nodes.Add(tnTransfRecirculationTimesChuteToExit);

                maxNbRecirc = 0;
                if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                {
                    tnRecirculations = new TreeNode();
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnTransfRecirculationTimesChuteToExit.Nodes.Add(tnRecirculations);
                    }
                }

                directoryTagForColl = "TransfChuteExitSegr";

                TreeNode tnTransfChuteExitSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                tnTransf_FromLastChuteToExit.Nodes.Add(tnTransfChuteExitSegregationByLine);

                int nbOfChuteLines = maxMakeUpStationIndex;//100;   // >> Bug #14922 Pax2Sim - BHS trace - Time chute to Exit Segregation per line problem
                TreeNode tnChuteLine = new TreeNode();

                for (int i = 1; i <= nbOfChuteLines; i++)
                {
                    tnChuteLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                    tnTransfChuteExitSegregationByLine.Nodes.Add(tnChuteLine);
                }

                tnTime.Nodes.Add(tnTransf_FromLastChuteToExit);
                #endregion
                // << Task #10026 Pax2Sim - Bag trace analysis - Originating&Transferring
                #endregion

                // >> Task #13659 IST MakeUp segregation
                if (generateMUPSegregation) // >> Task #14280 Bag Trace Loading time too long
                {
                    //tnTransferring.Nodes.Add(tnTransferMU);
                    foreach (string key in makeUpSGroupsDictionary.Keys)
                    {
                        string makeupGroupDescription = "";
                        if (makeUpGroupWithDescriptionDictionary.ContainsKey(key))
                            makeupGroupDescription = makeUpGroupWithDescriptionDictionary[key];

                        //TreeNode makeupGroup = OverallTools.TreeViewFunctions.CreateDirectory(key + "(" + makeupGroupDescription + ")", key + "(" + makeupGroupDescription + ")", cmsDirectorysMenu);
                        //tnTransferMU.Nodes.Add(makeupGroup);

                        #region _Times MUP Segregation
                        TreeNode tnMakeupGroupTime = OverallTools.TreeViewFunctions.CreateDirectory("Transferring" + key, "_Times " + key + "(" + makeupGroupDescription + ")", cmsDirectorysMenu);
                        tnTime.Nodes.Add(tnMakeupGroupTime);

                        #region From Coll to Exit, CI to Exit and From Queue to Exit                        
                        tnFromCollector = OverallTools.TreeViewFunctions.CreateDirectory("TransfColl" + key, "From Collector To Exit", cmsDirectorysMenu);
                        tnFromCI = OverallTools.TreeViewFunctions.CreateDirectory("TransfCI" + key, "From CheckIn To Exit", cmsDirectorysMenu);
                        tnFromQueue = OverallTools.TreeViewFunctions.CreateDirectory("Transf" + key, "From Queue To Exit", cmsDirectorysMenu);
                        directoryTagForNormal = "Transf" + key + "Rec";
                        directoryTagForColl = "TransfCI" + key + "Rec";
                        directoryTagForColl = "TransfColl" + key + "Rec";
                        tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                        tnFromQueue.Nodes.Add(tnRecirculationTimes);
                        tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI, "Recirculation Times", cmsDirectorysMenu);
                        tnFromCI.Nodes.Add(tnRecirculationTimes);
                        tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                        tnFromCollector.Nodes.Add(tnRecirculationTimesColl);

                        maxNbRecirc = 0;
                        if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                        {
                            tnRecirculations = new TreeNode();
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                            }
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesCI.Nodes.Add(tnRecirculations);
                            }
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimes.Nodes.Add(tnRecirculations);
                            }
                        }
                        /*makeupGroup.Nodes.Add(tnTime);
                        tnTime.Nodes.Add(tnFromQueue);
                        tnTime.Nodes.Add(tnFromCI);
                        tnTime.Nodes.Add(tnFromCollector);*/
                        tnMakeupGroupTime.Nodes.Add(tnFromQueue);
                        tnMakeupGroupTime.Nodes.Add(tnFromCI);
                        tnMakeupGroupTime.Nodes.Add(tnFromCollector);
                        #endregion

                        #region From Queue/CI/Coll To DepReader
                        tnFromQueueToDepReaderTimeStamp = OverallTools.TreeViewFunctions.CreateDirectory("TransfReaderTimeStamp" + key, "From Queue To Dep-Reader-TimeStamp", cmsDirectorysMenu);
                        tnFromCIToDepReaderTimeStamp = OverallTools.TreeViewFunctions.CreateDirectory("TransfCIReaderTimeStamp" + key, "From CheckIn To Dep-Reader-TimeStamp", cmsDirectorysMenu);
                        tnFromCollectorToDepReaderTimeStamp = OverallTools.TreeViewFunctions.CreateDirectory("TransfCollReaderTimeStamp" + key, "From Collector To Dep-Reader-TimeStamp", cmsDirectorysMenu);

                        directoryTagForNormal = "TransfReaderTimeStamp" + key + "Rec";
                        directoryTagForCI = "TransfCIReaderTimeStamp" + key + "Rec";
                        directoryTagForColl = "TransfCollReaderTimeStamp" + key + "Rec";

                        tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                        tnFromQueueToDepReaderTimeStamp.Nodes.Add(tnRecirculationTimes);
                        tnRecirculationTimesCI = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI, "Recirculation Times", cmsDirectorysMenu);
                        tnFromCIToDepReaderTimeStamp.Nodes.Add(tnRecirculationTimesCI);
                        tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                        tnFromCollectorToDepReaderTimeStamp.Nodes.Add(tnRecirculationTimesColl);

                        maxNbRecirc = 0;
                        if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                        {
                            tnRecirculations = new TreeNode();
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                            }
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesCI.Nodes.Add(tnRecirculations);
                            }
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimes.Nodes.Add(tnRecirculations);
                            }
                        }
                        #endregion

                        #region From DepReader To LastChute/Exit
                        tnFromDepReaderTimeStampToLastChute = OverallTools.TreeViewFunctions.CreateDirectory("TransfReaderChute" + key, "From Dep-Reader-TimeStamp To Last Chute", cmsDirectorysMenu);
                        tnFromDepReaderTimeStampToExit = OverallTools.TreeViewFunctions.CreateDirectory("TransfReaderExit" + key, "From Dep-Reader-TimeStamp To Exit", cmsDirectorysMenu);

                        directoryTagForNormal = "TransfReaderChute" + key + "Rec";
                        directoryTagForColl = "TransfReaderExit" + key + "Rec";

                        tnRecirculationTimesToLastChute = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                        tnFromDepReaderTimeStampToLastChute.Nodes.Add(tnRecirculationTimesToLastChute);
                        tnRecirculationTimesToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                        tnFromDepReaderTimeStampToExit.Nodes.Add(tnRecirculationTimesToExit);

                        maxNbRecirc = 0;
                        if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                        {
                            tnRecirculations = new TreeNode();
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesToExit.Nodes.Add(tnRecirculations);
                            }
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesToLastChute.Nodes.Add(tnRecirculations);
                            }
                        }

                        directoryTagForNormal = "TransfReaderChute" + key + "Segr";
                        directoryTagForColl = "TransfReaderExit" + key + "Segr";

                        tnReaderChuteSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                        tnFromDepReaderTimeStampToLastChute.Nodes.Add(tnReaderChuteSegregationByLine);
                        tnReaderExitSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                        tnFromDepReaderTimeStampToExit.Nodes.Add(tnReaderExitSegregationByLine);

                        nbOfReaderLines = 6;
                        tnReaderLine = new TreeNode();
                        for (int i = 1; i <= nbOfReaderLines; i++)
                        {
                            tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                            tnReaderChuteSegregationByLine.Nodes.Add(tnReaderLine);
                        }
                        for (int i = 1; i <= nbOfReaderLines; i++)
                        {
                            tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                            tnReaderExitSegregationByLine.Nodes.Add(tnReaderLine);
                        }

                        directoryTagForNormal = "TransfReaderTimeStamp" + key + "Segr";
                        directoryTagForColl = "TransfCollReaderTimeStamp" + key + "Segr";

                        tnReaderSegregationByLineQueue = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                        tnFromQueueToDepReaderTimeStamp.Nodes.Add(tnReaderSegregationByLineQueue);
                        tnReaderSegregationByLineColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                        tnFromCollectorToDepReaderTimeStamp.Nodes.Add(tnReaderSegregationByLineColl);

                        nbOfReaderLines = 6;
                        tnReaderLine = new TreeNode();
                        for (int i = 1; i <= nbOfReaderLines; i++)
                        {
                            tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                            tnReaderSegregationByLineQueue.Nodes.Add(tnReaderLine);
                        }
                        for (int i = 1; i <= nbOfReaderLines; i++)
                        {
                            tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                            tnReaderSegregationByLineColl.Nodes.Add(tnReaderLine);
                        }
                        #endregion

                        /*
                        tnTime.Nodes.Add(tnFromQueueToDepReaderTimeStamp);
                        tnTime.Nodes.Add(tnFromCollectorToDepReaderTimeStamp);
                        tnTime.Nodes.Add(tnFromDepReaderTimeStampToLastChute);
                        tnTime.Nodes.Add(tnFromDepReaderTimeStampToExit);
                        */
                        tnMakeupGroupTime.Nodes.Add(tnFromQueueToDepReaderTimeStamp);
                        tnMakeupGroupTime.Nodes.Add(tnFromCIToDepReaderTimeStamp);
                        tnMakeupGroupTime.Nodes.Add(tnFromCollectorToDepReaderTimeStamp);
                        tnMakeupGroupTime.Nodes.Add(tnFromDepReaderTimeStampToLastChute);
                        tnMakeupGroupTime.Nodes.Add(tnFromDepReaderTimeStampToExit);

                        #region From Queue/Coll to EBS
                        // >> Task #15042 Pax2Sim - BHS Analysis - new EBS stats
                        tnFromQueueToEBS = OverallTools.TreeViewFunctions.CreateDirectory("TransfEBS" + key, "From Queue To EBS", cmsDirectorysMenu);
                        tnFromCollectorToEBS = OverallTools.TreeViewFunctions.CreateDirectory("TransfCollEBS" + key, "From Collector To EBS", cmsDirectorysMenu);

                        directoryTagForNormal = "TransfEBS" + key + "Rec";
                        directoryTagForColl = "TransfCollEBS" + key + "Rec";
                        tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                        tnFromQueueToEBS.Nodes.Add(tnRecirculationTimes);
                        tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                        tnFromCollectorToEBS.Nodes.Add(tnRecirculationTimesColl);

                        maxNbRecirc = 0;
                        if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                        {
                            tnRecirculations = new TreeNode();
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                            }
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimes.Nodes.Add(tnRecirculations);
                            }
                        }

                        tnMakeupGroupTime.Nodes.Add(tnFromQueueToEBS);
                        tnMakeupGroupTime.Nodes.Add(tnFromCollectorToEBS);
                        // << Task #15042 Pax2Sim - BHS Analysis - new EBS stats
                        #endregion

                        #region From Queue/CI/Coll to Chute
                        tnFromQueueToChute = OverallTools.TreeViewFunctions.CreateDirectory("TransfChute" + key, "From Queue To Last Chute", cmsDirectorysMenu);
                        tnFromCIToChute = OverallTools.TreeViewFunctions.CreateDirectory("TransfCIChute" + key, "From CheckIn To Last Chute", cmsDirectorysMenu);
                        tnFromCollectorToChute = OverallTools.TreeViewFunctions.CreateDirectory("TransfCollChute" + key, "From Collector To Last Chute", cmsDirectorysMenu);

                        directoryTagForNormal = "TransfChute" + key + "Rec";
                        directoryTagForCI = "TransfCIChute" + key + "Rec";
                        directoryTagForColl = "TransfCollChute" + key + "Rec";
                        tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                        tnFromQueueToChute.Nodes.Add(tnRecirculationTimes);
                        tnRecirculationTimesCI = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI, "Recirculation Times", cmsDirectorysMenu);
                        tnFromCIToChute.Nodes.Add(tnRecirculationTimesCI);
                        tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                        tnFromCollectorToChute.Nodes.Add(tnRecirculationTimesColl);

                        maxNbRecirc = 0;
                        if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                        {
                            tnRecirculations = new TreeNode();
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                            }
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesCI.Nodes.Add(tnRecirculations);
                            }
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimes.Nodes.Add(tnRecirculations);
                            }
                        }
                        /*
                        tnTime.Nodes.Add(tnFromQueueToChute);
                        tnTime.Nodes.Add(tnFromCIToChute);
                        tnTime.Nodes.Add(tnFromCollectorToChute);*/
                        tnMakeupGroupTime.Nodes.Add(tnFromQueueToChute);
                        tnMakeupGroupTime.Nodes.Add(tnFromCIToChute);
                        tnMakeupGroupTime.Nodes.Add(tnFromCollectorToChute);

                        #endregion

                        #region From Queue/CI/Coll to Presortation
                        tnFromQueueToPresortation = OverallTools.TreeViewFunctions.CreateDirectory("TransfPresortation" + key, "From Queue To Presortation", cmsDirectorysMenu);
                        tnFromCIToPresortation = OverallTools.TreeViewFunctions.CreateDirectory("TransfCIPresortation" + key, "From CheckIn To Presortation", cmsDirectorysMenu);
                        tnFromCollectorToPresortation = OverallTools.TreeViewFunctions.CreateDirectory("TransfCollPresortation" + key, "From Collector To Presortation", cmsDirectorysMenu);

                        directoryTagForNormal = "TransfPresortation" + key + "Segr";
                        directoryTagForCI = "TransfCIPresortation" + key + "Segr";
                        directoryTagForColl = "TransfCollPresortation" + key + "Segr";

                        tnSegregationByLineQueue = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                        tnFromQueueToPresortation.Nodes.Add(tnSegregationByLineQueue);
                        tnSegregationByLineCI = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI, "Segregation By Line", cmsDirectorysMenu);
                        tnFromCIToPresortation.Nodes.Add(tnSegregationByLineCI);
                        tnSegregationByLineColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                        tnFromCollectorToPresortation.Nodes.Add(tnSegregationByLineColl);

                        nbOfLines = 4;
                        tnLine = new TreeNode();
                        for (int i = 1; i <= nbOfLines; i++)
                        {
                            tnLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                            tnSegregationByLineQueue.Nodes.Add(tnLine);
                        }
                        for (int i = 1; i <= nbOfLines; i++)
                        {
                            tnLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI + i, "Line_" + i, cmsDirectorysMenu);
                            tnSegregationByLineCI.Nodes.Add(tnLine);
                        }
                        for (int i = 1; i <= nbOfLines; i++)
                        {
                            tnLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                            tnSegregationByLineColl.Nodes.Add(tnLine);
                        }
                        /*
                        tnTime.Nodes.Add(tnFromQueueToPresortation);
                        tnTime.Nodes.Add(tnFromCIToPresortation);
                        tnTime.Nodes.Add(tnFromCollectorToPresortation);*/
                        tnMakeupGroupTime.Nodes.Add(tnFromQueueToPresortation);
                        tnMakeupGroupTime.Nodes.Add(tnFromCIToPresortation);
                        tnMakeupGroupTime.Nodes.Add(tnFromCollectorToPresortation);

                        #endregion

                        // >> Task #15042 Pax2Sim - BHS Analysis - new EBS stats
                        #region From EBS to Last Chute
                        TreeNode tnFromEBSToLastChute = OverallTools.TreeViewFunctions.CreateDirectory("TransfEBSChute" + key, "From EBS To LastChute", cmsDirectorysMenu);

                        directoryTagForColl = "TransfEBSChute" + key + "Rec";
                        TreeNode tnRecirculationTimesEBSToChute = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                        tnFromEBSToLastChute.Nodes.Add(tnRecirculationTimesEBSToChute);

                        maxNbRecirc = 0;
                        if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                        {
                            tnRecirculations = new TreeNode();
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesEBSToChute.Nodes.Add(tnRecirculations);
                            }
                        }

                        //tnTime.Nodes.Add(tnFromLastChuteToMakeUp);
                        tnMakeupGroupTime.Nodes.Add(tnFromEBSToLastChute);
                        #endregion

                        #region From EBS to Exit
                        tnFromEBSToExit = OverallTools.TreeViewFunctions.CreateDirectory("TransfEBSExit" + key, "From EBS To Exit", cmsDirectorysMenu);

                        directoryTagForColl = "TransfEBSExit" + key + "Rec";

                        tnRecircFromEBSToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                        tnFromEBSToExit.Nodes.Add(tnRecircFromEBSToExit);

                        maxNbRecirc = 0;
                        if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                        {
                            tnRecirculations = new TreeNode();
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecircFromEBSToExit.Nodes.Add(tnRecirculations);
                            }
                        }

                        directoryTagForColl = "TransfEBSExit" + key + "Segr";

                        tnSegregationByLineFromEBSToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                        tnFromEBSToExit.Nodes.Add(tnSegregationByLineFromEBSToExit);

                        tnEBSLine = new TreeNode();
                        for (int i = 1; i <= nbOfEBSLines; i++)
                        {
                            tnEBSLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                            tnSegregationByLineFromEBSToExit.Nodes.Add(tnEBSLine);
                        }
                        tnMakeupGroupTime.Nodes.Add(tnFromEBSToExit);
                        #endregion
                        // << Task #15042 Pax2Sim - BHS Analysis - new EBS stats

                        #region Chute To MakeUp directory
                        tnFromLastChuteToMakeUp = OverallTools.TreeViewFunctions.CreateDirectory("TransfChuteMakeUp" + key, "From LastChute To MakeUp", cmsDirectorysMenu);

                        directoryTagForColl = "TransfChuteMakeUp" + key + "Rec";

                        tnRecirculationTimesChuteToMakeUp = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                        tnFromLastChuteToMakeUp.Nodes.Add(tnRecirculationTimesChuteToMakeUp);

                        maxNbRecirc = 0;
                        if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                        {
                            tnRecirculations = new TreeNode();
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesChuteToMakeUp.Nodes.Add(tnRecirculations);
                            }
                        }

                        //tnTime.Nodes.Add(tnFromLastChuteToMakeUp);
                        tnMakeupGroupTime.Nodes.Add(tnFromLastChuteToMakeUp);
                        #endregion

                        #region Chute To Exit directory
                        tnFromLastChuteToExit = OverallTools.TreeViewFunctions.CreateDirectory("TransfChuteExit" + key, "From LastChute To Exit", cmsDirectorysMenu);

                        directoryTagForColl = "TransfChuteExit" + key + "Rec";

                        tnRecirculationTimesChuteToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                        tnFromLastChuteToExit.Nodes.Add(tnRecirculationTimesChuteToExit);

                        maxNbRecirc = 0;
                        if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                        {
                            tnRecirculations = new TreeNode();
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesChuteToExit.Nodes.Add(tnRecirculations);
                            }
                        }

                        directoryTagForColl = "TransfChuteExit" + key + "Segr";

                        tnChuteExitSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                        tnFromLastChuteToExit.Nodes.Add(tnChuteExitSegregationByLine);

                        //nbOfChuteLines = 100;//17;
                        tnChuteLine = new TreeNode();

                        for (int i = 1; i <= nbOfChuteLines; i++)
                        {
                            tnChuteLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                            tnChuteExitSegregationByLine.Nodes.Add(tnChuteLine);
                        }
                        //tnTime.Nodes.Add(tnFromLastChuteToExit);
                        tnMakeupGroupTime.Nodes.Add(tnFromLastChuteToExit);

                        #endregion

                        #endregion
                    }

                    #region commented
                    /*
                    #region _Times MUPS3

                    #region From Coll to Exit and From Queue to Exit
                    tnTime = OverallTools.TreeViewFunctions.CreateDirectory("Transferring", "_Times_Exit_MU Group 1 (S3)", cmsDirectorysMenu);
                    // << Task #8223 Pax2Sim - BHS mode - baggs IST statistic change                
                    tnFromCollector = OverallTools.TreeViewFunctions.CreateDirectory("TransfColl" + MUP_GROUP_S3, "From Collector To Exit", cmsDirectorysMenu);
                    tnFromQueue = OverallTools.TreeViewFunctions.CreateDirectory("Transf" + MUP_GROUP_S3, "From Queue To Exit", cmsDirectorysMenu);
                    // >> Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                    // << Task #7530 Analyze Bag Trace module - Recirculation statistics
                    directoryTagForNormal = "Transf" + MUP_GROUP_S3 + "Rec";
                    directoryTagForColl = "TransfColl" + MUP_GROUP_S3 + "Rec";
                    tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                    tnFromQueue.Nodes.Add(tnRecirculationTimes);
                    tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromCollector.Nodes.Add(tnRecirculationTimesColl);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                        }
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimes.Nodes.Add(tnRecirculations);
                        }
                    }
                    // >> Task #7530 Analyze Bag Trace module - Recirculation statistics

                    tnTransferring.Nodes.Add(tnTime);
                    tnTime.Nodes.Add(tnFromQueue);
                    tnTime.Nodes.Add(tnFromCollector);
                    #endregion

                    #region From Queue/Coll To DepReader
                    // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                    tnFromQueueToDepReaderTimeStamp = OverallTools.TreeViewFunctions.CreateDirectory("TransfReaderTimeStamp" + MUP_GROUP_S3, "From Queue To Dep-Reader-TimeStamp", cmsDirectorysMenu);
                    tnFromCollectorToDepReaderTimeStamp = OverallTools.TreeViewFunctions.CreateDirectory("TransfCollReaderTimeStamp" + MUP_GROUP_S3, "From Collector To Dep-Reader-TimeStamp", cmsDirectorysMenu);

                    directoryTagForNormal = "TransfReaderTimeStamp" + MUP_GROUP_S3 + "Rec";
                    directoryTagForColl = "TransfCollReaderTimeStamp" + MUP_GROUP_S3 + "Rec";

                    tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                    tnFromQueueToDepReaderTimeStamp.Nodes.Add(tnRecirculationTimes);
                    tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromCollectorToDepReaderTimeStamp.Nodes.Add(tnRecirculationTimesColl);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                        }
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimes.Nodes.Add(tnRecirculations);
                        }
                    }
                    #endregion

                    #region From DepReader To LastChute/Exit
                    tnFromDepReaderTimeStampToLastChute = OverallTools.TreeViewFunctions.CreateDirectory("TransfReaderChute" + MUP_GROUP_S3, "From Dep-Reader-TimeStamp To Last Chute", cmsDirectorysMenu);
                    tnFromDepReaderTimeStampToExit = OverallTools.TreeViewFunctions.CreateDirectory("TransfReaderExit" + MUP_GROUP_S3, "From Dep-Reader-TimeStamp To Exit", cmsDirectorysMenu);

                    directoryTagForNormal = "TransfReaderChute" + MUP_GROUP_S3 + "Rec";
                    directoryTagForColl = "TransfReaderExit" + MUP_GROUP_S3 + "Rec";

                    tnRecirculationTimesToLastChute = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                    tnFromDepReaderTimeStampToLastChute.Nodes.Add(tnRecirculationTimesToLastChute);
                    tnRecirculationTimesToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromDepReaderTimeStampToExit.Nodes.Add(tnRecirculationTimesToExit);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesToExit.Nodes.Add(tnRecirculations);
                        }
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesToLastChute.Nodes.Add(tnRecirculations);
                        }
                    }

                    directoryTagForNormal = "TransfReaderChute" + MUP_GROUP_S3 + "Segr";
                    directoryTagForColl = "TransfReaderExit" + MUP_GROUP_S3 + "Segr";

                    tnReaderChuteSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                    tnFromDepReaderTimeStampToLastChute.Nodes.Add(tnReaderChuteSegregationByLine);
                    tnReaderExitSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                    tnFromDepReaderTimeStampToExit.Nodes.Add(tnReaderExitSegregationByLine);

                    nbOfReaderLines = 6;
                    tnReaderLine = new TreeNode();
                    for (int i = 1; i <= nbOfReaderLines; i++)
                    {
                        tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                        tnReaderChuteSegregationByLine.Nodes.Add(tnReaderLine);
                    }
                    for (int i = 1; i <= nbOfReaderLines; i++)
                    {
                        tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                        tnReaderExitSegregationByLine.Nodes.Add(tnReaderLine);
                    }

                    directoryTagForNormal = "TransfReaderTimeStamp" + MUP_GROUP_S3 + "Segr";
                    directoryTagForColl = "TransfCollReaderTimeStamp" + MUP_GROUP_S3 + "Segr";

                    tnReaderSegregationByLineQueue = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                    tnFromQueueToDepReaderTimeStamp.Nodes.Add(tnReaderSegregationByLineQueue);
                    tnReaderSegregationByLineColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                    tnFromCollectorToDepReaderTimeStamp.Nodes.Add(tnReaderSegregationByLineColl);

                    nbOfReaderLines = 6;
                    tnReaderLine = new TreeNode();
                    for (int i = 1; i <= nbOfReaderLines; i++)
                    {
                        tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                        tnReaderSegregationByLineQueue.Nodes.Add(tnReaderLine);
                    }
                    for (int i = 1; i <= nbOfReaderLines; i++)
                    {
                        tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                        tnReaderSegregationByLineColl.Nodes.Add(tnReaderLine);
                    }
                    #endregion

                    tnTime.Nodes.Add(tnFromQueueToDepReaderTimeStamp);
                    tnTime.Nodes.Add(tnFromCollectorToDepReaderTimeStamp);
                    tnTime.Nodes.Add(tnFromDepReaderTimeStampToLastChute);
                    tnTime.Nodes.Add(tnFromDepReaderTimeStampToExit);
                    // >> Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader

                    #region From Queue/Coll to Chute
                    // << Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                    tnFromQueueToChute = OverallTools.TreeViewFunctions.CreateDirectory("TransfChute" + MUP_GROUP_S3, "From Queue To Last Chute", cmsDirectorysMenu);
                    tnFromCollectorToChute = OverallTools.TreeViewFunctions.CreateDirectory("TransfCollChute" + MUP_GROUP_S3, "From Collector To Last Chute", cmsDirectorysMenu);

                    directoryTagForNormal = "TransfChute" + MUP_GROUP_S3 + "Rec";
                    directoryTagForColl = "TransfCollChute" + MUP_GROUP_S3 + "Rec";
                    tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                    tnFromQueueToChute.Nodes.Add(tnRecirculationTimes);
                    tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromCollectorToChute.Nodes.Add(tnRecirculationTimesColl);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                        }
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimes.Nodes.Add(tnRecirculations);
                        }
                    }

                    tnTime.Nodes.Add(tnFromQueueToChute);
                    tnTime.Nodes.Add(tnFromCollectorToChute);
                    // >> Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                    #endregion

                    #region From Queue/Coll to Presortation
                    // << Task #8283 Pax2Sim - BHS mode - statistics for transportaition time per period of time
                    tnFromQueueToPresortation = OverallTools.TreeViewFunctions.CreateDirectory("TransfPresortation" + MUP_GROUP_S3, "From Queue To Presortation", cmsDirectorysMenu);
                    tnFromCollectorToPresortation = OverallTools.TreeViewFunctions.CreateDirectory("TransfCollPresortation" + MUP_GROUP_S3, "From Collector To Presortation", cmsDirectorysMenu);

                    directoryTagForNormal = "TransfPresortation" + MUP_GROUP_S3 + "Segr";
                    directoryTagForColl = "TransfCollPresortation" + MUP_GROUP_S3 + "Segr";

                    tnSegregationByLineQueue = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                    tnFromQueueToPresortation.Nodes.Add(tnSegregationByLineQueue);
                    tnSegregationByLineColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                    tnFromCollectorToPresortation.Nodes.Add(tnSegregationByLineColl);

                    nbOfLines = 4;
                    tnLine = new TreeNode();
                    for (int i = 1; i <= nbOfLines; i++)
                    {
                        tnLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                        tnSegregationByLineQueue.Nodes.Add(tnLine);
                    }
                    for (int i = 1; i <= nbOfLines; i++)
                    {
                        tnLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                        tnSegregationByLineColl.Nodes.Add(tnLine);
                    }

                    tnTime.Nodes.Add(tnFromQueueToPresortation);
                    tnTime.Nodes.Add(tnFromCollectorToPresortation);
                    // >> Task #8283 Pax2Sim - BHS mode - statistics for transportaition time per period of time
                    #endregion

                    // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                    #region Chute To MakeUp directory
                    tnFromLastChuteToMakeUp = OverallTools.TreeViewFunctions.CreateDirectory("TransfChuteMakeUp" + MUP_GROUP_S3, "From LastChute To MakeUp", cmsDirectorysMenu);

                    directoryTagForColl = "TransfChuteMakeUp" + MUP_GROUP_S3 + "Rec";

                    tnRecirculationTimesChuteToMakeUp = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromLastChuteToMakeUp.Nodes.Add(tnRecirculationTimesChuteToMakeUp);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesChuteToMakeUp.Nodes.Add(tnRecirculations);
                        }
                    }

                    tnTime.Nodes.Add(tnFromLastChuteToMakeUp);
                    #endregion
                    // >> Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader

                    // << Task #9611 Pax2Sim - BHS - Analyse BHS Results Assistant - Analysis Range option
                    #region Chute To Exit directory
                    tnFromLastChuteToExit = OverallTools.TreeViewFunctions.CreateDirectory("TransfChuteExit" + MUP_GROUP_S3, "From LastChute To Exit", cmsDirectorysMenu);

                    directoryTagForColl = "TransfChuteExit" + MUP_GROUP_S3 + "Rec";

                    tnRecirculationTimesChuteToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromLastChuteToExit.Nodes.Add(tnRecirculationTimesChuteToExit);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesChuteToExit.Nodes.Add(tnRecirculations);
                        }
                    }

                    directoryTagForColl = "TransfChuteExit" + MUP_GROUP_S3 + "Segr";

                    tnChuteExitSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                    tnFromLastChuteToExit.Nodes.Add(tnChuteExitSegregationByLine);

                    nbOfChuteLines = 17;
                    tnChuteLine = new TreeNode();

                    for (int i = 1; i <= nbOfChuteLines; i++)
                    {
                        tnChuteLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                        tnChuteExitSegregationByLine.Nodes.Add(tnChuteLine);
                    }

                    tnTime.Nodes.Add(tnFromLastChuteToExit);

                    // >> Task #9611 Pax2Sim - BHS - Analyse BHS Results Assistant - Analysis Range option
                    #endregion

                    #endregion

                    #region _Times MUPS4

                    #region From Coll to Exit and From Queue to Exit
                    tnTime = OverallTools.TreeViewFunctions.CreateDirectory("Transferring", "_Times_Exit_MU Group 2 (S4)", cmsDirectorysMenu);
                    // << Task #8223 Pax2Sim - BHS mode - baggs IST statistic change                
                    tnFromCollector = OverallTools.TreeViewFunctions.CreateDirectory("TransfColl" + MUP_GROUP_S4, "From Collector To Exit", cmsDirectorysMenu);
                    tnFromQueue = OverallTools.TreeViewFunctions.CreateDirectory("Transf" + MUP_GROUP_S4, "From Queue To Exit", cmsDirectorysMenu);
                    // >> Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                    // << Task #7530 Analyze Bag Trace module - Recirculation statistics
                    directoryTagForNormal = "Transf" + MUP_GROUP_S4 + "Rec";
                    directoryTagForColl = "TransfColl" + MUP_GROUP_S4 + "Rec";
                    tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                    tnFromQueue.Nodes.Add(tnRecirculationTimes);
                    tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromCollector.Nodes.Add(tnRecirculationTimesColl);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                        }
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimes.Nodes.Add(tnRecirculations);
                        }
                    }
                    // >> Task #7530 Analyze Bag Trace module - Recirculation statistics

                    tnTransferring.Nodes.Add(tnTime);
                    tnTime.Nodes.Add(tnFromQueue);
                    tnTime.Nodes.Add(tnFromCollector);
                    #endregion

                    #region From Queue/Coll To DepReader
                    // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                    tnFromQueueToDepReaderTimeStamp = OverallTools.TreeViewFunctions.CreateDirectory("TransfReaderTimeStamp" + MUP_GROUP_S4, "From Queue To Dep-Reader-TimeStamp", cmsDirectorysMenu);
                    tnFromCollectorToDepReaderTimeStamp = OverallTools.TreeViewFunctions.CreateDirectory("TransfCollReaderTimeStamp" + MUP_GROUP_S4, "From Collector To Dep-Reader-TimeStamp", cmsDirectorysMenu);

                    directoryTagForNormal = "TransfReaderTimeStamp" + MUP_GROUP_S4 + "Rec";
                    directoryTagForColl = "TransfCollReaderTimeStamp" + MUP_GROUP_S4 + "Rec";

                    tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                    tnFromQueueToDepReaderTimeStamp.Nodes.Add(tnRecirculationTimes);
                    tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromCollectorToDepReaderTimeStamp.Nodes.Add(tnRecirculationTimesColl);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                        }
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimes.Nodes.Add(tnRecirculations);
                        }
                    }
                    #endregion

                    #region From DepReader To LastChute/Exit
                    tnFromDepReaderTimeStampToLastChute = OverallTools.TreeViewFunctions.CreateDirectory("TransfReaderChute" + MUP_GROUP_S4, "From Dep-Reader-TimeStamp To Last Chute", cmsDirectorysMenu);
                    tnFromDepReaderTimeStampToExit = OverallTools.TreeViewFunctions.CreateDirectory("TransfReaderExit" + MUP_GROUP_S4, "From Dep-Reader-TimeStamp To Exit", cmsDirectorysMenu);

                    directoryTagForNormal = "TransfReaderChute" + MUP_GROUP_S4 + "Rec";
                    directoryTagForColl = "TransfReaderExit" + MUP_GROUP_S4 + "Rec";

                    tnRecirculationTimesToLastChute = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                    tnFromDepReaderTimeStampToLastChute.Nodes.Add(tnRecirculationTimesToLastChute);
                    tnRecirculationTimesToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromDepReaderTimeStampToExit.Nodes.Add(tnRecirculationTimesToExit);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesToExit.Nodes.Add(tnRecirculations);
                        }
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesToLastChute.Nodes.Add(tnRecirculations);
                        }
                    }

                    directoryTagForNormal = "TransfReaderChute" + MUP_GROUP_S4 + "Segr";
                    directoryTagForColl = "TransfReaderExit" + MUP_GROUP_S4 + "Segr";

                    tnReaderChuteSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                    tnFromDepReaderTimeStampToLastChute.Nodes.Add(tnReaderChuteSegregationByLine);
                    tnReaderExitSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                    tnFromDepReaderTimeStampToExit.Nodes.Add(tnReaderExitSegregationByLine);

                    nbOfReaderLines = 6;
                    tnReaderLine = new TreeNode();
                    for (int i = 1; i <= nbOfReaderLines; i++)
                    {
                        tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                        tnReaderChuteSegregationByLine.Nodes.Add(tnReaderLine);
                    }
                    for (int i = 1; i <= nbOfReaderLines; i++)
                    {
                        tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                        tnReaderExitSegregationByLine.Nodes.Add(tnReaderLine);
                    }

                    directoryTagForNormal = "TransfReaderTimeStamp" + MUP_GROUP_S4 + "Segr";
                    directoryTagForColl = "TransfCollReaderTimeStamp" + MUP_GROUP_S4 + "Segr";

                    tnReaderSegregationByLineQueue = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                    tnFromQueueToDepReaderTimeStamp.Nodes.Add(tnReaderSegregationByLineQueue);
                    tnReaderSegregationByLineColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                    tnFromCollectorToDepReaderTimeStamp.Nodes.Add(tnReaderSegregationByLineColl);

                    nbOfReaderLines = 6;
                    tnReaderLine = new TreeNode();
                    for (int i = 1; i <= nbOfReaderLines; i++)
                    {
                        tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                        tnReaderSegregationByLineQueue.Nodes.Add(tnReaderLine);
                    }
                    for (int i = 1; i <= nbOfReaderLines; i++)
                    {
                        tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                        tnReaderSegregationByLineColl.Nodes.Add(tnReaderLine);
                    }
                    #endregion

                    tnTime.Nodes.Add(tnFromQueueToDepReaderTimeStamp);
                    tnTime.Nodes.Add(tnFromCollectorToDepReaderTimeStamp);
                    tnTime.Nodes.Add(tnFromDepReaderTimeStampToLastChute);
                    tnTime.Nodes.Add(tnFromDepReaderTimeStampToExit);
                    // >> Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader

                    #region From Queue/Coll to Chute
                    // << Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                    tnFromQueueToChute = OverallTools.TreeViewFunctions.CreateDirectory("TransfChute" + MUP_GROUP_S4, "From Queue To Last Chute", cmsDirectorysMenu);
                    tnFromCollectorToChute = OverallTools.TreeViewFunctions.CreateDirectory("TransfCollChute" + MUP_GROUP_S4, "From Collector To Last Chute", cmsDirectorysMenu);

                    directoryTagForNormal = "TransfChute" + MUP_GROUP_S4 + "Rec";
                    directoryTagForColl = "TransfCollChute" + MUP_GROUP_S4 + "Rec";
                    tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                    tnFromQueueToChute.Nodes.Add(tnRecirculationTimes);
                    tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromCollectorToChute.Nodes.Add(tnRecirculationTimesColl);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                        }
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimes.Nodes.Add(tnRecirculations);
                        }
                    }

                    tnTime.Nodes.Add(tnFromQueueToChute);
                    tnTime.Nodes.Add(tnFromCollectorToChute);
                    // >> Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                    #endregion

                    #region From Queue/Coll to Presortation
                    // << Task #8283 Pax2Sim - BHS mode - statistics for transportaition time per period of time
                    tnFromQueueToPresortation = OverallTools.TreeViewFunctions.CreateDirectory("TransfPresortation" + MUP_GROUP_S4, "From Queue To Presortation", cmsDirectorysMenu);
                    tnFromCollectorToPresortation = OverallTools.TreeViewFunctions.CreateDirectory("TransfCollPresortation" + MUP_GROUP_S4, "From Collector To Presortation", cmsDirectorysMenu);

                    directoryTagForNormal = "TransfPresortation" + MUP_GROUP_S4 + "Segr";
                    directoryTagForColl = "TransfCollPresortation" + MUP_GROUP_S4 + "Segr";

                    tnSegregationByLineQueue = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                    tnFromQueueToPresortation.Nodes.Add(tnSegregationByLineQueue);
                    tnSegregationByLineColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                    tnFromCollectorToPresortation.Nodes.Add(tnSegregationByLineColl);

                    nbOfLines = 4;
                    tnLine = new TreeNode();
                    for (int i = 1; i <= nbOfLines; i++)
                    {
                        tnLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                        tnSegregationByLineQueue.Nodes.Add(tnLine);
                    }
                    for (int i = 1; i <= nbOfLines; i++)
                    {
                        tnLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                        tnSegregationByLineColl.Nodes.Add(tnLine);
                    }

                    tnTime.Nodes.Add(tnFromQueueToPresortation);
                    tnTime.Nodes.Add(tnFromCollectorToPresortation);
                    // >> Task #8283 Pax2Sim - BHS mode - statistics for transportaition time per period of time
                    #endregion

                    // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                    #region Chute To MakeUp directory
                    tnFromLastChuteToMakeUp = OverallTools.TreeViewFunctions.CreateDirectory("TransfChuteMakeUp" + MUP_GROUP_S4, "From LastChute To MakeUp", cmsDirectorysMenu);

                    directoryTagForColl = "TransfChuteMakeUp" + MUP_GROUP_S4 + "Rec";

                    tnRecirculationTimesChuteToMakeUp = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromLastChuteToMakeUp.Nodes.Add(tnRecirculationTimesChuteToMakeUp);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesChuteToMakeUp.Nodes.Add(tnRecirculations);
                        }
                    }

                    tnTime.Nodes.Add(tnFromLastChuteToMakeUp);
                    #endregion
                    // >> Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader

                    // << Task #9611 Pax2Sim - BHS - Analyse BHS Results Assistant - Analysis Range option
                    #region Chute To Exit directory
                    tnFromLastChuteToExit = OverallTools.TreeViewFunctions.CreateDirectory("TransfChuteExit" + MUP_GROUP_S4, "From LastChute To Exit", cmsDirectorysMenu);

                    directoryTagForColl = "TransfChuteExit" + MUP_GROUP_S4 + "Rec";

                    tnRecirculationTimesChuteToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromLastChuteToExit.Nodes.Add(tnRecirculationTimesChuteToExit);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesChuteToExit.Nodes.Add(tnRecirculations);
                        }
                    }

                    directoryTagForColl = "TransfChuteExit" + MUP_GROUP_S4 + "Segr";

                    tnChuteExitSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                    tnFromLastChuteToExit.Nodes.Add(tnChuteExitSegregationByLine);

                    nbOfChuteLines = 17;
                    tnChuteLine = new TreeNode();

                    for (int i = 1; i <= nbOfChuteLines; i++)
                    {
                        tnChuteLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                        tnChuteExitSegregationByLine.Nodes.Add(tnChuteLine);
                    }

                    tnTime.Nodes.Add(tnFromLastChuteToExit);

                    // >> Task #9611 Pax2Sim - BHS - Analyse BHS Results Assistant - Analysis Range option
                    #endregion

                    #endregion
                    */
                    #endregion
                }
                // << Task #13659 IST MakeUp segregation

                tnTransferring.Nodes.Add(tnTransferQueues);
                tnTransferring.Nodes.Add(tnTransferInfeed);
                //tnTransferring.Nodes.Add(tnTransferringCollector);  // >> Task #15087 Pax2Sim - BHS Analysis - Collector
                UpdateDirectories(tnTransferring, lsNames, sPersonalTransfQueue, "Transferring Queue", cmsDirectorysMenu);
                UpdateDirectories(tnTransferring, lsNames, sPersonalTransfConv, "Transferring Conveyor", cmsDirectorysMenu);
                UpdateDirectories(tnTransferring, lsNames, sPersonalTransfVeh, "Transferring Vehicle", cmsDirectorysMenu);
                UpdateDirectories(tnTransferring, lsNames, sPersonalTransfWorkCenter, "Transferring WorkCenter", cmsDirectorysMenu);
                UpdateDirectories(tnTransferring, lsNames, sPersonalTransfTimeStamp, "Transferring TimeStamp", cmsDirectorysMenu);
                UpdateDirectories(tnTransferring, lsNames, sPersonalTrans, "Transfering Desk", cmsDirectorysMenu);
                //<< New Objects - Task#7228
                UpdateDirectories(tnTransferring, lsNames, sTransfStorage, "Transferring Storage", cmsDirectorysMenu);
                UpdateDirectories(tnTransferring, lsNames, sTransfStorage1, "Transferring Storage 1", cmsDirectorysMenu);
                UpdateDirectories(tnTransferring, lsNames, sTransfStorage2, "Transferring Storage 2", cmsDirectorysMenu);
                UpdateDirectories(tnTransferring, lsNames, sTransfULDMUInUsed, "Transferring ULD MU InUsed", cmsDirectorysMenu);
                UpdateDirectories(tnTransferring, lsNames, sTransfULDFullStorage, "Transferring ULD Full Storage", cmsDirectorysMenu);
                UpdateDirectories(tnTransferring, lsNames, sTransfULDEmptyStorage, "Transferring ULD Empty Storage", cmsDirectorysMenu);

                UpdateDirectories(tnTransferring, lsNames, sTransfSlugs, "Transferring Slugs", cmsDirectorysMenu);
                UpdateDirectories(tnTransferring, lsNames, sTransfWindow, "Transferring Window", cmsDirectorysMenu);
                UpdateDirectories(tnTransferring, lsNames, sTransfFlow, "Transferring Flow", cmsDirectorysMenu);
                //>> New Objects - Task#7228
                //<< New Objects(II) - Task#7367
                UpdateDirectories(tnTransferring, lsNames, sTransfVSUInputDn, "Transferring VSU Input Dn", cmsDirectorysMenu);
                UpdateDirectories(tnTransferring, lsNames, sTransfVSUInputUp, "Transferring VSU Input Up", cmsDirectorysMenu);
                UpdateDirectories(tnTransferring, lsNames, sTransfVSUOutputDn, "Transferring VSU Output Dn", cmsDirectorysMenu);
                UpdateDirectories(tnTransferring, lsNames, sTransfVSUOutputUp, "Transferring VSU Output Up", cmsDirectorysMenu);
                //>> New Objects(II) - Task#7367
                #endregion

                #region Les noeuds affichés dans le noeud Originating
                TreeNode tnOriginatingCheckInQueues = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingQueue, "Check-In Queues", cmsDirectorysMenu);
                TreeNode tnOriginatingCheckIn = OverallTools.TreeViewFunctions.CreateDirectory(Originating, "Check-In", cmsDirectorysMenu);
                TreeNode tnOriginatingCheckInCollector = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingCollector, "Check-In Collectors", cmsDirectorysMenu);
                //TreeNode tnOriginatingMU = OverallTools.TreeViewFunctions.CreateDirectory("Make-Up", "Make-Up", cmsDirectorysMenu);

                #region _Times
                tnTime = OverallTools.TreeViewFunctions.CreateDirectory("Originating", "_Times", cmsDirectorysMenu);
                // << Task #8223 Pax2Sim - BHS mode - baggs IST statistic change                
                tnFromCollector = OverallTools.TreeViewFunctions.CreateDirectory("OrigColl", "From Collector To Exit", cmsDirectorysMenu);
                tnFromCI = OverallTools.TreeViewFunctions.CreateDirectory("OrigCI", "From CheckIn To Exit", cmsDirectorysMenu); // >> #13391 IST Tables standardization - IST - CI times columns
                tnFromQueue = OverallTools.TreeViewFunctions.CreateDirectory("Orig", "From Queue To Exit", cmsDirectorysMenu);
                // >> Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                // << Task #7530 Analyze Bag Trace module - Recirculation statistics
                directoryTagForNormal = "OrigRec";
                directoryTagForColl = "OrigCollRec";
                directoryTagForCI = "OrigCIRec";
                tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                tnFromQueue.Nodes.Add(tnRecirculationTimes);
                tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                tnFromCollector.Nodes.Add(tnRecirculationTimesColl);
                tnRecirculationTimesCI = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI, "Recirculation Times", cmsDirectorysMenu);
                tnFromCI.Nodes.Add(tnRecirculationTimesCI);

                maxNbRecirc = 0;
                if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsOrig].ToString(), out maxNbRecirc))
                {
                    tnRecirculations = new TreeNode();
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                    }
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimesCI.Nodes.Add(tnRecirculations);
                    }
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimes.Nodes.Add(tnRecirculations);
                    }
                }
                // >> Task #7530 Analyze Bag Trace module - Recirculation statistics

                tnOriginating.Nodes.Add(tnTime);
                tnTime.Nodes.Add(tnFromQueue);
                tnTime.Nodes.Add(tnFromCI);
                tnTime.Nodes.Add(tnFromCollector);

                // >> Task #10026 Pax2Sim - Bag trace analysis - Originating&Transferring
                #region From Queue/CI/Collector to DepReaderTimeStamp
                TreeNode tnOrig_FromQueueToDepReaderTimeStamp = OverallTools.TreeViewFunctions.CreateDirectory("OrigReaderTimeStamp", "From Queue To Dep-Reader-TimeStamp", cmsDirectorysMenu);
                TreeNode tnOrig_FromCIToDepReaderTimeStamp = OverallTools.TreeViewFunctions.CreateDirectory("OrigCIReaderTimeStamp", "From CheckIn To Dep-Reader-TimeStamp", cmsDirectorysMenu);
                TreeNode tnOrig_FromCollectorToDepReaderTimeStamp = OverallTools.TreeViewFunctions.CreateDirectory("OrigCollReaderTimeStamp", "From Collector To Dep-Reader-TimeStamp", cmsDirectorysMenu);

                directoryTagForNormal = "OrigReaderTimeStampRec";
                directoryTagForCI = "OrigCIReaderTimeStampRec";
                directoryTagForColl = "OrigCollReaderTimeStampRec";

                tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                tnOrig_FromQueueToDepReaderTimeStamp.Nodes.Add(tnRecirculationTimes);
                tnRecirculationTimesCI = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI, "Recirculation Times", cmsDirectorysMenu);
                tnOrig_FromCIToDepReaderTimeStamp.Nodes.Add(tnRecirculationTimesCI);
                tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                tnOrig_FromCollectorToDepReaderTimeStamp.Nodes.Add(tnRecirculationTimesColl);

                maxNbRecirc = 0;
                if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                {
                    tnRecirculations = new TreeNode();
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                    }
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimesCI.Nodes.Add(tnRecirculations);
                    }
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimes.Nodes.Add(tnRecirculations);
                    }
                }

                directoryTagForNormal = "OrigReaderTimeStampSegr";
                directoryTagForCI = "OrigCIReaderTimeStampSegr";
                directoryTagForColl = "OrigCollReaderTimeStampSegr";

                TreeNode tnOrigReaderSegregationByLineQueue = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                tnOrig_FromQueueToDepReaderTimeStamp.Nodes.Add(tnOrigReaderSegregationByLineQueue);
                TreeNode tnOrigReaderSegregationByLineCI = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI, "Segregation By Line", cmsDirectorysMenu);
                tnOrig_FromCIToDepReaderTimeStamp.Nodes.Add(tnOrigReaderSegregationByLineCI);
                TreeNode tnOrigReaderSegregationByLineColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                tnOrig_FromCollectorToDepReaderTimeStamp.Nodes.Add(tnOrigReaderSegregationByLineColl);

                nbOfReaderLines = 6;
                tnReaderLine = new TreeNode();
                for (int i = 1; i <= nbOfReaderLines; i++)
                {
                    tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                    tnOrigReaderSegregationByLineQueue.Nodes.Add(tnReaderLine);
                }
                for (int i = 1; i <= nbOfReaderLines; i++)
                {
                    tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI + i, "Line_" + i, cmsDirectorysMenu);
                    tnOrigReaderSegregationByLineCI.Nodes.Add(tnReaderLine);
                }
                for (int i = 1; i <= nbOfReaderLines; i++)
                {
                    tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                    tnOrigReaderSegregationByLineColl.Nodes.Add(tnReaderLine);
                }

                tnTime.Nodes.Add(tnOrig_FromQueueToDepReaderTimeStamp);
                tnTime.Nodes.Add(tnOrig_FromCIToDepReaderTimeStamp);
                tnTime.Nodes.Add(tnOrig_FromCollectorToDepReaderTimeStamp);
                #endregion

                #region From DepReaderTimeStamp to LastChute and From DepReaderTimeStamp to Exit
                TreeNode tnOrig_FromDepReaderTimeStampToLastChute = OverallTools.TreeViewFunctions.CreateDirectory("OrigReaderChute", "From Dep-Reader-TimeStamp To Last Chute", cmsDirectorysMenu);
                TreeNode tnOrig_FromDepReaderTimeStampToExit = OverallTools.TreeViewFunctions.CreateDirectory("OrigReaderExit", "From Dep-Reader-TimeStamp To Exit", cmsDirectorysMenu);

                directoryTagForNormal = "OrigReaderChuteRec";
                directoryTagForColl = "OrigReaderExitRec";

                TreeNode tnOrigRecirculationTimesToLastChute = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                tnOrig_FromDepReaderTimeStampToLastChute.Nodes.Add(tnOrigRecirculationTimesToLastChute);
                TreeNode tnOrigRecirculationTimesToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                tnOrig_FromDepReaderTimeStampToExit.Nodes.Add(tnOrigRecirculationTimesToExit);

                maxNbRecirc = 0;
                if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                {
                    tnRecirculations = new TreeNode();
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnOrigRecirculationTimesToExit.Nodes.Add(tnRecirculations);
                    }
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnOrigRecirculationTimesToLastChute.Nodes.Add(tnRecirculations);
                    }
                }

                directoryTagForNormal = "OrigReaderChuteSegr";
                directoryTagForColl = "OrigReaderExitSegr";

                TreeNode tnOrigReaderChuteSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                tnOrig_FromDepReaderTimeStampToLastChute.Nodes.Add(tnOrigReaderChuteSegregationByLine);
                TreeNode tnOrigReaderExitSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                tnOrig_FromDepReaderTimeStampToExit.Nodes.Add(tnOrigReaderExitSegregationByLine);

                nbOfReaderLines = 6;
                tnReaderLine = new TreeNode();
                for (int i = 1; i <= nbOfReaderLines; i++)
                {
                    tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                    tnOrigReaderChuteSegregationByLine.Nodes.Add(tnReaderLine);
                }
                for (int i = 1; i <= nbOfReaderLines; i++)
                {
                    tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                    tnOrigReaderExitSegregationByLine.Nodes.Add(tnReaderLine);
                }

                tnTime.Nodes.Add(tnOrig_FromDepReaderTimeStampToLastChute);
                tnTime.Nodes.Add(tnOrig_FromDepReaderTimeStampToExit);
                #endregion
                // << Task #10026 Pax2Sim - Bag trace analysis - Originating&Transferring

                #region From Queue/Coll to EBS
                // >> Task #15042 Pax2Sim - BHS Analysis - new EBS stats
                tnFromQueueToEBS = OverallTools.TreeViewFunctions.CreateDirectory("OrigEBS", "From Queue To EBS", cmsDirectorysMenu);
                tnFromCollectorToEBS = OverallTools.TreeViewFunctions.CreateDirectory("OrigCollEBS", "From Collector To EBS", cmsDirectorysMenu);

                directoryTagForNormal = "OrigEBSRec";
                directoryTagForColl = "OrigCollEBSRec";

                tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                tnFromQueueToEBS.Nodes.Add(tnRecirculationTimes);
                tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                tnFromCollectorToEBS.Nodes.Add(tnRecirculationTimesColl);

                maxNbRecirc = 0;
                if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsOrig].ToString(), out maxNbRecirc))
                {
                    tnRecirculations = new TreeNode();
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                    }
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimes.Nodes.Add(tnRecirculations);
                    }
                }

                tnTime.Nodes.Add(tnFromQueueToEBS);
                tnTime.Nodes.Add(tnFromCollectorToEBS);
                // << Task #15042 Pax2Sim - BHS Analysis - new EBS stats
                #endregion

                #region From Queue/CI/Coll to Last Chute
                // << Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                tnFromQueueToChute = OverallTools.TreeViewFunctions.CreateDirectory("OrigChute", "From Queue To Last Chute", cmsDirectorysMenu);
                tnFromCIToChute = OverallTools.TreeViewFunctions.CreateDirectory("OrigCIChute", "From CheckIn To Last Chute", cmsDirectorysMenu);
                tnFromCollectorToChute = OverallTools.TreeViewFunctions.CreateDirectory("OrigCollChute", "From Collector To Last Chute", cmsDirectorysMenu);

                directoryTagForNormal = "OrigChuteRec";
                directoryTagForColl = "OrigCollChuteRec";
                directoryTagForCI = "OrigCIChuteRec";
                tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                tnFromQueueToChute.Nodes.Add(tnRecirculationTimes);
                tnRecirculationTimesCI = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI, "Recirculation Times", cmsDirectorysMenu);
                tnFromCIToChute.Nodes.Add(tnRecirculationTimesCI);
                tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                tnFromCollectorToChute.Nodes.Add(tnRecirculationTimesColl);

                maxNbRecirc = 0;
                if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsOrig].ToString(), out maxNbRecirc))
                {
                    tnRecirculations = new TreeNode();
                    for (int i = 0; i <= maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                    }
                    for (int i = 0; i <= maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimesCI.Nodes.Add(tnRecirculations);
                    }
                    for (int i = 0; i <= maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimes.Nodes.Add(tnRecirculations);
                    }
                }

                tnTime.Nodes.Add(tnFromQueueToChute);
                tnTime.Nodes.Add(tnFromCIToChute);
                tnTime.Nodes.Add(tnFromCollectorToChute);
                // >> Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                #endregion

                // >> Task #10026 Pax2Sim - Bag trace analysis - Originating&Transferring
                #region From Queue/CI/Collector to Presortation
                TreeNode tnOrig_FromQueueToPresortation = OverallTools.TreeViewFunctions.CreateDirectory("OrigPresortation", "From Queue To Presortation", cmsDirectorysMenu);
                TreeNode tnOrig_FromCIToPresortation = OverallTools.TreeViewFunctions.CreateDirectory("OrigCIPresortation", "From CheckIn To Presortation", cmsDirectorysMenu);
                TreeNode tnOrig_FromCollectorToPresortation = OverallTools.TreeViewFunctions.CreateDirectory("OrigCollPresortation", "From Collector To Presortation", cmsDirectorysMenu);

                directoryTagForNormal = "OrigPresortationSegr";
                directoryTagForCI = "OrigCIPresortationSegr";
                directoryTagForColl = "OrigCollPresortationSegr";

                tnSegregationByLineQueue = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                tnOrig_FromQueueToPresortation.Nodes.Add(tnSegregationByLineQueue);
                tnSegregationByLineCI = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI, "Segregation By Line", cmsDirectorysMenu);
                tnOrig_FromCIToPresortation.Nodes.Add(tnSegregationByLineCI);
                tnSegregationByLineColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                tnOrig_FromCollectorToPresortation.Nodes.Add(tnSegregationByLineColl);

                nbOfLines = 4;
                tnLine = new TreeNode();
                for (int i = 1; i <= nbOfLines; i++)
                {
                    tnLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                    tnSegregationByLineQueue.Nodes.Add(tnLine);
                }
                for (int i = 1; i <= nbOfLines; i++)
                {
                    tnLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI + i, "Line_" + i, cmsDirectorysMenu);
                    tnSegregationByLineCI.Nodes.Add(tnLine);
                }
                for (int i = 1; i <= nbOfLines; i++)
                {
                    tnLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                    tnSegregationByLineColl.Nodes.Add(tnLine);
                }

                tnTime.Nodes.Add(tnOrig_FromQueueToPresortation);
                tnTime.Nodes.Add(tnOrig_FromCIToPresortation);
                tnTime.Nodes.Add(tnOrig_FromCollectorToPresortation);
                #endregion

                // >> Task #15042 Pax2Sim - BHS Analysis - new EBS stats
                #region From EBS to Last Chute
                TreeNode tnOrigFromEBSToChute = OverallTools.TreeViewFunctions.CreateDirectory("OrigEBSChute", "From EBS To LastChute", cmsDirectorysMenu);

                directoryTagForColl = "OrigEBSChuteRec";

                TreeNode tnOrigRecirculationTimesEBSChute = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                tnOrigFromEBSToChute.Nodes.Add(tnOrigRecirculationTimesEBSChute);

                maxNbRecirc = 0;
                if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                {
                    tnRecirculations = new TreeNode();
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnOrigRecirculationTimesEBSChute.Nodes.Add(tnRecirculations);
                    }
                }

                tnTime.Nodes.Add(tnOrigFromEBSToChute);
                #endregion

                #region From EBS to exit
                tnFromEBSToExit = OverallTools.TreeViewFunctions.CreateDirectory("OrigEBSExit", "From EBS To Exit", cmsDirectorysMenu);

                directoryTagForColl = "OrigEBSExitRec";

                tnRecircFromEBSToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                tnFromEBSToExit.Nodes.Add(tnRecircFromEBSToExit);

                maxNbRecirc = 0;
                if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                {
                    tnRecirculations = new TreeNode();
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecircFromEBSToExit.Nodes.Add(tnRecirculations);
                    }
                }

                directoryTagForColl = "OrigEBSExitSegr";

                tnSegregationByLineFromEBSToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                tnFromEBSToExit.Nodes.Add(tnSegregationByLineFromEBSToExit);

                //nbOfChuteLines = 100;
                tnEBSLine = new TreeNode();

                for (int i = 1; i <= nbOfEBSLines; i++)
                {
                    tnEBSLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                    tnSegregationByLineFromEBSToExit.Nodes.Add(tnEBSLine);
                }

                tnTime.Nodes.Add(tnFromEBSToExit);
                #endregion
                // << Task #15042 Pax2Sim - BHS Analysis - new EBS stats

                #region From LastChute to MakeUp
                TreeNode tnOrig_FromLastChuteToMakeUp = OverallTools.TreeViewFunctions.CreateDirectory("OrigChuteMakeUp", "From LastChute To MakeUp", cmsDirectorysMenu);

                directoryTagForColl = "OrigChuteMakeUpRec";

                TreeNode tnOrigRecirculationTimesChuteToMakeUp = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                tnOrig_FromLastChuteToMakeUp.Nodes.Add(tnOrigRecirculationTimesChuteToMakeUp);

                maxNbRecirc = 0;
                if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                {
                    tnRecirculations = new TreeNode();
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnOrigRecirculationTimesChuteToMakeUp.Nodes.Add(tnRecirculations);
                    }
                }

                tnTime.Nodes.Add(tnOrig_FromLastChuteToMakeUp);
                #endregion

                #region From LastChute to Exit
                TreeNode tnOrig_FromLastChuteToExit = OverallTools.TreeViewFunctions.CreateDirectory("OrigChuteExit", "From LastChute To Exit", cmsDirectorysMenu);

                directoryTagForColl = "OrigChuteExitRec";

                TreeNode tnOrigRecirculationTimesChuteToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                tnOrig_FromLastChuteToExit.Nodes.Add(tnOrigRecirculationTimesChuteToExit);

                maxNbRecirc = 0;
                if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                {
                    tnRecirculations = new TreeNode();
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnOrigRecirculationTimesChuteToExit.Nodes.Add(tnRecirculations);
                    }
                }

                directoryTagForColl = "OrigChuteExitSegr";

                TreeNode tnOrigChuteExitSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                tnOrig_FromLastChuteToExit.Nodes.Add(tnOrigChuteExitSegregationByLine);

                //nbOfChuteLines = 100;
                tnChuteLine = new TreeNode();

                for (int i = 1; i <= nbOfChuteLines; i++)
                {
                    tnChuteLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                    tnOrigChuteExitSegregationByLine.Nodes.Add(tnChuteLine);
                }

                tnTime.Nodes.Add(tnOrig_FromLastChuteToExit);
                #endregion
                // << Task #10026 Pax2Sim - Bag trace analysis - Originating&Transferring
                #endregion

                if (generateMUPSegregation) // >> Task #14280 Bag Trace Loading time too long
                {
                    foreach (string key in makeUpSGroupsDictionary.Keys)
                    {
                        string makeupGroupDescription = "";
                        if (makeUpGroupWithDescriptionDictionary.ContainsKey(key))
                            makeupGroupDescription = makeUpGroupWithDescriptionDictionary[key];

                        //TreeNode makeupGroup = OverallTools.TreeViewFunctions.CreateDirectory(key + "(" + makeupGroupDescription + ")", key + "(" + makeupGroupDescription + ")", cmsDirectorysMenu);
                        //tnOriginatingMU.Nodes.Add(makeupGroup);

                        #region _Times MUP Segregation
                        TreeNode tnMakeupGroupTime = OverallTools.TreeViewFunctions.CreateDirectory("Originating" + key, "_Times " + key + "(" + makeupGroupDescription + ")", cmsDirectorysMenu);
                        tnTime.Nodes.Add(tnMakeupGroupTime);

                        #region From Coll to Exit, CI to Exit and From Queue to Exit                        
                        tnFromCollector = OverallTools.TreeViewFunctions.CreateDirectory("OrigColl" + key, "From Collector To Exit", cmsDirectorysMenu);
                        tnFromCI = OverallTools.TreeViewFunctions.CreateDirectory("OrigCI" + key, "From CheckIn To Exit", cmsDirectorysMenu);
                        tnFromQueue = OverallTools.TreeViewFunctions.CreateDirectory("Orig" + key, "From Queue To Exit", cmsDirectorysMenu);
                        directoryTagForNormal = "Orig" + key + "Rec";
                        directoryTagForCI = "OrigCI" + key + "Rec";
                        directoryTagForColl = "OrigColl" + key + "Rec";
                        tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                        tnFromQueue.Nodes.Add(tnRecirculationTimes);
                        tnRecirculationTimesCI = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI, "Recirculation Times", cmsDirectorysMenu);
                        tnFromCI.Nodes.Add(tnRecirculationTimesCI);
                        tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                        tnFromCollector.Nodes.Add(tnRecirculationTimesColl);

                        maxNbRecirc = 0;
                        if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                        {
                            tnRecirculations = new TreeNode();
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                            }
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesCI.Nodes.Add(tnRecirculations);
                            }
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimes.Nodes.Add(tnRecirculations);
                            }
                        }

                        //makeupGroup.Nodes.Add(tnTime);
                        tnMakeupGroupTime.Nodes.Add(tnFromQueue);
                        tnMakeupGroupTime.Nodes.Add(tnFromCI);
                        tnMakeupGroupTime.Nodes.Add(tnFromCollector);
                        #endregion

                        #region From Queue/CI/Coll To DepReader
                        tnFromQueueToDepReaderTimeStamp = OverallTools.TreeViewFunctions.CreateDirectory("OrigReaderTimeStamp" + key, "From Queue To Dep-Reader-TimeStamp", cmsDirectorysMenu);
                        tnFromCIToDepReaderTimeStamp = OverallTools.TreeViewFunctions.CreateDirectory("OrigCIReaderTimeStamp" + key, "From CheckIn To Dep-Reader-TimeStamp", cmsDirectorysMenu);
                        tnFromCollectorToDepReaderTimeStamp = OverallTools.TreeViewFunctions.CreateDirectory("OrigCollReaderTimeStamp" + key, "From Collector To Dep-Reader-TimeStamp", cmsDirectorysMenu);

                        directoryTagForNormal = "OrigReaderTimeStamp" + key + "Rec";
                        directoryTagForCI = "OrigCIReaderTimeStamp" + key + "Rec";
                        directoryTagForColl = "OrigCollReaderTimeStamp" + key + "Rec";

                        tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                        tnFromQueueToDepReaderTimeStamp.Nodes.Add(tnRecirculationTimes);
                        tnRecirculationTimesCI = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI, "Recirculation Times", cmsDirectorysMenu);
                        tnFromCIToDepReaderTimeStamp.Nodes.Add(tnRecirculationTimesCI);
                        tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                        tnFromCollectorToDepReaderTimeStamp.Nodes.Add(tnRecirculationTimesColl);

                        maxNbRecirc = 0;
                        if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                        {
                            tnRecirculations = new TreeNode();
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                            }
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesCI.Nodes.Add(tnRecirculations);
                            }
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimes.Nodes.Add(tnRecirculations);
                            }
                        }
                        #endregion

                        #region From DepReader To LastChute/Exit
                        tnFromDepReaderTimeStampToLastChute = OverallTools.TreeViewFunctions.CreateDirectory("OrigReaderChute" + key, "From Dep-Reader-TimeStamp To Last Chute", cmsDirectorysMenu);
                        tnFromDepReaderTimeStampToExit = OverallTools.TreeViewFunctions.CreateDirectory("OrigReaderExit" + key, "From Dep-Reader-TimeStamp To Exit", cmsDirectorysMenu);

                        directoryTagForNormal = "OrigReaderChute" + key + "Rec";
                        directoryTagForColl = "OrigReaderExit" + key + "Rec";

                        tnRecirculationTimesToLastChute = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                        tnFromDepReaderTimeStampToLastChute.Nodes.Add(tnRecirculationTimesToLastChute);
                        tnRecirculationTimesToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                        tnFromDepReaderTimeStampToExit.Nodes.Add(tnRecirculationTimesToExit);

                        maxNbRecirc = 0;
                        if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                        {
                            tnRecirculations = new TreeNode();
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesToExit.Nodes.Add(tnRecirculations);
                            }
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesToLastChute.Nodes.Add(tnRecirculations);
                            }
                        }

                        directoryTagForNormal = "OrigReaderChute" + key + "Segr";
                        directoryTagForColl = "OrigReaderExit" + key + "Segr";

                        tnReaderChuteSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                        tnFromDepReaderTimeStampToLastChute.Nodes.Add(tnReaderChuteSegregationByLine);
                        tnReaderExitSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                        tnFromDepReaderTimeStampToExit.Nodes.Add(tnReaderExitSegregationByLine);

                        nbOfReaderLines = 6;
                        tnReaderLine = new TreeNode();
                        for (int i = 1; i <= nbOfReaderLines; i++)
                        {
                            tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                            tnReaderChuteSegregationByLine.Nodes.Add(tnReaderLine);
                        }
                        for (int i = 1; i <= nbOfReaderLines; i++)
                        {
                            tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                            tnReaderExitSegregationByLine.Nodes.Add(tnReaderLine);
                        }

                        directoryTagForNormal = "OrigReaderTimeStamp" + key + "Segr";
                        directoryTagForColl = "OrigCollReaderTimeStamp" + key + "Segr";

                        tnReaderSegregationByLineQueue = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                        tnFromQueueToDepReaderTimeStamp.Nodes.Add(tnReaderSegregationByLineQueue);
                        tnReaderSegregationByLineColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                        tnFromCollectorToDepReaderTimeStamp.Nodes.Add(tnReaderSegregationByLineColl);

                        nbOfReaderLines = 6;
                        tnReaderLine = new TreeNode();
                        for (int i = 1; i <= nbOfReaderLines; i++)
                        {
                            tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                            tnReaderSegregationByLineQueue.Nodes.Add(tnReaderLine);
                        }
                        for (int i = 1; i <= nbOfReaderLines; i++)
                        {
                            tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                            tnReaderSegregationByLineColl.Nodes.Add(tnReaderLine);
                        }
                        #endregion

                        tnMakeupGroupTime.Nodes.Add(tnFromQueueToDepReaderTimeStamp);
                        tnMakeupGroupTime.Nodes.Add(tnFromCIToDepReaderTimeStamp);
                        tnMakeupGroupTime.Nodes.Add(tnFromCollectorToDepReaderTimeStamp);
                        tnMakeupGroupTime.Nodes.Add(tnFromDepReaderTimeStampToLastChute);
                        tnMakeupGroupTime.Nodes.Add(tnFromDepReaderTimeStampToExit);

                        #region From Queue/Coll to EBS
                        // >> Task #15042 Pax2Sim - BHS Analysis - new EBS stats
                        tnFromQueueToEBS = OverallTools.TreeViewFunctions.CreateDirectory("OrigEBS" + key, "From Queue To EBS", cmsDirectorysMenu);
                        tnFromCollectorToEBS = OverallTools.TreeViewFunctions.CreateDirectory("OrigCollEBS" + key, "From Collector To EBS", cmsDirectorysMenu);

                        directoryTagForNormal = "OrigEBS" + key + "Rec";
                        directoryTagForColl = "OrigCollEBS" + key + "Rec";
                        tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                        tnFromQueueToEBS.Nodes.Add(tnRecirculationTimes);
                        tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                        tnFromCollectorToEBS.Nodes.Add(tnRecirculationTimesColl);

                        maxNbRecirc = 0;
                        if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                        {
                            tnRecirculations = new TreeNode();
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                            }
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimes.Nodes.Add(tnRecirculations);
                            }
                        }

                        tnMakeupGroupTime.Nodes.Add(tnFromQueueToEBS);
                        tnMakeupGroupTime.Nodes.Add(tnFromCollectorToEBS);
                        // << Task #15042 Pax2Sim - BHS Analysis - new EBS stats
                        #endregion

                        #region From Queue/CI/Coll to Chute
                        tnFromQueueToChute = OverallTools.TreeViewFunctions.CreateDirectory("OrigChute" + key, "From Queue To Last Chute", cmsDirectorysMenu);
                        tnFromCIToChute = OverallTools.TreeViewFunctions.CreateDirectory("OrigCIChute" + key, "From CheckIn To Last Chute", cmsDirectorysMenu);
                        tnFromCollectorToChute = OverallTools.TreeViewFunctions.CreateDirectory("OrigCollChute" + key, "From Collector To Last Chute", cmsDirectorysMenu);

                        directoryTagForNormal = "OrigChute" + key + "Rec";
                        directoryTagForColl = "OrigCollChute" + key + "Rec";
                        directoryTagForCI = "OrigCIChute" + key + "Rec";
                        tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                        tnFromQueueToChute.Nodes.Add(tnRecirculationTimes);
                        tnRecirculationTimesCI = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI, "Recirculation Times", cmsDirectorysMenu);
                        tnFromCIToChute.Nodes.Add(tnRecirculationTimesCI);
                        tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                        tnFromCollectorToChute.Nodes.Add(tnRecirculationTimesColl);

                        maxNbRecirc = 0;
                        if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                        {
                            tnRecirculations = new TreeNode();
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                            }
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesCI.Nodes.Add(tnRecirculations);
                            }
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimes.Nodes.Add(tnRecirculations);
                            }
                        }

                        tnMakeupGroupTime.Nodes.Add(tnFromQueueToChute);
                        tnMakeupGroupTime.Nodes.Add(tnFromCIToChute);
                        tnMakeupGroupTime.Nodes.Add(tnFromCollectorToChute);
                        #endregion

                        #region From Queue/CI/Coll to Presortation
                        tnFromQueueToPresortation = OverallTools.TreeViewFunctions.CreateDirectory("OrigPresortation" + key, "From Queue To Presortation", cmsDirectorysMenu);
                        tnFromCIToPresortation = OverallTools.TreeViewFunctions.CreateDirectory("OrigCIPresortation" + key, "From CheckIn To Presortation", cmsDirectorysMenu);
                        tnFromCollectorToPresortation = OverallTools.TreeViewFunctions.CreateDirectory("OrigCollPresortation" + key, "From Collector To Presortation", cmsDirectorysMenu);

                        directoryTagForNormal = "OrigPresortation" + key + "Segr";
                        directoryTagForCI = "OrigCIPresortation" + key + "Segr";
                        directoryTagForColl = "OrigCollPresortation" + key + "Segr";

                        tnSegregationByLineQueue = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                        tnFromQueueToPresortation.Nodes.Add(tnSegregationByLineQueue);
                        tnSegregationByLineCI = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI, "Segregation By Line", cmsDirectorysMenu);
                        tnFromCIToPresortation.Nodes.Add(tnSegregationByLineCI);
                        tnSegregationByLineColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                        tnFromCollectorToPresortation.Nodes.Add(tnSegregationByLineColl);

                        nbOfLines = 4;
                        tnLine = new TreeNode();
                        for (int i = 1; i <= nbOfLines; i++)
                        {
                            tnLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                            tnSegregationByLineQueue.Nodes.Add(tnLine);
                        }
                        for (int i = 1; i <= nbOfLines; i++)
                        {
                            tnLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI + i, "Line_" + i, cmsDirectorysMenu);
                            tnSegregationByLineCI.Nodes.Add(tnLine);
                        }
                        for (int i = 1; i <= nbOfLines; i++)
                        {
                            tnLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                            tnSegregationByLineColl.Nodes.Add(tnLine);
                        }

                        tnMakeupGroupTime.Nodes.Add(tnFromQueueToPresortation);
                        tnMakeupGroupTime.Nodes.Add(tnFromCIToPresortation);
                        tnMakeupGroupTime.Nodes.Add(tnFromCollectorToPresortation);
                        #endregion

                        // >> Task #15042 Pax2Sim - BHS Analysis - new EBS stats
                        #region From EBS to Last Chute
                        TreeNode tnOrigMupSegr_FromEBSToLastChute = OverallTools.TreeViewFunctions.CreateDirectory("OrigEBSChute" + key, "From EBS To LastChute", cmsDirectorysMenu);

                        directoryTagForColl = "OrigEBSChute" + key + "Rec";

                        TreeNode tnOrigMupSegr_RecirculationTimesEBSChute = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                        tnOrigMupSegr_FromEBSToLastChute.Nodes.Add(tnOrigMupSegr_RecirculationTimesEBSChute);

                        maxNbRecirc = 0;
                        if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                        {
                            tnRecirculations = new TreeNode();
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnOrigMupSegr_RecirculationTimesEBSChute.Nodes.Add(tnRecirculations);
                            }
                        }

                        tnMakeupGroupTime.Nodes.Add(tnOrigMupSegr_FromEBSToLastChute);
                        #endregion

                        #region From EBS to exit
                        tnFromEBSToExit = OverallTools.TreeViewFunctions.CreateDirectory("OrigEBSExit" + key, "From EBS To Exit", cmsDirectorysMenu);

                        directoryTagForColl = "OrigEBSExit" + key + "Rec";

                        tnRecircFromEBSToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                        tnFromEBSToExit.Nodes.Add(tnRecircFromEBSToExit);

                        maxNbRecirc = 0;
                        if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                        {
                            tnRecirculations = new TreeNode();
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecircFromEBSToExit.Nodes.Add(tnRecirculations);
                            }
                        }
                        directoryTagForColl = "OrigEBSExit" + key + "Segr";
                        tnSegregationByLineFromEBSToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                        tnFromEBSToExit.Nodes.Add(tnSegregationByLineFromEBSToExit);

                        //nbOfChuteLines = 30;
                        tnEBSLine = new TreeNode();
                        for (int i = 1; i <= nbOfEBSLines; i++)
                        {
                            tnEBSLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                            tnSegregationByLineFromEBSToExit.Nodes.Add(tnEBSLine);
                        }
                        tnMakeupGroupTime.Nodes.Add(tnFromEBSToExit);
                        #endregion
                        // << Task #15042 Pax2Sim - BHS Analysis - new EBS stats

                        #region Chute To MakeUp directory
                        tnFromLastChuteToMakeUp = OverallTools.TreeViewFunctions.CreateDirectory("OrigChuteMakeUp" + key, "From LastChute To MakeUp", cmsDirectorysMenu);

                        directoryTagForColl = "OrigChuteMakeUp" + key + "Rec";

                        tnRecirculationTimesChuteToMakeUp = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                        tnFromLastChuteToMakeUp.Nodes.Add(tnRecirculationTimesChuteToMakeUp);

                        maxNbRecirc = 0;
                        if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                        {
                            tnRecirculations = new TreeNode();
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesChuteToMakeUp.Nodes.Add(tnRecirculations);
                            }
                        }

                        tnMakeupGroupTime.Nodes.Add(tnFromLastChuteToMakeUp);
                        #endregion

                        #region Chute To Exit directory
                        tnFromLastChuteToExit = OverallTools.TreeViewFunctions.CreateDirectory("OrigChuteExit" + key, "From LastChute To Exit", cmsDirectorysMenu);

                        directoryTagForColl = "OrigChuteExit" + key + "Rec";

                        tnRecirculationTimesChuteToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                        tnFromLastChuteToExit.Nodes.Add(tnRecirculationTimesChuteToExit);

                        maxNbRecirc = 0;
                        if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                        {
                            tnRecirculations = new TreeNode();
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesChuteToExit.Nodes.Add(tnRecirculations);
                            }
                        }
                        directoryTagForColl = "OrigChuteExit" + key + "Segr";
                        tnChuteExitSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                        tnFromLastChuteToExit.Nodes.Add(tnChuteExitSegregationByLine);

                        //nbOfChuteLines = 30;
                        tnChuteLine = new TreeNode();
                        for (int i = 1; i <= nbOfChuteLines; i++)
                        {
                            tnChuteLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                            tnChuteExitSegregationByLine.Nodes.Add(tnChuteLine);
                        }
                        tnMakeupGroupTime.Nodes.Add(tnFromLastChuteToExit);
                        #endregion

                        #endregion
                    }
                    // >> Task #13659 IST MakeUp segregation
                    #region commented
                    /*
                    #region _Times MUPS3

                    #region From Coll to Exit and From Queue to Exit
                    tnTime = OverallTools.TreeViewFunctions.CreateDirectory("Originating", "_Times_Exit_MU Group 1 (S3)", cmsDirectorysMenu);
                    // << Task #8223 Pax2Sim - BHS mode - baggs IST statistic change                
                    tnFromCollector = OverallTools.TreeViewFunctions.CreateDirectory("OrigColl" + MUP_GROUP_S3, "From Collector To Exit", cmsDirectorysMenu);
                    tnFromQueue = OverallTools.TreeViewFunctions.CreateDirectory("Orig" + MUP_GROUP_S3, "From Queue To Exit", cmsDirectorysMenu);
                    // >> Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                    // << Task #7530 Analyze Bag Trace module - Recirculation statistics
                    directoryTagForNormal = "Orig" + MUP_GROUP_S3 + "Rec";
                    directoryTagForColl = "OrigColl" + MUP_GROUP_S3 + "Rec";
                    tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                    tnFromQueue.Nodes.Add(tnRecirculationTimes);
                    tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromCollector.Nodes.Add(tnRecirculationTimesColl);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                        }
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimes.Nodes.Add(tnRecirculations);
                        }
                    }
                    // >> Task #7530 Analyze Bag Trace module - Recirculation statistics

                    tnOriginating.Nodes.Add(tnTime);
                    tnTime.Nodes.Add(tnFromQueue);
                    tnTime.Nodes.Add(tnFromCollector);
                    #endregion

                    #region From Queue/Coll To DepReader
                    // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                    tnFromQueueToDepReaderTimeStamp = OverallTools.TreeViewFunctions.CreateDirectory("OrigReaderTimeStamp" + MUP_GROUP_S3, "From Queue To Dep-Reader-TimeStamp", cmsDirectorysMenu);
                    tnFromCollectorToDepReaderTimeStamp = OverallTools.TreeViewFunctions.CreateDirectory("OrigCollReaderTimeStamp" + MUP_GROUP_S3, "From Collector To Dep-Reader-TimeStamp", cmsDirectorysMenu);

                    directoryTagForNormal = "OrigReaderTimeStamp" + MUP_GROUP_S3 + "Rec";
                    directoryTagForColl = "OrigCollReaderTimeStamp" + MUP_GROUP_S3 + "Rec";

                    tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                    tnFromQueueToDepReaderTimeStamp.Nodes.Add(tnRecirculationTimes);
                    tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromCollectorToDepReaderTimeStamp.Nodes.Add(tnRecirculationTimesColl);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                        }
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimes.Nodes.Add(tnRecirculations);
                        }
                    }
                    #endregion

                    #region From DepReader To LastChute/Exit
                    tnFromDepReaderTimeStampToLastChute = OverallTools.TreeViewFunctions.CreateDirectory("OrigReaderChute" + MUP_GROUP_S3, "From Dep-Reader-TimeStamp To Last Chute", cmsDirectorysMenu);
                    tnFromDepReaderTimeStampToExit = OverallTools.TreeViewFunctions.CreateDirectory("OrigReaderExit" + MUP_GROUP_S3, "From Dep-Reader-TimeStamp To Exit", cmsDirectorysMenu);

                    directoryTagForNormal = "OrigReaderChute" + MUP_GROUP_S3 + "Rec";
                    directoryTagForColl = "OrigReaderExit" + MUP_GROUP_S3 + "Rec";

                    tnRecirculationTimesToLastChute = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                    tnFromDepReaderTimeStampToLastChute.Nodes.Add(tnRecirculationTimesToLastChute);
                    tnRecirculationTimesToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromDepReaderTimeStampToExit.Nodes.Add(tnRecirculationTimesToExit);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesToExit.Nodes.Add(tnRecirculations);
                        }
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesToLastChute.Nodes.Add(tnRecirculations);
                        }
                    }

                    directoryTagForNormal = "OrigReaderChute" + MUP_GROUP_S3 + "Segr";
                    directoryTagForColl = "OrigReaderExit" + MUP_GROUP_S3 + "Segr";

                    tnReaderChuteSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                    tnFromDepReaderTimeStampToLastChute.Nodes.Add(tnReaderChuteSegregationByLine);
                    tnReaderExitSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                    tnFromDepReaderTimeStampToExit.Nodes.Add(tnReaderExitSegregationByLine);

                    nbOfReaderLines = 6;
                    tnReaderLine = new TreeNode();
                    for (int i = 1; i <= nbOfReaderLines; i++)
                    {
                        tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                        tnReaderChuteSegregationByLine.Nodes.Add(tnReaderLine);
                    }
                    for (int i = 1; i <= nbOfReaderLines; i++)
                    {
                        tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                        tnReaderExitSegregationByLine.Nodes.Add(tnReaderLine);
                    }

                    directoryTagForNormal = "OrigReaderTimeStamp" + MUP_GROUP_S3 + "Segr";
                    directoryTagForColl = "OrigCollReaderTimeStamp" + MUP_GROUP_S3 + "Segr";

                    tnReaderSegregationByLineQueue = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                    tnFromQueueToDepReaderTimeStamp.Nodes.Add(tnReaderSegregationByLineQueue);
                    tnReaderSegregationByLineColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                    tnFromCollectorToDepReaderTimeStamp.Nodes.Add(tnReaderSegregationByLineColl);

                    nbOfReaderLines = 6;
                    tnReaderLine = new TreeNode();
                    for (int i = 1; i <= nbOfReaderLines; i++)
                    {
                        tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                        tnReaderSegregationByLineQueue.Nodes.Add(tnReaderLine);
                    }
                    for (int i = 1; i <= nbOfReaderLines; i++)
                    {
                        tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                        tnReaderSegregationByLineColl.Nodes.Add(tnReaderLine);
                    }
                    #endregion

                    tnTime.Nodes.Add(tnFromQueueToDepReaderTimeStamp);
                    tnTime.Nodes.Add(tnFromCollectorToDepReaderTimeStamp);
                    tnTime.Nodes.Add(tnFromDepReaderTimeStampToLastChute);
                    tnTime.Nodes.Add(tnFromDepReaderTimeStampToExit);
                    // >> Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader

                    #region From Queue/Coll to Chute
                    // << Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                    tnFromQueueToChute = OverallTools.TreeViewFunctions.CreateDirectory("OrigChute" + MUP_GROUP_S3, "From Queue To Last Chute", cmsDirectorysMenu);
                    tnFromCollectorToChute = OverallTools.TreeViewFunctions.CreateDirectory("OrigCollChute" + MUP_GROUP_S3, "From Collector To Last Chute", cmsDirectorysMenu);

                    directoryTagForNormal = "OrigChute" + MUP_GROUP_S3 + "Rec";
                    directoryTagForColl = "OrigCollChute" + MUP_GROUP_S3 + "Rec";
                    tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                    tnFromQueueToChute.Nodes.Add(tnRecirculationTimes);
                    tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromCollectorToChute.Nodes.Add(tnRecirculationTimesColl);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                        }
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimes.Nodes.Add(tnRecirculations);
                        }
                    }

                    tnTime.Nodes.Add(tnFromQueueToChute);
                    tnTime.Nodes.Add(tnFromCollectorToChute);
                    // >> Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                    #endregion

                    #region From Queue/Coll to Presortation
                    // << Task #8283 Pax2Sim - BHS mode - statistics for transportaition time per period of time
                    tnFromQueueToPresortation = OverallTools.TreeViewFunctions.CreateDirectory("OrigPresortation" + MUP_GROUP_S3, "From Queue To Presortation", cmsDirectorysMenu);
                    tnFromCollectorToPresortation = OverallTools.TreeViewFunctions.CreateDirectory("OrigCollPresortation" + MUP_GROUP_S3, "From Collector To Presortation", cmsDirectorysMenu);

                    directoryTagForNormal = "OrigPresortation" + MUP_GROUP_S3 + "Segr";
                    directoryTagForColl = "OrigCollPresortation" + MUP_GROUP_S3 + "Segr";

                    tnSegregationByLineQueue = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                    tnFromQueueToPresortation.Nodes.Add(tnSegregationByLineQueue);
                    tnSegregationByLineColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                    tnFromCollectorToPresortation.Nodes.Add(tnSegregationByLineColl);

                    nbOfLines = 4;
                    tnLine = new TreeNode();
                    for (int i = 1; i <= nbOfLines; i++)
                    {
                        tnLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                        tnSegregationByLineQueue.Nodes.Add(tnLine);
                    }
                    for (int i = 1; i <= nbOfLines; i++)
                    {
                        tnLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                        tnSegregationByLineColl.Nodes.Add(tnLine);
                    }

                    tnTime.Nodes.Add(tnFromQueueToPresortation);
                    tnTime.Nodes.Add(tnFromCollectorToPresortation);
                    // >> Task #8283 Pax2Sim - BHS mode - statistics for transportaition time per period of time
                    #endregion

                    // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                    #region Chute To MakeUp directory
                    tnFromLastChuteToMakeUp = OverallTools.TreeViewFunctions.CreateDirectory("OrigChuteMakeUp" + MUP_GROUP_S3, "From LastChute To MakeUp", cmsDirectorysMenu);

                    directoryTagForColl = "OrigChuteMakeUp" + MUP_GROUP_S3 + "Rec";

                    tnRecirculationTimesChuteToMakeUp = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromLastChuteToMakeUp.Nodes.Add(tnRecirculationTimesChuteToMakeUp);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesChuteToMakeUp.Nodes.Add(tnRecirculations);
                        }
                    }

                    tnTime.Nodes.Add(tnFromLastChuteToMakeUp);
                    #endregion
                    // >> Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader

                    // << Task #9611 Pax2Sim - BHS - Analyse BHS Results Assistant - Analysis Range option
                    #region Chute To Exit directory
                    tnFromLastChuteToExit = OverallTools.TreeViewFunctions.CreateDirectory("OrigChuteExit" + MUP_GROUP_S3, "From LastChute To Exit", cmsDirectorysMenu);

                    directoryTagForColl = "OrigChuteExit" + MUP_GROUP_S3 + "Rec";

                    tnRecirculationTimesChuteToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromLastChuteToExit.Nodes.Add(tnRecirculationTimesChuteToExit);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesChuteToExit.Nodes.Add(tnRecirculations);
                        }
                    }

                    directoryTagForColl = "OrigChuteExit" + MUP_GROUP_S3 + "Segr";

                    tnChuteExitSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                    tnFromLastChuteToExit.Nodes.Add(tnChuteExitSegregationByLine);

                    nbOfChuteLines = 17;
                    tnChuteLine = new TreeNode();

                    for (int i = 1; i <= nbOfChuteLines; i++)
                    {
                        tnChuteLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                        tnChuteExitSegregationByLine.Nodes.Add(tnChuteLine);
                    }

                    tnTime.Nodes.Add(tnFromLastChuteToExit);

                    // >> Task #9611 Pax2Sim - BHS - Analyse BHS Results Assistant - Analysis Range option
                    #endregion

                    #endregion

                    #region _Times MUPS4

                    #region From Coll to Exit and From Queue to Exit
                    tnTime = OverallTools.TreeViewFunctions.CreateDirectory("Originating", "_Times_Exit_MU Group 2 (S4)", cmsDirectorysMenu);
                    // << Task #8223 Pax2Sim - BHS mode - baggs IST statistic change                
                    tnFromCollector = OverallTools.TreeViewFunctions.CreateDirectory("OrigColl" + MUP_GROUP_S4, "From Collector To Exit", cmsDirectorysMenu);
                    tnFromQueue = OverallTools.TreeViewFunctions.CreateDirectory("Orig" + MUP_GROUP_S4, "From Queue To Exit", cmsDirectorysMenu);
                    // >> Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                    // << Task #7530 Analyze Bag Trace module - Recirculation statistics
                    directoryTagForNormal = "Orig" + MUP_GROUP_S4 + "Rec";
                    directoryTagForColl = "OrigColl" + MUP_GROUP_S4 + "Rec";
                    tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                    tnFromQueue.Nodes.Add(tnRecirculationTimes);
                    tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromCollector.Nodes.Add(tnRecirculationTimesColl);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                        }
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimes.Nodes.Add(tnRecirculations);
                        }
                    }
                    // >> Task #7530 Analyze Bag Trace module - Recirculation statistics

                    tnOriginating.Nodes.Add(tnTime);
                    tnTime.Nodes.Add(tnFromQueue);
                    tnTime.Nodes.Add(tnFromCollector);
                    #endregion

                    #region From Queue/Coll To DepReader
                    // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                    tnFromQueueToDepReaderTimeStamp = OverallTools.TreeViewFunctions.CreateDirectory("OrigReaderTimeStamp" + MUP_GROUP_S4, "From Queue To Dep-Reader-TimeStamp", cmsDirectorysMenu);
                    tnFromCollectorToDepReaderTimeStamp = OverallTools.TreeViewFunctions.CreateDirectory("OrigCollReaderTimeStamp" + MUP_GROUP_S4, "From Collector To Dep-Reader-TimeStamp", cmsDirectorysMenu);

                    directoryTagForNormal = "OrigReaderTimeStamp" + MUP_GROUP_S4 + "Rec";
                    directoryTagForColl = "OrigCollReaderTimeStamp" + MUP_GROUP_S4 + "Rec";

                    tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                    tnFromQueueToDepReaderTimeStamp.Nodes.Add(tnRecirculationTimes);
                    tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromCollectorToDepReaderTimeStamp.Nodes.Add(tnRecirculationTimesColl);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                        }
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimes.Nodes.Add(tnRecirculations);
                        }
                    }
                    #endregion

                    #region From DepReader To LastChute/Exit
                    tnFromDepReaderTimeStampToLastChute = OverallTools.TreeViewFunctions.CreateDirectory("OrigReaderChute" + MUP_GROUP_S4, "From Dep-Reader-TimeStamp To Last Chute", cmsDirectorysMenu);
                    tnFromDepReaderTimeStampToExit = OverallTools.TreeViewFunctions.CreateDirectory("OrigReaderExit" + MUP_GROUP_S4, "From Dep-Reader-TimeStamp To Exit", cmsDirectorysMenu);

                    directoryTagForNormal = "OrigReaderChute" + MUP_GROUP_S4 + "Rec";
                    directoryTagForColl = "OrigReaderExit" + MUP_GROUP_S4 + "Rec";

                    tnRecirculationTimesToLastChute = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                    tnFromDepReaderTimeStampToLastChute.Nodes.Add(tnRecirculationTimesToLastChute);
                    tnRecirculationTimesToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromDepReaderTimeStampToExit.Nodes.Add(tnRecirculationTimesToExit);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesToExit.Nodes.Add(tnRecirculations);
                        }
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesToLastChute.Nodes.Add(tnRecirculations);
                        }
                    }

                    directoryTagForNormal = "OrigReaderChute" + MUP_GROUP_S4 + "Segr";
                    directoryTagForColl = "OrigReaderExit" + MUP_GROUP_S4 + "Segr";

                    tnReaderChuteSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                    tnFromDepReaderTimeStampToLastChute.Nodes.Add(tnReaderChuteSegregationByLine);
                    tnReaderExitSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                    tnFromDepReaderTimeStampToExit.Nodes.Add(tnReaderExitSegregationByLine);

                    nbOfReaderLines = 6;
                    tnReaderLine = new TreeNode();
                    for (int i = 1; i <= nbOfReaderLines; i++)
                    {
                        tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                        tnReaderChuteSegregationByLine.Nodes.Add(tnReaderLine);
                    }
                    for (int i = 1; i <= nbOfReaderLines; i++)
                    {
                        tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                        tnReaderExitSegregationByLine.Nodes.Add(tnReaderLine);
                    }

                    directoryTagForNormal = "OrigReaderTimeStamp" + MUP_GROUP_S4 + "Segr";
                    directoryTagForColl = "OrigCollReaderTimeStamp" + MUP_GROUP_S4 + "Segr";

                    tnReaderSegregationByLineQueue = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                    tnFromQueueToDepReaderTimeStamp.Nodes.Add(tnReaderSegregationByLineQueue);
                    tnReaderSegregationByLineColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                    tnFromCollectorToDepReaderTimeStamp.Nodes.Add(tnReaderSegregationByLineColl);

                    nbOfReaderLines = 6;
                    tnReaderLine = new TreeNode();
                    for (int i = 1; i <= nbOfReaderLines; i++)
                    {
                        tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                        tnReaderSegregationByLineQueue.Nodes.Add(tnReaderLine);
                    }
                    for (int i = 1; i <= nbOfReaderLines; i++)
                    {
                        tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                        tnReaderSegregationByLineColl.Nodes.Add(tnReaderLine);
                    }
                    #endregion

                    tnTime.Nodes.Add(tnFromQueueToDepReaderTimeStamp);
                    tnTime.Nodes.Add(tnFromCollectorToDepReaderTimeStamp);
                    tnTime.Nodes.Add(tnFromDepReaderTimeStampToLastChute);
                    tnTime.Nodes.Add(tnFromDepReaderTimeStampToExit);
                    // >> Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader

                    #region From Queue/Coll to Chute
                    // << Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                    tnFromQueueToChute = OverallTools.TreeViewFunctions.CreateDirectory("OrigChute" + MUP_GROUP_S4, "From Queue To Last Chute", cmsDirectorysMenu);
                    tnFromCollectorToChute = OverallTools.TreeViewFunctions.CreateDirectory("OrigCollChute" + MUP_GROUP_S4, "From Collector To Last Chute", cmsDirectorysMenu);

                    directoryTagForNormal = "OrigChute" + MUP_GROUP_S4 + "Rec";
                    directoryTagForColl = "OrigCollChute" + MUP_GROUP_S4 + "Rec";
                    tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                    tnFromQueueToChute.Nodes.Add(tnRecirculationTimes);
                    tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromCollectorToChute.Nodes.Add(tnRecirculationTimesColl);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                        }
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimes.Nodes.Add(tnRecirculations);
                        }
                    }

                    tnTime.Nodes.Add(tnFromQueueToChute);
                    tnTime.Nodes.Add(tnFromCollectorToChute);
                    // >> Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                    #endregion

                    #region From Queue/Coll to Presortation
                    // << Task #8283 Pax2Sim - BHS mode - statistics for transportaition time per period of time
                    tnFromQueueToPresortation = OverallTools.TreeViewFunctions.CreateDirectory("OrigPresortation" + MUP_GROUP_S4, "From Queue To Presortation", cmsDirectorysMenu);
                    tnFromCollectorToPresortation = OverallTools.TreeViewFunctions.CreateDirectory("OrigCollPresortation" + MUP_GROUP_S4, "From Collector To Presortation", cmsDirectorysMenu);

                    directoryTagForNormal = "OrigPresortation" + MUP_GROUP_S4 + "Segr";
                    directoryTagForColl = "OrigCollPresortation" + MUP_GROUP_S4 + "Segr";

                    tnSegregationByLineQueue = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                    tnFromQueueToPresortation.Nodes.Add(tnSegregationByLineQueue);
                    tnSegregationByLineColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                    tnFromCollectorToPresortation.Nodes.Add(tnSegregationByLineColl);

                    nbOfLines = 4;
                    tnLine = new TreeNode();
                    for (int i = 1; i <= nbOfLines; i++)
                    {
                        tnLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                        tnSegregationByLineQueue.Nodes.Add(tnLine);
                    }
                    for (int i = 1; i <= nbOfLines; i++)
                    {
                        tnLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                        tnSegregationByLineColl.Nodes.Add(tnLine);
                    }

                    tnTime.Nodes.Add(tnFromQueueToPresortation);
                    tnTime.Nodes.Add(tnFromCollectorToPresortation);
                    // >> Task #8283 Pax2Sim - BHS mode - statistics for transportaition time per period of time
                    #endregion

                    // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                    #region Chute To MakeUp directory
                    tnFromLastChuteToMakeUp = OverallTools.TreeViewFunctions.CreateDirectory("OrigChuteMakeUp" + MUP_GROUP_S4, "From LastChute To MakeUp", cmsDirectorysMenu);

                    directoryTagForColl = "OrigChuteMakeUp" + MUP_GROUP_S4 + "Rec";

                    tnRecirculationTimesChuteToMakeUp = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromLastChuteToMakeUp.Nodes.Add(tnRecirculationTimesChuteToMakeUp);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesChuteToMakeUp.Nodes.Add(tnRecirculations);
                        }
                    }

                    tnTime.Nodes.Add(tnFromLastChuteToMakeUp);
                    #endregion
                    // >> Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader

                    // << Task #9611 Pax2Sim - BHS - Analyse BHS Results Assistant - Analysis Range option
                    #region Chute To Exit directory
                    tnFromLastChuteToExit = OverallTools.TreeViewFunctions.CreateDirectory("OrigChuteExit" + MUP_GROUP_S4, "From LastChute To Exit", cmsDirectorysMenu);

                    directoryTagForColl = "OrigChuteExit" + MUP_GROUP_S4 + "Rec";

                    tnRecirculationTimesChuteToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromLastChuteToExit.Nodes.Add(tnRecirculationTimesChuteToExit);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesChuteToExit.Nodes.Add(tnRecirculations);
                        }
                    }

                    directoryTagForColl = "OrigChuteExit" + MUP_GROUP_S4 + "Segr";

                    tnChuteExitSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                    tnFromLastChuteToExit.Nodes.Add(tnChuteExitSegregationByLine);

                    nbOfChuteLines = 17;
                    tnChuteLine = new TreeNode();

                    for (int i = 1; i <= nbOfChuteLines; i++)
                    {
                        tnChuteLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                        tnChuteExitSegregationByLine.Nodes.Add(tnChuteLine);
                    }

                    tnTime.Nodes.Add(tnFromLastChuteToExit);

                    // >> Task #9611 Pax2Sim - BHS - Analyse BHS Results Assistant - Analysis Range option
                    #endregion

                    #endregion
                    */
                    #endregion
                    // << Task #13659 IST MakeUp segregation
                }

                tnOriginating.Nodes.Add(tnOriginatingCheckInQueues);
                tnOriginating.Nodes.Add(tnOriginatingCheckIn);
                tnOriginating.Nodes.Add(tnOriginatingCheckInCollector);
                //if (generateMUPSegregation)
                //tnOriginating.Nodes.Add(tnOriginatingMU);
                UpdateDirectories(tnOriginating, lsNames, sPersonalOrigQueue, "Originating Queue", cmsDirectorysMenu);
                UpdateDirectories(tnOriginating, lsNames, sPersonalOrigConv, "Originating Conveyor", cmsDirectorysMenu);
                UpdateDirectories(tnOriginating, lsNames, sPersonalOrigVeh, "Originating Vehicle", cmsDirectorysMenu);
                UpdateDirectories(tnOriginating, lsNames, sPersonalOrigWorkCenter, "Originating WorkCenter", cmsDirectorysMenu);
                UpdateDirectories(tnOriginating, lsNames, sPersonalOrigTimeStamp, "Originating TimeStamp", cmsDirectorysMenu);
                //<< New Objects - Task#7228
                UpdateDirectories(tnOriginating, lsNames, sOrigStorage, "Originating Storage", cmsDirectorysMenu);
                UpdateDirectories(tnOriginating, lsNames, sOrigStorage1, "Originating Storage 1", cmsDirectorysMenu);
                UpdateDirectories(tnOriginating, lsNames, sOrigStorage2, "Originating Storage 2", cmsDirectorysMenu);
                UpdateDirectories(tnOriginating, lsNames, sOrigULDMUInUsed, "Originating ULD MU InUsed", cmsDirectorysMenu);
                UpdateDirectories(tnOriginating, lsNames, sOrigULDFullStorage, "Originating ULD Full Storage", cmsDirectorysMenu);
                UpdateDirectories(tnOriginating, lsNames, sOrigULDEmptyStorage, "Originating ULD Empty Storage", cmsDirectorysMenu);

                UpdateDirectories(tnOriginating, lsNames, sOrigSlugs, "Originating Slugs", cmsDirectorysMenu);
                UpdateDirectories(tnOriginating, lsNames, sOrigWindow, "Originating Window", cmsDirectorysMenu);
                UpdateDirectories(tnOriginating, lsNames, sOrigFlow, "Originating Flow", cmsDirectorysMenu);
                //>> New Objects - Task#7228
                //<< New Objects(II) - Task#7367
                UpdateDirectories(tnOriginating, lsNames, sOrigVSUInputDn, "Originating VSU Input Dn", cmsDirectorysMenu);
                UpdateDirectories(tnOriginating, lsNames, sOrigVSUInputUp, "Originating VSU Input Up", cmsDirectorysMenu);
                UpdateDirectories(tnOriginating, lsNames, sOrigVSUOutputDn, "Originating VSU Output Dn", cmsDirectorysMenu);
                UpdateDirectories(tnOriginating, lsNames, sOrigVSUOutputUp, "Originating VSU Output Up", cmsDirectorysMenu);
                //>> New Objects(II) - Task#7367
                #endregion

                #region Les noeuds affichés dans le noeud Departing
                TreeNode tnDepartingHBS = OverallTools.TreeViewFunctions.CreateDirectory("HBS", cmsDirectorysMenu);
                TreeNode tnDepartingSorter = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferSorterName, cmsDirectorysMenu);
                TreeNode tnDepartingMES = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferMES, cmsDirectorysMenu);
                TreeNode tnDepartingEBS = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferEBS, cmsDirectorysMenu);
                TreeNode tnDepartingBuffer = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferBuffer, "Buffer", cmsDirectorysMenu);
                TreeNode tnDepartingMU = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferMU, "Make-Up", cmsDirectorysMenu);
                //TreeNode tnDepartingMakeUp = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferMakeUp, "MakeUp", cmsDirectorysMenu);    // ADPi Chute

                #region _Times
                tnTime = OverallTools.TreeViewFunctions.CreateDirectory("Departing", "_Times", cmsDirectorysMenu);

                #region From Queue/Ci/Coll to Exit
                // << Task #8223 Pax2Sim - BHS mode - baggs IST statistic change                
                tnFromCollector = OverallTools.TreeViewFunctions.CreateDirectory("DepColl", "From Collector To Exit", cmsDirectorysMenu);
                tnFromCI = OverallTools.TreeViewFunctions.CreateDirectory("DepCI", "From CheckIn To Exit", cmsDirectorysMenu);
                tnFromQueue = OverallTools.TreeViewFunctions.CreateDirectory("Dep", "From Queue To Exit", cmsDirectorysMenu);
                // >> Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                // << Task #7530 Analyze Bag Trace module - Recirculation statistics
                directoryTagForNormal = "DepRec";
                directoryTagForCI = "DepCIRec";
                directoryTagForColl = "DepCollRec";
                tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                tnFromQueue.Nodes.Add(tnRecirculationTimes);
                tnRecirculationTimesCI = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI, "Recirculation Times", cmsDirectorysMenu);
                tnFromCI.Nodes.Add(tnRecirculationTimesCI);
                tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                tnFromCollector.Nodes.Add(tnRecirculationTimesColl);

                maxNbRecirc = 0;
                if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                {
                    tnRecirculations = new TreeNode();
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                    }
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimesCI.Nodes.Add(tnRecirculations);
                    }
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimes.Nodes.Add(tnRecirculations);
                    }
                }
                // >> Task #7530 Analyze Bag Trace module - Recirculation statistics

                tnDeparting.Nodes.Add(tnTime);
                tnTime.Nodes.Add(tnFromQueue);
                tnTime.Nodes.Add(tnFromCI);
                tnTime.Nodes.Add(tnFromCollector);
                #endregion

                // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                tnFromQueueToDepReaderTimeStamp = OverallTools.TreeViewFunctions.CreateDirectory("DepReaderTimeStamp", "From Queue To Dep-Reader-TimeStamp", cmsDirectorysMenu);
                tnFromCIToDepReaderTimeStamp = OverallTools.TreeViewFunctions.CreateDirectory("DepCIReaderTimeStamp", "From CheckIn To Dep-Reader-TimeStamp", cmsDirectorysMenu);
                tnFromCollectorToDepReaderTimeStamp = OverallTools.TreeViewFunctions.CreateDirectory("DepCollReaderTimeStamp", "From Collector To Dep-Reader-TimeStamp", cmsDirectorysMenu);

                directoryTagForNormal = "DepReaderTimeStampRec";
                directoryTagForColl = "DepCollReaderTimeStampRec";
                directoryTagForCI = "DepCIReaderTimeStampRec";

                tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                tnFromQueueToDepReaderTimeStamp.Nodes.Add(tnRecirculationTimes);
                tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                tnFromCollectorToDepReaderTimeStamp.Nodes.Add(tnRecirculationTimesColl);
                tnRecirculationTimesCI = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI, "Recirculation Times", cmsDirectorysMenu);
                tnFromCIToDepReaderTimeStamp.Nodes.Add(tnRecirculationTimesCI);

                maxNbRecirc = 0;
                if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                {
                    tnRecirculations = new TreeNode();
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                    }
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimesCI.Nodes.Add(tnRecirculations);
                    }
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimes.Nodes.Add(tnRecirculations);
                    }
                }

                tnFromDepReaderTimeStampToLastChute = OverallTools.TreeViewFunctions.CreateDirectory("DepReaderChute", "From Dep-Reader-TimeStamp To Last Chute", cmsDirectorysMenu);
                tnFromDepReaderTimeStampToExit = OverallTools.TreeViewFunctions.CreateDirectory("DepReaderExit", "From Dep-Reader-TimeStamp To Exit", cmsDirectorysMenu);

                directoryTagForNormal = "DepReaderChuteRec";
                directoryTagForColl = "DepReaderExitRec";

                tnRecirculationTimesToLastChute = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                tnFromDepReaderTimeStampToLastChute.Nodes.Add(tnRecirculationTimesToLastChute);
                tnRecirculationTimesToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                tnFromDepReaderTimeStampToExit.Nodes.Add(tnRecirculationTimesToExit);

                maxNbRecirc = 0;
                if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                {
                    tnRecirculations = new TreeNode();
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimesToExit.Nodes.Add(tnRecirculations);
                    }
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimesToLastChute.Nodes.Add(tnRecirculations);
                    }
                }

                directoryTagForNormal = "DepReaderChuteSegr";
                directoryTagForColl = "DepReaderExitSegr";

                tnReaderChuteSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                tnFromDepReaderTimeStampToLastChute.Nodes.Add(tnReaderChuteSegregationByLine);
                tnReaderExitSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                tnFromDepReaderTimeStampToExit.Nodes.Add(tnReaderExitSegregationByLine);

                nbOfReaderLines = 6;
                tnReaderLine = new TreeNode();
                for (int i = 1; i <= nbOfReaderLines; i++)
                {
                    tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                    tnReaderChuteSegregationByLine.Nodes.Add(tnReaderLine);
                }
                for (int i = 1; i <= nbOfReaderLines; i++)
                {
                    tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                    tnReaderExitSegregationByLine.Nodes.Add(tnReaderLine);
                }

                directoryTagForNormal = "DepReaderTimeStampSegr";
                directoryTagForCI = "DepCIReaderTimeStampSegr";
                directoryTagForColl = "DepCollReaderTimeStampSegr";

                tnReaderSegregationByLineQueue = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                tnFromQueueToDepReaderTimeStamp.Nodes.Add(tnReaderSegregationByLineQueue);
                tnReaderSegregationByLineCI = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI, "Segregation By Line", cmsDirectorysMenu);
                tnFromCIToDepReaderTimeStamp.Nodes.Add(tnReaderSegregationByLineCI);
                tnReaderSegregationByLineColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                tnFromCollectorToDepReaderTimeStamp.Nodes.Add(tnReaderSegregationByLineColl);

                nbOfReaderLines = 6;
                tnReaderLine = new TreeNode();
                for (int i = 1; i <= nbOfReaderLines; i++)
                {
                    tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                    tnReaderSegregationByLineQueue.Nodes.Add(tnReaderLine);
                }
                for (int i = 1; i <= nbOfReaderLines; i++)
                {
                    tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI + i, "Line_" + i, cmsDirectorysMenu);
                    tnReaderSegregationByLineCI.Nodes.Add(tnReaderLine);
                }
                for (int i = 1; i <= nbOfReaderLines; i++)
                {
                    tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                    tnReaderSegregationByLineColl.Nodes.Add(tnReaderLine);
                }

                tnTime.Nodes.Add(tnFromQueueToDepReaderTimeStamp);
                tnTime.Nodes.Add(tnFromCIToDepReaderTimeStamp);
                tnTime.Nodes.Add(tnFromCollectorToDepReaderTimeStamp);

                tnTime.Nodes.Add(tnFromDepReaderTimeStampToLastChute);
                tnTime.Nodes.Add(tnFromDepReaderTimeStampToExit);
                // >> Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader

                #region From Queue/Coll to EBS
                // >> Task #15042 Pax2Sim - BHS Analysis - new EBS stats
                tnFromQueueToEBS = OverallTools.TreeViewFunctions.CreateDirectory("DepEBS", "From Queue To EBS", cmsDirectorysMenu);
                tnFromCollectorToEBS = OverallTools.TreeViewFunctions.CreateDirectory("DepCollEBS", "From Collector To EBS", cmsDirectorysMenu);

                directoryTagForNormal = "DepEBSRec";
                directoryTagForColl = "DepCollEBSRec";
                tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                tnFromQueueToEBS.Nodes.Add(tnRecirculationTimes);
                tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                tnFromCollectorToEBS.Nodes.Add(tnRecirculationTimesColl);

                maxNbRecirc = 0;
                if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                {
                    tnRecirculations = new TreeNode();
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                    }
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimes.Nodes.Add(tnRecirculations);
                    }
                }

                tnTime.Nodes.Add(tnFromQueueToEBS);
                tnTime.Nodes.Add(tnFromCollectorToEBS);
                // << Task #15042 Pax2Sim - BHS Analysis - new EBS stats
                #endregion

                #region From Queue/CI/Coll to Last Chute
                // << Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                tnFromQueueToChute = OverallTools.TreeViewFunctions.CreateDirectory("DepChute", "From Queue To Last Chute", cmsDirectorysMenu);
                tnFromCIToChute = OverallTools.TreeViewFunctions.CreateDirectory("DepCIChute", "From CheckIn To Last Chute", cmsDirectorysMenu);
                tnFromCollectorToChute = OverallTools.TreeViewFunctions.CreateDirectory("DepCollChute", "From Collector To Last Chute", cmsDirectorysMenu);

                directoryTagForNormal = "DepChuteRec";
                directoryTagForColl = "DepCollChuteRec";
                directoryTagForCI = "DepCIChuteRec";
                tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                tnFromQueueToChute.Nodes.Add(tnRecirculationTimes);
                tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                tnFromCollectorToChute.Nodes.Add(tnRecirculationTimesColl);
                tnRecirculationTimesCI = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI, "Recirculation Times", cmsDirectorysMenu);
                tnFromCIToChute.Nodes.Add(tnRecirculationTimesCI);

                maxNbRecirc = 0;
                if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                {
                    tnRecirculations = new TreeNode();
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                    }
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimesCI.Nodes.Add(tnRecirculations);
                    }
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimes.Nodes.Add(tnRecirculations);
                    }
                }

                tnTime.Nodes.Add(tnFromQueueToChute);
                tnTime.Nodes.Add(tnFromCIToChute);
                tnTime.Nodes.Add(tnFromCollectorToChute);
                // >> Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                #endregion

                #region From Queue/CI/Coll to Presortation
                // << Task #8283 Pax2Sim - BHS mode - statistics for transportaition time per period of time
                tnFromQueueToPresortation = OverallTools.TreeViewFunctions.CreateDirectory("DepPresortation", "From Queue To Presortation", cmsDirectorysMenu);
                tnFromCIToPresortation = OverallTools.TreeViewFunctions.CreateDirectory("DepCIPresortation", "From CheckIn To Presortation", cmsDirectorysMenu);
                tnFromCollectorToPresortation = OverallTools.TreeViewFunctions.CreateDirectory("DepCollPresortation", "From Collector To Presortation", cmsDirectorysMenu);

                directoryTagForNormal = "DepPresortationSegr";
                directoryTagForCI = "DepCIPresortationSegr";
                directoryTagForColl = "DepCollPresortationSegr";

                tnSegregationByLineQueue = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                tnFromQueueToPresortation.Nodes.Add(tnSegregationByLineQueue);
                tnSegregationByLineCI = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI, "Segregation By Line", cmsDirectorysMenu);
                tnFromCIToPresortation.Nodes.Add(tnSegregationByLineCI);
                tnSegregationByLineColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                tnFromCollectorToPresortation.Nodes.Add(tnSegregationByLineColl);

                nbOfLines = 4;
                tnLine = new TreeNode();
                for (int i = 1; i <= nbOfLines; i++)
                {
                    tnLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                    tnSegregationByLineQueue.Nodes.Add(tnLine);
                }
                for (int i = 1; i <= nbOfLines; i++)
                {
                    tnLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI + i, "Line_" + i, cmsDirectorysMenu);
                    tnSegregationByLineCI.Nodes.Add(tnLine);
                }
                for (int i = 1; i <= nbOfLines; i++)
                {
                    tnLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                    tnSegregationByLineColl.Nodes.Add(tnLine);
                }

                tnTime.Nodes.Add(tnFromQueueToPresortation);
                tnTime.Nodes.Add(tnFromCIToPresortation);
                tnTime.Nodes.Add(tnFromCollectorToPresortation);
                // >> Task #8283 Pax2Sim - BHS mode - statistics for transportaition time per period of time
                #endregion

                // >> Task #15042 Pax2Sim - BHS Analysis - new EBS stats
                #region EBS to Last Chute
                TreeNode tnDep_FromLastChuteToMakeUp = OverallTools.TreeViewFunctions.CreateDirectory("DepEBSChute", "From EBS To LastChute", cmsDirectorysMenu);

                directoryTagForColl = "DepEBSChuteRec";

                TreeNode tnDep_RecirculationTimesChuteToMakeUp = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                tnDep_FromLastChuteToMakeUp.Nodes.Add(tnDep_RecirculationTimesChuteToMakeUp);

                maxNbRecirc = 0;
                if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                {
                    tnRecirculations = new TreeNode();
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnDep_RecirculationTimesChuteToMakeUp.Nodes.Add(tnRecirculations);
                    }
                }

                tnTime.Nodes.Add(tnDep_FromLastChuteToMakeUp);
                #endregion

                #region From EBS to exit
                tnFromEBSToExit = OverallTools.TreeViewFunctions.CreateDirectory("DepEBSExit", "From EBS To Exit", cmsDirectorysMenu);

                directoryTagForColl = "DepEBSExitRec";

                tnRecircFromEBSToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                tnFromEBSToExit.Nodes.Add(tnRecircFromEBSToExit);

                maxNbRecirc = 0;
                if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                {
                    tnRecirculations = new TreeNode();
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecircFromEBSToExit.Nodes.Add(tnRecirculations);
                    }
                }

                directoryTagForColl = "DepEBSExitSegr";

                tnSegregationByLineFromEBSToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                tnFromEBSToExit.Nodes.Add(tnSegregationByLineFromEBSToExit);

                //nbOfChuteLines = 30;
                tnEBSLine = new TreeNode();

                for (int i = 1; i <= nbOfEBSLines; i++)
                {
                    tnEBSLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                    tnSegregationByLineFromEBSToExit.Nodes.Add(tnEBSLine);
                }

                tnTime.Nodes.Add(tnFromEBSToExit);
                #endregion
                // << Task #15042 Pax2Sim - BHS Analysis - new EBS stats

                // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                #region Chute To MakeUp directory
                tnFromLastChuteToMakeUp = OverallTools.TreeViewFunctions.CreateDirectory("DepChuteMakeUp", "From LastChute To MakeUp", cmsDirectorysMenu);

                directoryTagForColl = "DepChuteMakeUpRec";

                tnRecirculationTimesChuteToMakeUp = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                tnFromLastChuteToMakeUp.Nodes.Add(tnRecirculationTimesChuteToMakeUp);

                maxNbRecirc = 0;
                if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                {
                    tnRecirculations = new TreeNode();
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimesChuteToMakeUp.Nodes.Add(tnRecirculations);
                    }
                }

                tnTime.Nodes.Add(tnFromLastChuteToMakeUp);
                #endregion
                // >> Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader

                // << Task #9611 Pax2Sim - BHS - Analyse BHS Results Assistant - Analysis Range option
                #region Chute To Exit directory
                tnFromLastChuteToExit = OverallTools.TreeViewFunctions.CreateDirectory("DepChuteExit", "From LastChute To Exit", cmsDirectorysMenu);

                directoryTagForColl = "DepChuteExitRec";

                tnRecirculationTimesChuteToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                tnFromLastChuteToExit.Nodes.Add(tnRecirculationTimesChuteToExit);

                maxNbRecirc = 0;
                if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                {
                    tnRecirculations = new TreeNode();
                    for (int i = 0; i < maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimesChuteToExit.Nodes.Add(tnRecirculations);
                    }
                }

                directoryTagForColl = "DepChuteExitSegr";

                tnChuteExitSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                tnFromLastChuteToExit.Nodes.Add(tnChuteExitSegregationByLine);

                //nbOfChuteLines = 30;
                tnChuteLine = new TreeNode();

                for (int i = 1; i <= nbOfChuteLines; i++)
                {
                    tnChuteLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                    tnChuteExitSegregationByLine.Nodes.Add(tnChuteLine);
                }

                tnTime.Nodes.Add(tnFromLastChuteToExit);
                #endregion
                // >> Task #9611 Pax2Sim - BHS - Analyse BHS Results Assistant - Analysis Range option
                #endregion

                if (generateMUPSegregation) // >> Task #14280 Bag Trace Loading time too long
                {
                    foreach (string key in makeUpSGroupsDictionary.Keys)
                    {
                        string makeupGroupDescription = "";
                        if (makeUpGroupWithDescriptionDictionary.ContainsKey(key))
                            makeupGroupDescription = makeUpGroupWithDescriptionDictionary[key];

                        TreeNode makeupGroup = OverallTools.TreeViewFunctions.CreateDirectory(key + "(" + makeupGroupDescription + ")", key + "(" + makeupGroupDescription + ")", cmsDirectorysMenu);
                        tnDepartingMU.Nodes.Add(makeupGroup);

                        #region _Times MUPSegregation
                        TreeNode tnMakeupGroupTime = OverallTools.TreeViewFunctions.CreateDirectory("Departing" + key, "_Times " + key + "(" + makeupGroupDescription + ")", cmsDirectorysMenu);
                        tnTime.Nodes.Add(tnMakeupGroupTime);

                        #region From Coll to Exit, CI to Exit and From Queue to Exit                        
                        tnFromCollector = OverallTools.TreeViewFunctions.CreateDirectory("DepColl" + key, "From Collector To Exit", cmsDirectorysMenu);
                        tnFromCI = OverallTools.TreeViewFunctions.CreateDirectory("DepCI" + key, "From CheckIn To Exit", cmsDirectorysMenu);
                        tnFromQueue = OverallTools.TreeViewFunctions.CreateDirectory("Dep" + key, "From Queue To Exit", cmsDirectorysMenu);

                        directoryTagForNormal = "Dep" + key + "Rec";
                        directoryTagForColl = "DepColl" + key + "Rec";
                        directoryTagForCI = "DepCI" + key + "Rec";

                        tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                        tnFromQueue.Nodes.Add(tnRecirculationTimes);
                        tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                        tnFromCollector.Nodes.Add(tnRecirculationTimesColl);
                        tnRecirculationTimesCI = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI, "Recirculation Times", cmsDirectorysMenu);
                        tnFromCI.Nodes.Add(tnRecirculationTimesCI);

                        maxNbRecirc = 0;
                        if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                        {
                            tnRecirculations = new TreeNode();
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                            }
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesCI.Nodes.Add(tnRecirculations);
                            }
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimes.Nodes.Add(tnRecirculations);
                            }
                        }
                        //makeupGroup.Nodes.Add(tnTime);
                        tnMakeupGroupTime.Nodes.Add(tnFromQueue);
                        tnMakeupGroupTime.Nodes.Add(tnFromCI);
                        tnMakeupGroupTime.Nodes.Add(tnFromCollector);
                        #endregion

                        #region From Queue/CI/Coll To DepReader
                        tnFromQueueToDepReaderTimeStamp = OverallTools.TreeViewFunctions.CreateDirectory("DepReaderTimeStamp" + key, "From Queue To Dep-Reader-TimeStamp", cmsDirectorysMenu);
                        tnFromCIToDepReaderTimeStamp = OverallTools.TreeViewFunctions.CreateDirectory("DepCIReaderTimeStamp" + key, "From CheckIn To Dep-Reader-TimeStamp", cmsDirectorysMenu);
                        tnFromCollectorToDepReaderTimeStamp = OverallTools.TreeViewFunctions.CreateDirectory("DepCollReaderTimeStamp" + key, "From Collector To Dep-Reader-TimeStamp", cmsDirectorysMenu);

                        directoryTagForNormal = "DepReaderTimeStamp" + key + "Rec";
                        directoryTagForColl = "DepCollReaderTimeStamp" + key + "Rec";
                        directoryTagForCI = "DepCIReaderTimeStamp" + key + "Rec";

                        tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                        tnFromQueueToDepReaderTimeStamp.Nodes.Add(tnRecirculationTimes);
                        tnRecirculationTimesCI = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI, "Recirculation Times", cmsDirectorysMenu);
                        tnFromCIToDepReaderTimeStamp.Nodes.Add(tnRecirculationTimesCI);
                        tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                        tnFromCollectorToDepReaderTimeStamp.Nodes.Add(tnRecirculationTimesColl);

                        maxNbRecirc = 0;
                        if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                        {
                            tnRecirculations = new TreeNode();
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                            }
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesCI.Nodes.Add(tnRecirculations);
                            }
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimes.Nodes.Add(tnRecirculations);
                            }
                        }
                        #endregion

                        #region From DepReader To LastChute/Exit
                        tnFromDepReaderTimeStampToLastChute = OverallTools.TreeViewFunctions.CreateDirectory("DepReaderChute" + key, "From Dep-Reader-TimeStamp To Last Chute", cmsDirectorysMenu);
                        tnFromDepReaderTimeStampToExit = OverallTools.TreeViewFunctions.CreateDirectory("DepReaderExit" + key, "From Dep-Reader-TimeStamp To Exit", cmsDirectorysMenu);

                        directoryTagForNormal = "DepReaderChute" + key + "Rec";
                        directoryTagForColl = "DepReaderExit" + key + "Rec";

                        tnRecirculationTimesToLastChute = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                        tnFromDepReaderTimeStampToLastChute.Nodes.Add(tnRecirculationTimesToLastChute);
                        tnRecirculationTimesToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                        tnFromDepReaderTimeStampToExit.Nodes.Add(tnRecirculationTimesToExit);

                        maxNbRecirc = 0;
                        if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                        {
                            tnRecirculations = new TreeNode();
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesToExit.Nodes.Add(tnRecirculations);
                            }
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesToLastChute.Nodes.Add(tnRecirculations);
                            }
                        }

                        directoryTagForNormal = "DepReaderChute" + key + "Segr";
                        directoryTagForColl = "DepReaderExit" + key + "Segr";

                        tnReaderChuteSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                        tnFromDepReaderTimeStampToLastChute.Nodes.Add(tnReaderChuteSegregationByLine);
                        tnReaderExitSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                        tnFromDepReaderTimeStampToExit.Nodes.Add(tnReaderExitSegregationByLine);

                        nbOfReaderLines = 6;
                        tnReaderLine = new TreeNode();
                        for (int i = 1; i <= nbOfReaderLines; i++)
                        {
                            tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                            tnReaderChuteSegregationByLine.Nodes.Add(tnReaderLine);
                        }
                        for (int i = 1; i <= nbOfReaderLines; i++)
                        {
                            tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                            tnReaderExitSegregationByLine.Nodes.Add(tnReaderLine);
                        }

                        directoryTagForNormal = "DepReaderTimeStamp" + key + "Segr";
                        directoryTagForColl = "DepCollReaderTimeStamp" + key + "Segr";

                        tnReaderSegregationByLineQueue = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                        tnFromQueueToDepReaderTimeStamp.Nodes.Add(tnReaderSegregationByLineQueue);
                        tnReaderSegregationByLineColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                        tnFromCollectorToDepReaderTimeStamp.Nodes.Add(tnReaderSegregationByLineColl);

                        nbOfReaderLines = 6;
                        tnReaderLine = new TreeNode();
                        for (int i = 1; i <= nbOfReaderLines; i++)
                        {
                            tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                            tnReaderSegregationByLineQueue.Nodes.Add(tnReaderLine);
                        }
                        for (int i = 1; i <= nbOfReaderLines; i++)
                        {
                            tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                            tnReaderSegregationByLineColl.Nodes.Add(tnReaderLine);
                        }
                        #endregion

                        tnMakeupGroupTime.Nodes.Add(tnFromQueueToDepReaderTimeStamp);
                        tnMakeupGroupTime.Nodes.Add(tnFromCIToDepReaderTimeStamp);
                        tnMakeupGroupTime.Nodes.Add(tnFromCollectorToDepReaderTimeStamp);

                        tnMakeupGroupTime.Nodes.Add(tnFromDepReaderTimeStampToLastChute);
                        tnMakeupGroupTime.Nodes.Add(tnFromDepReaderTimeStampToExit);

                        #region From Queue/Coll to EBS
                        // >> Task #15042 Pax2Sim - BHS Analysis - new EBS stats
                        tnFromQueueToEBS = OverallTools.TreeViewFunctions.CreateDirectory("DepEBS" + key, "From Queue To EBS", cmsDirectorysMenu);
                        tnFromCollectorToEBS = OverallTools.TreeViewFunctions.CreateDirectory("DepCollEBS" + key, "From Collector To EBS", cmsDirectorysMenu);

                        directoryTagForNormal = "DepChute" + key + "Rec";
                        directoryTagForColl = "DepCollChute" + key + "Rec";
                        tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                        tnFromQueueToEBS.Nodes.Add(tnRecirculationTimes);
                        tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                        tnFromCollectorToEBS.Nodes.Add(tnRecirculationTimesColl);

                        maxNbRecirc = 0;
                        if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                        {
                            tnRecirculations = new TreeNode();
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                            }
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimes.Nodes.Add(tnRecirculations);
                            }
                        }
                        tnMakeupGroupTime.Nodes.Add(tnFromQueueToEBS);
                        tnMakeupGroupTime.Nodes.Add(tnFromCollectorToEBS);
                        // << Task #15042 Pax2Sim - BHS Analysis - new EBS stats
                        #endregion

                        #region From Queue/CI/Coll to Chute
                        tnFromQueueToChute = OverallTools.TreeViewFunctions.CreateDirectory("DepChute" + key, "From Queue To Last Chute", cmsDirectorysMenu);
                        tnFromCIToChute = OverallTools.TreeViewFunctions.CreateDirectory("DepCIChute" + key, "From CheckIn To Last Chute", cmsDirectorysMenu);
                        tnFromCollectorToChute = OverallTools.TreeViewFunctions.CreateDirectory("DepCollChute" + key, "From Collector To Last Chute", cmsDirectorysMenu);

                        directoryTagForNormal = "DepChute" + key + "Rec";
                        directoryTagForColl = "DepCollChute" + key + "Rec";
                        directoryTagForCI = "DepCIChute" + key + "Rec";
                        tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                        tnFromQueueToChute.Nodes.Add(tnRecirculationTimes);
                        tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                        tnFromCollectorToChute.Nodes.Add(tnRecirculationTimesColl);
                        tnRecirculationTimesCI = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI, "Recirculation Times", cmsDirectorysMenu);
                        tnFromCIToChute.Nodes.Add(tnRecirculationTimesCI);

                        maxNbRecirc = 0;
                        if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                        {
                            tnRecirculations = new TreeNode();
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                            }
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesCI.Nodes.Add(tnRecirculations);
                            }
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimes.Nodes.Add(tnRecirculations);
                            }
                        }
                        tnMakeupGroupTime.Nodes.Add(tnFromQueueToChute);
                        tnMakeupGroupTime.Nodes.Add(tnFromCIToChute);
                        tnMakeupGroupTime.Nodes.Add(tnFromCollectorToChute);
                        #endregion

                        #region From Queue/CI/Coll to Presortation
                        tnFromQueueToPresortation = OverallTools.TreeViewFunctions.CreateDirectory("DepPresortation" + key, "From Queue To Presortation", cmsDirectorysMenu);
                        tnFromCIToPresortation = OverallTools.TreeViewFunctions.CreateDirectory("DepCIPresortation" + key, "From CheckIn To Presortation", cmsDirectorysMenu);
                        tnFromCollectorToPresortation = OverallTools.TreeViewFunctions.CreateDirectory("DepCollPresortation" + key, "From Collector To Presortation", cmsDirectorysMenu);

                        directoryTagForNormal = "DepPresortation" + key + "Segr";
                        directoryTagForCI = "DepCIPresortation" + key + "Segr";
                        directoryTagForColl = "DepCollPresortation" + key + "Segr";

                        tnSegregationByLineQueue = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                        tnFromQueueToPresortation.Nodes.Add(tnSegregationByLineQueue);
                        tnSegregationByLineCI = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI, "Segregation By Line", cmsDirectorysMenu);
                        tnFromCIToPresortation.Nodes.Add(tnSegregationByLineCI);
                        tnSegregationByLineColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                        tnFromCollectorToPresortation.Nodes.Add(tnSegregationByLineColl);

                        nbOfLines = 4;
                        tnLine = new TreeNode();
                        for (int i = 1; i <= nbOfLines; i++)
                        {
                            tnLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                            tnSegregationByLineQueue.Nodes.Add(tnLine);
                        }
                        for (int i = 1; i <= nbOfLines; i++)
                        {
                            tnLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI + i, "Line_" + i, cmsDirectorysMenu);
                            tnSegregationByLineCI.Nodes.Add(tnLine);
                        }
                        for (int i = 1; i <= nbOfLines; i++)
                        {
                            tnLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                            tnSegregationByLineColl.Nodes.Add(tnLine);
                        }
                        tnMakeupGroupTime.Nodes.Add(tnFromQueueToPresortation);
                        tnMakeupGroupTime.Nodes.Add(tnFromCIToPresortation);
                        tnMakeupGroupTime.Nodes.Add(tnFromCollectorToPresortation);
                        #endregion

                        // >> Task #15042 Pax2Sim - BHS Analysis - new EBS stats
                        #region EBS to Last Chute
                        TreeNode tnDepMupSegr_FromLastChuteToMakeUp = OverallTools.TreeViewFunctions.CreateDirectory("DepEBSChute" + key, "From EBS To LastChute", cmsDirectorysMenu);

                        directoryTagForColl = "DepEBSChute" + key + "Rec";

                        TreeNode tnDepMupSegr_RecirculationTimesChuteToMakeUp = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                        tnDepMupSegr_FromLastChuteToMakeUp.Nodes.Add(tnDepMupSegr_RecirculationTimesChuteToMakeUp);

                        maxNbRecirc = 0;
                        if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                        {
                            tnRecirculations = new TreeNode();
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnDepMupSegr_RecirculationTimesChuteToMakeUp.Nodes.Add(tnRecirculations);
                            }
                        }
                        tnMakeupGroupTime.Nodes.Add(tnDepMupSegr_FromLastChuteToMakeUp);
                        #endregion

                        #region From EBS to exit
                        tnFromEBSToExit = OverallTools.TreeViewFunctions.CreateDirectory("DepEBSExit" + key, "From EBS To Exit", cmsDirectorysMenu);

                        directoryTagForColl = "DepEBSExit" + key + "Rec";

                        tnRecircFromEBSToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                        tnFromEBSToExit.Nodes.Add(tnRecircFromEBSToExit);

                        maxNbRecirc = 0;
                        if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                        {
                            tnRecirculations = new TreeNode();
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecircFromEBSToExit.Nodes.Add(tnRecirculations);
                            }
                        }

                        directoryTagForColl = "DepEBSExit" + key + "Segr";
                        tnSegregationByLineFromEBSToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                        tnFromEBSToExit.Nodes.Add(tnSegregationByLineFromEBSToExit);

                        //nbOfChuteLines = 30;
                        tnEBSLine = new TreeNode();
                        for (int i = 1; i <= nbOfEBSLines; i++)
                        {
                            tnEBSLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                            tnSegregationByLineFromEBSToExit.Nodes.Add(tnEBSLine);
                        }
                        tnMakeupGroupTime.Nodes.Add(tnFromEBSToExit);
                        #endregion
                        // << Task #15042 Pax2Sim - BHS Analysis - new EBS stats

                        #region Chute To MakeUp directory
                        tnFromLastChuteToMakeUp = OverallTools.TreeViewFunctions.CreateDirectory("DepChuteMakeUp" + key, "From LastChute To MakeUp", cmsDirectorysMenu);

                        directoryTagForColl = "DepChuteMakeUp" + key + "Rec";

                        tnRecirculationTimesChuteToMakeUp = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                        tnFromLastChuteToMakeUp.Nodes.Add(tnRecirculationTimesChuteToMakeUp);

                        maxNbRecirc = 0;
                        if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                        {
                            tnRecirculations = new TreeNode();
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesChuteToMakeUp.Nodes.Add(tnRecirculations);
                            }
                        }

                        tnMakeupGroupTime.Nodes.Add(tnFromLastChuteToMakeUp);
                        #endregion

                        #region Chute To Exit directory
                        tnFromLastChuteToExit = OverallTools.TreeViewFunctions.CreateDirectory("DepChuteExit" + key, "From LastChute To Exit", cmsDirectorysMenu);

                        directoryTagForColl = "DepChuteExit" + key + "Rec";

                        tnRecirculationTimesChuteToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                        tnFromLastChuteToExit.Nodes.Add(tnRecirculationTimesChuteToExit);

                        maxNbRecirc = 0;
                        if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                        {
                            tnRecirculations = new TreeNode();
                            for (int i = 0; i < maxNbRecirc; i++)
                            {
                                tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                                tnRecirculationTimesChuteToExit.Nodes.Add(tnRecirculations);
                            }
                        }

                        directoryTagForColl = "DepChuteExit" + key + "Segr";
                        tnChuteExitSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                        tnFromLastChuteToExit.Nodes.Add(tnChuteExitSegregationByLine);

                        //nbOfChuteLines = 30;
                        tnChuteLine = new TreeNode();
                        for (int i = 1; i <= nbOfChuteLines; i++)
                        {
                            tnChuteLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                            tnChuteExitSegregationByLine.Nodes.Add(tnChuteLine);
                        }
                        tnMakeupGroupTime.Nodes.Add(tnFromLastChuteToExit);
                        #endregion

                        #endregion
                    }
                    // >> Task #13659 IST MakeUp segregation
                    #region commented
                    /*
                    #region _Times MUPS3

                    #region From Coll to Exit and From Queue to Exit
                    tnTime = OverallTools.TreeViewFunctions.CreateDirectory("Departing", "_Times_Exit_MU Group 1 (S3)", cmsDirectorysMenu);
                    // << Task #8223 Pax2Sim - BHS mode - baggs IST statistic change                
                    tnFromCollector = OverallTools.TreeViewFunctions.CreateDirectory("DepColl" + MUP_GROUP_S3, "From Collector To Exit", cmsDirectorysMenu);
                    tnFromQueue = OverallTools.TreeViewFunctions.CreateDirectory("Dep" + MUP_GROUP_S3, "From Queue To Exit", cmsDirectorysMenu);
                    // >> Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                    // << Task #7530 Analyze Bag Trace module - Recirculation statistics
                    directoryTagForNormal = "Dep" + MUP_GROUP_S3 + "Rec";
                    directoryTagForColl = "DepColl" + MUP_GROUP_S3 + "Rec";
                    tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                    tnFromQueue.Nodes.Add(tnRecirculationTimes);
                    tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromCollector.Nodes.Add(tnRecirculationTimesColl);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                        }
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimes.Nodes.Add(tnRecirculations);
                        }
                    }
                    // >> Task #7530 Analyze Bag Trace module - Recirculation statistics

                    tnDeparting.Nodes.Add(tnTime);
                    tnTime.Nodes.Add(tnFromQueue);
                    tnTime.Nodes.Add(tnFromCollector);
                    #endregion

                    #region From Queue/Coll To DepReader
                    // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                    tnFromQueueToDepReaderTimeStamp = OverallTools.TreeViewFunctions.CreateDirectory("DepReaderTimeStamp" + MUP_GROUP_S3, "From Queue To Dep-Reader-TimeStamp", cmsDirectorysMenu);
                    tnFromCollectorToDepReaderTimeStamp = OverallTools.TreeViewFunctions.CreateDirectory("DepCollReaderTimeStamp" + MUP_GROUP_S3, "From Collector To Dep-Reader-TimeStamp", cmsDirectorysMenu);

                    directoryTagForNormal = "DepReaderTimeStamp" + MUP_GROUP_S3 + "Rec";
                    directoryTagForColl = "DepCollReaderTimeStamp" + MUP_GROUP_S3 + "Rec";

                    tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                    tnFromQueueToDepReaderTimeStamp.Nodes.Add(tnRecirculationTimes);
                    tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromCollectorToDepReaderTimeStamp.Nodes.Add(tnRecirculationTimesColl);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                        }
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimes.Nodes.Add(tnRecirculations);
                        }
                    }
                    #endregion

                    #region From DepReader To LastChute/Exit
                    tnFromDepReaderTimeStampToLastChute = OverallTools.TreeViewFunctions.CreateDirectory("DepReaderChute" + MUP_GROUP_S3, "From Dep-Reader-TimeStamp To Last Chute", cmsDirectorysMenu);
                    tnFromDepReaderTimeStampToExit = OverallTools.TreeViewFunctions.CreateDirectory("DepReaderExit" + MUP_GROUP_S3, "From Dep-Reader-TimeStamp To Exit", cmsDirectorysMenu);

                    directoryTagForNormal = "DepReaderChute" + MUP_GROUP_S3 + "Rec";
                    directoryTagForColl = "DepReaderExit" + MUP_GROUP_S3 + "Rec";

                    tnRecirculationTimesToLastChute = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                    tnFromDepReaderTimeStampToLastChute.Nodes.Add(tnRecirculationTimesToLastChute);
                    tnRecirculationTimesToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromDepReaderTimeStampToExit.Nodes.Add(tnRecirculationTimesToExit);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesToExit.Nodes.Add(tnRecirculations);
                        }
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesToLastChute.Nodes.Add(tnRecirculations);
                        }
                    }

                    directoryTagForNormal = "DepReaderChute" + MUP_GROUP_S3 + "Segr";
                    directoryTagForColl = "DepReaderExit" + MUP_GROUP_S3 + "Segr";

                    tnReaderChuteSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                    tnFromDepReaderTimeStampToLastChute.Nodes.Add(tnReaderChuteSegregationByLine);
                    tnReaderExitSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                    tnFromDepReaderTimeStampToExit.Nodes.Add(tnReaderExitSegregationByLine);

                    nbOfReaderLines = 6;
                    tnReaderLine = new TreeNode();
                    for (int i = 1; i <= nbOfReaderLines; i++)
                    {
                        tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                        tnReaderChuteSegregationByLine.Nodes.Add(tnReaderLine);
                    }
                    for (int i = 1; i <= nbOfReaderLines; i++)
                    {
                        tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                        tnReaderExitSegregationByLine.Nodes.Add(tnReaderLine);
                    }

                    directoryTagForNormal = "DepReaderTimeStamp" + MUP_GROUP_S3 + "Segr";
                    directoryTagForColl = "DepCollReaderTimeStamp" + MUP_GROUP_S3 + "Segr";

                    tnReaderSegregationByLineQueue = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                    tnFromQueueToDepReaderTimeStamp.Nodes.Add(tnReaderSegregationByLineQueue);
                    tnReaderSegregationByLineColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                    tnFromCollectorToDepReaderTimeStamp.Nodes.Add(tnReaderSegregationByLineColl);

                    nbOfReaderLines = 6;
                    tnReaderLine = new TreeNode();
                    for (int i = 1; i <= nbOfReaderLines; i++)
                    {
                        tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                        tnReaderSegregationByLineQueue.Nodes.Add(tnReaderLine);
                    }
                    for (int i = 1; i <= nbOfReaderLines; i++)
                    {
                        tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                        tnReaderSegregationByLineColl.Nodes.Add(tnReaderLine);
                    }
                    #endregion

                    tnTime.Nodes.Add(tnFromQueueToDepReaderTimeStamp);
                    tnTime.Nodes.Add(tnFromCollectorToDepReaderTimeStamp);
                    tnTime.Nodes.Add(tnFromDepReaderTimeStampToLastChute);
                    tnTime.Nodes.Add(tnFromDepReaderTimeStampToExit);
                    // >> Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader

                    #region From Queue/Coll to Chute
                    // << Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                    tnFromQueueToChute = OverallTools.TreeViewFunctions.CreateDirectory("DepChute" + MUP_GROUP_S3, "From Queue To Last Chute", cmsDirectorysMenu);
                    tnFromCollectorToChute = OverallTools.TreeViewFunctions.CreateDirectory("DepCollChute" + MUP_GROUP_S3, "From Collector To Last Chute", cmsDirectorysMenu);

                    directoryTagForNormal = "DepChute" + MUP_GROUP_S3 + "Rec";
                    directoryTagForColl = "DepCollChute" + MUP_GROUP_S3 + "Rec";
                    tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                    tnFromQueueToChute.Nodes.Add(tnRecirculationTimes);
                    tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromCollectorToChute.Nodes.Add(tnRecirculationTimesColl);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                        }
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimes.Nodes.Add(tnRecirculations);
                        }
                    }

                    tnTime.Nodes.Add(tnFromQueueToChute);
                    tnTime.Nodes.Add(tnFromCollectorToChute);
                    // >> Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                    #endregion

                    #region From Queue/Coll to Presortation
                    // << Task #8283 Pax2Sim - BHS mode - statistics for transportaition time per period of time
                    tnFromQueueToPresortation = OverallTools.TreeViewFunctions.CreateDirectory("DepPresortation" + MUP_GROUP_S3, "From Queue To Presortation", cmsDirectorysMenu);
                    tnFromCollectorToPresortation = OverallTools.TreeViewFunctions.CreateDirectory("DepCollPresortation" + MUP_GROUP_S3, "From Collector To Presortation", cmsDirectorysMenu);

                    directoryTagForNormal = "DepPresortation" + MUP_GROUP_S3 + "Segr";
                    directoryTagForColl = "DepCollPresortation" + MUP_GROUP_S3 + "Segr";

                    tnSegregationByLineQueue = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                    tnFromQueueToPresortation.Nodes.Add(tnSegregationByLineQueue);
                    tnSegregationByLineColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                    tnFromCollectorToPresortation.Nodes.Add(tnSegregationByLineColl);

                    nbOfLines = 4;
                    tnLine = new TreeNode();
                    for (int i = 1; i <= nbOfLines; i++)
                    {
                        tnLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                        tnSegregationByLineQueue.Nodes.Add(tnLine);
                    }
                    for (int i = 1; i <= nbOfLines; i++)
                    {
                        tnLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                        tnSegregationByLineColl.Nodes.Add(tnLine);
                    }

                    tnTime.Nodes.Add(tnFromQueueToPresortation);
                    tnTime.Nodes.Add(tnFromCollectorToPresortation);
                    // >> Task #8283 Pax2Sim - BHS mode - statistics for transportaition time per period of time
                    #endregion

                    // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                    #region Chute To MakeUp directory
                    tnFromLastChuteToMakeUp = OverallTools.TreeViewFunctions.CreateDirectory("DepChuteMakeUp" + MUP_GROUP_S3, "From LastChute To MakeUp", cmsDirectorysMenu);

                    directoryTagForColl = "DepChuteMakeUp" + MUP_GROUP_S3 + "Rec";

                    tnRecirculationTimesChuteToMakeUp = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromLastChuteToMakeUp.Nodes.Add(tnRecirculationTimesChuteToMakeUp);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesChuteToMakeUp.Nodes.Add(tnRecirculations);
                        }
                    }

                    tnTime.Nodes.Add(tnFromLastChuteToMakeUp);
                    #endregion
                    // >> Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader

                    // << Task #9611 Pax2Sim - BHS - Analyse BHS Results Assistant - Analysis Range option
                    #region Chute To Exit directory
                    tnFromLastChuteToExit = OverallTools.TreeViewFunctions.CreateDirectory("DepChuteExit" + MUP_GROUP_S3, "From LastChute To Exit", cmsDirectorysMenu);

                    directoryTagForColl = "DepChuteExit" + MUP_GROUP_S3 + "Rec";

                    tnRecirculationTimesChuteToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromLastChuteToExit.Nodes.Add(tnRecirculationTimesChuteToExit);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesChuteToExit.Nodes.Add(tnRecirculations);
                        }
                    }

                    directoryTagForColl = "DepChuteExit" + MUP_GROUP_S3 + "Segr";

                    tnChuteExitSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                    tnFromLastChuteToExit.Nodes.Add(tnChuteExitSegregationByLine);

                    nbOfChuteLines = 17;
                    tnChuteLine = new TreeNode();

                    for (int i = 1; i <= nbOfChuteLines; i++)
                    {
                        tnChuteLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                        tnChuteExitSegregationByLine.Nodes.Add(tnChuteLine);
                    }

                    tnTime.Nodes.Add(tnFromLastChuteToExit);

                    // >> Task #9611 Pax2Sim - BHS - Analyse BHS Results Assistant - Analysis Range option
                    #endregion

                    #endregion

                    #region _Times MUPS4

                    #region From Coll to Exit and From Queue to Exit
                    tnTime = OverallTools.TreeViewFunctions.CreateDirectory("Departing", "_Times_Exit_MU Group 2 (S4)", cmsDirectorysMenu);
                    // << Task #8223 Pax2Sim - BHS mode - baggs IST statistic change                
                    tnFromCollector = OverallTools.TreeViewFunctions.CreateDirectory("DepColl" + MUP_GROUP_S4, "From Collector To Exit", cmsDirectorysMenu);
                    tnFromQueue = OverallTools.TreeViewFunctions.CreateDirectory("Dep" + MUP_GROUP_S4, "From Queue To Exit", cmsDirectorysMenu);
                    // >> Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                    // << Task #7530 Analyze Bag Trace module - Recirculation statistics
                    directoryTagForNormal = "Dep" + MUP_GROUP_S4 + "Rec";
                    directoryTagForColl = "DepColl" + MUP_GROUP_S4 + "Rec";
                    tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                    tnFromQueue.Nodes.Add(tnRecirculationTimes);
                    tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromCollector.Nodes.Add(tnRecirculationTimesColl);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                        }
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimes.Nodes.Add(tnRecirculations);
                        }
                    }
                    // >> Task #7530 Analyze Bag Trace module - Recirculation statistics

                    tnDeparting.Nodes.Add(tnTime);
                    tnTime.Nodes.Add(tnFromQueue);
                    tnTime.Nodes.Add(tnFromCollector);
                    #endregion

                    #region From Queue/Coll To DepReader
                    // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                    tnFromQueueToDepReaderTimeStamp = OverallTools.TreeViewFunctions.CreateDirectory("DepReaderTimeStamp" + MUP_GROUP_S4, "From Queue To Dep-Reader-TimeStamp", cmsDirectorysMenu);
                    tnFromCollectorToDepReaderTimeStamp = OverallTools.TreeViewFunctions.CreateDirectory("DepCollReaderTimeStamp" + MUP_GROUP_S4, "From Collector To Dep-Reader-TimeStamp", cmsDirectorysMenu);

                    directoryTagForNormal = "DepReaderTimeStamp" + MUP_GROUP_S4 + "Rec";
                    directoryTagForColl = "DepCollReaderTimeStamp" + MUP_GROUP_S4 + "Rec";

                    tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                    tnFromQueueToDepReaderTimeStamp.Nodes.Add(tnRecirculationTimes);
                    tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromCollectorToDepReaderTimeStamp.Nodes.Add(tnRecirculationTimesColl);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                        }
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimes.Nodes.Add(tnRecirculations);
                        }
                    }
                    #endregion

                    #region From DepReader To LastChute/Exit
                    tnFromDepReaderTimeStampToLastChute = OverallTools.TreeViewFunctions.CreateDirectory("DepReaderChute" + MUP_GROUP_S4, "From Dep-Reader-TimeStamp To Last Chute", cmsDirectorysMenu);
                    tnFromDepReaderTimeStampToExit = OverallTools.TreeViewFunctions.CreateDirectory("DepReaderExit" + MUP_GROUP_S4, "From Dep-Reader-TimeStamp To Exit", cmsDirectorysMenu);

                    directoryTagForNormal = "DepReaderChute" + MUP_GROUP_S4 + "Rec";
                    directoryTagForColl = "DepReaderExit" + MUP_GROUP_S4 + "Rec";

                    tnRecirculationTimesToLastChute = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                    tnFromDepReaderTimeStampToLastChute.Nodes.Add(tnRecirculationTimesToLastChute);
                    tnRecirculationTimesToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromDepReaderTimeStampToExit.Nodes.Add(tnRecirculationTimesToExit);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesToExit.Nodes.Add(tnRecirculations);
                        }
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesToLastChute.Nodes.Add(tnRecirculations);
                        }
                    }

                    directoryTagForNormal = "DepReaderChute" + MUP_GROUP_S4 + "Segr";
                    directoryTagForColl = "DepReaderExit" + MUP_GROUP_S4 + "Segr";

                    tnReaderChuteSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                    tnFromDepReaderTimeStampToLastChute.Nodes.Add(tnReaderChuteSegregationByLine);
                    tnReaderExitSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                    tnFromDepReaderTimeStampToExit.Nodes.Add(tnReaderExitSegregationByLine);

                    nbOfReaderLines = 6;
                    tnReaderLine = new TreeNode();
                    for (int i = 1; i <= nbOfReaderLines; i++)
                    {
                        tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                        tnReaderChuteSegregationByLine.Nodes.Add(tnReaderLine);
                    }
                    for (int i = 1; i <= nbOfReaderLines; i++)
                    {
                        tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                        tnReaderExitSegregationByLine.Nodes.Add(tnReaderLine);
                    }

                    directoryTagForNormal = "DepReaderTimeStamp" + MUP_GROUP_S4 + "Segr";
                    directoryTagForColl = "DepCollReaderTimeStamp" + MUP_GROUP_S4 + "Segr";

                    tnReaderSegregationByLineQueue = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                    tnFromQueueToDepReaderTimeStamp.Nodes.Add(tnReaderSegregationByLineQueue);
                    tnReaderSegregationByLineColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                    tnFromCollectorToDepReaderTimeStamp.Nodes.Add(tnReaderSegregationByLineColl);

                    nbOfReaderLines = 6;
                    tnReaderLine = new TreeNode();
                    for (int i = 1; i <= nbOfReaderLines; i++)
                    {
                        tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                        tnReaderSegregationByLineQueue.Nodes.Add(tnReaderLine);
                    }
                    for (int i = 1; i <= nbOfReaderLines; i++)
                    {
                        tnReaderLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                        tnReaderSegregationByLineColl.Nodes.Add(tnReaderLine);
                    }
                    #endregion

                    tnTime.Nodes.Add(tnFromQueueToDepReaderTimeStamp);
                    tnTime.Nodes.Add(tnFromCollectorToDepReaderTimeStamp);
                    tnTime.Nodes.Add(tnFromDepReaderTimeStampToLastChute);
                    tnTime.Nodes.Add(tnFromDepReaderTimeStampToExit);
                    // >> Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader

                    #region From Queue/Coll to Chute
                    // << Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                    tnFromQueueToChute = OverallTools.TreeViewFunctions.CreateDirectory("DepChute" + MUP_GROUP_S4, "From Queue To Last Chute", cmsDirectorysMenu);
                    tnFromCollectorToChute = OverallTools.TreeViewFunctions.CreateDirectory("DepCollChute" + MUP_GROUP_S4, "From Collector To Last Chute", cmsDirectorysMenu);

                    directoryTagForNormal = "DepChute" + MUP_GROUP_S4 + "Rec";
                    directoryTagForColl = "DepCollChute" + MUP_GROUP_S4 + "Rec";
                    tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                    tnFromQueueToChute.Nodes.Add(tnRecirculationTimes);
                    tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromCollectorToChute.Nodes.Add(tnRecirculationTimesColl);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                        }
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimes.Nodes.Add(tnRecirculations);
                        }
                    }

                    tnTime.Nodes.Add(tnFromQueueToChute);
                    tnTime.Nodes.Add(tnFromCollectorToChute);
                    // >> Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                    #endregion

                    #region From Queue/Coll to Presortation
                    // << Task #8283 Pax2Sim - BHS mode - statistics for transportaition time per period of time
                    tnFromQueueToPresortation = OverallTools.TreeViewFunctions.CreateDirectory("DepPresortation" + MUP_GROUP_S4, "From Queue To Presortation", cmsDirectorysMenu);
                    tnFromCollectorToPresortation = OverallTools.TreeViewFunctions.CreateDirectory("DepCollPresortation" + MUP_GROUP_S4, "From Collector To Presortation", cmsDirectorysMenu);

                    directoryTagForNormal = "DepPresortation" + MUP_GROUP_S4 + "Segr";
                    directoryTagForColl = "DepCollPresortation" + MUP_GROUP_S4 + "Segr";

                    tnSegregationByLineQueue = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Segregation By Line", cmsDirectorysMenu);
                    tnFromQueueToPresortation.Nodes.Add(tnSegregationByLineQueue);
                    tnSegregationByLineColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                    tnFromCollectorToPresortation.Nodes.Add(tnSegregationByLineColl);

                    nbOfLines = 4;
                    tnLine = new TreeNode();
                    for (int i = 1; i <= nbOfLines; i++)
                    {
                        tnLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, "Line_" + i, cmsDirectorysMenu);
                        tnSegregationByLineQueue.Nodes.Add(tnLine);
                    }
                    for (int i = 1; i <= nbOfLines; i++)
                    {
                        tnLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                        tnSegregationByLineColl.Nodes.Add(tnLine);
                    }

                    tnTime.Nodes.Add(tnFromQueueToPresortation);
                    tnTime.Nodes.Add(tnFromCollectorToPresortation);
                    // >> Task #8283 Pax2Sim - BHS mode - statistics for transportaition time per period of time
                    #endregion

                    // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                    #region Chute To MakeUp directory
                    tnFromLastChuteToMakeUp = OverallTools.TreeViewFunctions.CreateDirectory("DepChuteMakeUp" + MUP_GROUP_S4, "From LastChute To MakeUp", cmsDirectorysMenu);

                    directoryTagForColl = "DepChuteMakeUp" + MUP_GROUP_S4 + "Rec";

                    tnRecirculationTimesChuteToMakeUp = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromLastChuteToMakeUp.Nodes.Add(tnRecirculationTimesChuteToMakeUp);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesChuteToMakeUp.Nodes.Add(tnRecirculations);
                        }
                    }

                    tnTime.Nodes.Add(tnFromLastChuteToMakeUp);
                    #endregion
                    // >> Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader

                    // << Task #9611 Pax2Sim - BHS - Analyse BHS Results Assistant - Analysis Range option
                    #region Chute To Exit directory
                    tnFromLastChuteToExit = OverallTools.TreeViewFunctions.CreateDirectory("DepChuteExit" + MUP_GROUP_S4, "From LastChute To Exit", cmsDirectorysMenu);

                    directoryTagForColl = "DepChuteExit" + MUP_GROUP_S4 + "Rec";

                    tnRecirculationTimesChuteToExit = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                    tnFromLastChuteToExit.Nodes.Add(tnRecirculationTimesChuteToExit);

                    maxNbRecirc = 0;
                    if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsDep].ToString(), out maxNbRecirc))
                    {
                        tnRecirculations = new TreeNode();
                        for (int i = 0; i < maxNbRecirc; i++)
                        {
                            tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                            tnRecirculationTimesChuteToExit.Nodes.Add(tnRecirculations);
                        }
                    }

                    directoryTagForColl = "DepChuteExit" + MUP_GROUP_S4 + "Segr";

                    tnChuteExitSegregationByLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Segregation By Line", cmsDirectorysMenu);
                    tnFromLastChuteToExit.Nodes.Add(tnChuteExitSegregationByLine);

                    nbOfChuteLines = 17;
                    tnChuteLine = new TreeNode();

                    for (int i = 1; i <= nbOfChuteLines; i++)
                    {
                        tnChuteLine = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, "Line_" + i, cmsDirectorysMenu);
                        tnChuteExitSegregationByLine.Nodes.Add(tnChuteLine);
                    }

                    tnTime.Nodes.Add(tnFromLastChuteToExit);

                    // >> Task #9611 Pax2Sim - BHS - Analyse BHS Results Assistant - Analysis Range option
                    #endregion

                    #endregion
                    */
                    #endregion
                    // << Task #13659 IST MakeUp segregation
                }

                tnDeparting.Nodes.Add(tnDepartingHBS);
                tnDeparting.Nodes.Add(tnDepartingSorter);
                tnDeparting.Nodes.Add(tnDepartingMES);
                if (!bDelhi)
                {
                    tnDeparting.Nodes.Add(tnDepartingEBS);
                    //<< New Objects(II) - Task#7367 
                    UpdateDirectories(tnDeparting, lsNames, sEBSToploader, "EBS Toploader", cmsDirectorysMenu);
                    UpdateDirectories(tnDeparting, lsNames, sEBSUnloader, "EBS Unloader", cmsDirectorysMenu);
                    //>> New Objects(II) - Task#7367
                }
                tnDeparting.Nodes.Add(tnDepartingBuffer);
                tnDeparting.Nodes.Add(tnDepartingMU);
                //tnDeparting.Nodes.Add(tnDepartingMakeUp); // ADPi Chute

                // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                TreeNode tnICS = OverallTools.TreeViewFunctions.CreateDirectory(sICS, cmsDirectorysMenu);
                tnDeparting.Nodes.Add(tnICS);

                TreeNode tnDepartingICSRecirculation = OverallTools.TreeViewFunctions.CreateDirectory(sICSRecirc, "ICSRecirculation", cmsDirectorysMenu);
                tnICS.Nodes.Add(tnDepartingICSRecirculation);

                string icsLoaderKeyword = sNewICSToploader;
                if (hasOldICSLoaderKeyword)
                    icsLoaderKeyword = sICSToploader;
                TreeNode tnICSToploader = OverallTools.TreeViewFunctions.CreateDirectory(icsLoaderKeyword, "ICS Loader", cmsDirectorysMenu);
                TreeNode tnICSUnloader = OverallTools.TreeViewFunctions.CreateDirectory(sICSUnloader, "ICS Unloader", cmsDirectorysMenu);

                if (hasICSKeyword && !hasICSLoaderOrToploaderKeyword) // >> #13391 IST Tables standardization - sorter occupation
                {
                    TreeNode tnDepartingNewICS = OverallTools.TreeViewFunctions.CreateDirectory(BHS_KEYWORD_ICS, cmsDirectorysMenu);
                    tnICS.Nodes.Add(tnDepartingNewICS);
                }
                else if (hasICSLoaderOrToploaderKeyword)
                    tnICS.Nodes.Add(tnICSToploader);

                tnICS.Nodes.Add(tnICSUnloader);

                // >> Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader                
                UpdateDirectories(tnDeparting, lsNames, sPersonalDepQueue, "Departing Queue", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sPersonalDepConv, "Departing Conveyor", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sPersonalDepVeh, "Departing Vehicle", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sPersonalDepWorkCenter, "Departing WorkCenter", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sPersonalDepTimeStamp, "Departing TimeStamp", cmsDirectorysMenu);

                UpdateDirectories(tnDeparting, lsNames, sDepReaderTimeStamp, "Departing Reader TimeStamp", cmsDirectorysMenu);  // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader

                UpdateDirectories(tnDeparting, lsNames, sPersonalDepGate, "Departing Gate", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sPersonalDepSecu, "Departing Security", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sPersonalDepPass, "Departing Passport", cmsDirectorysMenu);
                //<< New Objects - Task#7228
                UpdateDirectories(tnDeparting, lsNames, sDepStorage, "Departing Storage", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sDepStorage1, "Departing Storage 1", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sDepStorage2, "Departing Storage 2", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sDepULDMUInUsed, "Departing ULD MU InUsed", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sDepULDFullStorage, "Departing ULD Full Storage", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sDepULDEmptyStorage, "Departing ULD Empty Storage", cmsDirectorysMenu);

                UpdateDirectories(tnDeparting, lsNames, sDepSlugs, "Departing Slugs", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sDepWindow, "Departing Window", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sDepFlow, "Departing Flow", cmsDirectorysMenu);
                //>> New Objects - Task#7228

                //<< New Objects(II) - Task#7367
                UpdateDirectories(tnDeparting, lsNames, sDepVSUInputDn, "Departing VSU Input Dn", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sDepVSUInputUp, "Departing VSU Input Up", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sDepVSUOutputDn, "Departing VSU Output Dn", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sDepVSUOutputUp, "Departing VSU Output Up", cmsDirectorysMenu);
                //>> New Objects(II) - Task#7367
                #endregion

                #region Les noeuds affichés dans le noeud HBS du noeud Departing
                TreeNode tnDepartingHBS1 = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferHBS1, "HBS1", cmsDirectorysMenu);
                TreeNode tnDepartingHBS2 = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferHBS2, "HBS2", cmsDirectorysMenu);
                TreeNode tnDepartingHBS3 = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferHBS3, "HBS3", cmsDirectorysMenu);
                TreeNode tnDepartingRecircHBS3 = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferRecirculationHBS3, "Recirculation", cmsDirectorysMenu);
                TreeNode tnDepartingHBS4;
                TreeNode tnDepartingHBS5;
                if (!bDelhi)
                {
                    tnDepartingHBS4 = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferHBS4, "HBS4", cmsDirectorysMenu);
                    tnDepartingHBS5 = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferHBS5, "HBS5", cmsDirectorysMenu);
                }
                else
                {
                    tnDepartingHBS4 = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferHBS4, "HBS3M", cmsDirectorysMenu);
                    tnDepartingHBS5 = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferHBS5, "HBS4", cmsDirectorysMenu);
                }

                tnDepartingHBS.Nodes.Add(tnDepartingHBS1);
                tnDepartingHBS.Nodes.Add(tnDepartingHBS2);
                tnDepartingHBS.Nodes.Add(tnDepartingHBS3);
                tnDepartingHBS3.Nodes.Add(tnDepartingRecircHBS3);
                tnDepartingHBS.Nodes.Add(tnDepartingHBS4);
                tnDepartingHBS.Nodes.Add(tnDepartingHBS5);
                #endregion

                #region Les noeuds affichés dans le noeud Sorter du noeud Departing
                TreeNode tnDepartingSorterInduction = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferSorterInduction, "Sorter Induction", cmsDirectorysMenu);
                TreeNode tnDepartingRecirculation = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferRecirculation, "Recirculation", cmsDirectorysMenu);
                TreeNode tnDepartingInterlink = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferInterLink, "Inter-Link", cmsDirectorysMenu);
                TreeNode tnDepartingChute = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferChute, "Chute", cmsDirectorysMenu);
                TreeNode tnDepartingPBC = OverallTools.TreeViewFunctions.CreateDirectory("PBC", cmsDirectorysMenu);
                TreeNode tnDepartingEarly = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferPBC_Early, "PBC-Early", cmsDirectorysMenu);
                TreeNode tnDepartingLate = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferPBC_Late, "PBC-Late", cmsDirectorysMenu);
                TreeNode tnDepartingRecirc = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferPBC_Recirc, "PBC-Recirculation", cmsDirectorysMenu);
                TreeNode tnDepartingTSA = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferPBC_TSA, "PBC-TSA", cmsDirectorysMenu);

                if (hasSorterKeyword) // >> #13391 IST Tables standardization - sorter occupation
                {
                    TreeNode tnDepartingNewSorter = OverallTools.TreeViewFunctions.CreateDirectory(BHS_KEYWORD_SORTER, cmsDirectorysMenu);
                    tnDepartingSorter.Nodes.Add(tnDepartingNewSorter);
                }
                if (hasSortIndKeyword)
                {
                    tnDepartingSorter.Nodes.Add(tnDepartingSorterInduction);
                }
                tnDepartingSorter.Nodes.Add(tnDepartingRecirculation);
                tnDepartingSorter.Nodes.Add(tnDepartingInterlink);
                tnDepartingSorter.Nodes.Add(tnDepartingChute);
                tnDepartingSorter.Nodes.Add(tnDepartingPBC);
                tnDepartingPBC.Nodes.Add(tnDepartingEarly);
                tnDepartingPBC.Nodes.Add(tnDepartingLate);
                tnDepartingPBC.Nodes.Add(tnDepartingRecirc);
                tnDepartingPBC.Nodes.Add(tnDepartingTSA);
                #endregion

                //<< New Objects - Task#7228
                #region Nodes shown in the Sodexi directory
                if (allowCreationSodexiDirectory && tnSodexiDirectory != null)
                {
                    TreeNode tnADArea = null;
                    if (hasADAreaObjects)
                        tnADArea = OverallTools.TreeViewFunctions.CreateDirectory("ADArea", "AD-Area", cmsDirectorysMenu);
                    TreeNode tnAAArea = null;
                    if (hasAAAreaObjects)
                        tnAAArea = OverallTools.TreeViewFunctions.CreateDirectory("AAArea", "AA-Area", cmsDirectorysMenu);
                    TreeNode tnAAExport = null;
                    if (hasAAExportObjects)
                        tnAAExport = OverallTools.TreeViewFunctions.CreateDirectory("AAExport", "AA-Export", cmsDirectorysMenu);
                    TreeNode tnAAImport = null;
                    if (hasAAImportObjects)
                        tnAAImport = OverallTools.TreeViewFunctions.CreateDirectory("AAImport", "AA-Import", cmsDirectorysMenu);
                    if (tnADArea != null)
                        tnSodexiDirectory.Nodes.Add(tnADArea);
                    if (tnAAArea != null)
                    {
                        if (tnAAExport != null)
                            tnAAArea.Nodes.Add(tnAAExport);
                        if (tnAAImport != null)
                            tnAAArea.Nodes.Add(tnAAImport);
                        tnSodexiDirectory.Nodes.Add(tnAAArea);
                    }

                    #region AD Area directory 
                    if (hasADAreaObjects)
                    {
                        UpdateDirectories(tnADArea, lsNames, sADCustomQueue, "AD Custom Queue", cmsDirectorysMenu);
                        UpdateDirectories(tnADArea, lsNames, sADOOGQueue, "AD OOG Queue", cmsDirectorysMenu);
                        UpdateDirectories(tnADArea, lsNames, sADOutputBuffer, "AD Output Buffer", cmsDirectorysMenu);
                        UpdateDirectories(tnADArea, lsNames, sADInputBuffer, "AD Input Buffer", cmsDirectorysMenu);
                        UpdateDirectories(tnADArea, lsNames, sADBagsInUsed, "AD BagsInUsed", cmsDirectorysMenu);
                        UpdateDirectories(tnADArea, lsNames, sADPositionInUsed, "AD PositionInUse", cmsDirectorysMenu);
                        UpdateDirectories(tnADArea, lsNames, sADEarlyStorage, "AD Early Storage", cmsDirectorysMenu);
                        UpdateDirectories(tnADArea, lsNames, sADInfeed, "AD Infeed", cmsDirectorysMenu);
                    }
                    #endregion

                    #region AA Area directory
                    if (hasAAExportObjects)
                    {
                        UpdateDirectories(tnAAExport, lsNames, sAAInputBuffer, "AA Input Buffer", cmsDirectorysMenu);
                        UpdateDirectories(tnAAExport, lsNames, sAAInfeed, "AA Infeed", cmsDirectorysMenu);
                        UpdateDirectories(tnAAExport, lsNames, sAAEarlyStorage, "AA Early Storage", cmsDirectorysMenu);
                        UpdateDirectories(tnAAExport, lsNames, sAAMUExport, "AA MU Export", cmsDirectorysMenu);
                        UpdateDirectories(tnAAExport, lsNames, sAAMUCloserHub, "AA MU Closer Hub", cmsDirectorysMenu);
                        UpdateDirectories(tnAAExport, lsNames, sAAMUVrac, "AA MU Vrac", cmsDirectorysMenu);
                        UpdateDirectories(tnAAExport, lsNames, sAAMUULD, "AA MU ULD", cmsDirectorysMenu);
                        UpdateDirectories(tnAAExport, lsNames, sAAExportG02Early, "AA Export G02 Early", cmsDirectorysMenu);
                    }
                    if (hasAAImportObjects)
                    {
                        UpdateDirectories(tnAAImport, lsNames, sAAImport, "AA Import", cmsDirectorysMenu);
                        UpdateDirectories(tnAAImport, lsNames, sAAImportPoste, "AA Import Poste", cmsDirectorysMenu);
                        UpdateDirectories(tnAAImport, lsNames, sAAImportPosteCHR, "AA Import Poste CHR", cmsDirectorysMenu);
                        UpdateDirectories(tnAAImport, lsNames, sAAImportPosteCYM, "AA Import Poste CYM", cmsDirectorysMenu);
                    }
                    #endregion
                }
                #endregion
                //>> New Objects - Task#7228

                // >> Task #13422 Keywords improvement
                #region User directory                
                UpdateDirectories(tnUser, lsNames, BHS_KEYWORD_USER_TIMESTAMP, GlobalNames.BHS_USER_TIMESTAMP_DIRECTORY_NAME, cmsDirectorysMenu);
                UpdateDirectories(tnUser, lsNames, BHS_KEYWORD_USER_QUEUE, GlobalNames.BHS_USER_QUEUE_DIRECTORY_NAME, cmsDirectorysMenu);
                UpdateDirectories(tnUser, lsNames, BHS_KEYWORD_USER_CONV, GlobalNames.BHS_USER_CONV_DIRECTORY_NAME, cmsDirectorysMenu);
                UpdateDirectories(tnUser, lsNames, BHS_KEYWORD_USER_SECURITY, GlobalNames.BHS_USER_SECU_DIRECTORY_NAME, cmsDirectorysMenu);
                UpdateDirectories(tnUser, lsNames, BHS_KEYWORD_USER_PASSPORT, GlobalNames.BHS_USER_PASS_DIRECTORY_NAME, cmsDirectorysMenu);
                UpdateDirectories(tnUser, lsNames, BHS_KEYWORD_USER_VEH, GlobalNames.BHS_USER_VEH_DIRECTORY_NAME, cmsDirectorysMenu);
                UpdateDirectories(tnUser, lsNames, BHS_KEYWORD_USER_WORKCENTER, GlobalNames.BHS_USER_WORKCENTER_DIRECTORY_NAME, cmsDirectorysMenu);
                UpdateDirectories(tnUser, lsNames, BHS_KEYWORD_USER_GATE, GlobalNames.BHS_USER_GATE_DIRECTORY_NAME, cmsDirectorysMenu);
                #endregion
                // << Task #13422 Keywords improvement
            }

            // >> Task #15088 Pax2Sim - BHS Analysis - Times and Indexes
            public const string ORIGINATING_TIMES_DIRECTORY_TAG = "Orig0Times";
            public const string TRANSFERRING_TIMES_DIRECTORY_TAG = "Transf0Times";
            public const string DEPARTING_TIMES_DIRECTORY_TAG = "Dep0Times";
            public static void GenerateDirectories_new(TreeNode tnRacine, List<String> lsNames, ContextMenuStrip cmsDirectorysMenu,
                List<AnalysisResultFilter> resultFilters, List<string> globalFlowTypes, Hashtable htMaxNbRecirc, bool generateMUPSegregation) // >> Task #14280 Bag Trace Loading time too long
            {
                if (tnRacine == null)
                    return;

                //<< New Objects - Task#7228
                #region Check for Sodexi objects
                bool allowCreationSodexiDirectory = false;
                bool hasADAreaObjects = false;
                bool hasAAAreaObjects = false;
                bool hasAAExportObjects = false;
                bool hasAAImportObjects = false;

                if (lsNames.Contains(sADCustomQueue) || lsNames.Contains(sADOOGQueue) || lsNames.Contains(sADOutputBuffer)
                    || lsNames.Contains(sADInputBuffer) || lsNames.Contains(sADBagsInUsed) || lsNames.Contains(sADPositionInUsed)
                    || lsNames.Contains(sADEarlyStorage) || lsNames.Contains(sADInfeed))
                    hasADAreaObjects = true;
                if (lsNames.Contains(sAAInputBuffer) || lsNames.Contains(sAAInfeed) || lsNames.Contains(sAAEarlyStorage)
                    || lsNames.Contains(sAAMUExport) || lsNames.Contains(sAAMUCloserHub) || lsNames.Contains(sAAMUVrac)
                    || lsNames.Contains(sAAMUULD) || lsNames.Contains(sAAExportG02Early))
                    hasAAExportObjects = true;
                if (lsNames.Contains(sAAImport) || lsNames.Contains(sAAImportPoste)
                    || lsNames.Contains(sAAImportPosteCHR) || lsNames.Contains(sAAImportPosteCYM))
                    hasAAImportObjects = true;

                if (hasAAImportObjects || hasAAExportObjects)
                    hasAAAreaObjects = true;
                if (hasAAAreaObjects || hasADAreaObjects)
                    allowCreationSodexiDirectory = true;
                #endregion
                //>> New Objects - Task#7228

                #region Les noeuds affichés à la racine.
                TreeNode tnTerminating = OverallTools.TreeViewFunctions.CreateDirectory("Terminating", cmsDirectorysMenu);
                TreeNode tnTransferring = OverallTools.TreeViewFunctions.CreateDirectory("Transferring", cmsDirectorysMenu);
                TreeNode tnOriginating = OverallTools.TreeViewFunctions.CreateDirectory("Originating", cmsDirectorysMenu);
                TreeNode tnDeparting = OverallTools.TreeViewFunctions.CreateDirectory("Departing", cmsDirectorysMenu);
                TreeNode tnUser = OverallTools.TreeViewFunctions.CreateDirectory(GlobalNames.BHS_USER_DIRECTORY_NAME, cmsDirectorysMenu);    // >> Task #13422 Keywords improvement
                TreeNode tnSodexiDirectory = null;
                tnRacine.Nodes.Add(tnTerminating);
                tnRacine.Nodes.Add(tnTransferring);
                tnRacine.Nodes.Add(tnOriginating);
                tnRacine.Nodes.Add(tnDeparting);
                tnRacine.Nodes.Add(tnUser);     // >> Task #13422 Keywords improvement

                if (allowCreationSodexiDirectory)
                {
                    tnSodexiDirectory = OverallTools.TreeViewFunctions.CreateDirectory("Sodexi", cmsDirectorysMenu);
                    tnRacine.Nodes.Add(tnSodexiDirectory);
                }

                // >> Task #13390 Targets for BHS Analysis output tables                
                String sTarget = GlobalNames.TARGET_DIRECTORY_NAME;
                TreeNode tnTarget = OverallTools.TreeViewFunctions.RechercherNomEnfants(sTarget, tnRacine);
                if (tnTarget == null)
                {
                    tnTarget = OverallTools.TreeViewFunctions.createBranch(sTarget, sTarget, TreeViewTag.getDirectoryNode(sTarget), null);
                    tnRacine.Nodes.Add(tnTarget);
                }
                // << Task #13390 Targets for BHS Analysis output tables

                UpdateDirectories(tnRacine, lsNames, sPersonalParking, "Car park", cmsDirectorysMenu);
                #endregion


                #region Les noeuds affichés dans le noeud Terminating
                TreeNode tnTime = OverallTools.TreeViewFunctions.CreateDirectory("Terminating", "_Times", cmsDirectorysMenu);
                TreeNode tnFromCollector = OverallTools.TreeViewFunctions.CreateDirectory("TermColl", "From Collector", cmsDirectorysMenu);
                TreeNode tnFromCI = OverallTools.TreeViewFunctions.CreateDirectory("TermCI", "From CheckIn", cmsDirectorysMenu);
                TreeNode tnFromQueue = OverallTools.TreeViewFunctions.CreateDirectory("Term", "From Queue", cmsDirectorysMenu);
                TreeNode tnArrivalQueues = OverallTools.TreeViewFunctions.CreateDirectory(TerminatingQueue, "Arrival Queues", cmsDirectorysMenu);
                TreeNode tnArrivalInfeed = OverallTools.TreeViewFunctions.CreateDirectory(TerminatingInfeed, "Arrival Infeed", cmsDirectorysMenu);
                TreeNode tnArrivalHBS = OverallTools.TreeViewFunctions.CreateDirectory(TerminatingHBS, "Arrival HBS", cmsDirectorysMenu);
                TreeNode tnArrivalCustom = OverallTools.TreeViewFunctions.CreateDirectory(TerminatingCustom, "Arrival Custom", cmsDirectorysMenu);
                TreeNode tnArrivalABS = OverallTools.TreeViewFunctions.CreateDirectory(TerminatingABS, "Arrival ABS", cmsDirectorysMenu);
                TreeNode tnArrivalReclaim = OverallTools.TreeViewFunctions.CreateDirectory(TerminatingReclaim, "Arrival Reclaim", cmsDirectorysMenu);
                TreeNode tnArrivalCollector = OverallTools.TreeViewFunctions.CreateDirectory(ArrivingCollector, "Arrival Collector", cmsDirectorysMenu);// >> Task #15087 Pax2Sim - BHS Analysis - Collector
                // << Task #7530 Analyze Bag Trace module - Recirculation statistics
                String directoryTagForColl = "TermCollRec";
                String directoryTagForCI = "TermCIRec";
                String directoryTagForNormal = "TermRec";
                TreeNode tnRecirculationTimes = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal, "Recirculation Times", cmsDirectorysMenu);
                tnFromQueue.Nodes.Add(tnRecirculationTimes);
                TreeNode tnRecirculationTimesCI = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI, "Recirculation Times", cmsDirectorysMenu);
                tnFromCI.Nodes.Add(tnRecirculationTimes);
                TreeNode tnRecirculationTimesColl = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl, "Recirculation Times", cmsDirectorysMenu);
                tnFromCollector.Nodes.Add(tnRecirculationTimesColl);

                TreeNode tnRecirculations = new TreeNode();
                int maxNbRecirc = 0;
                if (int.TryParse(htMaxNbRecirc[GlobalNames.maxNbOfRecirculationsTerm].ToString(), out maxNbRecirc))
                {
                    for (int i = 0; i <= maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForColl + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimesColl.Nodes.Add(tnRecirculations);
                    }
                    for (int i = 0; i <= maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForCI + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimesCI.Nodes.Add(tnRecirculations);
                    }
                    for (int i = 0; i <= maxNbRecirc; i++)
                    {
                        tnRecirculations = OverallTools.TreeViewFunctions.CreateDirectory(directoryTagForNormal + i, i + " Recirculation(s)", cmsDirectorysMenu);
                        tnRecirculationTimes.Nodes.Add(tnRecirculations);
                    }
                }
                // >> Task #7530 Analyze Bag Trace module - Recirculation statistics
                tnTerminating.Nodes.Add(tnTime);
                tnTime.Nodes.Add(tnFromQueue);
                //tnTime.Nodes.Add(tnFromCI);
                //tnTime.Nodes.Add(tnFromCollector);

                // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2
                TreeNode tnTermVSU = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_TERM_VSU, "VSU", cmsDirectorysMenu);
                TreeNode tnTermVMU = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_TERM_VMU, "VMU", cmsDirectorysMenu);
                TreeNode tnTermDivert = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_TERM_DIVERT, "Divert", cmsDirectorysMenu);
                TreeNode tnTermMerge = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_TERM_MERGE, "Merge", cmsDirectorysMenu);
                // << Task #10316 Pax2Sim - BHS - Presortation keyword C#2

                // >> Task #13422 Keywords improvement C#24
                TreeNode tnTermExit = OverallTools.TreeViewFunctions.CreateDirectory("Exit", "Exit", cmsDirectorysMenu);
                TreeNode tnTermExitOnTime = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_TERM_EXIT_ON_TIME, "Exit-OnTime", cmsDirectorysMenu);
                TreeNode tnTermExitEarly = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_TERM_EXIT_EARLY, "Exit-Early", cmsDirectorysMenu);
                TreeNode tnTermExitLate = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_TERM_EXIT_LATE, "Exit-Late", cmsDirectorysMenu);
                TreeNode tnTermExitRecirc = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_TERM_EXIT_RECIRC, "Exit-Recirculation", cmsDirectorysMenu);
                // << Task #13422 Keywords improvement C#24

                tnTerminating.Nodes.Add(tnArrivalQueues);
                tnTerminating.Nodes.Add(tnArrivalInfeed);
                tnTerminating.Nodes.Add(tnArrivalCollector);    // >> Task #15087 Pax2Sim - BHS Analysis - Collector
                tnTerminating.Nodes.Add(tnArrivalHBS);
                tnTerminating.Nodes.Add(tnArrivalCustom);
                if (!bDelhi)
                    tnTerminating.Nodes.Add(tnArrivalABS);
                tnTerminating.Nodes.Add(tnArrivalReclaim);

                if (!isOldVSUFormat) // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2
                {
                    if (stationTypesDictionary == null || stationTypesDictionary.Count == 0 || stationTypesDictionary.Keys == null || stationTypesDictionary.Keys.ToList() == null)
                    {
                        tnTerminating.Nodes.Add(tnTermVSU);
                        tnTerminating.Nodes.Add(tnTermVMU);
                        tnTerminating.Nodes.Add(tnTermDivert);
                        tnTerminating.Nodes.Add(tnTermMerge);
                    }
                    else
                    {
                        if (stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_TERM_VSU))
                        {
                            tnTerminating.Nodes.Add(tnTermVSU);
                        }
                        if (stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_TERM_VMU))
                        {
                            tnTerminating.Nodes.Add(tnTermVMU);
                        }
                        if (stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_TERM_DIVERT))
                        {
                            tnTerminating.Nodes.Add(tnTermDivert);
                        }
                        if (stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_TERM_MERGE))
                        {
                            tnTerminating.Nodes.Add(tnTermMerge);
                        }
                    }
                }
                // >> Task #13422 Keywords improvement C#24
                if (stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_TERM_EXIT_ON_TIME)
                    || stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_TERM_EXIT_EARLY)
                    || stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_TERM_EXIT_LATE)
                    || stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_TERM_EXIT_RECIRC))
                {
                    tnTerminating.Nodes.Add(tnTermExit);
                    tnTermExit.Nodes.Add(tnTermExitOnTime);
                    tnTermExit.Nodes.Add(tnTermExitEarly);
                    tnTermExit.Nodes.Add(tnTermExitLate);
                    tnTermExit.Nodes.Add(tnTermExitRecirc);
                }
                // << Task #13422 Keywords improvement C#24

                UpdateDirectories(tnTerminating, lsNames, sPersonalTermQueue, "Terminating Queue", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sPersonalTermConv, "Terminating Conveyor", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sPersonalTermVeh, "Terminating Vehicle", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sPersonalTermWorkCenter, "Terminating WorkCenter", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sPersonalArrGate, "Terminating Arrival Gate", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sPersonalTermTimeStamp, "Terminating TimeStamp", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sPersonalArrSecu, "Arriving Security", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sPersonalArrPass, "Arriving Passport", cmsDirectorysMenu);
                //<< New Objects - Task#7228
                UpdateDirectories(tnTerminating, lsNames, sTermStorage, "Terminating Storage", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sTermStorage1, "Terminating Storage 1", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sTermStorage2, "Terminating Storage 2", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sTermULDMUInUsed, "Terminating ULD MU InUsed", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sTermULDFullStorage, "Terminating ULD Full Storage", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sTermULDEmptyStorage, "Terminating ULD Empty Storage", cmsDirectorysMenu);

                UpdateDirectories(tnTerminating, lsNames, sTermSlugs, "Terminating Slugs", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sTermWindow, "Terminating Window", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sTermFlow, "Terminating Flow", cmsDirectorysMenu);
                //>> New Objects - Task#7228
                //<< New Objects(II) - Task#7367
                UpdateDirectories(tnTerminating, lsNames, sTermVSUInputDn, "Terminating VSU Input Dn", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sTermVSUInputUp, "Terminating VSU Input Up", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sTermVSUOutputDn, "Terminating VSU Output Dn", cmsDirectorysMenu);
                UpdateDirectories(tnTerminating, lsNames, sTermVSUOutputUp, "Terminating VSU Output Up", cmsDirectorysMenu);
                //>> New Objects(II) - Task#7367
                UpdateDirectories(tnTerminating, lsNames, BHS_TRACE_KEYWORD_TERM_PRESORT, "Terminating Presortation", cmsDirectorysMenu);   // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation
                #endregion

                #region Les noeuds affichés dans le noeud Transferring                
                TreeNode timesDirectory = OverallTools.TreeViewFunctions.CreateDirectory(TRANSFERRING_TIMES_DIRECTORY_TAG, "_Times", cmsDirectorysMenu);
                if (globalFlowTypes.Contains(AnalysisResultFilter.TRANSFERRING_FLOW_TYPE_VISUAL_NAME))
                {
                    tnTransferring.Nodes.Add(timesDirectory);
                    foreach (AnalysisResultFilter resultFilter in resultFilters)
                        GenerateSimpleFromToTimesSubDirectories(AnalysisResultFilter.TRANSFERRING_TECHNICAL_FLOW_TYPE, "Transf0", "Transf", resultFilter, timesDirectory, cmsDirectorysMenu);
                    if (generateMUPSegregation)
                    {
                        GenerateFromToTimesSubDirectoriesForMakeUpSegregation(AnalysisResultFilter.TRANSFERRING_TECHNICAL_FLOW_TYPE, "Transf0", "Transf", makeUpSGroupsDictionary, makeUpGroupWithDescriptionDictionary,
                            resultFilters, timesDirectory, cmsDirectorysMenu);
                    }
                }
                TreeNode tnTransferQueues = OverallTools.TreeViewFunctions.CreateDirectory(TransferringQueue, "Transfer Queues", cmsDirectorysMenu);
                TreeNode tnTransferInfeed = OverallTools.TreeViewFunctions.CreateDirectory(TransferringInfeed, "Transfer Infeed", cmsDirectorysMenu);
                TreeNode tnTransferringCollector = OverallTools.TreeViewFunctions.CreateDirectory(TransferringCollector, "Transfer Collector", cmsDirectorysMenu);  // >> Task #15087 Pax2Sim - BHS Analysis - Collector
                // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2
                TreeNode tnTransferVSU = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_TRANSFER_VSU, "VSU", cmsDirectorysMenu);
                TreeNode tnTransferVMU = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_TRANSFER_VMU, "VMU", cmsDirectorysMenu);
                TreeNode tnTransferDivert = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_TRANSFER_DIVERT, "Divert", cmsDirectorysMenu);
                TreeNode tnTransferMerge = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_TRANSFER_MERGE, "Merge", cmsDirectorysMenu);
                // << Task #10316 Pax2Sim - BHS - Presortation keyword C#2

                // >> Task #13422 Keywords improvement C#24
                TreeNode tnTransferExit = OverallTools.TreeViewFunctions.CreateDirectory("Exit", "Exit", cmsDirectorysMenu);
                TreeNode tnTransferExitOnTime = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_TRANSF_EXIT_ON_TIME, "Exit-OnTime", cmsDirectorysMenu);
                TreeNode tnTransferExitEarly = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_TRANSF_EXIT_EARLY, "Exit-Early", cmsDirectorysMenu);
                TreeNode tnTransferExitLate = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_TRANSF_EXIT_LATE, "Exit-Late", cmsDirectorysMenu);
                TreeNode tnTransferExitRecirc = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_TRANSF_EXIT_RECIRC, "Exit-Recirculation", cmsDirectorysMenu);
                // << Task #13422 Keywords improvement C#24

                tnTransferring.Nodes.Add(tnTransferQueues);
                tnTransferring.Nodes.Add(tnTransferInfeed);
                tnTransferring.Nodes.Add(tnTransferringCollector);  // >> Task #15087 Pax2Sim - BHS Analysis - Collector
                if (!isOldVSUFormat)    // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2
                {
                    if (stationTypesDictionary == null || stationTypesDictionary.Count == 0 || stationTypesDictionary.Keys == null || stationTypesDictionary.Keys.ToList() == null)
                    {
                        tnTransferring.Nodes.Add(tnTransferVSU);
                        tnTransferring.Nodes.Add(tnTransferVMU);
                        tnTransferring.Nodes.Add(tnTransferDivert);
                        tnTransferring.Nodes.Add(tnTransferMerge);
                    }
                    else
                    {
                        if (stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_TRANSFER_VSU))
                        {
                            tnTransferring.Nodes.Add(tnTransferVSU);
                        }
                        if (stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_TRANSFER_VMU))
                        {
                            tnTransferring.Nodes.Add(tnTransferVMU);
                        }
                        if (stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_TRANSFER_DIVERT))
                        {
                            tnTransferring.Nodes.Add(tnTransferDivert);
                        }
                        if (stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_TRANSFER_MERGE))
                        {
                            tnTransferring.Nodes.Add(tnTransferMerge);
                        }
                    }
                }
                // >> Task #13422 Keywords improvement C#24
                if (stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_TRANSF_EXIT_ON_TIME)
                    || stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_TRANSF_EXIT_EARLY)
                    || stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_TRANSF_EXIT_LATE)
                    || stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_TRANSF_EXIT_RECIRC))
                {
                    tnTransferring.Nodes.Add(tnTransferExit);
                    tnTransferExit.Nodes.Add(tnTransferExitOnTime);
                    tnTransferExit.Nodes.Add(tnTransferExitEarly);
                    tnTransferExit.Nodes.Add(tnTransferExitLate);
                    tnTransferExit.Nodes.Add(tnTransferExitRecirc);
                }
                // << Task #13422 Keywords improvement C#24

                UpdateDirectories(tnTransferring, lsNames, sPersonalTransfQueue, "Transferring Queue", cmsDirectorysMenu);
                UpdateDirectories(tnTransferring, lsNames, sPersonalTransfConv, "Transferring Conveyor", cmsDirectorysMenu);
                UpdateDirectories(tnTransferring, lsNames, sPersonalTransfVeh, "Transferring Vehicle", cmsDirectorysMenu);
                UpdateDirectories(tnTransferring, lsNames, sPersonalTransfWorkCenter, "Transferring WorkCenter", cmsDirectorysMenu);
                UpdateDirectories(tnTransferring, lsNames, sPersonalTransfTimeStamp, "Transferring TimeStamp", cmsDirectorysMenu);
                UpdateDirectories(tnTransferring, lsNames, sPersonalTrans, "Transfering Desk", cmsDirectorysMenu);
                //<< New Objects - Task#7228
                UpdateDirectories(tnTransferring, lsNames, sTransfStorage, "Transfering Storage", cmsDirectorysMenu);
                UpdateDirectories(tnTransferring, lsNames, sTransfStorage1, "Transfering Storage 1", cmsDirectorysMenu);
                UpdateDirectories(tnTransferring, lsNames, sTransfStorage2, "Transfering Storage 2", cmsDirectorysMenu);
                UpdateDirectories(tnTransferring, lsNames, sTransfULDMUInUsed, "Transfering ULD MU InUsed", cmsDirectorysMenu);
                UpdateDirectories(tnTransferring, lsNames, sTransfULDFullStorage, "Transfering ULD Full Storage", cmsDirectorysMenu);
                UpdateDirectories(tnTransferring, lsNames, sTransfULDEmptyStorage, "Transfering ULD Empty Storage", cmsDirectorysMenu);

                UpdateDirectories(tnTransferring, lsNames, sTransfSlugs, "Transfering Slugs", cmsDirectorysMenu);
                UpdateDirectories(tnTransferring, lsNames, sTransfWindow, "Transfering Window", cmsDirectorysMenu);
                UpdateDirectories(tnTransferring, lsNames, sTransfFlow, "Transfering Flow", cmsDirectorysMenu);
                //>> New Objects - Task#7228
                //<< New Objects(II) - Task#7367
                UpdateDirectories(tnTransferring, lsNames, sTransfVSUInputDn, "Transfering VSU Input Dn", cmsDirectorysMenu);
                UpdateDirectories(tnTransferring, lsNames, sTransfVSUInputUp, "Transfering VSU Input Up", cmsDirectorysMenu);
                UpdateDirectories(tnTransferring, lsNames, sTransfVSUOutputDn, "Transfering VSU Output Dn", cmsDirectorysMenu);
                UpdateDirectories(tnTransferring, lsNames, sTransfVSUOutputUp, "Transfering VSU Output Up", cmsDirectorysMenu);
                //>> New Objects(II) - Task#7367

                UpdateDirectories(tnTransferring, lsNames, BHS_TRACE_KEYWORD_TRANSF_PRESORT, "Transfering Presortation", cmsDirectorysMenu);   // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation
                #endregion

                #region Les noeuds affichés dans le noeud Originating
                timesDirectory = OverallTools.TreeViewFunctions.CreateDirectory(ORIGINATING_TIMES_DIRECTORY_TAG, "_Times", cmsDirectorysMenu);
                if (globalFlowTypes.Contains(AnalysisResultFilter.ORIGINATING_FLOW_TYPE_VISUAL_NAME))
                {
                    tnOriginating.Nodes.Add(timesDirectory);
                    foreach (AnalysisResultFilter resultFilter in resultFilters)
                        GenerateSimpleFromToTimesSubDirectories(AnalysisResultFilter.ORIGINATING_TECHNICAL_FLOW_TYPE, "Orig0", "Orig", resultFilter, timesDirectory, cmsDirectorysMenu);
                    if (generateMUPSegregation)
                    {
                        GenerateFromToTimesSubDirectoriesForMakeUpSegregation(AnalysisResultFilter.ORIGINATING_TECHNICAL_FLOW_TYPE, "Orig0", "Orig", makeUpSGroupsDictionary, makeUpGroupWithDescriptionDictionary,
                            resultFilters, timesDirectory, cmsDirectorysMenu);
                    }
                }

                TreeNode tnOriginatingCheckInQueues = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingQueue, "Check-In Queues", cmsDirectorysMenu);
                TreeNode tnOriginatingCheckIn = OverallTools.TreeViewFunctions.CreateDirectory(Originating, "Check-In", cmsDirectorysMenu);
                TreeNode tnOriginatingCheckInCollector = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingCollector, "Check-In Collectors", cmsDirectorysMenu);
                // >> _Times statistics - standard including MES
                // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2
                TreeNode tnOriginatingVSU = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_ORIG_VSU, "VSU", cmsDirectorysMenu);
                TreeNode tnOriginatingVMU = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_ORIG_VMU, "VMU", cmsDirectorysMenu);
                TreeNode tnOriginatingDivert = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_ORIG_DIVERT, "Divert", cmsDirectorysMenu);
                TreeNode tnOriginatingMerge = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_ORIG_MERGE, "Merge", cmsDirectorysMenu);
                // << Task #10316 Pax2Sim - BHS - Presortation keyword C#2

                // >> Task #13422 Keywords improvement C#24
                TreeNode tnOriginatingExit = OverallTools.TreeViewFunctions.CreateDirectory("Exit", "Exit", cmsDirectorysMenu);
                TreeNode tnOriginatingExitOnTime = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_ORIG_EXIT_ON_TIME, "Exit-OnTime", cmsDirectorysMenu);
                TreeNode tnOriginatingExitEarly = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_ORIG_EXIT_EARLY, "Exit-Early", cmsDirectorysMenu);
                TreeNode tnOriginatingExitLate = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_ORIG_EXIT_LATE, "Exit-Late", cmsDirectorysMenu);
                TreeNode tnOriginatingExitRecirc = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_ORIG_EXIT_RECIRC, "Exit-Recirculation", cmsDirectorysMenu);
                // << Task #13422 Keywords improvement C#24

                tnOriginating.Nodes.Add(tnOriginatingCheckInQueues);
                tnOriginating.Nodes.Add(tnOriginatingCheckIn);
                tnOriginating.Nodes.Add(tnOriginatingCheckInCollector);
                if (!isOldVSUFormat) // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2
                {
                    if (stationTypesDictionary == null || stationTypesDictionary.Count == 0 || stationTypesDictionary.Keys == null || stationTypesDictionary.Keys.ToList() == null)
                    {
                        tnOriginating.Nodes.Add(tnOriginatingVSU);
                        tnOriginating.Nodes.Add(tnOriginatingVMU);
                        tnOriginating.Nodes.Add(tnOriginatingDivert);
                        tnOriginating.Nodes.Add(tnOriginatingMerge);
                    }
                    else
                    {
                        if (stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_ORIG_VSU))
                        {
                            tnOriginating.Nodes.Add(tnOriginatingVSU);
                        }
                        if (stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_ORIG_VMU))
                        {
                            tnOriginating.Nodes.Add(tnOriginatingVMU);
                        }
                        if (stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_ORIG_DIVERT))
                        {
                            tnOriginating.Nodes.Add(tnOriginatingDivert);
                        }
                        if (stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_ORIG_MERGE))
                        {
                            tnOriginating.Nodes.Add(tnOriginatingMerge);
                        }
                    }
                }
                // >> Task #13422 Keywords improvement C#24
                if (stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_ORIG_EXIT_ON_TIME)
                    || stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_ORIG_EXIT_EARLY)
                    || stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_ORIG_EXIT_LATE)
                    || stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_ORIG_EXIT_RECIRC))
                {
                    tnOriginating.Nodes.Add(tnOriginatingExit);
                    tnOriginatingExit.Nodes.Add(tnOriginatingExitOnTime);
                    tnOriginatingExit.Nodes.Add(tnOriginatingExitEarly);
                    tnOriginatingExit.Nodes.Add(tnOriginatingExitLate);
                    tnOriginatingExit.Nodes.Add(tnOriginatingExitRecirc);
                }
                // << Task #13422 Keywords improvement C#24

                //if (generateMUPSegregation)
                //tnOriginating.Nodes.Add(tnOriginatingMU);
                UpdateDirectories(tnOriginating, lsNames, sPersonalOrigQueue, "Originating Queue", cmsDirectorysMenu);
                UpdateDirectories(tnOriginating, lsNames, sPersonalOrigConv, "Originating Conveyor", cmsDirectorysMenu);
                UpdateDirectories(tnOriginating, lsNames, sPersonalOrigVeh, "Originating Vehicle", cmsDirectorysMenu);
                UpdateDirectories(tnOriginating, lsNames, sPersonalOrigWorkCenter, "Originating WorkCenter", cmsDirectorysMenu);
                UpdateDirectories(tnOriginating, lsNames, sPersonalOrigTimeStamp, "Originating TimeStamp", cmsDirectorysMenu);
                //<< New Objects - Task#7228
                UpdateDirectories(tnOriginating, lsNames, sOrigStorage, "Originating Storage", cmsDirectorysMenu);
                UpdateDirectories(tnOriginating, lsNames, sOrigStorage1, "Originating Storage 1", cmsDirectorysMenu);
                UpdateDirectories(tnOriginating, lsNames, sOrigStorage2, "Originating Storage 2", cmsDirectorysMenu);
                UpdateDirectories(tnOriginating, lsNames, sOrigULDMUInUsed, "Originating ULD MU InUsed", cmsDirectorysMenu);
                UpdateDirectories(tnOriginating, lsNames, sOrigULDFullStorage, "Originating ULD Full Storage", cmsDirectorysMenu);
                UpdateDirectories(tnOriginating, lsNames, sOrigULDEmptyStorage, "Originating ULD Empty Storage", cmsDirectorysMenu);

                UpdateDirectories(tnOriginating, lsNames, sOrigSlugs, "Originating Slugs", cmsDirectorysMenu);
                UpdateDirectories(tnOriginating, lsNames, sOrigWindow, "Originating Window", cmsDirectorysMenu);
                UpdateDirectories(tnOriginating, lsNames, sOrigFlow, "Originating Flow", cmsDirectorysMenu);
                //>> New Objects - Task#7228
                //<< New Objects(II) - Task#7367
                UpdateDirectories(tnOriginating, lsNames, sOrigVSUInputDn, "Originating VSU Input Dn", cmsDirectorysMenu);
                UpdateDirectories(tnOriginating, lsNames, sOrigVSUInputUp, "Originating VSU Input Up", cmsDirectorysMenu);
                UpdateDirectories(tnOriginating, lsNames, sOrigVSUOutputDn, "Originating VSU Output Dn", cmsDirectorysMenu);
                UpdateDirectories(tnOriginating, lsNames, sOrigVSUOutputUp, "Originating VSU Output Up", cmsDirectorysMenu);
                //>> New Objects(II) - Task#7367

                UpdateDirectories(tnOriginating, lsNames, BHS_TRACE_KEYWORD_ORIG_PRESORT, "Originating Presortation", cmsDirectorysMenu);   // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation
                #endregion

                #region Les noeuds affichés dans le noeud Departing
                timesDirectory = OverallTools.TreeViewFunctions.CreateDirectory(DEPARTING_TIMES_DIRECTORY_TAG, "_Times", cmsDirectorysMenu);
                if (globalFlowTypes.Contains(AnalysisResultFilter.DEPARTING_FLOW_TYPE_VISUAL_NAME))
                {
                    tnDeparting.Nodes.Add(timesDirectory);
                    foreach (AnalysisResultFilter resultFilter in resultFilters)
                        GenerateSimpleFromToTimesSubDirectories(AnalysisResultFilter.DEPARTING_TECHNICAL_FLOW_TYPE, "Dep0", "Dep", resultFilter, timesDirectory, cmsDirectorysMenu);
                    if (generateMUPSegregation)
                    {
                        GenerateFromToTimesSubDirectoriesForMakeUpSegregation(AnalysisResultFilter.DEPARTING_TECHNICAL_FLOW_TYPE, "Dep0", "Dep", makeUpSGroupsDictionary, makeUpGroupWithDescriptionDictionary,
                            resultFilters, timesDirectory, cmsDirectorysMenu);
                    }
                }

                TreeNode tnDepartingHBS = OverallTools.TreeViewFunctions.CreateDirectory("HBS", cmsDirectorysMenu);
                TreeNode tnDepartingSorter = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferSorterName, cmsDirectorysMenu);
                TreeNode tnDepartingMES = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferMES, cmsDirectorysMenu);
                TreeNode tnDepartingEBS = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferEBS, cmsDirectorysMenu);
                TreeNode tnDepartingBuffer = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferBuffer, "Buffer", cmsDirectorysMenu);
                TreeNode tnDepartingMU = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferMU, "Make-Up", cmsDirectorysMenu);
                // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2
                TreeNode tnDepartingVSU = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_DEP_VSU, "VSU", cmsDirectorysMenu);
                TreeNode tnDepartingVMU = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_DEP_VMU, "VMU", cmsDirectorysMenu);
                TreeNode tnDepartingDivert = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_DEP_DIVERT, "Divert", cmsDirectorysMenu);
                TreeNode tnDepartingMerge = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_DEP_MERGE, "Merge", cmsDirectorysMenu);
                // << Task #10316 Pax2Sim - BHS - Presortation keyword C#2
                // >> Task #13422 Keywords improvement C#24
                TreeNode tnDepartingExit = OverallTools.TreeViewFunctions.CreateDirectory("Exit", "Exit", cmsDirectorysMenu);
                TreeNode tnDepartingExitOnTime = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_DEP_EXIT_ON_TIME, "Exit-OnTime", cmsDirectorysMenu);
                TreeNode tnDepartingExitEarly = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_DEP_EXIT_EARLY, "Exit-Early", cmsDirectorysMenu);
                TreeNode tnDepartingExitLate = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_DEP_EXIT_LATE, "Exit-Late", cmsDirectorysMenu);
                TreeNode tnDepartingExitRecirc = OverallTools.TreeViewFunctions.CreateDirectory(BHS_TRACE_KEYWORD_DEP_EXIT_RECIRC, "Exit-Recirculation", cmsDirectorysMenu);
                // << Task #13422 Keywords improvement C#24

                tnDeparting.Nodes.Add(tnDepartingHBS);
                tnDeparting.Nodes.Add(tnDepartingSorter);
                tnDeparting.Nodes.Add(tnDepartingMES);
                if (!isOldVSUFormat)    // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2
                {
                    if (stationTypesDictionary == null || stationTypesDictionary.Count == 0 || stationTypesDictionary.Keys == null || stationTypesDictionary.Keys.ToList() == null)
                    {
                        tnDeparting.Nodes.Add(tnDepartingVSU);
                        tnDeparting.Nodes.Add(tnDepartingVMU);
                        tnDeparting.Nodes.Add(tnDepartingDivert);
                        tnDeparting.Nodes.Add(tnDepartingMerge);
                    }
                    else
                    {
                        if (stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_DEP_VSU))
                        {
                            tnDeparting.Nodes.Add(tnDepartingVSU);
                        }
                        if (stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_DEP_VMU))
                        {
                            tnDeparting.Nodes.Add(tnDepartingVMU);
                        }
                        if (stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_DEP_DIVERT))
                        {
                            tnDeparting.Nodes.Add(tnDepartingDivert);
                        }
                        if (stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_DEP_MERGE))
                        {
                            tnDeparting.Nodes.Add(tnDepartingMerge);
                        }
                    }
                }
                // >> Task #13422 Keywords improvement C#24
                if (stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_DEP_EXIT_ON_TIME)
                    || stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_DEP_EXIT_EARLY)
                    || stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_DEP_EXIT_LATE)
                    || stationTypesDictionary.Keys.ToList().Contains(BHS_TRACE_KEYWORD_DEP_EXIT_RECIRC))
                {
                    tnDeparting.Nodes.Add(tnDepartingExit);
                    tnDepartingExit.Nodes.Add(tnDepartingExitOnTime);
                    tnDepartingExit.Nodes.Add(tnDepartingExitEarly);
                    tnDepartingExit.Nodes.Add(tnDepartingExitLate);
                    tnDepartingExit.Nodes.Add(tnDepartingExitRecirc);
                }
                // << Task #13422 Keywords improvement C#24

                if (!bDelhi)
                {
                    tnDeparting.Nodes.Add(tnDepartingEBS);
                    //<< New Objects(II) - Task#7367 
                    UpdateDirectories(tnDeparting, lsNames, sEBSToploader, "EBS Toploader", cmsDirectorysMenu);
                    UpdateDirectories(tnDeparting, lsNames, sEBSUnloader, "EBS Unloader", cmsDirectorysMenu);
                    //>> New Objects(II) - Task#7367
                }
                tnDeparting.Nodes.Add(tnDepartingBuffer);
                tnDeparting.Nodes.Add(tnDepartingMU);
                //tnDeparting.Nodes.Add(tnDepartingMakeUp); // ADPi Chute

                // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                TreeNode tnICS = OverallTools.TreeViewFunctions.CreateDirectory(sICS, cmsDirectorysMenu);
                tnDeparting.Nodes.Add(tnICS);

                TreeNode tnDepartingICSRecirculation = OverallTools.TreeViewFunctions.CreateDirectory(sICSRecirc, "ICSRecirculation", cmsDirectorysMenu);
                tnICS.Nodes.Add(tnDepartingICSRecirculation);

                string icsLoaderKeyword = sNewICSToploader;
                if (hasOldICSLoaderKeyword)
                    icsLoaderKeyword = sICSToploader;
                TreeNode tnICSToploader = OverallTools.TreeViewFunctions.CreateDirectory(icsLoaderKeyword, "ICS Loader", cmsDirectorysMenu);
                TreeNode tnICSUnloader = OverallTools.TreeViewFunctions.CreateDirectory(sICSUnloader, "ICS Unloader", cmsDirectorysMenu);

                if (hasICSKeyword && !hasICSLoaderOrToploaderKeyword) // >> #13391 IST Tables standardization - sorter occupation
                {
                    TreeNode tnDepartingNewICS = OverallTools.TreeViewFunctions.CreateDirectory(BHS_KEYWORD_ICS, cmsDirectorysMenu);
                    tnICS.Nodes.Add(tnDepartingNewICS);
                }
                else if (hasICSLoaderOrToploaderKeyword)
                    tnICS.Nodes.Add(tnICSToploader);

                tnICS.Nodes.Add(tnICSUnloader);

                // >> Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader                
                UpdateDirectories(tnDeparting, lsNames, sPersonalDepQueue, "Departing Queue", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sPersonalDepConv, "Departing Conveyor", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sPersonalDepVeh, "Departing Vehicle", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sPersonalDepWorkCenter, "Departing WorkCenter", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sPersonalDepTimeStamp, "Departing TimeStamp", cmsDirectorysMenu);

                UpdateDirectories(tnDeparting, lsNames, sDepReaderTimeStamp, "Departing Reader TimeStamp", cmsDirectorysMenu);  // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader

                UpdateDirectories(tnDeparting, lsNames, sPersonalDepGate, "Departing Gate", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sPersonalDepSecu, "Departing Security", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sPersonalDepPass, "Departing Passport", cmsDirectorysMenu);
                //<< New Objects - Task#7228
                UpdateDirectories(tnDeparting, lsNames, sDepStorage, "Departing Storage", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sDepStorage1, "Departing Storage 1", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sDepStorage2, "Departing Storage 2", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sDepULDMUInUsed, "Departing ULD MU InUsed", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sDepULDFullStorage, "Departing ULD Full Storage", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sDepULDEmptyStorage, "Departing ULD Empty Storage", cmsDirectorysMenu);

                UpdateDirectories(tnDeparting, lsNames, sDepSlugs, "Departing Slugs", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sDepWindow, "Departing Window", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sDepFlow, "Departing Flow", cmsDirectorysMenu);
                //>> New Objects - Task#7228

                //<< New Objects(II) - Task#7367
                UpdateDirectories(tnDeparting, lsNames, sDepVSUInputDn, "Departing VSU Input Dn", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sDepVSUInputUp, "Departing VSU Input Up", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sDepVSUOutputDn, "Departing VSU Output Dn", cmsDirectorysMenu);
                UpdateDirectories(tnDeparting, lsNames, sDepVSUOutputUp, "Departing VSU Output Up", cmsDirectorysMenu);
                //>> New Objects(II) - Task#7367

                UpdateDirectories(tnDeparting, lsNames, BHS_TRACE_KEYWORD_DEP_PRESORT, "Departing Presortation", cmsDirectorysMenu);   // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation                
                #endregion

                #region Les noeuds affichés dans le noeud HBS du noeud Departing
                TreeNode tnDepartingHBS1 = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferHBS1, "HBS1", cmsDirectorysMenu);
                TreeNode tnDepartingHBS2 = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferHBS2, "HBS2", cmsDirectorysMenu);
                TreeNode tnDepartingHBS3 = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferHBS3, "HBS3", cmsDirectorysMenu);
                TreeNode tnDepartingRecircHBS3 = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferRecirculationHBS3, "Recirculation", cmsDirectorysMenu);
                TreeNode tnDepartingHBS4;
                TreeNode tnDepartingHBS5;
                if (!bDelhi)
                {
                    tnDepartingHBS4 = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferHBS4, "HBS4", cmsDirectorysMenu);
                    tnDepartingHBS5 = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferHBS5, "HBS5", cmsDirectorysMenu);
                }
                else
                {
                    tnDepartingHBS4 = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferHBS4, "HBS3M", cmsDirectorysMenu);
                    tnDepartingHBS5 = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferHBS5, "HBS4", cmsDirectorysMenu);
                }

                tnDepartingHBS.Nodes.Add(tnDepartingHBS1);
                tnDepartingHBS.Nodes.Add(tnDepartingHBS2);
                tnDepartingHBS.Nodes.Add(tnDepartingHBS3);
                tnDepartingHBS3.Nodes.Add(tnDepartingRecircHBS3);
                tnDepartingHBS.Nodes.Add(tnDepartingHBS4);
                tnDepartingHBS.Nodes.Add(tnDepartingHBS5);
                #endregion

                #region Les noeuds affichés dans le noeud Sorter du noeud Departing
                TreeNode tnDepartingSorterInduction = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferSorterInduction, "Sorter Induction", cmsDirectorysMenu);
                TreeNode tnDepartingRecirculation = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferRecirculation, "Recirculation", cmsDirectorysMenu);
                TreeNode tnDepartingInterlink = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferInterLink, "Inter-Link", cmsDirectorysMenu);
                TreeNode tnDepartingChute = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferChute, "Chute", cmsDirectorysMenu);
                TreeNode tnDepartingPBC = OverallTools.TreeViewFunctions.CreateDirectory("PBC", cmsDirectorysMenu);
                TreeNode tnDepartingEarly = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferPBC_Early, "PBC-Early", cmsDirectorysMenu);
                TreeNode tnDepartingLate = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferPBC_Late, "PBC-Late", cmsDirectorysMenu);
                TreeNode tnDepartingRecirc = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferPBC_Recirc, "PBC-Recirculation", cmsDirectorysMenu);
                TreeNode tnDepartingTSA = OverallTools.TreeViewFunctions.CreateDirectory(OriginatingTransferPBC_TSA, "PBC-TSA", cmsDirectorysMenu);

                if (hasSorterKeyword) // >> #13391 IST Tables standardization - sorter occupation
                {
                    TreeNode tnDepartingNewSorter = OverallTools.TreeViewFunctions.CreateDirectory(BHS_KEYWORD_SORTER, cmsDirectorysMenu);
                    tnDepartingSorter.Nodes.Add(tnDepartingNewSorter);
                }
                if (hasSortIndKeyword)
                {
                    tnDepartingSorter.Nodes.Add(tnDepartingSorterInduction);
                }
                tnDepartingSorter.Nodes.Add(tnDepartingRecirculation);
                tnDepartingSorter.Nodes.Add(tnDepartingInterlink);
                tnDepartingSorter.Nodes.Add(tnDepartingChute);
                tnDepartingSorter.Nodes.Add(tnDepartingPBC);
                tnDepartingPBC.Nodes.Add(tnDepartingEarly);
                tnDepartingPBC.Nodes.Add(tnDepartingLate);
                tnDepartingPBC.Nodes.Add(tnDepartingRecirc);
                tnDepartingPBC.Nodes.Add(tnDepartingTSA);
                #endregion

                //<< New Objects - Task#7228
                #region Nodes shown in the Sodexi directory
                if (allowCreationSodexiDirectory && tnSodexiDirectory != null)
                {
                    TreeNode tnADArea = null;
                    if (hasADAreaObjects)
                        tnADArea = OverallTools.TreeViewFunctions.CreateDirectory("ADArea", "AD-Area", cmsDirectorysMenu);
                    TreeNode tnAAArea = null;
                    if (hasAAAreaObjects)
                        tnAAArea = OverallTools.TreeViewFunctions.CreateDirectory("AAArea", "AA-Area", cmsDirectorysMenu);
                    TreeNode tnAAExport = null;
                    if (hasAAExportObjects)
                        tnAAExport = OverallTools.TreeViewFunctions.CreateDirectory("AAExport", "AA-Export", cmsDirectorysMenu);
                    TreeNode tnAAImport = null;
                    if (hasAAImportObjects)
                        tnAAImport = OverallTools.TreeViewFunctions.CreateDirectory("AAImport", "AA-Import", cmsDirectorysMenu);
                    if (tnADArea != null)
                        tnSodexiDirectory.Nodes.Add(tnADArea);
                    if (tnAAArea != null)
                    {
                        if (tnAAExport != null)
                            tnAAArea.Nodes.Add(tnAAExport);
                        if (tnAAImport != null)
                            tnAAArea.Nodes.Add(tnAAImport);
                        tnSodexiDirectory.Nodes.Add(tnAAArea);
                    }

                    #region AD Area directory
                    if (hasADAreaObjects)
                    {
                        UpdateDirectories(tnADArea, lsNames, sADCustomQueue, "AD Custom Queue", cmsDirectorysMenu);
                        UpdateDirectories(tnADArea, lsNames, sADOOGQueue, "AD OOG Queue", cmsDirectorysMenu);
                        UpdateDirectories(tnADArea, lsNames, sADOutputBuffer, "AD Output Buffer", cmsDirectorysMenu);
                        UpdateDirectories(tnADArea, lsNames, sADInputBuffer, "AD Input Buffer", cmsDirectorysMenu);
                        UpdateDirectories(tnADArea, lsNames, sADBagsInUsed, "AD BagsInUsed", cmsDirectorysMenu);
                        UpdateDirectories(tnADArea, lsNames, sADPositionInUsed, "AD PositionInUse", cmsDirectorysMenu);
                        UpdateDirectories(tnADArea, lsNames, sADEarlyStorage, "AD Early Storage", cmsDirectorysMenu);
                        UpdateDirectories(tnADArea, lsNames, sADInfeed, "AD Infeed", cmsDirectorysMenu);
                    }
                    #endregion

                    #region AA Area directory
                    if (hasAAExportObjects)
                    {
                        UpdateDirectories(tnAAExport, lsNames, sAAInputBuffer, "AA Input Buffer", cmsDirectorysMenu);
                        UpdateDirectories(tnAAExport, lsNames, sAAInfeed, "AA Infeed", cmsDirectorysMenu);
                        UpdateDirectories(tnAAExport, lsNames, sAAEarlyStorage, "AA Early Storage", cmsDirectorysMenu);
                        UpdateDirectories(tnAAExport, lsNames, sAAMUExport, "AA MU Export", cmsDirectorysMenu);
                        UpdateDirectories(tnAAExport, lsNames, sAAMUCloserHub, "AA MU Closer Hub", cmsDirectorysMenu);
                        UpdateDirectories(tnAAExport, lsNames, sAAMUVrac, "AA MU Vrac", cmsDirectorysMenu);
                        UpdateDirectories(tnAAExport, lsNames, sAAMUULD, "AA MU ULD", cmsDirectorysMenu);
                        UpdateDirectories(tnAAExport, lsNames, sAAExportG02Early, "AA Export G02 Early", cmsDirectorysMenu);
                    }
                    if (hasAAImportObjects)
                    {
                        UpdateDirectories(tnAAImport, lsNames, sAAImport, "AA Import", cmsDirectorysMenu);
                        UpdateDirectories(tnAAImport, lsNames, sAAImportPoste, "AA Import Poste", cmsDirectorysMenu);
                        UpdateDirectories(tnAAImport, lsNames, sAAImportPosteCHR, "AA Import Poste CHR", cmsDirectorysMenu);
                        UpdateDirectories(tnAAImport, lsNames, sAAImportPosteCYM, "AA Import Poste CYM", cmsDirectorysMenu);
                    }
                    #endregion
                }
                #endregion
                //>> New Objects - Task#7228

                // >> Task #13422 Keywords improvement
                #region User directory
                UpdateDirectories(tnUser, lsNames, BHS_KEYWORD_USER_TIMESTAMP, GlobalNames.BHS_USER_TIMESTAMP_DIRECTORY_NAME, cmsDirectorysMenu);
                UpdateDirectories(tnUser, lsNames, BHS_KEYWORD_USER_QUEUE, GlobalNames.BHS_USER_QUEUE_DIRECTORY_NAME, cmsDirectorysMenu);
                UpdateDirectories(tnUser, lsNames, BHS_KEYWORD_USER_CONV, GlobalNames.BHS_USER_CONV_DIRECTORY_NAME, cmsDirectorysMenu);
                UpdateDirectories(tnUser, lsNames, BHS_KEYWORD_USER_SECURITY, GlobalNames.BHS_USER_SECU_DIRECTORY_NAME, cmsDirectorysMenu);
                UpdateDirectories(tnUser, lsNames, BHS_KEYWORD_USER_PASSPORT, GlobalNames.BHS_USER_PASS_DIRECTORY_NAME, cmsDirectorysMenu);
                UpdateDirectories(tnUser, lsNames, BHS_KEYWORD_USER_VEH, GlobalNames.BHS_USER_VEH_DIRECTORY_NAME, cmsDirectorysMenu);
                UpdateDirectories(tnUser, lsNames, BHS_KEYWORD_USER_WORKCENTER, GlobalNames.BHS_USER_WORKCENTER_DIRECTORY_NAME, cmsDirectorysMenu);
                UpdateDirectories(tnUser, lsNames, BHS_KEYWORD_USER_GATE, GlobalNames.BHS_USER_GATE_DIRECTORY_NAME, cmsDirectorysMenu);
                #endregion
                // << Task #13422 Keywords improvement
            }

            public static void GenerateSimpleFromToTimesSubDirectories(string flowType, string analysisTypeName, string analysisTypeShortName,
                AnalysisResultFilter resultFilter, TreeNode parentNode, ContextMenuStrip cmsDirectorysMenu)
            {
                if (resultFilter.flowType != flowType)
                    return;
                //check if from/to station type belongs to the flow type station type list. if any doesn't belong - return
                if (!resultFilter.belongsToTechnicalFlowType(flowType))
                    return;

                if (resultFilter.isCustomFilter())
                {
                    string customFilterTag = ANALYSIS_NAME_STATION_TYPES_SEPARATOR + resultFilter.filterName.Replace("_", "");
                    analysisTypeName = analysisTypeName + customFilterTag;
                    analysisTypeShortName = analysisTypeShortName + customFilterTag;
                }
                if (resultFilter.fromStationCode == FROMTO_ENTRY_STATION_CODE
                    && resultFilter.toStationCode == FROMTO_EXIT_STATION_CODE)
                {
                    addFromEntryToExitSubdirectory(flowType, analysisTypeName, analysisTypeShortName, resultFilter, parentNode, false, "", cmsDirectorysMenu);
                }
                else if (resultFilter.fromStationCode == FROMTO_ENTRY_STATION_CODE)
                    addFromEntrySubdirectory(flowType, analysisTypeName, analysisTypeShortName, resultFilter, parentNode, false, "", cmsDirectorysMenu);
                else if (resultFilter.toStationCode == FROMTO_EXIT_STATION_CODE)
                    addToExitSubdirectory(flowType, analysisTypeName, analysisTypeShortName, resultFilter, parentNode, false, "", cmsDirectorysMenu);
                else
                {
                    GenerateFromToTimesSubDirectories(flowType, analysisTypeShortName, resultFilter,
                        resultFilter.fromStationCode, resultFilter.toStationCode, parentNode, false, "", cmsDirectorysMenu);
                }
            }

            private static void addFromEntryToExitSubdirectory(string flowType, string analysisTypeName, string analysisTypeShortName,
                AnalysisResultFilter resultFilter, TreeNode parentNode, bool generateMupSegregation, string mupSegrKey,
                ContextMenuStrip cmsDirectorysMenu)
            {
                string fromEntryExitTimesDirectoryTag = analysisTypeName + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + FROMTO_ENTRY_STATION_CODE + FROMTO_EXIT_STATION_CODE
                    + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + FROMTO_ENTRY_STATION_CODE + FROMTO_EXIT_STATION_CODE;
                if (mupSegrKey != "")
                    fromEntryExitTimesDirectoryTag = fromEntryExitTimesDirectoryTag + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + mupSegrKey;

                string routeDirectoryText = "From Entry^ To Exit^";
                if (resultFilter.isCustomFilter())
                {
                    string routeDirectoryTextFilterNameSuffix = " (" + resultFilter.filterName + ")";
                    routeDirectoryText += routeDirectoryTextFilterNameSuffix;
                }
                TreeNode fromEntryExitTimesDirectory = OverallTools.TreeViewFunctions
                    .CreateDirectory(fromEntryExitTimesDirectoryTag, routeDirectoryText, cmsDirectorysMenu);
                parentNode.Nodes.Add(fromEntryExitTimesDirectory);

                string childDirectoryTag = analysisTypeShortName + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + FROMTO_ENTRY_STATION_CODE + FROMTO_EXIT_STATION_CODE;
                foreach (AnalysisResultFilter childFilter in resultFilter.fromEntryToExitChildFilters)
                {
                    //check if from/to station type belongs to the flow type station type list. if any doesn't belong - return
                    if (childFilter.belongsToTechnicalFlowType(flowType))
                    {
                        GenerateFromToTimesSubDirectories(flowType, childDirectoryTag, childFilter,
                            childFilter.fromStationCode, childFilter.toStationCode, fromEntryExitTimesDirectory, generateMupSegregation, mupSegrKey, cmsDirectorysMenu);
                    }
                }
            }

            private static void addFromEntrySubdirectory(string flowType, string analysisTypeName, string analysisTypeShortName,
                AnalysisResultFilter resultFilter, TreeNode parentNode, bool generateMupSegregation, string mupSegrKey,
                ContextMenuStrip cmsDirectorysMenu)
            {
                string fromEntryTimesDirectoryTag = analysisTypeName + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + FROMTO_ENTRY_STATION_CODE + resultFilter.toStationCode
                    + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + FROMTO_ENTRY_STATION_CODE + resultFilter.toStationCode;
                if (mupSegrKey != "")
                    fromEntryTimesDirectoryTag = fromEntryTimesDirectoryTag + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + mupSegrKey;

                string routeDirectoryText = "From Entry^ To " + resultFilter.toStationCode;

                if (resultFilter.isCustomFilter())
                {
                    string routeDirectoryTextFilterNameSuffix = " (" + resultFilter.filterName + ")";
                    routeDirectoryText += routeDirectoryTextFilterNameSuffix;
                }

                TreeNode fromEntryTimesDirectory = OverallTools.TreeViewFunctions
                    .CreateDirectory(fromEntryTimesDirectoryTag, routeDirectoryText, cmsDirectorysMenu);
                parentNode.Nodes.Add(fromEntryTimesDirectory);

                string childDirectoryTag = analysisTypeShortName + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + FROMTO_ENTRY_STATION_CODE + resultFilter.toStationCode;
                foreach (AnalysisResultFilter childFilter in resultFilter.fromEntryChildFilters)
                {
                    //check if from/to station type belongs to the flow type station type list. if any doesn't belong - return
                    if (childFilter.belongsToTechnicalFlowType(flowType))
                    {
                        GenerateFromToTimesSubDirectories(flowType, childDirectoryTag, childFilter,
                            childFilter.fromStationCode, childFilter.toStationCode, fromEntryTimesDirectory, generateMupSegregation, mupSegrKey, cmsDirectorysMenu);
                    }
                }
            }

            private static void addToExitSubdirectory(string flowType, string analysisTypeName, string analysisTypeShortName,
                AnalysisResultFilter resultFilter, TreeNode parentNode, bool generateMupSegregation, string mupSegrKey,
                ContextMenuStrip cmsDirectorysMenu)
            {


                string fromExitTimesDirectoryTag = analysisTypeName + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + resultFilter.fromStationCode + FROMTO_EXIT_STATION_CODE
                    + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + resultFilter.fromStationCode + FROMTO_EXIT_STATION_CODE;
                if (mupSegrKey != "")
                    fromExitTimesDirectoryTag = fromExitTimesDirectoryTag + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + mupSegrKey;


                string routeDirectoryText = "From " + resultFilter.fromStationCode + " To Exit^";

                if (resultFilter.isCustomFilter())
                {
                    string routeDirectoryTextFilterNameSuffix = " (" + resultFilter.filterName + ")";
                    routeDirectoryText += routeDirectoryTextFilterNameSuffix;
                }

                TreeNode fromExitTimesDirectory = OverallTools.TreeViewFunctions
                    .CreateDirectory(fromExitTimesDirectoryTag, routeDirectoryText, cmsDirectorysMenu);
                parentNode.Nodes.Add(fromExitTimesDirectory);

                string childDirectoryTag = analysisTypeShortName + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + resultFilter.fromStationCode + FROMTO_EXIT_STATION_CODE;

                foreach (AnalysisResultFilter childFilter in resultFilter.toExitChildFilters)
                {
                    //check if from/to station type belongs to the flow type station type list. if any doesn't belong - return
                    if (childFilter.belongsToTechnicalFlowType(flowType))
                    {
                        GenerateFromToTimesSubDirectories(flowType, childDirectoryTag, childFilter,
                            childFilter.fromStationCode, childFilter.toStationCode, fromExitTimesDirectory, generateMupSegregation, mupSegrKey, cmsDirectorysMenu);
                    }
                }
            }

            /// <summary>
            /// 
            /// </summary>
            /// <param name="analysisTypeName">Departing, Originating, Transferring</param>
            /// <param name="analysisTypeShortName">Dep, Orig, Transf</param>
            /// <param name="parentNode">tnDeparting, tnOriginating, ...</param>
            /// <param name="tnRacine"></param>
            /// <param name="lsNames"></param>
            /// <param name="cmsDirectorysMenu"></param>
            /// <param name="htMaxNbRecirc"></param>
            /// <param name="generateMUPSegregation"></param>
            public static void GenerateFromToTimesSubDirectories(string flowType, string analysisTypeShortName,
                AnalysisResultFilter resultFilter, string fromStationCode, string toStationCode, TreeNode parentNode,
                bool generateMupSegregation, string mupSegrKey, ContextMenuStrip cmsDirectorysMenu)
            {
                string fromCode = switchSpecialStationCodeByFlowType(flowType, fromStationCode);
                string toCode = switchSpecialStationCodeByFlowType(flowType, toStationCode);

                string routeDirectoryTag = analysisTypeShortName + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + fromCode + toCode;

                if (generateMupSegregation)
                    routeDirectoryTag = routeDirectoryTag + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + mupSegrKey;

                string routeDirectoryText = "From " + fromStationCode + " To " + toStationCode;
                if (resultFilter.isCustomFilter())
                {
                    string routeDirectoryTextFilterNameSuffix = " (" + resultFilter.filterName + ")";
                    routeDirectoryText += routeDirectoryTextFilterNameSuffix;
                }

                TreeNode routeDirectory = OverallTools.TreeViewFunctions.CreateDirectory(routeDirectoryTag, routeDirectoryText, cmsDirectorysMenu);
                parentNode.Nodes.Add(routeDirectory);

                if (resultFilter.withRecirculation && resultFilter.displayParameter != null)
                {
                    string recirculationDirectoryTag = routeDirectoryTag + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + RECIRCULATION_PREFFIX_PART;
                    TreeNode recirculationMainDirectory = OverallTools.TreeViewFunctions
                        .CreateDirectory(recirculationDirectoryTag, "Recirculation Times", cmsDirectorysMenu);
                    routeDirectory.Nodes.Add(recirculationMainDirectory);
                    for (int i = 0; i <= resultFilter.displayParameter.maxNbRecirculations; i++)
                    {
                        string recirculationChildDirectoryTag = recirculationDirectoryTag + i;
                        TreeNode recirculationChildNode = OverallTools.TreeViewFunctions
                            .CreateDirectory(recirculationChildDirectoryTag, i + " Recirculation(s)", cmsDirectorysMenu);
                        recirculationMainDirectory.Nodes.Add(recirculationChildNode);
                    }
                }
                if ((resultFilter.withFromSegregation || resultFilter.withToSegregation)
                    && resultFilter.displayParameter != null)
                {
                    string segregationDirectoryTag = routeDirectoryTag + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + LINE_SEGR_PREFFIX_PART;
                    TreeNode segregationMainDirectory = OverallTools.TreeViewFunctions
                        .CreateDirectory(segregationDirectoryTag, "Segregation By Line", cmsDirectorysMenu);
                    routeDirectory.Nodes.Add(segregationMainDirectory);
                    for (int i = 0; i < resultFilter.displayParameter.segregationLineNumbers.Count; i++)
                    {
                        int segregationLine = resultFilter.displayParameter.segregationLineNumbers[i];
                        string segregationChildDirectoryTag = segregationDirectoryTag + segregationLine;
                        TreeNode segregationChildDirectory = OverallTools.TreeViewFunctions
                            .CreateDirectory(segregationChildDirectoryTag, "Line " + segregationLine, cmsDirectorysMenu);
                        segregationMainDirectory.Nodes.Add(segregationChildDirectory);
                    }
                }
            }

            public static void GenerateFromToTimesSubDirectoriesForMakeUpSegregation(string flowType, string analysisTypeName, string analysisTypeShortName,
                Dictionary<string, List<int>> makeUpSGroupsDictionary, Dictionary<string, string> makeUpGroupWithDescriptionDictionary,
                List<AnalysisResultFilter> resultFilters, TreeNode timesDirectory, ContextMenuStrip cmsDirectorysMenu)
            {
                foreach (string key in makeUpSGroupsDictionary.Keys)
                {
                    string makeupGroupDescription = "";
                    if (makeUpGroupWithDescriptionDictionary.ContainsKey(key))
                        makeupGroupDescription = makeUpGroupWithDescriptionDictionary[key];

                    TreeNode tnMakeupGroupTime = OverallTools.TreeViewFunctions
                        .CreateDirectory(analysisTypeName + key, "_Times " + key + "(" + makeupGroupDescription + ")", cmsDirectorysMenu);
                    timesDirectory.Nodes.Add(tnMakeupGroupTime);
                    foreach (AnalysisResultFilter resultFilter in resultFilters)
                    {
                        if (resultFilter.flowType != flowType)
                            continue;
                        //check if from/to station type belongs to the flow type station type list. if any doesn't belong - continue
                        if (!resultFilter.belongsToTechnicalFlowType(flowType))
                            continue;

                        string analysisTypeNameByFilter = analysisTypeName;
                        string analysisTypeShortNameByFilter = analysisTypeShortName;
                        if (resultFilter.isCustomFilter())
                        {
                            string customFilterTag = ANALYSIS_NAME_STATION_TYPES_SEPARATOR + resultFilter.filterName.Replace("_", "");
                            analysisTypeNameByFilter = analysisTypeNameByFilter + customFilterTag;
                            analysisTypeShortNameByFilter = analysisTypeShortNameByFilter + customFilterTag;
                        }
                        if (resultFilter.fromStationCode == FROMTO_ENTRY_STATION_CODE
                            && resultFilter.toStationCode == FROMTO_EXIT_STATION_CODE)
                        {
                            addFromEntryToExitSubdirectory(flowType, analysisTypeNameByFilter, analysisTypeShortNameByFilter, resultFilter, tnMakeupGroupTime, true, key, cmsDirectorysMenu);
                        }
                        else if (resultFilter.fromStationCode == FROMTO_ENTRY_STATION_CODE)
                            addFromEntrySubdirectory(flowType, analysisTypeNameByFilter, analysisTypeShortNameByFilter, resultFilter, tnMakeupGroupTime, true, key, cmsDirectorysMenu);
                        else if (resultFilter.toStationCode == FROMTO_EXIT_STATION_CODE)
                            addToExitSubdirectory(flowType, analysisTypeNameByFilter, analysisTypeShortNameByFilter, resultFilter, tnMakeupGroupTime, true, key, cmsDirectorysMenu);
                        else
                        {
                            GenerateFromToTimesSubDirectories(flowType, analysisTypeShortNameByFilter, resultFilter,
                                resultFilter.fromStationCode, resultFilter.toStationCode, tnMakeupGroupTime, true, key, cmsDirectorysMenu);
                        }
                    }
                }
            }
            // << Task #15088 Pax2Sim - BHS Analysis - Times and Indexes
            #endregion

            #region Les différentes variables de la classe.

            private ParamScenario scenarioParameters;   // >> Task #19522

            private String sScenarioName;
            /// <summary>
            /// Le nom du fichier bagtrace.
            /// </summary>
            private String sFileName;


            #region //SGE-26/03/2012-Begin
            /// <summary>
            /// This is the trace that needs to be analysed. instead of being saved on the disk. The trace is coming
            /// directly from another classe.
            /// </summary>
            List<String> lsTraceToAnalyse;
            #endregion //SGE-26/03/2012-End

            /// <summary>
            /// Le Warm up utilisée pour la simulation (à appliquer sur les résultats).
            /// </summary>
            private Double warmUpInMinutes;

            /// <summary>
            /// La liste des erreurs qui ont pu apparaitre durant l'analyse du BagTrace
            /// </summary>
            internal ArrayList alErrorList;

            /// <summary>
            /// Hastable contenant les résultats de la simulation pour chaque station
            /// contient des StationResult.
            /// </summary>
            SortedDictionary<String, StationResult> htStation;  // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard (sortedDictionary instead of normal dictionary)

            /// <summary>
            /// Hastable contenant les résultats de la simulation pour chaque bagage en arrivée
            /// contient des TerminatingResult.
            /// </summary>
            Dictionary<Int32, BaggageResult> htTerminating;
            /// <summary>
            /// Hastable contenant les résultats de la simulation pour chaque bagage en arrivée
            /// contient des OriginatingResult.
            /// </summary>
            Dictionary<Int32, BaggageResult> htOriginating;
            /// <summary>
            /// Hastable contenant les résultats de la simulation pour chaque bagage en arrivée
            /// contient des TransferringResult.
            /// </summary>
            Dictionary<Int32, BaggageResult> htTransferring;

            /// <summary>
            /// Hastable contenant les résultats de la simulation pour chaque véhicule ayant séjourné dans un parking.
            /// </summary>
            Dictionary<Int32, BaggageResult> htParkingResult;

            Dictionary<int, BaggageResult> htUserResult;   // >> Task #13422 Keywords improvement

            // >> Bag trace data collecting
            /// <summary>
            /// K = station name
            /// V = BhsStation - name, type, terminal, group and station indexes
            /// </summary>
            Dictionary<string, BhsStation> stationsDictionary;

            /// <summary>
            /// K = station type
            /// V = list of all stations of that type
            /// </summary>
            internal static Dictionary<string, List<BhsStation>> stationTypesDictionary;
            // << Bag trace data collecting

            private Double dFirstLevelPercent;
            private Double dSecondLevelPercent;
            private Double dThirdLevelPercent;

            private List<String> lsNames;
            internal List<String> Names
            {
                get
                {
                    if (lsNames == null)
                        lsNames = new List<string>();
                    return lsNames;
                }
            }
            #endregion


            #region Classes utilisées pour les résultats présents dans le bagTrace

            #region BaggageDesk
            private class BaggageDesk
            {
                private String sName;
                private Double dEnter;
                private Double dLeave;
                private Double dTravelTime;
                private bool bUniqueTime;
                // >> Task #13422 Keywords improvement
                private int terminalIndex;
                private int groupIndex;
                // << Task #13422 Keywords improvement
                private Int32 iIndex;

                #region Accesseurs
                public String DeskName
                {
                    get
                    {
                        return sName;
                    }
                }
                public Double ArrivingTime
                {
                    get
                    {
                        return dEnter;
                    }
                }
                public Double LeavingTime
                {
                    get
                    {
                        return dLeave;
                    }
                    set
                    {
                        if (!bUniqueTime)
                            dLeave = value;
                    }
                }
                public String DeskType
                {
                    get
                    {
                        if (sName.Length == 0)
                            return "";
                        return (sName.Split('_'))[0];
                    }
                }
                // >> Task #13422 Keywords improvement
                public int TerminalIndex
                {
                    get
                    {
                        if (terminalIndex != -1)
                        {
                            return terminalIndex;
                        }
                        string[] nameSplittedByUnderscoreList
                            = sName.Split(new char[] { '_' }, StringSplitOptions.RemoveEmptyEntries);

                        if (nameSplittedByUnderscoreList.Length == 4)
                        {
                            Int32.TryParse(nameSplittedByUnderscoreList[1], out terminalIndex);
                        }
                        return terminalIndex;
                    }
                }

                public int GroupIndex
                {
                    get
                    {
                        if (groupIndex != -1)
                        {
                            return groupIndex;
                        }
                        string[] nameSplittedByUnderscoreList
                            = sName.Split(new char[] { '_' }, StringSplitOptions.RemoveEmptyEntries);

                        if (nameSplittedByUnderscoreList.Length == 3)
                        {
                            Int32.TryParse(nameSplittedByUnderscoreList[1], out groupIndex);
                        }
                        else if (nameSplittedByUnderscoreList.Length == 4)
                        {
                            Int32.TryParse(nameSplittedByUnderscoreList[2], out groupIndex);
                        }
                        return groupIndex;
                    }
                }
                // << Task #13422 Keywords improvement
                public Int32 DeskIndex
                {
                    get
                    {
                        if (iIndex != -1)
                            return iIndex;
                        String[] sData = sName.Split(new char[] { '_' }, StringSplitOptions.RemoveEmptyEntries);
                        if (sData.Length <= 1)
                            return -1;

                        if (!Int32.TryParse(sData[sData.Length - 1], out iIndex))
                            return -1;
                        return iIndex;
                    }
                }
                public Double TotalTime
                {
                    get
                    {
                        return (dLeave - dEnter);
                    }
                }
                public Double TravelTime
                {
                    get
                    {
                        return dTravelTime;
                    }
                    set
                    {
                        dTravelTime = value;
                    }
                }
                public bool UniqueTime
                {
                    get
                    {
                        return bUniqueTime;
                    }
                }
                #endregion

                #region Constructeurs
                public static BaggageDesk getBaggageDesk(String Name, String Enter, String Leave)
                {
                    if ((Name == null) || (Enter == null) || (Leave == null))
                        return null;
                    if ((Name.Length == 0) || (Enter.Length == 0) || (Leave.Length == 0))
                        return null;
                    Double dEnter_, dLeave_;
                    if (!Double.TryParse(Enter, out dEnter_))
                        return null;
                    if (!Double.TryParse(Leave, out dLeave_))
                        return null;
                    return new BaggageDesk(Name, dEnter_, dLeave_);
                }
                public static BaggageDesk getBaggageDesk(String Name, String Enter, Double Leave)
                {
                    if ((Name == null) || (Enter == null))
                        return null;
                    if ((Name.Length == 0) || (Enter.Length == 0))
                        return null;
                    Double dEnter_;
                    if (!Double.TryParse(Enter, out dEnter_))
                        return null;
                    return new BaggageDesk(Name, dEnter_, Leave);
                }
                private BaggageDesk(String Name, Double Enter, Double Leave)
                {
                    iIndex = -1;
                    groupIndex = -1;
                    terminalIndex = -1;
                    sName = Name;
                    dEnter = Enter;
                    dLeave = Leave;
                    if (dLeave == -1)
                    {
                        bUniqueTime = true;
                        dLeave = dEnter;
                    }
                }
                #endregion

                public override string ToString()
                {
                    return sName + ": Arriving minute: " + dEnter + " Leaving minute: " + dLeave;
                }

            }
            #endregion

            #region BaggageResult
            private class BaggageResult
            {
                /// <summary>
                /// Identifiant du bagage
                /// </summary>
                protected int iIDBag;
                /// <summary>
                /// Identifiant du passager
                /// </summary>
                protected int iIDPax;
                /// <summary>
                /// Identifiant du vol.
                /// </summary>
                protected int iIDFlight;
                /// <summary>
                /// Heure de départ prévue du vol.
                /// </summary>
                protected double dSTD;
                /// <summary>
                /// Nombre de recirculation.
                /// </summary>
                protected int iRecirculation;
                /// <summary>
                /// Interconnection entre les différents trieurs 
                /// </summary>
                protected int iInterLink;
                /// <summary>
                /// Booléen permettant de savoir si le colis a été stoppé à la fin de la simulation sans avoir atteint
                /// son objectif.
                /// </summary>
                protected bool bStopped;

                int iPrk;
                public List<BaggageDesk> alBaggageWay;
                protected String sLine;

                #region Accesseurs

                public int IDBag
                {
                    get
                    {
                        return iIDBag;
                    }
                }
                public int FlightID
                {
                    get
                    {
                        return iIDFlight;
                    }
                }
                public double STD
                {
                    get
                    {
                        return dSTD;
                    }
                }
                public Double arrivingMinuteAtFirstStation
                {
                    get
                    {
                        if (alBaggageWay.Count == 0)
                            return 0;
                        return alBaggageWay[0].ArrivingTime;
                    }
                }
                public double leavingMinuteFromFirstStation
                {
                    get
                    {
                        if (alBaggageWay.Count == 0)
                            return 0;
                        return alBaggageWay[0].LeavingTime;
                    }
                }

                protected BaggageDesk GetResults(int iIndex)
                {
                    if (iIndex < 0)
                        return null;
                    if (iIndex >= alBaggageWay.Count)
                        return null;
                    return alBaggageWay[iIndex];
                }

                public virtual Double LeavingSystemTime
                {
                    get
                    {
                        if ((alBaggageWay == null) || (alBaggageWay.Count == 0))
                            return 0;
                        return ((BaggageDesk)alBaggageWay[alBaggageWay.Count - 1]).LeavingTime;
                    }
                }
                public double arrivingMinuteAtLastStation
                {
                    get
                    {
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return -1;
                        BaggageDesk lastStation = (BaggageDesk)alBaggageWay[alBaggageWay.Count - 1];
                        if (lastStation == null)
                            return -1;
                        return lastStation.ArrivingTime;
                    }
                }
                public double leavingMinuteFromLastStation
                {
                    get
                    {
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return -1;
                        BaggageDesk lastStation = (BaggageDesk)alBaggageWay[alBaggageWay.Count - 1];
                        if (lastStation == null)
                            return -1;
                        return lastStation.LeavingTime;
                    }
                }

                // << Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                public virtual Double LeavingTimeFromLastChute
                {
                    get
                    {
                        if ((alBaggageWay == null) || (alBaggageWay.Count == 0))
                            return 0;
                        double lastChuteLeavingTime = 0;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingTransferChute)
                                if (lastChuteLeavingTime < baggageDesk.LeavingTime)
                                    lastChuteLeavingTime = baggageDesk.LeavingTime;
                        }
                        return lastChuteLeavingTime;
                    }
                }
                public virtual Double TotalTimeWhenLeavingLastChute
                {
                    get
                    {
                        if ((alBaggageWay == null) || (alBaggageWay.Count == 0))
                            return 0;
                        Double dArriving = arrivingMinuteAtFirstStation;
                        Double dLeavingTimeFromChute = LeavingTimeFromLastChute;
                        return dLeavingTimeFromChute - dArriving;
                    }
                }
                // >> Task #8223 Pax2Sim - BHS mode - baggs IST statistic change

                // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                public virtual Double LeavingTimeFromReaderTimeStamp
                {
                    get
                    {
                        if ((alBaggageWay == null) || (alBaggageWay.Count == 0))
                            return 0;
                        double readerTimeStampLeavingTime = 0;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sDepReaderTimeStamp)
                                readerTimeStampLeavingTime = baggageDesk.LeavingTime;
                        }
                        return readerTimeStampLeavingTime;
                    }
                }

                public virtual Double TotalTimeWhenLeavingReaderTimeStamp
                {
                    get
                    {
                        if ((alBaggageWay == null) || (alBaggageWay.Count == 0))
                            return 0;
                        return LeavingTimeFromReaderTimeStamp - arrivingMinuteAtFirstStation;
                    }
                }
                // >> Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader

                public virtual Double TotalTime
                {
                    get
                    {
                        if ((alBaggageWay == null) || (alBaggageWay.Count == 0))
                            return 0;
                        Double dArriving = arrivingMinuteAtFirstStation;
                        Double dLeaving = LeavingSystemTime;
                        return dLeaving - dArriving;
                    }
                }
                public virtual Double TotalSimulationTime
                {
                    get
                    {
                        return TotalTime;
                    }
                }
                // << Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                public virtual Double TotalSimulationTimeWhenLeavingChute
                {
                    get
                    {
                        return TotalTimeWhenLeavingLastChute;
                    }
                }
                // >> Task #8223 Pax2Sim - BHS mode - baggs IST statistic change                                
                public bool Stopped
                {
                    get
                    {
                        return bStopped;
                    }
                    set
                    {
                        bStopped = value;
                    }
                }
                // << Task #7527 Summaries correction
                public int IDPax
                {
                    get
                    {
                        return iIDPax;
                    }
                }

                public int Recirculation
                {
                    get
                    {
                        return iRecirculation;
                    }
                }
                // >> Task #7527 Summaries correction
                #endregion

                #region Constructeur
                /// <summary>
                /// Constructeur de la classe de résultat d'un bagage.
                /// </summary>
                /// <param name="IDBag">Identificant du bagage</param>
                /// <param name="IDFlight">Identifiant du vol.</param>
                /// <param name="STD">Heure de départ</param>
                /// <param name="Recirculation">Nombre de recirculation</param>
                /// <param name="InterLink">Information d'interlink</param>
                public BaggageResult(int IDBag, int IDPax, int IDFlight, double STD, int Recirculation, int InterLink)
                {
                    iIDBag = IDBag;
                    iIDPax = IDPax;
                    iIDFlight = IDFlight;
                    dSTD = STD;
                    iRecirculation = Recirculation;
                    iInterLink = InterLink;
                    alBaggageWay = new List<BaggageDesk>();
                    bStopped = false;
                    iPrk = -1;
                }
                #endregion

                #region public override void AddBaggageWay(BaggageDesk bdDesk)
                /// <summary>
                /// Fonction qui ajoute à la statistique du bagage les postes pas lesquels il est passé.
                /// </summary>
                /// <param name="bdDesk">L'information sur le poste.</param>
                public virtual void AddBaggageWay(BaggageDesk bdDesk)
                {
                    alBaggageWay.Add(bdDesk);               // >> Task #17603 PAX2SIM - BHS mode - Consecutive stations on a trace line with the same type         
                    /*  commented because of // >> Task #17603 PAX2SIM - BHS mode - Consecutive stations on a trace line with the same type
                    if ((alBaggageWay.Count > 0) &&
                        (alBaggageWay[alBaggageWay.Count - 1].DeskName == bdDesk.DeskName))
                    {
                        alBaggageWay[alBaggageWay.Count - 1].LeavingTime = bdDesk.LeavingTime;
                    }
                    else if (bdDesk.DeskType == sPersonalParking)
                        iPrk = alBaggageWay.Count - 1;
                    else
                    {
                        alBaggageWay.Add(bdDesk);
                    }*/
                }
                #endregion

                public virtual DateTime GetTimeAtQueue(DateTime dtBegin)
                {
                    return dtBegin.AddMinutes(arrivingMinuteAtFirstStation);
                }
            }

            class TerminatingResult : BaggageResult
            {
                private int iHBSIndex;
                private int iCustIndex;
                private int iInfeedIndex;
                private int iReclaimIndex;
                private int iABSIndex;

                private int iTermQIndex;
                private int iTermConvIndex;
                private int iTermVehIndex;
                private int iTermWCIndex;
                private int iTermGateIndex;
                private int iTermTStampIndex;

                // >> Task #15087 Pax2Sim - BHS Analysis - Collector
                /// <summary>
                /// Desk index is the 2nd index: ArrColl_1_2 is the desk nb 2.
                /// </summary>
                public Int32 arrivingCollectorDeskIndex
                {
                    get
                    {
                        foreach (BaggageDesk bd in alBaggageWay)
                        {
                            if (bd.DeskType == ArrivingCollector)
                                return bd.DeskIndex;
                        }
                        return -1;
                    }
                }

                /// <summary>
                /// Group index is the 1st index: ArrColl_1_2 belongs to Group 1.
                /// </summary>
                public Int32 arrivingCollectorGroupIndex
                {
                    get
                    {
                        foreach (BaggageDesk bd in alBaggageWay)
                        {
                            if (bd.DeskType == ArrivingCollector)
                                return bd.GroupIndex;
                        }
                        return -1;
                    }
                }
                // << Task #15087 Pax2Sim - BHS Analysis - Collector

                #region Accesseurs

                public bool HasInfeed
                {
                    get
                    {
                        return (iInfeedIndex != -1);
                    }
                }

                public bool HasHBS
                {
                    get
                    {
                        return (iHBSIndex != -1);
                    }

                }
                public BaggageDesk HBS
                {
                    get
                    {
                        if (iHBSIndex == -1)
                            return null;
                        return (BaggageDesk)alBaggageWay[iHBSIndex];
                    }
                }

                public bool HasCustom
                {
                    get
                    {
                        return (iCustIndex != -1);
                    }

                }
                public BaggageDesk Custom
                {
                    get
                    {
                        if (iCustIndex == -1)
                            return null;
                        return (BaggageDesk)alBaggageWay[iCustIndex];
                    }
                }

                public bool HasABS
                {
                    get
                    {
                        return (iABSIndex != -1);
                    }

                }
                public BaggageDesk ABS
                {
                    get
                    {
                        if (iABSIndex == -1)
                            return null;
                        return (BaggageDesk)alBaggageWay[iABSIndex];
                    }
                }
                public Double ArrivingInfeedTime
                {
                    get
                    {
                        if (iInfeedIndex != -1)
                            return GetResults(iInfeedIndex).LeavingTime;
                        return arrivingMinuteAtFirstStation;
                    }
                }
                public double arrivingMinuteAtInfeed
                {
                    get
                    {
                        if (iInfeedIndex != -1)
                            return GetResults(iInfeedIndex).ArrivingTime;
                        return arrivingMinuteAtFirstStation;
                    }
                }
                public override Double TotalSimulationTime
                {
                    get
                    {
                        if ((iInfeedIndex == -1) || (iReclaimIndex == -1))
                            return 0;
                        return GetResults(iReclaimIndex).LeavingTime - ArrivingInfeedTime;
                    }
                }
                public Double ABSTime
                {
                    get
                    {
                        if (!HasABS)
                            return 0;
                        return GetResults(iABSIndex).TotalTime;
                    }
                }

                public Int32 InfeedIndex
                {
                    get
                    {
                        foreach (BaggageDesk bd in alBaggageWay)
                        {
                            if (bd.DeskType == TerminatingInfeed)
                            {
                                return bd.DeskIndex;
                            }
                        }
                        return 0;
                    }
                }
                public Int32 ReclaimIndex
                {
                    get
                    {
                        foreach (BaggageDesk bd in alBaggageWay)
                        {
                            if (bd.DeskType == TerminatingReclaim)
                            {
                                return bd.DeskIndex;
                            }
                        }
                        return 0;
                    }
                }
                // << Task #7527 Summaries correction
                public bool isContainer
                {
                    get
                    {
                        foreach (BaggageDesk bd in alBaggageWay)
                        {
                            if (bd.DeskName.Contains("-ULD-"))
                            {
                                return true;
                            }
                        }
                        return false;
                    }
                }

                public int nbRecirculation
                {
                    get { return Recirculation; }
                }
                // >> Task #7527 Summaries correction

                // >> Task #10877 Pax2Sim - BHS analysis - local IST tables for all the objects
                #region Terminating (what was missing)
                public Int32 terminatingQueueDeskIndex
                {
                    get
                    {
                        Int32 terminatingQueueIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return terminatingQueueIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == TerminatingQueue)
                            {
                                terminatingQueueIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return terminatingQueueIndex;
                    }
                }
                public Int32 terminatingHBSDeskIndex
                {
                    get
                    {
                        Int32 terminatingHBSIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return terminatingHBSIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == TerminatingHBS)
                            {
                                terminatingHBSIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return terminatingHBSIndex;
                    }
                }
                public Int32 terminatingCustomDeskIndex
                {
                    get
                    {
                        Int32 terminatingCustomIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return terminatingCustomIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == TerminatingCustom)
                            {
                                terminatingCustomIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return terminatingCustomIndex;
                    }
                }
                public Int32 terminatingABSDeskIndex
                {
                    get
                    {
                        Int32 terminatingABSIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return terminatingABSIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == TerminatingABS)
                            {
                                terminatingABSIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return terminatingABSIndex;
                    }
                }

                public Int32 personalTermQueueDeskIndex
                {
                    get
                    {
                        Int32 personalTermQueueIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalTermQueueIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalTermQueue)
                            {
                                personalTermQueueIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalTermQueueIndex;
                    }
                }

                public Int32 termStorageDeskIndex
                {
                    get
                    {
                        Int32 termStorageIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return termStorageIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTermStorage)
                            {
                                termStorageIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return termStorageIndex;
                    }
                }

                public Int32 termStorage1DeskIndex
                {
                    get
                    {
                        Int32 termStorage1Index = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return termStorage1Index;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTermStorage1)
                            {
                                termStorage1Index = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return termStorage1Index;
                    }
                }

                public Int32 termStorage2DeskIndex
                {
                    get
                    {
                        Int32 termStorage2Index = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return termStorage2Index;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTermStorage2)
                            {
                                termStorage2Index = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return termStorage2Index;
                    }
                }

                public Int32 termULDMUInUsedDeskIndex
                {
                    get
                    {
                        Int32 termULDMUInUseIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return termULDMUInUseIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTermULDMUInUsed)
                            {
                                termULDMUInUseIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return termULDMUInUseIndex;
                    }
                }

                public Int32 termULDEmptyStorageDeskIndex
                {
                    get
                    {
                        Int32 termULDEmptyStorageIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return termULDEmptyStorageIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTermULDEmptyStorage)
                            {
                                termULDEmptyStorageIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return termULDEmptyStorageIndex;
                    }
                }

                public Int32 termULDFullStorageDeskIndex
                {
                    get
                    {
                        Int32 termULDFullStorageIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return termULDFullStorageIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTermULDFullStorage)
                            {
                                termULDFullStorageIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return termULDFullStorageIndex;
                    }
                }

                public Int32 termSlugsDeskIndex
                {
                    get
                    {
                        Int32 termSlugsIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return termSlugsIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTermSlugs)
                            {
                                termSlugsIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return termSlugsIndex;
                    }
                }

                public Int32 termWindowDeskIndex
                {
                    get
                    {
                        Int32 termWindowIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return termWindowIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTermWindow)
                            {
                                termWindowIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return termWindowIndex;
                    }
                }

                public Int32 termFlowDeskIndex
                {
                    get
                    {
                        Int32 termFlowIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return termFlowIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTermFlow)
                            {
                                termFlowIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return termFlowIndex;
                    }
                }

                public Int32 termVSUInputDnDeskIndex
                {
                    get
                    {
                        Int32 termVSUInputDnIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return termVSUInputDnIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTermVSUInputDn)
                            {
                                termVSUInputDnIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return termVSUInputDnIndex;
                    }
                }
                public Int32 termVSUInputUpDeskIndex
                {
                    get
                    {
                        Int32 termVSUInputUpIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return termVSUInputUpIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTermVSUInputUp)
                            {
                                termVSUInputUpIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return termVSUInputUpIndex;
                    }
                }
                public Int32 termVSUOutputDnDeskIndex
                {
                    get
                    {
                        Int32 termVSUOutputDnIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return termVSUOutputDnIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTermVSUOutputDn)
                            {
                                termVSUOutputDnIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return termVSUOutputDnIndex;
                    }
                }
                public Int32 termVSUOutputUpDeskIndex
                {
                    get
                    {
                        Int32 termVSUOutputUpIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return termVSUOutputUpIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTermVSUOutputUp)
                            {
                                termVSUOutputUpIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return termVSUOutputUpIndex;
                    }
                }

                public Int32 personalTermTimeStampDeskIndex
                {
                    get
                    {
                        Int32 personalTermTimeStampIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalTermTimeStampIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalTermTimeStamp)
                            {
                                personalTermTimeStampIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalTermTimeStampIndex;
                    }
                }

                public Int32 personalTermConvDeskIndex
                {
                    get
                    {
                        Int32 personalTermConvIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalTermConvIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalTermConv)
                            {
                                personalTermConvIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalTermConvIndex;
                    }
                }

                public Int32 personalTermVehDeskIndex
                {
                    get
                    {
                        Int32 personalTermVehIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalTermVehIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalTermVeh)
                            {
                                personalTermVehIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalTermVehIndex;
                    }
                }

                public Int32 personalTermWorkCenterDeskIndex
                {
                    get
                    {
                        Int32 personalTermWorkCenterIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalTermWorkCenterIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalTermWorkCenter)
                            {
                                personalTermWorkCenterIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalTermWorkCenterIndex;
                    }
                }

                public Int32 personalTermSecuDeskIndex
                {
                    get
                    {
                        Int32 personalSecuCenterIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalSecuCenterIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalArrSecu)
                            {
                                personalSecuCenterIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalSecuCenterIndex;
                    }
                }

                public Int32 personalTermPassDeskIndex
                {
                    get
                    {
                        Int32 personalTermPassCenterIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalTermPassCenterIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalArrPass)
                            {
                                personalTermPassCenterIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalTermPassCenterIndex;
                    }
                }

                public Int32 personalTermGateDeskIndex
                {
                    get
                    {
                        Int32 personalTermGateCenterIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalTermGateCenterIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalArrGate)
                            {
                                personalTermGateCenterIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalTermGateCenterIndex;
                    }
                }
                #endregion                
                // << Task #10877 Pax2Sim - BHS analysis - local IST tables for all the objects

                // >> Task #15087 Pax2Sim - BHS Analysis - Collector
                public double getArrivingMinuteAtArrivingCollector()
                {
                    double arrivingMinute = -1;
                    if (alBaggageWay == null || alBaggageWay.Count == 0)
                        return arrivingMinute;
                    foreach (BaggageDesk desk in alBaggageWay)
                    {
                        if (desk.DeskType == ArrivingCollector)
                            arrivingMinute = desk.ArrivingTime;
                    }
                    return arrivingMinute;
                }
                public double getLeavingMinuteFromArrivingCollector()
                {
                    double leavingMinute = -1;
                    if (alBaggageWay == null || alBaggageWay.Count == 0)
                        return leavingMinute;
                    foreach (BaggageDesk desk in alBaggageWay)
                    {
                        if (desk.DeskType == ArrivingCollector)
                            leavingMinute = desk.LeavingTime;
                    }
                    return leavingMinute;
                }

                public DateTime getArrivingDateAtArrivingCollector(DateTime dtBegin)
                {
                    DateTime arrivingDate = DateTime.MinValue;
                    double arrivingMinute = getArrivingMinuteAtArrivingCollector();
                    if (arrivingMinute != -1)
                        arrivingDate = dtBegin.AddMinutes(arrivingMinute);
                    return arrivingDate;
                }
                public DateTime getLeavingDateFromArrivingCollector(DateTime dtBegin)
                {
                    DateTime leavingDate = DateTime.MinValue;
                    double leavingMinute = getLeavingMinuteFromArrivingCollector();
                    if (leavingMinute != -1)
                        leavingDate = dtBegin.AddMinutes(leavingMinute);
                    return leavingDate;
                }
                // << Task #15087 Pax2Sim - BHS Analysis - Collector
                #endregion

                #region Constructeurs
                public TerminatingResult(int IDBag, int IDPax, int IDFlight, double STD, int Recirculation, int InterLink)
                    : base(IDBag, IDPax, IDFlight, STD, Recirculation, InterLink)
                {
                    iHBSIndex = -1;
                    iCustIndex = -1;
                    iInfeedIndex = -1;
                    iReclaimIndex = -1;
                    iABSIndex = -1;

                    iTermQIndex = -1;
                    iTermConvIndex = -1;
                    iTermVehIndex = -1;
                    iTermWCIndex = -1;
                    iTermGateIndex = -1;
                    iTermTStampIndex = -1;

                }
                #endregion

                #region public override void AddBaggageWay(BaggageDesk bdDesk)
                public override void AddBaggageWay(BaggageDesk bdDesk)
                {
                    base.AddBaggageWay(bdDesk);
                    if (bdDesk.DeskType == TerminatingInfeed)
                        iInfeedIndex = alBaggageWay.Count - 1;
                    else if (bdDesk.DeskType == TerminatingHBS)
                        iHBSIndex = alBaggageWay.Count - 1;
                    else if (bdDesk.DeskType == TerminatingCustom)
                        iCustIndex = alBaggageWay.Count - 1;
                    else if (bdDesk.DeskType == TerminatingReclaim)
                        iReclaimIndex = alBaggageWay.Count - 1;
                    else if (bdDesk.DeskType == TerminatingABS)
                        iABSIndex = alBaggageWay.Count - 1;
                    else if (bdDesk.DeskType == sPersonalTermQueue)
                        iTermQIndex = alBaggageWay.Count - 1;
                    else if (bdDesk.DeskType == sPersonalTermConv)
                        iTermConvIndex = alBaggageWay.Count - 1;
                    else if (bdDesk.DeskType == sPersonalTermVeh)
                        iTermVehIndex = alBaggageWay.Count - 1;
                    else if (bdDesk.DeskType == sPersonalTermWorkCenter)
                        iTermWCIndex = alBaggageWay.Count - 1;
                    else if (bdDesk.DeskType == sPersonalArrGate)
                        iTermGateIndex = alBaggageWay.Count - 1;
                    else if (bdDesk.DeskType == sPersonalTermTimeStamp)
                        iTermTStampIndex = alBaggageWay.Count - 1;
                }
                #endregion
                public DateTime GetTimeAtInfeed(DateTime dtBegin)
                {
                    return dtBegin.AddMinutes(ArrivingInfeedTime);
                }

                // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation
                public List<int> presortationDeskIndexes
                {
                    get
                    {
                        List<int> deskIndexes = new List<int>();
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return deskIndexes;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == BHS_TRACE_KEYWORD_TERM_PRESORT)
                            {
                                if (!deskIndexes.Contains(baggageDesk.DeskIndex))
                                {
                                    deskIndexes.Add(baggageDesk.DeskIndex);
                                }
                            }
                        }
                        return deskIndexes;
                    }
                }

                public List<string> presortationIdentifiers
                {
                    get
                    {
                        List<string> identifiers = new List<string>();
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return identifiers;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == BHS_TRACE_KEYWORD_TERM_PRESORT)
                            {
                                string identifier = baggageDesk.GroupIndex + "_" + baggageDesk.DeskIndex;
                                if (!identifiers.Contains(identifier))
                                {
                                    identifiers.Add(identifier);
                                }
                            }
                        }
                        return identifiers;
                    }
                }

                public double firstPresortationArrivingMinute
                {
                    get
                    {
                        double minute = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return minute;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == BHS_TRACE_KEYWORD_TERM_PRESORT)
                            {
                                minute = baggageDesk.ArrivingTime;
                                break;
                            }
                        }
                        return minute;
                    }
                }

                public DateTime getFirstPresortationArrivingTime(DateTime dtBegin)
                {
                    if (firstPresortationArrivingMinute != -1)
                        return dtBegin.AddMinutes(firstPresortationArrivingMinute);
                    return DateTime.MinValue;
                }

                public double lastPresortationLeavingMinute
                {
                    get
                    {
                        double minute = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return minute;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == BHS_TRACE_KEYWORD_TERM_PRESORT)
                            {
                                minute = baggageDesk.LeavingTime;
                            }
                        }
                        return minute;
                    }
                }

                public DateTime getLastPresortationLeavingTime(DateTime dtBegin)
                {
                    if (lastPresortationLeavingMinute != -1)
                        return dtBegin.AddMinutes(lastPresortationLeavingMinute);
                    return DateTime.MinValue;
                }
                // << Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation
            }

            class DepartingResult : BaggageResult
            {
                /// <summary>
                /// Index du point d'entree (CI ou TrIF)
                /// </summary>
                protected int iInfeedIndex;
                /// <summary>
                /// Index du point de sortie (MU)
                /// </summary>
                protected int iMUIndex;

                // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                protected int depReaderTimestampBagWayListIndex;
                protected int icsToploaderBagWayListIndex;
                protected int icsUnloaderBagWayListIndex;
                // >> Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader

                protected int iBuffer;
                /// <summary>
                /// Some simulation can send several times the same bagage in the EBS area.
                /// </summary>
                protected List<Int32> liEBSIndex;
                protected int iHBS1;
                protected int iHBS2;
                protected int iHBS3;
                protected int iHBS4;
                protected int iHBS5;
                protected int iMES;
                protected int iChute;
                protected int iInterlink;
                private int iDepQIndex;
                private int iDepConvIndex;
                private int iDepVehIndex;
                private int iDepWCIndex;
                private int iDepGateIndex;
                private int iDepTSIndex;
                protected int iPBC;
                protected string _pbcStationType;
                #region Accesseurs

                public bool HasInfeed
                {
                    get
                    {
                        return (iInfeedIndex != -1);
                    }
                }
                public bool HasHBS1
                {
                    get
                    {
                        return (iHBS1 != -1);
                    }
                }
                public bool HasHBS2
                {
                    get
                    {
                        return (iHBS2 != -1);
                    }
                }
                public bool HasHBS3
                {
                    get
                    {
                        return (iHBS3 != -1);
                    }
                }
                public bool HasHBS4
                {
                    get
                    {
                        return (iHBS4 != -1);
                    }
                }
                public bool HasHBS5
                {
                    get
                    {
                        return (iHBS5 != -1);
                    }
                }

                public bool HasMES
                {
                    get
                    {
                        return (iMES != -1);
                    }
                }
                public bool HasEBS
                {
                    get
                    {
                        return (liEBSIndex.Count != 0);
                    }
                }
                public bool HasInterLink
                {
                    get
                    {
                        return (iInterlink != -1);
                    }
                }
                public bool HasPBC
                {
                    get { return iPBC != -1; }
                }


                public Double EBSTime
                {
                    get
                    {
                        if (!HasEBS)
                            return 0;
                        Double dResult = 0;
                        foreach (int iEBSIndex in liEBSIndex)
                            dResult += GetResults(iEBSIndex).TotalTime;
                        return dResult;
                    }
                }

                public Double ArrivingInfeedTime
                {
                    get
                    {
                        if (iInfeedIndex != -1)
                            return GetResults(iInfeedIndex).LeavingTime;
                        return GetResults(0).ArrivingTime;
                    }
                }

                public double arrivingMinuteAtInfeed
                {
                    get
                    {
                        if (iInfeedIndex != -1)
                            return GetResults(iInfeedIndex).ArrivingTime;
                        return GetResults(0).ArrivingTime;
                    }
                }

                // >> #13391 IST Tables standardization - IST - CI times columns
                public Double CI_Arriving_Minute
                {
                    get
                    {
                        if ((alBaggageWay == null) || (alBaggageWay.Count == 0))
                            return -1;
                        double ciArrivingTime = -1;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == Originating)
                                ciArrivingTime = baggageDesk.ArrivingTime;
                        }
                        return ciArrivingTime;
                    }
                }
                public Double CI_Leaving_Minute
                {
                    get
                    {
                        if ((alBaggageWay == null) || (alBaggageWay.Count == 0))
                            return -1;
                        double ciLeavingTime = -1;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == Originating)
                                ciLeavingTime = baggageDesk.LeavingTime;
                        }
                        return ciLeavingTime;
                    }
                }

                // >> Task #15042 Pax2Sim - BHS Analysis - new EBS stats
                /// <summary>
                /// Queue is considered one of the following trace objects: CIQ, TrQ, Orig-Queue, Transf-Queue, Dep-Queue.
                /// </summary>
                public double queueLeavingTime
                {
                    get
                    {
                        double queueLeavingTime = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return queueLeavingTime;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingQueue || baggageDesk.DeskType == TransferringQueue
                                || baggageDesk.DeskType == sPersonalOrigQueue || baggageDesk.DeskType == sPersonalTransfQueue
                                || baggageDesk.DeskType == sPersonalDepQueue)
                            {
                                queueLeavingTime = baggageDesk.LeavingTime;
                            }
                        }
                        return queueLeavingTime;
                    }
                }

                public double checkInQueueLeavingMinute
                {
                    get
                    {
                        double queueLeavingTime = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return queueLeavingTime;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingQueue)
                                queueLeavingTime = baggageDesk.LeavingTime;
                        }
                        return queueLeavingTime;
                    }
                }

                public double transferQueueLeavingMinute
                {
                    get
                    {
                        double queueLeavingTime = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return queueLeavingTime;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == TransferringQueue)
                                queueLeavingTime = baggageDesk.LeavingTime;
                        }
                        return queueLeavingTime;
                    }
                }

                public double queueArrivingTime
                {
                    get
                    {
                        double queueArrivingTime = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return queueArrivingTime;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingQueue || baggageDesk.DeskType == TransferringQueue
                                || baggageDesk.DeskType == sPersonalOrigQueue || baggageDesk.DeskType == sPersonalTransfQueue
                                || baggageDesk.DeskType == sPersonalDepQueue)
                            {
                                queueArrivingTime = baggageDesk.ArrivingTime;
                            }
                        }
                        return queueArrivingTime;
                    }
                }

                public double checkInQueueArrivingMinute
                {
                    get
                    {
                        double queueArrivingTime = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return queueArrivingTime;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingQueue)
                                queueArrivingTime = baggageDesk.ArrivingTime;
                        }
                        return queueArrivingTime;
                    }
                }

                public double transferQueueArrivingMinute
                {
                    get
                    {
                        double queueArrivingTime = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return queueArrivingTime;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == TransferringQueue)
                                queueArrivingTime = baggageDesk.ArrivingTime;
                        }
                        return queueArrivingTime;
                    }
                }

                public double checkInCollectorArrivingMinute
                {
                    get
                    {
                        double collectorArrivingTime = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return collectorArrivingTime;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingCollector)
                                collectorArrivingTime = baggageDesk.ArrivingTime;
                        }
                        return collectorArrivingTime;
                    }
                }

                public double checkInCollectorLeavingMinute
                {
                    get
                    {
                        double collectorLeavingTime = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return collectorLeavingTime;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingCollector)
                                collectorLeavingTime = baggageDesk.LeavingTime;
                        }
                        return collectorLeavingTime;
                    }
                }

                public DateTime checkInCollectorArrivingDate(DateTime dtBegin)
                {
                    if (checkInCollectorArrivingMinute != -1)
                        return dtBegin.AddMinutes(checkInCollectorArrivingMinute);
                    return DateTime.MinValue;
                }

                public DateTime checkInCollectorLeavingDate(DateTime dtBegin)
                {
                    if (checkInCollectorLeavingMinute != -1)
                        return dtBegin.AddMinutes(checkInCollectorLeavingMinute);
                    return DateTime.MinValue;
                }

                /// <summary>
                /// deprecated
                /// </summary>
                public double collectorArrivingMinute
                {
                    get
                    {
                        double collectorArrivingTime = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return collectorArrivingTime;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingCollector
                                || baggageDesk.DeskType == TransferringInfeed)
                            {
                                collectorArrivingTime = baggageDesk.ArrivingTime;
                            }
                        }
                        return collectorArrivingTime;
                    }
                }

                public double transferCollectorArrivingMinute
                {
                    get
                    {
                        double collectorArrivingTime = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return collectorArrivingTime;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == TransferringCollector)
                                collectorArrivingTime = baggageDesk.ArrivingTime;
                        }
                        return collectorArrivingTime;
                    }
                }
                public double transferCollectorLeavingMinute
                {
                    get
                    {
                        double collectorLeavingMinute = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return collectorLeavingMinute;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == TransferringCollector)
                                collectorLeavingMinute = baggageDesk.LeavingTime;
                        }
                        return collectorLeavingMinute;
                    }
                }

                public DateTime transferCollectorArrivingDate(DateTime dtBegin)
                {
                    if (transferCollectorArrivingMinute != -1)
                        return dtBegin.AddMinutes(transferCollectorArrivingMinute);
                    return DateTime.MinValue;
                }

                public DateTime transferCollectorLeavingDate(DateTime dtBegin)
                {
                    if (transferCollectorLeavingMinute != -1)
                        return dtBegin.AddMinutes(transferCollectorLeavingMinute);
                    return DateTime.MinValue;
                }

                public double lastStationLeavingMinute
                {
                    get
                    {
                        double leavingMinute = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return leavingMinute;
                        BaggageDesk lastBaggageDesk = alBaggageWay[alBaggageWay.Count - 1];
                        if (lastBaggageDesk != null)
                            leavingMinute = lastBaggageDesk.LeavingTime;
                        return leavingMinute;
                    }
                }

                public double transferInfeedArrivingMinute
                {
                    get
                    {
                        double arrivingTime = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return arrivingTime;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == TransferringInfeed)
                                arrivingTime = baggageDesk.ArrivingTime;
                        }
                        return arrivingTime;
                    }
                }
                public double transferInfeedLeavingMinute
                {
                    get
                    {
                        double leavingMinute = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return leavingMinute;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == TransferringInfeed)
                                leavingMinute = baggageDesk.LeavingTime;
                        }
                        return leavingMinute;
                    }
                }

                public double getMinutesFromCheckInCollectorArrivingToLastStationLeaving()
                {
                    double minutesDifference = -1;
                    if (checkInCollectorArrivingMinute != -1 && lastStationLeavingMinute != -1)
                        minutesDifference = lastStationLeavingMinute - checkInCollectorArrivingMinute - EBSTime;
                    return minutesDifference;
                }

                public double getMinutesFromTransferCollectorArrivingToLastStationLeaving()
                {
                    double minutesDifference = -1;
                    if (transferCollectorArrivingMinute != -1 && lastStationLeavingMinute != -1)
                        minutesDifference = lastStationLeavingMinute - transferCollectorArrivingMinute - EBSTime;
                    return minutesDifference;
                }
                // << Task #15042 Pax2Sim - BHS Analysis - new EBS stats

                // << Task #8280 Pax2Sim - BHS mode - statistics for VSU Departing objects                
                /*
                public Double PresortationDepVSUInputDn1_4ArrivingTime
                {
                    get
                    {
                        if ((alBaggageWay == null) || (alBaggageWay.Count == 0))
                            return -1;
                        double presortationDepVSUInputDnArrivingTime = -1;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sDepVSUInputDn && baggageDesk.DeskIndex <= 4)
                                if (presortationDepVSUInputDnArrivingTime < baggageDesk.ArrivingTime)
                                    presortationDepVSUInputDnArrivingTime = baggageDesk.ArrivingTime;
                        }
                        return presortationDepVSUInputDnArrivingTime;
                    }
                }

                public Double PresortationDepVSUInputDn1_4LeavingMinute
                {
                    get
                    {
                        if ((alBaggageWay == null) || (alBaggageWay.Count == 0))
                            return -1;
                        double presortationDepVSUInputDnLeavingTime = -1;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sDepVSUInputDn && baggageDesk.DeskIndex <= 4)
                            {
                                if (presortationDepVSUInputDnLeavingTime < baggageDesk.LeavingTime)
                                    presortationDepVSUInputDnLeavingTime = baggageDesk.LeavingTime;
                            }
                        }
                        return presortationDepVSUInputDnLeavingTime;
                    }
                }*/
                // >> Task #8280 Pax2Sim - BHS mode - statistics for VSU Departing objects

                // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation
                public List<int> presortationDeskIndexes
                {
                    get
                    {
                        List<int> deskIndexes = new List<int>();
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return deskIndexes;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == BHS_TRACE_KEYWORD_ORIG_PRESORT
                                || baggageDesk.DeskType == BHS_TRACE_KEYWORD_TRANSF_PRESORT
                                || baggageDesk.DeskType == BHS_TRACE_KEYWORD_DEP_PRESORT)
                            {
                                if (!deskIndexes.Contains(baggageDesk.DeskIndex))
                                {
                                    deskIndexes.Add(baggageDesk.DeskIndex);
                                }
                            }
                        }
                        return deskIndexes;
                    }
                }

                public int firstPresortationDeskIndex
                {
                    get
                    {
                        int deskIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return deskIndex;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == BHS_TRACE_KEYWORD_ORIG_PRESORT
                                || baggageDesk.DeskType == BHS_TRACE_KEYWORD_TRANSF_PRESORT
                                || baggageDesk.DeskType == BHS_TRACE_KEYWORD_DEP_PRESORT)
                            {
                                deskIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return deskIndex;
                    }
                }

                public List<string> presortationIdentifiers
                {
                    get
                    {
                        List<string> identifiers = new List<string>();
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return identifiers;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == BHS_TRACE_KEYWORD_ORIG_PRESORT
                                || baggageDesk.DeskType == BHS_TRACE_KEYWORD_TRANSF_PRESORT
                                || baggageDesk.DeskType == BHS_TRACE_KEYWORD_DEP_PRESORT)
                            {
                                string identifier = baggageDesk.GroupIndex + "_" + baggageDesk.DeskIndex;
                                if (!identifiers.Contains(identifier))
                                {
                                    identifiers.Add(identifier);
                                }
                            }
                        }
                        return identifiers;
                    }
                }

                public double firstPresortationArrivingMinute
                {
                    get
                    {
                        double minute = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return minute;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == BHS_TRACE_KEYWORD_ORIG_PRESORT
                                || baggageDesk.DeskType == BHS_TRACE_KEYWORD_TRANSF_PRESORT
                                || baggageDesk.DeskType == BHS_TRACE_KEYWORD_DEP_PRESORT)
                            {
                                minute = baggageDesk.ArrivingTime;
                                break;
                            }
                        }
                        return minute;
                    }
                }

                public DateTime getFirstPresortationArrivingTime(DateTime dtBegin)
                {
                    if (firstPresortationArrivingMinute != -1)
                        return dtBegin.AddMinutes(firstPresortationArrivingMinute);
                    return DateTime.MinValue;
                }

                public double firstPresortationLeavingMinute
                {
                    get
                    {
                        double minute = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return minute;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == BHS_TRACE_KEYWORD_ORIG_PRESORT
                                || baggageDesk.DeskType == BHS_TRACE_KEYWORD_TRANSF_PRESORT
                                || baggageDesk.DeskType == BHS_TRACE_KEYWORD_DEP_PRESORT)
                            {
                                minute = baggageDesk.LeavingTime;
                                break;
                            }
                        }
                        return minute;
                    }
                }

                public double lastPresortationLeavingMinute
                {
                    get
                    {
                        double minute = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return minute;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == BHS_TRACE_KEYWORD_ORIG_PRESORT
                                || baggageDesk.DeskType == BHS_TRACE_KEYWORD_TRANSF_PRESORT
                                || baggageDesk.DeskType == BHS_TRACE_KEYWORD_DEP_PRESORT)
                            {
                                minute = baggageDesk.LeavingTime;
                            }
                        }
                        return minute;
                    }
                }

                public DateTime getLastPresortationLeavingTime(DateTime dtBegin)
                {
                    if (lastPresortationLeavingMinute != -1)
                        return dtBegin.AddMinutes(lastPresortationLeavingMinute);
                    return DateTime.MinValue;
                }
                // << Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation

                // >> Task #15042 Pax2Sim - BHS Analysis - new EBS stats
                public double firstEBSArrivingTime
                {
                    get
                    {
                        if ((alBaggageWay == null) || (alBaggageWay.Count == 0))
                            return -1;
                        double firstEBSArrivingTime = -1;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingTransferEBS)
                            {
                                firstEBSArrivingTime = baggageDesk.ArrivingTime;
                                break;
                            }
                        }
                        return firstEBSArrivingTime;
                    }
                }
                // << Task #15042 Pax2Sim - BHS Analysis - new EBS stats

                // >> Task #7949 Capacity Analysis - IST tables modification C#4
                public double lastEBSExitMinute
                {
                    get
                    {
                        if ((alBaggageWay == null) || (alBaggageWay.Count == 0))
                            return -1;
                        double exitMinute = -1;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingTransferEBS)
                            {
                                exitMinute = baggageDesk.LeavingTime;
                            }
                        }
                        return exitMinute;
                    }
                }
                // >> Task #7949 Capacity Analysis - IST tables modification C#4

                // << Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                public Double LastChuteArrivingMinute
                {
                    get
                    {
                        if ((alBaggageWay == null) || (alBaggageWay.Count == 0))
                            return -1;
                        double lastChuteArrivingTime = -1;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingTransferChute)
                            {
                                if (lastChuteArrivingTime < baggageDesk.ArrivingTime)
                                    lastChuteArrivingTime = baggageDesk.ArrivingTime;
                            }
                        }
                        return lastChuteArrivingTime;
                    }
                }

                public Double LastChuteLeavingMinute
                {
                    get
                    {
                        if ((alBaggageWay == null) || (alBaggageWay.Count == 0))
                            return -1;
                        double lastChuteLeavingTime = -1;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingTransferChute)
                            {
                                if (lastChuteLeavingTime < baggageDesk.LeavingTime)
                                    lastChuteLeavingTime = baggageDesk.LeavingTime;
                            }
                        }
                        return lastChuteLeavingTime;
                    }
                }

                public override Double TotalTimeWhenLeavingLastChute
                {
                    get
                    {
                        return base.TotalTimeWhenLeavingLastChute - getEBSTimeBeforeProcessTime(LastChuteArrivingMinute);
                    }
                }
                // >> Task #8223 Pax2Sim - BHS mode - baggs IST statistic change

                // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                public override Double TotalTimeWhenLeavingReaderTimeStamp
                {
                    get
                    {
                        return base.TotalTimeWhenLeavingReaderTimeStamp - getEBSTimeBeforeProcessTime(getArrivingMinuteAtDepReaderTimeStamp());
                    }
                }
                // >> Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader

                // >> #13391 IST Tables standardization - sorter occupation
                public double getSorterOccupationTime(int sortIndGroupIndex, double sortIndLeavingTime)
                {
                    if ((alBaggageWay == null) || (alBaggageWay.Count == 0))
                        return -1;
                    double sorterOccupationTime = -1;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.DeskType == BHS_KEYWORD_SORTER
                            && baggageDesk.ArrivingTime == sortIndLeavingTime)
                        {
                            sorterOccupationTime = baggageDesk.LeavingTime - baggageDesk.ArrivingTime;
                            break;
                        }
                        else if (baggageDesk.DeskType == OriginatingTransferChute
                            && baggageDesk.GroupIndex == sortIndGroupIndex
                            && baggageDesk.ArrivingTime >= sortIndLeavingTime)
                        {
                            sorterOccupationTime = baggageDesk.ArrivingTime - sortIndLeavingTime;
                            break;
                        }
                    }
                    return sorterOccupationTime;
                }

                public double getSorterLeavingMinute(int sortIndGroupIndex, double sortIndLeavingTime)
                {
                    if ((alBaggageWay == null) || (alBaggageWay.Count == 0))
                        return -1;
                    double sorterLeavingTime = -1;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.DeskType == BHS_KEYWORD_SORTER
                            && baggageDesk.ArrivingTime == sortIndLeavingTime)
                        {
                            sorterLeavingTime = baggageDesk.LeavingTime;
                            break;
                        }
                        else if (baggageDesk.DeskType == OriginatingTransferChute
                            && baggageDesk.GroupIndex == sortIndGroupIndex
                            && baggageDesk.ArrivingTime >= sortIndLeavingTime)
                        {
                            sorterLeavingTime = baggageDesk.LeavingTime;
                            break;
                        }
                    }
                    return sorterLeavingTime;
                }

                public double getICSOccupationTime(int icsIndGroupIndex, double icsLeavingTime)
                {
                    if ((alBaggageWay == null) || (alBaggageWay.Count == 0))
                        return -1;
                    double occupationTime = -1;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.DeskType == BHS_KEYWORD_ICS
                            && baggageDesk.ArrivingTime == icsLeavingTime)
                        {
                            occupationTime = baggageDesk.LeavingTime - baggageDesk.ArrivingTime;
                            break;
                        }
                        else if (baggageDesk.DeskType == sICSUnloader
                            && baggageDesk.GroupIndex == icsIndGroupIndex
                            && baggageDesk.ArrivingTime >= icsLeavingTime)
                        {
                            occupationTime = baggageDesk.ArrivingTime - icsLeavingTime;
                            break;
                        }
                    }
                    return occupationTime;
                }

                public double getICSLeavingMinute(int icsGroupIndex, double icsLeavingTime)
                {
                    if ((alBaggageWay == null) || (alBaggageWay.Count == 0))
                        return -1;
                    double leavingTime = -1;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.DeskType == BHS_KEYWORD_ICS
                            && baggageDesk.ArrivingTime == icsLeavingTime)
                        {
                            leavingTime = baggageDesk.LeavingTime;
                            break;
                        }
                        else if (baggageDesk.DeskType == sICSUnloader
                            && baggageDesk.GroupIndex == icsGroupIndex
                            && baggageDesk.ArrivingTime >= icsLeavingTime)
                        {
                            leavingTime = baggageDesk.LeavingTime;
                            break;
                        }
                    }
                    return leavingTime;
                }

                public double getArrivingMinuteAtFirstGivenStationTypeAfterGivenStationEntryMinute(string searchedStationType,
                    double referenceEntryMinute, int referenceGroupIndex)
                {
                    if ((alBaggageWay == null) || (alBaggageWay.Count == 0))
                        return -1;
                    double arrivingMinute = -1;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.DeskType == searchedStationType
                            && baggageDesk.ArrivingTime > referenceEntryMinute
                            && baggageDesk.GroupIndex == referenceGroupIndex)
                        {
                            arrivingMinute = baggageDesk.ArrivingTime;
                            break;
                        }
                    }
                    if (arrivingMinute == -1 && searchedStationType == sNewICSToploader)
                        arrivingMinute = getArrivingMinuteAtFirstGivenStationTypeAfterGivenStationEntryMinute(sICSToploader, referenceEntryMinute, referenceGroupIndex);
                    return arrivingMinute;
                }

                public double getLeavingMinuteAtLastGivenStationTypeAfterGivenStationEntryMinute(string searchedStationType,
                    double referenceEntryMinute, int referenceGroupIndex)
                {
                    if ((alBaggageWay == null) || (alBaggageWay.Count == 0))
                        return -1;
                    double leavingMinute = -1;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.DeskType == searchedStationType
                            && baggageDesk.ArrivingTime > referenceEntryMinute
                            && baggageDesk.GroupIndex == referenceGroupIndex)
                        {
                            leavingMinute = baggageDesk.LeavingTime;
                        }
                    }
                    return leavingMinute;
                }

                // << #13391 IST Tables standardization - sorter occupation

                /// <summary>
                /// From the queue till the end without the ebs time.
                /// </summary>
                public override Double TotalTime
                {
                    get
                    {
                        return base.TotalTime - EBSTime;
                    }
                }
                /// <summary>
                /// From the infeed till the end without the ebs time.
                /// </summary>
                public override Double TotalSimulationTime
                {
                    get
                    {
                        if ((iInfeedIndex == -1) || ((iMUIndex == -1) && (!HasHBS5) && (!HasPBC)))
                            return 0;
                        //Double EBSTime = 0;

                        //if (HasEBS){
                        //    EBSTime = GetResults(iEBSIndex).TotalTime;
                        int iIndexSortie = iMUIndex;
                        if (HasHBS5)
                            iIndexSortie = iHBS5;
                        if (HasPBC)
                            iIndexSortie = iPBC;
                        return GetResults(iIndexSortie).LeavingTime - GetResults(iInfeedIndex).LeavingTime - EBSTime;
                    }
                }
                // << Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                public override Double TotalSimulationTimeWhenLeavingChute
                {
                    get
                    {
                        if ((iInfeedIndex == -1) || ((iChute == -1) && (!HasHBS5) && (!HasPBC)))
                            return 0;
                        //Double EBSTime = 0;

                        //if (HasEBS){
                        //    EBSTime = GetResults(iEBSIndex).TotalTime;
                        int iIndexSortie = iChute;
                        if (HasHBS5)
                            iIndexSortie = iHBS5;
                        if (HasPBC)
                            iIndexSortie = iPBC;
                        return GetResults(iIndexSortie).LeavingTime - GetResults(iInfeedIndex).LeavingTime - EBSTime;
                    }
                }
                // >> Task #8223 Pax2Sim - BHS mode - baggs IST statistic change

                /// <summary>
                /// Overall Queue: CIQ / TrQ / ArrQ
                /// </summary>
                public int overallQueueDeskIndex
                {
                    get
                    {
                        int deskIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return deskIndex;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == Originating
                                || baggageDesk.DeskType == TransferringQueue
                                || baggageDesk.DeskType == TerminatingQueue)
                            {
                                deskIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return deskIndex;

                    }
                }

                /// <summary>
                /// Overall Collector: CIColl / TrIF or TrColl / ArrColl
                /// </summary>
                public int overallCollectorDeskIndex
                {
                    get
                    {
                        int deskIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return deskIndex;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingCollector
                                || baggageDesk.DeskType == TransferringInfeed || baggageDesk.DeskType == TransferringCollector
                                || baggageDesk.DeskType == ArrivingCollector)
                            {
                                deskIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return deskIndex;
                    }
                }

                /// <summary>
                /// CIColl, TrIF.
                /// Should be replaced with specific CIColl and TrIF desk indexes.
                /// </summary>
                public int firstCollectorGeneralDeskIndex
                {
                    get
                    {
                        int deskIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return deskIndex;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingCollector
                                || baggageDesk.DeskType == TransferringInfeed)
                            {
                                deskIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return deskIndex;
                    }
                }

                public int firstCheckInCollectorDeskIndex
                {
                    get
                    {
                        int deskIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return deskIndex;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingCollector)
                            {
                                deskIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return deskIndex;
                    }
                }

                public Int32 CheckInIndex
                {
                    get
                    {
                        foreach (BaggageDesk bd in alBaggageWay)
                        {
                            if (bd.DeskType == Originating)
                            {
                                return bd.DeskIndex;
                            }
                        }
                        return -1;
                    }
                }
                public Int32 CheckInCollectorIndex
                {
                    get
                    {
                        foreach (BaggageDesk bd in alBaggageWay)
                        {
                            if (bd.DeskType == OriginatingCollector)
                            {
                                return bd.DeskIndex;
                            }
                        }
                        return -1;
                    }
                }
                public Int32 transferInfeedStationIndex
                {
                    get
                    {
                        foreach (BaggageDesk bd in alBaggageWay)
                        {
                            if (bd.DeskType == TransferringInfeed)
                            {
                                return bd.DeskIndex;
                            }
                        }
                        return -1;
                    }
                }

                // >> Task #15087 Pax2Sim - BHS Analysis - Collector
                /// <summary>
                /// Station index is the 2nd index: TrColl_1_2 is the station nb 2.
                /// </summary>
                public Int32 transferringCollectorDeskIndex
                {
                    get
                    {
                        foreach (BaggageDesk bd in alBaggageWay)
                        {
                            if (bd.DeskType == TransferringCollector)
                                return bd.DeskIndex;
                        }
                        return -1;
                    }
                }

                /// <summary>
                /// Group index is the 1st index: TrColl_1_2 belongs to Group 1.
                /// </summary>
                public Int32 transferringCollectorGroupIndex
                {
                    get
                    {
                        foreach (BaggageDesk bd in alBaggageWay)
                        {
                            if (bd.DeskType == TransferringCollector)
                                return bd.GroupIndex;
                        }
                        return -1;
                    }
                }
                // << Task #15087 Pax2Sim - BHS Analysis - Collector

                public Int32 MakeUpIndex
                {
                    get
                    {
                        foreach (BaggageDesk bd in alBaggageWay)
                        {
                            if (bd.DeskType == OriginatingTransferMU)
                            {
                                return bd.DeskIndex;
                            }
                        }
                        return -1;
                    }
                }
                // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                public Int32 DepReaderTimestampDeskIndex
                {
                    get
                    {
                        Int32 deskIndex = -1;   // >> Bug - BHS analysis - DepReaderTimeStamp and InterLink
                        foreach (BaggageDesk bd in alBaggageWay)
                        {
                            if (bd.DeskType == sDepReaderTimeStamp)
                                deskIndex = bd.DeskIndex;   //return bd.DeskIndex;  // >> Bug - BHS analysis - DepReaderTimeStamp and InterLink
                        }
                        return deskIndex;   //return -1;    // >> Bug - BHS analysis - DepReaderTimeStamp and InterLink
                    }
                }
                public Int32 ICSToploaderDeskIndex
                {
                    get
                    {
                        foreach (BaggageDesk bd in alBaggageWay)
                        {
                            if (bd.DeskType == sICSToploader || bd.DeskType == sNewICSToploader)
                                return bd.DeskIndex;
                        }
                        return -1;
                    }
                }
                public Int32 ICSUnloaderDeskIndex
                {
                    get
                    {
                        foreach (BaggageDesk bd in alBaggageWay)
                        {
                            if (bd.DeskType == sICSUnloader)
                                return bd.DeskIndex;
                        }
                        return -1;
                    }
                }
                public Int32 LastChuteDeskIndex
                {
                    get
                    {
                        if ((alBaggageWay == null) || (alBaggageWay.Count == 0))
                            return -1;
                        Int32 lastChuteDeskIndex = 0;
                        double lastChuteArrivingTime = -1;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingTransferChute)
                                if (lastChuteArrivingTime < baggageDesk.ArrivingTime)
                                {
                                    lastChuteArrivingTime = baggageDesk.ArrivingTime;
                                    lastChuteDeskIndex = baggageDesk.DeskIndex;
                                }
                        }
                        return lastChuteDeskIndex;
                    }
                }
                // >> Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader

                // >> Task #10877 Pax2Sim - BHS analysis - local IST tables for all the objects
                /// <summary>
                /// Queue: CIQ, TrQ, PersonalOrigQueue, PersonalTransfQueue, PersonalDepQueue
                /// Replace with specific CIQ, TrQ, ... desk indexes !
                /// </summary>
                public int firstQueueGeneralDeskIndex
                {
                    get
                    {
                        int deskIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                            return deskIndex;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingQueue || baggageDesk.DeskType == TransferringQueue
                                || baggageDesk.DeskType == sPersonalOrigQueue || baggageDesk.DeskType == sPersonalTransfQueue
                                || baggageDesk.DeskType == sPersonalDepQueue)
                            {
                                deskIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return deskIndex;
                    }
                }

                #region Originating (what was missing)
                public Int32 checkInQueueDeskIndex
                {
                    get
                    {
                        Int32 checkInQueueDeskIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return checkInQueueDeskIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingQueue)
                            {
                                checkInQueueDeskIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return checkInQueueDeskIndex;
                    }
                }

                public Int32 personalOrigQueueDeskIndex
                {
                    get
                    {
                        Int32 personalOrigQueueDeskIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalOrigQueueDeskIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalOrigQueue)
                            {
                                personalOrigQueueDeskIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalOrigQueueDeskIndex;
                    }
                }

                public Int32 origStorageDeskIndex
                {
                    get
                    {
                        Int32 origStorageDeskIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return origStorageDeskIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sOrigStorage)
                            {
                                origStorageDeskIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return origStorageDeskIndex;
                    }
                }

                public Int32 origStorage1DeskIndex
                {
                    get
                    {
                        Int32 origStorage1DeskIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return origStorage1DeskIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sOrigStorage1)
                            {
                                origStorage1DeskIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return origStorage1DeskIndex;
                    }
                }

                public Int32 origStorage2DeskIndex
                {
                    get
                    {
                        Int32 origStorage2DeskIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return origStorage2DeskIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sOrigStorage2)
                            {
                                origStorage2DeskIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return origStorage2DeskIndex;
                    }
                }

                public Int32 origULDMUInUsedDeskIndex
                {
                    get
                    {
                        Int32 origULDMUInUsedDeskIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return origULDMUInUsedDeskIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sOrigULDMUInUsed)
                            {
                                origULDMUInUsedDeskIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return origULDMUInUsedDeskIndex;
                    }
                }

                public Int32 origULDEmptyStorageDeskIndex
                {
                    get
                    {
                        Int32 origULDEmptyStorageDeskIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return origULDEmptyStorageDeskIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sOrigULDEmptyStorage)
                            {
                                origULDEmptyStorageDeskIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return origULDEmptyStorageDeskIndex;
                    }
                }

                public Int32 origULDFullStorageDeskIndex
                {
                    get
                    {
                        Int32 origULDFullStorageDeskIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return origULDFullStorageDeskIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sOrigULDFullStorage)
                            {
                                origULDFullStorageDeskIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return origULDFullStorageDeskIndex;
                    }
                }

                public Int32 origFlowDeskIndex
                {
                    get
                    {
                        Int32 origFlowDeskIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return origFlowDeskIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sOrigFlow)
                            {
                                origFlowDeskIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return origFlowDeskIndex;
                    }
                }

                public Int32 origSlugsDeskIndex
                {
                    get
                    {
                        Int32 origSlugsDeskIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return origSlugsDeskIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sOrigSlugs)
                            {
                                origSlugsDeskIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return origSlugsDeskIndex;
                    }
                }

                public Int32 origWindowDeskIndex
                {
                    get
                    {
                        Int32 origWindowDeskIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return origWindowDeskIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sOrigWindow)
                            {
                                origWindowDeskIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return origWindowDeskIndex;
                    }
                }

                public Int32 origVSUInputUpDeskIndex
                {
                    get
                    {
                        Int32 origVSUInputUpDeskIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return origVSUInputUpDeskIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sOrigVSUInputUp)
                            {
                                origVSUInputUpDeskIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return origVSUInputUpDeskIndex;
                    }
                }

                public Int32 origVSUInputDnDeskIndex
                {
                    get
                    {
                        Int32 origVSUInputDnDeskIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return origVSUInputDnDeskIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sOrigVSUInputDn)
                            {
                                origVSUInputDnDeskIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return origVSUInputDnDeskIndex;
                    }
                }

                public Int32 origVSUOutputUpDeskIndex
                {
                    get
                    {
                        Int32 origVSUOutputUpDeskIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return origVSUOutputUpDeskIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sOrigVSUOutputUp)
                            {
                                origVSUOutputUpDeskIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return origVSUOutputUpDeskIndex;
                    }
                }

                public Int32 origVSUOutputDnDeskIndex
                {
                    get
                    {
                        Int32 origVSUOutputDnDeskIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return origVSUOutputDnDeskIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sOrigVSUOutputDn)
                            {
                                origVSUOutputDnDeskIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return origVSUOutputDnDeskIndex;
                    }
                }

                public Int32 personalOrigConvDeskIndex
                {
                    get
                    {
                        Int32 personalOrigConvDeskIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalOrigConvDeskIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalOrigConv)
                            {
                                personalOrigConvDeskIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalOrigConvDeskIndex;
                    }
                }

                public Int32 personalOrigTimeStampDeskIndex
                {
                    get
                    {
                        Int32 personalOrigTimeStampDeskIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalOrigTimeStampDeskIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalOrigTimeStamp)
                            {
                                personalOrigTimeStampDeskIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalOrigTimeStampDeskIndex;
                    }
                }

                public Int32 personalOrigVehDeskIndex
                {
                    get
                    {
                        Int32 personalOrigVehDeskIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalOrigVehDeskIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalOrigVeh)
                            {
                                personalOrigVehDeskIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalOrigVehDeskIndex;
                    }
                }

                public Int32 personalOrigWorkCenterDeskIndex
                {
                    get
                    {
                        Int32 personalOrigWorkCenterDeskIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalOrigWorkCenterDeskIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalOrigWorkCenter)
                            {
                                personalOrigWorkCenterDeskIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalOrigWorkCenterDeskIndex;
                    }
                }
                #endregion

                #region Terminating (what was missing)
                public Int32 terminatingQueueDeskIndex
                {
                    get
                    {
                        Int32 terminatingQueueIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return terminatingQueueIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == TerminatingQueue)
                            {
                                terminatingQueueIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return terminatingQueueIndex;
                    }
                }
                public Int32 terminatingHBSDeskIndex
                {
                    get
                    {
                        Int32 terminatingHBSIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return terminatingHBSIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == TerminatingHBS)
                            {
                                terminatingHBSIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return terminatingHBSIndex;
                    }
                }
                public Int32 terminatingCustomDeskIndex
                {
                    get
                    {
                        Int32 terminatingCustomIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return terminatingCustomIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == TerminatingCustom)
                            {
                                terminatingCustomIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return terminatingCustomIndex;
                    }
                }
                public Int32 terminatingABSDeskIndex
                {
                    get
                    {
                        Int32 terminatingABSIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return terminatingABSIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == TerminatingABS)
                            {
                                terminatingABSIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return terminatingABSIndex;
                    }
                }

                public Int32 personalTermQueueDeskIndex
                {
                    get
                    {
                        Int32 personalTermQueueIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalTermQueueIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalTermQueue)
                            {
                                personalTermQueueIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalTermQueueIndex;
                    }
                }

                public Int32 termStorageDeskIndex
                {
                    get
                    {
                        Int32 termStorageIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return termStorageIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTermStorage)
                            {
                                termStorageIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return termStorageIndex;
                    }
                }

                public Int32 termStorage1DeskIndex
                {
                    get
                    {
                        Int32 termStorage1Index = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return termStorage1Index;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTermStorage1)
                            {
                                termStorage1Index = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return termStorage1Index;
                    }
                }

                public Int32 termStorage2DeskIndex
                {
                    get
                    {
                        Int32 termStorage2Index = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return termStorage2Index;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTermStorage2)
                            {
                                termStorage2Index = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return termStorage2Index;
                    }
                }

                public Int32 termULDMUInUsedDeskIndex
                {
                    get
                    {
                        Int32 termULDMUInUseIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return termULDMUInUseIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTermULDMUInUsed)
                            {
                                termULDMUInUseIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return termULDMUInUseIndex;
                    }
                }

                public Int32 termULDEmptyStorageDeskIndex
                {
                    get
                    {
                        Int32 termULDEmptyStorageIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return termULDEmptyStorageIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTermULDEmptyStorage)
                            {
                                termULDEmptyStorageIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return termULDEmptyStorageIndex;
                    }
                }

                public Int32 termULDFullStorageDeskIndex
                {
                    get
                    {
                        Int32 termULDFullStorageIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return termULDFullStorageIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTermULDFullStorage)
                            {
                                termULDFullStorageIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return termULDFullStorageIndex;
                    }
                }

                public Int32 termSlugsDeskIndex
                {
                    get
                    {
                        Int32 termSlugsIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return termSlugsIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTermSlugs)
                            {
                                termSlugsIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return termSlugsIndex;
                    }
                }

                public Int32 termWindowDeskIndex
                {
                    get
                    {
                        Int32 termWindowIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return termWindowIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTermWindow)
                            {
                                termWindowIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return termWindowIndex;
                    }
                }

                public Int32 termFlowDeskIndex
                {
                    get
                    {
                        Int32 termFlowIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return termFlowIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTermFlow)
                            {
                                termFlowIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return termFlowIndex;
                    }
                }

                public Int32 termVSUInputDnDeskIndex
                {
                    get
                    {
                        Int32 termVSUInputDnIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return termVSUInputDnIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTermVSUInputDn)
                            {
                                termVSUInputDnIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return termVSUInputDnIndex;
                    }
                }
                public Int32 termVSUInputUpDeskIndex
                {
                    get
                    {
                        Int32 termVSUInputUpIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return termVSUInputUpIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTermVSUInputUp)
                            {
                                termVSUInputUpIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return termVSUInputUpIndex;
                    }
                }
                public Int32 termVSUOutputDnDeskIndex
                {
                    get
                    {
                        Int32 termVSUOutputDnIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return termVSUOutputDnIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTermVSUOutputDn)
                            {
                                termVSUOutputDnIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return termVSUOutputDnIndex;
                    }
                }
                public Int32 termVSUOutputUpDeskIndex
                {
                    get
                    {
                        Int32 termVSUOutputUpIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return termVSUOutputUpIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTermVSUOutputUp)
                            {
                                termVSUOutputUpIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return termVSUOutputUpIndex;
                    }
                }

                public Int32 personalTermTimeStampDeskIndex
                {
                    get
                    {
                        Int32 personalTermTimeStampIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalTermTimeStampIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalTermTimeStamp)
                            {
                                personalTermTimeStampIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalTermTimeStampIndex;
                    }
                }

                public Int32 personalTermConvDeskIndex
                {
                    get
                    {
                        Int32 personalTermConvIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalTermConvIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalTermConv)
                            {
                                personalTermConvIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalTermConvIndex;
                    }
                }

                public Int32 personalTermVehDeskIndex
                {
                    get
                    {
                        Int32 personalTermVehIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalTermVehIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalTermVeh)
                            {
                                personalTermVehIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalTermVehIndex;
                    }
                }

                public Int32 personalTermWorkCenterDeskIndex
                {
                    get
                    {
                        Int32 personalTermWorkCenterIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalTermWorkCenterIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalTermWorkCenter)
                            {
                                personalTermWorkCenterIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalTermWorkCenterIndex;
                    }
                }

                public Int32 personalTermSecuDeskIndex
                {
                    get
                    {
                        Int32 personalSecuCenterIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalSecuCenterIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalArrSecu)
                            {
                                personalSecuCenterIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalSecuCenterIndex;
                    }
                }

                public Int32 personalTermPassDeskIndex
                {
                    get
                    {
                        Int32 personalTermPassCenterIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalTermPassCenterIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalArrPass)
                            {
                                personalTermPassCenterIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalTermPassCenterIndex;
                    }
                }

                public Int32 personalTermGateDeskIndex
                {
                    get
                    {
                        Int32 personalTermGateCenterIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalTermGateCenterIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalArrGate)
                            {
                                personalTermGateCenterIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalTermGateCenterIndex;
                    }
                }
                #endregion

                #region Transferring (what was missing)
                public Int32 transferringQueueDeskIndex
                {
                    get
                    {
                        Int32 transferringQueueIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return transferringQueueIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == TransferringQueue)
                            {
                                transferringQueueIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return transferringQueueIndex;
                    }
                }
                public Int32 transferringInfeedDeskIndex
                {
                    get
                    {
                        Int32 transferringInfeedIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return transferringInfeedIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == TransferringInfeed)
                            {
                                transferringInfeedIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return transferringInfeedIndex;
                    }
                }

                public Int32 personalTransferQueueDeskIndex
                {
                    get
                    {
                        Int32 personalTransferQueueIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalTransferQueueIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalTransfQueue)
                            {
                                personalTransferQueueIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalTransferQueueIndex;
                    }
                }

                public Int32 personalTransferStorageDeskIndex
                {
                    get
                    {
                        Int32 personalTransferStorageIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalTransferStorageIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTransfStorage)
                            {
                                personalTransferStorageIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalTransferStorageIndex;
                    }
                }

                public Int32 personalTransferStorage1DeskIndex
                {
                    get
                    {
                        Int32 personalTransferStorage1Index = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalTransferStorage1Index;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTransfStorage1)
                            {
                                personalTransferStorage1Index = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalTransferStorage1Index;
                    }
                }

                public Int32 personalTransferStorage2DeskIndex
                {
                    get
                    {
                        Int32 personalTransferStorage2Index = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalTransferStorage2Index;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTransfStorage2)
                            {
                                personalTransferStorage2Index = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalTransferStorage2Index;
                    }
                }

                public Int32 transfULDMUInUseDeskIndex
                {
                    get
                    {
                        Int32 transfULDMUInUseIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return transfULDMUInUseIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTransfULDMUInUsed)
                            {
                                transfULDMUInUseIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return transfULDMUInUseIndex;
                    }
                }

                public Int32 transfULDEmptyDeskIndex
                {
                    get
                    {
                        Int32 transfULDEmptyIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return transfULDEmptyIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTransfULDEmptyStorage)
                            {
                                transfULDEmptyIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return transfULDEmptyIndex;
                    }
                }
                public Int32 transfULDFullDeskIndex
                {
                    get
                    {
                        Int32 transfULDFullIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return transfULDFullIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTransfULDFullStorage)
                            {
                                transfULDFullIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return transfULDFullIndex;
                    }
                }
                public Int32 transfSlugsDeskIndex
                {
                    get
                    {
                        Int32 transfSlugsIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return transfSlugsIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTransfSlugs)
                            {
                                transfSlugsIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return transfSlugsIndex;
                    }
                }
                public Int32 transfWindowDeskIndex
                {
                    get
                    {
                        Int32 transfWindowIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return transfWindowIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTransfWindow)
                            {
                                transfWindowIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return transfWindowIndex;
                    }
                }
                public Int32 transfFlowDeskIndex
                {
                    get
                    {
                        Int32 transfFlowIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return transfFlowIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTransfFlow)
                            {
                                transfFlowIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return transfFlowIndex;
                    }
                }
                public Int32 transfVSUInputDnDeskIndex
                {
                    get
                    {
                        Int32 transfVSUInputDnIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return transfVSUInputDnIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTransfVSUInputDn)
                            {
                                transfVSUInputDnIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return transfVSUInputDnIndex;
                    }
                }
                public Int32 transfVSUInputUpDeskIndex
                {
                    get
                    {
                        Int32 transfVSUInputUpIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return transfVSUInputUpIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTransfVSUInputUp)
                            {
                                transfVSUInputUpIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return transfVSUInputUpIndex;
                    }
                }
                public Int32 transfVSUOutputDnDeskIndex
                {
                    get
                    {
                        Int32 transfVSUOutputDnIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return transfVSUOutputDnIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTransfVSUOutputDn)
                            {
                                transfVSUOutputDnIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return transfVSUOutputDnIndex;
                    }
                }
                public Int32 transfVSUOutputUpDeskIndex
                {
                    get
                    {
                        Int32 transfVSUOutputUpIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return transfVSUOutputUpIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sTransfVSUOutputUp)
                            {
                                transfVSUOutputUpIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return transfVSUOutputUpIndex;
                    }
                }
                public Int32 personalTransfTimeStampDeskIndex
                {
                    get
                    {
                        Int32 personalTransfTimeStampIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalTransfTimeStampIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalTransfTimeStamp)
                            {
                                personalTransfTimeStampIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalTransfTimeStampIndex;
                    }
                }
                public Int32 personalTransfConvDeskIndex
                {
                    get
                    {
                        Int32 personalTransfConvIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalTransfConvIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalTransfConv)
                            {
                                personalTransfConvIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalTransfConvIndex;
                    }
                }
                public Int32 personalTransfVehDeskIndex
                {
                    get
                    {
                        Int32 personalTransfVehvIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalTransfVehvIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalTransfVeh)
                            {
                                personalTransfVehvIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalTransfVehvIndex;
                    }
                }
                public Int32 personalTransfWorkCenterDeskIndex
                {
                    get
                    {
                        Int32 personalTransfWorkCenterIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalTransfWorkCenterIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalTransfWorkCenter)
                            {
                                personalTransfWorkCenterIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalTransfWorkCenterIndex;
                    }
                }
                #endregion

                #region Departing (what was missing)

                /*public int depVSUInputDn1_4DeskIndex
                {
                    get
                    {
                        int presortationDepVSUInputDn1_4Index = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return presortationDepVSUInputDn1_4Index;
                        }
                        double presortationDepVSUInputDnArrivingTime = -1;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType.Contains(sDepVSUInputDn) && baggageDesk.DeskIndex <= 4)
                            {//problem: deskType comes as Dep-VSU-Input-1 // bhs object = Dep-VSU-Input-Dn
                                if (presortationDepVSUInputDnArrivingTime < baggageDesk.ArrivingTime)                                
                                    presortationDepVSUInputDn1_4Index = baggageDesk.DeskIndex;                                
                            }
                        }
                        return presortationDepVSUInputDn1_4Index;
                    }
                }*/

                public List<String> allInterLinkDeskIndexesList
                {
                    get
                    {
                        List<String> allInterLinkIndexes = new List<String>();
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return allInterLinkIndexes;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingTransferInterLink)
                            {
                                String interLinkIndex = baggageDesk.DeskName.Substring(baggageDesk.DeskType.Length + 1);
                                allInterLinkIndexes.Add(interLinkIndex);
                            }
                        }
                        return allInterLinkIndexes;
                    }
                }

                public List<String> allSorterInductionDeskIndexesList
                {
                    get
                    {
                        List<String> allSorterInductionIndexes = new List<String>();
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return allSorterInductionIndexes;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingTransferSorterInduction)
                            {
                                String sorterIndIndex = baggageDesk.DeskName.Substring(baggageDesk.DeskType.Length + 1);
                                allSorterInductionIndexes.Add(sorterIndIndex);
                            }
                        }
                        return allSorterInductionIndexes;
                    }
                }
                public List<String> allChutesDeskIndexesList
                {
                    get
                    {
                        List<String> allIndexes = new List<String>();
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return allIndexes;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingTransferChute)
                            {
                                String chuteIndex = baggageDesk.DeskName.Substring(baggageDesk.DeskType.Length + 1);
                                allIndexes.Add(chuteIndex);
                            }
                        }
                        return allIndexes;
                    }
                }

                public String LastChuteDeskWithTwoIndexes
                {
                    get
                    {
                        if ((alBaggageWay == null) || (alBaggageWay.Count == 0))
                            return "-1";
                        String lastChuteIndex = "-1";
                        double lastChuteArrivingTime = -1;
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingTransferChute)
                                if (lastChuteArrivingTime < baggageDesk.ArrivingTime)
                                {
                                    lastChuteArrivingTime = baggageDesk.ArrivingTime;
                                    lastChuteIndex = baggageDesk.DeskName.Substring(baggageDesk.DeskType.Length + 1);
                                }
                        }
                        return lastChuteIndex;
                    }
                }

                public String ICSToploaderTwoDeskIndexes
                {
                    get
                    {
                        foreach (BaggageDesk bd in alBaggageWay)
                        {
                            if (bd.DeskType == sICSToploader || bd.DeskType == sNewICSToploader)
                            {
                                if (bd.DeskName.Length > bd.DeskType.Length + 1)
                                {
                                    String ICSToploaderDeskIndexes = bd.DeskName.Substring(bd.DeskType.Length + 1);
                                    return ICSToploaderDeskIndexes;
                                }
                            }
                        }
                        return "";
                    }
                }
                public String ICSUnloaderTwoDeskIndexes
                {
                    get
                    {
                        foreach (BaggageDesk bd in alBaggageWay)
                        {
                            if (bd.DeskType == sICSUnloader)
                            {
                                if (bd.DeskName.Length > bd.DeskType.Length + 1)
                                {
                                    String ICSUnloaderDeskIndexes = bd.DeskName.Substring(bd.DeskType.Length + 1);
                                    return ICSUnloaderDeskIndexes;
                                }
                            }
                        }
                        return "";
                    }
                }
                public String DepReaderTimestampTwoDeskIndexes
                {
                    get
                    {
                        String depReaderTimeStampDeskIndexes = "";  // >> Bug - BHS analysis - DepReaderTimeStamp and InterLink
                        foreach (BaggageDesk bd in alBaggageWay)
                        {
                            if (bd.DeskType == sDepReaderTimeStamp)
                            {
                                if (bd.DeskName.Length > bd.DeskType.Length + 1)
                                {
                                    depReaderTimeStampDeskIndexes = bd.DeskName.Substring(bd.DeskType.Length + 1);
                                    //return depReaderTimeStampDeskIndexes;// >> Bug - BHS analysis - DepReaderTimeStamp and InterLink
                                }
                            }
                        }
                        return depReaderTimeStampDeskIndexes;   //return ""; // >> Bug - BHS analysis - DepReaderTimeStamp and InterLink
                    }
                }

                public Int32 originatingTransferHBS1DeskIndex
                {
                    get
                    {
                        Int32 originatingTransferHBS1Index = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return originatingTransferHBS1Index;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingTransferHBS1)
                            {
                                originatingTransferHBS1Index = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return originatingTransferHBS1Index;
                    }
                }
                public Int32 originatingTransferHBS2DeskIndex
                {
                    get
                    {
                        Int32 originatingTransferHBS2Index = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return originatingTransferHBS2Index;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingTransferHBS2)
                            {
                                originatingTransferHBS2Index = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return originatingTransferHBS2Index;
                    }
                }
                public Int32 originatingTransferHBS3DeskIndex
                {
                    get
                    {
                        Int32 originatingTransferHBS3Index = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return originatingTransferHBS3Index;
                        }
                        foreach (BaggageDesk baggagaDesk in alBaggageWay)
                        {
                            if (baggagaDesk.DeskType == OriginatingTransferHBS3)
                            {
                                originatingTransferHBS3Index = baggagaDesk.DeskIndex;
                                break;
                            }
                        }
                        return originatingTransferHBS3Index;
                    }
                }
                public Int32 originatingTransferHBS4DeskIndex
                {
                    get
                    {
                        Int32 originatingTransferHBS4Index = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return originatingTransferHBS4Index;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingTransferHBS4)
                            {
                                originatingTransferHBS4Index = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return originatingTransferHBS4Index;
                    }
                }
                public Int32 originatingTransferHBS5DeskIndex
                {
                    get
                    {
                        Int32 originatingTransferHBS5Index = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return originatingTransferHBS5Index;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingTransferHBS5)
                            {
                                originatingTransferHBS5Index = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return originatingTransferHBS5Index;
                    }
                }

                public Int32 originatingTransferPBCEarlyDeskIndex
                {
                    get
                    {
                        Int32 pbcEarlyIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return pbcEarlyIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingTransferPBC_Early)
                            {
                                pbcEarlyIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return pbcEarlyIndex;
                    }
                }
                public Int32 originatingTransferPBSLateDeskIndex
                {
                    get
                    {
                        Int32 pbcLateIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return pbcLateIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingTransferPBC_Late)
                            {
                                pbcLateIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return pbcLateIndex;
                    }
                }
                public Int32 originatingTransferPBCTSADeskIndex
                {
                    get
                    {
                        Int32 pbcTSAIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return pbcTSAIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingTransferPBC_TSA)
                            {
                                pbcTSAIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return pbcTSAIndex;
                    }
                }

                public Int32 originatingTransferMESDeskIndex
                {
                    get
                    {
                        Int32 originatingTransferMESIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return originatingTransferMESIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingTransferMES)
                            {
                                originatingTransferMESIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return originatingTransferMESIndex;
                    }
                }

                public Int32 firstEBSDeskIndex
                {
                    get
                    {
                        Int32 originatingTransferEBSIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return originatingTransferEBSIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingTransferEBS)
                            {
                                originatingTransferEBSIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return originatingTransferEBSIndex;
                    }
                }

                public Int32 firstEBSBeforeGivenStationTypeDeskIndex(string givenStationType)
                {

                    Int32 deskIndex = -1;
                    if (alBaggageWay == null || alBaggageWay.Count == 0)
                        return deskIndex;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.DeskType == OriginatingTransferEBS)
                            deskIndex = baggageDesk.DeskIndex;
                        else if (baggageDesk.DeskType == givenStationType)
                            break;
                    }
                    return deskIndex;

                }

                public Int32 firstEBSAfterGivenStationTypeDeskIndex(string givenStationType)
                {
                    if (alBaggageWay == null || alBaggageWay.Count == 0)
                        return -1;
                    bool startSearchingForEBS = false;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.DeskType == givenStationType)
                            startSearchingForEBS = true;
                        else if (baggageDesk.DeskType == OriginatingTransferEBS
                                && startSearchingForEBS)
                        {
                            return baggageDesk.DeskIndex;
                        }
                    }
                    return -1;
                }

                // >> Task #15088 Pax2Sim - BHS Analysis - Times and Indexes
                public int getFurthestEBSDeskIndexBeforeStationKeyword(string referenceStationKeyword)
                {
                    if (alBaggageWay == null)
                        return -1;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.DeskType == OriginatingTransferEBS)
                            return baggageDesk.DeskIndex;
                        if (baggageDesk.DeskType == referenceStationKeyword)
                            return -1;
                    }
                    return -1;
                }

                public int getFurthestEBSDeskIndexBeforeFirstOccurenceOfAnyOfGivenStationKeywords(List<string> referenceStationKeywords)    // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation
                {
                    if (alBaggageWay == null)
                        return -1;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.DeskType == OriginatingTransferEBS)
                            return baggageDesk.DeskIndex;
                        if (referenceStationKeywords.Contains(baggageDesk.DeskType))
                            return -1;
                    }
                    return -1;
                }

                public int getFirstEBSDeskIndexBeforeStationKeyword(string referenceStationKeyword)
                {
                    int ebsDeskIndex = -1;
                    if (alBaggageWay == null)
                        return ebsDeskIndex;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.DeskType == OriginatingTransferEBS)
                            ebsDeskIndex = baggageDesk.DeskIndex;
                        if (baggageDesk.DeskType == referenceStationKeyword)
                            break;
                    }
                    return ebsDeskIndex;
                }

                public int getFirstEBSDeskIndexBeforeFirstOccurenceOfAnyOfGivenStationKeywords(List<string> referenceStationKeywords)    // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation
                {
                    int ebsDeskIndex = -1;
                    if (alBaggageWay == null)
                        return ebsDeskIndex;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.DeskType == OriginatingTransferEBS)
                            ebsDeskIndex = baggageDesk.DeskIndex;
                        if (referenceStationKeywords.Contains(baggageDesk.DeskType))
                            break;
                    }
                    return ebsDeskIndex;
                }

                public int getFurthestEBSDeskIndexAfterStationKeyword(string referenceStationKeyword)
                {
                    int ebsDeskIndex = -1;
                    if (alBaggageWay == null)
                        return ebsDeskIndex;
                    bool foundReference = false;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.DeskType == referenceStationKeyword)
                            foundReference = true;
                        if (foundReference && baggageDesk.DeskType == OriginatingTransferEBS)
                            ebsDeskIndex = baggageDesk.DeskIndex;
                    }
                    return ebsDeskIndex;
                }

                public int getFurthestEBSDeskIndexAfterFirstOccurenceOfAnyOfGivenStationKeywords(List<string> referenceStationKeywords)    // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation
                {
                    int ebsDeskIndex = -1;
                    if (alBaggageWay == null)
                        return ebsDeskIndex;
                    bool foundReference = false;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (referenceStationKeywords.Contains(baggageDesk.DeskType))
                            foundReference = true;
                        if (foundReference && baggageDesk.DeskType == OriginatingTransferEBS)
                            ebsDeskIndex = baggageDesk.DeskIndex;
                    }
                    return ebsDeskIndex;
                }

                public int getFirstEBSDeskIndexAfterStationKeyword(string referenceStationKeyword)
                {
                    int ebsDeskIndex = -1;
                    if (alBaggageWay == null)
                        return ebsDeskIndex;
                    bool foundReference = false;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.DeskType == referenceStationKeyword)
                            foundReference = true;
                        if (foundReference && baggageDesk.DeskType == OriginatingTransferEBS)
                            return baggageDesk.DeskIndex;
                    }
                    return ebsDeskIndex;
                }

                public int getFirstEBSDeskIndexAfterFirstOccurenceOfAnyOfGivenStationKeywords(List<string> referenceStationKeywords)    // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation
                {
                    int ebsDeskIndex = -1;
                    if (alBaggageWay == null)
                        return ebsDeskIndex;
                    bool foundReference = false;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (referenceStationKeywords.Contains(baggageDesk.DeskType))
                            foundReference = true;
                        if (foundReference && baggageDesk.DeskType == OriginatingTransferEBS)
                            return baggageDesk.DeskIndex;
                    }
                    return ebsDeskIndex;
                }
                // << Task #15088 Pax2Sim - BHS Analysis - Times and Indexes

                public Int32 originatingTransferBufferDeskIndex
                {
                    get
                    {
                        Int32 originatingTransferBufferIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return originatingTransferBufferIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == OriginatingTransferEBS)
                            {
                                originatingTransferBufferIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return originatingTransferBufferIndex;
                    }
                }
                public Int32 personalDepQueueDeskIndex
                {
                    get
                    {
                        Int32 personalDepQueueIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalDepQueueIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalDepQueue)
                            {
                                personalDepQueueIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalDepQueueIndex;
                    }
                }
                public Int32 depStorageDeskIndex
                {
                    get
                    {
                        Int32 depStorageIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return depStorageIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sDepStorage)
                            {
                                depStorageIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return depStorageIndex;
                    }
                }
                public Int32 depStorage1DeskIndex
                {
                    get
                    {
                        Int32 depStorage1Index = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return depStorage1Index;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sDepStorage1)
                            {
                                depStorage1Index = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return depStorage1Index;
                    }
                }
                public Int32 depStorage2DeskIndex
                {
                    get
                    {
                        Int32 depStorage2Index = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return depStorage2Index;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sDepStorage2)
                            {
                                depStorage2Index = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return depStorage2Index;
                    }
                }
                public Int32 depULDMUInUsedDeskIndex
                {
                    get
                    {
                        Int32 depULDMUInUsedIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return depULDMUInUsedIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sDepULDMUInUsed)
                            {
                                depULDMUInUsedIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return depULDMUInUsedIndex;
                    }
                }
                public Int32 depULDEmptyDeskIndex
                {
                    get
                    {
                        Int32 depULDEmptyIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return depULDEmptyIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sDepULDEmptyStorage)
                            {
                                depULDEmptyIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return depULDEmptyIndex;
                    }
                }
                public Int32 depULDFullDeskIndex
                {
                    get
                    {
                        Int32 depULDFullIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return depULDFullIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sDepULDFullStorage)
                            {
                                depULDFullIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return depULDFullIndex;
                    }
                }
                public Int32 depSlugsDeskIndex
                {
                    get
                    {
                        Int32 depSlugsIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return depSlugsIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sDepSlugs)
                            {
                                depSlugsIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return depSlugsIndex;
                    }
                }
                public Int32 depWindowDeskIndex
                {
                    get
                    {
                        Int32 depWindowIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return depWindowIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sDepWindow)
                            {
                                depWindowIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return depWindowIndex;
                    }
                }
                public Int32 depFlowDeskIndex
                {
                    get
                    {
                        Int32 depFlowIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return depFlowIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sDepFlow)
                            {
                                depFlowIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return depFlowIndex;
                    }
                }

                public Int32 personalDepTimeStampDeskIndex
                {
                    get
                    {
                        Int32 personalDepTimeStampIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalDepTimeStampIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalDepTimeStamp)
                            {
                                personalDepTimeStampIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalDepTimeStampIndex;
                    }
                }
                public Int32 personalDepConvDeskIndex
                {
                    get
                    {
                        Int32 personalDepConvIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalDepConvIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalDepConv)
                            {
                                personalDepConvIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalDepConvIndex;
                    }
                }
                public Int32 personalDepVehDeskIndex
                {
                    get
                    {
                        Int32 personalDepVehIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalDepVehIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalDepVeh)
                            {
                                personalDepVehIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalDepVehIndex;
                    }
                }
                public Int32 personalDepWorkCenterDeskIndex
                {
                    get
                    {
                        Int32 personalDepWorkCenterIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalDepWorkCenterIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalDepWorkCenter)
                            {
                                personalDepWorkCenterIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalDepWorkCenterIndex;
                    }
                }
                public Int32 personalDepPassDeskIndex
                {
                    get
                    {
                        Int32 personalDepPassIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalDepPassIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalDepPass)
                            {
                                personalDepPassIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalDepPassIndex;
                    }
                }
                public Int32 personalDepSecuDeskIndex
                {
                    get
                    {
                        Int32 personalDepSecuIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalDepSecuIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalDepSecu)
                            {
                                personalDepSecuIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalDepSecuIndex;
                    }
                }
                public Int32 personalDepGateDeskIndex
                {
                    get
                    {
                        Int32 personalDepGateIndex = -1;
                        if (alBaggageWay == null || alBaggageWay.Count == 0)
                        {
                            return personalDepGateIndex;
                        }
                        foreach (BaggageDesk baggageDesk in alBaggageWay)
                        {
                            if (baggageDesk.DeskType == sPersonalDepGate)
                            {
                                personalDepGateIndex = baggageDesk.DeskIndex;
                                break;
                            }
                        }
                        return personalDepGateIndex;
                    }
                }
                #endregion

                // << Task #10877 Pax2Sim - BHS analysis - local IST tables for all the objects

                // << Task #7527 Summaries correction
                public bool isContainer
                {
                    get
                    {
                        foreach (BaggageDesk bd in alBaggageWay)
                        {
                            if (bd.DeskName.Contains("-ULD-"))
                            {
                                return true;
                            }
                        }
                        return false;
                    }
                }

                public int pbcType
                {
                    get { return iPBC; }
                }

                public string pbcStationType
                {
                    get { return _pbcStationType; }
                }

                public int nbRecirculation
                {
                    get { return Recirculation; }
                }
                // >> Task #7527 Summaries correction
                #endregion

                #region Constructeur
                public DepartingResult(int IDBag, int IDPax, int IDFlight, double STD, int Recirculation, int InterLink)
                    : base(IDBag, IDPax, IDFlight, STD, Recirculation, InterLink)
                {
                    iMUIndex = -1;
                    iInfeedIndex = -1;
                    liEBSIndex = new List<int>();
                    iHBS1 = -1;
                    iHBS2 = -1;
                    iHBS3 = -1;
                    iHBS4 = -1;
                    iHBS5 = -1;
                    iMES = -1;
                    iChute = -1;
                    iInterlink = -1;
                    iPBC = -1;
                    iBuffer = -1;

                    iDepQIndex = -1;
                    iDepConvIndex = -1;
                    iDepVehIndex = -1;
                    iDepWCIndex = -1;
                    iDepGateIndex = -1;
                    iDepTSIndex = -1;
                    iPBC = -1;

                    // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader                    
                    depReaderTimestampBagWayListIndex = -1;
                    icsToploaderBagWayListIndex = -1;
                    icsUnloaderBagWayListIndex = -1;
                    // >> Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                }
                #endregion

                #region public override void AddBaggageWay(BaggageDesk bdDesk)
                public override void AddBaggageWay(BaggageDesk bdDesk)
                {
                    base.AddBaggageWay(bdDesk);
                    if (bdDesk.DeskType == OriginatingTransferMU)
                        iMUIndex = alBaggageWay.Count - 1;
                    else if (bdDesk.DeskType == OriginatingTransferEBS)
                        liEBSIndex.Add(alBaggageWay.Count - 1);
                    else if (bdDesk.DeskType == OriginatingTransferHBS1)
                        iHBS1 = alBaggageWay.Count - 1;
                    else if (bdDesk.DeskType == OriginatingTransferHBS2)
                        iHBS2 = alBaggageWay.Count - 1;
                    else if (bdDesk.DeskType == OriginatingTransferHBS3)
                        iHBS3 = alBaggageWay.Count - 1;
                    else if (bdDesk.DeskType == OriginatingTransferHBS4)
                        iHBS4 = alBaggageWay.Count - 1;
                    else if (bdDesk.DeskType == OriginatingTransferHBS5)
                        iHBS5 = alBaggageWay.Count - 1;
                    else if (bdDesk.DeskType == OriginatingTransferMES)
                        iMES = alBaggageWay.Count - 1;
                    else if (bdDesk.DeskType == OriginatingTransferChute)
                        iChute = alBaggageWay.Count - 1;
                    else if (bdDesk.DeskType == OriginatingTransferInterLink)
                        iInterlink = alBaggageWay.Count - 1;
                    else if (bdDesk.DeskType == OriginatingTransferBuffer)
                        iBuffer = alBaggageWay.Count - 1;
                    else if (bdDesk.DeskType == sPersonalDepQueue)
                        iDepQIndex = alBaggageWay.Count - 1;
                    else if (bdDesk.DeskType == sPersonalDepConv)
                        iDepConvIndex = alBaggageWay.Count - 1;
                    else if (bdDesk.DeskType == sPersonalDepVeh)
                        iDepVehIndex = alBaggageWay.Count - 1;
                    else if (bdDesk.DeskType == sPersonalDepWorkCenter)
                        iDepWCIndex = alBaggageWay.Count - 1;
                    else if (bdDesk.DeskType == sPersonalDepGate)
                        iDepGateIndex = alBaggageWay.Count - 1;
                    else if (bdDesk.DeskType == sPersonalDepTimeStamp)
                        iDepTSIndex = alBaggageWay.Count - 1;
                    else if ((bdDesk.DeskType == OriginatingTransferPBC_Early)
                            || (bdDesk.DeskType == OriginatingTransferPBC_Late)
                            || (bdDesk.DeskType == OriginatingTransferPBC_Recirc)
                            || (bdDesk.DeskType == OriginatingTransferPBC_TSA))
                    {
                        iPBC = alBaggageWay.Count - 1;
                        _pbcStationType = bdDesk.DeskType;
                    }
                    else if (bdDesk.DeskType == sDepReaderTimeStamp)    // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                    {
                        depReaderTimestampBagWayListIndex = alBaggageWay.Count - 1;
                    }
                    else if (bdDesk.DeskType == sICSToploader || bdDesk.DeskType == sNewICSToploader)          // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                    {
                        icsToploaderBagWayListIndex = alBaggageWay.Count - 1;
                    }
                    else if (bdDesk.DeskType == sICSUnloader)           // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                    {
                        icsUnloaderBagWayListIndex = alBaggageWay.Count - 1;
                    }
                }
                #endregion

                public Double RemainingTime
                {
                    get
                    {
                        if (dSTD == -1)
                            return -1;
                        return ((Double)dSTD) - LeavingSystemTime;
                    }
                }
                // << Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                public Double RemainingTimeWhenLeavingLastChute
                {
                    get
                    {
                        if (dSTD == -1)
                            return -1;
                        return ((Double)dSTD) - LeavingTimeFromLastChute;
                    }
                }
                // >> Task #8223 Pax2Sim - BHS mode - baggs IST statistic change

                public DateTime GetTimeAtColl(DateTime dtBegin)
                {
                    return dtBegin.AddMinutes(ArrivingInfeedTime);
                }

                // >> #13391 IST Tables standardization - IST - CI times columns
                public double getMinutesFromCheckInToExit(DateTime dtBegin)
                {
                    DateTime leavingTimeFromCheckIn = getLeavingTimeFromCheckIn(dtBegin);
                    if (leavingTimeFromCheckIn != DateTime.MinValue && !Stopped)
                    {
                        DateTime leavingTime = dtBegin.AddMinutes(LeavingSystemTime);
                        double ebsTimeBeforeExit = getEBSTimeBeforeProcessTime(LeavingSystemTime);
                        return Math.Round(leavingTime.Subtract(leavingTimeFromCheckIn).TotalMinutes - ebsTimeBeforeExit, 2);
                    }
                    return -1;
                }

                public double getMinutesFromCheckInToLastChute(DateTime dtBegin)
                {
                    DateTime leavingTimeFromCheckIn = getLeavingTimeFromCheckIn(dtBegin);
                    if (leavingTimeFromCheckIn != DateTime.MinValue && !Stopped)
                    {
                        DateTime arrivalTimeAtLastChute = GetArrivingTimeAtLastChute(dtBegin);
                        double ebsTimeBeforeLastChuteArrivingTime = getEBSTimeBeforeProcessTime(LastChuteArrivingMinute);
                        if (arrivalTimeAtLastChute != DateTime.MinValue)
                            return Math.Round(arrivalTimeAtLastChute.Subtract(leavingTimeFromCheckIn).TotalMinutes - ebsTimeBeforeLastChuteArrivingTime, 2);
                    }
                    return -1;
                }

                public double getMinutesFromCheckInToDepReaderTimeStamp(DateTime dtBegin)
                {
                    DateTime leavingTimeFromCheckIn = getLeavingTimeFromCheckIn(dtBegin);
                    if (leavingTimeFromCheckIn != DateTime.MinValue && !Stopped)
                    {
                        DateTime arrivalTimeAtDepReaderTS = getArrivingTimeAtDepReaderTimeStamp(dtBegin);
                        double ebsTimeBeforeDepReaderArrivingTime = getEBSTimeBeforeProcessTime(getArrivingMinuteAtDepReaderTimeStamp());
                        if (arrivalTimeAtDepReaderTS != DateTime.MinValue)
                            return Math.Round(arrivalTimeAtDepReaderTS.Subtract(leavingTimeFromCheckIn).TotalMinutes - ebsTimeBeforeDepReaderArrivingTime, 2);
                    }
                    return -1;
                }

                public double getMinutesFromCheckInToFirstPresortation(DateTime dtBegin)
                {
                    DateTime leavingTimeFromCheckIn = getLeavingTimeFromCheckIn(dtBegin);
                    if (leavingTimeFromCheckIn != DateTime.MinValue && !Stopped)
                    {
                        DateTime arrivalTimeAtFirstPresortation = getFirstPresortationArrivingTime(dtBegin); //GetTimeAtPresortationDepVSUInputDn(dtBegin); // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation
                        double ebsTimeBeforePresortationArrivingTime = getEBSTimeBeforeProcessTime(firstPresortationArrivingMinute);    //PresortationDepVSUInputDn1_4ArrivingTime);
                        if (arrivalTimeAtFirstPresortation != DateTime.MinValue)
                            return Math.Round(arrivalTimeAtFirstPresortation.Subtract(leavingTimeFromCheckIn).TotalMinutes - ebsTimeBeforePresortationArrivingTime, 2);
                    }
                    return -1;
                }
                // << #13391 IST Tables standardization - IST - CI times columns

                // >> Task #15042 Pax2Sim - BHS Analysis - new EBS stats
                public DateTime getTimeAtFirstEBS(DateTime dtBegin)
                {
                    if (firstEBSArrivingTime != -1)
                        return dtBegin.AddMinutes(firstEBSArrivingTime);
                    return DateTime.MinValue;
                }

                public DateTime getExitTimeFromLastEBS(DateTime dtBegin)
                {
                    if (lastEBSExitMinute < 0)
                    {
                        return DateTime.MinValue;
                    }
                    return dtBegin.AddMinutes(lastEBSExitMinute);
                }

                public DateTime getLeavingDateFromFirstEBSAfterProcessLeavingTime(DateTime dtBegin,
                   double processLeavingTime)
                {
                    double ebsLeavingTime = -1;
                    DateTime ebsLeavingDate = DateTime.MinValue;

                    if (alBaggageWay == null || alBaggageWay.Count == 0)
                        return ebsLeavingDate;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.DeskType == OriginatingTransferEBS
                            && baggageDesk.LeavingTime >= processLeavingTime)
                        {
                            ebsLeavingTime = baggageDesk.LeavingTime;
                            ebsLeavingDate = dtBegin.AddMinutes(ebsLeavingTime);
                            break;
                        }
                    }
                    return ebsLeavingDate;
                }

                public DateTime getArrivingDateAtFirstEBSAfterProcessLeavingTime(DateTime dtBegin,
                    double processLeavingTime)
                {
                    double ebsArrivingTime = -1;
                    DateTime ebsArrivingDate = DateTime.MinValue;

                    if (alBaggageWay == null || alBaggageWay.Count == 0)
                        return ebsArrivingDate;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.DeskType == OriginatingTransferEBS
                            && baggageDesk.ArrivingTime >= processLeavingTime)
                        {
                            ebsArrivingTime = baggageDesk.ArrivingTime;
                            ebsArrivingDate = dtBegin.AddMinutes(ebsArrivingTime);
                            break;
                        }
                    }
                    return ebsArrivingDate;
                }

                public double getMinutesFromEntryToArrivingTimeOfFirstEBSAfterProcessLeavingTime(DateTime dtBegin,
                    double processLeavingTime)
                {
                    double minutesDifference = -1;
                    if (alBaggageWay == null || alBaggageWay.Count == 0)
                        return minutesDifference;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.DeskType == OriginatingTransferEBS
                            && baggageDesk.ArrivingTime >= processLeavingTime)
                        {
                            minutesDifference = baggageDesk.ArrivingTime - arrivingMinuteAtFirstStation;
                            break;
                        }
                    }
                    return minutesDifference;
                }

                public DateTime getArrivingDateAtLastEBSBeforeProcessArrivingTime(DateTime dtBegin,
                    double processArrivingTime)
                {
                    double ebsArrivingTime = -1;
                    DateTime ebsArrivingDate = DateTime.MinValue;

                    if (alBaggageWay == null || alBaggageWay.Count == 0)
                        return ebsArrivingDate;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.DeskType == OriginatingTransferEBS
                            && baggageDesk.LeavingTime <= processArrivingTime)
                        {
                            ebsArrivingTime = baggageDesk.ArrivingTime;
                            ebsArrivingDate = dtBegin.AddMinutes(ebsArrivingTime);
                        }
                    }
                    return ebsArrivingDate;
                }

                public DateTime getLeavingDateFromLastEBSBeforeProcessArrivingTime(DateTime dtBegin,
                    double processArrivingTime)
                {
                    double ebsLeavingTime = -1;
                    DateTime ebsLeavingDate = DateTime.MinValue;

                    if (alBaggageWay == null || alBaggageWay.Count == 0)
                        return ebsLeavingDate;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.DeskType == OriginatingTransferEBS
                            && baggageDesk.LeavingTime <= processArrivingTime)
                        {
                            ebsLeavingTime = baggageDesk.LeavingTime;
                            ebsLeavingDate = dtBegin.AddMinutes(ebsLeavingTime);
                        }
                    }
                    return ebsLeavingDate;
                }
                public DateTime getArrivingDateFromLastEBSBeforeProcessArrivingTime(DateTime dtBegin,
                    double processArrivingTime)
                {
                    double ebsArrivingTime = -1;
                    DateTime ebsArrivingDate = DateTime.MinValue;

                    if (alBaggageWay == null || alBaggageWay.Count == 0)
                        return ebsArrivingDate;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.DeskType == OriginatingTransferEBS
                            && baggageDesk.ArrivingTime <= processArrivingTime)
                        {
                            ebsArrivingTime = baggageDesk.ArrivingTime;
                            ebsArrivingDate = dtBegin.AddMinutes(ebsArrivingTime);
                        }
                    }
                    return ebsArrivingDate;
                }

                public double getLeavingMinuteFromFirstEBSBeforeGivenMinute(double givenMinute)
                {
                    double leavingMinute = -1;
                    if (alBaggageWay == null)
                        return -1;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.LeavingTime <= givenMinute
                            && baggageDesk.DeskType == OriginatingTransferEBS)
                        {
                            leavingMinute = baggageDesk.LeavingTime;
                        }
                    }
                    return leavingMinute;
                }

                public double getArrivingMinuteAtFirstEBSAfterGivenMinute(double givenMinute)
                {
                    if (alBaggageWay == null)
                        return -1;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.ArrivingTime >= givenMinute
                            && baggageDesk.DeskType == OriginatingTransferEBS)
                        {
                            return baggageDesk.ArrivingTime;
                        }
                    }
                    return -1;
                }

                public double getArrivingMinuteAtFurthestEBSBeforeGivenMinute(double givenMinute)
                {
                    if (alBaggageWay == null)
                        return -1;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.ArrivingTime <= givenMinute
                            && baggageDesk.DeskType == OriginatingTransferEBS)
                        {
                            return baggageDesk.ArrivingTime;
                        }
                    }
                    return -1;
                }

                public double getLeavingMinuteFromFurthestEBSAfterGivenMinute(double givenMinute)
                {
                    double ebsLeavingMinute = -1;
                    if (alBaggageWay == null)
                        return ebsLeavingMinute;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.LeavingTime >= givenMinute
                            && baggageDesk.DeskType == OriginatingTransferEBS)
                        {
                            ebsLeavingMinute = baggageDesk.LeavingTime;
                        }
                    }
                    return ebsLeavingMinute;
                }
                // << Task #15042 Pax2Sim - BHS Analysis - new EBS stats

                // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation
                public double getLeavingMinuteFromAnyOfGivenStationTypeBeforeAndClosestToGivenMinute(List<string> stationTypes, double givenMinute)
                {
                    double leavingMinute = -1;
                    if (alBaggageWay == null)
                        return -1;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.LeavingTime <= givenMinute
                            && stationTypes.Contains(baggageDesk.DeskType))
                        {
                            leavingMinute = baggageDesk.LeavingTime;
                        }
                    }
                    return leavingMinute;
                }

                public double getArrivingMinuteAtAnyOfGivenStationTypeAfterAndClosestToGivenMinute(List<string> stationTypes, double givenMinute)
                {
                    if (alBaggageWay == null)
                        return -1;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.ArrivingTime >= givenMinute
                            && stationTypes.Contains(baggageDesk.DeskType))
                        {
                            return baggageDesk.ArrivingTime;
                        }
                    }
                    return -1;
                }

                public double getArrivingMinuteAtAnyOfGivenStationTypeBeforeAndFurthestFromGivenMinute(List<string> stationTypes, double givenMinute)
                {
                    if (alBaggageWay == null)
                        return -1;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.ArrivingTime <= givenMinute
                            && stationTypes.Contains(baggageDesk.DeskType))
                        {
                            return baggageDesk.ArrivingTime;
                        }
                    }
                    return -1;
                }

                public double getLeavingMinuteFromAnyOfGivenStationTypeAfterAndFurthestFromGivenMinute(List<string> stationTypes, double givenMinute)
                {
                    double leavingMinute = -1;
                    if (alBaggageWay == null)
                        return leavingMinute;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.LeavingTime >= givenMinute
                            && stationTypes.Contains(baggageDesk.DeskType))
                        {
                            leavingMinute = baggageDesk.LeavingTime;
                        }
                    }
                    return leavingMinute;
                }
                // << Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation

                // << Task #8223 Pax2Sim - BHS mode - baggs IST statistic change
                public DateTime GetArrivingTimeAtLastChute(DateTime dtBegin)
                {
                    if (LastChuteArrivingMinute != -1)
                        return dtBegin.AddMinutes(LastChuteArrivingMinute);
                    return DateTime.MinValue;
                }

                public DateTime getLeavingTimeFromLastChute(DateTime dtBegin)
                {
                    if (LastChuteLeavingMinute != -1)
                        return dtBegin.AddMinutes(LastChuteLeavingMinute);
                    return DateTime.MinValue;
                }

                public Double getEBSTimeBeforeProcessTime(Double processTime)
                {
                    Double ebsTime = 0;
                    if ((alBaggageWay == null) || (alBaggageWay.Count == 0))
                        return ebsTime;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.DeskType == OriginatingTransferEBS)
                        {
                            if (baggageDesk.LeavingTime <= processTime)
                                ebsTime += baggageDesk.TotalTime;
                        }
                    }
                    return ebsTime;
                }

                /// <summary>
                /// Deprecated - Use 'getEBSStorageMinutesBetweenGivenMinutes'.
                /// </summary>
                /// <param name="firstProcessLeavingTime"></param>
                /// <param name="lastProcessArrivingTime"></param>
                /// <returns></returns>
                public Double getEBSStorageTimeBetweenProcessTimes(Double firstProcessLeavingTime,
                    Double lastProcessArrivingTime)
                {
                    Double ebsTime = 0;
                    if ((alBaggageWay == null) || (alBaggageWay.Count == 0))
                        return ebsTime;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.DeskType == OriginatingTransferEBS)
                        {
                            if (baggageDesk.ArrivingTime >= firstProcessLeavingTime
                                && baggageDesk.LeavingTime <= lastProcessArrivingTime)
                            {
                                ebsTime += baggageDesk.TotalTime;
                            }
                        }
                    }
                    return ebsTime;
                }

                public Double getEBSStorageMinutesBetweenGivenMinutes(double givenStartMinute,
                    double givenEndMinute)
                {
                    double ebsStorageTime = 0;
                    if (alBaggageWay == null)
                        return ebsStorageTime;
                    foreach (BaggageDesk baggageDesk in alBaggageWay)
                    {
                        if (baggageDesk.ArrivingTime >= givenStartMinute && baggageDesk.LeavingTime <= givenEndMinute   // >> Task #15683 PAX2SIM - Result Filters - Split by Flow Type C#20
                            && baggageDesk.DeskType == OriginatingTransferEBS)
                        {
                            ebsStorageTime += baggageDesk.TotalTime;
                        }
                    }
                    return ebsStorageTime;
                }
                // >> Task #8223 Pax2Sim - BHS mode - baggs IST statistic change

                // >> Task #15087 Pax2Sim - BHS Analysis - Collector
                public double getArrivingMinuteAtTransferringCollector()
                {
                    double arrivingMinute = -1;
                    if (alBaggageWay == null || alBaggageWay.Count == 0)
                        return arrivingMinute;
                    foreach (BaggageDesk desk in alBaggageWay)
                    {
                        if (desk.DeskType == TransferringCollector)
                            arrivingMinute = desk.ArrivingTime;
                    }
                    return arrivingMinute;
                }
                public double getLeavingMinuteFromTransferringCollector()
                {
                    double leavingMinute = -1;
                    if (alBaggageWay == null || alBaggageWay.Count == 0)
                        return leavingMinute;
                    foreach (BaggageDesk desk in alBaggageWay)
                    {
                        if (desk.DeskType == TransferringCollector)
                            leavingMinute = desk.LeavingTime;
                    }
                    return leavingMinute;
                }

                public DateTime getArrivingDateAtTransferringCollector(DateTime dtBegin)
                {
                    DateTime arrivingDate = DateTime.MinValue;
                    double arrivingMinute = getArrivingMinuteAtTransferringCollector();
                    if (arrivingMinute != -1)
                        arrivingDate = dtBegin.AddMinutes(arrivingMinute);
                    return arrivingDate;
                }
                public DateTime getLeavingDateFromTransferringCollector(DateTime dtBegin)
                {
                    DateTime leavingDate = DateTime.MinValue;
                    double leavingMinute = getLeavingMinuteFromTransferringCollector();
                    if (leavingMinute != -1)
                        leavingDate = dtBegin.AddMinutes(leavingMinute);
                    return leavingDate;
                }
                // << Task #15087 Pax2Sim - BHS Analysis - Collector

                // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                public DateTime getArrivingTimeAtDepReaderTimeStamp(DateTime dtBegin)
                {
                    DateTime arrivingTime = DateTime.MinValue;

                    if (alBaggageWay == null || alBaggageWay.Count == 0 || depReaderTimestampBagWayListIndex == -1)
                        return arrivingTime;

                    BaggageDesk baggageDesk = GetResults(depReaderTimestampBagWayListIndex);
                    if (baggageDesk != null)
                    {
                        arrivingTime = dtBegin.AddMinutes(baggageDesk.ArrivingTime);
                    }

                    return arrivingTime;
                }

                public DateTime getLeavingTimeFromDepReaderTimeStamp(DateTime dtBegin)
                {
                    DateTime leavingTime = DateTime.MinValue;

                    if (alBaggageWay == null || alBaggageWay.Count == 0 || depReaderTimestampBagWayListIndex == -1)
                        return leavingTime;

                    BaggageDesk baggageDesk = GetResults(depReaderTimestampBagWayListIndex);
                    if (baggageDesk != null)
                        leavingTime = dtBegin.AddMinutes(baggageDesk.LeavingTime);
                    return leavingTime;
                }

                public Double getArrivingMinuteAtDepReaderTimeStamp()
                {
                    Double arrivingMinute = -1;

                    if (alBaggageWay == null || alBaggageWay.Count == 0 || depReaderTimestampBagWayListIndex == -1)
                        return arrivingMinute;

                    BaggageDesk baggageDesk = GetResults(depReaderTimestampBagWayListIndex);
                    if (baggageDesk != null)
                    {
                        arrivingMinute = baggageDesk.ArrivingTime;
                    }

                    return arrivingMinute;
                }

                public Double getLeavingMinuteFromDepReaderTimeStamp()
                {
                    Double leavingMinute = -1;

                    if (alBaggageWay == null || alBaggageWay.Count == 0 || depReaderTimestampBagWayListIndex == -1)
                        return leavingMinute;

                    BaggageDesk baggageDesk = GetResults(depReaderTimestampBagWayListIndex);
                    if (baggageDesk != null)
                        leavingMinute = baggageDesk.LeavingTime;
                    return leavingMinute;
                }

                public DateTime getArrivingTimeAtICSToploader(DateTime dtBegin)
                {
                    DateTime arrivingTime = DateTime.MinValue;

                    if (alBaggageWay == null || alBaggageWay.Count == 0 || icsToploaderBagWayListIndex == -1)
                        return arrivingTime;

                    BaggageDesk baggageDesk = GetResults(icsToploaderBagWayListIndex);
                    if (baggageDesk != null)
                        arrivingTime = dtBegin.AddMinutes(baggageDesk.ArrivingTime);

                    return arrivingTime;
                }
                public Double getArrivingMinuteAtICSToploader()
                {
                    Double arrivingMinute = -1;

                    if (alBaggageWay == null || alBaggageWay.Count == 0 || icsToploaderBagWayListIndex == -1)
                        return arrivingMinute;

                    BaggageDesk baggageDesk = GetResults(icsToploaderBagWayListIndex);
                    if (baggageDesk != null)
                        arrivingMinute = baggageDesk.ArrivingTime;

                    return arrivingMinute;
                }

                public DateTime getArrivingTimeAtICSUnloader(DateTime dtBegin)
                {
                    DateTime arrivingTime = DateTime.MinValue;

                    if (alBaggageWay == null || alBaggageWay.Count == 0 || icsUnloaderBagWayListIndex == -1)
                        return arrivingTime;

                    BaggageDesk baggageDesk = GetResults(icsUnloaderBagWayListIndex);
                    if (baggageDesk != null)
                        arrivingTime = dtBegin.AddMinutes(baggageDesk.ArrivingTime);

                    return arrivingTime;
                }
                public Double getArrivingMinuteAtICSUnloader()
                {
                    Double arrivingMinute = -1;

                    if (alBaggageWay == null || alBaggageWay.Count == 0 || icsUnloaderBagWayListIndex == -1)
                        return arrivingMinute;

                    BaggageDesk baggageDesk = GetResults(icsUnloaderBagWayListIndex);
                    if (baggageDesk != null)
                        arrivingMinute = baggageDesk.ArrivingTime;

                    return arrivingMinute;
                }

                public DateTime getLeavingTimeFromMup(DateTime dtBegin)
                {
                    DateTime leavingTime = DateTime.MinValue;

                    if (alBaggageWay == null || alBaggageWay.Count == 0 || iMUIndex == -1)
                        return leavingTime;

                    BaggageDesk baggageDesk = GetResults(iMUIndex);
                    if (baggageDesk != null)
                        leavingTime = dtBegin.AddMinutes(baggageDesk.LeavingTime);

                    return leavingTime;
                }

                public DateTime getArrivingTimeAtMup(DateTime dtBegin)
                {
                    DateTime arrivingTime = DateTime.MinValue;

                    if (alBaggageWay == null || alBaggageWay.Count == 0 || iMUIndex == -1)
                        return arrivingTime;

                    BaggageDesk baggageDesk = GetResults(iMUIndex);
                    if (baggageDesk != null)
                        arrivingTime = dtBegin.AddMinutes(baggageDesk.ArrivingTime);

                    return arrivingTime;
                }
                public Double getArrivingMinuteAtMup()
                {
                    Double arrivingMinute = -1;
                    if (alBaggageWay == null || alBaggageWay.Count == 0 || iMUIndex == -1)
                        return arrivingMinute;

                    BaggageDesk baggageDesk = GetResults(iMUIndex);
                    if (baggageDesk != null)
                        arrivingMinute = baggageDesk.ArrivingTime;
                    return arrivingMinute;
                }
                public double getLeavingMinuteFromMup()
                {
                    double leavingMinute = -1;
                    if (alBaggageWay == null || alBaggageWay.Count == 0 || iMUIndex == -1)
                        return leavingMinute;

                    BaggageDesk baggageDesk = GetResults(iMUIndex);
                    if (baggageDesk != null)
                        leavingMinute = baggageDesk.LeavingTime;
                    return leavingMinute;
                }
                // >> Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader

                // >> #13391 IST Tables standardization - IST - CI times columns
                public DateTime getArrivalTimeAtCheckIn(DateTime dtBegin)
                {
                    if (CI_Arriving_Minute >= 0)
                        return dtBegin.AddMinutes(CI_Arriving_Minute);
                    return DateTime.MinValue;
                }

                public DateTime getLeavingTimeFromCheckIn(DateTime dtBegin)
                {
                    if (CI_Leaving_Minute >= 0)
                        return dtBegin.AddMinutes(CI_Leaving_Minute);
                    return DateTime.MinValue;
                }
                // >> #13391 IST Tables standardization - IST - CI times columns
            }

            class OriginatingResult : DepartingResult
            {
                #region Constructeurs
                public OriginatingResult(int IDBag, int IDPax, int IDFlight, double STD, int Recirculation, int InterLink)
                    : base(IDBag, IDPax, IDFlight, STD, Recirculation, InterLink)
                {
                }
                #endregion

                #region public override void AddBaggageWay(BaggageDesk bdDesk)
                public override void AddBaggageWay(BaggageDesk bdDesk)
                {
                    base.AddBaggageWay(bdDesk);
                    if (bdDesk.DeskType == OriginatingCollector)
                        iInfeedIndex = alBaggageWay.Count - 1;
                    if (bdDesk.DeskType == Originating)
                        iInfeedIndex = alBaggageWay.Count - 1;

                }
                #endregion
            }

            class TransferringResult : DepartingResult
            {
                #region Constructeurs
                public TransferringResult(int IDBag, int IDPax, int IDFlight, double STD, int Recirculation, int InterLink)
                    : base(IDBag, IDPax, IDFlight, STD, Recirculation, InterLink)
                {
                }
                #endregion

                #region public override void AddBaggageWay(BaggageDesk bdDesk)
                public override void AddBaggageWay(BaggageDesk bdDesk)
                {
                    base.AddBaggageWay(bdDesk);
                    if (bdDesk.DeskType == TransferringInfeed)
                        iInfeedIndex = alBaggageWay.Count - 1;
                }
                #endregion
            }
            #endregion

            #region StationResult
            private class StationResult
            {
                private String sStationName;
                private String sStationType;
                private int iIndexStation;
                private int iIndexSorter;
                private int iIndexICS;  // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                /// <summary>
                /// Booléen indiquand si le poste courant à une valeur de process ou non.
                /// </summary>
                private bool bTimeNull;

                private Double dMinThroughputInput;
                private Double dAverageThroughputInput;
                private Double dMaxThroughputInput;

                // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS) C#9 Instant Throughput KPIs
                private Double dMinInstantThroughputInput;
                private Double dAverageInstantThroughputInput;
                private Double dMaxInstantThroughputInput;

                private Double dMinThroughputOutput;
                private Double dAverageThroughputOutput;
                private Double dMaxThroughputOutput;

                private Double dMinInstantThroughputOutput;
                private Double dAverageInstantThroughputOutput;
                private Double dMaxInstantThroughputOutput;
                // << Task #14902 Improve Dynamic Occupation tables (PAX & BHS) C#9 Instant Throughput KPIs

                private Double dMinAverage;
                private Double dAverageAverage;
                private Double dMaxAverage;

                private Double dMinMax;
                private Double dAverageMax;
                private Double dMaxMax;

                private String sUnit;
                private Double dFirstLevel;
                private Double dSecondLevel;
                private Double dThirdLevel;

                private Double dFirstLevelPercent;
                private Double dSecondLevelPercent;
                private Double dThirdLevelPercent;

                public List<Result> alStationUse;
                private int iNumberOfRecirculation;
                private int iNumberOfICSRecirculations; // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader

                // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard                
                #region Tables saved to be used for generating the Statistic table
                public DataTable dwellAreaTable;
                public DataTable occupationTable;
                public DataTable utilizationTable;
                #endregion

                public double totalDwellAreaTime = -1;
                // << Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                public List<double> dwellAreaTimes = new List<double>();    // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS)

                public class Result
                {
                    private Double dArrivingTime;
                    private Double dLeavingTime;
                    private Double dTime;
                    private Double dTravelTime;
                    private Double dSTD;
                    private bool bStopped;
                    private Int32 _bagId;    // >> Task #10926 Pax2Sim - BHS analysis - Filter period problem
                    // >> Task #13422 Keywords improvement
                    public Int32 passengerId { get; set; }
                    public Int32 flightId { get; set; }
                    public string arrivalOrDeparture { get; set; }
                    internal string stationName { get; set; }
                    internal string stationType { get; set; }
                    // << Task #13422 Keywords improvement
                    // >> #13391 IST Tables standardization - sorter occupation
                    public int stationTerminalIndex { get; set; }
                    public int stationGroupIndex { get; set; }
                    public int stationDeskIndex { get; set; }
                    // << #13391 IST Tables standardization - sorter occupation

                    public Result(Double ArrivingTime, Double LeavingTime, Double STD,
                        Int32 pBagId, int pPaxId, int pFlightId, string pArrivalOrDeparture,
                        string deskName, string deskType, int terminalIndex, int groupIndex, int deskIndex)
                    {
                        dArrivingTime = ArrivingTime;
                        dLeavingTime = LeavingTime;
                        dTime = dLeavingTime - dArrivingTime;
                        dTravelTime = 0;
                        bStopped = false;
                        dSTD = STD;
                        _bagId = pBagId; // >> Task #10926 Pax2Sim - BHS analysis - Filter period problem
                        passengerId = pPaxId;
                        flightId = pFlightId;
                        arrivalOrDeparture = pArrivalOrDeparture;
                        stationName = deskName;
                        stationType = deskType;
                        stationTerminalIndex = terminalIndex;
                        stationGroupIndex = groupIndex;
                        stationDeskIndex = deskIndex;
                    }
                    public Double OccupationTime
                    {
                        get
                        {
                            return dTime;
                        }
                    }
                    public Double ArrivingTime
                    {
                        get
                        {
                            return dArrivingTime;
                        }
                    }
                    public Double LeavingTime
                    {
                        get
                        {
                            return dLeavingTime;
                        }
                        set
                        {
                            dLeavingTime = value;
                            dTime = dLeavingTime - dArrivingTime;
                        }
                    }
                    public Double TravelTime
                    {
                        get
                        {
                            return dTravelTime;
                        }
                        set
                        {
                            dTravelTime = value;
                        }
                    }
                    public Double STD
                    {
                        get
                        {
                            return dSTD;
                        }
                        set
                        {
                            dSTD = value;
                        }
                    }
                    public bool Stopped
                    {
                        get
                        {
                            return bStopped;
                        }
                        set
                        {
                            bStopped = value;
                        }
                    }

                    // >> Task #10926 Pax2Sim - BHS analysis - Filter period problem
                    public Int32 bagId
                    {
                        get { return _bagId; }
                        set { _bagId = value; }
                    }
                    // << Task #10926 Pax2Sim - BHS analysis - Filter period problem

                    public double getICSsOccupationTime(Dictionary<int, BaggageResult> baggageResultsDictionary)   // >> Bug #15291 Pax2Sim - BHS Analysis - _Times statistics From Entry to Exit
                    {
                        double loaderArrivingMinute = -1;
                        double lastUnloaderLeavingMinute = -1;
                        double occupationTime = 0;

                        loaderArrivingMinute = ArrivingTime;
                        if (baggageResultsDictionary.ContainsKey(bagId))
                        {
                            BaggageResult bagRes = baggageResultsDictionary[bagId];
                            foreach (BaggageDesk bd in bagRes.alBaggageWay)
                            {
                                if (bd.DeskType == sICSUnloader && bd.GroupIndex == stationGroupIndex)
                                    lastUnloaderLeavingMinute = bd.LeavingTime;
                            }
                        }
                        if (loaderArrivingMinute != -1 && lastUnloaderLeavingMinute != -1)
                            occupationTime = lastUnloaderLeavingMinute - loaderArrivingMinute;
                        return occupationTime;
                    }
                }

                #region Accesseurs
                public String StationType
                {
                    get
                    {
                        if (sStationType != "")
                            return sStationType;
                        if (sStationName.Length == 0)
                            return "";
                        String[] tsObject = sStationName.Split('_');
                        String tmp = tsObject[0];

                        if (!Int32.TryParse(tsObject[tsObject.Length - 1], out iIndexStation))
                        {
                            if ((tmp != OriginatingTransferHBS2) &&
                                (tmp != OriginatingTransferHBS4) &&
                                (tmp != OriginatingTransferHBS5) &&
                                (tmp != TerminatingABS))
                                return "";
                        }
                        if (tsObject.Length > 2)
                        {
                            if (!Int32.TryParse(tsObject[1], out iIndexSorter))
                                return "";
                            // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                            if (!Int32.TryParse(tsObject[1], out iIndexICS))
                                return "";
                            // >> Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                        }
                        if (tmp == OriginatingTransferSorterName)
                        {
                            iIndexSorter = iIndexStation;
                            iIndexStation = -1;
                        }
                        // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                        if (tmp == sICS)
                        {
                            iIndexICS = iIndexStation;
                            iIndexStation = -1;
                        }
                        // >> Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                        sStationType = tmp;
                        return sStationType;
                    }
                }
                public String StationName
                {
                    get
                    {
                        return sStationName;
                    }
                }
                public int SorterIndex
                {
                    get
                    {
                        if (StationType == "")
                            return -1;
                        return iIndexSorter;
                    }
                }
                // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                public int ICSIndex
                {
                    get
                    {
                        if (StationType == "")
                            return -1;
                        return iIndexICS;
                    }
                }
                // >> Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                public int StationIndex
                {
                    get
                    {
                        if (StationType == "")
                            return -1;
                        return iIndexStation;
                    }
                }
                public int NumberOfRecirculation
                {
                    get
                    {
                        return iNumberOfRecirculation;
                    }
                }
                // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                public int NumberOfICSRecirculations
                {
                    get { return iNumberOfICSRecirculations; }
                }
                // >> Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                public bool TimeNull
                {
                    get
                    {
                        return bTimeNull;
                    }
                    set
                    {
                        bTimeNull = value;
                    }
                }

                // >> Task #13422 Keywords improvement
                public int terminalIndex
                {
                    get
                    {
                        int index = -1;
                        if (sStationType != "" && sStationName.Length > 0
                            && sStationName.IndexOf("_") != -1)
                        {
                            String[] tsObject = sStationName.Split('_');
                            if (BHS_OBJECTS_ON_3_INDEXES_LIST.Contains(sStationType)
                                && tsObject.Length == 4 && tsObject[1] != null)
                            {
                                Int32.TryParse(tsObject[1].ToString(), out index);
                            }
                        }
                        return index;
                    }
                }
                public int groupIndex
                {
                    get
                    {
                        int index = -1;
                        if (sStationType == OriginatingTransferSorterInduction
                            || sStationType == OriginatingTransferSorterName
                            || sStationType == OriginatingTransferChute)
                        {
                            return iIndexSorter;
                        }
                        else if (sStationType == sICS
                            || sStationType == sICSToploader || sStationType == sNewICSToploader
                            || sStationType == sICSUnloader)
                        {
                            return iIndexICS;
                        }
                        else if (sStationType != "" && sStationName.Length > 0
                            && sStationName.IndexOf("_") != -1)
                        {
                            String[] tsObject = sStationName.Split('_');
                            if (BHS_OBJECTS_ON_3_INDEXES_LIST.Contains(sStationType)
                                && tsObject.Length == 4 && tsObject[2] != null)
                            {
                                Int32.TryParse(tsObject[2].ToString(), out index);
                            }
                        }
                        return index;
                    }
                }
                // << Task #13422 Keywords improvement

                internal List<BaggageResult> baggageResults = new List<BaggageResult>();    // >> Task #13391 IST tables standardization
                public Dictionary<int, BaggageResult> baggageResultsDictionary = new Dictionary<int, BaggageResult>();    // >> #13391 IST Tables standardization - sorter occupation
                #endregion

                #region Constructeur
                public StationResult(String StationName, Double FirstLevelPercent,
                                     Double SecondLevelPercent,
                                     Double ThirdLevelPercent)
                {
                    sStationName = StationName;
                    alStationUse = new List<Result>();
                    iNumberOfRecirculation = 0;
                    iNumberOfICSRecirculations = 0; // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                    sStationType = "";
                    iIndexStation = -1;
                    iIndexSorter = -1;
                    iIndexICS = -1; // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                    dMinThroughputInput = -1;
                    dAverageThroughputInput = -1;
                    dMaxThroughputInput = -1;

                    // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS) C#9 Instant Throughput KPIs
                    dMinInstantThroughputInput = -1;
                    dAverageInstantThroughputInput = -1;
                    dMaxInstantThroughputInput = -1;

                    dMinThroughputOutput = -1;
                    dAverageThroughputOutput = -1;
                    dMaxThroughputOutput = -1;

                    dMinInstantThroughputOutput = -1;
                    dAverageInstantThroughputOutput = -1;
                    dMaxInstantThroughputOutput = -1;
                    // << Task #14902 Improve Dynamic Occupation tables (PAX & BHS) C#9 Instant Throughput KPIs

                    dMinAverage = -1;
                    dAverageAverage = -1;
                    dMaxAverage = -1;

                    dMinMax = -1;
                    dAverageMax = -1;
                    dMaxMax = -1;

                    sUnit = "";
                    dFirstLevel = -1;
                    dSecondLevel = -1;
                    dThirdLevel = -1;

                    dFirstLevelPercent = FirstLevelPercent;
                    dSecondLevelPercent = SecondLevelPercent;
                    dThirdLevelPercent = ThirdLevelPercent;

                    bTimeNull = false;
                    dwellAreaTimes = new List<double>();
                }
                #endregion

                #region AddStationResult -- functions
                // >> Task #13391 IST tables standardization
                public void addBaggageResult(BaggageResult pBagRes)
                {
                    if (!baggageResults.Contains(pBagRes))
                        baggageResults.Add(pBagRes);
                }
                // << Task #13391 IST tables standardization

                public void AddStationResult(Result result)
                {
                    alStationUse.Add(result);
                }
                /* not used anywhere before this change (=> it is commented, will be removed after tests) // >> Task #10926 Pax2Sim - BHS analysis - Filter period problem
                public void AddStationResult(Double ArrivingTime, Double LeavingTime, Double dSTD)
                {
                    alStationUse.Add(new Result(ArrivingTime, LeavingTime, dSTD));
                }*/
                #endregion

                public void AddRecirculation()
                {
                    if (StationType != OriginatingTransferSorterInduction)
                        return;
                    iNumberOfRecirculation++;
                }
                // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                public void AddICSRecirculation()
                {
                    if (StationType != sICS)
                        return;
                    iNumberOfICSRecirculations++;
                }
                // >> Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                public void AddRangeInformation(StationResult srInformation)
                {
                    if ((srInformation.SorterIndex != SorterIndex) &&
                        (SorterIndex != -1) &&
                        (SorterIndex != 0))
                        return;
                    iNumberOfRecirculation += srInformation.NumberOfRecirculation;
                    iNumberOfICSRecirculations += srInformation.NumberOfICSRecirculations;  // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader                    
                    foreach (Result rValue in srInformation.alStationUse)
                    {
                        AddStationResult(rValue);
                    }
                    // >> Task #13391 IST tables standardization
                    if (srInformation.baggageResults != null
                        && srInformation.baggageResults.Count > 0)
                    {
                        foreach (BaggageResult bagRes in srInformation.baggageResults)
                        {
                            addBaggageResult(bagRes);
                            if (!baggageResultsDictionary.ContainsKey(bagRes.IDBag))    // >> #13391 IST Tables standardization - sorter occupation
                                baggageResultsDictionary.Add(bagRes.IDBag, bagRes);
                        }

                    }
                    // << Task #13391 IST tables standardization
                }

                // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                private static class StatisticTableColumnIndexes
                {
                    public static int kpiIdColumnIndex = -1;
                    public static int kpiNameColumnIndex = -1;
                    public static int totalValueColumnIndex = -1;
                    public static int totalValueUnitColumnIndex = -1;
                    public static int minValueColumnIndex = -1;
                    public static int avgValueColumnIndex = -1;
                    public static int maxValueColumnIndex = -1;
                    public static int maxLevel1ValueColumnIndex = -1;
                    public static int maxLevel2ValueColumnIndex = -1;
                    public static int maxLevel3ValueColumnIndex = -1;
                    public static int unitColumnIndex = -1;

                    // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
                    public static int kpiCategoryColumnIndex = -1;
                    public static int kpiStatColumnIndex = -1;
                    public static int valueUnitColumnIndex = -1;
                    public static int valueColumnIndex = -1;
                    // << Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
                }
                private static class StatisticTableKPIValues
                {
                    public static int kpiId = 0;
                    public static String kpiName = "";
                    public static double totalValue = -1;
                    public static String totalValueUnitName = "";
                    public static double minValue = -1;
                    public static double avgValue = -1;
                    public static double maxValue = -1;
                    public static double maxLevel1Value = -1;
                    public static double maxLevel2Value = -1;
                    public static double maxLevel3Value = -1;
                    public static String unitName = "";
                }

                public DataTable getDashboardStatistics(Double warmUp, DateTime simulationStartDate, DateTime simulationEndDate)
                {
                    return getDashboardStatistics_initial(warmUp, simulationStartDate, simulationEndDate);
                }

                public DataTable getDashboardStatistics_modified(Double warmUp, DateTime simulationStartDate, DateTime simulationEndDate)   // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
                {
                    DataTable statisticTable = new DataTable(sStationName + "_Statistics" + GlobalNames.BHS_STATS_TRANSP_TABLE_SUFFIX);

                    #region statistic table structure
                    StatisticTableColumnIndexes.kpiCategoryColumnIndex = statisticTable.Columns.Count;
                    statisticTable.Columns.Add(GlobalNames.SUMMARY_TABLE_TRANSP_KPI_CATEGORY_COLUMN_NAME, typeof(String));

                    StatisticTableColumnIndexes.kpiStatColumnIndex = statisticTable.Columns.Count;
                    statisticTable.Columns.Add(GlobalNames.SUMMARY_TABLE_TRANSP_KPI_STAT_COLUMN_NAME, typeof(String));

                    StatisticTableColumnIndexes.valueUnitColumnIndex = statisticTable.Columns.Count;
                    statisticTable.Columns.Add(GlobalNames.SUMMARY_TABLE_TRANSP_VALUE_UNIT_COLUMN_NAME, typeof(String));

                    StatisticTableColumnIndexes.valueColumnIndex = statisticTable.Columns.Count;
                    statisticTable.Columns.Add(GlobalNames.SUMMARY_TABLE_TRANSP_VALUE_COLUMN_NAME, typeof(Double));
                    #endregion

                    string level1PercentileKpiStatName = dFirstLevelPercent + GlobalNames.SUMMARY_TABLE_TRANSP_DISTRIBUTION_LEVEL_KPI_STAT_SUFIX;
                    string level2PercentileKpiStatName = dSecondLevelPercent + GlobalNames.SUMMARY_TABLE_TRANSP_DISTRIBUTION_LEVEL_KPI_STAT_SUFIX;
                    string level3PercentileKpiStatName = dThirdLevelPercent + GlobalNames.SUMMARY_TABLE_TRANSP_DISTRIBUTION_LEVEL_KPI_STAT_SUFIX;
                    if (!GlobalNames.SUMMARY_TABLE_TRANSP_KPI_STAT_NAMES.Contains(level1PercentileKpiStatName))
                        GlobalNames.SUMMARY_TABLE_TRANSP_KPI_STAT_NAMES.Add(level1PercentileKpiStatName);
                    if (!GlobalNames.SUMMARY_TABLE_TRANSP_KPI_STAT_NAMES.Contains(level2PercentileKpiStatName))
                        GlobalNames.SUMMARY_TABLE_TRANSP_KPI_STAT_NAMES.Add(level2PercentileKpiStatName);
                    if (!GlobalNames.SUMMARY_TABLE_TRANSP_KPI_STAT_NAMES.Contains(level3PercentileKpiStatName))
                        GlobalNames.SUMMARY_TABLE_TRANSP_KPI_STAT_NAMES.Add(level3PercentileKpiStatName);

                    //for each KPI in the list
                    int kpiId = 1;
                    foreach (String kpiName in GlobalNames.BHS_KPIS_NAMES_LIST)
                    {
                        //calc the kpi values in a separate method and store in the static class
                        if (calculateKpiValuesByKpiName(kpiName, kpiId, simulationStartDate, simulationEndDate, warmUp))
                        {
                            addNewRowToDashboardStatisticsTable(statisticTable, kpiName,
                                level1PercentileKpiStatName, level2PercentileKpiStatName, level3PercentileKpiStatName);
                        }
                        kpiId++;
                    }
                    statisticTable.AcceptChanges();
                    return statisticTable;
                }

                private void addNewRowToDashboardStatisticsTable(DataTable statisticTable, string kpiName,
                    string level1PercentileKpiStatName, string level2PercentileKpiStatName, string level3PercentileKpiStatName)
                {
                    foreach (string kpiStatName in GlobalNames.SUMMARY_TABLE_TRANSP_KPI_STAT_NAMES)
                    {
                        DataRow row = statisticTable.NewRow();

                        if (StatisticTableColumnIndexes.kpiStatColumnIndex != -1)
                            row[StatisticTableColumnIndexes.kpiStatColumnIndex] = kpiStatName;
                        if (kpiStatName == GlobalNames.SUMMARY_TABLE_TRANSP_TOTAL_VALUE_KPI_STAT_NAME)
                        {
                            if (StatisticTableColumnIndexes.kpiCategoryColumnIndex != -1)
                                row[StatisticTableColumnIndexes.kpiCategoryColumnIndex] = kpiName;
                            if (StatisticTableColumnIndexes.valueColumnIndex != -1 && StatisticTableKPIValues.totalValue > -1)
                                row[StatisticTableColumnIndexes.valueColumnIndex] = StatisticTableKPIValues.totalValue;
                            if (StatisticTableColumnIndexes.valueUnitColumnIndex != -1 && StatisticTableKPIValues.totalValue > -1)
                                row[StatisticTableColumnIndexes.valueUnitColumnIndex] = StatisticTableKPIValues.totalValueUnitName;
                        }
                        else if (kpiStatName == GlobalNames.SUMMARY_TABLE_TRANSP_MIN_VALUE_KPI_STAT_NAME)
                        {
                            if (StatisticTableColumnIndexes.valueColumnIndex != -1 && StatisticTableKPIValues.minValue > -1)
                                row[StatisticTableColumnIndexes.valueColumnIndex] = StatisticTableKPIValues.minValue;
                            if (StatisticTableColumnIndexes.valueUnitColumnIndex != -1 && StatisticTableKPIValues.minValue > -1)
                                row[StatisticTableColumnIndexes.valueUnitColumnIndex] = StatisticTableKPIValues.unitName;
                        }
                        else if (kpiStatName == GlobalNames.SUMMARY_TABLE_TRANSP_AVG_VALUE_KPI_STAT_NAME)
                        {
                            if (StatisticTableColumnIndexes.valueColumnIndex != -1 && StatisticTableKPIValues.avgValue > -1)
                                row[StatisticTableColumnIndexes.valueColumnIndex] = StatisticTableKPIValues.avgValue;
                            if (StatisticTableColumnIndexes.valueUnitColumnIndex != -1 && StatisticTableKPIValues.avgValue > -1)
                                row[StatisticTableColumnIndexes.valueUnitColumnIndex] = StatisticTableKPIValues.unitName;
                        }
                        else if (kpiStatName == GlobalNames.SUMMARY_TABLE_TRANSP_MAX_VALUE_KPI_STAT_NAME)
                        {
                            if (StatisticTableColumnIndexes.valueColumnIndex != -1 && StatisticTableKPIValues.maxValue > -1)
                                row[StatisticTableColumnIndexes.valueColumnIndex] = StatisticTableKPIValues.maxValue;
                            if (StatisticTableColumnIndexes.valueUnitColumnIndex != -1 && StatisticTableKPIValues.maxValue > -1)
                                row[StatisticTableColumnIndexes.valueUnitColumnIndex] = StatisticTableKPIValues.unitName;
                        }
                        else if (kpiStatName == level1PercentileKpiStatName)
                        {
                            if (StatisticTableColumnIndexes.valueColumnIndex != -1 && StatisticTableKPIValues.maxLevel1Value > -1)
                                row[StatisticTableColumnIndexes.valueColumnIndex] = StatisticTableKPIValues.maxLevel1Value;
                            if (StatisticTableColumnIndexes.valueUnitColumnIndex != -1 && StatisticTableKPIValues.maxLevel1Value > -1)
                                row[StatisticTableColumnIndexes.valueUnitColumnIndex] = StatisticTableKPIValues.unitName;
                        }
                        else if (kpiStatName == level2PercentileKpiStatName)
                        {
                            if (StatisticTableColumnIndexes.valueColumnIndex != -1 && StatisticTableKPIValues.maxLevel2Value > -1)
                                row[StatisticTableColumnIndexes.valueColumnIndex] = StatisticTableKPIValues.maxLevel2Value;
                            if (StatisticTableColumnIndexes.valueUnitColumnIndex != -1 && StatisticTableKPIValues.maxLevel2Value > -1)
                                row[StatisticTableColumnIndexes.valueUnitColumnIndex] = StatisticTableKPIValues.unitName;
                        }
                        else if (kpiStatName == level3PercentileKpiStatName)
                        {
                            if (StatisticTableColumnIndexes.valueColumnIndex != -1 && StatisticTableKPIValues.maxLevel3Value > -1)
                                row[StatisticTableColumnIndexes.valueColumnIndex] = StatisticTableKPIValues.maxLevel3Value;
                            if (StatisticTableColumnIndexes.valueUnitColumnIndex != -1 && StatisticTableKPIValues.maxLevel3Value > -1)
                                row[StatisticTableColumnIndexes.valueUnitColumnIndex] = StatisticTableKPIValues.unitName;
                        }
                        statisticTable.Rows.Add(row);
                    }
                }

                public DataTable getDashboardStatistics_initial(Double warmUp, DateTime simulationStartDate, DateTime simulationEndDate)
                {
                    DataTable statisticTable = new DataTable(sStationName + "_Statistics");

                    #region statistic table structure                    
                    StatisticTableColumnIndexes.kpiIdColumnIndex = statisticTable.Columns.Count;
                    statisticTable.Columns.Add(GlobalNames.SUMMARY_TABLE_KPI_ID_COLUMN_NAME, typeof(Int32));

                    StatisticTableColumnIndexes.kpiNameColumnIndex = statisticTable.Columns.Count;
                    statisticTable.Columns.Add(GlobalNames.SUMMARY_TABLE_DATA_COLUMN_NAME, typeof(String));

                    StatisticTableColumnIndexes.totalValueColumnIndex = statisticTable.Columns.Count;
                    statisticTable.Columns.Add(GlobalNames.SUMMARY_TABLE_VALUE_COLUMN_NAME, typeof(Double));

                    StatisticTableColumnIndexes.totalValueUnitColumnIndex = statisticTable.Columns.Count;
                    statisticTable.Columns.Add(GlobalNames.BHS_STATS_TABLE_TOTAL_VALUE_UNIT_COLUMN_NAME, typeof(String));

                    StatisticTableColumnIndexes.minValueColumnIndex = statisticTable.Columns.Count;
                    statisticTable.Columns.Add(GlobalNames.SUMMARY_TABLE_MIN_VALUE_COLUMN_NAME, typeof(Double));

                    StatisticTableColumnIndexes.avgValueColumnIndex = statisticTable.Columns.Count;
                    statisticTable.Columns.Add(GlobalNames.SUMMARY_TABLE_AVG_VALUE_COLUMN_NAME, typeof(Double));

                    StatisticTableColumnIndexes.maxValueColumnIndex = statisticTable.Columns.Count;
                    statisticTable.Columns.Add(GlobalNames.SUMMARY_TABLE_MAX_VALUE_COLUMN_NAME, typeof(Double));

                    StatisticTableColumnIndexes.maxLevel1ValueColumnIndex = statisticTable.Columns.Count;
                    statisticTable.Columns
                        .Add(dFirstLevelPercent + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(Double));

                    int maxLevel2ValueColumnIndex = statisticTable.Columns.Count;
                    StatisticTableColumnIndexes.maxLevel2ValueColumnIndex = maxLevel2ValueColumnIndex;
                    statisticTable.Columns
                        .Add(dSecondLevelPercent + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(Double));

                    StatisticTableColumnIndexes.maxLevel3ValueColumnIndex = statisticTable.Columns.Count;
                    statisticTable.Columns
                        .Add(dThirdLevelPercent + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(Double));

                    StatisticTableColumnIndexes.unitColumnIndex = statisticTable.Columns.Count;
                    statisticTable.Columns.Add(GlobalNames.SUMMARY_TABLE_UNIT_COLUMN_NAME, typeof(String));
                    #endregion

                    //for each KPI in the list
                    int kpiId = 1;
                    foreach (String kpiName in GlobalNames.BHS_KPIS_NAMES_LIST)
                    {
                        //calc the kpi values in a separate method and store in the static class
                        if (calculateKpiValuesByKpiName(kpiName, kpiId, simulationStartDate, simulationEndDate, warmUp))
                        {
                            //call add new row
                            if (addNewRowToDashboardStatisticsTable(statisticTable))
                            {
                                kpiId++;
                            }
                        }
                    }
                    return statisticTable;
                }

                /// <summary>
                /// Returns true if the KPI can be calculated for the Station.(For this Station type the required table/time was generated)
                /// </summary>
                /// <param name="kpiName"></param>
                /// <param name="simulationStartDate"></param>
                /// <param name="simulationEndDate"></param>
                /// <param name="warmUp"></param>
                /// <returns></returns>
                private bool calculateKpiValuesByKpiName(String kpiName, int kpiId, DateTime simulationStartDate, DateTime simulationEndDate, Double warmUp)
                {
                    bool resultAquired = true;

                    switch (kpiName)
                    {
                        case GlobalNames.BHS_KPI_NAME_NB_BAGS:
                        case GlobalNames.BHS_KPI_NAME_NB_STOPPED_BAGS:
                        case GlobalNames.BHS_KPI_NAME_NB_STOPPED_BAGS_AFTER_STATION:
                        case GlobalNames.BHS_KPI_NAME_PROCESS_TIME:
                        case GlobalNames.BHS_KPI_NAME_TRAVEL_TIME_TO_NEXT_STATION:
                            {
                                ArrayList travelTimesList = new ArrayList();
                                ArrayList processTimesList = new ArrayList();

                                int totalNbBags = 0;
                                int stoppedBagsNb = 0;
                                int stoppedBagsNbAfterStation = 0;

                                double totalProcessTime = 0;
                                double minProcessTime = -1;
                                double avgProcessTime = -1;
                                double maxProcessTime = -1;
                                double maxLevel1ProcessTime = -1;
                                double maxLevel2ProcessTime = -1;
                                double maxLevel3ProcessTime = -1;

                                double totalTravelTime = 0;
                                double minTravelTime = -1;
                                double avgTravelTime = -1;
                                double maxTravelTime = -1;
                                double maxLevel1TravelTime = -1;
                                double maxLevel2TravelTime = -1;
                                double maxLevel3TravelTime = -1;

                                double timeUnitCoefficient = 1; // for minutes

                                String timeUnitName = GlobalNames.BHS_STATS_UNIT_NAME_MINUTES;
                                if (StationType == OriginatingTransferSorterInduction || StationType == OriginatingTransferHBS1
                                    || StationType == OriginatingTransferHBS2 || StationType == OriginatingTransferHBS3
                                    || StationType == OriginatingTransferHBS4 || StationType == OriginatingTransferChute
                                    || StationType == sICSToploader || StationType == sNewICSToploader || StationType == sICSUnloader)
                                {
                                    timeUnitName = GlobalNames.BHS_STATS_UNIT_NAME_SECONDS;
                                    timeUnitCoefficient = 60;
                                }
                                else if (StationType == OriginatingTransferEBS || StationType == sPersonalParking)
                                {
                                    if (!PAX2SIM.cdgMode)
                                    {
                                        timeUnitName = GlobalNames.BHS_STATS_UNIT_NAME_HOURS;
                                        timeUnitCoefficient = 1.0 / 60.0;
                                    }
                                }

                                for (int i = 0; i < alStationUse.Count; i++)
                                {
                                    Result stationInUseResults = (Result)alStationUse[i];

                                    if (stationInUseResults.ArrivingTime < warmUp)
                                        continue;
                                    if (stationInUseResults.Stopped)
                                    {
                                        stoppedBagsNb++;
                                        continue;
                                    }
                                    TimeSpan simulationDuration = simulationEndDate.Subtract(simulationStartDate);
                                    if (stationInUseResults.ArrivingTime > simulationDuration.TotalMinutes)
                                        continue;

                                    totalNbBags++;

                                    if (kpiName.Equals(GlobalNames.BHS_KPI_NAME_PROCESS_TIME))
                                    {
                                        double processTime = stationInUseResults.OccupationTime;
                                        if (StationType == sICS)
                                            processTime = stationInUseResults.getICSsOccupationTime(baggageResultsDictionary);
                                        processTime = processTime * timeUnitCoefficient;

                                        if (processTime < minProcessTime || minProcessTime == -1)
                                            minProcessTime = processTime;

                                        if (processTime > maxProcessTime)
                                            maxProcessTime = processTime;

                                        totalProcessTime += processTime;
                                        processTimesList.Add(processTime);
                                    }

                                    if (stationInUseResults.TravelTime == -1)
                                    {
                                        stoppedBagsNbAfterStation++;
                                        continue;
                                    }

                                    if (kpiName.Equals(GlobalNames.BHS_KPI_NAME_TRAVEL_TIME_TO_NEXT_STATION))
                                    {
                                        double travelTime = stationInUseResults.TravelTime;
                                        travelTime = travelTime * timeUnitCoefficient;

                                        travelTimesList.Add(travelTime);
                                        if (travelTime < minTravelTime || minTravelTime == -1)
                                            minTravelTime = travelTime;

                                        if (travelTime > maxTravelTime)
                                            maxTravelTime = travelTime;

                                        totalTravelTime += travelTime;
                                    }
                                }

                                if (kpiName.Equals(GlobalNames.BHS_KPI_NAME_PROCESS_TIME))
                                {
                                    if (totalNbBags != 0)
                                        avgProcessTime = totalProcessTime / totalNbBags;
                                    else
                                        minProcessTime = 0;

                                    processTimesList.Sort();
                                    if (processTimesList.Count > 0)
                                    {
                                        maxLevel1ProcessTime = OverallTools.ResultFunctions.getLevelValue(processTimesList, dFirstLevelPercent);
                                        maxLevel2ProcessTime = ResultFunctions.getLevelValue(processTimesList, dSecondLevelPercent);
                                        maxLevel3ProcessTime = ResultFunctions.getLevelValue(processTimesList, dThirdLevelPercent);
                                    }
                                }

                                if (kpiName.Equals(GlobalNames.BHS_KPI_NAME_TRAVEL_TIME_TO_NEXT_STATION))
                                {
                                    if (totalNbBags != 0)
                                        avgTravelTime = totalTravelTime / (totalNbBags - stoppedBagsNb);
                                    else
                                        minTravelTime = 0;

                                    travelTimesList.Sort();
                                    if (travelTimesList.Count > 0)
                                    {
                                        maxLevel1TravelTime = OverallTools.ResultFunctions.getLevelValue(travelTimesList, dFirstLevelPercent);
                                        maxLevel2TravelTime = ResultFunctions.getLevelValue(travelTimesList, dSecondLevelPercent);
                                        maxLevel3TravelTime = ResultFunctions.getLevelValue(travelTimesList, dThirdLevelPercent);
                                    }
                                }

                                String objectUnitName = GlobalNames.BHS_STATS_UNIT_NAME_BAG;
                                if (StationType == sPersonalParking)
                                {
                                    objectUnitName = GlobalNames.BHS_STATS_UNIT_NAME_CARS;
                                }

                                //total value unit selection
                                String totalValueUnitName = "";
                                double newTotalTimeValue = -1;

                                if (kpiName.Equals(GlobalNames.BHS_KPI_NAME_PROCESS_TIME))  // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
                                {
                                    if (getMeaningfulTimeUsingAdequateTimeUnit(totalProcessTime, timeUnitName, out newTotalTimeValue, out totalValueUnitName))
                                        totalProcessTime = newTotalTimeValue;
                                    else
                                        totalValueUnitName = timeUnitName;
                                }
                                if (kpiName.Equals(GlobalNames.BHS_KPI_NAME_TRAVEL_TIME_TO_NEXT_STATION))   // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
                                {
                                    if (getMeaningfulTimeUsingAdequateTimeUnit(totalTravelTime, timeUnitName, out newTotalTimeValue, out totalValueUnitName))
                                        totalTravelTime = newTotalTimeValue;
                                    else
                                        totalValueUnitName = timeUnitName;
                                }

                                if (kpiName.Equals(GlobalNames.BHS_KPI_NAME_NB_BAGS))
                                {
                                    StatisticTableKPIValues.kpiId = kpiId;
                                    StatisticTableKPIValues.kpiName = kpiName;
                                    StatisticTableKPIValues.totalValue = totalNbBags;
                                    StatisticTableKPIValues.totalValueUnitName = objectUnitName;
                                    StatisticTableKPIValues.minValue = -1;
                                    StatisticTableKPIValues.avgValue = -1;
                                    StatisticTableKPIValues.maxValue = -1;
                                    StatisticTableKPIValues.maxLevel1Value = -1;
                                    StatisticTableKPIValues.maxLevel2Value = -1;
                                    StatisticTableKPIValues.maxLevel3Value = -1;
                                    StatisticTableKPIValues.unitName = objectUnitName;
                                }
                                else if (kpiName.Equals(GlobalNames.BHS_KPI_NAME_NB_STOPPED_BAGS))
                                {
                                    StatisticTableKPIValues.kpiId = kpiId;
                                    StatisticTableKPIValues.kpiName = kpiName;
                                    StatisticTableKPIValues.totalValue = stoppedBagsNb;
                                    StatisticTableKPIValues.totalValueUnitName = objectUnitName;
                                    StatisticTableKPIValues.minValue = -1;
                                    StatisticTableKPIValues.avgValue = -1;
                                    StatisticTableKPIValues.maxValue = -1;
                                    StatisticTableKPIValues.maxLevel1Value = -1;
                                    StatisticTableKPIValues.maxLevel2Value = -1;
                                    StatisticTableKPIValues.maxLevel3Value = -1;
                                    StatisticTableKPIValues.unitName = objectUnitName;
                                }
                                else if (kpiName.Equals(GlobalNames.BHS_KPI_NAME_NB_STOPPED_BAGS_AFTER_STATION))
                                {
                                    StatisticTableKPIValues.kpiId = kpiId;
                                    StatisticTableKPIValues.kpiName = kpiName;
                                    StatisticTableKPIValues.totalValue = stoppedBagsNbAfterStation;
                                    StatisticTableKPIValues.totalValueUnitName = objectUnitName;
                                    StatisticTableKPIValues.minValue = -1;
                                    StatisticTableKPIValues.avgValue = -1;
                                    StatisticTableKPIValues.maxValue = -1;
                                    StatisticTableKPIValues.maxLevel1Value = -1;
                                    StatisticTableKPIValues.maxLevel2Value = -1;
                                    StatisticTableKPIValues.maxLevel3Value = -1;
                                    StatisticTableKPIValues.unitName = objectUnitName;
                                }
                                else if (kpiName.Equals(GlobalNames.BHS_KPI_NAME_PROCESS_TIME))
                                {
                                    if (!TimeNull)
                                    {
                                        StatisticTableKPIValues.kpiId = kpiId;
                                        StatisticTableKPIValues.kpiName = kpiName;
                                        StatisticTableKPIValues.totalValue = Math.Round(totalProcessTime, 2);
                                        StatisticTableKPIValues.totalValueUnitName = totalValueUnitName;
                                        StatisticTableKPIValues.minValue = Math.Round(minProcessTime, 2);
                                        StatisticTableKPIValues.avgValue = Math.Round(avgProcessTime, 2);
                                        StatisticTableKPIValues.maxValue = Math.Round(maxProcessTime, 2);
                                        StatisticTableKPIValues.maxLevel1Value = Math.Round(maxLevel1ProcessTime, 2);
                                        StatisticTableKPIValues.maxLevel2Value = Math.Round(maxLevel2ProcessTime, 2);
                                        StatisticTableKPIValues.maxLevel3Value = Math.Round(maxLevel3ProcessTime, 2);
                                        StatisticTableKPIValues.unitName = timeUnitName;
                                    }
                                    else
                                        resultAquired = false;  //return false;                                    
                                }
                                else if (kpiName.Equals(GlobalNames.BHS_KPI_NAME_TRAVEL_TIME_TO_NEXT_STATION))
                                {
                                    StatisticTableKPIValues.kpiId = kpiId;
                                    StatisticTableKPIValues.kpiName = kpiName;
                                    StatisticTableKPIValues.totalValue = Math.Round(totalTravelTime, 2);
                                    StatisticTableKPIValues.totalValueUnitName = totalValueUnitName;
                                    StatisticTableKPIValues.minValue = Math.Round(minTravelTime, 2);
                                    StatisticTableKPIValues.avgValue = Math.Round(avgTravelTime, 2);
                                    StatisticTableKPIValues.maxValue = Math.Round(maxTravelTime, 2);
                                    StatisticTableKPIValues.maxLevel1Value = Math.Round(maxLevel1TravelTime, 2);
                                    StatisticTableKPIValues.maxLevel2Value = Math.Round(maxLevel2TravelTime, 2);
                                    StatisticTableKPIValues.maxLevel3Value = Math.Round(maxLevel3TravelTime, 2);
                                    StatisticTableKPIValues.unitName = timeUnitName;
                                }
                                break;
                            }
                        case GlobalNames.BHS_KPI_NAME_OCCUPATION:
                        case GlobalNames.BHS_KPI_NAME_INPUT_BAGS:
                        case GlobalNames.BHS_KPI_NAME_OUTPUT_BAGS:
                        case GlobalNames.BHS_KPI_NAME_THROUGHPUT_INPUT:
                        case GlobalNames.BHS_KPI_NAME_THROUGHPUT_OUTPUT:
                        case GlobalNames.BHS_KPI_NAME_THROUGHPUT_INSTANT_INPUT:             // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS) C#9 Instant Throughput KPIs
                        case GlobalNames.BHS_KPI_NAME_THROUGHPUT_INSTANT_OUTPUT:
                            {
                                if (occupationTable == null)
                                {
                                    resultAquired = false;
                                    break;
                                }

                                if (kpiName.Equals(GlobalNames.BHS_KPI_NAME_OCCUPATION))
                                {
                                    double minOccupation = -1;
                                    double avgOccupation = -1;
                                    double maxOccupation = -1;

                                    if (occupationTable.Columns.IndexOf(GlobalNames.BHS_OCCUPATION_TABLE_MIN_OCC_COLUMN_NAME) != -1
                                        && occupationTable.Columns.IndexOf(GlobalNames.BHS_OCCUPATION_TABLE_AVG_OCC_COLUMN_NAME) != -1
                                        && occupationTable.Columns.IndexOf(GlobalNames.BHS_OCCUPATION_TABLE_MAX_OCC_COLUMN_NAME) != -1)
                                    {
                                        Double[] minOccupationStats
                                            = DataFunctions.GetStatColumn(occupationTable, GlobalNames.BHS_OCCUPATION_TABLE_MIN_OCC_COLUMN_NAME);
                                        Double[] avgOccupationStats
                                            = DataFunctions.GetStatColumn(occupationTable, GlobalNames.BHS_OCCUPATION_TABLE_AVG_OCC_COLUMN_NAME);
                                        Double[] maxOccupationStats
                                            = DataFunctions.GetStatColumn(occupationTable, GlobalNames.BHS_OCCUPATION_TABLE_MAX_OCC_COLUMN_NAME);

                                        if ((minOccupationStats != null) && (avgOccupationStats != null) && (maxOccupationStats != null))
                                        {
                                            minOccupation = minOccupationStats[0];
                                            avgOccupation = avgOccupationStats[2];
                                            maxOccupation = maxOccupationStats[1];
                                        }
                                    }

                                    StatisticTableKPIValues.kpiId = kpiId;
                                    StatisticTableKPIValues.kpiName = kpiName;
                                    StatisticTableKPIValues.totalValue = -1;
                                    StatisticTableKPIValues.totalValueUnitName = GlobalNames.BHS_STATS_UNIT_NAME_BAG;
                                    StatisticTableKPIValues.minValue = Math.Round(minOccupation, 2);
                                    StatisticTableKPIValues.avgValue = Math.Round(avgOccupation, 2);
                                    StatisticTableKPIValues.maxValue = Math.Round(maxOccupation, 2);
                                    StatisticTableKPIValues.maxLevel1Value = -1;
                                    StatisticTableKPIValues.maxLevel2Value = -1;
                                    StatisticTableKPIValues.maxLevel3Value = -1;
                                    StatisticTableKPIValues.unitName = GlobalNames.BHS_STATS_UNIT_NAME_BAG;
                                }

                                if (kpiName.Equals(GlobalNames.BHS_KPI_NAME_INPUT_BAGS))
                                {
                                    double totalNbBagsIn = -1;
                                    double minInBags = -1;
                                    double avgInBags = -1;
                                    double maxInBags = -1;

                                    if (occupationTable.Columns.IndexOf(GlobalNames.BHS_OCCUPATION_TABLE_NB_BAGS_IN_COLUMN_NAME) != -1)
                                    {
                                        Double[] occupationNbBagsInStats
                                            = DataFunctions.GetStatColumn(occupationTable, GlobalNames.BHS_OCCUPATION_TABLE_NB_BAGS_IN_COLUMN_NAME);
                                        if (occupationNbBagsInStats != null
                                            && occupationNbBagsInStats.Length >= 3)
                                        {
                                            minInBags = occupationNbBagsInStats[0];
                                            avgInBags = occupationNbBagsInStats[2];
                                            maxInBags = occupationNbBagsInStats[1];
                                        }
                                        totalNbBagsIn = DataFunctions.SumColumn(occupationTable, GlobalNames.BHS_OCCUPATION_TABLE_NB_BAGS_IN_COLUMN_NAME);
                                    }

                                    StatisticTableKPIValues.kpiId = kpiId;
                                    StatisticTableKPIValues.kpiName = kpiName;
                                    StatisticTableKPIValues.totalValue = totalNbBagsIn;
                                    StatisticTableKPIValues.totalValueUnitName = GlobalNames.BHS_STATS_UNIT_NAME_BAG;
                                    StatisticTableKPIValues.minValue = Math.Round(minInBags, 2);
                                    StatisticTableKPIValues.avgValue = Math.Round(avgInBags, 2);
                                    StatisticTableKPIValues.maxValue = Math.Round(maxInBags, 2);
                                    StatisticTableKPIValues.maxLevel1Value = -1;
                                    StatisticTableKPIValues.maxLevel2Value = -1;
                                    StatisticTableKPIValues.maxLevel3Value = -1;
                                    StatisticTableKPIValues.unitName = GlobalNames.BHS_STATS_UNIT_NAME_BAG;
                                }

                                if (kpiName.Equals(GlobalNames.BHS_KPI_NAME_OUTPUT_BAGS))
                                {
                                    double totalNbBagsOut = -1;
                                    double minOutBags = -1;
                                    double avgOutBags = -1;
                                    double maxOutBags = -1;

                                    if (occupationTable.Columns.IndexOf(GlobalNames.BHS_OCCUPATION_TABLE_NB_BAGS_OUT_COLUMN_NAME) != -1)
                                    {
                                        Double[] occupationNbBagsOutStats
                                            = DataFunctions.GetStatColumn(occupationTable, GlobalNames.BHS_OCCUPATION_TABLE_NB_BAGS_OUT_COLUMN_NAME);
                                        if (occupationNbBagsOutStats != null
                                            && occupationNbBagsOutStats.Length >= 3)
                                        {
                                            minOutBags = occupationNbBagsOutStats[0];
                                            avgOutBags = occupationNbBagsOutStats[2];
                                            maxOutBags = occupationNbBagsOutStats[1];
                                        }
                                        totalNbBagsOut = DataFunctions.SumColumn(occupationTable, GlobalNames.BHS_OCCUPATION_TABLE_NB_BAGS_OUT_COLUMN_NAME);
                                    }

                                    StatisticTableKPIValues.kpiId = kpiId;
                                    StatisticTableKPIValues.kpiName = kpiName;
                                    StatisticTableKPIValues.totalValue = totalNbBagsOut;
                                    StatisticTableKPIValues.totalValueUnitName = GlobalNames.BHS_STATS_UNIT_NAME_BAG;
                                    StatisticTableKPIValues.minValue = Math.Round(minOutBags, 2);
                                    StatisticTableKPIValues.avgValue = Math.Round(avgOutBags, 2);
                                    StatisticTableKPIValues.maxValue = Math.Round(maxOutBags, 2);
                                    StatisticTableKPIValues.maxLevel1Value = -1;
                                    StatisticTableKPIValues.maxLevel2Value = -1;
                                    StatisticTableKPIValues.maxLevel3Value = -1;
                                    StatisticTableKPIValues.unitName = GlobalNames.BHS_STATS_UNIT_NAME_BAG;
                                }

                                if (kpiName.Equals(GlobalNames.BHS_KPI_NAME_THROUGHPUT_INPUT))
                                {
                                    double minThroughputIn = -1;
                                    double avgThroughputIn = -1;
                                    double maxThroughputIn = -1;

                                    if (occupationTable.Columns.IndexOf(GlobalNames.BHS_OCCUPATION_TABLE_THROUGHPUT_IN_COLUMN_NAME) != -1)
                                    {
                                        Double[] throughputInputStats
                                            = DataFunctions.GetStatColumn(occupationTable, GlobalNames.BHS_OCCUPATION_TABLE_THROUGHPUT_IN_COLUMN_NAME);

                                        if (throughputInputStats != null)
                                        {
                                            minThroughputIn = throughputInputStats[0];
                                            maxThroughputIn = throughputInputStats[1];
                                            avgThroughputIn = throughputInputStats[2];
                                        }
                                        StatisticTableKPIValues.kpiId = kpiId;
                                        StatisticTableKPIValues.kpiName = kpiName;
                                        StatisticTableKPIValues.totalValue = -1;
                                        StatisticTableKPIValues.totalValueUnitName = GlobalNames.BHS_STATS_UNIT_NAME_BAG;
                                        StatisticTableKPIValues.minValue = Math.Round(minThroughputIn, 2);
                                        StatisticTableKPIValues.avgValue = Math.Round(avgThroughputIn, 2);
                                        StatisticTableKPIValues.maxValue = Math.Round(maxThroughputIn, 2);
                                        StatisticTableKPIValues.maxLevel1Value = -1;
                                        StatisticTableKPIValues.maxLevel2Value = -1;
                                        StatisticTableKPIValues.maxLevel3Value = -1;
                                        StatisticTableKPIValues.unitName = GlobalNames.BHS_STATS_UNIT_NAME_BAGS_PER_HOUR;
                                    }
                                }
                                if (kpiName.Equals(GlobalNames.BHS_KPI_NAME_THROUGHPUT_INSTANT_INPUT))  // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS) C#9 Instant Throughput KPIs
                                {
                                    double minThroughputIn = -1;
                                    double avgThroughputIn = -1;
                                    double maxThroughputIn = -1;

                                    if (occupationTable.Columns.IndexOf(GlobalNames.OCCUPATION_TABLE_THROUGHPUT_INSTANT_IN_COLUMN_NAME) != -1)
                                    {
                                        Double[] throughputInputStats
                                            = DataFunctions.GetStatColumn(occupationTable, GlobalNames.OCCUPATION_TABLE_THROUGHPUT_INSTANT_IN_COLUMN_NAME);

                                        if (throughputInputStats != null)
                                        {
                                            minThroughputIn = throughputInputStats[0];
                                            maxThroughputIn = throughputInputStats[1];
                                            avgThroughputIn = throughputInputStats[2];
                                        }
                                        StatisticTableKPIValues.kpiId = kpiId;
                                        StatisticTableKPIValues.kpiName = kpiName;
                                        StatisticTableKPIValues.totalValue = -1;
                                        StatisticTableKPIValues.totalValueUnitName = GlobalNames.BHS_STATS_UNIT_NAME_BAG;
                                        StatisticTableKPIValues.minValue = Math.Round(minThroughputIn, 2);
                                        StatisticTableKPIValues.avgValue = Math.Round(avgThroughputIn, 2);
                                        StatisticTableKPIValues.maxValue = Math.Round(maxThroughputIn, 2);
                                        StatisticTableKPIValues.maxLevel1Value = -1;
                                        StatisticTableKPIValues.maxLevel2Value = -1;
                                        StatisticTableKPIValues.maxLevel3Value = -1;
                                        StatisticTableKPIValues.unitName = GlobalNames.BHS_STATS_UNIT_NAME_BAGS_PER_HOUR;
                                    }
                                }

                                if (kpiName.Equals(GlobalNames.BHS_KPI_NAME_THROUGHPUT_OUTPUT))
                                {
                                    double minThroughputOut = -1;
                                    double avgThroughputOut = -1;
                                    double maxThroughputOut = -1;

                                    if (occupationTable.Columns.IndexOf(GlobalNames.BHS_OCCUPATION_TABLE_THROUGHPUT_OUT_COLUMN_NAME) != -1)
                                    {
                                        Double[] throughputOutputStats
                                            = DataFunctions.GetStatColumn(occupationTable, GlobalNames.BHS_OCCUPATION_TABLE_THROUGHPUT_OUT_COLUMN_NAME);

                                        if (throughputOutputStats != null)
                                        {
                                            minThroughputOut = throughputOutputStats[0];
                                            maxThroughputOut = throughputOutputStats[1];
                                            avgThroughputOut = throughputOutputStats[2];
                                        }
                                        StatisticTableKPIValues.kpiId = kpiId;
                                        StatisticTableKPIValues.kpiName = kpiName;
                                        StatisticTableKPIValues.totalValue = -1;
                                        StatisticTableKPIValues.totalValueUnitName = GlobalNames.BHS_STATS_UNIT_NAME_BAG;
                                        StatisticTableKPIValues.minValue = Math.Round(minThroughputOut, 2);
                                        StatisticTableKPIValues.avgValue = Math.Round(avgThroughputOut, 2);
                                        StatisticTableKPIValues.maxValue = Math.Round(maxThroughputOut, 2);
                                        StatisticTableKPIValues.maxLevel1Value = -1;
                                        StatisticTableKPIValues.maxLevel2Value = -1;
                                        StatisticTableKPIValues.maxLevel3Value = -1;
                                        StatisticTableKPIValues.unitName = GlobalNames.BHS_STATS_UNIT_NAME_BAGS_PER_HOUR;
                                    }
                                }
                                if (kpiName.Equals(GlobalNames.BHS_KPI_NAME_THROUGHPUT_INSTANT_OUTPUT)) // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS) C#9 Instant Throughput KPIs
                                {
                                    double minThroughputOut = -1;
                                    double avgThroughputOut = -1;
                                    double maxThroughputOut = -1;

                                    if (occupationTable.Columns.IndexOf(GlobalNames.OCCUPATION_TABLE_THROUGHPUT_INSTANT_OUT_COLUMN_NAME) != -1)
                                    {
                                        Double[] throughputOutputStats
                                            = DataFunctions.GetStatColumn(occupationTable, GlobalNames.OCCUPATION_TABLE_THROUGHPUT_INSTANT_OUT_COLUMN_NAME);

                                        if (throughputOutputStats != null)
                                        {
                                            minThroughputOut = throughputOutputStats[0];
                                            maxThroughputOut = throughputOutputStats[1];
                                            avgThroughputOut = throughputOutputStats[2];
                                        }
                                        StatisticTableKPIValues.kpiId = kpiId;
                                        StatisticTableKPIValues.kpiName = kpiName;
                                        StatisticTableKPIValues.totalValue = -1;
                                        StatisticTableKPIValues.totalValueUnitName = GlobalNames.BHS_STATS_UNIT_NAME_BAG;
                                        StatisticTableKPIValues.minValue = Math.Round(minThroughputOut, 2);
                                        StatisticTableKPIValues.avgValue = Math.Round(avgThroughputOut, 2);
                                        StatisticTableKPIValues.maxValue = Math.Round(maxThroughputOut, 2);
                                        StatisticTableKPIValues.maxLevel1Value = -1;
                                        StatisticTableKPIValues.maxLevel2Value = -1;
                                        StatisticTableKPIValues.maxLevel3Value = -1;
                                        StatisticTableKPIValues.unitName = GlobalNames.BHS_STATS_UNIT_NAME_BAGS_PER_HOUR;
                                    }
                                }

                                break;
                            }
                        case GlobalNames.BHS_KPI_NAME_DWELL_AREA_TIME:
                            {
                                if (dwellAreaTable == null)
                                {
                                    resultAquired = false;  //return false;
                                    break;
                                }

                                int minDwellAreaColumnIndex = dwellAreaTable.Columns.IndexOf(GlobalNames.BHS_DWELL_AREA_MIN_COLUMN_NAME);
                                int avgDwellAreaColumnIndex = dwellAreaTable.Columns.IndexOf(GlobalNames.BHS_DWELL_AREA_AVG_COLUMN_NAME);
                                int maxDwellAreaColumnIndex = dwellAreaTable.Columns.IndexOf(GlobalNames.BHS_DWELL_AREA_MAX_COLUMN_NAME);
                                int nbBagsDwellAreaColumnIndex = dwellAreaTable.Columns.IndexOf(GlobalNames.BHS_DWELL_AREA_NB_PAX_COLUMN_NAME);

                                double minDwellArea = -1;
                                double avgDwellArea = -1;
                                double maxDwellArea = -1;

                                if (minDwellAreaColumnIndex != -1 && avgDwellAreaColumnIndex != -1
                                    && maxDwellAreaColumnIndex != -1 && nbBagsDwellAreaColumnIndex != -1)
                                {
                                    Double[] minDwellAreaStats
                                        = DataFunctions.GetStatColumnIgnoreZeros(dwellAreaTable, minDwellAreaColumnIndex, nbBagsDwellAreaColumnIndex);
                                    minDwellArea = minDwellAreaStats[0];

                                    Double[] avgDwellAreaStats
                                        = DataFunctions.GetStatColumnIgnoreZeros(dwellAreaTable, avgDwellAreaColumnIndex, nbBagsDwellAreaColumnIndex);
                                    avgDwellArea = avgDwellAreaStats[2];

                                    Double[] maxDwellAreaStats
                                        = DataFunctions.GetStatColumnIgnoreZeros(dwellAreaTable, maxDwellAreaColumnIndex, nbBagsDwellAreaColumnIndex);
                                    maxDwellArea = maxDwellAreaStats[1];

                                    double maxLevel1DwellArea = -1;
                                    double maxLevel2DwellArea = -1;
                                    double maxLevel3DwellArea = -1;
                                    dwellAreaTimes.Sort();
                                    if (dwellAreaTimes.Count > 0)
                                    {
                                        maxLevel1DwellArea = OverallTools.ResultFunctions.getLevelValue(dwellAreaTimes, dFirstLevelPercent);
                                        maxLevel2DwellArea = ResultFunctions.getLevelValue(dwellAreaTimes, dSecondLevelPercent);
                                        maxLevel3DwellArea = ResultFunctions.getLevelValue(dwellAreaTimes, dThirdLevelPercent);
                                    }

                                    StatisticTableKPIValues.kpiId = kpiId;
                                    StatisticTableKPIValues.kpiName = kpiName;
                                    StatisticTableKPIValues.totalValue = Math.Round(totalDwellAreaTime, 2);
                                    StatisticTableKPIValues.totalValueUnitName = GlobalNames.BHS_STATS_UNIT_NAME_MINUTES;
                                    StatisticTableKPIValues.minValue = Math.Round(minDwellArea, 2);
                                    StatisticTableKPIValues.avgValue = Math.Round(avgDwellArea, 2);
                                    StatisticTableKPIValues.maxValue = Math.Round(maxDwellArea, 2);
                                    StatisticTableKPIValues.maxLevel1Value = Math.Round(maxLevel1DwellArea, 2);
                                    StatisticTableKPIValues.maxLevel2Value = Math.Round(maxLevel2DwellArea, 2);
                                    StatisticTableKPIValues.maxLevel3Value = Math.Round(maxLevel3DwellArea, 2);
                                    StatisticTableKPIValues.unitName = GlobalNames.BHS_STATS_UNIT_NAME_MINUTES;
                                }
                                else
                                    resultAquired = false;  //return false;                                
                                break;
                            }
                        case GlobalNames.BHS_KPI_NAME_STATION_UTILIZATION_PERCENT:
                            {
                                if (utilizationTable == null)
                                {
                                    resultAquired = false;  //return false;
                                    break;
                                }

                                int utilizationPercentColumnIndex
                                    = utilizationTable.Columns.IndexOf(GlobalNames.BHS_UTILIZATION_PERCENT_COLUMN_NAME);

                                double minUtilizationPercent = -1;
                                double avgUtilizationPercent = -1;
                                double maxUtilizationPercent = -1;

                                if (utilizationPercentColumnIndex != -1)
                                {
                                    Double[] utilizationPercentStats
                                        = DataFunctions.GetStatColumn(utilizationTable, utilizationPercentColumnIndex);
                                    minUtilizationPercent = utilizationPercentStats[0];
                                    avgUtilizationPercent = utilizationPercentStats[2];
                                    maxUtilizationPercent = utilizationPercentStats[1];

                                    StatisticTableKPIValues.kpiId = kpiId;
                                    StatisticTableKPIValues.kpiName = kpiName;
                                    StatisticTableKPIValues.totalValue = -1;
                                    StatisticTableKPIValues.totalValueUnitName = GlobalNames.BHS_STATS_UNIT_NAME_PERCENTAGE;
                                    StatisticTableKPIValues.minValue = Math.Round(minUtilizationPercent, 2);
                                    StatisticTableKPIValues.avgValue = Math.Round(avgUtilizationPercent, 2);
                                    StatisticTableKPIValues.maxValue = Math.Round(maxUtilizationPercent, 2);
                                    StatisticTableKPIValues.maxLevel1Value = -1;
                                    StatisticTableKPIValues.maxLevel2Value = -1;
                                    StatisticTableKPIValues.maxLevel3Value = -1;
                                    StatisticTableKPIValues.unitName = GlobalNames.BHS_STATS_UNIT_NAME_PERCENTAGE;
                                }
                                else
                                    resultAquired = false;  //return false;
                                break;
                            }
                        case GlobalNames.BHS_KPI_NAME_STATION_NEED:
                            {
                                if (utilizationTable == null)
                                {
                                    resultAquired = false;  //return false;
                                    break;
                                }

                                int stationNeedColumnIndex
                                    = utilizationTable.Columns.IndexOf(GlobalNames.BHS_UTILIZATION_STATION_NEED_COLUMN_NAME);

                                double minStationNeed = -1;
                                double avgStationNeed = -1;
                                double maxStationNeed = -1;

                                if (stationNeedColumnIndex != -1)
                                {
                                    Double[] utilizationStationNeedStats
                                        = DataFunctions.GetStatColumn(utilizationTable, stationNeedColumnIndex);
                                    minStationNeed = utilizationStationNeedStats[0];
                                    avgStationNeed = utilizationStationNeedStats[2];
                                    maxStationNeed = utilizationStationNeedStats[1];

                                    StatisticTableKPIValues.kpiId = kpiId;
                                    StatisticTableKPIValues.kpiName = kpiName;
                                    StatisticTableKPIValues.totalValue = -1;
                                    StatisticTableKPIValues.totalValueUnitName = GlobalNames.BHS_STATS_UNIT_NAME_STATION;
                                    StatisticTableKPIValues.minValue = Math.Round(minStationNeed, 2);
                                    StatisticTableKPIValues.avgValue = Math.Round(avgStationNeed, 2);
                                    StatisticTableKPIValues.maxValue = Math.Round(maxStationNeed, 2);
                                    StatisticTableKPIValues.maxLevel1Value = -1;
                                    StatisticTableKPIValues.maxLevel2Value = -1;
                                    StatisticTableKPIValues.maxLevel3Value = -1;
                                    StatisticTableKPIValues.unitName = GlobalNames.BHS_STATS_UNIT_NAME_STATION;
                                }
                                else
                                    resultAquired = false;  //return false;
                                break;
                            }
                        default:
                            {
                                resultAquired = false;
                                break;
                            }
                    }
                    return resultAquired;
                }

                private bool addNewRowToDashboardStatisticsTable(DataTable statisticTable)
                {
                    DataRow row = statisticTable.NewRow();

                    if (checkRowValidity())
                    {
                        row[StatisticTableColumnIndexes.kpiIdColumnIndex] = StatisticTableKPIValues.kpiId;
                        row[StatisticTableColumnIndexes.kpiNameColumnIndex] = StatisticTableKPIValues.kpiName;
                        if (StatisticTableKPIValues.totalValue > -1)
                        {
                            row[StatisticTableColumnIndexes.totalValueColumnIndex] = StatisticTableKPIValues.totalValue;
                            row[StatisticTableColumnIndexes.totalValueUnitColumnIndex] = StatisticTableKPIValues.totalValueUnitName;
                        }
                        if (StatisticTableKPIValues.minValue > -1)
                        {
                            row[StatisticTableColumnIndexes.minValueColumnIndex] = StatisticTableKPIValues.minValue;
                        }
                        if (StatisticTableKPIValues.avgValue > -1)
                        {
                            row[StatisticTableColumnIndexes.avgValueColumnIndex] = StatisticTableKPIValues.avgValue;
                        }
                        if (StatisticTableKPIValues.maxValue > -1)
                        {
                            row[StatisticTableColumnIndexes.maxValueColumnIndex] = StatisticTableKPIValues.maxValue;
                        }
                        if (StatisticTableKPIValues.maxLevel1Value > -1)
                        {
                            row[StatisticTableColumnIndexes.maxLevel1ValueColumnIndex] = StatisticTableKPIValues.maxLevel1Value;
                        }
                        if (StatisticTableKPIValues.maxLevel2Value > -1)
                        {
                            row[StatisticTableColumnIndexes.maxLevel2ValueColumnIndex] = StatisticTableKPIValues.maxLevel2Value;
                        }
                        if (StatisticTableKPIValues.maxLevel3Value > -1)
                        {
                            row[StatisticTableColumnIndexes.maxLevel3ValueColumnIndex] = StatisticTableKPIValues.maxLevel3Value;
                        }
                        row[StatisticTableColumnIndexes.unitColumnIndex] = StatisticTableKPIValues.unitName;

                        statisticTable.Rows.Add(row);
                        statisticTable.AcceptChanges();
                    }
                    else
                    {
                        return false;
                    }
                    return true;

                }

                private bool checkRowValidity()
                {
                    bool rowIndexesValid = false;
                    bool rowDataValid = false;

                    if (StatisticTableColumnIndexes.kpiIdColumnIndex != -1 && StatisticTableColumnIndexes.kpiNameColumnIndex != -1
                        && StatisticTableColumnIndexes.totalValueColumnIndex != -1 && StatisticTableColumnIndexes.minValueColumnIndex != -1
                        && StatisticTableColumnIndexes.avgValueColumnIndex != -1 || StatisticTableColumnIndexes.maxValueColumnIndex != -1
                        && StatisticTableColumnIndexes.maxLevel1ValueColumnIndex != -1 && StatisticTableColumnIndexes.maxLevel2ValueColumnIndex != -1
                        && StatisticTableColumnIndexes.maxLevel3ValueColumnIndex != -1 && StatisticTableColumnIndexes.unitColumnIndex != -1)
                    {
                        rowIndexesValid = true;
                    }

                    if (StatisticTableKPIValues.totalValue >= 0 &&
                        (StatisticTableKPIValues.minValue < 0 && StatisticTableKPIValues.avgValue < 0 && StatisticTableKPIValues.maxValue < 0
                        || StatisticTableKPIValues.maxLevel1Value < 0 && StatisticTableKPIValues.maxLevel2Value < 0 && StatisticTableKPIValues.maxLevel3Value < 0))
                    {
                        rowDataValid = true;
                    }

                    if (StatisticTableKPIValues.totalValue >= 0 && StatisticTableKPIValues.minValue >= 0 && StatisticTableKPIValues.avgValue >= 0
                        && StatisticTableKPIValues.maxValue >= 0 && StatisticTableKPIValues.maxLevel1Value >= 0 && StatisticTableKPIValues.maxLevel2Value >= 0
                        && StatisticTableKPIValues.maxLevel3Value >= 0)
                    {
                        rowDataValid = true;
                    }
                    if (StatisticTableKPIValues.totalValue >= 0 && StatisticTableKPIValues.minValue >= 0 && StatisticTableKPIValues.avgValue >= 0
                        && StatisticTableKPIValues.maxValue >= 0
                        && StatisticTableKPIValues.maxLevel1Value < 0 && StatisticTableKPIValues.maxLevel2Value < 0 && StatisticTableKPIValues.maxLevel3Value < 0)
                    {
                        rowDataValid = true;
                    }

                    if (StatisticTableKPIValues.totalValue < 0
                        && StatisticTableKPIValues.minValue >= 0 && StatisticTableKPIValues.avgValue >= 0 && StatisticTableKPIValues.maxValue >= 0
                        && StatisticTableKPIValues.maxLevel1Value < 0 && StatisticTableKPIValues.maxLevel2Value < 0 && StatisticTableKPIValues.maxLevel3Value < 0)
                    {
                        rowDataValid = true;
                    }

                    return rowIndexesValid && rowDataValid;
                }

                private bool getMeaningfulTimeUsingAdequateTimeUnit(double currentTimeValue,
                    String currentTimeUnitName, out double timeValue, out String newTimeUnitName)
                {
                    timeValue = -1;
                    newTimeUnitName = "";

                    if (currentTimeUnitName.Equals(GlobalNames.BHS_STATS_UNIT_NAME_SECONDS))
                    {
                        if (currentTimeValue > -1)
                        {
                            if (currentTimeValue >= 60 && currentTimeValue <= 3600)
                            {
                                newTimeUnitName = GlobalNames.BHS_STATS_UNIT_NAME_MINUTES;
                                timeValue = currentTimeValue / 60.0;
                            }
                            else if (currentTimeValue > 3600)
                            {
                                newTimeUnitName = GlobalNames.BHS_STATS_UNIT_NAME_HOURS;
                                timeValue = currentTimeValue / 3600.0;
                            }
                        }
                    }
                    else if (currentTimeUnitName.Equals(GlobalNames.BHS_STATS_UNIT_NAME_MINUTES))
                    {
                        if (currentTimeValue > -1)
                        {
                            if (currentTimeValue >= 60)
                            {
                                newTimeUnitName = GlobalNames.BHS_STATS_UNIT_NAME_HOURS;
                                timeValue = currentTimeValue / 60.0;
                            }
                        }
                    }

                    if (timeValue < 0 || newTimeUnitName == "")
                    {
                        return false;
                    }
                    return true;
                }
                // << Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard

                public DataTable getStatistics(Double dWarmUp,
                                               DateTime simulationStartDate,    // >> Task #10926 Pax2Sim - BHS analysis - Filter period proble
                                               DateTime simulationEndDate)      // >> Task #10926 Pax2Sim - BHS analysis - Filter period proble
                {
                    DataTable dtResults = new DataTable(sStationName + "_Statistics");
                    dtResults.Columns.Add("Type", typeof(String));
                    dtResults.Columns.Add("Value", typeof(Double));
                    dtResults.Columns.Add("Unit", typeof(String));
                    Double[] tdResults = new double[9];
                    //Number of bags
                    //Stopped bags
                    //Stopped bags after desk.
                    //Min
                    //Average
                    //Max
                    //Travel min
                    //Travel Average
                    //Travel max
                    tdResults[0] = 0;
                    tdResults[1] = 0;
                    tdResults[2] = 0;
                    tdResults[3] = -1;
                    tdResults[4] = 0;
                    tdResults[5] = 0;
                    tdResults[6] = -1;
                    tdResults[7] = 0;
                    tdResults[8] = 0;
                    ArrayList alTravelTimes = new ArrayList();
                    bool invalidTravelTime = false;
                    for (int i = 0; i < alStationUse.Count; i++)
                    {
                        Result rResult = (Result)alStationUse[i];
                        if (rResult.ArrivingTime < dWarmUp)
                            continue;
                        if (rResult.Stopped)
                        {
                            tdResults[1]++;
                            continue;
                        }

                        // >> Task #10926 Pax2Sim - BHS analysis - Filter period proble
                        TimeSpan simulationDuration = simulationEndDate.Subtract(simulationStartDate);
                        if (rResult.ArrivingTime > simulationDuration.TotalMinutes)
                        {
                            continue;
                        }
                        // << Task #10926 Pax2Sim - BHS analysis - Filter period problem

                        tdResults[0]++;
                        Double dTime = rResult.OccupationTime;
                        if (StationType == sICS)    // >> Bug #15291 Pax2Sim - BHS Analysis - _Times statistics From Entry to Exit                        
                            dTime = rResult.getICSsOccupationTime(baggageResultsDictionary);

                        if ((dTime < tdResults[3]) || (tdResults[3] == -1))
                            tdResults[3] = dTime;
                        if (dTime > tdResults[5])
                            tdResults[5] = dTime;
                        tdResults[4] += dTime;
                        if (rResult.TravelTime == -1)
                        {
                            tdResults[2]++;
                            continue;
                        }
                        if (rResult.TravelTime < 0) // >> Task #14844 Pax2Sim - BHS trace - ICS throughput in global stats
                        {
                            invalidTravelTime = true;
                        }
                        dTime = rResult.TravelTime;
                        alTravelTimes.Add(dTime);
                        if ((dTime < tdResults[6]) || (tdResults[6] == -1))
                            tdResults[6] = dTime;
                        if (dTime > tdResults[8])
                            tdResults[8] = dTime;
                        tdResults[7] += dTime;
                    }
                    if (tdResults[0] != 0)
                    {
                        tdResults[4] = tdResults[4] / tdResults[0];
                        if (tdResults[8] > 0)
                            tdResults[7] = tdResults[7] / (tdResults[0] - tdResults[2]);

                    }
                    else
                    {
                        tdResults[3] = 0;
                        tdResults[6] = 0;
                    }
                    String sType = "Bags";
                    if (StationType == sPersonalParking)
                        sType = "Cars";

                    if (invalidTravelTime)
                    {
                        tdResults[8] = -1;
                        tdResults[7] = -1;
                        tdResults[6] = -1;
                    }

                    dtResults.Rows.Add(new Object[] { "Total number of bags", tdResults[0], sType });
                    dtResults.Rows.Add(new Object[] { "Total number of stopped bags", Math.Round(tdResults[1], 2), sType });
                    dtResults.Rows.Add(new Object[] { "Total number of stopped bags after the desk", Math.Round(tdResults[2], 2), sType });
                    if (!TimeNull)
                    {
                        dtResults.Rows.Add(new Object[] { "Minimum processing time", Math.Round(tdResults[3], 2), "Minutes" });
                        dtResults.Rows.Add(new Object[] { "Average processing time", Math.Round(tdResults[4], 2), "Minutes" });
                        dtResults.Rows.Add(new Object[] { "Maximum processing time", Math.Round(tdResults[5], 2), "Minutes" });
                    }

                    if (dFirstLevel != -1)
                    {
                        dtResults.Rows.Add(new Object[] { "Processing time " + dFirstLevelPercent + " %", Math.Round(dFirstLevel, 2), sUnit });
                        dtResults.Rows.Add(new Object[] { "Processing time " + dSecondLevelPercent + " %", Math.Round(dSecondLevel, 2), sUnit });
                        dtResults.Rows.Add(new Object[] { "Processing time " + dThirdLevelPercent + " %", Math.Round(dThirdLevel, 2), sUnit });
                    }
                    //<< issue Fixed - BHS Queue Stats not detailed as Desk: Commented
                    //if (tdResults[8] > 0 
                    //    || invalidTravelTime)   // >> Task #14844 Pax2Sim - BHS trace - ICS throughput in global stats
                    //{
                    //>> issue Fixed - BHS Queue Stats not detailed as Desk: Commented
                    dtResults.Rows.Add(new Object[] { "Minimum travel time", Math.Round(tdResults[6], 2), "Minutes" });
                    dtResults.Rows.Add(new Object[] { "Average travel time", Math.Round(tdResults[7], 2), "Minutes" });
                    dtResults.Rows.Add(new Object[] { "Maximum travel time", Math.Round(tdResults[8], 2), "Minutes" });
                    if (alTravelTimes.Count > 0)
                    {
                        if (tdResults[8] <= 0
                    //<< issue Fixed - BHS Queue Stats not detailed as Desk: Added
                    || invalidTravelTime)
                        //>> issue Fixed - BHS Queue Stats not detailed as Desk: Added
                        {
                            dtResults.Rows.Add(new Object[] { "Travel time " + dFirstLevelPercent + " %", -1, "Minutes" });
                            dtResults.Rows.Add(new Object[] { "Travel time " + dSecondLevelPercent + " %", -1, "Minutes" });
                            dtResults.Rows.Add(new Object[] { "Travel time " + dThirdLevelPercent + " %", -1, "Minutes" });
                        }
                        else
                        {
                            alTravelTimes.Sort();
                            dtResults.Rows.Add(new Object[] { "Travel time " + dFirstLevelPercent + " %", Math.Round(ResultFunctions.getLevelValue(alTravelTimes, dFirstLevelPercent), 2), "Minutes" });
                            dtResults.Rows.Add(new Object[] { "Travel time " + dSecondLevelPercent + " %", Math.Round(ResultFunctions.getLevelValue(alTravelTimes, dSecondLevelPercent), 2), "Minutes" });
                            dtResults.Rows.Add(new Object[] { "Travel time " + dThirdLevelPercent + " %", Math.Round(ResultFunctions.getLevelValue(alTravelTimes, dThirdLevelPercent), 2), "Minutes" });
                        }
                        //<< issue Fixed - BHS Queue Stats not detailed as Desk: Commented
                        //}
                        //>> issue Fixed - BHS Queue Stats not detailed as Desk: Commented
                    }
                    // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS) C#9 Instant Throughput KPIs                    
                    if (dMinThroughputInput != -1 && dAverageThroughputInput != -1 && dMaxThroughputInput != -1)
                    {
                        dtResults.Rows.Add(new Object[] { "Min throughput input", Math.Round(dMinThroughputInput, 2), sType + "/h" });
                        dtResults.Rows.Add(new Object[] { "Average throughput input", Math.Round(dAverageThroughputInput, 2), sType + "/h" });
                        dtResults.Rows.Add(new Object[] { "Max throughput input", Math.Round(dMaxThroughputInput, 2), sType + "/h" });
                    }
                    if (dMinInstantThroughputInput != -1 && dAverageInstantThroughputInput != -1 && dMaxInstantThroughputInput != -1)
                    {
                        dtResults.Rows.Add(new Object[] { "Min instant throughput input", Math.Round(dMinInstantThroughputInput, 2), sType + "/h" });
                        dtResults.Rows.Add(new Object[] { "Average instant throughput input", Math.Round(dAverageInstantThroughputInput, 2), sType + "/h" });
                        dtResults.Rows.Add(new Object[] { "Max instant throughput input", Math.Round(dMaxInstantThroughputInput, 2), sType + "/h" });
                    }
                    if (dMinThroughputOutput != -1 && dAverageThroughputOutput != -1 && dMaxThroughputOutput != -1)
                    {
                        dtResults.Rows.Add(new Object[] { "Min throughput output", Math.Round(dMinThroughputOutput, 2), sType + "/h" });
                        dtResults.Rows.Add(new Object[] { "Average throughput output", Math.Round(dAverageThroughputOutput, 2), sType + "/h" });
                        dtResults.Rows.Add(new Object[] { "Max throughput output", Math.Round(dMaxThroughputOutput, 2), sType + "/h" });
                    }
                    if (dMinInstantThroughputOutput != -1 && dAverageInstantThroughputOutput != -1 && dMaxInstantThroughputOutput != -1)
                    {
                        dtResults.Rows.Add(new Object[] { "Min instant throughput output", Math.Round(dMinInstantThroughputOutput, 2), sType + "/h" });
                        dtResults.Rows.Add(new Object[] { "Average instant throughput output", Math.Round(dAverageInstantThroughputOutput, 2), sType + "/h" });
                        dtResults.Rows.Add(new Object[] { "Max instant throughput output", Math.Round(dMaxInstantThroughputOutput, 2), sType + "/h" });
                    }
                    // << Task #14902 Improve Dynamic Occupation tables (PAX & BHS) C#9 Instant Throughput KPIs

                    if (dAverageAverage != -1)
                    {
                        dtResults.Rows.Add(new Object[] { "Min Average", Math.Round(dMinAverage, 2), sType });
                        dtResults.Rows.Add(new Object[] { "Average Average", Math.Round(dAverageAverage, 2), sType });
                        dtResults.Rows.Add(new Object[] { "Max Average", Math.Round(dMaxAverage, 2), sType });
                    }
                    if (dAverageMax != -1)
                    {
                        dtResults.Rows.Add(new Object[] { "Min Max", Math.Round(dMinMax, 2), sType });
                        dtResults.Rows.Add(new Object[] { "Average Max", Math.Round(dAverageMax, 2), sType });
                        dtResults.Rows.Add(new Object[] { "Max Max", Math.Round(dMaxMax, 2), sType });
                    }
                    return dtResults;
                }

                public DataTable getDistribution(Double dStep, int iNbClasses, Double dWarmUp,
                    DateTime dtBegin, DateTime dtEnd, double samplingStep)   // >> Task #10926 Pax2Sim - BHS analysis - Filter period problem
                {
                    return getDistribution(false, dStep, iNbClasses, dWarmUp, dtBegin, dtEnd, samplingStep);
                }

                public DataTable getDistribution(bool bTravelTimes, Double dStep, int iNbClasses, Double dWarmUp,
                    DateTime simulationStartDate, DateTime simulationEndDate, double samplingStep)   // >> Task #10926 Pax2Sim - BHS analysis - Filter period problem
                {
                    dFirstLevel = -1;
                    dSecondLevel = -1;
                    dThirdLevel = -1;

                    sUnit = "Minutes";
                    Double dCoeff = 1;
                    if ((StationType == OriginatingTransferSorterInduction)
                        || (StationType == OriginatingTransferHBS1)
                        || (StationType == OriginatingTransferHBS2)
                        || (StationType == OriginatingTransferHBS3)
                        || (StationType == OriginatingTransferHBS4)
                        || (StationType == OriginatingTransferChute)
                        || (StationType == sICSToploader || StationType == sNewICSToploader) || (StationType == sICSUnloader))   // >> Task #10372 Pax2Sim - BHS - waiting time per period of time for ICS-Toploader
                    {
                        sUnit = "Seconds";
                        dCoeff = 60;
                        dStep = 1;
                    }

                    if ((StationType == OriginatingTransferEBS) ||
                        (StationType == sPersonalParking))
                    {
                        if (PAX2SIM.cdgMode)
                        {
                            dStep = samplingStep;
                            iNbClasses = 30;
                        }
                        else
                        {
                            sUnit = "Hours";
                            dCoeff = 1.0 / 60.0;
                            dStep = 1;
                            iNbClasses = 14;
                        }
                    }
                    String sType = "Nb Bags";
                    if (this.StationType == sPersonalParking)
                        sType = "Nb Cars";
                    DataTable dtResult = ResultFunctions.BuildClassTable(sStationName + "_Distribution", dStep, iNbClasses, 0, sUnit, new string[] { sType });
                    if (dtResult == null)
                        return null;
                    Double dValue;
                    int iNbBaggage = 0;
                    //Variable qui permet de déterminer les valeurs à x%
                    ArrayList alTimes = new ArrayList();
                    for (int i = 0; i < alStationUse.Count; i++)
                    {
                        Result rResult = (Result)alStationUse[i];

                        if (rResult.ArrivingTime < dWarmUp)
                            continue;
                        if (rResult.Stopped)
                            continue;

                        // >> Task #10926 Pax2Sim - BHS analysis - Filter period problem
                        TimeSpan simulationDuration = simulationEndDate.Subtract(simulationStartDate);
                        if (rResult.ArrivingTime > simulationDuration.TotalMinutes)
                        {
                            continue;
                        }
                        // << Task #10926 Pax2Sim - BHS analysis - Filter period problem

                        iNbBaggage++;
                        if (bTravelTimes)
                            dValue = rResult.TravelTime;
                        else
                            dValue = rResult.OccupationTime;
                        dValue = dValue * dCoeff;
                        alTimes.Add(dValue);
                        int iIndex = ResultFunctions.DetermineClass(dValue, dStep, iNbClasses);
                        dtResult.Rows[iIndex][1] = (int)dtResult.Rows[iIndex][1] + 1;
                    }
                    alTimes.Sort();
                    if (alTimes.Count > 0)
                    {
                        dFirstLevel = OverallTools.ResultFunctions.getLevelValue(alTimes, dFirstLevelPercent);
                        dSecondLevel = ResultFunctions.getLevelValue(alTimes, dSecondLevelPercent);
                        dThirdLevel = ResultFunctions.getLevelValue(alTimes, dThirdLevelPercent);
                    }

                    //On calcul les pourcentages et le cumul des pourcentages.
                    dtResult.Columns.Add("Distrib. (%)", typeof(Double));
                    dtResult.Columns.Add("Cumul (%)", typeof(Double));
                    Double cumul = 0;
                    foreach (DataRow drTheLine in dtResult.Rows)
                    {
                        if (iNbBaggage == 0)
                        {
                            drTheLine[2] = 0;
                            drTheLine[3] = 0;
                        }
                        else
                        {
                            drTheLine[2] = Math.Round(((float)((int)drTheLine[1]) / (float)(iNbBaggage)) * 100, 2);
                            cumul += (Double)drTheLine[2];
                            drTheLine[3] = Math.Round(cumul, 2);
                        }
                    }
                    return dtResult;
                }

                public DataTable getDistribution_tbdev(bool bTravelTimes, Double dStep, int iNbClasses, Double dWarmUp,
                    DateTime simulationStartDate, DateTime simulationEndDate, double samplingStep)   // >> Task #10926 Pax2Sim - BHS analysis - Filter period problem
                {
                    dFirstLevel = -1;
                    dSecondLevel = -1;
                    dThirdLevel = -1;

                    sUnit = "Minutes";
                    Double dCoeff = 1;
                    if ((StationType == OriginatingTransferSorterInduction)
                        || (StationType == OriginatingTransferHBS1)
                        || (StationType == OriginatingTransferHBS2)
                        || (StationType == OriginatingTransferHBS3)
                        || (StationType == OriginatingTransferHBS4)
                        || (StationType == OriginatingTransferChute)
                        || (StationType == sICSToploader || StationType == sNewICSToploader) || (StationType == sICSUnloader))
                    {
                        sUnit = "Seconds";
                        dCoeff = 60;
                        dStep = 1;
                    }

                    if ((StationType == OriginatingTransferEBS) ||
                        (StationType == sPersonalParking))
                    {
                        if (PAX2SIM.cdgMode)
                        {
                            dStep = samplingStep;
                            iNbClasses = 30;
                        }
                        else
                        {
                            sUnit = "Hours";
                            dCoeff = 1.0 / 60.0;
                            dStep = 1;
                            iNbClasses = 14;
                        }
                    }
                    String sType = "Nb Bags";
                    if (this.StationType == sPersonalParking)
                        sType = "Nb Cars";
                    int totalBagsNb = 0;
                    double value = 0;
                    ArrayList alTimes = new ArrayList();
                    for (int i = 0; i < alStationUse.Count; i++)
                    {
                        Result rResult = (Result)alStationUse[i];

                        if (rResult.ArrivingTime < dWarmUp)
                            continue;
                        if (rResult.Stopped)
                            continue;

                        TimeSpan simulationDuration = simulationEndDate.Subtract(simulationStartDate);
                        if (rResult.ArrivingTime > simulationDuration.TotalMinutes)
                            continue;

                        if (bTravelTimes)
                            value = rResult.TravelTime;
                        else
                            value = rResult.OccupationTime;
                        value = value * dCoeff;
                        alTimes.Add(value);
                        totalBagsNb++;
                    }
                    alTimes.Sort();

                    if (alTimes.Count > 0)
                    {
                        int maxValueFromMajority = (int)Math.Ceiling(OverallTools.ResultFunctions.getLevelValue(alTimes, 99.0));
                        iNbClasses = maxValueFromMajority;//(maxValueFromMajority / 2) + 2;
                    }
                    DataTable dtResult = ResultFunctions.BuildClassTable(sStationName + "_Distribution", dStep, iNbClasses, 0, sUnit, new string[] { sType });
                    if (dtResult == null)
                        return null;

                    for (int i = 0; i < alTimes.Count; i++)
                    {
                        value = (double)alTimes[i];
                        int index = ResultFunctions.DetermineClass(value, dStep, iNbClasses);
                        dtResult.Rows[index][1] = (int)dtResult.Rows[index][1] + 1;
                    }

                    if (alTimes.Count > 0)
                    {
                        dFirstLevel = OverallTools.ResultFunctions.getLevelValue(alTimes, dFirstLevelPercent);
                        dSecondLevel = ResultFunctions.getLevelValue(alTimes, dSecondLevelPercent);
                        dThirdLevel = ResultFunctions.getLevelValue(alTimes, dThirdLevelPercent);
                    }

                    //On calcul les pourcentages et le cumul des pourcentages.
                    dtResult.Columns.Add("Distrib. (%)", typeof(Double));
                    dtResult.Columns.Add("Cumul (%)", typeof(Double));
                    Double cumul = 0;
                    foreach (DataRow drTheLine in dtResult.Rows)
                    {
                        if (totalBagsNb == 0)
                        {
                            drTheLine[2] = 0;
                            drTheLine[3] = 0;
                        }
                        else
                        {
                            drTheLine[2] = Math.Round(((float)((int)drTheLine[1]) / (float)(totalBagsNb)) * 100, 2);
                            cumul += (Double)drTheLine[2];
                            drTheLine[3] = Math.Round(cumul, 2);
                        }
                    }
                    return dtResult;
                }

                public DataTable getMinMaxSorterOccupation_initial(DateTime dtBegin, DateTime dtEnd, Double dStep, Double dWarmUp,
                    Double analysisRange)   // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                {
                    if (StationType == sPersonalParking)
                        return getMinMaxQueueOccupation(dtBegin, dtEnd, dStep, dWarmUp, analysisRange); // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                    if (StationType != OriginatingTransferSorterName
                        && StationType != sICS) // && StationType != sICSToploader && StationType != sICSUnloader && StationType != sICSRecirc)   // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader  // >> Task #10372 Pax2Sim - BHS - waiting time per period of time for ICS-Toploader(comment)
                        return null;
                    OverallTools.ExternFunctions.PrintLogFile(StationType + " : " + "own chute times calculation start");
                    ArrayList alTimes = new ArrayList();
                    foreach (Result rValues in alStationUse)
                        alTimes.Add(new PointF((float)Math.Round(rValues.LeavingTime, 2), (float)Math.Floor(rValues.TravelTime * 100) / 100));
                    OverallTools.ExternFunctions.PrintLogFile(StationType + " : " + "own chute times calculation end");
                    String sType = "Nb Bags";
                    if (this.StationType == sPersonalParking)
                        sType = "Nb Cars";
                    DataTable dtOccupation = ResultFunctions.CalcQueueOccupation(sStationName + "_Occupation", alTimes,
                        dtBegin, dtEnd, dStep, sType, true, true, analysisRange);   // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                    UpdateThroughput(dtOccupation, dWarmUp);
                    return dtOccupation;
                }

                public DataTable getMinMaxSorterOccupation_V1(DateTime dtBegin, DateTime dtEnd, Double dStep, Double dWarmUp,
                    Double analysisRange)   // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                {
                    if (StationType == sPersonalParking)
                        return getMinMaxQueueOccupation(dtBegin, dtEnd, dStep, dWarmUp, analysisRange); // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                    if (StationType != OriginatingTransferSorterName
                        && StationType != sICS) // && StationType != sICSToploader && StationType != sICSUnloader && StationType != sICSRecirc)   // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader  // >> Task #10372 Pax2Sim - BHS - waiting time per period of time for ICS-Toploader(comment)
                        return null;
                    OverallTools.ExternFunctions.PrintLogFile(StationType + " : " + "own chute times calculation start");
                    ArrayList alTimes = new ArrayList();
                    foreach (Result rValues in alStationUse)
                    {
                        double startTime = rValues.LeavingTime;
                        double travelTime = 0;
                        double chuteArrivingTime = 0;

                        foreach (BaggageResult br in baggageResults)
                        {
                            if (br.IDBag == rValues.bagId)
                            {
                                foreach (BaggageDesk bd in br.alBaggageWay)
                                {
                                    if (bd.DeskType == "Chute" && bd.GroupIndex == rValues.stationGroupIndex)
                                    {
                                        if (bd.ArrivingTime > chuteArrivingTime)
                                            chuteArrivingTime = bd.ArrivingTime;
                                    }
                                }
                                break;
                            }
                        }
                        if (chuteArrivingTime >= rValues.LeavingTime)
                            travelTime = chuteArrivingTime - rValues.LeavingTime;
                        else
                        {
                            if (chuteArrivingTime > 0)
                            {
                                OverallTools.ExternFunctions.PrintLogFile("Last Chute arriving time (" + chuteArrivingTime + ") < "
                                    + StationType + " leaving time (" + rValues.LeavingTime + ")");
                            }
                        }

                        alTimes.Add(new PointF((float)Math.Round(startTime, 2), (float)Math.Floor(travelTime * 100) / 100));
                    }
                    OverallTools.ExternFunctions.PrintLogFile(StationType + " : " + "own chute times calculation end");

                    String sType = "Nb Bags";
                    if (this.StationType == sPersonalParking)
                        sType = "Nb Cars";
                    DataTable dtOccupation = ResultFunctions.CalcQueueOccupation(sStationName + "_Occupation", alTimes,
                        dtBegin, dtEnd, dStep, sType, true, true, analysisRange);   // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                    UpdateThroughput(dtOccupation, dWarmUp);
                    return dtOccupation;
                }

                public DataTable getSorterGroupingOccupation(DateTime dtBegin, DateTime dtEnd, Double dStep, Double dWarmUp,
                    Double analysisRange)   // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                {
                    if (StationType != OriginatingTransferSorterName
                        && StationType != BHS_KEYWORD_SORTER && StationType != OriginatingTransferSorterInduction && StationType != OriginatingTransferChute)
                    {
                        return null;
                    }
                    ArrayList alTimes = new ArrayList();
                    if (!hasSorterKeyword && StationType == OriginatingTransferSorterName)
                    {

                        alTimes = getTimesForSorterGroupingOccupationBasedOnSortIndAndChute();
                    }
                    else
                    {
                        alTimes = getStationTimesForOccupation();
                    }

                    String sType = "Nb Bags";
                    /*  // Sorter/ICS Occupation calculation reverted
                    DataTable dtOccupation = ResultFunctions.CalcQueueOccupation_V0(sStationName + "_Occupation", alTimes,
                        dtBegin, dtEnd, dStep, sType, true, true, analysisRange);   // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                    */
                    DataTable dtOccupation = ResultFunctions.CalcQueueOccupation(sStationName + "_Occupation", alTimes,
                        dtBegin, dtEnd, dStep, sType, true, true, analysisRange);
                    UpdateThroughput(dtOccupation, dWarmUp);
                    return dtOccupation;
                }

                public DataTable getMinMaxSorterOccupation(DateTime dtBegin, DateTime dtEnd, Double dStep, Double dWarmUp,
                    Double analysisRange)   // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                {
                    if (StationType == sPersonalParking)
                        return getMinMaxQueueOccupation(dtBegin, dtEnd, dStep, dWarmUp, analysisRange); // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                    if (StationType != OriginatingTransferSorterName
                        && StationType != BHS_KEYWORD_SORTER && StationType != BHS_KEYWORD_ICS
                        && StationType != sICS // && StationType != sICSToploader && StationType != sICSUnloader && StationType != sICSRecirc)   // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader  // >> Task #10372 Pax2Sim - BHS - waiting time per period of time for ICS-Toploader(comment)
                        && StationType != sICSToploader && StationType != sICSUnloader && StationType != sNewICSToploader)
                    {
                        return null;
                    }

                    if ((hasSortIndKeyword && StationType == BHS_KEYWORD_SORTER) ||
                         (hasICSLoaderOrToploaderKeyword && StationType == BHS_KEYWORD_ICS))
                    {
                        return null;
                    }

                    //OverallTools.ExternFunctions.PrintLogFile(StationName + " : " + "own chute times calculation start");
                    ArrayList alTimes = new ArrayList();
                    if ((!hasSortIndKeyword && StationType == BHS_KEYWORD_SORTER)
                        || (!hasICSLoaderOrToploaderKeyword && StationType == BHS_KEYWORD_ICS)
                        || StationType == sICSToploader || StationType == sICSUnloader || StationType == sNewICSToploader)
                    {
                        alTimes = getStationTimesForOccupation();
                    }
                    else
                        alTimes = getStationTimesForOccupationUsingHelperStation(StationType);

                    //OverallTools.ExternFunctions.PrintLogFile(StationType + " : " + "own chute times calculation end");

                    String sType = "Nb Bags";
                    if (this.StationType == sPersonalParking)
                        sType = "Nb Cars";

                    OverallTools.ExternFunctions.PrintLogFile(StationType + " : " + "occupation alg start");
                    /*  // Sorter/ICS Occupation calculation reverted
                    DataTable dtOccupation = ResultFunctions.CalcQueueOccupation_V0(sStationName + "_Occupation", alTimes,
                        dtBegin, dtEnd, dStep, sType, true, true, analysisRange);   // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                    */
                    DataTable dtOccupation = ResultFunctions.CalcQueueOccupation(sStationName + "_Occupation", alTimes,
                        dtBegin, dtEnd, dStep, sType, true, true, analysisRange);
                    OverallTools.ExternFunctions.PrintLogFile(StationType + " : " + "occupation alg end");

                    UpdateThroughput(dtOccupation, dWarmUp);
                    return dtOccupation;
                }

                private ArrayList getStationTimesForOccupationUsingHelperStation(string StationType)
                {
                    ArrayList alTimes = new ArrayList();
                    string stationTypeForTimesInNewTrace = "";
                    string stationTypeForTimesInOldTrace = "";

                    if (StationType == OriginatingTransferSorterName)
                    {
                        stationTypeForTimesInNewTrace = BHS_KEYWORD_SORTER;
                        stationTypeForTimesInOldTrace = OriginatingTransferChute;
                    }
                    else if (StationType == sICS)
                    {
                        stationTypeForTimesInNewTrace = BHS_KEYWORD_ICS;
                        stationTypeForTimesInOldTrace = sICSUnloader;
                    }
                    foreach (Result station in alStationUse)
                    {
                        double startTime = station.LeavingTime;
                        double travelTimeToSorterExit = 0;
                        double leavingTimeFromSorter = 0;

                        if (baggageResultsDictionary.ContainsKey(station.bagId))
                        {
                            BaggageResult br = baggageResultsDictionary[station.bagId];
                            if (br != null)
                            {
                                foreach (BaggageDesk bd in br.alBaggageWay)
                                {
                                    if (bd.DeskType == stationTypeForTimesInNewTrace)   //BHS_KEYWORD_SORTER
                                    //&& bd.ArrivingTime == station.LeavingTime)    // >> Task #18306 PAX2SIM - BHS - Sorter occupation
                                    {
                                        startTime = bd.ArrivingTime;
                                        leavingTimeFromSorter = bd.LeavingTime;
                                        break;
                                    }
                                    else if (bd.DeskType == stationTypeForTimesInOldTrace   //OriginatingTransferChute 
                                        && bd.ArrivingTime >= station.LeavingTime
                                        && bd.GroupIndex == station.stationGroupIndex)
                                    {
                                        leavingTimeFromSorter = bd.ArrivingTime;
                                        break;
                                    }
                                }
                            }
                        }
                        if (leavingTimeFromSorter >= station.LeavingTime)
                            travelTimeToSorterExit = leavingTimeFromSorter - station.LeavingTime;
                        else
                        {
                            if (leavingTimeFromSorter > 0)
                            {
                                OverallTools.ExternFunctions.PrintLogFile("Last Chute arriving time (" + leavingTimeFromSorter + ") < "
                                    + StationType + " leaving time (" + station.LeavingTime + ")");
                            }
                        }

                        alTimes.Add(new PointF((float)Math.Round(startTime, 2), (float)Math.Floor(travelTimeToSorterExit * 100) / 100));
                    }
                    return alTimes;
                }

                private ArrayList getTimesForSorterGroupingOccupationBasedOnSortIndAndChute()
                {
                    ArrayList alTimes = new ArrayList();

                    foreach (Result station in alStationUse)
                    {
                        double startTime = station.LeavingTime;
                        double travelTimeToSorterExit = 0;
                        double leavingTimeFromSorter = 0;

                        if (baggageResultsDictionary.ContainsKey(station.bagId))
                        {
                            BaggageResult br = baggageResultsDictionary[station.bagId];
                            if (br != null)
                            {
                                foreach (BaggageDesk bd in br.alBaggageWay)
                                {
                                    if (bd.DeskType == OriginatingTransferChute
                                        && bd.ArrivingTime >= station.LeavingTime
                                        && bd.GroupIndex == station.stationGroupIndex)
                                    {
                                        leavingTimeFromSorter = bd.ArrivingTime;
                                        break;
                                    }
                                }
                            }
                        }
                        if (leavingTimeFromSorter >= station.LeavingTime)
                            travelTimeToSorterExit = leavingTimeFromSorter - station.LeavingTime;
                        else
                        {
                            if (leavingTimeFromSorter > 0)
                            {
                                OverallTools.ExternFunctions.PrintLogFile("Last Chute arriving time (" + leavingTimeFromSorter + ") < "
                                    + "SortInd" + " leaving time (" + station.LeavingTime + ")");
                            }
                        }

                        alTimes.Add(new PointF((float)Math.Round(startTime, 2), (float)Math.Floor(travelTimeToSorterExit * 100) / 100));
                    }
                    return alTimes;
                }

                private ArrayList getStationTimesForOccupation()
                {
                    ArrayList alTimes = new ArrayList();
                    foreach (Result station in alStationUse)
                    {
                        alTimes.Add(new PointF((float)Math.Round(station.ArrivingTime, 2), (float)Math.Round(station.LeavingTime - station.ArrivingTime, 2)));
                    }
                    return alTimes;
                }

                public DataTable getMinMaxQueueOccupation(DateTime dtBegin, DateTime dtEnd, Double dStep, Double dWarmUp,
                    Double analysisRange)   // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                {
                    ArrayList alTimes = new ArrayList();
                    foreach (Result rValues in alStationUse)
                    {
                        alTimes.Add(new PointF((float)rValues.ArrivingTime, (float)rValues.LeavingTime));
                    }
                    DataTable dtOccupation = CalcOccupationQueue(sStationName + "_Occupation", alTimes, dtBegin, dtEnd,
                        dStep, true, true, analysisRange);  // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                    UpdateThroughput(dtOccupation, dWarmUp);
                    return dtOccupation;
                }

                public DataTable getRemainingTime(DateTime dtBegin, DateTime dtEnd, Double dStep, Double dWarmUp, Double[] Levels)
                {
                    ArrayList htRemaining = new ArrayList();

                    foreach (Result rValues in alStationUse)
                    {
                        if (rValues.ArrivingTime < dWarmUp)
                            continue;
                        if (rValues.STD == -1)
                            continue;
                        htRemaining.Add(rValues.STD - rValues.LeavingTime + dDecallage);
                    }
                    String sType = "Nb Bags";
                    if (this.StationType == sPersonalParking)
                        sType = "Nb Cars";
                    if (htRemaining.Count > 0)
                    {
                        // << Task #8246 Pax2Sim - Dynamic Analysis - Bag Trace analysis - split the total time into smaller intervals
                        DataTable dtOriginatingDistribution = ResultFunctions.GenerateDistribution(sStationName + "_RemainingTime", htRemaining, 5, GlobalNames.nbTimeIntervalsForRemainingTimeTable, -dDecallage, "Minutes", new String[] { sType }, Levels, null);
                        // >> Task #8246 Pax2Sim - Dynamic Analysis - Bag Trace analysis - split the total time into smaller intervals                        
                        return dtOriginatingDistribution;
                    }
                    return null;
                }

                public DataTable getUtilisation(DateTime dtBegin, DateTime dtEnd, Double dStep, Double dWarmUp,
                    bool forGroups) // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                {
                    List<PointF> lpTmp = new List<PointF>();
                    foreach (Result rValues in alStationUse)
                    {
                        if (rValues.ArrivingTime == rValues.LeavingTime)
                            continue;
                        if (rValues.ArrivingTime < dWarmUp)
                            continue;
                        lpTmp.Add(new PointF((float)rValues.ArrivingTime, (float)rValues.LeavingTime));
                    }
                    return OverallTools.ResultFunctions.DeskOccupation(sStationName + "_Utilization", dtBegin, dtEnd, dStep, lpTmp,
                                                                            forGroups); // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                }

                // >> Task #18306 PAX2SIM - BHS - Sorter occupation
                public DataTable createProcessTimePerPeriodOfTimeTable(DateTime dtBegin, DateTime dtEnd, Double dStep, Double dWarmUp, List<double> levels,
                    out double totalDwellArea)  // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                {
                    DataTable processTimePerPeriodOfTimeTable = new DataTable(sStationName + GlobalNames.DWELL_TIME_TABLE_NAME_SUFIX);
                    if (levels == null || levels.Count != 3)
                    {
                        OverallTools.ExternFunctions.PrintLogFile("The table \"" + processTimePerPeriodOfTimeTable.TableName + "\" could not be created because the percentile levels are missing.");
                        totalDwellArea = 0;
                        return processTimePerPeriodOfTimeTable;
                    }

                    processTimePerPeriodOfTimeTable.Columns.Add("Time", typeof(DateTime));
                    processTimePerPeriodOfTimeTable.Columns.Add(GlobalNames.BHS_DWELL_AREA_MIN_COLUMN_NAME, typeof(Double));
                    processTimePerPeriodOfTimeTable.Columns.Add(GlobalNames.BHS_DWELL_AREA_AVG_COLUMN_NAME, typeof(Double));
                    processTimePerPeriodOfTimeTable.Columns.Add(GlobalNames.BHS_DWELL_AREA_MAX_COLUMN_NAME, typeof(Double));
                    processTimePerPeriodOfTimeTable.Columns.Add("Nb Bags", typeof(Int32));

                    int firstLevelColumnIndex = processTimePerPeriodOfTimeTable.Columns.Count;
                    processTimePerPeriodOfTimeTable.Columns.Add(levels[0].ToString() + " % (mn)", typeof(Double));
                    int secondLevelColumnIndex = processTimePerPeriodOfTimeTable.Columns.Count;
                    processTimePerPeriodOfTimeTable.Columns.Add(levels[1].ToString() + " % (mn)", typeof(Double));
                    int thirdLevelColumnIndex = processTimePerPeriodOfTimeTable.Columns.Count;
                    processTimePerPeriodOfTimeTable.Columns.Add(levels[2].ToString() + " % (mn)", typeof(Double));

                    OverallTools.DataFunctions.initialiserLignes(processTimePerPeriodOfTimeTable, dtBegin, dtEnd, dStep);
                    foreach (DataRow row in processTimePerPeriodOfTimeTable.Rows)
                    {
                        row[1] = 0.0d;
                        row[2] = 0.0d;
                        row[3] = 0.0d;
                        row[4] = 0;

                        row[firstLevelColumnIndex] = 0;
                        row[secondLevelColumnIndex] = 0;
                        row[thirdLevelColumnIndex] = 0;
                    }
                    dwellAreaTimes = new List<double>();
                    totalDwellArea = 0; // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard

                    List<PointF> bagTimesList = new List<PointF>();

                    foreach (Result rValues in alStationUse)
                    {
                        if (rValues.ArrivingTime < dWarmUp)
                            continue;
                        bagTimesList.Add(new PointF((float)rValues.ArrivingTime, (float)rValues.LeavingTime));
                    }

                    if (bagTimesList != null && bagTimesList.Count > 0)
                    {
                        int rowIndex = 0;
                        foreach (DataRow row in processTimePerPeriodOfTimeTable.Rows)
                        {
                            DateTime referenceBeginTime = (DateTime)row[0];
                            DateTime referenceEndTime = DateTime.MinValue;

                            if (rowIndex + 1 < processTimePerPeriodOfTimeTable.Rows.Count)
                                referenceEndTime = (DateTime)processTimePerPeriodOfTimeTable.Rows[rowIndex + 1][0];
                            else
                            {
                                DateTime finalTime = (DateTime)row[0];
                                referenceEndTime = finalTime.AddMinutes(dStep);
                            }

                            rowIndex = rowIndex + 1;

                            if (referenceBeginTime != null && referenceEndTime != DateTime.MinValue)
                            {
                                double min = double.MaxValue;
                                double max = double.MinValue;
                                int nbItems = 0;
                                double total = 0;

                                ArrayList bagsOnTimeSlot = new ArrayList();
                                foreach (PointF bagTimesInfo in bagTimesList)
                                {
                                    DateTime bagArrivalTime = dtBegin.AddMinutes(bagTimesInfo.X);
                                    DateTime bagLeavingTime = dtBegin.AddMinutes(bagTimesInfo.Y);

                                    if (bagArrivalTime != null && bagLeavingTime != null &&
                                        bagArrivalTime >= referenceBeginTime && bagArrivalTime < referenceEndTime)
                                    {
                                        double bagTimesInfoProcessTime = bagTimesInfo.Y - bagTimesInfo.X;
                                        dwellAreaTimes.Add(bagTimesInfoProcessTime);    // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS)

                                        if (bagTimesInfoProcessTime < min)
                                            min = bagTimesInfoProcessTime;
                                        if (bagTimesInfoProcessTime > max)
                                            max = bagTimesInfoProcessTime;
                                        total += bagTimesInfoProcessTime;
                                        nbItems++;
                                        bagsOnTimeSlot.Add(bagTimesInfoProcessTime);
                                    }
                                }
                                if (min != double.MaxValue && max != double.MinValue)
                                {
                                    row[1] = Math.Round(min, 2);
                                    row[2] = Math.Round((double)total / (double)nbItems, 2);
                                    row[3] = Math.Round(max, 2);
                                    row[4] = nbItems;

                                    totalDwellArea += total;    // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                                }
                                if (bagsOnTimeSlot.Count > 0)
                                {
                                    bagsOnTimeSlot.Sort();
                                    double firstLevelValue = ResultFunctions.getLevelValue(bagsOnTimeSlot, levels[0]);
                                    double secondLevelValue = ResultFunctions.getLevelValue(bagsOnTimeSlot, levels[1]);
                                    double thirdLevelValue = ResultFunctions.getLevelValue(bagsOnTimeSlot, levels[2]);

                                    row[firstLevelColumnIndex] = Math.Round(firstLevelValue, 2);
                                    row[secondLevelColumnIndex] = Math.Round(secondLevelValue, 2);
                                    row[thirdLevelColumnIndex] = Math.Round(thirdLevelValue, 2);
                                }
                            }
                        }
                        processTimePerPeriodOfTimeTable.AcceptChanges();
                    }

                    return processTimePerPeriodOfTimeTable;
                }
                // << Task #18306 PAX2SIM - BHS - Sorter occupation

                private void UpdateThroughput(DataTable dtOccupationTable, Double dWarmUp)
                {
                    dMinThroughputInput = -1;
                    dAverageThroughputInput = -1;
                    dMaxThroughputInput = -1;

                    // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS) C#9 Instant Throughput KPIs
                    dMinInstantThroughputInput = -1;
                    dAverageInstantThroughputInput = -1;
                    dMaxInstantThroughputInput = -1;

                    dMinThroughputOutput = -1;
                    dAverageThroughputOutput = -1;
                    dMaxThroughputOutput = -1;

                    dMinInstantThroughputOutput = -1;
                    dAverageInstantThroughputOutput = -1;
                    dMaxInstantThroughputOutput = -1;
                    // << Task #14902 Improve Dynamic Occupation tables (PAX & BHS) C#9 Instant Throughput KPIs

                    dMinAverage = -1;
                    dAverageAverage = -1;
                    dMaxAverage = -1;

                    dMinMax = -1;
                    dAverageMax = -1;
                    dMaxMax = -1;
                    Double[] dtResult = ResultFunctions.GetStatColumn(dtOccupationTable, "Throughput", dWarmUp);
                    if (dtResult == null)
                    {
                        dtResult = ResultFunctions.GetStatColumn(dtOccupationTable, "Throughput (Input)", dWarmUp);
                        if (dtResult == null)
                            return;
                    }
                    dMinThroughputInput = dtResult[0];
                    dAverageThroughputInput = dtResult[2];
                    dMaxThroughputInput = dtResult[1];

                    // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS) C#9 Instant Throughput KPIs
                    dtResult = ResultFunctions.GetStatColumn(dtOccupationTable, GlobalNames.OCCUPATION_TABLE_THROUGHPUT_INSTANT_IN_COLUMN_NAME, dWarmUp);
                    if (dtResult != null)
                    {
                        dMinInstantThroughputInput = dtResult[0];
                        dAverageInstantThroughputInput = dtResult[2];
                        dMaxInstantThroughputInput = dtResult[1];
                    }

                    dtResult = ResultFunctions.GetStatColumn(dtOccupationTable, GlobalNames.OCCUPATION_TABLE_THROUGHPUT_OUT_COLUMN_NAME, dWarmUp);
                    if (dtResult != null)
                    {
                        dMinThroughputOutput = dtResult[0];
                        dAverageThroughputOutput = dtResult[2];
                        dMaxThroughputOutput = dtResult[1];
                    }

                    dtResult = ResultFunctions.GetStatColumn(dtOccupationTable, GlobalNames.OCCUPATION_TABLE_THROUGHPUT_INSTANT_OUT_COLUMN_NAME, dWarmUp);
                    if (dtResult != null)
                    {
                        dMinInstantThroughputOutput = dtResult[0];
                        dAverageInstantThroughputOutput = dtResult[2];
                        dMaxInstantThroughputOutput = dtResult[1];
                    }
                    // << Task #14902 Improve Dynamic Occupation tables (PAX & BHS) C#9 Instant Throughput KPIs

                    dtResult = ResultFunctions.GetStatColumn(dtOccupationTable, "Average", dWarmUp);
                    if (dtResult == null)
                    {
                        dtResult = ResultFunctions.GetStatColumn(dtOccupationTable, "Average Occupation", dWarmUp);
                        if (dtResult == null)
                            return;
                    }
                    dMinAverage = dtResult[0];
                    dAverageAverage = dtResult[2];
                    dMaxAverage = dtResult[1];
                    dtResult = ResultFunctions.GetStatColumn(dtOccupationTable, "Max", dWarmUp);
                    if (dtResult == null)
                    {
                        dtResult = ResultFunctions.GetStatColumn(dtOccupationTable, "Max Occupation", dWarmUp);
                        if (dtResult == null)
                            return;
                    }
                    dMinMax = dtResult[0];
                    dAverageMax = dtResult[2];
                    dMaxMax = dtResult[1];
                }

                public static bool isValidDesk(String sName)
                {
                    if (sName == null || sName.Length == 0)
                        return false;
                    String[] tsObject = sName.Split('_');
                    String tmp = tsObject[0];

                    int iLenght = 2;
                    if ((tmp == OriginatingTransferSorterInduction)
                        || tmp == BHS_KEYWORD_SORTER || tmp == BHS_KEYWORD_ICS   // >> #13391 IST Tables standardization - sorter occupation
                        || (tmp == OriginatingTransferChute) ||
                        (tmp == sPersonalParking)
                        || tmp == sICSToploader || tmp == sNewICSToploader || tmp == sICSUnloader || tmp == sDepReaderTimeStamp // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                        || BHS_KEYWORDS_LIST_PRESORTATION.Contains(tmp) // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation
                        )
                    {
                        iLenght = 3;
                    }
                    // >> Task #13422 Keywords improvement
                    if (BHS_OBJECTS_ON_3_INDEXES_LIST.Contains(tmp))
                    {
                        iLenght = GlobalNames.BHS_OBJECTS_ON_3_INDEXES_LENGTH;
                    }
                    // << Task #13422 Keywords improvement
                    if (tsObject.Length != iLenght)
                        return false;

                    int iTmp;
                    if (!Int32.TryParse(tsObject[tsObject.Length - 1], out iTmp))
                    {
                        if ((tmp != OriginatingTransferHBS2) &&
                            (tmp != OriginatingTransferHBS4) &&
                            (tmp != OriginatingTransferHBS5) &&
                            (tmp != TerminatingABS))
                            return false;
                    }
                    if (tsObject.Length > 2)
                        if (!Int32.TryParse(tsObject[1], out iTmp))
                            return false;
                    return true;
                }

                // >> Task #10926 Pax2Sim - BHS analysis - Filter period problem
                /// <summary>
                /// Returns the list with the ids of the bags that entered this station in the simulation period. (entriTime inside [start, end].
                /// This is needed because a scenario can be recalculated using a different period of time that the original one.
                /// </summary>
                /// <param name="simulationStart"></param>
                /// <param name="simulationEnd"></param>
                /// <returns></returns>
                public List<Int32> getBagIdsListWithinTheSimulationPeriod(DateTime simulationStart, DateTime simulationEnd)
                {
                    List<Int32> bagsWithinTheSimPeriod = new List<Int32>();

                    if (simulationStart > simulationEnd)
                    {
                        return bagsWithinTheSimPeriod;
                    }

                    foreach (Result bagResult in alStationUse)
                    {
                        TimeSpan simulationDuration = simulationEnd.Subtract(simulationStart);
                        if (bagResult.ArrivingTime <= simulationDuration.TotalMinutes)
                        {
                            bagsWithinTheSimPeriod.Add(bagResult.bagId);
                        }
                    }
                    return bagsWithinTheSimPeriod;
                }
                // << Task #10926 Pax2Sim - BHS analysis - Filter period problem           
            }
            #endregion

            #endregion

            // >> #13391 IST Tables standardization - sorter occupation
            internal static bool hasSorterKeyword = false;
            internal static bool hasSortIndKeyword = false;
            internal static bool hasICSKeyword = false;
            internal static bool hasICSLoaderOrToploaderKeyword = false;
            // << #13391 IST Tables standardization - sorter occupation

            // >> Task #15088 Pax2Sim - BHS Analysis - Times and Indexes
            /// <summary>
            /// K = station type keyword / V = all different desk indexes found in the trace
            /// </summary>
            internal static Dictionary<string, List<int>> deskIndexesByStationTypeDictionary = new Dictionary<string, List<int>>();
            internal static List<string> entryStationTypesList = new List<string>();
            internal static List<string> exitStationTypesList = new List<string>();
            /// <summary>
            /// K = entry desk type, V = List of exit desk types that are connected to this entry that represents the key
            /// </summary>
            internal static Dictionary<string, List<string>> entryExitRoutesDictionary = new Dictionary<string, List<string>>();
            // << Task #15088 Pax2Sim - BHS Analysis - Times and Indexes

            #region Les constructeurs de la classe.
            /// <summary>
            /// Constructeur de la classe qui s'occupe d'analyser le contenu du bagtrace.
            /// </summary>
            /// <param name="FileName">Le nom du fichier bagtrace à analyser (avec son chemin complet)</param>
            /// <param name="WarmUp">Le Warmup appliqué sur cette simulation (en minutes)</param>
            public BagTraceAnalysis(String ScenarioName,
                                    String FileName,
                                    double warmUpInMinutes,
                                    Double FirstLevelPercent,
                                    Double SecondLevelPercent,
                                    Double ThirdLevelPercent,
                                    ParamScenario scenarioParameters)
            {
                this.scenarioParameters = scenarioParameters;
                sScenarioName = ScenarioName;
                sFileName = FileName;
                this.warmUpInMinutes = warmUpInMinutes;

                dFirstLevelPercent = FirstLevelPercent;
                dSecondLevelPercent = SecondLevelPercent;
                dThirdLevelPercent = ThirdLevelPercent;

                deskIndexesByStationTypeDictionary = new Dictionary<string, List<int>>();
                entryStationTypesList = new List<string>();
                exitStationTypesList = new List<string>();
                entryExitRoutesDictionary = new Dictionary<string, List<string>>();

                Initialize();
            }

            #region //SGE-26/03/2012-Begin
            public BagTraceAnalysis(List<String> lsPRKTrace,
                                    Double FirstLevelPercent,
                                    Double SecondLevelPercent,
                                    Double ThirdLevelPercent)
            {
                sScenarioName = "";
                sFileName = "";
                warmUpInMinutes = 0;
                lsTraceToAnalyse = lsPRKTrace;

                dFirstLevelPercent = FirstLevelPercent;
                dSecondLevelPercent = SecondLevelPercent;
                dThirdLevelPercent = ThirdLevelPercent;

                Initialize();
            }

            internal Boolean OpenBagTrace(Double dEndingTime, Prompt.SIM_LoadingForm cht)
            {
                return OpenBagTrace(dEndingTime, false, true, cht);
            }
            #endregion //SGE-26/03/2012-End
            public void Initialize()
            {
                alErrorList = new ArrayList();
                htStation = new SortedDictionary<string, StationResult>();  // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard (sortedDictionary instead of normal dictionary)
                htTerminating = new Dictionary<Int32, BaggageResult>();
                htOriginating = new Dictionary<Int32, BaggageResult>();
                htTransferring = new Dictionary<Int32, BaggageResult>();
                htParkingResult = new Dictionary<int, BaggageResult>();
                htUserResult = new Dictionary<int, BaggageResult>();   // >> Task #13422 Keywords improvement
                // >> Bag trace data collecting
                stationsDictionary = new Dictionary<string, BhsStation>();
                stationTypesDictionary = new Dictionary<string, List<BhsStation>>();
                // << Bag trace data collecting
            }
            #endregion

            #region Les fonctions qui ouvrent le bagtrace et qui initialisent les informations de résultats.
            /// <summary>
            /// All error types cause the bag to be ignored (even the station's invalid index or the station bad time format).
            /// </summary>
            private enum BAG_TRACE_ERROR_TYPE
            {
                TRACE_LINE_INVALID_BAG_ATTRIBUTE_OTHER_THAN_ID, TRACE_LINE_INVALID_BAG_ID,
                TRACE_STEPS_START_WITH_STOPPED_KEYWORD, TRACE_STEPS_INVALID_FIRST_KEYWORD,
                TRACE_STEPS_INVALID_STATION_BY_OTHER_REASON,
                TRACE_STEPS_INVALID_STATION_BY_STATION_NAME, TRACE_STEPS_INVALID_STATION_BY_RESERVED_INDEX_USAGE, TRACE_STEPS_INVALID_STATION_BY_TIMES_FORMAT
            }

            public Boolean OpenBagTrace(Double dEndingTime, bool bSaveTraceMode, Prompt.SIM_LoadingForm cht)
            {
                return OpenBagTrace(dEndingTime, bSaveTraceMode, false, cht);
            }
            public Boolean OpenBagTrace(Double dEndingTime, bool bSaveTraceMode, bool bTraceAlredyOpened, Prompt.SIM_LoadingForm cht)
            {
                Initialize();
                #region Ouverture du fichier bagtrace.

                System.IO.StreamReader monLecteur;
                String sTmp;
                #region //SGE-26/03/2012-Begin
                if (!bTraceAlredyOpened)
                {
                    #endregion //SGE-26/03/2012-End
                    if (!System.IO.File.Exists(sFileName))
                    {
                        alErrorList.Add("Err10001 : A problem appear when trying to read the Automod file result.");
                        return false;
                    }
                    try
                    {
                        monLecteur = new System.IO.StreamReader(sFileName);
                    }
                    catch (Exception exc)
                    {
                        alErrorList.Add("Err10002 : A problem appear when trying to read the Automod file result.");
                        OverallTools.ExternFunctions.PrintLogFile("Err10002: " + this.GetType().ToString() + " throw an exception: " + exc.Message);
                        return false;
                    }
                    if (monLecteur == null)
                        return false;
                    //On ignore la première ligne.
                    sTmp = monLecteur.ReadLine();
                    #region //SGE-26/03/2012-Begin
                }
                else
                {
                    if (lsTraceToAnalyse == null)
                        return false;
                    sTmp = lsTraceToAnalyse[0];
                    monLecteur = null;
                }
                #endregion //SGE-26/03/2012-End
                #endregion
                bool bPaxID = sTmp.Contains("PaxID");
                int iPaxIDOffset = 0;
                if (bPaxID)
                    iPaxIDOffset++;
                // >> #13391 IST Tables standardization - sorter occupation
                hasSorterKeyword = false;
                hasSortIndKeyword = false;
                hasICSKeyword = false;
                hasICSLoaderOrToploaderKeyword = false;
                // << #13391 IST Tables standardization - sorter occupation


                #region les variables
                int iIDBag;         //Identifiant du bagage
                int iIDPax = 0;         //Identifiant du Passager
                int iIDFlight;      //Identifiant du vol.
                double dSTD;           //Heure de départ prévu du vol.
                int iRecirculation; //Nombre de recirculation.
                int iInterLink;     //Interconnection.

                String sUneLigne;
                String[] dsValeurs;
                int iIndex;
                #endregion

                List<String> alList = new List<String>();
                #region //SGE-26/03/2012-Begin
                if (!bTraceAlredyOpened)
                {
                    #endregion //SGE-26/03/2012-End
                    #region On lit tout le contenu de la table.
                    if (cht != null)
                    {
                        cht.setFileNumber(1);
                        cht.ChargementFichier("Reading " + sFileName);
                    }

                    while (monLecteur.Peek() != -1)
                    {
                        sUneLigne = monLecteur.ReadLine();
                        alList.Add(sUneLigne);
                    }
                    monLecteur.Close();
                    #region //SGE-26/03/2012-Begin
                }
                else
                {
                    alList = lsTraceToAnalyse;
                }
                #endregion //SGE-26/03/2012-End
                if (cht != null)
                {
                    cht.Reset(0);
                    cht.setFileNumber(alList.Count / 1000);
                }
                #endregion

                bool bIsStoppedInCurrentProcess = false;
                isOldVSUFormat = false;

                Dictionary<BAG_TRACE_ERROR_TYPE, List<int>> errorTypes = new Dictionary<BAG_TRACE_ERROR_TYPE, List<int>>();
                ArrayList localErrors = new ArrayList();
                String ObservedLine;
                for (int iLine = 0; iLine < alList.Count; iLine++)
                {
                    if ((cht != null) && (iLine % 1000 == 0))
                    {
                        //cht.ChargementFichier("Line " + iLine.ToString());
                        cht.ChargementFichier("Scenario \"" + sScenarioName + "\": line " + iLine.ToString());  // >> Task #16728 PAX2SIM Improvements (Recurring) C#13
                    }
                    ObservedLine = (String)alList[iLine].Trim();
                    dsValeurs = ObservedLine.Split('\t');

                    #region Lecture des 5 (ou 6) premières colonnes (colonnes toujours présentes)
                    if (dsValeurs.Length <= 5)
                    {
                        //alErrorList.Add("Err10009 : The line n° " + (iLine + 2).ToString() + " has an invalid format (line ignored).");
                        localErrors.Add("Err10009 : The line n° " + (iLine + 2).ToString() + " has an invalid format (line ignored).");
                        updateBagTraceErrorTypesCount(-1, BAG_TRACE_ERROR_TYPE.TRACE_LINE_INVALID_BAG_ID, errorTypes);
                        continue;
                    }

                    //Les 5 premières ligne contiennent les informations concernant le vol du baggage. 
                    if (!Int32.TryParse(dsValeurs[0], out iIDBag))
                    {
                        //alErrorList.Add("Err10003 : Unable to read the bag identifier :  \"" + dsValeurs[0] + "\" in line n°" + (iLine + 2).ToString() + " (line ignored).");
                        localErrors.Add("Err10003 : Unable to read the bag identifier :  \"" + dsValeurs[0] + "\" in line n°" + (iLine + 2).ToString() + " (line ignored).");
                        updateBagTraceErrorTypesCount(-1, BAG_TRACE_ERROR_TYPE.TRACE_LINE_INVALID_BAG_ID, errorTypes);
                        continue;
                    }
                    if ((bPaxID) && (!Int32.TryParse(dsValeurs[1], out iIDPax)))
                    {
                        //alErrorList.Add("Err10015 : Unable to read the pax identifier :  \"" + dsValeurs[1] + "\" for baggage : \"" + iIDBag.ToString() + "\" in line n°" + (iLine + 2).ToString() + " (line ignored).");
                        localErrors.Add("Err10015 : Unable to read the pax identifier :  \"" + dsValeurs[1] + "\" for baggage : \"" + iIDBag.ToString() + "\" in line n°" + (iLine + 2).ToString() + " (line ignored).");
                        updateBagTraceErrorTypesCount(iIDBag, BAG_TRACE_ERROR_TYPE.TRACE_LINE_INVALID_BAG_ATTRIBUTE_OTHER_THAN_ID, errorTypes);
                        continue;
                    }
                    if (!Int32.TryParse(dsValeurs[iPaxIDOffset + 1], out iIDFlight))
                    {
                        //alErrorList.Add("Err10004 : Unable to read the flight identifier :  \"" + dsValeurs[iPaxIDOffset + 1] + "\" for baggage : \"" + iIDBag.ToString() + "\" in line n°" + (iLine + 2).ToString() + " (line ignored).");
                        localErrors.Add("Err10004 : Unable to read the flight identifier :  \"" + dsValeurs[iPaxIDOffset + 1] + "\" for baggage : \"" + iIDBag.ToString() + "\" in line n°" + (iLine + 2).ToString() + " (line ignored).");
                        updateBagTraceErrorTypesCount(iIDBag, BAG_TRACE_ERROR_TYPE.TRACE_LINE_INVALID_BAG_ATTRIBUTE_OTHER_THAN_ID, errorTypes);
                        continue;
                    }
                    if (!Double.TryParse(dsValeurs[iPaxIDOffset + 2], out dSTD))
                    {
                        //alErrorList.Add("Err10005 : Unable to read the flight identifier :  \"" + dsValeurs[iPaxIDOffset + 2] + "\" for baggage : \"" + iIDBag.ToString() + "\" in line n°" + (iLine + 2).ToString() + " (line ignored).");
                        localErrors.Add("Err10005 : Unable to read the flight identifier :  \"" + dsValeurs[iPaxIDOffset + 2] + "\" for baggage : \"" + iIDBag.ToString() + "\" in line n°" + (iLine + 2).ToString() + " (line ignored).");
                        updateBagTraceErrorTypesCount(iIDBag, BAG_TRACE_ERROR_TYPE.TRACE_LINE_INVALID_BAG_ATTRIBUTE_OTHER_THAN_ID, errorTypes);
                        continue;
                    }
                    if (!Int32.TryParse(dsValeurs[iPaxIDOffset + 3], out iRecirculation))
                    {
                        //alErrorList.Add("Err10006 : Unable to read the flight identifier :  \"" + dsValeurs[iPaxIDOffset + 3] + "\" for baggage : \"" + iIDBag.ToString() + "\" in line n°" + (iLine + 2).ToString() + " (line ignored).");
                        localErrors.Add("Err10006 : Unable to read the flight identifier :  \"" + dsValeurs[iPaxIDOffset + 3] + "\" for baggage : \"" + iIDBag.ToString() + "\" in line n°" + (iLine + 2).ToString() + " (line ignored).");
                        updateBagTraceErrorTypesCount(iIDBag, BAG_TRACE_ERROR_TYPE.TRACE_LINE_INVALID_BAG_ATTRIBUTE_OTHER_THAN_ID, errorTypes);
                        continue;
                    }
                    if (!Int32.TryParse(dsValeurs[iPaxIDOffset + 4], out iInterLink))
                    {
                        //alErrorList.Add("Err10007 : Unable to read the flight identifier :  \"" + dsValeurs[iPaxIDOffset + 4] + "\" for baggage : \"" + iIDBag.ToString() + "\" in line n°" + (iLine + 2).ToString() + " (line ignored).");
                        localErrors.Add("Err10007 : Unable to read the flight identifier :  \"" + dsValeurs[iPaxIDOffset + 4] + "\" for baggage : \"" + iIDBag.ToString() + "\" in line n°" + (iLine + 2).ToString() + " (line ignored).");
                        updateBagTraceErrorTypesCount(iIDBag, BAG_TRACE_ERROR_TYPE.TRACE_LINE_INVALID_BAG_ATTRIBUTE_OTHER_THAN_ID, errorTypes);
                        continue;
                    }
                    #endregion

                    BaggageResult brBaggageResult = null;
                    iIndex = 5 + iPaxIDOffset;

                    #region Génération de la classe de stockage des résultats
                    if (dsValeurs.Length > iIndex)
                    {
                        String sPoste = dsValeurs[iIndex];
                        if (sPoste == StoppedKeyWord)
                        {
                            //alErrorList.Add("Warning: The trace line for the bag \"" + iIDBag + "\" starts with the keyword " + StoppedKeyWord + ". The bag will be ignored.");
                            localErrors.Add("Warning: The trace line for the bag \"" + iIDBag + "\" starts with the keyword " + StoppedKeyWord + ". The bag will be ignored.");
                            updateBagTraceErrorTypesCount(iIDBag, BAG_TRACE_ERROR_TYPE.TRACE_STEPS_START_WITH_STOPPED_KEYWORD, errorTypes);
                            continue;
                        }
                        if (sPoste.Length != 0)
                        {
                            String sDeskType = sPoste.Split('_')[0];
                            if (!Names.Contains(sDeskType))
                                Names.Add(sDeskType);

                            checkKeywordPresence(sDeskType);    // >> #13391 IST Tables standardization - sorter occupation

                            if ((sDeskType == TerminatingQueue) || sDeskType == ArrivingCollector ||
                                (sDeskType == TerminatingInfeed) ||
                                (sDeskType == sPersonalTermQueue)
                                || (sDeskType == sTermStorage) || (sDeskType == sTermStorage1)      //<< New Objects - Task#7228
                                || (sDeskType == sTermStorage2) || (sDeskType == sTermULDMUInUsed)
                                || (sDeskType == sTermULDEmptyStorage) || (sDeskType == sTermULDFullStorage))   //>> New Objects - Task#7228
                            {
                                brBaggageResult = new TerminatingResult(iIDBag, iIDPax, iIDFlight, dSTD, iRecirculation, iInterLink);
                            }
                            else if ((sDeskType == TransferringQueue) || (sDeskType == TransferringInfeed) || sDeskType == TransferringCollector
                                    || (sDeskType == sPersonalTransfQueue)
                                    || (sDeskType == sTransfStorage) || (sDeskType == sTransfStorage1)      //<< New Objects - Task#7228  use TransferringResult for Sodexi
                                    || (sDeskType == sTransfStorage2) || (sDeskType == sTransfULDMUInUsed)  //only objects that represent the starting point for the bagg
                                    || (sDeskType == sTransfULDEmptyStorage) || (sDeskType == sTransfULDFullStorage)
                                    || (sDeskType == sADCustomQueue) || (sDeskType == sADOOGQueue)
                                    || (sDeskType == sADOutputBuffer) || (sDeskType == sADInputBuffer)
                                    || (sDeskType == sADBagsInUsed) || (sDeskType == sADPositionInUsed)
                                    || (sDeskType == sADEarlyStorage) || (sDeskType == sADInfeed)
                                    || (sDeskType == sAAInputBuffer) || (sDeskType == sAAInfeed)
                                    || (sDeskType == sAAEarlyStorage) || (sDeskType == sAAMUExport)
                                    || (sDeskType == sAAMUCloserHub) || (sDeskType == sAAMUVrac)
                                    || (sDeskType == sAAMUULD) || (sDeskType == sAAExportG02Early)
                                    || (sDeskType == sAAImport) || (sDeskType == sAAImportPoste)
                                    || (sDeskType == sAAImportPosteCHR) || (sDeskType == sAAImportPosteCYM))   //>> New Objects - Task#7228
                            {
                                brBaggageResult = new TransferringResult(iIDBag, iIDPax, iIDFlight, dSTD, iRecirculation, iInterLink);
                                //SDE Débuggage 13/01/2010
                                //brBaggageResult.OldLine = ObservedLine;
                            }
                            else if ((sDeskType == OriginatingQueue) || sDeskType == OriginatingCollector ||    // >> Task #18592 PAX2SIM - BHS - trace parsing updates
                                     (sDeskType == Originating) ||
                                    (sDeskType == sPersonalOrigQueue) ||
                                    (sDeskType == sPersonalDepQueue)
                                    || (sDeskType == sOrigStorage) || (sDeskType == sOrigStorage1)      //<< New Objects - Task#7228
                                    || (sDeskType == sOrigStorage2) || (sDeskType == sOrigULDMUInUsed)
                                    || (sDeskType == sOrigULDEmptyStorage) || (sDeskType == sOrigULDFullStorage)
                                    || (sDeskType == sDepStorage) || (sDeskType == sDepStorage1)        // use OriginatingResult for departing 
                                    || (sDeskType == sDepStorage2) || (sDeskType == sDepULDMUInUsed)
                                    || (sDeskType == sDepULDEmptyStorage) || (sDeskType == sDepULDFullStorage))   //>> New Objects - Task#7228
                            {
                                brBaggageResult = new OriginatingResult(iIDBag, iIDPax, iIDFlight, dSTD, iRecirculation, iInterLink);
                            }
                            else if (sDeskType == sPersonalParking
                                || BHS_USER_OBJECTS_LIST.Contains(sDeskType)) // >> Task #13422 Keywords improvement)
                            {
                                brBaggageResult = new BaggageResult(iIDBag, iIDPax, iIDFlight, dSTD, iRecirculation, iInterLink);
                            }
                            else
                            {
                                //alErrorList.Add("Err10011 : The keyword \"" + sDeskType + "\" for the station that processed the bag \"" + iIDBag.ToString() + "\" is not valid in line n°" + (iLine + 2).ToString() + ". The bag will be ignored.");
                                localErrors.Add("Err10011 : The keyword \"" + sDeskType + "\" for the station that processed the bag \"" + iIDBag.ToString() + "\" is not valid in line n°" + (iLine + 2).ToString() + ". The bag will be ignored.");
                                updateBagTraceErrorTypesCount(iIDBag, BAG_TRACE_ERROR_TYPE.TRACE_STEPS_INVALID_FIRST_KEYWORD, errorTypes);
                                continue;
                            }
                            if (!entryStationTypesList.Contains(sDeskType))
                                entryStationTypesList.Add(sDeskType);
                        }
                    }
                    #endregion
                    if (dsValeurs[dsValeurs.Length - 1] == StoppedKeyWord)
                        brBaggageResult.Stopped = true;

                    // << Task #9611 Pax2Sim - BHS - Analyse BHS Results Assistant - Analysis Range option
                    foreach (string code in dsValeurs)
                    {
                        if (code.Equals(StoppedKeyWord))
                            brBaggageResult.Stopped = true;
                    }
                    // >> Task #9611 Pax2Sim - BHS - Analyse BHS Results Assistant - Analysis Range option

                    // >> Bag trace data collecting
                    BhsItem bhsItem = new BhsItem(iIDBag, iIDPax, iIDFlight, dSTD, iRecirculation, iInterLink, BhsItem.STATUS_TYPE.OK);
                    if (brBaggageResult.Stopped)
                    {
                        bhsItem.status = BhsItem.STATUS_TYPE.STOPPED;
                    }
                    // << Bag trace data collecting

                    String sLastDesk = "";
                    StationResult.Result Res = null;
                    StationResult.Result ResHBS1 = null;
                    //Ensuite viennent une succession de temps indiquant les différentes étapes suivies par le baggage.
                    bool bBlank = false;
                    bool hasBeenThroughUserobject = false;  // >> Task #13422 Keywords improvement
                    bool reservedIndexUsage = false;
                    bool invalidStationByIndexes = false;
                    bool invalidStationByTimes = false;
                    while (dsValeurs.Length >= iIndex + 3)
                    {
                        if (dsValeurs[iIndex] == "")
                        {
                            bBlank = true;
                            break;
                        }
                        if (!StationResult.isValidDesk(dsValeurs[iIndex]))
                        {
                            //alErrorList.Add("Err10012 : Invalid station (" + dsValeurs[iIndex] + ") for the baggage \"" + iIDBag.ToString() + "\" in line n°" + (iLine + 2).ToString());
                            localErrors.Add("Err10012 : Invalid station (" + dsValeurs[iIndex] + ") for the baggage \"" + iIDBag.ToString() + "\" in line n°" + (iLine + 2).ToString());
                            updateBagTraceErrorTypesCount(iIDBag, BAG_TRACE_ERROR_TYPE.TRACE_STEPS_INVALID_STATION_BY_STATION_NAME, errorTypes);
                            invalidStationByIndexes = true;
                            break;
                        }
                        if (dsValeurs[iIndex] != null && dsValeurs[iIndex].Contains("_0"))
                        {
                            //alErrorList.Add("Invalid station (" + dsValeurs[iIndex] + ") for the baggage \"" + iIDBag.ToString() + "\" in line n°" + (iLine + 2).ToString()
                            //    + " because the station uses the index \"0\" which is reserved for the global statistics.");
                            localErrors.Add("Invalid station (" + dsValeurs[iIndex] + ") for the baggage \"" + iIDBag.ToString() + "\" in line n°" + (iLine + 2).ToString()
                                + " because the station uses the index \"0\" which is reserved for the global statistics.");
                            updateBagTraceErrorTypesCount(iIDBag, BAG_TRACE_ERROR_TYPE.TRACE_STEPS_INVALID_STATION_BY_RESERVED_INDEX_USAGE, errorTypes);
                            reservedIndexUsage = true;
                            break;
                        }
                        bIsStoppedInCurrentProcess = (dsValeurs[iIndex + 2] == StoppedKeyWord);
                        if (bIsStoppedInCurrentProcess)
                        {
                            bhsItem.status = BhsItem.STATUS_TYPE.STOPPED;
                        }
                        BaggageDesk desk;
                        if (bIsStoppedInCurrentProcess)
                            desk = BaggageDesk.getBaggageDesk(dsValeurs[iIndex], dsValeurs[iIndex + 1], dEndingTime);
                        else
                            desk = BaggageDesk.getBaggageDesk(dsValeurs[iIndex], dsValeurs[iIndex + 1], dsValeurs[iIndex + 2]);

                        if (desk == null)
                        {
                            //alErrorList.Add("Err10013 : Invalid format for the baggage \"" + iIDBag.ToString() + "\" in line n°" + (iLine + 2).ToString()
                            //    + ". The time for that desk does not have a good format.");
                            localErrors.Add("Err10013 : Invalid format for the baggage \"" + iIDBag.ToString() + "\" in line n°" + (iLine + 2).ToString()
                                + ". The time for that desk does not have a good format.");
                            updateBagTraceErrorTypesCount(iIDBag, BAG_TRACE_ERROR_TYPE.TRACE_STEPS_INVALID_STATION_BY_TIMES_FORMAT, errorTypes);
                            invalidStationByTimes = true;
                            break;
                        }
                        // >> Task #13422 Keywords improvement
                        if (BHS_USER_OBJECTS_LIST.Contains(desk.DeskType))
                            hasBeenThroughUserobject = true;
                        // << Task #13422 Keywords improvement
                        if (!Names.Contains(desk.DeskType))
                            Names.Add(desk.DeskType);

                        checkKeywordPresence(desk.DeskType);    // >> #13391 IST Tables standardization - sorter occupation                        
                        updateMaxStationTypeDeskIndexDictionary(desk.DeskType, desk.DeskIndex); // >> Task #15088 Pax2Sim - BHS Analysis - Times and Indexes

                        if (!bHasABS)
                            bHasABS = (desk.DeskType == TerminatingABS);

                        if (!bHasEBS)
                            bHasEBS = (desk.DeskType == OriginatingTransferEBS);
                        iIndex += 3;
                        brBaggageResult.AddBaggageWay(desk);

                        if (desk.DeskType == sICSToploader && !hasOldICSLoaderKeyword)    // >> Task #13422 Keywords improvement
                            hasOldICSLoaderKeyword = true;

                        if (OLD_VSU_BHS_TRACE_KEYWORDS.Contains(desk.DeskType))
                        {
                            isOldVSUFormat = true;
                        }

                        if (desk.DeskType == OriginatingTransferRecirculation)
                        {
                            if (htStation.ContainsKey(sLastDesk))
                                ((StationResult)htStation[sLastDesk]).AddRecirculation();
                        }
                        else if (desk.DeskType == OriginatingTransferRecirculation)
                        {
                            if (htStation.ContainsKey(sLastDesk))
                                ((StationResult)htStation[sLastDesk]).AddRecirculation();
                        }
                        else if (desk.DeskType == sICSRecirc)
                        {
                            if (htStation.ContainsKey(sLastDesk))
                                ((StationResult)htStation[sLastDesk]).AddICSRecirculation();
                        }
                        /*if (sLastDesk == desk.DeskName) commented because of   // >> Task #17603 PAX2SIM - BHS mode - Consecutive stations on a trace line with the same type
                        {
                            Res.LeavingTime = desk.LeavingTime;
                            if (bIsStoppedInCurrentProcess)
                                Res.Stopped = true;
                            ((StationResult)htStation[desk.DeskName]).addBaggageResult(brBaggageResult);    // >> Task #13391 IST tables standardization
                            if (!((StationResult)htStation[desk.DeskName]).baggageResultsDictionary.ContainsKey(brBaggageResult.IDBag)) // >> #13391 IST Tables standardization - sorter occupation
                                ((StationResult)htStation[desk.DeskName]).baggageResultsDictionary.Add(brBaggageResult.IDBag, brBaggageResult);
                        }
                        else
                        {*/
                        if (!htStation.ContainsKey(desk.DeskName))
                        {
                            htStation.Add(desk.DeskName, new StationResult(desk.DeskName, dFirstLevelPercent, dSecondLevelPercent, dThirdLevelPercent));
                            if (desk.UniqueTime)
                                ((StationResult)htStation[desk.DeskName]).TimeNull = true;
                        }
                        if (Res != null)
                        {
                            Res.TravelTime = desk.ArrivingTime - Res.LeavingTime;
                            if (ResHBS1 != null)
                            {
                                ResHBS1.TravelTime = desk.ArrivingTime - ResHBS1.LeavingTime;
                            }
                        }
                        if ((desk.DeskType == OriginatingTransferHBS2) ||
                            (desk.DeskType == OriginatingTransferHBS4))
                        {
                            ResHBS1 = Res;
                        }
                        else
                        {
                            ResHBS1 = null;
                        }

                        // >> Task #13422 Keywords improvement
                        string arrivalOrDeparture = "";
                        if (brBaggageResult.GetType() == typeof(TerminatingResult))
                        {
                            arrivalOrDeparture = GlobalNames.BHS_TRACE_ARRIVAL_TAG;
                        }
                        else if (brBaggageResult.GetType() == typeof(OriginatingResult)
                                 || brBaggageResult.GetType() == typeof(TransferringResult))
                        {
                            arrivalOrDeparture = GlobalNames.BHS_TRACE_DEPARTURE_TAG;
                        }
                        // << Task #13422 Keywords improvement

                        Res = new StationResult.Result(desk.ArrivingTime, desk.LeavingTime, brBaggageResult.STD,
                                                        brBaggageResult.IDBag, brBaggageResult.IDPax, brBaggageResult.FlightID, arrivalOrDeparture // >> Task #10926 Pax2Sim - BHS analysis - Filter period problem
                                                        , desk.DeskName, desk.DeskType, desk.TerminalIndex, desk.GroupIndex, desk.DeskIndex);
                        ((StationResult)htStation[desk.DeskName]).AddStationResult(Res);
                        ((StationResult)htStation[desk.DeskName]).addBaggageResult(brBaggageResult);    // >> Task #13391 IST tables standardization
                        if (!((StationResult)htStation[desk.DeskName]).baggageResultsDictionary.ContainsKey(brBaggageResult.IDBag)) // >> #13391 IST Tables standardization - sorter occupation
                            ((StationResult)htStation[desk.DeskName]).baggageResultsDictionary.Add(brBaggageResult.IDBag, brBaggageResult);
                        if (bIsStoppedInCurrentProcess)
                            Res.Stopped = true;
                        sLastDesk = desk.DeskName;
                        //}  commented because of // >> Task #17603 PAX2SIM - BHS mode - Consecutive stations on a trace line with the same type

                        /*}
                        else
                        {
                            if(htStation.ContainsKey(sLastDesk))
                                ((StationResult)htStation[sLastDesk]).AddRecirculation();
                        }*/

                        BhsStation station = null;
                        AccessingItem accessingItem = new AccessingItem(bhsItem, desk.ArrivingTime, desk.LeavingTime);
                        if (!stationsDictionary.ContainsKey(desk.DeskName))
                        {
                            station = new BhsStation(desk.DeskName, desk.DeskType, desk.TerminalIndex, desk.GroupIndex, desk.DeskIndex);
                            station.accessingItems.Add(accessingItem);
                            stationsDictionary.Add(station.name, station);
                        }
                        else
                        {
                            station = stationsDictionary[desk.DeskName];
                            station.accessingItems.Add(accessingItem);
                        }

                        if (!stationTypesDictionary.ContainsKey(station.type))
                        {
                            List<BhsStation> stationsByType = new List<BhsStation>();
                            stationsByType.Add(station);
                            stationTypesDictionary.Add(station.type, stationsByType);
                        }
                        else
                        {
                            List<BhsStation> stationsByType = stationTypesDictionary[station.type];
                            stationsByType.Add(station);
                        }
                        AccessedStation accessedStation = new AccessedStation(station, desk.ArrivingTime, desk.LeavingTime);
                        bhsItem.accessedStations.Add(accessedStation);
                    }

                    if ((brBaggageResult.Stopped) && (Res != null) && (!bIsStoppedInCurrentProcess))
                    {
                        Res.TravelTime = -1;
                        if (ResHBS1 != null)
                            ResHBS1.TravelTime = -1;
                    }
                    if (reservedIndexUsage)
                        continue;
                    if ((dsValeurs.Length != iIndex) && (!bBlank))
                    {
                        if (dsValeurs[iIndex] != StoppedKeyWord)
                        {
                            //Il y a eu un break dans la boucle précédente, car les valeurs n'étaient pas correctes.
                            //Ou alors le nombre de colonnes pour les temps de passage n'est pas multiple de 3,
                            //et donc il y a un problème dans le BagTrace.
                            //alErrorList.Add("Err10010 : The trace line representing the baggage with the id \"" + iIDBag.ToString() 
                            //    + "\" contains errors near \"" + dsValeurs[iIndex] + "\" The entire line is ignored.");
                            localErrors.Add("Err10010 : The trace line representing the baggage with the id \"" + iIDBag.ToString()
                                + "\" contains errors near \"" + dsValeurs[iIndex] + "\" The entire line is ignored.");
                            if (!invalidStationByIndexes && !invalidStationByTimes && !reservedIndexUsage)
                                updateBagTraceErrorTypesCount(iIDBag, BAG_TRACE_ERROR_TYPE.TRACE_STEPS_INVALID_STATION_BY_OTHER_REASON, errorTypes);
                            continue;
                        }
                    }

                    if (!brBaggageResult.Stopped && brBaggageResult != null
                        && brBaggageResult.alBaggageWay.Count > 0)
                    {
                        BaggageDesk entryDesk = brBaggageResult.alBaggageWay[0];
                        BaggageDesk exitDesk = brBaggageResult.alBaggageWay[brBaggageResult.alBaggageWay.Count - 1];

                        if (!BHS_USER_OBJECTS_LIST.Contains(exitDesk.DeskType)  //User keyword ignored if found as exit point
                            && !BHS_ULD_OBJECTS_LIST.Contains(entryDesk.DeskType))  //ULDs (containers) ignored if found as entries
                        {
                            if (!entryExitRoutesDictionary.ContainsKey(entryDesk.DeskType))
                            {
                                List<string> exitDesks = new List<string>();
                                exitDesks.Add(exitDesk.DeskType);
                                entryExitRoutesDictionary.Add(entryDesk.DeskType, exitDesks);
                            }
                            else
                            {
                                List<string> exitDesks = entryExitRoutesDictionary[entryDesk.DeskType];
                                if (!exitDesks.Contains(exitDesk.DeskType))
                                    exitDesks.Add(exitDesk.DeskType);
                            }
                            if (!exitStationTypesList.Contains(exitDesk.DeskType))
                                exitStationTypesList.Add(exitDesk.DeskType);

                            if (!foundTransferInfeedInTrace || !foundTransferCollectorInTrace)
                            {
                                foreach (BaggageDesk desk in brBaggageResult.alBaggageWay)
                                {
                                    if (desk.DeskType == TransferringInfeed)
                                        foundTransferInfeedInTrace = true;
                                    if (desk.DeskType == TransferringCollector)
                                        foundTransferCollectorInTrace = true;
                                }
                            }
                        }
                    }

                    try
                    {
                        //SDE 22/01/2010
                        //brBaggageResult.OldLine = ObservedLine;
                        if (brBaggageResult.GetType() == typeof(TerminatingResult))
                            htTerminating.Add(iIDBag, brBaggageResult);
                        else if (brBaggageResult.GetType() == typeof(TransferringResult))
                            htTransferring.Add(iIDBag, brBaggageResult);
                        else if (brBaggageResult.GetType() == typeof(OriginatingResult))
                            htOriginating.Add(iIDBag, brBaggageResult);
                        else if (brBaggageResult.GetType() == typeof(BaggageResult))
                            htParkingResult.Add(iIDBag, brBaggageResult);

                        if (hasBeenThroughUserobject)
                            htUserResult.Add(iIDBag, brBaggageResult);
                    }
                    catch (Exception exc)
                    {
                        alErrorList.Add("Err10014 : Unable to insert the baggage \"" + iIDBag.ToString() + "\". The baggage has already been inserted.");
                        OverallTools.ExternFunctions.PrintLogFile("Err10014: " + this.GetType().ToString() + " throw an exception: " + exc.Message);
                        continue;
                    }
                }
                if (errorTypes.Count > 0)
                    alErrorList.Add(getBagTraceErrorsSummary(errorTypes));
                alErrorList.AddRange(localErrors);
                //TODO: Remove  // >> Task #19522
                OverallTools.ExternFunctions.PrintLogFile("Originating: " + htOriginating.Count);
                OverallTools.ExternFunctions.PrintLogFile("Transferring: " + htTransferring.Count);
                OverallTools.ExternFunctions.PrintLogFile("Terminating: " + htTerminating.Count);
                OverallTools.ExternFunctions.PrintLogFile("Parking: " + htParkingResult.Count);
                OverallTools.ExternFunctions.PrintLogFile("UserResult: " + htUserResult.Count);

                if (cht != null)
                    cht.Reset(0);
                //We copy the bagtrace in the temporary directory, to save it later with the project.
                //if (bSaveTraceMode)   // >> Task #1954_bagTrace
                //{
                String sTempDirectory = ExternFunctions.getTempDirectoryForPax2sim();
                if (sTempDirectory != "")
                {
                    if (ExternFunctions.CheckCreateDirectory(sTempDirectory))
                    {
                        ExternFunctions.CopyFile(sTempDirectory + sScenarioName + "_BagTrace.tmp", sFileName, "", null, null, cht);
                    }
                }
                //}
                return true;
            }

            private void updateBagTraceErrorTypesCount(int bagId, BAG_TRACE_ERROR_TYPE errorType, Dictionary<BAG_TRACE_ERROR_TYPE, List<int>> errorTypes)
            {
                if (errorTypes == null)
                    errorTypes = new Dictionary<BAG_TRACE_ERROR_TYPE, List<int>>();
                if (!errorTypes.ContainsKey(errorType))
                    errorTypes.Add(errorType, new List<int>(new int[] { bagId }));
                else
                    errorTypes[errorType].Add(bagId);
            }
            private string getBagTraceErrorsSummary(Dictionary<BAG_TRACE_ERROR_TYPE, List<int>> errorTypes)
            {
                if (errorTypes == null || errorTypes.Count == 0)
                    return string.Empty;
                int totalNbErrorBags = getTotalNbErrorBags(errorTypes);
                string message = "The trace had " + totalNbErrorBags + " ignored bag(s).";

                if (errorTypes.ContainsKey(BAG_TRACE_ERROR_TYPE.TRACE_LINE_INVALID_BAG_ID))
                    message += Environment.NewLine + errorTypes[BAG_TRACE_ERROR_TYPE.TRACE_LINE_INVALID_BAG_ID].Count + " bag(s) ignored due to an invalid bag id.";
                if (errorTypes.ContainsKey(BAG_TRACE_ERROR_TYPE.TRACE_LINE_INVALID_BAG_ATTRIBUTE_OTHER_THAN_ID))
                {
                    message += Environment.NewLine + errorTypes[BAG_TRACE_ERROR_TYPE.TRACE_LINE_INVALID_BAG_ATTRIBUTE_OTHER_THAN_ID].Count + " bag(s) ignored due to an invalid bag attribute, other than id.";
                    message += Environment.NewLine + "Bag ids: ";
                    message += string.Join(",", errorTypes[BAG_TRACE_ERROR_TYPE.TRACE_LINE_INVALID_BAG_ATTRIBUTE_OTHER_THAN_ID].Select(p => p.ToString()).ToArray());
                }
                if (errorTypes.ContainsKey(BAG_TRACE_ERROR_TYPE.TRACE_STEPS_START_WITH_STOPPED_KEYWORD))
                {
                    message += Environment.NewLine + errorTypes[BAG_TRACE_ERROR_TYPE.TRACE_STEPS_START_WITH_STOPPED_KEYWORD].Count + " bag(s) ignored because the trace steps start with the \"STOPPED\" keyword.";
                    message += Environment.NewLine + "Bag ids: ";
                    message += string.Join(",", errorTypes[BAG_TRACE_ERROR_TYPE.TRACE_STEPS_START_WITH_STOPPED_KEYWORD].Select(p => p.ToString()).ToArray());
                }
                if (errorTypes.ContainsKey(BAG_TRACE_ERROR_TYPE.TRACE_STEPS_INVALID_FIRST_KEYWORD))
                {
                    message += Environment.NewLine + errorTypes[BAG_TRACE_ERROR_TYPE.TRACE_STEPS_INVALID_FIRST_KEYWORD].Count + " bag(s) ignored because the trace steps start with an invalid keyword.";
                    message += Environment.NewLine + "Bag ids: ";
                    message += string.Join(",", errorTypes[BAG_TRACE_ERROR_TYPE.TRACE_STEPS_INVALID_FIRST_KEYWORD].Select(p => p.ToString()).ToArray());
                }
                if (errorTypes.ContainsKey(BAG_TRACE_ERROR_TYPE.TRACE_STEPS_INVALID_STATION_BY_STATION_NAME))
                {
                    message += Environment.NewLine + errorTypes[BAG_TRACE_ERROR_TYPE.TRACE_STEPS_INVALID_STATION_BY_STATION_NAME].Count + " bag(s) ignored because of an invalid station name.";
                    message += Environment.NewLine + "Bag ids: ";
                    message += string.Join(",", errorTypes[BAG_TRACE_ERROR_TYPE.TRACE_STEPS_INVALID_STATION_BY_STATION_NAME].Select(p => p.ToString()).ToArray());
                }
                if (errorTypes.ContainsKey(BAG_TRACE_ERROR_TYPE.TRACE_STEPS_INVALID_STATION_BY_RESERVED_INDEX_USAGE))
                {
                    message += Environment.NewLine + errorTypes[BAG_TRACE_ERROR_TYPE.TRACE_STEPS_INVALID_STATION_BY_RESERVED_INDEX_USAGE].Count + " bag(s) ignored because the reserved \"0\" index was used.";
                    message += Environment.NewLine + "Bag ids: ";
                    message += string.Join(",", errorTypes[BAG_TRACE_ERROR_TYPE.TRACE_STEPS_INVALID_STATION_BY_RESERVED_INDEX_USAGE].Select(p => p.ToString()).ToArray());
                }
                if (errorTypes.ContainsKey(BAG_TRACE_ERROR_TYPE.TRACE_STEPS_INVALID_STATION_BY_TIMES_FORMAT))
                {
                    message += Environment.NewLine + errorTypes[BAG_TRACE_ERROR_TYPE.TRACE_STEPS_INVALID_STATION_BY_TIMES_FORMAT].Count + " bag(s) ignored because the time format was wrong.";
                    message += Environment.NewLine + "Bag ids: ";
                    message += string.Join(",", errorTypes[BAG_TRACE_ERROR_TYPE.TRACE_STEPS_INVALID_STATION_BY_TIMES_FORMAT].Select(p => p.ToString()).ToArray());
                }
                if (errorTypes.ContainsKey(BAG_TRACE_ERROR_TYPE.TRACE_STEPS_INVALID_STATION_BY_OTHER_REASON))
                {
                    message += Environment.NewLine + errorTypes[BAG_TRACE_ERROR_TYPE.TRACE_STEPS_INVALID_STATION_BY_OTHER_REASON].Count + " bag(s) ignored because the trace line had other issues.";
                    message += Environment.NewLine + "Bag ids: ";
                    message += string.Join(",", errorTypes[BAG_TRACE_ERROR_TYPE.TRACE_STEPS_INVALID_STATION_BY_OTHER_REASON].Select(p => p.ToString()).ToArray());
                }
                return message + Environment.NewLine;
            }
            private int getTotalNbErrorBags(Dictionary<BAG_TRACE_ERROR_TYPE, List<int>> errorTypes)
            {
                int totalNbErrorBags = 0;
                if (errorTypes == null)
                    return totalNbErrorBags;
                foreach (BAG_TRACE_ERROR_TYPE errorType in errorTypes.Keys)
                    totalNbErrorBags += errorTypes[errorType].Count;
                return totalNbErrorBags;
            }
            // >> #13391 IST Tables standardization - sorter occupation
            private static void checkKeywordPresence(string deskType)
            {
                if (deskType == BHS_KEYWORD_SORTER)
                    hasSorterKeyword = true;
                if (deskType == OriginatingTransferSorterInduction)
                    hasSortIndKeyword = true;
                if (deskType == BHS_KEYWORD_ICS)
                    hasICSKeyword = true;
                if (deskType == sNewICSToploader
                    || deskType == sICSToploader)
                {
                    hasICSLoaderOrToploaderKeyword = true;
                }
            }
            // << #13391 IST Tables standardization - sorter occupation

            // >> Task #15088 Pax2Sim - BHS Analysis - Times and Indexes
            private static void updateMaxStationTypeDeskIndexDictionary(string stationTypeKeyword, int deskIndex)
            {
                if (deskIndexesByStationTypeDictionary.ContainsKey(stationTypeKeyword))
                {
                    List<int> existingDeskIndexes = deskIndexesByStationTypeDictionary[stationTypeKeyword];
                    if (!existingDeskIndexes.Contains(deskIndex))
                    {
                        existingDeskIndexes.Add(deskIndex);
                        existingDeskIndexes.Sort();
                    }
                }
                else
                {
                    List<int> deskIndexes = new List<int>();
                    deskIndexes.Add(deskIndex);
                    deskIndexesByStationTypeDictionary.Add(stationTypeKeyword, deskIndexes);
                }
            }
            // << Task #15088 Pax2Sim - BHS Analysis - Times and Indexes
            #endregion

            #region Terminating part

            private void GenerateTerminatingResults(Hashtable htResults,
                            DateTime dtBegin,
                            DateTime dtEnd) // >> Task #10926 Pax2Sim - BHS analysis - Filter period problem
            {
                if (htTerminating.Count > 0)
                {
                    AnalyseTerminating(htResults, "Term", htTerminating, dtBegin, 1, 31, warmUpInMinutes,
                        new Double[] { dFirstLevelPercent, dSecondLevelPercent, dThirdLevelPercent }, false, bHasABS,
                        dtEnd); // >> Task #10926 Pax2Sim - BHS analysis - Filter period problem
                    AnalyseTerminating(htResults, "Term", htTerminating, dtBegin, 1, 31, warmUpInMinutes,
                        new Double[] { dFirstLevelPercent, dSecondLevelPercent, dThirdLevelPercent }, true, bHasABS,
                        dtEnd); // >> Task #10926 Pax2Sim - BHS analysis - Filter period problem
                }
            }

            private void GenerateTerminatingResults_new(Hashtable htResults, DateTime dtBegin, DateTime dtEnd, Double scenarioStep,
                List<AnalysisResultFilter> resultsFilters)//resultsFilters that are only for terminating!
            {
                if (htTerminating.Count > 0)
                {
                    AnalyseTerminating_new("Term", htTerminating, htResults, dtBegin, dtEnd, scenarioStep, warmUpInMinutes,
                        new Double[] { dFirstLevelPercent, dSecondLevelPercent, dThirdLevelPercent }, 31, bHasABS, resultsFilters);
                }
            }

            #endregion

            #region Originating part
            // >> Task #15088 Pax2Sim - BHS Analysis - Times and Indexes
            private void GenerateOriginatingResults_new(Hashtable htResults,
                            DateTime dtBegin, DateTime dtEnd, Double scenarioStep, Double analysisRange,
                            bool generateMUPSegregation,   // >> Task #14280 Bag Trace Loading time too long
                            XmlNode airportStructure, List<AnalysisResultFilter> resultsFilters)   // >> Task #13659 IST MakeUp segregation
            {
                if (htOriginating.Count > 0)
                {
                    List<AnalysisResultFilter> originatingResultFilters = new List<AnalysisResultFilter>();
                    foreach (AnalysisResultFilter rf in resultsFilters)
                    {
                        if (rf.flowType == AnalysisResultFilter.ORIGINATING_TECHNICAL_FLOW_TYPE)
                            originatingResultFilters.Add(rf);
                    }
                    AnalyseDeparting_new(htResults, "Orig", AnalysisResultFilter.ORIGINATING_TECHNICAL_FLOW_TYPE, dtBegin, htOriginating,
                        1, 31, warmUpInMinutes, new Double[] { dFirstLevelPercent, dSecondLevelPercent, dThirdLevelPercent }, true, bHasEBS
                        , dtEnd, scenarioStep, analysisRange, generateMUPSegregation, airportStructure, originatingResultFilters); // >> Task #14280 Bag Trace Loading time too long                   
                }
            }
            // << Task #15088 Pax2Sim - BHS Analysis - Times and Indexes
            #endregion

            #region Transferring part
            // >> Task #15088 Pax2Sim - BHS Analysis - Times and Indexes
            private void GenerateTransferringResults_new(Hashtable htResults,
                            DateTime dtBegin, DateTime dtEnd, Double scenarioStep, double analysisRange,
                            bool generateMUPSegregation,   // >> Task #14280 Bag Trace Loading time too long
                            XmlNode airportStructure, List<AnalysisResultFilter> resultsFilters)
            {
                if (htTransferring.Count > 0)
                {
                    List<AnalysisResultFilter> transferringResultFilters = new List<AnalysisResultFilter>();
                    foreach (AnalysisResultFilter rf in resultsFilters)
                    {
                        if (rf.flowType == AnalysisResultFilter.TRANSFERRING_TECHNICAL_FLOW_TYPE)
                            transferringResultFilters.Add(rf);
                    }
                    AnalyseDeparting_new(htResults, "Transf", AnalysisResultFilter.TRANSFERRING_TECHNICAL_FLOW_TYPE, dtBegin, htTransferring,
                        1, 31, warmUpInMinutes, new Double[] { dFirstLevelPercent, dSecondLevelPercent, dThirdLevelPercent }, true, bHasEBS
                        , dtEnd, scenarioStep, analysisRange, generateMUPSegregation, airportStructure, transferringResultFilters); // >> Task #14280 Bag Trace Loading time too long                    
                }
            }
            // << Task #15088 Pax2Sim - BHS Analysis - Times and Indexes
            #endregion

            #region Departing part
            // >> Task #15088 Pax2Sim - BHS Analysis - Times and Indexes
            private void GenerateDepartingResults_new(Hashtable htResults,
                            DateTime dtBegin, DateTime dtEnd, Double scenarioStep, double analysisRange,
                            bool generateMUPSegregation,   // >> Task #14280 Bag Trace Loading time too long
                            XmlNode airportStructure, List<AnalysisResultFilter> resultsFilters)
            {
                Dictionary<Int32, BaggageResult> htTotalDeparture = new Dictionary<Int32, BaggageResult>();
                foreach (int key in htOriginating.Keys)
                    htTotalDeparture.Add(key, htOriginating[key]);

                foreach (int key in htTransferring.Keys)
                    htTotalDeparture.Add(key, htTransferring[key]);

                if (htTotalDeparture.Count > 0)
                {
                    List<AnalysisResultFilter> departingResultFilters = new List<AnalysisResultFilter>();
                    foreach (AnalysisResultFilter rf in resultsFilters)
                    {
                        if (rf.flowType == AnalysisResultFilter.DEPARTING_TECHNICAL_FLOW_TYPE)
                            departingResultFilters.Add(rf);
                    }
                    AnalyseDeparting_new(htResults, "Dep", AnalysisResultFilter.DEPARTING_TECHNICAL_FLOW_TYPE, dtBegin, htTotalDeparture,
                        1, 31, warmUpInMinutes, new Double[] { dFirstLevelPercent, dSecondLevelPercent, dThirdLevelPercent }, true, bHasEBS
                        , dtEnd, scenarioStep, analysisRange, generateMUPSegregation, airportStructure, departingResultFilters); // >> Task #14280 Bag Trace Loading time too long                    
                }
            }
            // << Task #15088 Pax2Sim - BHS Analysis - Times and Indexes
            #endregion

            #region Fonction pour le calcul de l'occupation globale par les bagages
            private void GenerateGlobalOccupationResults(Hashtable htResults, DateTime dtBeginDate, DateTime dtEndDate,
                Double dStep, Double analysisRange) // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
            {
                ArrayList alOriginating = new ArrayList();
                ArrayList alOriginatingQueue = new ArrayList();
                ArrayList alTransferring = new ArrayList();
                ArrayList alTransferringQueue = new ArrayList();
                ArrayList alTerminating = new ArrayList();
                ArrayList alTerminatingQueue = new ArrayList();
                float fEndSimulation = (float)Math.Round(OverallTools.DataFunctions.MinuteDifference(dtBeginDate, dtEndDate), 1);
                float fArrivingTime, fArrivingInfeedTime, fLeavingTime;
                foreach (OriginatingResult orResult in htOriginating.Values)
                {
                    fArrivingTime = (float)orResult.arrivingMinuteAtFirstStation;
                    fArrivingInfeedTime = (float)orResult.ArrivingInfeedTime;
                    fLeavingTime = (float)orResult.LeavingSystemTime;
                    if (orResult.Stopped)
                    {
                        alOriginatingQueue.Add(new PointF(fArrivingTime, fEndSimulation));
                        if (orResult.HasInfeed)
                            alOriginating.Add(new PointF(fArrivingInfeedTime, fEndSimulation));
                    }
                    else
                    {
                        alOriginatingQueue.Add(new PointF(fArrivingTime, fLeavingTime));
                        if (orResult.HasInfeed)
                            alOriginating.Add(new PointF(fArrivingInfeedTime, fLeavingTime));
                    }
                }
                foreach (TransferringResult orResult in htTransferring.Values)
                {
                    fArrivingTime = (float)orResult.arrivingMinuteAtFirstStation;
                    fArrivingInfeedTime = (float)orResult.ArrivingInfeedTime;
                    fLeavingTime = (float)orResult.LeavingSystemTime;
                    if (orResult.Stopped)
                    {
                        alTransferringQueue.Add(new PointF(fArrivingTime, fEndSimulation));
                        if (orResult.HasInfeed)
                            alTransferring.Add(new PointF(fArrivingInfeedTime, fEndSimulation));
                    }
                    else
                    {
                        alTransferringQueue.Add(new PointF(fArrivingTime, fLeavingTime));
                        if (orResult.HasInfeed)
                            alTransferring.Add(new PointF(fArrivingInfeedTime, fLeavingTime));
                    }
                }
                foreach (TerminatingResult trResult in htTerminating.Values)
                {
                    fArrivingTime = (float)trResult.arrivingMinuteAtFirstStation;
                    fArrivingInfeedTime = (float)trResult.ArrivingInfeedTime;
                    fLeavingTime = (float)trResult.LeavingSystemTime;
                    if (trResult.Stopped)
                    {
                        alTerminatingQueue.Add(new PointF(fArrivingTime, fEndSimulation));
                        if (trResult.HasInfeed)
                            alTerminating.Add(new PointF(fArrivingInfeedTime, fEndSimulation));
                    }
                    else
                    {
                        alTerminatingQueue.Add(new PointF(fArrivingTime, fLeavingTime));
                        if (trResult.HasInfeed)
                            alTerminating.Add(new PointF(fArrivingInfeedTime, fLeavingTime));
                    }
                }

                DataTable dtTable;
                if (htOriginating.Count > 0)
                {
                    dtTable = OverallTools.ResultFunctions
                        .CalcQueueOccupationWithLeavingTimes("Originating_From_Collector", alOriginating, dtBeginDate,
                        dtEndDate, dStep, "Nb Bags", true, true, analysisRange);    // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                    if (!htResults.ContainsKey(dtTable.TableName))
                        htResults.Add(dtTable.TableName, dtTable);
                    dtTable = OverallTools.ResultFunctions
                        .CalcQueueOccupationWithLeavingTimes("Originating_From_Queue", alOriginatingQueue, dtBeginDate,
                        dtEndDate, dStep, "Nb Bags", true, true, analysisRange);    // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                    if (!htResults.ContainsKey(dtTable.TableName))
                        htResults.Add(dtTable.TableName, dtTable);
                }

                if (htTransferring.Count > 0)
                {
                    dtTable = OverallTools.ResultFunctions
                        .CalcQueueOccupationWithLeavingTimes("Transferring_From_Collector", alTransferring, dtBeginDate,
                        dtEndDate, dStep, "Nb Bags", true, true, analysisRange);    // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                    if (!htResults.ContainsKey(dtTable.TableName))
                        htResults.Add(dtTable.TableName, dtTable);
                    dtTable = OverallTools.ResultFunctions
                        .CalcQueueOccupationWithLeavingTimes("Transferring_From_Queue", alTransferringQueue, dtBeginDate,
                        dtEndDate, dStep, "Nb Bags", true, true, analysisRange);    // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                    if (!htResults.ContainsKey(dtTable.TableName))
                        htResults.Add(dtTable.TableName, dtTable);
                }
                alOriginating.AddRange(alTransferring);
                alOriginatingQueue.AddRange(alTransferringQueue);
                if (alOriginating.Count > 0)
                {
                    dtTable = OverallTools.ResultFunctions
                        .CalcQueueOccupationWithLeavingTimes("Departing_From_Collector", alOriginating, dtBeginDate,
                        dtEndDate, dStep, "Nb Bags", true, true, analysisRange);    // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                    if (!htResults.ContainsKey(dtTable.TableName))
                        htResults.Add(dtTable.TableName, dtTable);
                    dtTable = OverallTools.ResultFunctions
                        .CalcQueueOccupationWithLeavingTimes("Departing_From_Queue", alOriginatingQueue, dtBeginDate,
                        dtEndDate, dStep, "Nb Bags", true, true, analysisRange);    // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                    if (!htResults.ContainsKey(dtTable.TableName))
                        htResults.Add(dtTable.TableName, dtTable);
                }
                if (htTerminating.Count > 0)
                {
                    dtTable = OverallTools.ResultFunctions
                        .CalcQueueOccupationWithLeavingTimes("Terminating_From_Collector", alTerminating, dtBeginDate,
                        dtEndDate, dStep, "Nb Bags", true, true, analysisRange);    // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                    if (!htResults.ContainsKey(dtTable.TableName))
                        htResults.Add(dtTable.TableName, dtTable);
                    dtTable = OverallTools.ResultFunctions
                        .CalcQueueOccupationWithLeavingTimes("Terminating_From_Queue", alTerminatingQueue, dtBeginDate,
                        dtEndDate, dStep, "Nb Bags", true, true, analysisRange);    // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                    if (!htResults.ContainsKey(dtTable.TableName))
                        htResults.Add(dtTable.TableName, dtTable);
                }

                alOriginating.AddRange(alTerminating);
                alOriginatingQueue.AddRange(alTerminatingQueue);
                if (alOriginating.Count > 0)
                {
                    dtTable = OverallTools.ResultFunctions
                        .CalcQueueOccupationWithLeavingTimes("Global_From_Collector", alOriginating, dtBeginDate,
                        dtEndDate, dStep, "Nb Bags", true, true, analysisRange);    // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                    if (!htResults.ContainsKey(dtTable.TableName))
                        htResults.Add(dtTable.TableName, dtTable);
                    dtTable = OverallTools.ResultFunctions
                        .CalcQueueOccupationWithLeavingTimes("Global_From_Queue", alOriginatingQueue, dtBeginDate,
                        dtEndDate, dStep, "Nb Bags", true, true, analysisRange);    // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                    if (!htResults.ContainsKey(dtTable.TableName))
                        htResults.Add(dtTable.TableName, dtTable);
                }
            }

            // >> Task #15088 Pax2Sim - BHS Analysis - Times and Indexes
            private void GenerateGlobalOccupationResults_new(Hashtable htResults, DateTime dtBeginDate, DateTime dtEndDate,
                Double dStep, Double analysisRange)
            {
                ArrayList alTotal = new ArrayList();
                ArrayList alTotalQueue = new ArrayList();

                ArrayList alOriginating = new ArrayList();
                ArrayList alOriginatingQueue = new ArrayList();
                ArrayList alTransferring = new ArrayList();
                ArrayList alTransferringQueue = new ArrayList();
                ArrayList alTerminating = new ArrayList();
                ArrayList alTerminatingQueue = new ArrayList();
                float fEndSimulation = (float)Math.Round(OverallTools.DataFunctions.MinuteDifference(dtBeginDate, dtEndDate), 1);
                float fArrivingTime, fArrivingInfeedTime, fLeavingTime;
                foreach (OriginatingResult orResult in htOriginating.Values)
                {
                    DateTime timeAtSystemEntrance = orResult.GetTimeAtQueue(dtBeginDate);
                    if (timeAtSystemEntrance != null && timeAtSystemEntrance > dtEndDate)
                        continue;
                    if (orResult.LeavingSystemTime < warmUpInMinutes)
                        continue;

                    fArrivingTime = (float)orResult.arrivingMinuteAtFirstStation;
                    fArrivingInfeedTime = (float)orResult.arrivingMinuteAtInfeed;
                    fLeavingTime = (float)orResult.LeavingSystemTime;

                    if (orResult.Stopped)
                    {
                        alOriginatingQueue.Add(new PointF(fArrivingTime, fEndSimulation));
                        if (orResult.HasInfeed)
                            alOriginating.Add(new PointF(fArrivingInfeedTime, fEndSimulation));
                    }
                    else
                    {
                        alOriginatingQueue.Add(new PointF(fArrivingTime, fLeavingTime));
                        if (orResult.HasInfeed)
                            alOriginating.Add(new PointF(fArrivingInfeedTime, fLeavingTime));
                    }
                }
                foreach (TransferringResult orResult in htTransferring.Values)
                {
                    DateTime timeAtSystemEntrance = orResult.GetTimeAtQueue(dtBeginDate);
                    if (timeAtSystemEntrance != null && timeAtSystemEntrance > dtEndDate)
                        continue;
                    if (orResult.LeavingSystemTime < warmUpInMinutes)
                        continue;

                    fArrivingTime = (float)orResult.arrivingMinuteAtFirstStation;
                    fArrivingInfeedTime = (float)orResult.arrivingMinuteAtInfeed;
                    fLeavingTime = (float)orResult.LeavingSystemTime;

                    if (orResult.Stopped)
                    {
                        alTransferringQueue.Add(new PointF(fArrivingTime, fEndSimulation));
                        if (orResult.HasInfeed)
                            alTransferring.Add(new PointF(fArrivingInfeedTime, fEndSimulation));
                    }
                    else
                    {
                        alTransferringQueue.Add(new PointF(fArrivingTime, fLeavingTime));
                        if (orResult.HasInfeed)
                            alTransferring.Add(new PointF(fArrivingInfeedTime, fLeavingTime));
                    }
                }

                foreach (TerminatingResult trResult in htTerminating.Values)
                {
                    DateTime timeAtSystemEntrance = trResult.GetTimeAtQueue(dtBeginDate);
                    if (timeAtSystemEntrance != null && timeAtSystemEntrance > dtEndDate)
                        continue;
                    if (trResult.LeavingSystemTime < warmUpInMinutes)
                        continue;

                    fArrivingTime = (float)trResult.arrivingMinuteAtFirstStation;
                    fArrivingInfeedTime = (float)trResult.arrivingMinuteAtInfeed;
                    fLeavingTime = (float)trResult.LeavingSystemTime;

                    if (trResult.Stopped)
                    {
                        alTerminatingQueue.Add(new PointF(fArrivingTime, fEndSimulation));
                        if (trResult.HasInfeed)
                            alTerminating.Add(new PointF(fArrivingInfeedTime, fEndSimulation));
                    }
                    else
                    {
                        alTerminatingQueue.Add(new PointF(fArrivingTime, fLeavingTime));
                        if (trResult.HasInfeed)
                            alTerminating.Add(new PointF(fArrivingInfeedTime, fLeavingTime));
                    }
                }

                DataTable dtTable;

                alTotal.AddRange(alOriginating);
                alTotal.AddRange(alTransferring);
                alTotal.AddRange(alTerminating);

                alTotalQueue.AddRange(alOriginatingQueue);
                alTotalQueue.AddRange(alTransferringQueue);
                alTotalQueue.AddRange(alTerminatingQueue);

                if (alTotal.Count > 0)
                {
                    dtTable = OverallTools.ResultFunctions
                        .CalcQueueOccupationWithLeavingTimes("Global_Occupation_From_Collector^_To_Exit^", alTotal, dtBeginDate,
                        dtEndDate, dStep, "Nb Bags", true, true, analysisRange);
                    if (!htResults.ContainsKey(dtTable.TableName))
                        htResults.Add(dtTable.TableName, dtTable);
                    dtTable = OverallTools.ResultFunctions
                        .CalcQueueOccupationWithLeavingTimes("Global_Occupation_From_Queue^_To_Exit^", alTotalQueue, dtBeginDate,
                        dtEndDate, dStep, "Nb Bags", true, true, analysisRange);
                    if (!htResults.ContainsKey(dtTable.TableName))
                        htResults.Add(dtTable.TableName, dtTable);
                }
            }
            // << Task #15088 Pax2Sim - BHS Analysis - Times and Indexes
            #endregion

            // >> Task #13390 Targets for BHS Analysis output tables
            internal class BHSStatistic
            {
                public string stationType { get; set; }
                public int terminalNb { get; set; }
                public int groupNb { get; set; }
                public int stationNb { get; set; }
                public DataTable statsTable { get; set; }
                public DataTable transpStatsTable { get; set; } // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS)

                public BHSStatistic(string pStationType, int pTerminalNb, int pGroupNb, int pStationNb,
                    DataTable pStatsTable)
                {
                    stationType = pStationType;
                    terminalNb = pTerminalNb;
                    groupNb = pGroupNb;
                    stationNb = pStationNb;
                    statsTable = pStatsTable;
                }
            }
            // << Task #13390 Targets for BHS Analysis output tables

            // >> Task #15088 Pax2Sim - BHS Analysis - Times and Indexes
            public static List<AnalysisResultFilter> splitResultFiltersByFlowType(List<AnalysisResultFilter> resultFilters)
            {
                List<AnalysisResultFilter> resultFiltersByFlow = new List<AnalysisResultFilter>();
                foreach (AnalysisResultFilter rf in resultFilters)
                {
                    AnalysisResultFilter cloneRF = rf.clone();
                    cloneRF.flowType = AnalysisResultFilter.TRANSFERRING_TECHNICAL_FLOW_TYPE;
                    resultFiltersByFlow.Add(cloneRF);

                    cloneRF = rf.clone();
                    cloneRF.flowType = AnalysisResultFilter.ORIGINATING_TECHNICAL_FLOW_TYPE;
                    resultFiltersByFlow.Add(cloneRF);

                    cloneRF = rf.clone();
                    cloneRF.flowType = AnalysisResultFilter.DEPARTING_TECHNICAL_FLOW_TYPE;
                    resultFiltersByFlow.Add(cloneRF);
                }
                return resultFiltersByFlow;
            }
            // << Task #15088 Pax2Sim - BHS Analysis - Times and Indexes

            public Hashtable GenerateResults(DateTime dtBeginDate,
                                             DateTime dtEndDate,
                                             Double dStep,
                                             Double dStepDistribution,
                                             int iNbClasses,
                                             Prompt.SIM_LoadingForm cht,
                                             Double analysisRange,  // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                                             bool generateLocalIST, // >> Task #13955 Pax2Sim -BHS trace loading issue
                                             bool generateGroupIST, // >> Task #14280 Bag Trace Loading time too long
                                             bool generateMUPSegregation, // >> Task #14280 Bag Trace Loading time too long
                                             XmlNode airportStructure,  // >> Task #13659 IST MakeUp segregation
                                             List<AnalysisResultFilter> resultsFilters, List<AnalysisResultFilter> splittedResultsFilters,
                                             List<string> flowTypes,
                                             List<double> percentiles)  // >> Task #18306 PAX2SIM - BHS - Sorter occupation
            {
                int iResult = htStation.Keys.Count + 5;
                if (generateMUPSegregation) // >> Task #14280 Bag Trace Loading time too long
                    iResult++;
                if (cht != null)
                    cht.setFileNumber(iResult);
                Hashtable htResults = new Hashtable();

                splittedResultsFilters.Clear();
                splittedResultsFilters.AddRange(splitResultFiltersByFlowType(resultsFilters));   // >> Task #15088 Pax2Sim - BHS Analysis - Times and Indexes

                if (cht != null)
                {
                    //cht.ChargementFichier("Terminating distribution");
                    cht.ChargementFichier("Scenario \"" + sScenarioName + "\": Terminating distribution");  // >> Task #16728 PAX2SIM Improvements (Recurring) C#13
                }
                GenerateTerminatingResults(htResults, dtBeginDate, dtEndDate);  // >> Task #10926 Pax2Sim - BHS analysis - Filter period problem (added dtEnd)

                if (flowTypes.Contains(AnalysisResultFilter.ORIGINATING_FLOW_TYPE_VISUAL_NAME))
                {
                    if (cht != null)
                        cht.ChargementFichier("Originating distribution");
                    // << Task #8283 Pax2Sim - BHS mode - statistics for transportaition time per period of time                

                    // V6.225 without _Times
                    //GenerateOriginatingResults_old(htResults, dtBeginDate, dtEndDate, dStep, generateMUPSegregation, airportStructure);   // >> Task #14280 Bag Trace Loading time too long                
                    GenerateOriginatingResults_new(htResults, dtBeginDate, dtEndDate, dStep, analysisRange, generateMUPSegregation, airportStructure, splittedResultsFilters);   // >> Task #14280 Bag Trace Loading time too long
                    // >> Task #8283 Pax2Sim - BHS mode - statistics for transportaition time per period of time
                }

                if (flowTypes.Contains(AnalysisResultFilter.TRANSFERRING_FLOW_TYPE_VISUAL_NAME))
                {
                    if (cht != null)
                    {
                        //cht.ChargementFichier("Transferring distribution");
                        cht.ChargementFichier("Scenario \"" + sScenarioName + "\": Transferring distribution");  // >> Task #16728 PAX2SIM Improvements (Recurring) C#13
                    }
                    // << Task #8283 Pax2Sim - BHS mode - statistics for transportaition time per period of time                

                    // V6.225 without _Times
                    //GenerateTransferringResults_old(htResults, dtBeginDate, dtEndDate, dStep, generateMUPSegregation, airportStructure);  // >> Task #14280 Bag Trace Loading time too long
                    GenerateTransferringResults_new(htResults, dtBeginDate, dtEndDate, dStep, analysisRange, generateMUPSegregation, airportStructure, splittedResultsFilters);  // >> Task #14280 Bag Trace Loading time too long
                    // >> Task #8283 Pax2Sim - BHS mode - statistics for transportaition time per period of time
                }

                if (flowTypes.Contains(AnalysisResultFilter.DEPARTING_FLOW_TYPE_VISUAL_NAME))
                {
                    if (cht != null)
                    {
                        //cht.ChargementFichier("Departing distribution");
                        cht.ChargementFichier("Scenario \"" + sScenarioName + "\": Departing distribution");  // >> Task #16728 PAX2SIM Improvements (Recurring) C#13
                    }
                    // << Task #8283 Pax2Sim - BHS mode - statistics for transportaition time per period of time                

                    // V6.225 without _Times
                    //GenerateDepartingResults_old(htResults, dtBeginDate, dtEndDate, dStep, generateMUPSegregation, airportStructure); // >> Task #14280 Bag Trace Loading time too long
                    GenerateDepartingResults_new(htResults, dtBeginDate, dtEndDate, dStep, analysisRange, generateMUPSegregation, airportStructure, splittedResultsFilters); // >> Task #14280 Bag Trace Loading time too long
                    // >> Task #8283 Pax2Sim - BHS mode - statistics for transportaition time per period of time
                }

                if (cht != null)
                {
                    //cht.ChargementFichier("Generating global occupations");
                    cht.ChargementFichier("Scenario \"" + sScenarioName + "\": Generating global occupations");  // >> Task #16728 PAX2SIM Improvements (Recurring) C#13
                }

                // V6.225 without _Times
                //GenerateGlobalOccupationResults(htResults, dtBeginDate, dtEndDate, dStep, analysisRange);   // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                GenerateGlobalOccupationResults_new(htResults, dtBeginDate, dtEndDate, dStep, analysisRange);

                // >> Task #11603 Pax2Sim - BHS analysis - Dashboard for Times stats                
                List<DataTable> timesDirectoryStatisticsTables = getAllTimesDirectoryStatisticsTables(htResults);
                foreach (DataTable statisticTable in timesDirectoryStatisticsTables)
                {
                    SourceStatisticTableColumnIndexes
                        .setUpIndexes(statisticTable, dFirstLevelPercent, dSecondLevelPercent, dThirdLevelPercent);
                    DataTable summaryTable = createAndFillSummaryTableForBHSTimesDirectory(statisticTable);
                    htResults.Add(summaryTable.TableName, summaryTable);
                }
                // << Task #11603 Pax2Sim - BHS analysis - Dashboard for Times stats

                SortedDictionary<String, StationResult> htSorter = new SortedDictionary<String, StationResult>();
                SortedDictionary<String, StationResult> htICS = new SortedDictionary<String, StationResult>();  // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                Hashtable htHBS = new Hashtable();
                Hashtable htGroups = new Hashtable();
                Hashtable htMupSegregationGroups = new Hashtable();   // >> Task #13659 IST MakeUp segregation
                // >> Task #13422 Keywords improvement
                Hashtable allUserTerminals = new Hashtable();
                Hashtable allUserGroupsByTerminal = new Hashtable();
                Hashtable allUserStationsByGroup = new Hashtable();
                // << Task #13422 Keywords improvement

                Hashtable htConcatValues = new Hashtable();
                Hashtable dashboardConcatStatsTables = new Hashtable(); // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                List<BHSStatistic> dashboardConcatStatsList = new List<BHSStatistic>();// >> Task #13390 Targets for BHS Analysis output tables
                Hashtable transpDashboardConcatStatsTables = new Hashtable(); // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS)

                StationResult srTmp;
                DataTable dtTmp;
                #region Parcours de tous les objets trouvé dans le bagtrace
                foreach (String key in htStation.Keys)
                {
                    if (cht != null)
                    {
                        //cht.ChargementFichier(key);
                        cht.ChargementFichier("Scenario \"" + sScenarioName + "\": " + key);  // >> Task #16728 PAX2SIM Improvements (Recurring) C#13
                    }
                    srTmp = ((StationResult)htStation[key]);
                    dtTmp = null;
                    if (key != null && key.Contains("_0"))
                    {
                        string errorMessage = "Skipping the station \"" + key + "\" because it is using the index \"0\", which is reserved for the global statistics.";
                        if (alErrorList == null)
                            alErrorList = new ArrayList();
                        alErrorList.Add(errorMessage);
                        continue;
                    }
                    // >> #13391 IST Tables standardization - sorter occupation
                    //if (srTmp.StationType == BHS_KEYWORD_SORTER && hasSortIndKeyword)
                    //    continue;
                    if (srTmp.StationType == BHS_KEYWORD_ICS && hasICSLoaderOrToploaderKeyword)
                        continue;
                    // << #13391 IST Tables standardization - sorter occupation

                    #region Partie pour la génération des statistiques de temps restant   (SGE 01/02/2012)
                    //Ajout SGE 01/02/2012
                    dtTmp = srTmp.getRemainingTime(dtBeginDate, dtEndDate, dStep, warmUpInMinutes, new Double[] { dFirstLevelPercent, dSecondLevelPercent, dThirdLevelPercent });

                    if (dtTmp != null)
                    {
                        if (!htConcatValues.Contains(srTmp.StationType + "_RemainingTime"))
                            htConcatValues.Add(srTmp.StationType + "_RemainingTime", new DataTable(srTmp.StationType + "_RemainingTime"));
                        htResults.Add(dtTmp.TableName, dtTmp);
                        OverallTools.DataFunctions.ConcateneTable(((DataTable)htConcatValues[srTmp.StationType + "_RemainingTime"]), dtTmp, new String[] { "Nb Bags" }, srTmp.StationName + "_");
                    }
                    //fin Ajout SGE 01/02/2012
                    #endregion

                    #region Partie pour la génération des statistiques sur l'utilisation des postes   (SGE 01/02/2012)
                    //Ajout SGE 01/02/2012
                    dtTmp = srTmp.getUtilisation(dtBeginDate, dtEndDate, dStep, warmUpInMinutes,
                                                    false);  // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard

                    if (dtTmp != null)
                    {
                        if (!htConcatValues.Contains(srTmp.StationType + "_Utilization"))
                            htConcatValues.Add(srTmp.StationType + "_Utilization", new DataTable(srTmp.StationType + "_Utilization"));
                        htResults.Add(dtTmp.TableName, dtTmp);
                        OverallTools.DataFunctions.ConcateneTable(((DataTable)htConcatValues[srTmp.StationType + "_Utilization"]), dtTmp, new String[] { "% Occupation" }, srTmp.StationName + "_");
                        srTmp.utilizationTable = dtTmp;     // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                    }
                    //fin Ajout SGE 01/02/2012
                    #endregion

                    #region Dwell Area
                    // >> Task #10372 Pax2Sim - BHS - waiting time per period of time for ICS-Toploader
                    double totalDwellAreaTime = 0;  // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                    dtTmp = srTmp.createProcessTimePerPeriodOfTimeTable(dtBeginDate, dtEndDate, dStep, warmUpInMinutes, percentiles, out totalDwellAreaTime);

                    if (dtTmp != null)
                    {
                        if (!htConcatValues.Contains(srTmp.StationType + "_DwellArea"))
                            htConcatValues.Add(srTmp.StationType + "_DwellArea", new DataTable(srTmp.StationType + "_DwellArea"));
                        OverallTools.DataFunctions.ConcateneTable(((DataTable)htConcatValues[srTmp.StationType + "_DwellArea"]), dtTmp, new String[] { "Nb Bags" }, srTmp.StationName + "_");

                        htResults.Add(dtTmp.TableName, dtTmp);
                        // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                        srTmp.dwellAreaTable = dtTmp;
                        srTmp.totalDwellAreaTime = totalDwellAreaTime;
                        // << Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                    }
                    // << Task #10372 Pax2Sim - BHS - waiting time per period of time for ICS-Toploader
                    #endregion

                    if ((srTmp.StationType == OriginatingTransferSorterInduction) ||
                         srTmp.StationType == BHS_KEYWORD_SORTER ||
                        (srTmp.StationType == OriginatingTransferChute) ||
                        (srTmp.StationType == sPersonalParking))
                    {
                        #region Suivant le type d'objet (induction, Chute)
                        String sName = srTmp.StationType + "_" + srTmp.SorterIndex + "_0";
                        if ((srTmp.StationType == OriginatingTransferSorterInduction) ||
                             srTmp.StationType == BHS_KEYWORD_SORTER ||
                            (srTmp.StationType == sPersonalParking))
                        {
                            if (!htSorter.ContainsKey(sName))
                            {
                                htSorter.Add(sName, new StationResult(sName, dFirstLevelPercent, dSecondLevelPercent, dThirdLevelPercent));
                                ((StationResult)htSorter[sName]).TimeNull = srTmp.TimeNull;
                                iResult++;
                                if (cht != null)
                                    cht.setFileNumber(iResult);
                            }
                            ((StationResult)htSorter[sName]).AddRangeInformation(srTmp);
                            if (!hasSorterKeyword)
                            {
                                if (srTmp.StationType == OriginatingTransferSorterInduction)
                                {
                                    sName = OriginatingTransferSorterName + "_" + srTmp.SorterIndex;
                                }
                            }
                            else
                            {
                                if (srTmp.StationType == BHS_KEYWORD_SORTER)
                                {
                                    sName = OriginatingTransferSorterName + "_" + srTmp.SorterIndex;
                                }
                            }
                        }
                        if (!htSorter.ContainsKey(sName))
                        {
                            htSorter.Add(sName, new StationResult(sName, dFirstLevelPercent, dSecondLevelPercent, dThirdLevelPercent));
                            ((StationResult)htSorter[sName]).TimeNull = srTmp.TimeNull;
                            iResult++;
                            if (cht != null)
                                cht.setFileNumber(iResult);
                        }
                        if (sName.Contains(OriginatingTransferSorterName) || srTmp.StationType == OriginatingTransferChute)
                        {
                            ((StationResult)htSorter[sName]).AddRangeInformation(srTmp);
                        }

                        sName = srTmp.StationType + "_0";
                        if ((srTmp.StationType == OriginatingTransferSorterInduction) ||
                             srTmp.StationType == BHS_KEYWORD_SORTER ||
                            (srTmp.StationType == sPersonalParking))
                        {
                            if (!htSorter.ContainsKey(sName))
                            {
                                htSorter.Add(sName, new StationResult(sName, dFirstLevelPercent, dSecondLevelPercent, dThirdLevelPercent));
                                ((StationResult)htSorter[sName]).TimeNull = srTmp.TimeNull;
                                iResult++;
                                if (cht != null)
                                    cht.setFileNumber(iResult);
                            }
                            ((StationResult)htSorter[sName]).AddRangeInformation(srTmp);
                            //sName = OriginatingTransferSorterName + "_0";
                            if (!hasSorterKeyword)
                            {
                                if (srTmp.StationType == OriginatingTransferSorterInduction)
                                {
                                    sName = OriginatingTransferSorterName + "_0";
                                }
                            }
                            else
                            {
                                if (srTmp.StationType == BHS_KEYWORD_SORTER)
                                {
                                    sName = OriginatingTransferSorterName + "_0";
                                }
                            }
                        }

                        if (!htSorter.ContainsKey(sName))
                        {
                            htSorter.Add(sName, new StationResult(sName, dFirstLevelPercent, dSecondLevelPercent, dThirdLevelPercent));
                            ((StationResult)htSorter[sName]).TimeNull = srTmp.TimeNull;
                            iResult++;
                            if (cht != null)
                                cht.setFileNumber(iResult);
                        }
                        if (sName.Contains(OriginatingTransferSorterName) || srTmp.StationType == OriginatingTransferChute)
                        {
                            ((StationResult)htSorter[sName]).AddRangeInformation(srTmp);
                        }
                        #endregion
                    }
                    else if (srTmp.StationType == sICSToploader || srTmp.StationType == sNewICSToploader || srTmp.StationType == sICSUnloader)
                    {
                        // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                        #region Object types ICS-Toploader and ICS-Unloader
                        String sName = srTmp.StationType + "_" + srTmp.ICSIndex + "_0";
                        if ((srTmp.StationType == sICSToploader || srTmp.StationType == sNewICSToploader))
                        {
                            if (!htICS.ContainsKey(sName))
                            {
                                htICS.Add(sName, new StationResult(sName, dFirstLevelPercent, dSecondLevelPercent, dThirdLevelPercent));
                                ((StationResult)htICS[sName]).TimeNull = srTmp.TimeNull;
                                iResult++;
                                if (cht != null)
                                    cht.setFileNumber(iResult);
                            }
                            ((StationResult)htICS[sName]).AddRangeInformation(srTmp);
                            sName = sICS + "_" + srTmp.ICSIndex;//srTmp.SorterIndex;    // >> Task #10372 Pax2Sim - BHS - waiting time per period of time for ICS-Toploader
                        }
                        if (!htICS.ContainsKey(sName))
                        {
                            htICS.Add(sName, new StationResult(sName, dFirstLevelPercent, dSecondLevelPercent, dThirdLevelPercent));
                            ((StationResult)htICS[sName]).TimeNull = srTmp.TimeNull;
                            iResult++;
                            if (cht != null)
                                cht.setFileNumber(iResult);
                        }
                        ((StationResult)htICS[sName]).AddRangeInformation(srTmp);

                        sName = srTmp.StationType + "_0";
                        if ((srTmp.StationType == sICSToploader || srTmp.StationType == sNewICSToploader))
                        {
                            if (!htICS.ContainsKey(sName))
                            {
                                htICS.Add(sName, new StationResult(sName, dFirstLevelPercent, dSecondLevelPercent, dThirdLevelPercent));
                                ((StationResult)htICS[sName]).TimeNull = srTmp.TimeNull;
                                iResult++;
                                if (cht != null)
                                    cht.setFileNumber(iResult);
                            }
                            ((StationResult)htICS[sName]).AddRangeInformation(srTmp);
                            sName = sICS + "_0";
                        }

                        if (!htICS.ContainsKey(sName))
                        {
                            htICS.Add(sName, new StationResult(sName, dFirstLevelPercent, dSecondLevelPercent, dThirdLevelPercent));
                            ((StationResult)htICS[sName]).TimeNull = srTmp.TimeNull;
                            iResult++;
                            if (cht != null)
                                cht.setFileNumber(iResult);
                        }
                        ((StationResult)htICS[sName]).AddRangeInformation(srTmp);
                        #endregion
                        // >> Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                    }
                    else if (BHS_OBJECTS_ON_3_INDEXES_LIST.Contains(srTmp.StationType))
                    {
                        #region BHS Objects on 3 indexes
                        // >> Task #13422 Keywords improvement
                        String sName = srTmp.StationType + "_0" + "_0" + "_0";
                        if (!allUserTerminals.ContainsKey(sName))
                        {
                            allUserTerminals.Add(sName, new StationResult(sName, dFirstLevelPercent, dSecondLevelPercent, dThirdLevelPercent));
                            ((StationResult)allUserTerminals[sName]).TimeNull = srTmp.TimeNull;
                            iResult++;
                            if (cht != null)
                                cht.setFileNumber(iResult);
                        }
                        ((StationResult)allUserTerminals[sName]).AddRangeInformation(srTmp);

                        sName = srTmp.StationType + "_" + srTmp.terminalIndex + "_0" + "_0";
                        if (!allUserGroupsByTerminal.ContainsKey(sName))
                        {
                            allUserGroupsByTerminal.Add(sName, new StationResult(sName, dFirstLevelPercent, dSecondLevelPercent, dThirdLevelPercent));
                            ((StationResult)allUserGroupsByTerminal[sName]).TimeNull = srTmp.TimeNull;
                            iResult++;
                            if (cht != null)
                                cht.setFileNumber(iResult);
                        }
                        ((StationResult)allUserGroupsByTerminal[sName]).AddRangeInformation(srTmp);

                        sName = srTmp.StationType + "_" + srTmp.terminalIndex + "_" + srTmp.groupIndex + "_0";
                        if (!allUserStationsByGroup.ContainsKey(sName))
                        {
                            allUserStationsByGroup.Add(sName, new StationResult(sName, dFirstLevelPercent, dSecondLevelPercent, dThirdLevelPercent));
                            ((StationResult)allUserStationsByGroup[sName]).TimeNull = srTmp.TimeNull;
                            iResult++;
                            if (cht != null)
                                cht.setFileNumber(iResult);
                        }
                        ((StationResult)allUserStationsByGroup[sName]).AddRangeInformation(srTmp);
                        // << Task #13422 Keywords improvement
                        #endregion
                    }
                    else
                    {
                        #region Dans le cas des autres postes
                        if (!htGroups.ContainsKey(srTmp.StationType))
                        {
                            htGroups.Add(srTmp.StationType, new StationResult(srTmp.StationType + "_0", dFirstLevelPercent, dSecondLevelPercent, dThirdLevelPercent));
                            ((StationResult)htGroups[srTmp.StationType]).TimeNull = srTmp.TimeNull;
                            iResult++;
                            if (cht != null)
                                cht.setFileNumber(iResult);
                        }
                        ((StationResult)htGroups[srTmp.StationType]).AddRangeInformation(srTmp);
                        #endregion

                        if (generateMUPSegregation && srTmp.StationType == OriginatingTransferMU)   // >> Task #13659 IST MakeUp segregation
                        {
                            foreach (KeyValuePair<string, List<int>> pair in makeUpSGroupsDictionary)
                            {
                                if (pair.Value.Contains(srTmp.StationIndex))
                                {
                                    if (!htMupSegregationGroups.ContainsKey(pair.Key))
                                    {
                                        htMupSegregationGroups.Add(pair.Key, new StationResult("MU_" + pair.Key, dFirstLevelPercent, dSecondLevelPercent, dThirdLevelPercent));
                                        ((StationResult)htMupSegregationGroups[pair.Key]).TimeNull = srTmp.TimeNull;
                                    }
                                    ((StationResult)htMupSegregationGroups[pair.Key]).AddRangeInformation(srTmp);
                                    break;
                                }
                            }
                        }
                    }
                    #region S'il s'agit d'un poste HBS 2, 4 ou 5, on n'a pas besoin d'avancer dans les statistiques.
                    if (/*(srTmp.StationType == OriginatingTransferHBS2) || // >> Task #17229 PAX2SIM - BHS Analysis - HBS stats issues
                        (srTmp.StationType == OriginatingTransferHBS4) ||
                        (srTmp.StationType == OriginatingTransferHBS5) ||*/
                        ((srTmp.StationType == OriginatingCollector) && (srTmp.StationIndex == 0)) ||
                        (srTmp.StationType == TerminatingABS))
                        continue;
                    #endregion

                    #region Partie pour la génération de l'occupation des files d'attente.
                    if (srTmp.StationType == BHS_KEYWORD_ICS) //srTmp.StationType == BHS_KEYWORD_SORTER || srTmp.StationType == BHS_KEYWORD_ICS)    // >> #13391 IST Tables standardization - sorter occupation
                        dtTmp = srTmp.getMinMaxSorterOccupation(dtBeginDate, dtEndDate, dStep, warmUpInMinutes, analysisRange);
                    else
                        dtTmp = srTmp.getMinMaxQueueOccupation(dtBeginDate, dtEndDate, dStep, warmUpInMinutes, analysisRange);  // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation

                    if (dtTmp != null)
                    {
                        if (!htConcatValues.Contains(srTmp.StationType + "_Occupation"))
                            htConcatValues.Add(srTmp.StationType + "_Occupation", new DataTable(srTmp.StationType + "_Occupation"));
                        htResults.Add(dtTmp.TableName, dtTmp);
                        OverallTools.DataFunctions.ConcateneTable(((DataTable)htConcatValues[srTmp.StationType + "_Occupation"]), dtTmp, new String[] { "Throughput (Input)", "Throughput (Output)" }, srTmp.StationName + "_");
                        srTmp.occupationTable = dtTmp;  // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                    }
                    #endregion

                    #region S'il y a un temps de traitement.
                    if (!srTmp.TimeNull)
                    {
                        dtTmp = srTmp.getDistribution(dStepDistribution, iNbClasses, warmUpInMinutes, dtBeginDate, dtEndDate, dStep);  // >> Task #10926 Pax2Sim - BHS analysis - Filter period problem
                        htResults.Add(dtTmp.TableName, dtTmp);
                        if (!htConcatValues.Contains(srTmp.StationType + "_Distribution"))
                            htConcatValues.Add(srTmp.StationType + "_Distribution", new DataTable(srTmp.StationType + "_Distribution"));
                        OverallTools.DataFunctions.ConcateneTable(((DataTable)htConcatValues[srTmp.StationType + "_Distribution"]), dtTmp, new String[] { "Distrib. (%)" }, srTmp.StationName + "_");
                    }
                    #endregion

                    #region Partie pour les statistiques des postes.
                    dtTmp = srTmp.getStatistics(warmUpInMinutes, dtBeginDate, dtEndDate);   // >> Task #10926 Pax2Sim - BHS analysis - Filter period proble
                    htResults.Add(dtTmp.TableName, dtTmp);

                    // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                    DataTable dashboardStatsTable = srTmp.getDashboardStatistics(warmUpInMinutes, dtBeginDate, dtEndDate);
                    dashboardStatsTable.TableName = dashboardStatsTable.TableName + GlobalNames.BHS_STATS_TABLE_SUFFIX;
                    htResults.Add(dashboardStatsTable.TableName, dashboardStatsTable);

                    BHSStatistic bhsStats = new BHSStatistic(srTmp.StationType, srTmp.terminalIndex, srTmp.groupIndex, srTmp.StationIndex, dashboardStatsTable);
                    dashboardConcatStatsList.Add(bhsStats);

                    String dashboardConcatKey = srTmp.StationType + "_dashboardConcatStatistics";
                    if (!dashboardConcatStatsTables.ContainsKey(dashboardConcatKey))
                    {
                        DataTable dashboardConcatStatsTable = dashboardStatsTable.Clone();
                        concatenateDashboardStatisticTables(dashboardStatsTable, dashboardConcatStatsTable, srTmp.StationName);

                        dashboardConcatStatsTables.Add(dashboardConcatKey, dashboardConcatStatsTable);
                    }
                    else
                    {
                        concatenateDashboardStatisticTables(dashboardStatsTable,
                            (DataTable)dashboardConcatStatsTables[dashboardConcatKey], srTmp.StationName);
                    }
                    // << Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard

                    if (!htConcatValues.Contains(srTmp.StationType + "_Statistics"))
                        htConcatValues.Add(srTmp.StationType + "_Statistics", new DataTable(srTmp.StationType + "_Statistics"));
                    OverallTools.DataFunctions.ConcateneTable(((DataTable)htConcatValues[srTmp.StationType + "_Statistics"]), dtTmp, new String[] { "Value" }, srTmp.StationName + "_");

                    // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
                    DataTable dashboardStatsTable_Mod = srTmp.getDashboardStatistics_modified(warmUpInMinutes, dtBeginDate, dtEndDate);
                    htResults.Add(dashboardStatsTable_Mod.TableName, dashboardStatsTable_Mod);

                    String dashboardKey = srTmp.StationType + "_transpDashboardConcatStatistics";
                    if (!transpDashboardConcatStatsTables.Contains(dashboardKey))
                    {
                        DataTable transpDashboardConcatTable = dashboardStatsTable_Mod.Copy();

                        int valueUnitColumnIndex = transpDashboardConcatTable.Columns.IndexOf(GlobalNames.SUMMARY_TABLE_TRANSP_VALUE_UNIT_COLUMN_NAME);
                        transpDashboardConcatTable.Columns.RemoveAt(valueUnitColumnIndex);
                        int valueColumnIndex = transpDashboardConcatTable.Columns.IndexOf(GlobalNames.SUMMARY_TABLE_TRANSP_VALUE_COLUMN_NAME);
                        transpDashboardConcatTable.Columns.RemoveAt(valueColumnIndex);

                        concatenateTranspDashboardStatisticTables(dashboardStatsTable_Mod, transpDashboardConcatTable, srTmp.StationName);
                        transpDashboardConcatStatsTables.Add(dashboardKey, transpDashboardConcatTable);
                        bhsStats.transpStatsTable = transpDashboardConcatTable;
                    }
                    else
                    {
                        concatenateTranspDashboardStatisticTables(dashboardStatsTable_Mod,
                            (DataTable)transpDashboardConcatStatsTables[dashboardKey], srTmp.StationName);
                        bhsStats.transpStatsTable = (DataTable)transpDashboardConcatStatsTables[dashboardKey];
                    }
                    // << Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
                    #endregion

                    #region Local IST
                    // >> Task #13422 Keywords improvement  
                    if (generateLocalIST)   // >> Task #13955 Pax2Sim -BHS trace loading issue
                    {
                        dtTmp = getBHSLocalInSystemTimesTable(srTmp, dtBeginDate, dtEndDate, false, false);
                        if (dtTmp != null
                            && !htResults.ContainsKey(dtTmp.TableName))
                        {
                            htResults.Add(dtTmp.TableName, dtTmp);
                        }
                    }
                    // << Task #13422 Keywords improvement
                    #endregion
                }
                #endregion

                #region Gestion des résultats des Sorters
                DataTable dtResult;
                Hashtable htSorterAccumulation = new Hashtable();
                Hashtable sorterDashboardStatsAccumulation = new Hashtable();   // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                Hashtable sorterTranspDashboardStatsAccumulation = new Hashtable();

                foreach (String sKey in htSorter.Keys)
                {
                    if (cht != null)
                    {
                        //cht.ChargementFichier(sKey);
                        cht.ChargementFichier("Scenario \"" + sScenarioName + "\": " + sKey);  // >> Task #16728 PAX2SIM Improvements (Recurring) C#13
                    }
                    dtResult = null;
                    srTmp = ((StationResult)htSorter[sKey]);
                    if (hasSorterKeyword && srTmp.StationType == OriginatingTransferSorterName)
                    {
                        continue;
                    }
                    #region Sorter IST
                    // >> Task #13391 IST tables standardization                    
                    if (generateGroupIST)   // >> Task #14280 Bag Trace Loading time too long
                    {
                        if (srTmp != null)
                        {
                            dtTmp = getBHSLocalInSystemTimesTable(srTmp, dtBeginDate, dtEndDate, true, false);
                            if (dtTmp != null
                                && !htResults.ContainsKey(dtTmp.TableName))
                            {
                                htResults.Add(dtTmp.TableName, dtTmp);
                            }
                        }
                    }
                    // << Task #13391 IST tables standardization
                    #endregion

                    double totalDwellAreaTime = 0;
                    dtResult = srTmp.createProcessTimePerPeriodOfTimeTable(dtBeginDate, dtEndDate, dStep, warmUpInMinutes, percentiles, out totalDwellAreaTime);    // >> Task #18306
                    srTmp.totalDwellAreaTime = totalDwellAreaTime;
                    if (dtResult != null && !htResults.ContainsKey(dtResult.TableName))
                        htResults.Add(dtResult.TableName, dtResult);

                    //int x = ((StationResult)htSorter[sKey]).baggageResults.Count;
                    //if (srTmp.StationType == OriginatingTransferSorterName)
                    //dtResult = ((StationResult)htSorter[sKey]).getMinMaxSorterOccupation(dtBeginDate, dtEndDate, dStep, dWarmUp, analysisRange);    // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                    dtResult = ((StationResult)htSorter[sKey]).getSorterGroupingOccupation(dtBeginDate, dtEndDate, dStep, warmUpInMinutes, analysisRange);
                    //else
                    //    dtResult = ((StationResult)htSorter[sKey]).getOccupation(dtBeginDate, dtEndDate, dStep, dWarmUp, true);

                    if (dtResult != null)
                    {
                        if (htConcatValues.Contains(srTmp.StationType + "_Occupation"))
                        {
                            AddDesksStatistics(dtResult, (DataTable)htConcatValues[srTmp.StationType + "_Occupation"], srTmp.StationType + "_", "_Throughput", srTmp.SorterIndex);
                        }
                        if (!htResults.ContainsKey(dtResult.TableName))
                        {
                            htResults.Add(dtResult.TableName, dtResult);
                        }
                        else
                        {
                            OverallTools.ExternFunctions.PrintLogFile("Warning while generating the bag trace results: The results were already generated for "
                                + dtResult.TableName + ".");
                        }
                        if ((srTmp.SorterIndex > 0) && (srTmp.StationIndex <= 0))
                        {
                            if (!htSorterAccumulation.Contains(srTmp.StationType + "_Occupation"))
                                htSorterAccumulation.Add(srTmp.StationType + "_Occupation", new DataTable(srTmp.StationType + "_Occupation"));
                            OverallTools.DataFunctions.ConcateneTable(((DataTable)htSorterAccumulation[srTmp.StationType + "_Occupation"]), dtResult, new String[] { "Throughput" }, srTmp.StationType + "_" + srTmp.SorterIndex.ToString() + "_");
                        }
                        srTmp.occupationTable = dtResult;   // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                    }
                    if (srTmp.StationType == OriginatingTransferSorterName)
                        dtResult = ((StationResult)htSorter[sKey]).getDistribution(true, dStepDistribution, iNbClasses, warmUpInMinutes, dtBeginDate, dtEndDate, dStep);  // >> Task #10926 Pax2Sim - BHS analysis - Filter period problem
                    else
                        dtResult = ((StationResult)htSorter[sKey]).getDistribution(false, dStepDistribution, iNbClasses, warmUpInMinutes, dtBeginDate, dtEndDate, dStep);  // >> Task #10926 Pax2Sim - BHS analysis - Filter period problem
                    if (dtResult != null)
                    {
                        if (htConcatValues.Contains(srTmp.StationType + "_Distribution"))
                        {
                            AddDesksStatistics(dtResult, (DataTable)htConcatValues[srTmp.StationType + "_Distribution"], srTmp.StationType + "_", "_Distrib. (%)", srTmp.SorterIndex);
                        }
                        if (!htResults.ContainsKey(dtResult.TableName))
                        {
                            htResults.Add(dtResult.TableName, dtResult);
                        }
                        else
                        {
                            OverallTools.ExternFunctions.PrintLogFile("Warning while generating the bag trace results: The results were already generated for "
                                + dtResult.TableName + ".");
                        }

                        if ((srTmp.SorterIndex > 0) && (srTmp.StationIndex <= 0))
                        {
                            if (!htSorterAccumulation.Contains(srTmp.StationType + "_Distribution"))
                                htSorterAccumulation.Add(srTmp.StationType + "_Distribution", new DataTable(srTmp.StationType + "_Distribution"));
                            OverallTools.DataFunctions.ConcateneTable(((DataTable)htSorterAccumulation[srTmp.StationType + "_Distribution"]), dtResult, new String[] { "Distrib. (%)" }, srTmp.StationType + "_" + srTmp.SorterIndex.ToString() + "_");
                        }

                    }
                    dtResult = srTmp.getStatistics(warmUpInMinutes, dtBeginDate, dtEndDate);    // >> Task #10926 Pax2Sim - BHS analysis - Filter period proble
                    if (dtResult != null)
                    {
                        if (htConcatValues.Contains(srTmp.StationType + "_Statistics"))
                        {
                            AddDesksStatistics(dtResult, (DataTable)htConcatValues[srTmp.StationType + "_Statistics"], srTmp.StationType + "_", "_Value", srTmp.SorterIndex);
                        }
                        if (!htResults.ContainsKey(dtResult.TableName))
                        {
                            htResults.Add(dtResult.TableName, dtResult);
                        }
                        else
                        {
                            OverallTools.ExternFunctions.PrintLogFile("Warning while generating the bag trace results: The results were already generated for "
                                + dtResult.TableName + ".");
                        }
                        if ((srTmp.SorterIndex > 0) && (srTmp.StationIndex <= 0))
                        {
                            if (!htSorterAccumulation.Contains(srTmp.StationType + "_Statistics"))
                                htSorterAccumulation.Add(srTmp.StationType + "_Statistics", new DataTable(srTmp.StationType + "_Statistics"));
                            OverallTools.DataFunctions.ConcateneTable(((DataTable)htSorterAccumulation[srTmp.StationType + "_Statistics"]), dtResult, new String[] { "Value" }, srTmp.StationType + "_" + srTmp.SorterIndex.ToString() + "_");
                        }
                    }
                    // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                    DataTable dashboardStatsTableForSorters = srTmp.getDashboardStatistics(warmUpInMinutes, dtBeginDate, dtEndDate);
                    dashboardStatsTableForSorters.TableName = dashboardStatsTableForSorters.TableName + GlobalNames.BHS_STATS_TABLE_SUFFIX;
                    if (!htResults.ContainsKey(dashboardStatsTableForSorters.TableName))
                    {
                        htResults.Add(dashboardStatsTableForSorters.TableName, dashboardStatsTableForSorters);
                    }
                    else
                    {
                        OverallTools.ExternFunctions.PrintLogFile("Warning while generating the bag trace results: The results were already generated for "
                                + dashboardStatsTableForSorters.TableName + ".");
                    }
                    if (!srTmp.StationName.Equals(srTmp.StationType + "_0"))
                    {
                        String dashboardConcatSorterStatsKey = srTmp.StationType + "_dashboardConcatStatistics";
                        if (!sorterDashboardStatsAccumulation.ContainsKey(dashboardConcatSorterStatsKey))
                        {
                            DataTable dashboardConcatSorterStatsTable = dashboardStatsTableForSorters.Clone();
                            concatenateDashboardStatisticTables(dashboardStatsTableForSorters, dashboardConcatSorterStatsTable, srTmp.StationName);

                            sorterDashboardStatsAccumulation.Add(dashboardConcatSorterStatsKey, dashboardConcatSorterStatsTable);
                        }
                        else
                        {
                            concatenateDashboardStatisticTables(dashboardStatsTableForSorters,
                                (DataTable)sorterDashboardStatsAccumulation[dashboardConcatSorterStatsKey], srTmp.StationName);
                        }
                    }
                    // << Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard

                    // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
                    DataTable dashboardStatsTable_Mod = srTmp.getDashboardStatistics_modified(warmUpInMinutes, dtBeginDate, dtEndDate);
                    if (!htResults.ContainsKey(dashboardStatsTable_Mod.TableName))
                    {
                        htResults.Add(dashboardStatsTable_Mod.TableName, dashboardStatsTable_Mod);
                    }
                    else
                    {
                        OverallTools.ExternFunctions.PrintLogFile("Warning while generating the bag trace results: The results were already generated for "
                                + dashboardStatsTable_Mod.TableName + ".");
                    }
                    String dashboardKey = srTmp.StationType + "_transpDashboardConcatStatistics";
                    if (!srTmp.StationName.Equals(srTmp.StationType + "_0"))
                    {
                        if (!sorterTranspDashboardStatsAccumulation.Contains(dashboardKey))
                        {
                            DataTable transpDashboardConcatTable = dashboardStatsTable_Mod.Copy();

                            int valueUnitColumnIndex = transpDashboardConcatTable.Columns.IndexOf(GlobalNames.SUMMARY_TABLE_TRANSP_VALUE_UNIT_COLUMN_NAME);
                            transpDashboardConcatTable.Columns.RemoveAt(valueUnitColumnIndex);
                            int valueColumnIndex = transpDashboardConcatTable.Columns.IndexOf(GlobalNames.SUMMARY_TABLE_TRANSP_VALUE_COLUMN_NAME);
                            transpDashboardConcatTable.Columns.RemoveAt(valueColumnIndex);

                            concatenateTranspDashboardStatisticTables(dashboardStatsTable_Mod, transpDashboardConcatTable, srTmp.StationName);
                            sorterTranspDashboardStatsAccumulation.Add(dashboardKey, transpDashboardConcatTable);
                        }
                        else
                        {
                            concatenateTranspDashboardStatisticTables(dashboardStatsTable_Mod,
                                (DataTable)sorterTranspDashboardStatsAccumulation[dashboardKey], srTmp.StationName);
                        }
                    }
                    // << Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
                }
                foreach (String sKey in htSorter.Keys)
                {
                    srTmp = ((StationResult)htSorter[sKey]);
                    if ((srTmp.SorterIndex > 0) || ((srTmp.SorterIndex == -1) && (srTmp.StationIndex != 0)))
                        continue;

                    String sStationName = srTmp.StationName;
                    if (htResults.ContainsKey(sStationName + "_Occupation"))
                    {
                        dtResult = (DataTable)htResults[sStationName + "_Occupation"];
                        if (htSorterAccumulation.Contains(srTmp.StationType + "_Occupation"))
                        {
                            AddDesksStatistics(dtResult, (DataTable)htSorterAccumulation[srTmp.StationType + "_Occupation"], srTmp.StationType + "_", "_Throughput", -1);
                        }
                    }
                    if (htResults.ContainsKey(sStationName + "_Distribution"))
                    {
                        dtResult = (DataTable)htResults[sStationName + "_Distribution"];
                        if (htSorterAccumulation.Contains(srTmp.StationType + "_Distribution"))
                        {
                            AddDesksStatistics(dtResult, (DataTable)htSorterAccumulation[srTmp.StationType + "_Distribution"], srTmp.StationType + "_", "_Distrib. (%)", -1);
                        }
                    }
                    if (htResults.ContainsKey(sStationName + "_Statistics"))
                    {
                        dtResult = (DataTable)htResults[sStationName + "_Statistics"];
                        if (htSorterAccumulation.Contains(srTmp.StationType + "_Statistics"))
                        {
                            AddDesksStatistics(dtResult, (DataTable)htSorterAccumulation[srTmp.StationType + "_Statistics"], srTmp.StationType + "_", "_Value", -1);
                        }
                    }

                    // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard                    
                    String statisticTableKey = sStationName + "_Statistics" + GlobalNames.BHS_STATS_TABLE_SUFFIX;
                    if (htResults.ContainsKey(statisticTableKey))
                    {
                        DataTable sorterDashboardStatsTable = (DataTable)htResults[statisticTableKey];

                        String dashboardConcatKey = srTmp.StationType + "_dashboardConcatStatistics";
                        if (sorterDashboardStatsAccumulation.ContainsKey(dashboardConcatKey))
                        {
                            DataTable dashboardConcatStatsTable = (DataTable)sorterDashboardStatsAccumulation[dashboardConcatKey];
                            if (sorterDashboardStatsTable != null && dashboardConcatStatsTable != null)
                            {
                                foreach (DataRow concatStatsRow in dashboardConcatStatsTable.Rows)
                                {
                                    sorterDashboardStatsTable.ImportRow(concatStatsRow);
                                }
                            }
                        }
                    }
                    // << Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard

                    // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
                    String stationStatTableKey = sStationName + "_Statistics" + GlobalNames.BHS_STATS_TRANSP_TABLE_SUFFIX;
                    if (htResults.ContainsKey(stationStatTableKey))
                    {
                        DataTable dashboardStatsTable_Mod = (DataTable)htResults[stationStatTableKey];
                        String key = srTmp.StationType + "_transpDashboardConcatStatistics";
                        if (sorterTranspDashboardStatsAccumulation.Contains(key))
                        {
                            DataTable concatStatTable = (DataTable)sorterTranspDashboardStatsAccumulation[key];
                            addConcatStationsToGlobalStats(concatStatTable, dashboardStatsTable_Mod);
                        }
                    }
                    // << Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
                }
                #endregion

                // << Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader
                #region Gestion des résultats des ICS

                Hashtable htICSAccumulation = new Hashtable();
                Hashtable ICSDashboardStatsAccumulation = new Hashtable();  // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                Hashtable ICSTranspDashboardStatsAccumulation = new Hashtable();

                foreach (String sKey in htICS.Keys)
                {
                    if (cht != null)
                    {
                        //cht.ChargementFichier(sKey); 
                        cht.ChargementFichier("Scenario \"" + sScenarioName + "\": " + sKey);  // >> Task #16728 PAX2SIM Improvements (Recurring) C#13
                    }
                    dtResult = null;
                    srTmp = ((StationResult)htICS[sKey]);

                    #region ICS IST
                    // >> Task #13391 IST tables standardization  
                    if (generateGroupIST)   // >> Task #14280 Bag Trace Loading time too long
                    {
                        if (srTmp != null)
                        {
                            dtTmp = getBHSLocalInSystemTimesTable(srTmp, dtBeginDate, dtEndDate, false, true);
                            if (dtTmp != null
                                && !htResults.ContainsKey(dtTmp.TableName))
                            {
                                htResults.Add(dtTmp.TableName, dtTmp);
                            }
                        }
                    }
                    // << Task #13391 IST tables standardization
                    #endregion

                    double totalDwellAreaTime = 0;
                    dtResult = srTmp.createProcessTimePerPeriodOfTimeTable(dtBeginDate, dtEndDate, dStep, warmUpInMinutes, percentiles, out totalDwellAreaTime);    // >> Task #18306
                    srTmp.totalDwellAreaTime = totalDwellAreaTime;
                    if (dtResult != null && !htResults.ContainsKey(dtResult.TableName))
                        htResults.Add(dtResult.TableName, dtResult);

                    dtResult = ((StationResult)htICS[sKey]).getMinMaxSorterOccupation(dtBeginDate, dtEndDate, dStep, warmUpInMinutes, analysisRange);    // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation

                    if (dtResult != null)
                    {
                        if (htConcatValues.Contains(srTmp.StationType + "_Occupation"))
                        {
                            AddDesksStatistics(dtResult, (DataTable)htConcatValues[srTmp.StationType + "_Occupation"], srTmp.StationType + "_", "_Throughput", srTmp.ICSIndex);
                        }
                        if (!htResults.ContainsKey(dtResult.TableName))
                        {
                            htResults.Add(dtResult.TableName, dtResult);
                        }
                        else
                        {
                            OverallTools.ExternFunctions.PrintLogFile("Warning while generating the bag trace results: The results were already generated for "
                                + dtResult.TableName + ".");
                        }
                        if ((srTmp.ICSIndex > 0) && (srTmp.StationIndex <= 0))
                        {
                            if (!htICSAccumulation.Contains(srTmp.StationType + "_Occupation"))
                                htICSAccumulation.Add(srTmp.StationType + "_Occupation", new DataTable(srTmp.StationType + "_Occupation"));
                            OverallTools.DataFunctions.ConcateneTable(((DataTable)htICSAccumulation[srTmp.StationType + "_Occupation"]), dtResult, new String[] { "Throughput" }, srTmp.StationType + "_" + srTmp.ICSIndex.ToString() + "_");
                        }
                        srTmp.occupationTable = dtResult;   // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                    }
                    if (srTmp.StationType == sICS)
                        dtResult = ((StationResult)htICS[sKey]).getDistribution(true, dStepDistribution, iNbClasses, warmUpInMinutes, dtBeginDate, dtEndDate, dStep);  // >> Task #10926 Pax2Sim - BHS analysis - Filter period problem
                    else
                        dtResult = ((StationResult)htICS[sKey]).getDistribution(false, dStepDistribution, iNbClasses, warmUpInMinutes, dtBeginDate, dtEndDate, dStep); // >> Task #10926 Pax2Sim - BHS analysis - Filter period problem
                    if (dtResult != null)
                    {
                        if (htConcatValues.Contains(srTmp.StationType + "_Distribution"))
                        {
                            AddDesksStatistics(dtResult, (DataTable)htConcatValues[srTmp.StationType + "_Distribution"], srTmp.StationType + "_", "_Distrib. (%)", srTmp.ICSIndex);
                        }
                        if (!htResults.ContainsKey(dtResult.TableName))
                        {
                            htResults.Add(dtResult.TableName, dtResult);
                        }
                        else
                        {
                            OverallTools.ExternFunctions.PrintLogFile("Warning while generating the bag trace results: The results were already generated for "
                                + dtResult.TableName + ".");
                        }

                        if ((srTmp.ICSIndex > 0) && (srTmp.StationIndex <= 0))
                        {
                            if (!htICSAccumulation.Contains(srTmp.StationType + "_Distribution"))
                                htICSAccumulation.Add(srTmp.StationType + "_Distribution", new DataTable(srTmp.StationType + "_Distribution"));
                            OverallTools.DataFunctions.ConcateneTable(((DataTable)htICSAccumulation[srTmp.StationType + "_Distribution"]), dtResult, new String[] { "Distrib. (%)" }, srTmp.StationType + "_" + srTmp.ICSIndex.ToString() + "_");
                        }

                    }
                    dtResult = srTmp.getStatistics(warmUpInMinutes, dtBeginDate, dtEndDate);   // >> Task #10926 Pax2Sim - BHS analysis - Filter period proble
                    if (dtResult != null)
                    {
                        if (htConcatValues.Contains(srTmp.StationType + "_Statistics"))
                        {
                            AddDesksStatistics(dtResult, (DataTable)htConcatValues[srTmp.StationType + "_Statistics"], srTmp.StationType + "_", "_Value", srTmp.ICSIndex);
                        }
                        if (!htResults.ContainsKey(dtResult.TableName))
                        {
                            htResults.Add(dtResult.TableName, dtResult);
                        }
                        else
                        {
                            OverallTools.ExternFunctions.PrintLogFile("Warning while generating the bag trace results: The results were already generated for "
                                + dtResult.TableName + ".");
                        }
                        if ((srTmp.ICSIndex > 0) && (srTmp.StationIndex <= 0))
                        {
                            if (!htICSAccumulation.Contains(srTmp.StationType + "_Statistics"))
                                htICSAccumulation.Add(srTmp.StationType + "_Statistics", new DataTable(srTmp.StationType + "_Statistics"));
                            OverallTools.DataFunctions.ConcateneTable(((DataTable)htICSAccumulation[srTmp.StationType + "_Statistics"]), dtResult, new String[] { "Value" }, srTmp.StationType + "_" + srTmp.ICSIndex.ToString() + "_");
                        }
                    }
                    // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                    DataTable dashboardStatsTableForICS = srTmp.getDashboardStatistics(warmUpInMinutes, dtBeginDate, dtEndDate);
                    dashboardStatsTableForICS.TableName = dashboardStatsTableForICS.TableName + GlobalNames.BHS_STATS_TABLE_SUFFIX;
                    if (!htResults.ContainsKey(dashboardStatsTableForICS.TableName))
                    {
                        htResults.Add(dashboardStatsTableForICS.TableName, dashboardStatsTableForICS);
                    }
                    else
                    {
                        OverallTools.ExternFunctions.PrintLogFile("Warning while generating the bag trace results: The results were already generated for "
                                + dashboardStatsTableForICS.TableName + ".");
                    }

                    if (!srTmp.StationName.Equals(srTmp.StationType + "_0"))
                    {
                        String dashboardConcatKey = srTmp.StationType + "_dashboardConcatStatistics";
                        if (!ICSDashboardStatsAccumulation.ContainsKey(dashboardConcatKey))
                        {
                            DataTable dashboardConcatStatsTable = dashboardStatsTableForICS.Clone();
                            concatenateDashboardStatisticTables(dashboardStatsTableForICS, dashboardConcatStatsTable, srTmp.StationName);

                            ICSDashboardStatsAccumulation.Add(dashboardConcatKey, dashboardConcatStatsTable);
                        }
                        else
                        {
                            concatenateDashboardStatisticTables(dashboardStatsTableForICS,
                                (DataTable)ICSDashboardStatsAccumulation[dashboardConcatKey], srTmp.StationName);
                        }
                    }
                    // << Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                    // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
                    DataTable dashboardStatsTable_Mod = srTmp.getDashboardStatistics_modified(warmUpInMinutes, dtBeginDate, dtEndDate);
                    if (!htResults.ContainsKey(dashboardStatsTable_Mod.TableName))
                    {
                        htResults.Add(dashboardStatsTable_Mod.TableName, dashboardStatsTable_Mod);
                    }
                    else
                    {
                        OverallTools.ExternFunctions.PrintLogFile("Warning while generating the bag trace results: The results were already generated for "
                                + dashboardStatsTable_Mod.TableName + ".");
                    }

                    String dashboardKey = srTmp.StationType + "_transpDashboardConcatStatistics";
                    if (!srTmp.StationName.Equals(srTmp.StationType + "_0"))
                    {
                        if (!ICSTranspDashboardStatsAccumulation.Contains(dashboardKey))
                        {
                            DataTable transpDashboardConcatTable = dashboardStatsTable_Mod.Copy();

                            int valueUnitColumnIndex = transpDashboardConcatTable.Columns.IndexOf(GlobalNames.SUMMARY_TABLE_TRANSP_VALUE_UNIT_COLUMN_NAME);
                            transpDashboardConcatTable.Columns.RemoveAt(valueUnitColumnIndex);
                            int valueColumnIndex = transpDashboardConcatTable.Columns.IndexOf(GlobalNames.SUMMARY_TABLE_TRANSP_VALUE_COLUMN_NAME);
                            transpDashboardConcatTable.Columns.RemoveAt(valueColumnIndex);

                            concatenateTranspDashboardStatisticTables(dashboardStatsTable_Mod, transpDashboardConcatTable, srTmp.StationName);
                            ICSTranspDashboardStatsAccumulation.Add(dashboardKey, transpDashboardConcatTable);
                        }
                        else
                        {
                            concatenateTranspDashboardStatisticTables(dashboardStatsTable_Mod,
                                (DataTable)ICSTranspDashboardStatsAccumulation[dashboardKey], srTmp.StationName);
                        }
                    }
                    // << Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
                }
                foreach (String sKey in htICS.Keys)
                {
                    srTmp = ((StationResult)htICS[sKey]);
                    if ((srTmp.ICSIndex > 0) || ((srTmp.ICSIndex == -1) && (srTmp.StationIndex != 0)))
                        continue;

                    String sStationName = srTmp.StationName;
                    if (htResults.ContainsKey(sStationName + "_Occupation"))
                    {
                        dtResult = (DataTable)htResults[sStationName + "_Occupation"];
                        if (htICSAccumulation.Contains(srTmp.StationType + "_Occupation"))
                        {
                            AddDesksStatistics(dtResult, (DataTable)htICSAccumulation[srTmp.StationType + "_Occupation"], srTmp.StationType + "_", "_Throughput", -1);
                        }
                    }
                    if (htResults.ContainsKey(sStationName + "_Distribution"))
                    {
                        dtResult = (DataTable)htResults[sStationName + "_Distribution"];
                        if (htICSAccumulation.Contains(srTmp.StationType + "_Distribution"))
                        {
                            AddDesksStatistics(dtResult, (DataTable)htICSAccumulation[srTmp.StationType + "_Distribution"], srTmp.StationType + "_", "_Distrib. (%)", -1);
                        }
                    }
                    if (htResults.ContainsKey(sStationName + "_Statistics"))
                    {
                        dtResult = (DataTable)htResults[sStationName + "_Statistics"];
                        if (htICSAccumulation.Contains(srTmp.StationType + "_Statistics"))
                        {
                            AddDesksStatistics(dtResult, (DataTable)htICSAccumulation[srTmp.StationType + "_Statistics"], srTmp.StationType + "_", "_Value", -1);
                        }
                    }

                    // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                    String statisticsTableKey = sStationName + "_Statistics" + GlobalNames.BHS_STATS_TABLE_SUFFIX;
                    if (htResults.ContainsKey(statisticsTableKey))
                    {
                        DataTable dashboardStatsTable = (DataTable)htResults[statisticsTableKey];

                        String dashboardConcatKey = srTmp.StationType + "_dashboardConcatStatistics";
                        if (ICSDashboardStatsAccumulation.ContainsKey(dashboardConcatKey))
                        {
                            DataTable dashboardConcatStatsTable = (DataTable)ICSDashboardStatsAccumulation[dashboardConcatKey];
                            if (dashboardStatsTable != null && dashboardConcatStatsTable != null)
                            {
                                foreach (DataRow concatStatsRow in dashboardConcatStatsTable.Rows)
                                {
                                    dashboardStatsTable.ImportRow(concatStatsRow);
                                }
                            }
                        }
                    }
                    // << Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                    // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
                    String stationStatTableKey = sStationName + "_Statistics" + GlobalNames.BHS_STATS_TRANSP_TABLE_SUFFIX;
                    if (htResults.ContainsKey(stationStatTableKey))
                    {
                        DataTable dashboardStatsTable_Mod = (DataTable)htResults[stationStatTableKey];
                        String key = srTmp.StationType + "_transpDashboardConcatStatistics";
                        if (ICSTranspDashboardStatsAccumulation.Contains(key))
                        {
                            DataTable concatStatTable = (DataTable)ICSTranspDashboardStatsAccumulation[key];
                            addConcatStationsToGlobalStats(concatStatTable, dashboardStatsTable_Mod);
                        }
                    }
                    // << Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
                }
                #endregion
                // >> Task #9582 Pax2Sim - BagTrace - ICS_Toploader and ICS_Unloader

                // >> Task #13422 Keywords improvement
                #region BHS objects on 3 indexes
                foreach (String sKey in allUserTerminals.Keys)
                {
                    createGlobalStatsTablesForBHS(cht, allUserTerminals, TERMINAL_USER_OBJECT_TYPE, sKey, dtBeginDate, dtEndDate, dStep, warmUpInMinutes,
                                                    analysisRange, dStepDistribution, iNbClasses, htConcatValues, dashboardConcatStatsList, htResults, percentiles);
                }
                foreach (String sKey in allUserGroupsByTerminal.Keys)
                {
                    createGlobalStatsTablesForBHS(cht, allUserGroupsByTerminal, GROUP_USER_OBJECT_TYPE, sKey, dtBeginDate, dtEndDate, dStep, warmUpInMinutes,
                                                    analysisRange, dStepDistribution, iNbClasses, htConcatValues, dashboardConcatStatsList, htResults, percentiles);
                }
                foreach (String sKey in allUserStationsByGroup.Keys)
                {
                    createGlobalStatsTablesForBHS(cht, allUserStationsByGroup, STATION_USER_OBJECT_TYPE, sKey, dtBeginDate, dtEndDate, dStep, warmUpInMinutes,
                                                    analysisRange, dStepDistribution, iNbClasses, htConcatValues, dashboardConcatStatsList, htResults, percentiles);
                }
                #endregion
                // << Task #13422 Keywords improvement

                #region Gestion des résultats pour les groupes de postes.
                foreach (String sKey in htGroups.Keys)
                {
                    if (cht != null)
                    {
                        //cht.ChargementFichier(sKey);
                        cht.ChargementFichier("Scenario \"" + sScenarioName + "\": " + sKey);  // >> Task #16728 PAX2SIM Improvements (Recurring) C#13
                    }
                    srTmp = ((StationResult)htGroups[sKey]);

                    #region Group IST
                    // >> Task #13391 IST tables standardization
                    if (generateGroupIST)   // >> Task #14280 Bag Trace Loading time too long
                    {
                        dtTmp = getBHSLocalInSystemTimesTable(srTmp, dtBeginDate, dtEndDate, false, false);
                        if (dtTmp != null
                            && !htResults.ContainsKey(dtTmp.TableName))
                        {
                            htResults.Add(dtTmp.TableName, dtTmp);
                        }
                    }
                    // << Task #13391 IST tables standardization
                    #endregion

                    #region Partie pour la génération des statistiques de temps restant   (SGE 01/02/2012)
                    //Ajout SGE 01/02/2012
                    dtTmp = srTmp.getRemainingTime(dtBeginDate, dtEndDate, dStep, warmUpInMinutes, new Double[] { dFirstLevelPercent, dSecondLevelPercent, dThirdLevelPercent });

                    if (dtTmp != null)
                    {
                        if (htConcatValues.Contains(srTmp.StationType + "_RemainingTime"))
                        {
                            AddDesksStatistics(dtTmp, (DataTable)htConcatValues[srTmp.StationType + "_RemainingTime"], srTmp.StationType + "_", "_Nb Bags", -1);
                        }

                        htResults.Add(dtTmp.TableName, dtTmp);
                    }
                    //fin Ajout SGE 01/02/2012
                    #endregion

                    #region Partie pour la génération des statistiques sur l'utilisation des postes   (SGE 01/02/2012)
                    //Ajout SGE 01/02/2012
                    dtTmp = srTmp.getUtilisation(dtBeginDate, dtEndDate, dStep, warmUpInMinutes,
                                                    true);  // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard

                    if (dtTmp != null)
                    {
                        if (htConcatValues.Contains(srTmp.StationType + "_Utilization"))
                        {
                            AddDesksStatistics(dtTmp, (DataTable)htConcatValues[srTmp.StationType + "_Utilization"], srTmp.StationType + "_", "_% Occupation", -1);
                        }

                        // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                        computeAverageUtilizationAndDeskNeedForGroupUtilizationTable(dtTmp, srTmp.StationType);
                        // << Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard

                        // >> Bug - BHS analysis - DepReaderTimeStamp and InterLink                                                
                        if (htResults.ContainsKey(dtTmp.TableName))
                        {
                            htResults[dtTmp.TableName] = dtTmp;
                        }
                        else
                        {
                            htResults.Add(dtTmp.TableName, dtTmp);
                        }
                        ///////
                        //htResults.Add(dtTmp.TableName, dtTmp);
                        // << Bug - BHS analysis - DepReaderTimeStamp and InterLink

                        srTmp.utilizationTable = dtTmp; // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                    }
                    //fin Ajout SGE 01/02/2012
                    #endregion

                    #region Occupation
                    if (srTmp.StationType == BHS_KEYWORD_ICS)//srTmp.StationType == BHS_KEYWORD_SORTER || srTmp.StationType == BHS_KEYWORD_ICS)    // >> #13391 IST Tables standardization - sorter occupation
                        dtTmp = srTmp.getMinMaxSorterOccupation(dtBeginDate, dtEndDate, dStep, warmUpInMinutes, analysisRange);
                    else
                        dtTmp = srTmp.getMinMaxQueueOccupation(dtBeginDate, dtEndDate, dStep, warmUpInMinutes, analysisRange);  // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
                    if (dtTmp != null)
                    {
                        if (htConcatValues.Contains(srTmp.StationType + "_Occupation"))
                        {
                            AddDesksStatistics(dtTmp, (DataTable)htConcatValues[srTmp.StationType + "_Occupation"], srTmp.StationType + "_", "_Throughput (Input)", -1);
                        }
                        // >> Bug - BHS analysis - DepReaderTimeStamp and InterLink
                        if (htResults.ContainsKey(dtTmp.TableName))
                        {
                            htResults[dtTmp.TableName] = dtTmp;
                        }
                        else
                        {
                            htResults.Add(dtTmp.TableName, dtTmp);
                        }
                        //// 
                        //htResults.Add(dtTmp.TableName, dtTmp);
                        // << Bug - BHS analysis - DepReaderTimeStamp and InterLink

                        srTmp.occupationTable = dtTmp;  // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                    }
                    #endregion

                    #region Distribution
                    if (!srTmp.TimeNull)
                    {
                        dtTmp = srTmp.getDistribution(dStepDistribution, iNbClasses, warmUpInMinutes, dtBeginDate, dtEndDate, dStep);  // >> Task #10926 Pax2Sim - BHS analysis - Filter period problem
                        if (htConcatValues.Contains(srTmp.StationType + "_Distribution"))
                        {
                            AddDesksStatistics(dtTmp, (DataTable)htConcatValues[srTmp.StationType + "_Distribution"], srTmp.StationType + "_", "_Distrib. (%)", -1);
                        }
                        // >> Bug - BHS analysis - DepReaderTimeStamp and InterLink
                        if (htResults.ContainsKey(dtTmp.TableName))
                        {
                            htResults[dtTmp.TableName] = dtTmp;
                        }
                        else
                        {
                            htResults.Add(dtTmp.TableName, dtTmp);
                        }
                        ////
                        //htResults.Add(dtTmp.TableName, dtTmp);
                        // << Bug - BHS analysis - DepReaderTimeStamp and InterLink
                    }
                    #endregion

                    #region Statistics
                    dtTmp = srTmp.getStatistics(warmUpInMinutes, dtBeginDate, dtEndDate);   // >> Task #10926 Pax2Sim - BHS analysis - Filter period proble
                    // >> Bug - BHS analysis - DepReaderTimeStamp and InterLink
                    if (htResults.ContainsKey(dtTmp.TableName))
                    {
                        htResults[dtTmp.TableName] = dtTmp;
                    }
                    else
                    {
                        htResults.Add(dtTmp.TableName, dtTmp);
                    }
                    ////
                    //htResults.Add(dtTmp.TableName, dtTmp);
                    // << Bug - BHS analysis - DepReaderTimeStamp and InterLink
                    if (htConcatValues.Contains(srTmp.StationType + "_Statistics"))
                    {
                        if (BHS_STATIONS_WITH_TWO_INDEXES_LIST.Contains(srTmp.StationType)) // >> Task #11602 Pax2Sim - BHS analysis - Global stats not showing the child stats for DepReaderTimestamp
                        {
                            AddDesksStatisticsForBHSDesksWithTwoIndexes(dtTmp, (DataTable)htConcatValues[srTmp.StationType + "_Statistics"], srTmp.StationType + "_", "_Value", -1);
                        }
                        else
                        {
                            AddDesksStatistics(dtTmp, (DataTable)htConcatValues[srTmp.StationType + "_Statistics"], srTmp.StationType + "_", "_Value", -1);
                        }
                    }
                    #endregion

                    #region Dashboard Statistics
                    // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                    DataTable dashboardStatsTableForGroups = srTmp.getDashboardStatistics(warmUpInMinutes, dtBeginDate, dtEndDate);
                    dashboardStatsTableForGroups.TableName = dashboardStatsTableForGroups.TableName + GlobalNames.BHS_STATS_TABLE_SUFFIX;

                    String dashboardConcatKey = srTmp.StationType + "_dashboardConcatStatistics";
                    if (dashboardConcatStatsTables.ContainsKey(dashboardConcatKey))
                    {
                        DataTable dashboardConcatStatsTable = (DataTable)dashboardConcatStatsTables[dashboardConcatKey];
                        if (dashboardConcatStatsTable != null)
                        {
                            foreach (DataRow concatStatsRow in dashboardConcatStatsTable.Rows)
                            {
                                dashboardStatsTableForGroups.ImportRow(concatStatsRow);
                            }
                        }
                    }
                    htResults.Add(dashboardStatsTableForGroups.TableName, dashboardStatsTableForGroups);
                    // << Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
                    #endregion
                    // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
                    DataTable dashboardStatsTable_Mod = srTmp.getDashboardStatistics_modified(warmUpInMinutes, dtBeginDate, dtEndDate);
                    htResults.Add(dashboardStatsTable_Mod.TableName, dashboardStatsTable_Mod);

                    String key = srTmp.StationType + "_transpDashboardConcatStatistics";
                    if (transpDashboardConcatStatsTables.Contains(key))
                    {
                        DataTable concatStatTable = (DataTable)transpDashboardConcatStatsTables[key];
                        addConcatStationsToGlobalStats(concatStatTable, dashboardStatsTable_Mod);
                    }
                    // << Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
                }

                #region MUP Segregation
                if (generateMUPSegregation
                    && htMupSegregationGroups.Count > 0)    // >> Task #13659 IST MakeUp segregation
                {
                    if (cht != null)
                    {
                        //cht.ChargementFichier("Generating Make-up segregation statistics...");
                        cht.ChargementFichier("Scenario \"" + sScenarioName + "\": Generating Make-up segregation statistics...");  // >> Task #16728 PAX2SIM Improvements (Recurring) C#13
                    }
                    foreach (String sKey in htMupSegregationGroups.Keys)
                    {
                        srTmp = ((StationResult)htMupSegregationGroups[sKey]);
                        #region Group IST
                        if (generateGroupIST)
                        {
                            dtTmp = getBHSLocalInSystemTimesTable(srTmp, dtBeginDate, dtEndDate, false, false);
                            if (dtTmp != null
                                && !htResults.ContainsKey(dtTmp.TableName))
                            {
                                htResults.Add(dtTmp.TableName, dtTmp);
                            }
                        }
                        #endregion
                        #region Partie pour la génération des statistiques de temps restant   (SGE 01/02/2012)
                        dtTmp = srTmp.getRemainingTime(dtBeginDate, dtEndDate, dStep, warmUpInMinutes, new Double[] { dFirstLevelPercent, dSecondLevelPercent, dThirdLevelPercent });
                        if (dtTmp != null)
                        {
                            if (htConcatValues.Contains(srTmp.StationType + "_RemainingTime"))
                            {
                                AddDesksStatistics(dtTmp, (DataTable)htConcatValues[srTmp.StationType + "_RemainingTime"], srTmp.StationType + "_", "_Nb Bags", -1);
                            }
                            htResults.Add(dtTmp.TableName, dtTmp);
                        }
                        #endregion
                        #region Partie pour la génération des statistiques sur l'utilisation des postes   (SGE 01/02/2012)
                        dtTmp = srTmp.getUtilisation(dtBeginDate, dtEndDate, dStep, warmUpInMinutes, true);
                        if (dtTmp != null)
                        {
                            if (htConcatValues.Contains(srTmp.StationType + "_Utilization"))
                            {
                                AddDesksStatistics(dtTmp, (DataTable)htConcatValues[srTmp.StationType + "_Utilization"], srTmp.StationType + "_", "_% Occupation", -1);
                            }
                            computeAverageUtilizationAndDeskNeedForGroupUtilizationTable(dtTmp, srTmp.StationType);
                            if (htResults.ContainsKey(dtTmp.TableName))
                                htResults[dtTmp.TableName] = dtTmp;
                            else
                                htResults.Add(dtTmp.TableName, dtTmp);
                            srTmp.utilizationTable = dtTmp;
                        }
                        #endregion
                        #region Occupation
                        dtTmp = srTmp.getMinMaxQueueOccupation(dtBeginDate, dtEndDate, dStep, warmUpInMinutes, analysisRange);
                        if (dtTmp != null)
                        {
                            if (htConcatValues.Contains(srTmp.StationType + "_Occupation"))
                            {
                                AddDesksStatistics(dtTmp, (DataTable)htConcatValues[srTmp.StationType + "_Occupation"], srTmp.StationType + "_", "_Throughput (Input)", -1);
                            }
                            if (htResults.ContainsKey(dtTmp.TableName))
                                htResults[dtTmp.TableName] = dtTmp;
                            else
                                htResults.Add(dtTmp.TableName, dtTmp);
                            srTmp.occupationTable = dtTmp;
                        }
                        #endregion
                        #region Distribution
                        if (!srTmp.TimeNull)
                        {
                            dtTmp = srTmp.getDistribution(dStepDistribution, iNbClasses, warmUpInMinutes, dtBeginDate, dtEndDate, dStep);
                            if (htConcatValues.Contains(srTmp.StationType + "_Distribution"))
                            {
                                AddDesksStatistics(dtTmp, (DataTable)htConcatValues[srTmp.StationType + "_Distribution"], srTmp.StationType + "_", "_Distrib. (%)", -1);
                            }
                            if (htResults.ContainsKey(dtTmp.TableName))
                                htResults[dtTmp.TableName] = dtTmp;
                            else
                                htResults.Add(dtTmp.TableName, dtTmp);
                        }
                        #endregion
                        #region Statistics
                        dtTmp = srTmp.getStatistics(warmUpInMinutes, dtBeginDate, dtEndDate);
                        if (htResults.ContainsKey(dtTmp.TableName))
                            htResults[dtTmp.TableName] = dtTmp;
                        else
                            htResults.Add(dtTmp.TableName, dtTmp);
                        if (htConcatValues.Contains(srTmp.StationType + "_Statistics"))
                        {
                            if (BHS_STATIONS_WITH_TWO_INDEXES_LIST.Contains(srTmp.StationType))
                            {
                                AddDesksStatisticsForBHSDesksWithTwoIndexes(dtTmp, (DataTable)htConcatValues[srTmp.StationType + "_Statistics"], srTmp.StationType + "_", "_Value", -1);
                            }
                            else
                            {
                                AddDesksStatistics(dtTmp, (DataTable)htConcatValues[srTmp.StationType + "_Statistics"], srTmp.StationType + "_", "_Value", -1);
                            }
                        }
                        #endregion
                        #region Dashboard Statistics                                                
                        DataTable dashboardStatsTableForGroups = srTmp.getDashboardStatistics(warmUpInMinutes, dtBeginDate, dtEndDate);
                        dashboardStatsTableForGroups.TableName = dashboardStatsTableForGroups.TableName + GlobalNames.BHS_STATS_TABLE_SUFFIX;
                        String dashboardConcatKey = srTmp.StationType + "_dashboardConcatStatistics";
                        if (dashboardConcatStatsTables.ContainsKey(dashboardConcatKey))
                        {
                            DataTable dashboardConcatStatsTable = (DataTable)dashboardConcatStatsTables[dashboardConcatKey];
                            if (dashboardConcatStatsTable != null)
                            {
                                foreach (DataRow concatStatsRow in dashboardConcatStatsTable.Rows)
                                    dashboardStatsTableForGroups.ImportRow(concatStatsRow);
                            }
                        }
                        htResults.Add(dashboardStatsTableForGroups.TableName, dashboardStatsTableForGroups);
                        #endregion
                        // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
                        DataTable dashboardStatsTable_Mod = srTmp.getDashboardStatistics_modified(warmUpInMinutes, dtBeginDate, dtEndDate);
                        htResults.Add(dashboardStatsTable_Mod.TableName, dashboardStatsTable_Mod);

                        String key = srTmp.StationType + "_transpDashboardConcatStatistics";
                        if (transpDashboardConcatStatsTables.Contains(key))
                        {
                            DataTable concatStatTable = (DataTable)transpDashboardConcatStatsTables[key];
                            addConcatStationsToGlobalStats(concatStatTable, dashboardStatsTable_Mod);
                        }
                        // << Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
                    }
                }
                #endregion

                #endregion

                return htResults;
            }

            // >> Task #13422 Keywords improvement
            internal string TERMINAL_USER_OBJECT_TYPE = "T";
            internal string GROUP_USER_OBJECT_TYPE = "G";
            internal string STATION_USER_OBJECT_TYPE = "S";
            internal void createGlobalStatsTablesForBHS(SIM_LoadingForm cht, Hashtable globalUserObjects, string userObjectType, string sKey, DateTime dtBeginDate,
                DateTime dtEndDate, double dStep, double dWarmUp, double analysisRange, double dStepDistribution, int iNbClasses,
                Hashtable htConcatValues, List<BHSStatistic> dashboardConcatStatsList, Hashtable htResults, List<double> percentiles)
            {
                if (cht != null)
                {
                    //cht.ChargementFichier(sKey);
                    cht.ChargementFichier("Scenario \"" + sScenarioName + "\": " + sKey);  // >> Task #16728 PAX2SIM Improvements (Recurring) C#13
                }
                DataTable resultsTable = null;
                StationResult srTmp = ((StationResult)globalUserObjects[sKey]);

                #region Occupation
                resultsTable = ((StationResult)globalUserObjects[sKey]).getMinMaxQueueOccupation(dtBeginDate, dtEndDate, dStep, dWarmUp, analysisRange);
                if (resultsTable != null)
                {
                    concatenateWithColumnsFromChildTables("_Occupation", htConcatValues, srTmp, userObjectType, resultsTable);
                    htResults.Add(resultsTable.TableName, resultsTable);
                }
                #endregion

                #region Remaining Time
                resultsTable = srTmp.getRemainingTime(dtBeginDate, dtEndDate, dStep, dWarmUp, new Double[] { dFirstLevelPercent, dSecondLevelPercent, dThirdLevelPercent });
                if (resultsTable != null)
                {
                    concatenateWithColumnsFromChildTables("_RemainingTime", htConcatValues, srTmp, userObjectType, resultsTable);
                    htResults.Add(resultsTable.TableName, resultsTable);
                }
                #endregion

                #region Distribution
                if (!srTmp.TimeNull)
                {
                    resultsTable = ((StationResult)globalUserObjects[sKey]).getDistribution(false, dStepDistribution, iNbClasses, dWarmUp, dtBeginDate, dtEndDate, dStep);
                    if (resultsTable != null)
                    {
                        concatenateWithColumnsFromChildTables("_Distribution", htConcatValues, srTmp, userObjectType, resultsTable);
                        htResults.Add(resultsTable.TableName, resultsTable);

                    }
                }
                #endregion

                #region Statistics (old and Dashboard)
                resultsTable = srTmp.getStatistics(dWarmUp, dtBeginDate, dtEndDate);
                if (resultsTable != null)
                {
                    concatenateWithColumnsFromChildTables("_Statistics", htConcatValues, srTmp, userObjectType, resultsTable);
                    htResults.Add(resultsTable.TableName, resultsTable);
                }
                DataTable dashboardStatsTable = srTmp.getDashboardStatistics(dWarmUp, dtBeginDate, dtEndDate);
                dashboardStatsTable.TableName = dashboardStatsTable.TableName + GlobalNames.BHS_STATS_TABLE_SUFFIX;
                // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
                DataTable dashboardStatsTable_Mod = srTmp.getDashboardStatistics_modified(dWarmUp, dtBeginDate, dtEndDate);
                htResults.Add(dashboardStatsTable_Mod.TableName, dashboardStatsTable_Mod);

                // << Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
                if (userObjectType == TERMINAL_USER_OBJECT_TYPE)
                {
                    DataTable transpStatsTable = null;
                    foreach (BHSStatistic bhsStat in dashboardConcatStatsList)
                    {
                        transpStatsTable = bhsStat.transpStatsTable;  // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
                        if (srTmp.StationType == bhsStat.stationType)
                        {
                            if (srTmp.terminalIndex == 0)
                            {
                                DataRow titleRow = dashboardStatsTable.NewRow();
                                titleRow[1] = bhsStat.stationType + "_" + bhsStat.terminalNb + "_" + bhsStat.groupNb + "_" + bhsStat.stationNb;
                                dashboardStatsTable.Rows.Add(titleRow);
                                foreach (DataRow concatStatsRow in bhsStat.statsTable.Rows)
                                {
                                    dashboardStatsTable.ImportRow(concatStatsRow);
                                }
                            }
                            else if (srTmp.terminalIndex == bhsStat.terminalNb)
                            {
                                DataRow titleRow = dashboardStatsTable.NewRow();
                                titleRow[1] = bhsStat.stationType + "_" + bhsStat.terminalNb + "_" + bhsStat.groupNb + "_" + bhsStat.stationNb;
                                dashboardStatsTable.Rows.Add(titleRow);
                                foreach (DataRow concatStatsRow in bhsStat.statsTable.Rows)
                                {
                                    dashboardStatsTable.ImportRow(concatStatsRow);
                                }
                            }
                        }
                    }
                    if (transpStatsTable != null)
                        addConcatStationsToGlobalStats(transpStatsTable, dashboardStatsTable_Mod);  // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
                }
                else if (userObjectType == GROUP_USER_OBJECT_TYPE)
                {
                    DataTable transpStatsTable = null;
                    foreach (BHSStatistic bhsStat in dashboardConcatStatsList)
                    {
                        transpStatsTable = bhsStat.transpStatsTable;  // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
                        if (srTmp.StationType == bhsStat.stationType)
                        {
                            if (srTmp.terminalIndex == bhsStat.terminalNb && srTmp.groupIndex == 0)
                            {
                                addTitleRowToBHSDashboardGlobalStatsTable(dashboardStatsTable, bhsStat);
                                foreach (DataRow concatStatsRow in bhsStat.statsTable.Rows)
                                {
                                    dashboardStatsTable.ImportRow(concatStatsRow);
                                }
                            }
                            else if (srTmp.terminalIndex == bhsStat.terminalNb && srTmp.groupIndex == bhsStat.groupNb)
                            {
                                addTitleRowToBHSDashboardGlobalStatsTable(dashboardStatsTable, bhsStat);
                                foreach (DataRow concatStatsRow in bhsStat.statsTable.Rows)
                                {
                                    dashboardStatsTable.ImportRow(concatStatsRow);
                                }
                            }
                        }
                    }
                    if (transpStatsTable != null)
                        addConcatStationsToGlobalStats(transpStatsTable, dashboardStatsTable_Mod);  // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
                }
                else if (userObjectType == STATION_USER_OBJECT_TYPE)
                {
                    DataTable transpStatsTable = null;
                    foreach (BHSStatistic bhsStat in dashboardConcatStatsList)
                    {
                        transpStatsTable = bhsStat.transpStatsTable;  // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
                        if (srTmp.StationType == bhsStat.stationType)
                        {
                            if (srTmp.terminalIndex == bhsStat.terminalNb && srTmp.groupIndex == bhsStat.groupNb && srTmp.StationIndex == 0)
                            {
                                addTitleRowToBHSDashboardGlobalStatsTable(dashboardStatsTable, bhsStat);
                                foreach (DataRow concatStatsRow in bhsStat.statsTable.Rows)
                                {
                                    dashboardStatsTable.ImportRow(concatStatsRow);
                                }
                            }
                            else if (srTmp.terminalIndex == bhsStat.terminalNb && srTmp.groupIndex == bhsStat.groupNb && srTmp.StationIndex == bhsStat.stationNb)
                            {
                                addTitleRowToBHSDashboardGlobalStatsTable(dashboardStatsTable, bhsStat);
                                foreach (DataRow concatStatsRow in bhsStat.statsTable.Rows)
                                {
                                    dashboardStatsTable.ImportRow(concatStatsRow);
                                }
                            }
                        }
                    }
                    if (transpStatsTable != null)
                        addConcatStationsToGlobalStats(transpStatsTable, dashboardStatsTable_Mod);  // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
                }
                htResults.Add(dashboardStatsTable.TableName, dashboardStatsTable);
                #endregion

                #region Utilization
                resultsTable = srTmp.getUtilisation(dtBeginDate, dtEndDate, dStep, dWarmUp, true);
                if (resultsTable != null)
                {
                    concatenateWithColumnsFromChildTables("_Utilization", htConcatValues, srTmp, userObjectType, resultsTable);
                    computeAverageUtilizationAndDeskNeedForGroupUtilizationTable(resultsTable, srTmp.StationType);

                    if (htResults.ContainsKey(resultsTable.TableName))
                    {
                        htResults[resultsTable.TableName] = resultsTable;
                    }
                    else
                    {
                        htResults.Add(resultsTable.TableName, resultsTable);
                    }
                    srTmp.utilizationTable = resultsTable;
                }
                #endregion

                #region Dwell Area
                double totalDwellAreaTime = 0;
                resultsTable = srTmp.createProcessTimePerPeriodOfTimeTable(dtBeginDate, dtEndDate, dStep, dWarmUp, percentiles, out totalDwellAreaTime);
                if (resultsTable != null)
                {
                    concatenateWithColumnsFromChildTables("_DwellArea", htConcatValues, srTmp, userObjectType, resultsTable);
                    htResults.Add(resultsTable.TableName, resultsTable);
                    srTmp.dwellAreaTable = resultsTable;
                    srTmp.totalDwellAreaTime = totalDwellAreaTime;
                }
                #endregion

                #region Local IST
                resultsTable = getBHSLocalInSystemTimesTable(srTmp, dtBeginDate, dtEndDate, false, false);
                if (resultsTable != null)
                    htResults.Add(resultsTable.TableName, resultsTable);
                #endregion
            }

            private void addTitleRowToBHSDashboardGlobalStatsTable(DataTable dashboardStatsTable, BHSStatistic bhsStat)
            {
                DataRow titleRow = dashboardStatsTable.NewRow();
                titleRow[1] = bhsStat.stationType + "_" + bhsStat.terminalNb + "_" + bhsStat.groupNb + "_" + bhsStat.stationNb;
                dashboardStatsTable.Rows.Add(titleRow);
            }

            private void concatenateWithColumnsFromChildTables(string statisticTypeKey, Hashtable htConcatValues, StationResult srTmp,
                string userObjectType, DataTable resultsTable)
            {
                if (htConcatValues.Contains(srTmp.StationType + statisticTypeKey))
                {
                    string columnNamePrefix = getColumnNamePrefixByUserObjectType(userObjectType, srTmp);
                    AddDesksStatisticsForBHSDesks(resultsTable, (DataTable)htConcatValues[srTmp.StationType + statisticTypeKey],
                                                    columnNamePrefix);
                }
            }

            private string getColumnNamePrefixByUserObjectType(string userObjectType, StationResult stationResult)
            {
                string columnNamePrefix = "";
                if (userObjectType.Equals(TERMINAL_USER_OBJECT_TYPE))
                    columnNamePrefix = stationResult.StationType + "_";
                else if (userObjectType.Equals(GROUP_USER_OBJECT_TYPE))
                    columnNamePrefix = stationResult.StationType + "_" + stationResult.terminalIndex;
                else if (userObjectType.Equals(STATION_USER_OBJECT_TYPE))
                    columnNamePrefix = stationResult.StationType + "_" + stationResult.terminalIndex + "_" + stationResult.groupIndex;
                return columnNamePrefix;
            }

            private DataTable getBHSLocalInSystemTimesTable(StationResult stationResult,
                DateTime dtBeginDate, DateTime dtEndDate, bool isSorterIST, bool isICS_IST)
            {
                DataTable localIST = null;
                if (stationResult != null)
                {
                    localIST = new DataTable(stationResult.StationName + "_IST");

                    int bagIdColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_BAG_ID_COLUMN_NAME, typeof(Int32));
                    int paxIdColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_PAX_ID_COLUMN_NAME, typeof(Int32));
                    int stoppedColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_STOPPED_COLUMN_NAME, typeof(Boolean));
                    int beforeWarmUpColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_BEFORE_WARMUP_COLUMN_NAME, typeof(Boolean));

                    int arrivalOrDepartureColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_ARRIVAL_OR_DEPARTURE_COLUMN_NAME, typeof(String));
                    int flightIdColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_FLIGHT_ID_COLUMN_NAME, typeof(Int32));
                    int flightTimeColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_FLIGHT_TIME_COLUMN_NAME, typeof(DateTime));

                    int stationTypeColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_STATION_TYPE_COLUMN_NAME, typeof(String));
                    int terminalNbColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_TERMINAL_NB_COLUMN_NAME, typeof(Int32));
                    int groupNbColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_GROUP_NB_COLUMN_NAME, typeof(Int32));
                    int stationNbColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_STATION_NB_COLUMN_NAME, typeof(Int32));

                    int arrivingTimeColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_ARRIVING_TIME_COLUMN_NAME, typeof(DateTime));
                    int leavingTimeColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_LEAVING_TIME_COLUMN_NAME, typeof(DateTime));
                    int occupationTimeColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_OCCUPATION_TIME_COLUMN_NAME, typeof(Double));
                    int travelTimeColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_TRAVEL_TIME_TO_NEXT_COLUMN_NAME, typeof(Double));

                    int recirculationColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_RECIRCULATION_COLUMN_NAME, typeof(Int32));

                    int timeAtExitColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_TIME_AT_EXIT_COLUMN_NAME, typeof(DateTime));

                    #region Global Information Columns

                    #region Departing
                    int timeAtCIQColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_TIME_AT_CI_QUEUE_COLUMN_NAME, typeof(DateTime));
                    int timeAtCIColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.ARRIVING_TIME_AT_CI_COLUMN_NAME, typeof(DateTime));   // >> #13391 IST Tables standardization - IST - CI times columns
                    int timeAtCICollColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_TIME_AT_CI_COLLECTOR_COLUMN_NAME, typeof(DateTime));
                    int timeAtTransferCollColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add("Time At Transfer Collector", typeof(DateTime));

                    int timeAtDepReadTSColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_TIME_AT_DEP_READER_TS_COLUMN_NAME, typeof(DateTime));

                    int entryTimeAtFirstEBSColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.FIRST_EBS_ENTRY_TIME_COLUMN_NAME, typeof(DateTime));
                    int exitTimeFromLastEBSColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.LAST_EBS_EXIT_TIME_COLUMN_NAME, typeof(DateTime));

                    int timeAtPresortationColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_ARRIVING_TIME_AT_FIRST_PRESORTATION_COLUMN_NAME, typeof(DateTime));
                    int iIndexLeavingTimeFromLastPresortation = localIST.Columns.Count; // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_LEAVING_TIME_FROM_LAST_PRESORTATION_COLUMN_NAME, typeof(DateTime));

                    int timeAtICSToploaderColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_TIME_AT_ICS_TOPLOADER_COLUMN_NAME, typeof(DateTime));
                    int timeAtICSUnloaderColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_TIME_AT_ICS_UNLOADER_COLUMN_NAME, typeof(DateTime));

                    int timeAtLastChuteColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_TIME_AT_LAST_CHUTE_COLUMN_NAME, typeof(DateTime));
                    int timeAtMupColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_TIME_AT_MUP_COLUMN_NAME, typeof(DateTime));

                    int totalTimeFromCIQtoPresortationColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_TIME_FROM_CIQ_TO_PRESORT_COLUMN_NAME, typeof(Double));
                    int totalTimeFromCItoPresortationColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.TOTAL_TIME_FROM_CI_TO_PRESORTATION_COLUMN_NAME, typeof(Double));   // >> #13391 IST Tables standardization - IST - CI times columns
                    int totalTimeFromCIColltoPresortationColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_TIME_FROM_CICOLL_TO_PRESORT_COLUMN_NAME, typeof(Double));
                    int totalTimeFromTransfCollToPresortationColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add("Total Time From Transfer Collector to First Presortation", typeof(Double));

                    int totalTimeFromCIQtoDepReadTSColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_TIME_FROM_CIQ_TO_DEP_READER_COLUMN_NAME, typeof(Double));
                    int totalTimeFromCIQtoLastChuteColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_TIME_FROM_CIQ_TO_LAST_CHUTE_COLUMN_NAME, typeof(Double));
                    int totalTimeFromCIColltoDepReadTSColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_TIME_FROM_CICOLL_TO_DEP_READER_COLUMN_NAME, typeof(Double));
                    int totalTimeFromTransferColltoDepReadTSColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add("Total Time From Transfer Collector to Reader", typeof(Double));

                    int totalTimeFromCItoDepReaderColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.TOTAL_TIME_FROM_CI_TO_DEPREADERTIMESTAMP_COLUMN_NAME, typeof(Double));   // >> #13391 IST Tables standardization - IST - CI times columns
                    int totalTimeFromCItoLastChuteColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.TOTAL_TIME_FROM_CI_TO_LASTCHUTE_COLUMN_NAME, typeof(Double));   // >> #13391 IST Tables standardization - IST - CI times columns

                    int totalTimeFromCIColltoLastChuteColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_TIME_FROM_CICOLL_TO_LAST_CHUTE_COLUMN_NAME, typeof(Double));
                    int totalTimeFromTransfColltoLastChuteColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add("Total Time From Transfer Collector to Last Chute", typeof(Double));

                    int totalTimeFromDepReadTStoLastChuteColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_TIME_FROM_DEP_READER_TO_LAST_CHUTE_COLUMN_NAME, typeof(Double));
                    int totalTimeFromLastChuteToMupColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_TIME_FROM_LAST_CHUTE_TO_MUP_COLUMN_NAME, typeof(Double));

                    int totalTimeFromCIQtoExitColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_TIME_FROM_CIQ_TO_EXIT_COLUMN_NAME, typeof(Double));
                    int totalTimeFromCItoExitColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.TOTAL_TIME_FROM_CI_TO_EXIT_COLUMN_NAME, typeof(Double));
                    int totalTimeFromCIColltoExitColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_TIME_FROM_CICOLL_TO_EXIT_COLUMN_NAME, typeof(Double));
                    int totalTimeFromTransfColltoExitColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add("Total Time From Transfer Collector to Exit", typeof(Double));
                    int totalTimeFromDepReadTStoExitColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_TIME_FROM_DEPREAD_TO_EXIT_COLUMN_NAME, typeof(Double));
                    int totalTimeFromLastChutetoExitColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_TIME_FROM_LAST_CHUTE_TO_EXIT_COLUMN_NAME, typeof(Double));

                    int totalEBSDurationColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.EBS_TOTAL_DURATION, typeof(Double));

                    int ciQueueNbColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_CIQ_NB_COLUMN_NAME, typeof(Int32));
                    int ciNbColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_CI_NB_COLUMN_NAME, typeof(Int32));
                    int ciCollNbColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_CICOLL_NB_COLUMN_NAME, typeof(Int32));
                    int transfCollNbColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add("Transfer Collector", typeof(Int32));

                    int presortationIdentifierColumnIndex = localIST.Columns.Count;    // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation
                    localIST.Columns.Add("Presortation", typeof(String));

                    int depReaderTSNbColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_DEPREAD_NB_COLUMN_NAME, typeof(String));
                    int icsToploaderNbColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_ICS_TOPLOADER_NB_COLUMN_NAME, typeof(String));
                    int icsUnloaderNbColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_ICS_UNLOADER_NB_COLUMN_NAME, typeof(String));

                    int mupNbColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_MUP_NB_COLUMN_NAME, typeof(Int32));

                    int lastChuteNbColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_LAST_CHUTE_NB_COLUMN_NAME, typeof(String));

                    int hbs1NbColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_HBS1_NB_COLUMN_NAME, typeof(Int32));
                    int hbs2NbColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_HBS2_NB_COLUMN_NAME, typeof(Int32));
                    int hbs3NbColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_HBS3_NB_COLUMN_NAME, typeof(Int32));
                    int hbs4NbColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_HBS4_NB_COLUMN_NAME, typeof(Int32));
                    int hbs5NbColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_HBS5_NB_COLUMN_NAME, typeof(Int32));

                    int intLinkNbColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_INTERLINK_NB_COLUMN_NAME, typeof(String));

                    int mesNbColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_MES_NB_COLUMN_NAME, typeof(Int32));
                    int ebsNbColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_EBS_NB_COLUMN_NAME, typeof(Int32));

                    int transferInfeedNbColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_TRANSFER_INFEED_NB_COLUMN_NAME, typeof(Int32));
                    int transferInfeedQueueNbColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_TRANSFER_INFEED_QUEUE_NB_COLUMN_NAME, typeof(Int32));

                    int pbcTypeNbColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_PBC_TYPE_COLUMN_NAME, typeof(Int32));
                    #endregion                   

                    #region Terminating
                    int timeAtInfeedColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_TIME_AT_INFEED_COLUMN_NAME, typeof(DateTime));
                    int timeAtArrivingCollectorColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add("Time At Collector", typeof(DateTime));
                    int totalTimeFromQueueColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_TOTAL_TIME_FROM_QUEUE_COLUMN_NAME, typeof(Double));
                    int totalTimeFromInfeedColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_TOTAL_TIME_FROM_INFEED_COLUMN_NAME, typeof(Double));

                    int arrivingCollectorDeskColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add("Arriving Collector", typeof(Int32));
                    int infeedNbColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_INFEED_NB_COLUMN_NAME, typeof(Int32));
                    int reclaimNbColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_RECLAIM_NB_COLUMN_NAME, typeof(Int32));
                    int hbsTermNbColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_TERM_HBS_NB_COLUMN_NAME, typeof(Int32));
                    int customColumnIndex = localIST.Columns.Count;
                    localIST.Columns.Add(GlobalNames.BHS_IST_TABLE_CUSTOM_COLUMN_NAME, typeof(Int32));
                    #endregion

                    #endregion

                    foreach (StationResult.Result bhsObject in stationResult.alStationUse)
                    {
                        BaggageResult baggageResult = getBaggageResultByBagId(bhsObject.bagId, stationResult.baggageResults);
                        if (baggageResult != null)
                        {
                            DateTime timeAtSystemEntrance = baggageResult.GetTimeAtQueue(dtBeginDate);
                            if (timeAtSystemEntrance != null && timeAtSystemEntrance > dtEndDate)
                            {
                                OverallTools.ExternFunctions.PrintLogFile("Bag trace analysis: The baggage with the Id " + baggageResult.IDBag
                                    + " enters the system at " + timeAtSystemEntrance + "."
                                    + " Because the simulation ends at " + dtEndDate + " the bag is not considered.");
                                continue;
                            }
                            DataRow row = localIST.NewRow();

                            row[bagIdColumnIndex] = bhsObject.bagId;
                            row[paxIdColumnIndex] = bhsObject.passengerId;
                            row[stoppedColumnIndex] = bhsObject.Stopped;

                            row[arrivalOrDepartureColumnIndex] = bhsObject.arrivalOrDeparture;
                            row[flightIdColumnIndex] = bhsObject.flightId;
                            DateTime flightTime = dtBeginDate.AddMinutes(bhsObject.STD);
                            row[flightTimeColumnIndex] = flightTime;

                            row[stationTypeColumnIndex] = stationResult.StationType;
                            row[terminalNbColumnIndex]
                                = getNumberByStationNameAndStructureType(bhsObject.stationName, TERMINAL_USER_OBJECT_TYPE);
                            row[groupNbColumnIndex]
                                = getNumberByStationNameAndStructureType(bhsObject.stationName, GROUP_USER_OBJECT_TYPE);
                            row[stationNbColumnIndex]
                                = getNumberByStationNameAndStructureType(bhsObject.stationName, STATION_USER_OBJECT_TYPE);

                            DateTime arrivingTime = dtBeginDate.AddMinutes(bhsObject.ArrivingTime);
                            row[arrivingTimeColumnIndex] = arrivingTime;
                            DateTime leavingTime = dtBeginDate.AddMinutes(bhsObject.LeavingTime);
                            row[leavingTimeColumnIndex] = leavingTime;
                            row[occupationTimeColumnIndex] = Math.Round(bhsObject.OccupationTime, 2);

                            row[travelTimeColumnIndex] = Math.Round(bhsObject.TravelTime, 2);

                            FLOW_TYPE flowType = getOriginByObjectId(bhsObject.bagId, baggageResult);
                            if (flowType != FLOW_TYPE.NONE)
                            {
                                if (flowType == FLOW_TYPE.TERMINATING)
                                {
                                    #region Terminating Results (for Terminating objects)
                                    TerminatingResult terminatingBagRes = (TerminatingResult)baggageResult;
                                    if (terminatingBagRes != null)
                                    {
                                        row[timeAtCIQColumnIndex] = terminatingBagRes.GetTimeAtQueue(dtBeginDate);
                                        row[timeAtArrivingCollectorColumnIndex] = terminatingBagRes.getArrivingDateAtArrivingCollector(dtBeginDate);
                                        row[timeAtInfeedColumnIndex] = terminatingBagRes.GetTimeAtInfeed(dtBeginDate);

                                        if (terminatingBagRes.getFirstPresortationArrivingTime(dtBeginDate) != DateTime.MinValue && !terminatingBagRes.Stopped)
                                        {
                                            row[timeAtPresortationColumnIndex] = terminatingBagRes.getFirstPresortationArrivingTime(dtBeginDate);
                                        }
                                        if (terminatingBagRes.getLastPresortationLeavingTime(dtBeginDate) != DateTime.MinValue && !terminatingBagRes.Stopped)
                                        {
                                            row[iIndexLeavingTimeFromLastPresortation] = terminatingBagRes.getLastPresortationLeavingTime(dtBeginDate);
                                        }
                                        row[timeAtExitColumnIndex] = terminatingBagRes.GetTimeAtInfeed(dtBeginDate).AddMinutes(Math.Round(terminatingBagRes.TotalSimulationTime, 2));

                                        row[totalTimeFromQueueColumnIndex] = Math.Round(terminatingBagRes.TotalTime, 2);
                                        row[totalTimeFromInfeedColumnIndex] = Math.Round(terminatingBagRes.TotalSimulationTime, 2);

                                        row[arrivingCollectorDeskColumnIndex] = terminatingBagRes.arrivingCollectorDeskIndex;
                                        row[infeedNbColumnIndex] = terminatingBagRes.InfeedIndex;
                                        if (terminatingBagRes.presortationIdentifiers.Count > 0)
                                        {
                                            string ids = "";
                                            for (int i = 0; i < terminatingBagRes.presortationIdentifiers.Count; i++)
                                            {
                                                ids += terminatingBagRes.presortationIdentifiers[i];
                                                if (i < terminatingBagRes.presortationIdentifiers.Count - 1)
                                                {
                                                    ids += ", ";
                                                }
                                            }
                                            row[presortationIdentifierColumnIndex] = ids;
                                        }
                                        row[reclaimNbColumnIndex] = terminatingBagRes.ReclaimIndex;
                                        row[hbsTermNbColumnIndex] = terminatingBagRes.terminatingHBSDeskIndex;
                                        row[customColumnIndex] = terminatingBagRes.terminatingCustomDeskIndex;

                                        row[stoppedColumnIndex] = false;
                                        row[beforeWarmUpColumnIndex] = false;
                                        row[recirculationColumnIndex] = terminatingBagRes.nbRecirculation;

                                        if ((terminatingBagRes.Stopped) || (terminatingBagRes.LeavingSystemTime < warmUpInMinutes))
                                        {
                                            row[stoppedColumnIndex] = terminatingBagRes.Stopped;
                                            row[beforeWarmUpColumnIndex] = (terminatingBagRes.LeavingSystemTime < warmUpInMinutes);
                                            localIST.Rows.Add(row);
                                            continue;
                                        }
                                    }
                                    #endregion
                                }
                                else if (flowType == FLOW_TYPE.ORIGINATING
                                    || flowType == FLOW_TYPE.TRANSFERRING)
                                {
                                    #region Departing Results (for Originating, Transferring)
                                    DepartingResult departingBagRes = (DepartingResult)baggageResult;
                                    if (departingBagRes != null)
                                    {
                                        if (stationResult.StationType == sICS)
                                        {
                                            double arrivingMinuteAtLoader = bhsObject.ArrivingTime;
                                            double leavingMinuteAtLastUnloaderAfterLoaderEntryMinute = departingBagRes
                                                .getLeavingMinuteAtLastGivenStationTypeAfterGivenStationEntryMinute(sICSUnloader,
                                                    bhsObject.ArrivingTime, bhsObject.stationGroupIndex);
                                            if (leavingMinuteAtLastUnloaderAfterLoaderEntryMinute != -1)
                                                row[leavingTimeColumnIndex] = dtBeginDate.AddMinutes(leavingMinuteAtLastUnloaderAfterLoaderEntryMinute);
                                            else
                                                row[leavingTimeColumnIndex] = DBNull.Value;
                                            if (arrivingMinuteAtLoader == -1 || leavingMinuteAtLastUnloaderAfterLoaderEntryMinute == -1)
                                                row[occupationTimeColumnIndex] = 0;
                                            else
                                            {
                                                row[occupationTimeColumnIndex] = Math.Round(leavingMinuteAtLastUnloaderAfterLoaderEntryMinute
                                                                                            - arrivingMinuteAtLoader, 2);
                                            }
                                        }
                                        else if (bhsObject.stationType == BHS_KEYWORD_SORTER)
                                        {
                                            double arrivingMinuteAtFirstSortIndAfterSorterEntryMinute = departingBagRes
                                                .getArrivingMinuteAtFirstGivenStationTypeAfterGivenStationEntryMinute(OriginatingTransferSorterInduction,
                                                 bhsObject.ArrivingTime, bhsObject.stationGroupIndex);
                                            double leavingMinuteFromLastSortIndAfterICSEntryMinute = departingBagRes
                                                .getLeavingMinuteAtLastGivenStationTypeAfterGivenStationEntryMinute(OriginatingTransferSorterInduction,
                                                 bhsObject.ArrivingTime, bhsObject.stationGroupIndex);

                                            row[leavingTimeColumnIndex] = dtBeginDate.AddMinutes(leavingMinuteFromLastSortIndAfterICSEntryMinute);
                                            if (arrivingMinuteAtFirstSortIndAfterSorterEntryMinute == -1 || leavingMinuteFromLastSortIndAfterICSEntryMinute == -1)
                                                row[occupationTimeColumnIndex] = 0;
                                            else
                                            {
                                                row[occupationTimeColumnIndex] = Math.Round(leavingMinuteFromLastSortIndAfterICSEntryMinute
                                                                                            - arrivingMinuteAtFirstSortIndAfterSorterEntryMinute, 2);
                                            }
                                        }
                                        row[timeAtCIQColumnIndex] = departingBagRes.GetTimeAtQueue(dtBeginDate);
                                        DateTime arrivalTimeAtCheckIn = departingBagRes.getArrivalTimeAtCheckIn(dtBeginDate);
                                        if (arrivalTimeAtCheckIn != DateTime.MinValue)
                                            row[timeAtCIColumnIndex] = arrivalTimeAtCheckIn;

                                        //row[timeAtCICollColumnIndex] = departingBagRes.GetTimeAtColl(dtBeginDate);

                                        if (departingBagRes.checkInCollectorArrivingDate(dtBeginDate) != DateTime.MinValue)
                                            row[timeAtCICollColumnIndex] = departingBagRes.checkInCollectorArrivingDate(dtBeginDate);
                                        if (departingBagRes.transferCollectorLeavingDate(dtBeginDate) != DateTime.MinValue)
                                            row[timeAtTransferCollColumnIndex] = departingBagRes.transferCollectorLeavingDate(dtBeginDate);

                                        row[timeAtDepReadTSColumnIndex] = departingBagRes.getArrivingTimeAtDepReaderTimeStamp(dtBeginDate);
                                        row[timeAtExitColumnIndex] = departingBagRes.GetTimeAtColl(dtBeginDate).AddMinutes(Math.Round(departingBagRes.TotalSimulationTime, 2));
                                        row[totalTimeFromCIQtoExitColumnIndex] = Math.Round(departingBagRes.TotalTime, 2);
                                        //row[totalTimeFromCIColltoExitColumnIndex] = Math.Round(departingBagRes.TotalSimulationTime, 2);
                                        row[totalTimeFromCIColltoExitColumnIndex] = Math.Round(departingBagRes.getMinutesFromCheckInCollectorArrivingToLastStationLeaving(), 2);
                                        row[totalTimeFromTransfColltoExitColumnIndex] = Math.Round(departingBagRes.getMinutesFromTransferCollectorArrivingToLastStationLeaving(), 2);

                                        // >> Task #7949 Capacity Analysis - IST tables modification C#4
                                        DateTime firstEbsEntryTime = departingBagRes.getTimeAtFirstEBS(dtBeginDate);
                                        if (firstEbsEntryTime != DateTime.MinValue)
                                        {
                                            row[entryTimeAtFirstEBSColumnIndex] = firstEbsEntryTime;
                                        }
                                        DateTime lastEbsExitTime = departingBagRes.getExitTimeFromLastEBS(dtBeginDate);
                                        if (lastEbsExitTime != DateTime.MinValue)
                                        {
                                            row[exitTimeFromLastEBSColumnIndex] = lastEbsExitTime;
                                        }
                                        row[totalEBSDurationColumnIndex] = Math.Round(departingBagRes.getEBSStorageMinutesBetweenGivenMinutes(0, double.MaxValue), 2);
                                        // >> Task #7949 Capacity Analysis - IST tables modification C#4

                                        row[ciNbColumnIndex] = departingBagRes.CheckInIndex;
                                        row[ciCollNbColumnIndex] = departingBagRes.CheckInCollectorIndex;
                                        row[ciQueueNbColumnIndex] = departingBagRes.checkInQueueDeskIndex;
                                        row[transfCollNbColumnIndex] = departingBagRes.CheckInCollectorIndex;
                                        row[mupNbColumnIndex] = departingBagRes.MakeUpIndex;
                                        row[lastChuteNbColumnIndex] = departingBagRes.LastChuteDeskWithTwoIndexes;

                                        row[stoppedColumnIndex] = false;
                                        row[beforeWarmUpColumnIndex] = false;
                                        if (departingBagRes.pbcType == -1)
                                            row[pbcTypeNbColumnIndex] = 0;
                                        else
                                            row[pbcTypeNbColumnIndex] = departingBagRes.pbcType;
                                        row[recirculationColumnIndex] = departingBagRes.nbRecirculation;

                                        DateTime timeAtLastChute = departingBagRes.GetArrivingTimeAtLastChute(dtBeginDate);
                                        if (timeAtLastChute != DateTime.MinValue && !departingBagRes.Stopped)
                                        {
                                            double ebsTimeBeforeLastChuteArrivingTime = departingBagRes.getEBSTimeBeforeProcessTime(departingBagRes.LastChuteArrivingMinute);
                                            row[timeAtLastChuteColumnIndex] = timeAtLastChute;
                                            row[totalTimeFromCIQtoLastChuteColumnIndex] = Math.Round(timeAtLastChute.Subtract(departingBagRes.GetTimeAtQueue(dtBeginDate)).TotalMinutes - ebsTimeBeforeLastChuteArrivingTime, 2);
                                            //row[totalTimeFromCIColltoLastChuteColumnIndex] = Math.Round(timeAtLastChute.Subtract(departingBagRes.GetTimeAtColl(dtBeginDate)).TotalMinutes - ebsTimeBeforeLastChuteArrivingTime, 2);
                                            if (departingBagRes.checkInCollectorArrivingDate(dtBeginDate) != DateTime.MinValue)
                                                row[totalTimeFromCIColltoLastChuteColumnIndex] = Math.Round(timeAtLastChute.Subtract(departingBagRes.checkInCollectorArrivingDate(dtBeginDate)).TotalMinutes - ebsTimeBeforeLastChuteArrivingTime, 2);
                                            if (departingBagRes.transferCollectorArrivingDate(dtBeginDate) != DateTime.MinValue)
                                                row[totalTimeFromTransfColltoLastChuteColumnIndex] = Math.Round(timeAtLastChute.Subtract(departingBagRes.transferCollectorArrivingDate(dtBeginDate)).TotalMinutes - ebsTimeBeforeLastChuteArrivingTime, 2);
                                        }

                                        DateTime timeAtFirstPresortation = departingBagRes.getFirstPresortationArrivingTime(dtBeginDate); //GetTimeAtPresortationDepVSUInputDn(dtBeginDate);   // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation
                                        if (timeAtFirstPresortation != DateTime.MinValue && !departingBagRes.Stopped)
                                        {
                                            row[timeAtPresortationColumnIndex] = timeAtFirstPresortation;
                                            if (departingBagRes.getLastPresortationLeavingTime(dtBeginDate) != DateTime.MinValue)
                                            {
                                                row[iIndexLeavingTimeFromLastPresortation] = departingBagRes.getLastPresortationLeavingTime(dtBeginDate);
                                            }
                                            double ebsTimeBeforePresortationArrivingTime = departingBagRes.getEBSTimeBeforeProcessTime(departingBagRes.firstPresortationArrivingMinute);    //PresortationDepVSUInputDn1_4ArrivingTime);
                                            row[totalTimeFromCIQtoPresortationColumnIndex] = Math.Round(timeAtFirstPresortation.Subtract(departingBagRes.GetTimeAtQueue(dtBeginDate)).TotalMinutes - ebsTimeBeforePresortationArrivingTime, 2);
                                            if (departingBagRes.checkInCollectorArrivingDate(dtBeginDate) != DateTime.MinValue)
                                                row[totalTimeFromCIColltoPresortationColumnIndex] = Math.Round(timeAtFirstPresortation.Subtract(departingBagRes.checkInCollectorArrivingDate(dtBeginDate)).TotalMinutes - ebsTimeBeforePresortationArrivingTime, 2);
                                            if (departingBagRes.transferCollectorArrivingDate(dtBeginDate) != DateTime.MinValue)
                                                row[totalTimeFromTransfCollToPresortationColumnIndex] = Math.Round(timeAtFirstPresortation.Subtract(departingBagRes.transferCollectorArrivingDate(dtBeginDate)).TotalMinutes - ebsTimeBeforePresortationArrivingTime, 2);
                                        }

                                        Double arrivalMinuteAtDepReaderTimeStamp = departingBagRes.getArrivingMinuteAtDepReaderTimeStamp();
                                        DateTime arrivalTimeAtDepReaderTimeStamp = departingBagRes.getArrivingTimeAtDepReaderTimeStamp(dtBeginDate);
                                        if (arrivalTimeAtDepReaderTimeStamp != DateTime.MinValue && arrivalMinuteAtDepReaderTimeStamp != -1 && !departingBagRes.Stopped)
                                        {
                                            double ebsTimeBeforDepReaderTimeStamp = departingBagRes.getEBSTimeBeforeProcessTime(arrivalMinuteAtDepReaderTimeStamp);
                                            row[totalTimeFromCIQtoDepReadTSColumnIndex] = Math.Round(arrivalTimeAtDepReaderTimeStamp.Subtract(departingBagRes.GetTimeAtQueue(dtBeginDate)).TotalMinutes - ebsTimeBeforDepReaderTimeStamp, 2);
                                            //row[totalTimeFromCIColltoDepReadTSColumnIndex] = Math.Round(arrivalTimeAtDepReaderTimeStamp.Subtract(departingBagRes.GetTimeAtColl(dtBeginDate)).TotalMinutes - ebsTimeBeforDepReaderTimeStamp, 2);

                                            if (departingBagRes.checkInCollectorArrivingDate(dtBeginDate) != DateTime.MinValue)
                                                row[totalTimeFromCIColltoDepReadTSColumnIndex] = Math.Round(arrivalTimeAtDepReaderTimeStamp.Subtract(departingBagRes.checkInCollectorArrivingDate(dtBeginDate)).TotalMinutes - ebsTimeBeforDepReaderTimeStamp, 2);
                                            if (departingBagRes.transferCollectorArrivingDate(dtBeginDate) != DateTime.MinValue)
                                                row[totalTimeFromTransferColltoDepReadTSColumnIndex] = Math.Round(arrivalTimeAtDepReaderTimeStamp.Subtract(departingBagRes.transferCollectorArrivingDate(dtBeginDate)).TotalMinutes - ebsTimeBeforDepReaderTimeStamp, 2);

                                            if (timeAtLastChute != DateTime.MinValue)
                                                row[totalTimeFromDepReadTStoLastChuteColumnIndex] = Math.Round(timeAtLastChute.Subtract(arrivalTimeAtDepReaderTimeStamp).TotalMinutes, 2);
                                            row[totalTimeFromDepReadTStoExitColumnIndex] = Math.Round(departingBagRes.LeavingSystemTime - arrivalMinuteAtDepReaderTimeStamp, 2);
                                        }

                                        timeAtLastChute = departingBagRes.GetArrivingTimeAtLastChute(dtBeginDate);
                                        if (timeAtLastChute != DateTime.MinValue && !departingBagRes.Stopped)
                                        {
                                            leavingTime = dtBeginDate.AddMinutes(departingBagRes.LeavingSystemTime);
                                            row[totalTimeFromLastChutetoExitColumnIndex] = Math.Round(leavingTime.Subtract(timeAtLastChute).TotalMinutes, 2);
                                        }

                                        timeAtLastChute = departingBagRes.GetArrivingTimeAtLastChute(dtBeginDate);
                                        DateTime arrivingTimeAtMakeUp = departingBagRes.getArrivingTimeAtMup(dtBeginDate);
                                        if (timeAtLastChute != DateTime.MinValue && arrivingTimeAtMakeUp != DateTime.MinValue)
                                        {
                                            row[totalTimeFromLastChuteToMupColumnIndex] = Math.Round(arrivingTimeAtMakeUp.Subtract(timeAtLastChute).TotalMinutes, 2);
                                        }

                                        DateTime arrivingTimeAtICSToploader = departingBagRes.getArrivingTimeAtICSToploader(dtBeginDate);
                                        if (arrivingTimeAtICSToploader != DateTime.MinValue && !departingBagRes.Stopped)
                                        {
                                            row[timeAtICSToploaderColumnIndex] = arrivingTimeAtICSToploader;
                                        }
                                        DateTime arrivingTimeAtICSUnloader = departingBagRes.getArrivingTimeAtICSUnloader(dtBeginDate);
                                        if (arrivingTimeAtICSUnloader != DateTime.MinValue && !departingBagRes.Stopped)
                                        {
                                            row[timeAtICSUnloaderColumnIndex] = arrivingTimeAtICSUnloader;
                                        }
                                        DateTime arrivingTimeAtMup = departingBagRes.getArrivingTimeAtMup(dtBeginDate);
                                        if (arrivingTimeAtMup != DateTime.MinValue && !departingBagRes.Stopped)
                                        {
                                            row[timeAtMupColumnIndex] = arrivingTimeAtMup;
                                        }

                                        // >> #13391 IST Tables standardization - IST - CI times columns
                                        if (totalTimeFromCItoDepReaderColumnIndex != -1 && departingBagRes.getMinutesFromCheckInToDepReaderTimeStamp(dtBeginDate) >= 0)
                                            row[totalTimeFromCItoDepReaderColumnIndex] = departingBagRes.getMinutesFromCheckInToDepReaderTimeStamp(dtBeginDate);

                                        if (totalTimeFromCItoPresortationColumnIndex != -1 && departingBagRes.getMinutesFromCheckInToFirstPresortation(dtBeginDate) >= 0)
                                            row[totalTimeFromCItoPresortationColumnIndex] = departingBagRes.getMinutesFromCheckInToFirstPresortation(dtBeginDate);

                                        if (totalTimeFromCItoLastChuteColumnIndex != -1 && departingBagRes.getMinutesFromCheckInToLastChute(dtBeginDate) >= 0)
                                            row[totalTimeFromCItoLastChuteColumnIndex] = departingBagRes.getMinutesFromCheckInToLastChute(dtBeginDate);

                                        if (totalTimeFromCItoExitColumnIndex != -1 && departingBagRes.getMinutesFromCheckInToExit(dtBeginDate) >= 0)
                                            row[totalTimeFromCItoExitColumnIndex] = departingBagRes.getMinutesFromCheckInToExit(dtBeginDate);
                                        // << #13391 IST Tables standardization - IST - CI times columns

                                        #region HBS1..5
                                        row[hbs1NbColumnIndex] = departingBagRes.originatingTransferHBS1DeskIndex;
                                        row[hbs2NbColumnIndex] = departingBagRes.originatingTransferHBS2DeskIndex;
                                        row[hbs3NbColumnIndex] = departingBagRes.originatingTransferHBS3DeskIndex;
                                        row[hbs4NbColumnIndex] = departingBagRes.originatingTransferHBS4DeskIndex;
                                        row[hbs5NbColumnIndex] = departingBagRes.originatingTransferHBS5DeskIndex;
                                        row[mesNbColumnIndex] = departingBagRes.originatingTransferMESDeskIndex;
                                        row[ebsNbColumnIndex] = departingBagRes.firstEBSDeskIndex;
                                        #endregion

                                        #region InterLink
                                        String allInterLinkIndexes = "";
                                        if (departingBagRes.allInterLinkDeskIndexesList != null && departingBagRes.allInterLinkDeskIndexesList.Count > 0)
                                        {
                                            for (int i = 0; i < departingBagRes.allInterLinkDeskIndexesList.Count; i++)
                                            {
                                                String interLinkIndex = departingBagRes.allInterLinkDeskIndexesList[i];
                                                allInterLinkIndexes += interLinkIndex;
                                                if (i < departingBagRes.allInterLinkDeskIndexesList.Count - 1)
                                                {
                                                    allInterLinkIndexes += ", ";
                                                }
                                            }
                                            row[intLinkNbColumnIndex] = allInterLinkIndexes;
                                        }
                                        else
                                        {
                                            row[intLinkNbColumnIndex] = -1;
                                        }
                                        #endregion

                                        #region ICS
                                        if (departingBagRes.ICSToploaderTwoDeskIndexes != null
                                            && departingBagRes.ICSToploaderTwoDeskIndexes != "")
                                        {
                                            row[icsToploaderNbColumnIndex] = departingBagRes.ICSToploaderTwoDeskIndexes;
                                        }
                                        else
                                        {
                                            row[icsToploaderNbColumnIndex] = "-1";
                                        }

                                        if (departingBagRes.ICSUnloaderTwoDeskIndexes != null && departingBagRes.ICSUnloaderTwoDeskIndexes != "")
                                        {
                                            row[icsUnloaderNbColumnIndex] = departingBagRes.ICSUnloaderTwoDeskIndexes;
                                        }
                                        else
                                        {
                                            row[icsUnloaderNbColumnIndex] = "-1";
                                        }
                                        #endregion


                                        if (departingBagRes.DepReaderTimestampTwoDeskIndexes != null && departingBagRes.DepReaderTimestampTwoDeskIndexes != "")
                                        {
                                            row[depReaderTSNbColumnIndex] = departingBagRes.DepReaderTimestampTwoDeskIndexes;
                                        }
                                        else
                                        {
                                            row[depReaderTSNbColumnIndex] = "-1";
                                        }

                                        if (departingBagRes.transferringInfeedDeskIndex >= 0)
                                            row[transferInfeedNbColumnIndex] = departingBagRes.transferringInfeedDeskIndex;
                                        else
                                            row[transferInfeedNbColumnIndex] = -1;

                                        if (departingBagRes.transferringQueueDeskIndex >= 0)
                                            row[transferInfeedQueueNbColumnIndex] = departingBagRes.transferringQueueDeskIndex;
                                        else
                                            row[transferInfeedQueueNbColumnIndex] = -1;

                                        if ((departingBagRes.Stopped) || (departingBagRes.LeavingSystemTime < warmUpInMinutes))
                                        {
                                            row[stoppedColumnIndex] = departingBagRes.Stopped;
                                            row[beforeWarmUpColumnIndex] = (departingBagRes.LeavingSystemTime < warmUpInMinutes);
                                            localIST.Rows.Add(row);
                                            continue;
                                        }
                                        if (departingBagRes.presortationIdentifiers.Count > 0)
                                        {
                                            string ids = "";
                                            for (int i = 0; i < departingBagRes.presortationIdentifiers.Count; i++)
                                            {
                                                ids += departingBagRes.presortationIdentifiers[i];
                                                if (i < departingBagRes.presortationIdentifiers.Count - 1)
                                                {
                                                    ids += ", ";
                                                }
                                            }
                                            row[presortationIdentifierColumnIndex] = ids;
                                        }
                                    }
                                    #endregion
                                }
                            }
                            localIST.Rows.Add(row);
                        }
                    }
                    localIST.AcceptChanges();
                }
                return localIST;
            }

            private BaggageResult getBaggageResultByBagId(int bagId, List<BaggageResult> baggageResults)
            {
                if (baggageResults != null)
                {
                    foreach (BaggageResult bagRes in baggageResults)
                    {
                        if (bagRes != null && bagRes.IDBag == bagId)
                        {
                            return bagRes;
                        }
                    }
                }
                return null;
            }

            private int getNumberByStationNameAndStructureType(string stationName, string structureType)
            {
                int stationNb = -1;
                string[] splittedStationName = stationName.Split('_');

                if (structureType == TERMINAL_USER_OBJECT_TYPE)
                {
                    if (splittedStationName.Length == 4)
                    {
                        Int32.TryParse(splittedStationName[1], out stationNb);
                    }
                }
                else if (structureType == GROUP_USER_OBJECT_TYPE)
                {
                    if (splittedStationName.Length == 4)
                    {
                        Int32.TryParse(splittedStationName[2], out stationNb);
                    }
                    else if (splittedStationName.Length == 3)
                    {
                        Int32.TryParse(splittedStationName[1], out stationNb);
                    }
                }
                else if (structureType == STATION_USER_OBJECT_TYPE)
                {
                    Int32.TryParse(splittedStationName[splittedStationName.Length - 1], out stationNb);
                }
                return stationNb;
            }

            internal enum FLOW_TYPE { TERMINATING, TRANSFERRING, ORIGINATING, NONE };    // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation            
            private FLOW_TYPE getOriginByObjectId(int objectId, BaggageResult baggageResult)
            {
                FLOW_TYPE flowType = FLOW_TYPE.NONE;
                if (baggageResult != null)
                {
                    if (baggageResult.GetType() == typeof(TerminatingResult))
                        flowType = FLOW_TYPE.TERMINATING;
                    else if (baggageResult.GetType() == typeof(TransferringResult))
                        flowType = FLOW_TYPE.TRANSFERRING;
                    else if (baggageResult.GetType() == typeof(OriginatingResult))
                        flowType = FLOW_TYPE.ORIGINATING;
                }
                return flowType;
            }
            // << Task #13422 Keywords improvement

            // >> Task #13391 IST tables standardization
            private DataTable getGlobalISTByStationType(string stationType, Hashtable htResults)
            {
                DataTable globalIST = null;
                if (BHS_OBJECTS_LIST_ORIGINATING.Contains(stationType))
                {
                    if (htResults.ContainsKey(ORIGINATING_GLOBAL_IST_TABLE_NAME))
                    {
                        globalIST = (DataTable)htResults[ORIGINATING_GLOBAL_IST_TABLE_NAME];
                    }
                }
                else if (BHS_OBJECTS_LIST_DEPARTING.Contains(stationType))
                {
                    if (htResults.ContainsKey(DEPARTING_GLOBAL_IST_TABLE_NAME))
                    {
                        globalIST = (DataTable)htResults[DEPARTING_GLOBAL_IST_TABLE_NAME];
                    }
                }
                else if (BHS_OBJECTS_LIST_TRANSFERRING.Contains(stationType))
                {
                    if (htResults.ContainsKey(TRANSFERRING_GLOBAL_IST_TABLE_NAME))
                    {
                        globalIST = (DataTable)htResults[TRANSFERRING_GLOBAL_IST_TABLE_NAME];
                    }
                }
                else if (BHS_OBJECTS_LIST_TERMINATING.Contains(stationType))
                {
                    if (htResults.ContainsKey(TERMINATING_GLOBAL_IST_TABLE_NAME))
                    {
                        globalIST = (DataTable)htResults[TERMINATING_GLOBAL_IST_TABLE_NAME];
                    }
                }
                return globalIST;
            }
            // << Task #13391 IST tables standardization

            // >> Task #11603 Pax2Sim - BHS analysis - Dashboard for Times stats
            public const string STATISTIC_TABLE_TYPE_COLUMN_NAME = "Type";
            public const string STATISTIC_TABLE_NB_BAGS_COLUMN_NAME = "Nb Bags";
            public const string STATISTIC_TABLE_MIN_COLUMN_NAME = "Min";
            public const string STATISTIC_TABLE_AVG_COLUMN_NAME = "Average";
            public const string STATISTIC_TABLE_MAX_COLUMN_NAME = "Max";
            public const string STATISTIC_TABLE_LEVEL_SUFFIX_COLUMN_NAME = " %";

            private static class SourceStatisticTableColumnIndexes
            {
                public static int typeColumnIndex = -1;
                public static int nbBagsColumnIndex = -1;
                public static int percentOfGlobalColumnIndex = -1;
                public static int minColumnIndex = -1;
                public static int avgColumnIndex = -1;
                public static int maxColumnIndex = -1;
                public static int level1ColumnIndex = -1;
                public static int level2ColumnIndex = -1;
                public static int level3ColumnIndex = -1;

                public static void setUpIndexes(DataTable statisticTable,
                    Double level1, Double level2, Double level3)
                {
                    if (statisticTable == null)
                    {
                        return;
                    }
                    typeColumnIndex = statisticTable.Columns.IndexOf(STATISTIC_TABLE_TYPE_COLUMN_NAME);
                    nbBagsColumnIndex = statisticTable.Columns.IndexOf(STATISTIC_TABLE_NB_BAGS_COLUMN_NAME);
                    percentOfGlobalColumnIndex = statisticTable.Columns.IndexOf(GlobalNames.BHS_STATISTICS_TABLE_PERCENT_OF_GLOBAL_COLUMN_NAME);
                    minColumnIndex = statisticTable.Columns.IndexOf(STATISTIC_TABLE_MIN_COLUMN_NAME);
                    avgColumnIndex = statisticTable.Columns.IndexOf(STATISTIC_TABLE_AVG_COLUMN_NAME);
                    maxColumnIndex = statisticTable.Columns.IndexOf(STATISTIC_TABLE_MAX_COLUMN_NAME);
                    level1ColumnIndex = statisticTable.Columns.IndexOf(level1.ToString() + STATISTIC_TABLE_LEVEL_SUFFIX_COLUMN_NAME);
                    level2ColumnIndex = statisticTable.Columns.IndexOf(level2.ToString() + STATISTIC_TABLE_LEVEL_SUFFIX_COLUMN_NAME);
                    level3ColumnIndex = statisticTable.Columns.IndexOf(level3.ToString() + STATISTIC_TABLE_LEVEL_SUFFIX_COLUMN_NAME);
                }
            }
            private static class StatisticTableColumnIndexes
            {
                public static int kpiIdColumnIndex = -1;
                public static int kpiNameColumnIndex = -1;
                public static int totalValueColumnIndex = -1;
                public static int totalValueUnitColumnIndex = -1;
                public static int percentOfGlobalColumnIndex = -1;
                public static int minValueColumnIndex = -1;
                public static int avgValueColumnIndex = -1;
                public static int maxValueColumnIndex = -1;
                public static int maxLevel1ValueColumnIndex = -1;
                public static int maxLevel2ValueColumnIndex = -1;
                public static int maxLevel3ValueColumnIndex = -1;
                public static int unitColumnIndex = -1;
            }

            private class KPIGroup
            {
                public String groupName = "";
                public List<KPIHelper> kpisList = new List<KPIHelper>();
            }
            public class KPIHelper
            {
                public int id = -1;
                public String data = "";
                public String totalValue = "";
                public String totalValueUnitName = "";
                public String percentOfGlobal = "";
                public String minValue = "";
                public String avgValue = "";
                public String maxValue = "";
                public String level1Value = "";
                public String level2Value = "";
                public String level3Value = "";
                public String unitName = "";
            }

            public static readonly String TIMES_DIRECTORY_STATISTIC_TABLE_SUFFIX = "__Statistics";
            private static List<DataTable> getAllTimesDirectoryStatisticsTables(Hashtable results)
            {
                List<DataTable> timesDirectoryStatisticsTables = new List<DataTable>();
                if (results != null)
                {
                    foreach (DictionaryEntry pair in results)
                    {
                        if (pair.Key != null && pair.Value != null)
                        {
                            String statisticTableName = pair.Key.ToString();
                            DataTable statisticTable = (DataTable)pair.Value;
                            if (statisticTableName != null && statisticTableName.Contains(TIMES_DIRECTORY_STATISTIC_TABLE_SUFFIX)
                                && pair.Value != null)
                            {
                                timesDirectoryStatisticsTables.Add(statisticTable);
                            }
                        }
                    }
                }
                return timesDirectoryStatisticsTables;
            }

            private DataTable createAndFillSummaryTableForBHSTimesDirectory(DataTable statisticTable)
            {
                DataTable summaryTable = createSummaryTableStructureForBHSTimesDirectory(statisticTable);
                List<KPIGroup> kpiGroupsList = extractKPIsFromStatisticTable(statisticTable);
                fillSummaryTable(summaryTable, kpiGroupsList);
                return summaryTable;
            }

            private DataTable createSummaryTableStructureForBHSTimesDirectory(DataTable statisticTable)
            {
                DataTable summaryTable = new DataTable(statisticTable.TableName + GlobalNames.BHS_STATS_TABLE_SUFFIX);

                StatisticTableColumnIndexes.kpiIdColumnIndex = summaryTable.Columns.Count;
                summaryTable.Columns.Add(GlobalNames.SUMMARY_TABLE_KPI_ID_COLUMN_NAME, typeof(Int32));

                StatisticTableColumnIndexes.kpiNameColumnIndex = summaryTable.Columns.Count;
                summaryTable.Columns.Add(GlobalNames.SUMMARY_TABLE_DATA_COLUMN_NAME, typeof(String));

                StatisticTableColumnIndexes.totalValueColumnIndex = summaryTable.Columns.Count;
                summaryTable.Columns.Add(GlobalNames.SUMMARY_TABLE_VALUE_COLUMN_NAME, typeof(String));

                StatisticTableColumnIndexes.totalValueUnitColumnIndex = summaryTable.Columns.Count;
                summaryTable.Columns.Add(GlobalNames.BHS_STATS_TABLE_TOTAL_VALUE_UNIT_COLUMN_NAME, typeof(String));

                StatisticTableColumnIndexes.percentOfGlobalColumnIndex = summaryTable.Columns.Count;
                summaryTable.Columns.Add(GlobalNames.BHS_STATISTICS_TABLE_PERCENT_OF_GLOBAL_COLUMN_NAME, typeof(String));

                StatisticTableColumnIndexes.minValueColumnIndex = summaryTable.Columns.Count;
                summaryTable.Columns.Add(GlobalNames.SUMMARY_TABLE_MIN_VALUE_COLUMN_NAME, typeof(String));

                StatisticTableColumnIndexes.avgValueColumnIndex = summaryTable.Columns.Count;
                summaryTable.Columns.Add(GlobalNames.SUMMARY_TABLE_AVG_VALUE_COLUMN_NAME, typeof(String));

                StatisticTableColumnIndexes.maxValueColumnIndex = summaryTable.Columns.Count;
                summaryTable.Columns.Add(GlobalNames.SUMMARY_TABLE_MAX_VALUE_COLUMN_NAME, typeof(String));

                StatisticTableColumnIndexes.maxLevel1ValueColumnIndex = summaryTable.Columns.Count;
                summaryTable.Columns
                    .Add(dFirstLevelPercent + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(String));

                int maxLevel2ValueColumnIndex = summaryTable.Columns.Count;
                StatisticTableColumnIndexes.maxLevel2ValueColumnIndex = maxLevel2ValueColumnIndex;
                summaryTable.Columns
                    .Add(dSecondLevelPercent + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(String));

                StatisticTableColumnIndexes.maxLevel3ValueColumnIndex = summaryTable.Columns.Count;
                summaryTable.Columns
                    .Add(dThirdLevelPercent + GlobalNames.SUMMARY_TABLE_DISTRIBUTION_LEVEL_COLUMN_SUFIX, typeof(String));

                StatisticTableColumnIndexes.unitColumnIndex = summaryTable.Columns.Count;
                summaryTable.Columns.Add(GlobalNames.SUMMARY_TABLE_UNIT_COLUMN_NAME, typeof(String));

                return summaryTable;
            }

            private List<KPIGroup> extractKPIsFromStatisticTable(DataTable statisticTable)
            {
                List<KPIGroup> kpiGroupsList = new List<KPIGroup>();

                KPIGroup kpiGroup = new KPIGroup();

                int kpiId = 1;
                foreach (DataRow dr in statisticTable.Rows)
                {
                    String type = "";
                    String nbBags = "";
                    String percentOfGlobal = "";
                    String min = "";
                    String avg = "";
                    String max = "";
                    String level1 = "";
                    String level2 = "";
                    String level3 = "";

                    if (SourceStatisticTableColumnIndexes.typeColumnIndex != -1)
                    {
                        type = dr[SourceStatisticTableColumnIndexes.typeColumnIndex].ToString();
                    }
                    if (SourceStatisticTableColumnIndexes.nbBagsColumnIndex != -1)
                    {
                        nbBags = dr[SourceStatisticTableColumnIndexes.nbBagsColumnIndex].ToString();
                    }
                    if (SourceStatisticTableColumnIndexes.percentOfGlobalColumnIndex != -1)
                    {
                        percentOfGlobal = dr[SourceStatisticTableColumnIndexes.percentOfGlobalColumnIndex].ToString();
                    }
                    if (SourceStatisticTableColumnIndexes.minColumnIndex != -1)
                    {
                        min = dr[SourceStatisticTableColumnIndexes.minColumnIndex].ToString();
                    }
                    if (SourceStatisticTableColumnIndexes.avgColumnIndex != -1)
                    {
                        avg = dr[SourceStatisticTableColumnIndexes.avgColumnIndex].ToString();
                    }
                    if (SourceStatisticTableColumnIndexes.maxColumnIndex != -1)
                    {
                        max = dr[SourceStatisticTableColumnIndexes.maxColumnIndex].ToString();
                    }
                    if (SourceStatisticTableColumnIndexes.level1ColumnIndex != -1)
                    {
                        level1 = dr[SourceStatisticTableColumnIndexes.level1ColumnIndex].ToString();
                    }
                    if (SourceStatisticTableColumnIndexes.level2ColumnIndex != -1)
                    {
                        level2 = dr[SourceStatisticTableColumnIndexes.level2ColumnIndex].ToString();
                    }
                    if (SourceStatisticTableColumnIndexes.level3ColumnIndex != -1)
                    {
                        level3 = dr[SourceStatisticTableColumnIndexes.level3ColumnIndex].ToString();
                    }
                    if (isKPIGroupHeader(dr))
                    {
                        kpiGroupsList.Add(kpiGroup);

                        kpiGroup = new KPIGroup();
                        kpiGroup.groupName = type;
                        kpiId = 1;
                    }
                    else
                    {
                        KPIHelper kpiHelper = new KPIHelper();
                        kpiHelper.id = kpiId++;
                        kpiHelper.data = type;
                        kpiHelper.totalValue = nbBags;
                        kpiHelper.totalValueUnitName = "Bag(s)";
                        kpiHelper.percentOfGlobal = percentOfGlobal;
                        kpiHelper.minValue = min;
                        kpiHelper.avgValue = avg;
                        kpiHelper.maxValue = max;
                        kpiHelper.level1Value = level1;
                        kpiHelper.level2Value = level2;
                        kpiHelper.level3Value = level3;
                        kpiHelper.unitName = "Minute(s)";   // >> Task #13880 Wrong Unit in "_Times" Dashboard table

                        kpiGroup.kpisList.Add(kpiHelper);
                    }
                }
                kpiGroupsList.Add(kpiGroup);
                return kpiGroupsList;
            }

            private bool isKPIGroupHeader(DataRow statisticTableRow)
            {
                String nbBags = statisticTableRow[SourceStatisticTableColumnIndexes.nbBagsColumnIndex].ToString();

                String min = statisticTableRow[SourceStatisticTableColumnIndexes.minColumnIndex].ToString();
                String avg = statisticTableRow[SourceStatisticTableColumnIndexes.avgColumnIndex].ToString();
                String max = statisticTableRow[SourceStatisticTableColumnIndexes.maxColumnIndex].ToString();
                String level1 = statisticTableRow[SourceStatisticTableColumnIndexes.level1ColumnIndex].ToString();
                String level2 = statisticTableRow[SourceStatisticTableColumnIndexes.level2ColumnIndex].ToString();
                String level3 = statisticTableRow[SourceStatisticTableColumnIndexes.level3ColumnIndex].ToString();

                if (nbBags == "" && min == "" && avg == ""
                    && max == "" && level1 == "" && level2 == "" && level3 == "")
                {
                    return true;
                }
                return false;
            }

            private void fillSummaryTable(DataTable summaryTable, List<KPIGroup> kpiGroupsList)
            {
                DataRow dr;
                foreach (KPIGroup kpiGroup in kpiGroupsList)
                {
                    String groupName = kpiGroup.groupName;
                    if (groupName == "")
                    {
                        foreach (KPIHelper kpiHelper in kpiGroup.kpisList)
                        {
                            addCompleteRowToSummaryTable(summaryTable, kpiHelper);
                        }
                    }
                    else
                    {
                        dr = summaryTable.NewRow();
                        dr[StatisticTableColumnIndexes.kpiNameColumnIndex] = groupName;
                        summaryTable.Rows.Add(dr);
                        foreach (KPIHelper kpiHelper in kpiGroup.kpisList)
                        {
                            addCompleteRowToSummaryTable(summaryTable, kpiHelper);
                        }
                    }
                }
                summaryTable.AcceptChanges();
            }

            private void addCompleteRowToSummaryTable(DataTable summaryTable, KPIHelper kpi)
            {
                DataRow dr = summaryTable.NewRow();

                if (StatisticTableColumnIndexes.kpiIdColumnIndex != -1)
                {
                    dr[StatisticTableColumnIndexes.kpiIdColumnIndex] = kpi.id;
                }
                if (StatisticTableColumnIndexes.kpiNameColumnIndex != -1)
                {
                    dr[StatisticTableColumnIndexes.kpiNameColumnIndex] = kpi.data;
                }
                if (StatisticTableColumnIndexes.totalValueColumnIndex != -1)
                {
                    dr[StatisticTableColumnIndexes.totalValueColumnIndex] = kpi.totalValue;
                }
                if (StatisticTableColumnIndexes.totalValueUnitColumnIndex != -1)
                {
                    dr[StatisticTableColumnIndexes.totalValueUnitColumnIndex] = kpi.totalValueUnitName;
                }
                if (StatisticTableColumnIndexes.percentOfGlobalColumnIndex != -1)
                {
                    dr[StatisticTableColumnIndexes.percentOfGlobalColumnIndex] = kpi.percentOfGlobal;
                }
                if (StatisticTableColumnIndexes.minValueColumnIndex != -1)
                {
                    dr[StatisticTableColumnIndexes.minValueColumnIndex] = kpi.minValue;
                }
                if (StatisticTableColumnIndexes.avgValueColumnIndex != -1)
                {
                    dr[StatisticTableColumnIndexes.avgValueColumnIndex] = kpi.avgValue;
                }
                if (StatisticTableColumnIndexes.maxValueColumnIndex != -1)
                {
                    dr[StatisticTableColumnIndexes.maxValueColumnIndex] = kpi.maxValue;
                }
                if (StatisticTableColumnIndexes.maxLevel1ValueColumnIndex != -1)
                {
                    dr[StatisticTableColumnIndexes.maxLevel1ValueColumnIndex] = kpi.level1Value;
                }
                if (StatisticTableColumnIndexes.maxLevel2ValueColumnIndex != -1)
                {
                    dr[StatisticTableColumnIndexes.maxLevel2ValueColumnIndex] = kpi.level2Value;
                }
                if (StatisticTableColumnIndexes.maxLevel3ValueColumnIndex != -1)
                {
                    dr[StatisticTableColumnIndexes.maxLevel3ValueColumnIndex] = kpi.level3Value;
                }
                if (StatisticTableColumnIndexes.unitColumnIndex != -1)
                {
                    dr[StatisticTableColumnIndexes.unitColumnIndex] = kpi.unitName;
                }
                summaryTable.Rows.Add(dr);
            }
            // << Task #11603 Pax2Sim - BHS analysis - Dashboard for Times stats

            private static bool AddDesksStatistics(DataTable dtGeneral, DataTable dtDesks, String sPrefixe, String sSuffixe, int iIndexSorter)
            {
                if (dtGeneral.Rows.Count != dtDesks.Rows.Count)
                    return false;
                for (int i = 1; i < 1000; i++)//(int i = 1; i < 300; i++)
                {
                    String SColumnName = sPrefixe + i.ToString() + sSuffixe;
                    if (iIndexSorter != -1)
                        SColumnName = sPrefixe + iIndexSorter.ToString() + "_" + i.ToString() + sSuffixe;
                    if (!dtDesks.Columns.Contains(SColumnName))
                        continue;
                    OverallTools.DataFunctions.ConcateneTable(dtGeneral, dtDesks, new String[] { SColumnName }, "");
                    dtDesks.Columns.Remove(SColumnName);
                    if (dtDesks.Columns.Count == 0)
                        break;
                }
                if (dtDesks.Columns.Count == 0)
                    return true;
                return false;
            }

            private static bool AddDesksStatistics_inDev(DataTable dtGeneral, DataTable dtDesks, String sPrefixe, String sSuffixe, int iIndexSorter)    // Bug #19036
            {
                if (dtGeneral.Rows.Count != dtDesks.Rows.Count)
                    return false;
                if (iIndexSorter != -1)
                {
                    sPrefixe += iIndexSorter.ToString() + "_";
                }
                List<string> columnNames = new List<string>();
                foreach (DataColumn column in dtDesks.Columns)
                {
                    if (column.ColumnName.StartsWith(sPrefixe) && column.ColumnName.EndsWith(sSuffixe))
                    {
                        columnNames.Add(column.ColumnName);
                    }
                }
                foreach (string columnName in columnNames)
                {
                    if (!OverallTools.DataFunctions.ConcateneTable(dtGeneral, dtDesks, new String[] { columnName }, ""))
                    {
                        return false;
                    }
                    dtDesks.Columns.Remove(columnName);
                }
                return true;
            }

            // >> Task #11602 Pax2Sim - BHS analysis - Global stats not showing the child stats for DepReaderTimestamp
            private static bool AddDesksStatisticsForBHSDesksWithTwoIndexes(DataTable dtGeneral, DataTable dtDesks,
                String sPrefixe, String sSuffixe, int iIndexSorter)
            {
                if (dtGeneral.Rows.Count != dtDesks.Rows.Count)
                    return false;
                List<String> childColumnNames = new List<String>();
                foreach (DataColumn childDeskStatsColumn in dtDesks.Columns)
                {
                    childColumnNames.Add(childDeskStatsColumn.ColumnName);
                }
                foreach (String columnName in childColumnNames)
                {
                    if (!OverallTools.DataFunctions.ConcateneTable(dtGeneral, dtDesks, new String[] { columnName }, ""))
                    {
                        return false;
                    }
                    dtDesks.Columns.Remove(columnName);
                }
                return true;
            }
            // << Task #11602 Pax2Sim - BHS analysis - Global stats not showing the child stats for DepReaderTimestamp

            // >> Task #13422 Keywords improvement            
            private static bool AddDesksStatisticsForBHSDesks(DataTable dtGeneral, DataTable dtDesks,
                String sPrefixe)
            {
                if (dtGeneral.Rows.Count != dtDesks.Rows.Count)
                    return false;

                DataTable sourceTable = dtDesks.Copy();
                List<String> childColumnNames = new List<String>();
                foreach (DataColumn childDeskStatsColumn in sourceTable.Columns)
                {
                    if (childDeskStatsColumn.ColumnName.StartsWith(sPrefixe))
                        childColumnNames.Add(childDeskStatsColumn.ColumnName);
                }
                foreach (String columnName in childColumnNames)
                {
                    if (!OverallTools.DataFunctions.ConcateneTable(dtGeneral, sourceTable, new String[] { columnName }, ""))
                    {
                        return false;
                    }
                    sourceTable.Columns.Remove(columnName);
                }
                return true;
            }
            // << Task #13422 Keywords improvement

            // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
            /// <summary>
            /// Calculates the average utilization for the Group utilization table based on the 
            /// number of desks the group has and the total utilization for each time slot from the given utilization table.
            /// </summary>
            /// <param name="utilizationTable">The utilization table for a Group of Desks/Stations. 
            /// It must have the columns representing each child desk/station utilization.</param>
            /// <returns></returns>
            private static void computeAverageUtilizationAndDeskNeedForGroupUtilizationTable(DataTable utilizationTable, String stationType)
            {
                int nbOfChildStations = 0;
                int averageColumnIndex = -1;
                int stationNeedColumnIndex = -1;
                int totalUtilizationColumnIndex = -1;

                if (utilizationTable != null)
                {
                    averageColumnIndex = utilizationTable.Columns.IndexOf(GlobalNames.BHS_UTILIZATION_AVERAGE_COLUMN_NAME);
                    stationNeedColumnIndex = utilizationTable.Columns.IndexOf(GlobalNames.BHS_UTILIZATION_STATION_NEED_COLUMN_NAME);
                    totalUtilizationColumnIndex = utilizationTable.Columns.IndexOf(GlobalNames.BHS_UTILIZATION_PERCENT_COLUMN_NAME);

                    if (averageColumnIndex != -1 && totalUtilizationColumnIndex != -1
                        && stationNeedColumnIndex != -1)
                    {
                        foreach (DataColumn column in utilizationTable.Columns)
                        {
                            if (column.ColumnName.Contains(stationType))
                            {
                                nbOfChildStations++;
                            }
                        }

                        foreach (DataRow row in utilizationTable.Rows)
                        {

                            double totalUtilization = -1;
                            if (Double.TryParse(row[totalUtilizationColumnIndex].ToString(), out totalUtilization)
                                && totalUtilization > 0)
                            {
                                if (nbOfChildStations > 0)
                                {
                                    row[averageColumnIndex] = Math.Round(totalUtilization / nbOfChildStations, 2);
                                }
                                row[stationNeedColumnIndex] = Math.Ceiling(totalUtilization / 100);
                            }
                        }
                    }
                }
            }
            // << Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard

            // >> Task #14902 Improve Dynamic Occupation tables (PAX & BHS)
            const string TRANSP_DASHBOARD_CONCAT_STATION_VALUE_UNIT_COLUMN_NAME = "Station Value Unit";
            private static void concatenateTranspDashboardStatisticTables(DataTable stationStatTable, DataTable concatStatTable,
                string stationName)
            {
                if (stationStatTable != null && concatStatTable != null
                    && stationStatTable.Rows.Count == concatStatTable.Rows.Count)
                {
                    int concatTableStationValueUnitColumnIndex = concatStatTable.Columns.IndexOf(TRANSP_DASHBOARD_CONCAT_STATION_VALUE_UNIT_COLUMN_NAME);
                    if (concatTableStationValueUnitColumnIndex == -1)
                    {
                        concatTableStationValueUnitColumnIndex = concatStatTable.Columns.Count;
                        concatStatTable.Columns.Add(TRANSP_DASHBOARD_CONCAT_STATION_VALUE_UNIT_COLUMN_NAME, typeof(String));
                    }
                    int concatTableStationNameColumnIndex = concatStatTable.Columns.Count;
                    concatStatTable.Columns.Add(stationName, typeof(Double));

                    int valueUnitStationTableColumnIndex = stationStatTable.Columns.IndexOf(GlobalNames.SUMMARY_TABLE_TRANSP_VALUE_UNIT_COLUMN_NAME);
                    int valueStationTableColumnIndex = stationStatTable.Columns.IndexOf(GlobalNames.SUMMARY_TABLE_TRANSP_VALUE_COLUMN_NAME);
                    if (valueUnitStationTableColumnIndex != -1 && valueStationTableColumnIndex != -1)
                    {
                        for (int i = 0; i < stationStatTable.Rows.Count; i++)
                        {
                            DataRow stationStatRow = stationStatTable.Rows[i];
                            string stationStatValueUnit = stationStatRow[valueUnitStationTableColumnIndex].ToString();
                            double stationStatValue = -1;
                            if (stationStatRow[valueStationTableColumnIndex] != null
                                && Double.TryParse(stationStatRow[valueStationTableColumnIndex].ToString(), out stationStatValue))
                            {
                                concatStatTable.Rows[i][concatTableStationValueUnitColumnIndex] = stationStatValueUnit;
                                concatStatTable.Rows[i][concatTableStationNameColumnIndex] = stationStatValue;
                            }
                        }
                    }
                }
            }

            private static void addConcatStationsToGlobalStats(DataTable concatStatTable,
                DataTable globalStatTable)
            {
                if (concatStatTable != null && globalStatTable != null)
                {
                    int kpiStatConcatStatColumnIndex = concatStatTable.Columns.IndexOf(GlobalNames.SUMMARY_TABLE_TRANSP_KPI_STAT_COLUMN_NAME);
                    if (kpiStatConcatStatColumnIndex != -1 && kpiStatConcatStatColumnIndex < concatStatTable.Columns.Count)
                    {
                        int i = kpiStatConcatStatColumnIndex + 1;
                        for (; i < concatStatTable.Columns.Count; i++)
                        {
                            DataColumn concatStatColumn = concatStatTable.Columns[i];

                            addConcatColumnToGlobalStatTable(concatStatColumn, concatStatTable, globalStatTable);
                        }
                    }
                }
            }
            private static void addConcatColumnToGlobalStatTable(DataColumn concatColumn, DataTable concatStatTable,
                DataTable globalStatTable)
            {
                int kpiCategoryGlobalColumnIndex = globalStatTable.Columns.IndexOf(GlobalNames.SUMMARY_TABLE_TRANSP_KPI_CATEGORY_COLUMN_NAME);
                int kpiCategoryConcatColumnIndex = concatStatTable.Columns.IndexOf(GlobalNames.SUMMARY_TABLE_TRANSP_KPI_CATEGORY_COLUMN_NAME);

                if (kpiCategoryGlobalColumnIndex == -1 && kpiCategoryConcatColumnIndex == -1)
                    return;

                DataColumn newGlobalColumn = globalStatTable.Columns.Add(concatColumn.ColumnName, concatColumn.DataType);
                int kpiCategoryGlobalRowIndex = ROW_NOT_FOUND;
                int globalRowIndex = 0;
                for (int i = 0; i < concatStatTable.Rows.Count; i++)
                {
                    string kpiCategoryConcat = concatStatTable.Rows[i][kpiCategoryConcatColumnIndex].ToString();
                    if (kpiCategoryConcat != "")
                    {
                        globalRowIndex = 0;
                        kpiCategoryGlobalRowIndex = getKpiCategoryRowIndex(globalStatTable, kpiCategoryConcat);
                    }

                    if (kpiCategoryGlobalRowIndex != ROW_NOT_FOUND)
                    {
                        globalStatTable.Rows[kpiCategoryGlobalRowIndex + globalRowIndex][newGlobalColumn] = concatStatTable.Rows[i][concatColumn];
                        globalRowIndex++;
                    }
                }
            }
            const int ROW_NOT_FOUND = -1;
            private static int getKpiCategoryRowIndex(DataTable statsTable, string givenKPICategory)
            {
                int kpiCategoryColumnIndex = statsTable.Columns.IndexOf(GlobalNames.SUMMARY_TABLE_TRANSP_KPI_CATEGORY_COLUMN_NAME);
                if (kpiCategoryColumnIndex == -1)
                    return ROW_NOT_FOUND;
                for (int i = 0; i < statsTable.Rows.Count; i++)
                {
                    string kpiCategory = statsTable.Rows[i][kpiCategoryColumnIndex].ToString();
                    if (givenKPICategory == kpiCategory)
                        return i;
                }
                return ROW_NOT_FOUND;
            }
            // << Task #14902 Improve Dynamic Occupation tables (PAX & BHS)

            // >> Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard
            private static void concatenateDashboardStatisticTables(DataTable stationDashboardStatisticTable, DataTable dashboardConcatStatsTable,
                String stationName)
            {
                if (stationDashboardStatisticTable != null && dashboardConcatStatsTable != null)
                {
                    int kpiNameColumnIndex = stationDashboardStatisticTable.Columns.IndexOf(GlobalNames.SUMMARY_TABLE_DATA_COLUMN_NAME);

                    if (kpiNameColumnIndex != -1)
                    {
                        DataRow stationNameRow = dashboardConcatStatsTable.NewRow();
                        stationNameRow[kpiNameColumnIndex] = stationName;
                        dashboardConcatStatsTable.Rows.Add(stationNameRow);
                        dashboardConcatStatsTable.AcceptChanges();

                        foreach (DataRow stationStatsRow in stationDashboardStatisticTable.Rows)
                        {
                            dashboardConcatStatsTable.ImportRow(stationStatsRow);
                        }
                    }
                }
            }
            // << Task #10985 Pax2Sim - BHS dynamic analysis - adapt statistics tables for the Dashboard

            #region Fonctions statiques.

            public static DataTable CalcOccupationQueue(String sTableName, ArrayList alTimes, DateTime dtBegin,
                DateTime dtEnd, Double dStep, bool bUseSliddingHour, bool bOutputStats, Double analysisRange)   // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
            {

                String sType = "Nb Bags";
                if (sTableName.StartsWith(sPersonalParking))
                    sType = "Nb Cars";
                return ResultFunctions.CalcQueueOccupationWithLeavingTimes(sTableName, alTimes, dtBegin, dtEnd, dStep,
                    sType, bUseSliddingHour, bOutputStats, analysisRange); // << Task #8775 Pax2Sim - Occupation stat - Throughput calculation
            }

            /// <summary>
            /// K: makeUp group index with description
            /// V: list of makeUp stations indexes that belong to the group
            /// </summary>
            public static Dictionary<string, List<int>> makeUpSGroupsDictionary = new Dictionary<string, List<int>>();
            public static int maxMakeUpStationIndex = -1;   // >> Bug #14922 Pax2Sim - BHS trace - Time chute to Exit Segregation per line problem
            /// <summary>
            /// K: makeUp group index with description (same as makeUpSGroupsDictionary)
            /// V: makeUp group description
            /// </summary>
            public static Dictionary<string, string> makeUpGroupWithDescriptionDictionary = new Dictionary<string, string>();

            // >> Task #15088 Pax2Sim - BHS Analysis - Times and Indexes
            private static void AnalyseDeparting_new(Hashtable htResults, String sName, String flowType,
                                                DateTime dtBegin, Dictionary<Int32, BaggageResult> htData,
                                                Double dDistributionStep, int iNbClasses, Double dWarmUp, Double[] Levels,
                                                bool bCollector, bool bHasEBS, DateTime dtEnd, Double scenarioStep, Double analysisRange,
                                                bool generateMUPSegregation,
                                                XmlNode airportStructure, List<AnalysisResultFilter> resultFilters)
            {
                makeUpSGroupsDictionary = getMakeUpSegregationDictionary(airportStructure);
                generateDeparting(htResults, sName, flowType, dtBegin, htData, dDistributionStep, iNbClasses, dWarmUp, Levels,
                    bHasEBS, dtEnd, scenarioStep, analysisRange, MUP_SEGREGATION_ALL, airportStructure, resultFilters);
                if (generateMUPSegregation)
                {
                    foreach (string key in makeUpSGroupsDictionary.Keys)
                    {
                        generateDeparting(htResults, sName, flowType, dtBegin, htData, dDistributionStep, iNbClasses, dWarmUp,
                            Levels, bHasEBS, dtEnd, scenarioStep, analysisRange, key, airportStructure, resultFilters);
                    }
                }
            }
            private static void generateDeparting(Hashtable htResults, String sName, String flowType,
                                                DateTime dtBegin, Dictionary<Int32, BaggageResult> htData,
                                                Double dDistributionStep, int iNbClasses, Double dWarmUp, Double[] Levels,
                                                bool bHasEBS, DateTime dtEnd, Double scenarioStep, double analysisRange, string mupSegregation,
                                                XmlNode airportStructure, List<AnalysisResultFilter> resultsFilters)
            {
                string mupSegregationAddition = "";
                if (mupSegregation != MUP_SEGREGATION_ALL)
                    mupSegregationAddition = mupSegregation + "_";

                DataTable istTable = addDepartingISTTableByRoute(flowType + mupSegregationAddition + "Times" + "_Overall", "", "", "", "", htData, dtBegin, dtEnd, dWarmUp, mupSegregation, htResults);
                DataTable queueExitOccupationTable = addOccupationByRoute(FROMTO_QUEUE_STATION_CODE, FROMTO_EXIT_STATION_CODE,
                    flowType + mupSegregationAddition + "Times" + "_Occupation", htData, dtBegin, dtEnd, scenarioStep, analysisRange, dWarmUp, mupSegregation, htResults);
                DataTable collectorExitOccupationTable = addOccupationByRoute(FROMTO_COLLECTOR_STATION_CODE,
                    FROMTO_EXIT_STATION_CODE, flowType + mupSegregationAddition + "Times" + "_Occupation", htData, dtBegin, dtEnd, scenarioStep, analysisRange, dWarmUp, mupSegregation, htResults);

                addGlobalSummaryTable(flowType + mupSegregationAddition + "Times", istTable, queueExitOccupationTable, collectorExitOccupationTable, htResults);

                foreach (AnalysisResultFilter resultFilter in resultsFilters)
                {
                    string sNameWithCustom = sName;
                    string sRemainingNameWithCustom = flowType;
                    if (resultFilter.isCustomFilter())
                    {
                        string customFilterTag = ANALYSIS_NAME_STATION_TYPES_SEPARATOR + resultFilter.filterName.Replace("_", "");
                        sNameWithCustom += customFilterTag;
                        sRemainingNameWithCustom += customFilterTag;
                    }
                    if (resultFilter.fromStationCode == FROMTO_ENTRY_STATION_CODE
                        && resultFilter.toStationCode == FROMTO_EXIT_STATION_CODE)
                    {
                        string analysisShortName = sNameWithCustom + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + FROMTO_ENTRY_STATION_CODE + FROMTO_EXIT_STATION_CODE;
                        string analysisLongName = sRemainingNameWithCustom + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + FROMTO_ENTRY_STATION_CODE + FROMTO_EXIT_STATION_CODE;
                        Dictionary<int, BaggageResult> filteredData = filterDataByRoute(resultFilter.fromStationCode, resultFilter.toStationCode, resultFilter.fromStationTimeType, resultFilter.toStationTimeType,
                                                                        dtBegin, dtEnd, dWarmUp, mupSegregation, makeUpSGroupsDictionary, htData);

                        addDepartingISTTableByRoute("", resultFilter.fromStationCode, resultFilter.toStationCode, analysisLongName, analysisLongName, filteredData,
                            dtBegin, dtEnd, dWarmUp, mupSegregation, htResults);
                        addRemainingTimeTableByRoute(resultFilter.fromStationCode, resultFilter.toStationCode, analysisLongName, filteredData,
                                dtBegin, dtEnd, Levels, dWarmUp, mupSegregation, makeUpSGroupsDictionary, htResults);

                        addFromToDepartingStatisticTables(resultFilter.fromStationCode, resultFilter.toStationCode, htData, analysisLongName, analysisLongName,
                                    Levels, dDistributionStep, scenarioStep, dWarmUp, bHasEBS, iNbClasses, mupSegregation, dtBegin, dtEnd, htResults, airportStructure,
                                    resultFilter);  // >> Task #15683 PAX2SIM - Result Filters - Split by Flow Type C#23    // -> all the statistics tables for the Entry-Exit route.

                        foreach (string entryStationType in entryExitRoutesDictionary.Keys)
                        {
                            string entryStationCode = getStationCodeByStationTraceKeyword(entryStationType);
                            foreach (string exitStationType in entryExitRoutesDictionary[entryStationType])
                            {
                                string exitStationCode = getStationCodeByStationTraceKeyword(exitStationType);
                                filteredData = filterDataByRoute(entryStationCode, exitStationCode, resultFilter.fromStationTimeType, resultFilter.toStationTimeType,
                                    dtBegin, dtEnd, dWarmUp, mupSegregation, makeUpSGroupsDictionary, htData);

                                if (resultFilter.generateIST)
                                {
                                    DataTable departingIST = addDepartingISTTableByRoute("", entryStationCode, exitStationCode, analysisShortName, analysisLongName, filteredData,
                                        dtBegin, dtEnd, dWarmUp, mupSegregation, htResults);
                                    addLocalFromToIST(departingIST, entryStationCode, resultFilter.fromStationTimeType,
                                        exitStationCode, resultFilter.toStationTimeType, resultFilter.excludeEBSStorageTime, htData, dtBegin, htResults);
                                }
                                if (filteredData.Count > 0)
                                {
                                    addRemainingTimeTableByRoute(entryStationCode, exitStationCode, analysisShortName, filteredData,
                                            dtBegin, dtEnd, Levels, dWarmUp, mupSegregation, makeUpSGroupsDictionary, htResults);
                                }
                                addFromToDepartingStatisticTables(entryStationCode, exitStationCode, htData, analysisShortName, analysisLongName,
                                    Levels, dDistributionStep, scenarioStep, dWarmUp, bHasEBS, iNbClasses, mupSegregation, dtBegin, dtEnd, htResults, airportStructure, resultFilter);

                                AnalysisResultFilter childFilter = new AnalysisResultFilter(resultFilter.filterName, entryStationCode, resultFilter.fromStationTimeType,
                                    exitStationCode, resultFilter.toStationTimeType, resultFilter.withRecirculation, resultFilter.withFromSegregation,
                                    resultFilter.withToSegregation, resultFilter.excludeEBSStorageTime, resultFilter.generateIST);
                                childFilter.displayParameter = resultFilter.displayParameter;
                                if (!resultFilter.fromEntryToExitChildFilters.Contains(childFilter))
                                    resultFilter.fromEntryToExitChildFilters.Add(childFilter);
                            }
                        }
                    }
                    else if (resultFilter.fromStationCode == FROMTO_ENTRY_STATION_CODE)
                    {
                        string analysisShortName = sNameWithCustom + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + FROMTO_ENTRY_STATION_CODE + resultFilter.toStationCode;
                        string analysisLongName = sRemainingNameWithCustom + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + FROMTO_ENTRY_STATION_CODE + resultFilter.toStationCode;

                        Dictionary<int, BaggageResult> filteredData = filterDataByRoute(resultFilter.fromStationCode, resultFilter.toStationCode, resultFilter.fromStationTimeType, resultFilter.toStationTimeType, dtBegin, dtEnd,
                                                                       dWarmUp, mupSegregation, makeUpSGroupsDictionary, htData);

                        addDepartingISTTableByRoute("", resultFilter.fromStationCode, resultFilter.toStationCode, analysisLongName, analysisLongName, filteredData,
                            dtBegin, dtEnd, dWarmUp, mupSegregation, htResults);

                        addRemainingTimeTableByRoute(resultFilter.fromStationCode, resultFilter.toStationCode, analysisLongName, filteredData,
                                dtBegin, dtEnd, Levels, dWarmUp, mupSegregation, makeUpSGroupsDictionary, htResults);


                        addFromToDepartingStatisticTables(resultFilter.fromStationCode, resultFilter.toStationCode, htData, analysisLongName, analysisLongName,
                                    Levels, dDistributionStep, scenarioStep, dWarmUp, bHasEBS, iNbClasses, mupSegregation, dtBegin, dtEnd, htResults, airportStructure,
                                    resultFilter);  // >> Task #15683 PAX2SIM - Result Filters - Split by Flow Type C#23 // -> all the statistics tables

                        analysisShortName = sNameWithCustom + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + FROMTO_ENTRY_STATION_CODE + resultFilter.toStationCode;
                        analysisLongName = sRemainingNameWithCustom + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + FROMTO_ENTRY_STATION_CODE + resultFilter.toStationCode;

                        string toStationCode = switchSpecialStationCodeByFlowType(flowType, resultFilter.toStationCode);
                        foreach (string entryStationType in entryStationTypesList)
                        {
                            string entryStationCode = getStationCodeByStationTraceKeyword(entryStationType);
                            filteredData = filterDataByRoute(entryStationCode, toStationCode, resultFilter.fromStationTimeType, resultFilter.toStationTimeType, dtBegin, dtEnd,
                                                                       dWarmUp, mupSegregation, makeUpSGroupsDictionary, htData);

                            if (resultFilter.generateIST)
                            {
                                DataTable departingIST = addDepartingISTTableByRoute("", entryStationCode, toStationCode, analysisShortName, analysisLongName, filteredData,
                                    dtBegin, dtEnd, dWarmUp, mupSegregation, htResults);
                                addLocalFromToIST(departingIST, entryStationCode, resultFilter.fromStationTimeType,
                                    toStationCode, resultFilter.toStationTimeType, resultFilter.excludeEBSStorageTime, htData, dtBegin, htResults);
                            }
                            if (filteredData.Count > 0)
                            {
                                addRemainingTimeTableByRoute(entryStationCode, toStationCode, analysisShortName, filteredData,
                                        dtBegin, dtEnd, Levels, dWarmUp, mupSegregation, makeUpSGroupsDictionary, htResults);
                            }
                            addFromToDepartingStatisticTables(entryStationCode, toStationCode, htData, analysisShortName, analysisLongName,
                                Levels, dDistributionStep, scenarioStep, dWarmUp, bHasEBS, iNbClasses, mupSegregation, dtBegin, dtEnd, htResults, airportStructure, resultFilter);

                            if (!resultFilter.entryStationCodesList.Contains(entryStationCode))
                            {
                                resultFilter.entryStationCodesList.Add(entryStationCode);
                                AnalysisResultFilter childFilter = new AnalysisResultFilter(resultFilter.filterName, entryStationCode, resultFilter.fromStationTimeType,
                                    toStationCode, resultFilter.toStationTimeType, resultFilter.withRecirculation, resultFilter.withFromSegregation,
                                    resultFilter.withToSegregation, resultFilter.excludeEBSStorageTime, resultFilter.generateIST);
                                childFilter.displayParameter = resultFilter.displayParameter;
                                resultFilter.fromEntryChildFilters.Add(childFilter);
                            }
                        }
                    }
                    else if (resultFilter.toStationCode == FROMTO_EXIT_STATION_CODE)
                    {
                        string analysisShortName = sNameWithCustom + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + resultFilter.fromStationCode + FROMTO_EXIT_STATION_CODE;
                        string analysisLongName = sRemainingNameWithCustom + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + resultFilter.fromStationCode + FROMTO_EXIT_STATION_CODE;

                        Dictionary<int, BaggageResult> filteredData = filterDataByRoute(resultFilter.fromStationCode, resultFilter.toStationCode, resultFilter.fromStationTimeType, resultFilter.toStationTimeType, dtBegin, dtEnd,
                                                                       dWarmUp, mupSegregation, makeUpSGroupsDictionary, htData);

                        addDepartingISTTableByRoute("", resultFilter.fromStationCode, resultFilter.toStationCode, analysisLongName, analysisLongName, filteredData,
                            dtBegin, dtEnd, dWarmUp, mupSegregation, htResults);

                        addRemainingTimeTableByRoute(resultFilter.fromStationCode, resultFilter.toStationCode, analysisLongName, filteredData,
                                dtBegin, dtEnd, Levels, dWarmUp, mupSegregation, makeUpSGroupsDictionary, htResults);


                        addFromToDepartingStatisticTables(resultFilter.fromStationCode, resultFilter.toStationCode, htData, analysisLongName, analysisLongName,
                                    Levels, dDistributionStep, scenarioStep, dWarmUp, bHasEBS, iNbClasses, mupSegregation, dtBegin, dtEnd, htResults, airportStructure,
                                    resultFilter);  // >> Task #15683 PAX2SIM - Result Filters - Split by Flow Type C#23 // -> all the statistics tables

                        analysisShortName = sNameWithCustom + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + resultFilter.fromStationCode + FROMTO_EXIT_STATION_CODE;
                        analysisLongName = sRemainingNameWithCustom + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + resultFilter.fromStationCode + FROMTO_EXIT_STATION_CODE;

                        string fromStationCode = switchSpecialStationCodeByFlowType(flowType, resultFilter.fromStationCode);
                        foreach (string exitStationType in exitStationTypesList)
                        {
                            string exitStationCode = getStationCodeByStationTraceKeyword(exitStationType);
                            filteredData = filterDataByRoute(fromStationCode, exitStationCode, resultFilter.fromStationTimeType, resultFilter.toStationTimeType, dtBegin, dtEnd,
                                                              dWarmUp, mupSegregation, makeUpSGroupsDictionary, htData);

                            if (resultFilter.generateIST)
                            {
                                DataTable departingIST = addDepartingISTTableByRoute("", fromStationCode, exitStationCode, analysisShortName, analysisLongName, filteredData,
                                    dtBegin, dtEnd, dWarmUp, mupSegregation, htResults);
                                addLocalFromToIST(departingIST, fromStationCode, resultFilter.fromStationTimeType,
                                    exitStationCode, resultFilter.toStationTimeType, resultFilter.excludeEBSStorageTime, htData, dtBegin, htResults);
                            }
                            if (filteredData.Count > 0)
                            {
                                addRemainingTimeTableByRoute(fromStationCode, exitStationCode, analysisShortName, filteredData,
                                    dtBegin, dtEnd, Levels, dWarmUp, mupSegregation, makeUpSGroupsDictionary, htResults);
                            }
                            addFromToDepartingStatisticTables(fromStationCode, exitStationCode, htData, analysisShortName, analysisLongName,
                                Levels, dDistributionStep, scenarioStep, dWarmUp, bHasEBS, iNbClasses, mupSegregation, dtBegin, dtEnd, htResults, airportStructure, resultFilter);

                            if (!resultFilter.exitStationCodesList.Contains(exitStationCode))
                            {
                                resultFilter.exitStationCodesList.Add(exitStationCode);
                                AnalysisResultFilter childFilter = new AnalysisResultFilter(resultFilter.filterName,
                                    fromStationCode, resultFilter.fromStationTimeType, exitStationCode, resultFilter.toStationTimeType,
                                    resultFilter.withRecirculation, resultFilter.withFromSegregation, resultFilter.withToSegregation,
                                    resultFilter.excludeEBSStorageTime, resultFilter.generateIST);
                                childFilter.displayParameter = resultFilter.displayParameter;
                                resultFilter.toExitChildFilters.Add(childFilter);
                            }
                        }
                    }
                    else
                    {
                        string fromStationCode = switchSpecialStationCodeByFlowType(flowType, resultFilter.fromStationCode);
                        string toStationCode = switchSpecialStationCodeByFlowType(flowType, resultFilter.toStationCode);

                        Dictionary<int, BaggageResult> filteredData = filterDataByRoute(fromStationCode, toStationCode, resultFilter.fromStationTimeType, resultFilter.toStationTimeType, dtBegin, dtEnd,
                                                                        dWarmUp, mupSegregation, makeUpSGroupsDictionary, htData);

                        if (resultFilter.generateIST)
                        {
                            DataTable departingIST = addDepartingISTTableByRoute("", fromStationCode, toStationCode, sNameWithCustom, sRemainingNameWithCustom, filteredData,
                                dtBegin, dtEnd, dWarmUp, mupSegregation, htResults);

                            addLocalFromToIST(departingIST, fromStationCode, resultFilter.fromStationTimeType,
                                toStationCode, resultFilter.toStationTimeType, resultFilter.excludeEBSStorageTime, htData, dtBegin, htResults);
                        }
                        if (filteredData.Count > 0)
                        {
                            addRemainingTimeTableByRoute(fromStationCode, toStationCode, sNameWithCustom, filteredData,
                                dtBegin, dtEnd, Levels, dWarmUp, mupSegregation, makeUpSGroupsDictionary, htResults);
                        }
                        addFromToDepartingStatisticTables(fromStationCode, toStationCode, htData, sNameWithCustom, sRemainingNameWithCustom,
                            Levels, dDistributionStep, scenarioStep, dWarmUp, bHasEBS, iNbClasses, mupSegregation, dtBegin, dtEnd, htResults, airportStructure, resultFilter);
                    }
                }
            }

            private static string switchSpecialStationCodeByFlowType(string flowType, string givenStationCode)
            {
                if (flowType == AnalysisResultFilter.ORIGINATING_TECHNICAL_FLOW_TYPE)
                {
                    if (givenStationCode == FROMTO_QUEUE_STATION_CODE)
                        return FROMTO_CI_QUEUE_STATION_CODE;
                    else if (givenStationCode == FROMTO_COLLECTOR_STATION_CODE)
                        return FROMTO_CI_COLLECTOR_STATION_CODE;
                }
                else if (flowType == AnalysisResultFilter.TRANSFERRING_TECHNICAL_FLOW_TYPE)
                {
                    if (givenStationCode == FROMTO_QUEUE_STATION_CODE)
                        return FROMTO_TRANSF_QUEUE_STATION_CODE;
                    else if (givenStationCode == FROMTO_COLLECTOR_STATION_CODE)
                        return FROMTO_TRANSF_COLLECTOR_STATION_CODE;
                }
                return givenStationCode;
            }

            private static Dictionary<Int32, BaggageResult> filterDataByRoute(string fromStationCode, string toStationCode, string fromStationTimeType,
                string toStationTimeType, DateTime dtBegin, DateTime dtEnd, double dWarmUp, string mupSegregation, Dictionary<string, List<int>> makeUpSGroupsDictionary,
                Dictionary<Int32, BaggageResult> htData)
            {
                Dictionary<Int32, BaggageResult> filteredData = new Dictionary<int, BaggageResult>();
                foreach (int iResult in htData.Keys)
                {
                    DepartingResult drTmp = (DepartingResult)htData[iResult];
                    DateTime timeAtSystemEntrance = drTmp.GetTimeAtQueue(dtBegin);
                    if (timeAtSystemEntrance != null && timeAtSystemEntrance > dtEnd)
                        continue;
                    if (mupSegregation != MUP_SEGREGATION_ALL)
                    {
                        if (makeUpSGroupsDictionary.ContainsKey(mupSegregation))
                        {
                            List<int> s3MupIndexes = makeUpSGroupsDictionary[mupSegregation];
                            if (!s3MupIndexes.Contains(drTmp.MakeUpIndex))
                                continue;
                        }
                    }
                    if (drTmp.Stopped || (drTmp.LeavingSystemTime < dWarmUp))
                        continue;
                    if (fromStationCode != FROMTO_ENTRY_STATION_CODE)
                    {
                        int fromStationDeskIndex = getStationDeskIndex(fromStationCode, fromStationCode, toStationCode, fromStationTimeType, toStationTimeType, drTmp);
                        if (fromStationDeskIndex == -1)
                            continue;
                    }
                    if (toStationCode != FROMTO_EXIT_STATION_CODE)
                    {
                        int toStationDeskIndex = getStationDeskIndex(toStationCode, fromStationCode, toStationCode, fromStationTimeType, toStationTimeType, drTmp);
                        if (toStationDeskIndex == -1)
                            continue;
                    }
                    if (!filteredData.ContainsKey(iResult))
                        filteredData.Add(iResult, drTmp);
                }
                return filteredData;
            }

            private static DataTable addDepartingISTTableByRoute(string istTablePreffix,
                string fromStationCode, string toStationCode, string sName, string sRemainingName,
                Dictionary<Int32, BaggageResult> htData, DateTime dtBegin, DateTime dtEnd, double dWarmUp, string mupSegregation, Hashtable htResults)
            {
                string preffix = "";
                if (istTablePreffix != "")
                    preffix = istTablePreffix;
                else
                {
                    preffix = sName + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + fromStationCode + toStationCode;
                    if (mupSegregation != MUP_SEGREGATION_ALL)
                        preffix = preffix + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + mupSegregation;
                }
                DataTable dtGlobalIST = dtGlobalIST = new DataTable(preffix + "_IST");

                #region column indexes
                int iIndexTimeAtQueue = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Time At Entrance Queue", typeof(DateTime));
                int iIndexTimeAtCI = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.ARRIVING_TIME_AT_CI_COLUMN_NAME, typeof(DateTime));
                //int iIndexTimeAtColl = dtGlobalIST.Columns.Count;
                //dtGlobalIST.Columns.Add("Time At Entrance Collector", typeof(DateTime));
                int iIndexTimeAtCheckInColl = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Time At CheckIn Collector", typeof(DateTime));
                int iIndexTimeAtTransferColl = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Time At Transfer Collector", typeof(DateTime));
                int iIndexArrivingTimeAtDepReaderTimestamp = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.ARRIVING_TIME_AT_DEP_READER_TIMESTAMP_COLUMN_NAME, typeof(DateTime));

                int iIndexEntryTimeAtFirstEBS = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.FIRST_EBS_ENTRY_TIME_COLUMN_NAME, typeof(DateTime));
                int iIndexExitTimeFromLastEBS = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.LAST_EBS_EXIT_TIME_COLUMN_NAME, typeof(DateTime));

                int iIndexArrivingTimeAtFirstPresortation = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Arriving Time At First Pre-Sortation", typeof(DateTime));
                int iIndexLeavingTimeFromLastPresortation = dtGlobalIST.Columns.Count;   // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation
                dtGlobalIST.Columns.Add("Leaving Time From Last Pre-Sortation", typeof(DateTime));

                int iIndexTimeAtICSToploader = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.ARRIVING_TIME_AT_ICS_TOPLOADER_COLUMN_NAME, typeof(DateTime));
                int iIndexTimeAtICSUnloader = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.ARRIVING_TIME_AT_ICS_UNLOADER_COLUMN_NAME, typeof(DateTime));
                int iIndexTimeAtChute = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Time At Last Chute", typeof(DateTime));
                int iIndexTimeAtMup = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.ARRIVING_TIME_AT_MAKE_UP_COLUMN_NAME, typeof(DateTime));
                int iIndexTimeAtExit = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Time At Exit", typeof(DateTime));

                int iIndexTimeFromCIQueueToPresortation = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Total Time From Entrance Queue To First Pre-Sortation", typeof(Double));
                int iIndexTimeFromCIToPresortation = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.TOTAL_TIME_FROM_CI_TO_PRESORTATION_COLUMN_NAME, typeof(Double));
                int iIndexTimeFromCICollectorToPresortation = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Total Time From CheckIn Collector To First Pre-Sortation", typeof(Double));
                int iIndexTimeFromTransferCollectorToPresortation = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Total Time From Transfer Collector To First Pre-Sortation", typeof(Double));

                int iIndexTimeFromCIQueueToDepReaderTimeStamp = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.TOTAL_TIME_FROM_CIQUEUE_TO_DEPREADERTIMESTAMP_COLUMN_NAME, typeof(Double));
                int iIndexTimeFromCIToDepReaderTimeStamp = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.TOTAL_TIME_FROM_CI_TO_DEPREADERTIMESTAMP_COLUMN_NAME, typeof(Double));
                int iIndexTimeFromCICollectorToDepReaderTimeStamp = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.TOTAL_TIME_FROM_CICOLL_TO_DEPREADERTIMESTAMP_COLUMN_NAME, typeof(Double));
                int iIndexTimeFromTransferCollectorToDepReaderTimeStamp = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Total Time From Transfer Collector to Reader", typeof(Double));

                int iIndexTimeFromCIQueueToEBS = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Total Time From Entrance Queue to EBS", typeof(Double));
                int iIndexTimeFromCICollectorToEBS = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Total Time From CheckIn Collector to EBS", typeof(Double));
                int iIndexTimeFromTransferCollectorToEBS = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Total Time From Transfer Collector to EBS", typeof(Double));

                int iIndexTimeFromCIQueueToChute = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Total Time From Entrance Queue To Last Chute", typeof(Double));
                int iIndexTimeFromCIToChute = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.TOTAL_TIME_FROM_CI_TO_LASTCHUTE_COLUMN_NAME, typeof(Double));
                int iIndexTimeFromCICollectorToChute = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Total Time From CheckIn Collector To Last Chute", typeof(Double));
                int iIndexTimeFromTransferCollectorToChute = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Total Time From Transfer Collector To Last Chute", typeof(Double));
                int iIndexTimeFromReaderToLastChute = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.TOTAL_TIME_FROM_READER_TO_LASTCHUTE_COLUMN_NAME, typeof(Double));
                int iIndexTimeFromEBSToLastChute = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Total Time From EBS To Last Chute", typeof(Double));
                int iIndexTimeFromLastChuteToMakeUp = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.TOTAL_TIME_FROM_LASTCHUTE_TO_MAKEUP_COLUMN_NAME, typeof(Double));

                int iIndexTimeFromQueue = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.TOTAL_TIME_FROM_QUEUE_TO_EXIT_COLUMN_NAME, typeof(Double));//"Total Time From Entrance Queue To Exit", typeof(Double));
                int iIndexTimeFromCIToExit = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.TOTAL_TIME_FROM_CI_TO_EXIT_COLUMN_NAME, typeof(Double));
                int iIndexTimeFromCIColl = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.TOTAL_TIME_FROM_CI_COLL_TO_EXIT_COLUMN_NAME, typeof(Double)); //"Total Time From CheckIn Collector To Exit", typeof(Double));
                int iIndexTimeFromTransferColl = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.TOTAL_TIME_FROM_TRANSFER_COLL_TO_EXIT_COLUMN_NAME, typeof(Double));//"Total Time From Transfer Collector To Exit", typeof(Double));
                int iIndexTimeFromReaderToExit = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.TOTAL_TIME_FROM_READER_TO_EXIT_COLUMN_NAME, typeof(Double));
                int iIndexTimeFromEBSToExit = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Total Time From EBS to Exit", typeof(Double));
                int iIndexTimeFromChuteToExit = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.TOTAL_TIME_FROM_LASTCHUTE_TO_EXIT_COLUMN_NAME, typeof(Double));

                int iIndexTotalEBSDuration = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.EBS_TOTAL_DURATION, typeof(Double));

                int iIndexFlightID = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.FLIGHT_ID_IST_TABLE_COLUMN_NAME, typeof(Int32));
                int iIndexBagId = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.BAG_ID_IST_TABLE_COLUMN_NAME, typeof(int));
                int iIndexPaxId = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("PAX ID", typeof(int));

                int origCheckInQueuesColumnIndex = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(CHECK_IN_QUEUE_INDEX_IST_COLUMN_NAME, typeof(Int32));
                int iIndexCheckIn = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.CHECK_IN_IST_TABLE_COLUMN_NAME, typeof(Int32));
                int iIndexCheckInCollector = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("CheckInCollector", typeof(Int32));
                int iIndexTransferCollector = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("TransferCollector", typeof(Int32));

                int iIndexPresortationIdentifierColumnIndex = dtGlobalIST.Columns.Count;    // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation
                dtGlobalIST.Columns.Add("Presortation", typeof(String));

                int depDepartureReaderTimeStampColumnIndex = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(sDepReaderTimeStamp, typeof(String));
                int depICSToploaderBHSColumnIndex = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(sNewICSToploader, typeof(String));
                int depICSUnloaderBHSColumnIndex = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(sICSUnloader, typeof(String));
                int iIndexLastChute = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.LAST_CHUTE_COLUMN_NAME, typeof(String));
                int iIndexMakeUp = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.MAKE_UP_IST_TABLE_COLUMN_NAME, typeof(Int32));
                int iIndexMakeUpGroup = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.BHS_IST_MAKEUP_GROUP_COLUMN_NAME, typeof(String));

                int iIndexStopped = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.STOPPED_IST_TABLE_COLUMN_NAME, typeof(Boolean));
                int iIndexBeforeWarmUp = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Before WarmUp", typeof(Boolean));
                int iIndexPBCType = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.PBC_TYPE_IST_TABLE_COLUMN_NAME, typeof(String));
                int iIndexNbRecirculation = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Recirculation", typeof(int));

                int depHBS1ColumnIndex = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(HBS1_INDEX_IST_COLUMN_NAME, typeof(Int32));
                int depHBS2ColumnIndex = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(HBS2_INDEX_IST_COLUMN_NAME, typeof(Int32));
                int depHBS3ColumnIndex = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(HBS3_INDEX_IST_COLUMN_NAME, typeof(Int32));
                int depHBS4ColumnIndex = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(HBS4_INDEX_IST_COLUMN_NAME, typeof(Int32));
                int depHBS5ColumnIndex = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(HBS5_INDEX_IST_COLUMN_NAME, typeof(Int32));

                int depInterLinkColumnIndex = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(OriginatingTransferInterLink, typeof(String));

                int depMESColumnIndex = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(MES_INDEX_IST_COLUMN_NAME, typeof(Int32));
                int depEBSColumnIndex = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(EBS_INDEX_IST_COLUMN_NAME, typeof(Int32));

                int iIndexTransferInfeedDeskNb = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.TRANSFER_INFEED_DESK_IST_TABLE_COLUMN_NAME, typeof(int));
                int iIndexTransferInfeedQueueNb = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.TRANSFER_INFEED_QUEUE_IST_TABLE_COLUMN_NAME, typeof(int));
                #endregion

                foreach (int iResult in htData.Keys)
                {
                    DepartingResult drTmp = (DepartingResult)htData[iResult];

                    DateTime timeAtSystemEntrance = drTmp.GetTimeAtQueue(dtBegin);
                    if (timeAtSystemEntrance != null && timeAtSystemEntrance > dtEnd)
                        continue;
                    if (drTmp.LeavingSystemTime < dWarmUp)
                        continue;
                    if (drTmp.isContainer)
                        continue;
                    if (mupSegregation != MUP_SEGREGATION_ALL)
                    {
                        if (makeUpSGroupsDictionary.ContainsKey(mupSegregation))
                        {
                            List<int> s3MupIndexes = makeUpSGroupsDictionary[mupSegregation];
                            if (!s3MupIndexes.Contains(drTmp.MakeUpIndex))
                                continue;
                        }
                    }

                    DataRow drNewRow = dtGlobalIST.NewRow();
                    drNewRow[iIndexTimeAtQueue] = drTmp.GetTimeAtQueue(dtBegin);
                    DateTime arrivalTimeAtCheckIn = drTmp.getArrivalTimeAtCheckIn(dtBegin);
                    if (arrivalTimeAtCheckIn != DateTime.MinValue)
                        drNewRow[iIndexTimeAtCI] = arrivalTimeAtCheckIn;
                    //drNewRow[iIndexTimeAtColl] = drTmp.GetTimeAtColl(dtBegin);
                    DateTime arrivingTimeAtCheckInCollector = drTmp.checkInCollectorArrivingDate(dtBegin);
                    if (arrivingTimeAtCheckInCollector != DateTime.MinValue)
                        drNewRow[iIndexTimeAtCheckInColl] = arrivingTimeAtCheckInCollector;
                    DateTime arrivingTimeAtTransferCollector = drTmp.transferCollectorArrivingDate(dtBegin);
                    if (arrivingTimeAtTransferCollector != DateTime.MinValue)
                        drNewRow[iIndexTimeAtTransferColl] = arrivingTimeAtTransferCollector;
                    drNewRow[iIndexArrivingTimeAtDepReaderTimestamp] = drTmp.getArrivingTimeAtDepReaderTimeStamp(dtBegin);
                    drNewRow[iIndexTimeAtExit] = drTmp.GetTimeAtColl(dtBegin).AddMinutes(Math.Round(drTmp.TotalSimulationTime, 2));

                    drNewRow[iIndexTimeFromQueue] = Math.Round(drTmp.TotalTime, 2);
                    double minDiff = -1;
                    minDiff = drTmp.getMinutesFromCheckInCollectorArrivingToLastStationLeaving();
                    if (minDiff != -1)
                        drNewRow[iIndexTimeFromCIColl] = Math.Round(minDiff, 2);//Math.Round(drTmp.TotalSimulationTime, 2);
                    minDiff = drTmp.getMinutesFromTransferCollectorArrivingToLastStationLeaving();
                    if (minDiff != -1)
                        drNewRow[iIndexTimeFromTransferColl] = Math.Round(minDiff, 2);

                    drNewRow[iIndexFlightID] = drTmp.FlightID;
                    drNewRow[iIndexBagId] = drTmp.IDBag;
                    drNewRow[iIndexPaxId] = drTmp.IDPax;

                    drNewRow[iIndexCheckIn] = drTmp.CheckInIndex;
                    drNewRow[iIndexCheckInCollector] = drTmp.CheckInCollectorIndex;
                    drNewRow[iIndexTransferCollector] = drTmp.transferringCollectorDeskIndex;
                    drNewRow[iIndexMakeUp] = drTmp.MakeUpIndex;
                    int makeUpGroupIndex = getMakeUpGroupIndexByMakeUpStationIndex(drTmp.MakeUpIndex, makeUpSGroupsDictionary);
                    if (makeUpGroupIndex != -1)
                        drNewRow[iIndexMakeUpGroup] = makeUpGroupIndex.ToString();

                    drNewRow[iIndexLastChute] = drTmp.LastChuteDeskWithTwoIndexes;

                    drNewRow[iIndexStopped] = false;
                    drNewRow[iIndexBeforeWarmUp] = false;

                    drNewRow[iIndexPBCType] = drTmp.pbcStationType;
                    drNewRow[iIndexNbRecirculation] = drTmp.nbRecirculation;

                    DateTime timeAtFirstEBS = drTmp.getTimeAtFirstEBS(dtBegin);
                    if (timeAtFirstEBS != DateTime.MinValue && !drTmp.Stopped)
                        drNewRow[iIndexEntryTimeAtFirstEBS] = timeAtFirstEBS;

                    // >> Task #7949 Capacity Analysis - IST tables modification C#4                    
                    DateTime lastEbsExitTime = drTmp.getExitTimeFromLastEBS(dtBegin);
                    if (lastEbsExitTime != DateTime.MinValue && !drTmp.Stopped)
                        drNewRow[iIndexExitTimeFromLastEBS] = lastEbsExitTime;
                    drNewRow[iIndexTotalEBSDuration] = Math.Round(drTmp.getEBSStorageMinutesBetweenGivenMinutes(0, double.MaxValue), 2);
                    // >> Task #7949 Capacity Analysis - IST tables modification C#4

                    DateTime timeAtFirstEBSAfterEntrance = drTmp.getArrivingDateAtFirstEBSAfterProcessLeavingTime(dtBegin, drTmp.queueLeavingTime);
                    if (timeAtFirstEBSAfterEntrance != DateTime.MinValue)
                    {
                        drNewRow[iIndexTimeFromCIQueueToEBS] = Math.Round(timeAtFirstEBSAfterEntrance.Subtract(drTmp.GetTimeAtQueue(dtBegin)).TotalMinutes, 2);
                        if (drTmp.checkInCollectorArrivingDate(dtBegin) != DateTime.MinValue)
                            drNewRow[iIndexTimeFromCICollectorToEBS] = Math.Round(timeAtFirstEBSAfterEntrance.Subtract(drTmp.checkInCollectorArrivingDate(dtBegin)).TotalMinutes, 2);
                        if (drTmp.transferCollectorArrivingDate(dtBegin) != DateTime.MinValue)
                            drNewRow[iIndexTimeFromTransferCollectorToEBS] = Math.Round(timeAtFirstEBSAfterEntrance.Subtract(drTmp.transferCollectorArrivingDate(dtBegin)).TotalMinutes, 2);
                    }
                    DateTime timeAtLastEBSBeforeLastChute = drTmp.getLeavingDateFromLastEBSBeforeProcessArrivingTime(dtBegin, drTmp.LastChuteArrivingMinute);
                    DateTime timeAtLastChute = drTmp.GetArrivingTimeAtLastChute(dtBegin);
                    if (timeAtLastEBSBeforeLastChute != DateTime.MinValue && timeAtLastChute != DateTime.MinValue)
                        drNewRow[iIndexTimeFromEBSToLastChute] = Math.Round(timeAtLastChute.Subtract(timeAtLastEBSBeforeLastChute).TotalMinutes, 2);
                    DateTime leavingTimeFromFirstEBSBeforeExit = drTmp.getLeavingDateFromLastEBSBeforeProcessArrivingTime(dtBegin, drTmp.LeavingSystemTime);
                    DateTime leavingSystemDate = dtBegin.AddMinutes(drTmp.LeavingSystemTime);
                    if (leavingTimeFromFirstEBSBeforeExit != DateTime.MinValue)
                        drNewRow[iIndexTimeFromEBSToExit] = Math.Round(leavingSystemDate.Subtract(leavingTimeFromFirstEBSBeforeExit).TotalMinutes, 2);

                    if (timeAtLastChute != DateTime.MinValue && !drTmp.Stopped)
                    {
                        double ebsTimeBeforeLastChuteArrivingTime = drTmp.getEBSTimeBeforeProcessTime(drTmp.LastChuteArrivingMinute);
                        drNewRow[iIndexTimeAtChute] = timeAtLastChute;
                        drNewRow[iIndexTimeFromCIQueueToChute] = Math.Round(timeAtLastChute.Subtract(drTmp.GetTimeAtQueue(dtBegin)).TotalMinutes - ebsTimeBeforeLastChuteArrivingTime, 2);
                        if (drTmp.checkInCollectorArrivingDate(dtBegin) != DateTime.MinValue)
                            drNewRow[iIndexTimeFromCICollectorToChute] = Math.Round(timeAtLastChute.Subtract(drTmp.checkInCollectorArrivingDate(dtBegin)).TotalMinutes - ebsTimeBeforeLastChuteArrivingTime, 2);
                        if (drTmp.transferCollectorArrivingDate(dtBegin) != DateTime.MinValue)
                            drNewRow[iIndexTimeFromTransferCollectorToChute] = Math.Round(timeAtLastChute.Subtract(drTmp.transferCollectorArrivingDate(dtBegin)).TotalMinutes - ebsTimeBeforeLastChuteArrivingTime, 2);
                    }
                    DateTime arrivingTimeAtFirstPresortation = drTmp.getFirstPresortationArrivingTime(dtBegin);  //drTmp.GetTimeAtPresortationDepVSUInputDn(dtBegin);    // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation
                    if (arrivingTimeAtFirstPresortation != DateTime.MinValue && !drTmp.Stopped)
                    {
                        drNewRow[iIndexArrivingTimeAtFirstPresortation] = arrivingTimeAtFirstPresortation;
                        if (drTmp.getLastPresortationLeavingTime(dtBegin) != DateTime.MinValue)
                        {
                            drNewRow[iIndexLeavingTimeFromLastPresortation] = drTmp.getLastPresortationLeavingTime(dtBegin);
                        }
                        double ebsTimeBeforePresortationArrivingTime = drTmp.getEBSTimeBeforeProcessTime(drTmp.firstPresortationArrivingMinute);
                        drNewRow[iIndexTimeFromCIQueueToPresortation] = Math.Round(arrivingTimeAtFirstPresortation.Subtract(drTmp.GetTimeAtQueue(dtBegin)).TotalMinutes - ebsTimeBeforePresortationArrivingTime, 2);
                        if (drTmp.checkInCollectorArrivingDate(dtBegin) != DateTime.MinValue)
                            drNewRow[iIndexTimeFromCICollectorToPresortation] = Math.Round(arrivingTimeAtFirstPresortation.Subtract(drTmp.checkInCollectorArrivingDate(dtBegin)).TotalMinutes - ebsTimeBeforePresortationArrivingTime, 2);
                        if (drTmp.transferCollectorArrivingDate(dtBegin) != DateTime.MinValue)
                            drNewRow[iIndexTimeFromTransferCollectorToPresortation] = Math.Round(arrivingTimeAtFirstPresortation.Subtract(drTmp.transferCollectorArrivingDate(dtBegin)).TotalMinutes - ebsTimeBeforePresortationArrivingTime, 2);
                    }

                    Double arrivalMinuteAtDepReaderTimeStamp = drTmp.getArrivingMinuteAtDepReaderTimeStamp();
                    DateTime arrivalTimeAtDepReaderTimeStamp = drTmp.getArrivingTimeAtDepReaderTimeStamp(dtBegin);
                    if (arrivalTimeAtDepReaderTimeStamp != DateTime.MinValue && arrivalMinuteAtDepReaderTimeStamp != -1 && !drTmp.Stopped)
                    {
                        double ebsTimeBeforDepReaderTimeStamp = drTmp.getEBSTimeBeforeProcessTime(arrivalMinuteAtDepReaderTimeStamp);
                        drNewRow[iIndexTimeFromCIQueueToDepReaderTimeStamp] = Math.Round(arrivalTimeAtDepReaderTimeStamp.Subtract(drTmp.GetTimeAtQueue(dtBegin)).TotalMinutes - ebsTimeBeforDepReaderTimeStamp, 2);
                        if (drTmp.checkInCollectorArrivingDate(dtBegin) != DateTime.MinValue)
                            drNewRow[iIndexTimeFromCICollectorToDepReaderTimeStamp] = Math.Round(arrivalTimeAtDepReaderTimeStamp.Subtract(drTmp.checkInCollectorArrivingDate(dtBegin)).TotalMinutes - ebsTimeBeforDepReaderTimeStamp, 2);
                        if (drTmp.transferCollectorArrivingDate(dtBegin) != DateTime.MinValue)
                            drNewRow[iIndexTimeFromTransferCollectorToDepReaderTimeStamp] = Math.Round(arrivalTimeAtDepReaderTimeStamp.Subtract(drTmp.transferCollectorArrivingDate(dtBegin)).TotalMinutes - ebsTimeBeforDepReaderTimeStamp, 2);

                        double ebsStorage = -1;
                        if (timeAtLastChute != DateTime.MinValue)
                        {
                            ebsStorage = drTmp.getEBSStorageTimeBetweenProcessTimes(arrivalMinuteAtDepReaderTimeStamp, drTmp.LastChuteArrivingMinute);
                            drNewRow[iIndexTimeFromReaderToLastChute] = Math.Round(timeAtLastChute.Subtract(arrivalTimeAtDepReaderTimeStamp).TotalMinutes - ebsStorage, 2);
                        }
                        ebsStorage = drTmp.getEBSStorageTimeBetweenProcessTimes(arrivalMinuteAtDepReaderTimeStamp, drTmp.LeavingSystemTime);
                        double minutesFromReaderToExitIncludingEBS = drTmp.LeavingSystemTime - arrivalMinuteAtDepReaderTimeStamp;
                        drNewRow[iIndexTimeFromReaderToExit] = Math.Round(minutesFromReaderToExitIncludingEBS - ebsStorage, 2);
                    }

                    timeAtLastChute = drTmp.GetArrivingTimeAtLastChute(dtBegin);
                    if (timeAtLastChute != DateTime.MinValue && !drTmp.Stopped)
                    {

                        DateTime leavingTime = dtBegin.AddMinutes(drTmp.LeavingSystemTime);
                        double ebsStorage = drTmp.getEBSStorageTimeBetweenProcessTimes(drTmp.LastChuteArrivingMinute, drTmp.LeavingSystemTime);
                        drNewRow[iIndexTimeFromChuteToExit] = Math.Round(leavingTime.Subtract(timeAtLastChute).TotalMinutes - ebsStorage, 2);
                    }

                    timeAtLastChute = drTmp.GetArrivingTimeAtLastChute(dtBegin);
                    DateTime arrivingTimeAtMakeUp = drTmp.getArrivingTimeAtMup(dtBegin);
                    if (timeAtLastChute != DateTime.MinValue && arrivingTimeAtMakeUp != DateTime.MinValue)
                    {
                        double ebsStorage = drTmp.getEBSStorageTimeBetweenProcessTimes(drTmp.LastChuteArrivingMinute, drTmp.getArrivingMinuteAtMup());
                        drNewRow[iIndexTimeFromLastChuteToMakeUp] = Math.Round(arrivingTimeAtMakeUp.Subtract(timeAtLastChute).TotalMinutes - ebsStorage, 2);
                    }

                    DateTime arrivingTimeAtICSToploader = drTmp.getArrivingTimeAtICSToploader(dtBegin);
                    if (arrivingTimeAtICSToploader != DateTime.MinValue && !drTmp.Stopped)
                    {
                        drNewRow[iIndexTimeAtICSToploader] = arrivingTimeAtICSToploader;
                    }
                    DateTime arrivingTimeAtICSUnloader = drTmp.getArrivingTimeAtICSUnloader(dtBegin);
                    if (arrivingTimeAtICSUnloader != DateTime.MinValue && !drTmp.Stopped)
                    {
                        drNewRow[iIndexTimeAtICSUnloader] = arrivingTimeAtICSUnloader;
                    }
                    DateTime arrivingTimeAtMup = drTmp.getArrivingTimeAtMup(dtBegin);
                    if (arrivingTimeAtMup != DateTime.MinValue && !drTmp.Stopped)
                    {
                        drNewRow[iIndexTimeAtMup] = arrivingTimeAtMup;
                    }
                    drNewRow[origCheckInQueuesColumnIndex] = drTmp.checkInQueueDeskIndex;

                    drNewRow[depHBS1ColumnIndex] = drTmp.originatingTransferHBS1DeskIndex;

                    drNewRow[depHBS2ColumnIndex] = drTmp.originatingTransferHBS2DeskIndex;
                    drNewRow[depHBS3ColumnIndex] = drTmp.originatingTransferHBS3DeskIndex;
                    drNewRow[depHBS4ColumnIndex] = drTmp.originatingTransferHBS4DeskIndex;
                    drNewRow[depHBS5ColumnIndex] = drTmp.originatingTransferHBS5DeskIndex;
                    drNewRow[depMESColumnIndex] = drTmp.originatingTransferMESDeskIndex;
                    drNewRow[depEBSColumnIndex] = drTmp.firstEBSDeskIndex;

                    #region Chute, SorterInduction, InterLink
                    if (depInterLinkColumnIndex != -1)
                    {
                        String allInterLinkIndexes = "";
                        if (drTmp.allInterLinkDeskIndexesList != null && drTmp.allInterLinkDeskIndexesList.Count > 0)
                        {
                            for (int i = 0; i < drTmp.allInterLinkDeskIndexesList.Count; i++)
                            {
                                String interLinkIndex = drTmp.allInterLinkDeskIndexesList[i];
                                allInterLinkIndexes += interLinkIndex;
                                if (i < drTmp.allInterLinkDeskIndexesList.Count - 1)
                                {
                                    allInterLinkIndexes += ", ";
                                }
                            }
                            drNewRow[depInterLinkColumnIndex] = allInterLinkIndexes;
                        }
                        else
                        {
                            drNewRow[depInterLinkColumnIndex] = -1;
                        }
                    }
                    #endregion

                    #region ICS toploader/unloader, Dep reader timestamp (with 2 indexes)
                    if (depICSToploaderBHSColumnIndex != -1)
                    {
                        if (drTmp.ICSToploaderTwoDeskIndexes != null && drTmp.ICSToploaderTwoDeskIndexes != "")
                        {
                            drNewRow[depICSToploaderBHSColumnIndex] = drTmp.ICSToploaderTwoDeskIndexes;
                        }
                        else
                        {
                            drNewRow[depICSToploaderBHSColumnIndex] = "-1";
                        }
                    }
                    if (depICSUnloaderBHSColumnIndex != -1)
                    {
                        if (drTmp.ICSUnloaderTwoDeskIndexes != null && drTmp.ICSUnloaderTwoDeskIndexes != "")
                        {
                            drNewRow[depICSUnloaderBHSColumnIndex] = drTmp.ICSUnloaderTwoDeskIndexes;
                        }
                        else
                        {
                            drNewRow[depICSUnloaderBHSColumnIndex] = "-1";
                        }
                    }
                    if (depDepartureReaderTimeStampColumnIndex != -1)
                    {
                        if (drTmp.DepReaderTimestampTwoDeskIndexes != null && drTmp.DepReaderTimestampTwoDeskIndexes != "")
                        {
                            drNewRow[depDepartureReaderTimeStampColumnIndex] = drTmp.DepReaderTimestampTwoDeskIndexes;
                        }
                        else
                        {
                            drNewRow[depDepartureReaderTimeStampColumnIndex] = "-1";
                        }
                    }
                    #endregion

                    if (iIndexTransferInfeedDeskNb != -1)
                    {
                        if (drTmp.transferringInfeedDeskIndex >= 0)
                            drNewRow[iIndexTransferInfeedDeskNb] = drTmp.transferringInfeedDeskIndex;
                        else
                            drNewRow[iIndexTransferInfeedDeskNb] = -1;
                    }
                    if (iIndexTransferInfeedQueueNb != -1)
                    {
                        if (drTmp.transferringQueueDeskIndex >= 0)
                            drNewRow[iIndexTransferInfeedQueueNb] = drTmp.transferringQueueDeskIndex;
                        else
                            drNewRow[iIndexTransferInfeedQueueNb] = -1;
                    }

                    if (iIndexTimeFromCIToDepReaderTimeStamp != -1 && drTmp.getMinutesFromCheckInToDepReaderTimeStamp(dtBegin) >= 0)
                        drNewRow[iIndexTimeFromCIToDepReaderTimeStamp] = drTmp.getMinutesFromCheckInToDepReaderTimeStamp(dtBegin);

                    if (iIndexTimeFromCIToPresortation != -1 && drTmp.getMinutesFromCheckInToFirstPresortation(dtBegin) >= 0)
                        drNewRow[iIndexTimeFromCIToPresortation] = drTmp.getMinutesFromCheckInToFirstPresortation(dtBegin);

                    if (iIndexTimeFromCIToChute != -1 && drTmp.getMinutesFromCheckInToLastChute(dtBegin) >= 0)
                        drNewRow[iIndexTimeFromCIToChute] = drTmp.getMinutesFromCheckInToLastChute(dtBegin);

                    if (iIndexTimeFromCIToExit != -1 && drTmp.getMinutesFromCheckInToExit(dtBegin) >= 0)
                        drNewRow[iIndexTimeFromCIToExit] = drTmp.getMinutesFromCheckInToExit(dtBegin);

                    if (drTmp.Stopped || (drTmp.LeavingSystemTime < dWarmUp))
                    {
                        drNewRow[iIndexStopped] = drTmp.Stopped;
                        drNewRow[iIndexBeforeWarmUp] = drTmp.LeavingSystemTime < dWarmUp;
                    }

                    if (drTmp.presortationIdentifiers.Count > 0)
                    {
                        string ids = "";
                        for (int i = 0; i < drTmp.presortationIdentifiers.Count; i++)
                        {
                            ids += drTmp.presortationIdentifiers[i];
                            if (i < drTmp.presortationIdentifiers.Count - 1)
                            {
                                ids += ", ";
                            }
                        }
                        drNewRow[iIndexPresortationIdentifierColumnIndex] = ids;
                    }
                    dtGlobalIST.Rows.Add(drNewRow);
                }
                dtGlobalIST.AcceptChanges();
                htResults.Add(dtGlobalIST.TableName, dtGlobalIST);
                return dtGlobalIST;
            }

            private static void addLocalFromToIST(DataTable generalDepartingIST, string fromStationCode, string fromStationTimeType,
                string toStationCode, string toStationTimeType, bool subtractEBS,
                Dictionary<Int32, BaggageResult> htData, DateTime dtBegin,
                Hashtable htResults)
            {
                if (generalDepartingIST == null)
                    return;
                DataTable localIST = generalDepartingIST.Copy();
                localIST.TableName = generalDepartingIST.TableName + "_FromTo";

                int timeAtFromStationColumnIndex = localIST.Columns.Count;
                localIST.Columns.Add("Time At " + fromStationCode + " (" + fromStationTimeType + ")", typeof(DateTime));
                // fromStationCode = toStationCode then FromTimeType != ToTimeType
                int timeAtToStationColumnIndex = localIST.Columns.Count;
                localIST.Columns.Add("Time At " + toStationCode + " (" + toStationTimeType + ")", typeof(DateTime));

                int minutesBetweenFromAndToStationColumnIndex = localIST.Columns.Count;
                localIST.Columns.Add("Total Time From " + fromStationCode + " (" + fromStationTimeType + ")"
                    + " To " + toStationCode + " (" + toStationTimeType + ")" + " (min)", typeof(Double));

                int bagIdColumnIndex = localIST.Columns.IndexOf(GlobalNames.BAG_ID_IST_TABLE_COLUMN_NAME);
                if (bagIdColumnIndex == -1)
                    return;

                foreach (DataRow row in localIST.Rows)
                {
                    int bagId = -1;
                    if (row[bagIdColumnIndex] == null || !Int32.TryParse(row[bagIdColumnIndex].ToString(), out bagId))
                        continue;
                    if (!htData.ContainsKey(bagId))
                        continue;

                    BaggageResult bagRes = htData[bagId];
                    if (bagRes is DepartingResult)
                    {
                        DepartingResult drTmp = (DepartingResult)bagRes;
                        if (drTmp == null)
                            continue;

                        double fromStationArrivingMinute = -1;
                        double toStationArrivingMinute = -1;
                        double ebsStorageMinutes = -1;
                        double dValue = getFromToMinutesDifference(fromStationCode, toStationCode, fromStationTimeType,
                            toStationTimeType, drTmp, false, out fromStationArrivingMinute, out toStationArrivingMinute,
                            out ebsStorageMinutes);

                        DateTime arrivingTimeAtFromStation = dtBegin.AddMinutes(fromStationArrivingMinute);
                        DateTime arrivingTimeAtToStation = dtBegin.AddMinutes(toStationArrivingMinute);
                        double minutesDifference = arrivingTimeAtToStation.Subtract(arrivingTimeAtFromStation).TotalMinutes;
                        if (subtractEBS)
                            minutesDifference = minutesDifference - ebsStorageMinutes;

                        row[timeAtFromStationColumnIndex] = arrivingTimeAtFromStation;
                        row[timeAtToStationColumnIndex] = arrivingTimeAtToStation;
                        row[minutesBetweenFromAndToStationColumnIndex] = Math.Round(minutesDifference, 2);
                    }
                }
                localIST.AcceptChanges();
                htResults.Add(localIST.TableName, localIST);
            }

            // >> Task #15684	PAX2SIM - BHS Analysis - Occupation by flow type            
            private static DataTable addOccupationByRoute(string fromStationCode, string toStationCode, string occupationTablePreffix,
                Dictionary<Int32, BaggageResult> htData, DateTime dtBegin, DateTime dtEnd, double scenarioStep, double analysisRange, double dWarmUp,
                string mupSegregation, Hashtable htResults)
            {
                string tableName = occupationTablePreffix + "_From_" + fromStationCode + "_To_" + toStationCode;

                ArrayList timesList = new ArrayList();
                foreach (int iResult in htData.Keys)
                {
                    DepartingResult drTmp = (DepartingResult)htData[iResult];
                    DateTime timeAtSystemEntrance = drTmp.GetTimeAtQueue(dtBegin);
                    if (timeAtSystemEntrance != null && timeAtSystemEntrance > dtEnd)
                        continue;
                    if (drTmp.LeavingSystemTime < dWarmUp)
                        continue;
                    if (mupSegregation != MUP_SEGREGATION_ALL)
                    {
                        if (makeUpSGroupsDictionary.ContainsKey(mupSegregation))
                        {
                            List<int> s3MupIndexes = makeUpSGroupsDictionary[mupSegregation];
                            if (!s3MupIndexes.Contains(drTmp.MakeUpIndex))
                                continue;
                        }
                    }

                    double fromStationMinute = -1;
                    double toStationMinute = -1;
                    double ebsStorageMinutes = -1;
                    double dValue = getFromToMinutesDifference(fromStationCode, toStationCode, AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING,
                        AnalysisResultFilter.STATION_TIME_TYPE_LEAVING, drTmp, false, out fromStationMinute, out toStationMinute,
                        out ebsStorageMinutes);

                    if (drTmp.Stopped)
                        toStationMinute = Math.Round(DataFunctions.MinuteDifference(dtBegin, dtEnd), 1);

                    if (fromStationMinute == -1 || toStationMinute == -1)
                        continue;

                    timesList.Add(new PointF((float)fromStationMinute, (float)toStationMinute));
                }
                if (timesList.Count > 0)
                {
                    DataTable dtTable = OverallTools.ResultFunctions.CalcQueueOccupationWithLeavingTimes(tableName, timesList, dtBegin,
                                            dtEnd, scenarioStep, "Nb Bags", true, true, analysisRange);
                    if (!htResults.ContainsKey(dtTable.TableName))
                    {
                        htResults.Add(dtTable.TableName, dtTable);
                        return dtTable;
                    }
                }
                return null;
            }
            // << Task #15684	PAX2SIM - BHS Analysis - Occupation by flow type

            private static void addRemainingTimeTableByRoute(string fromStationCode, string toStationCode,
                string sName, Dictionary<Int32, BaggageResult> htData, DateTime dtBegin, DateTime dtEnd,
                Double[] Levels, double dWarmUp, string mupSegregation, Dictionary<string, List<int>> makeUpSGroupsDictionary, Hashtable htResults)
            {
                string preffix = sName + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + fromStationCode + toStationCode;
                if (mupSegregation != MUP_SEGREGATION_ALL)
                    preffix = preffix + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + mupSegregation;

                ArrayList htRemaining = new ArrayList();
                foreach (int iResult in htData.Keys)
                {
                    DepartingResult drTmp = (DepartingResult)htData[iResult];
                    DateTime timeAtSystemEntrance = drTmp.GetTimeAtQueue(dtBegin);
                    if (timeAtSystemEntrance != null && timeAtSystemEntrance > dtEnd)
                        continue;

                    if (mupSegregation != MUP_SEGREGATION_ALL)
                    {
                        if (makeUpSGroupsDictionary.ContainsKey(mupSegregation))
                        {
                            List<int> s3MupIndexes = makeUpSGroupsDictionary[mupSegregation];
                            if (!s3MupIndexes.Contains(drTmp.MakeUpIndex))
                                continue;
                        }
                    }
                    if (drTmp.Stopped || (drTmp.LeavingSystemTime < dWarmUp))
                        continue;
                    if (drTmp.isContainer)
                        continue;

                    if (drTmp.STD != -1)
                        htRemaining.Add(drTmp.RemainingTime + dDecallage);
                }
                if (!htResults.ContainsKey(sName + "_RemainingTime"))
                {
                    DataTable distributionTable = ResultFunctions.GenerateDistribution(preffix + "_RemainingTime",
                        htRemaining, 5, GlobalNames.nbTimeIntervalsForRemainingTimeTable, -dDecallage, "Minutes", new String[] { "Nb Bags" }, Levels, null);
                    htResults.Add(distributionTable.TableName, distributionTable);
                }
            }

            // >> Task #17222 PAX2SIM - FromTo Times statistics - global summaries
            private static void addGlobalSummaryTable(string summaryTablePreffix, DataTable istTable, DataTable queueExitOccupationTable,
                DataTable collectorExitOccupationTable, Hashtable htResults)
            {
                DataTable globalSummaryTable = new DataTable(summaryTablePreffix + GlobalNames.BHS_SUMMARY_TABLE_NAME_SUFFIX);

                #region statistic table structure
                int kpiIdColumnIndex = globalSummaryTable.Columns.Count;
                globalSummaryTable.Columns.Add(GlobalNames.SUMMARY_TABLE_KPI_ID_COLUMN_NAME, typeof(Int32));

                int kpiNameColumnIndex = globalSummaryTable.Columns.Count;
                globalSummaryTable.Columns.Add(GlobalNames.SUMMARY_TABLE_DATA_COLUMN_NAME, typeof(String));

                int totalValueColumnIndex = globalSummaryTable.Columns.Count;
                globalSummaryTable.Columns.Add(GlobalNames.SUMMARY_TABLE_VALUE_COLUMN_NAME, typeof(Double));

                int totalValueUnitColumnIndex = globalSummaryTable.Columns.Count;
                globalSummaryTable.Columns.Add(GlobalNames.BHS_STATS_TABLE_TOTAL_VALUE_UNIT_COLUMN_NAME, typeof(String));

                int minValueColumnIndex = globalSummaryTable.Columns.Count;
                globalSummaryTable.Columns.Add(GlobalNames.SUMMARY_TABLE_MIN_VALUE_COLUMN_NAME, typeof(Double));

                int avgValueColumnIndex = globalSummaryTable.Columns.Count;
                globalSummaryTable.Columns.Add(GlobalNames.SUMMARY_TABLE_AVG_VALUE_COLUMN_NAME, typeof(Double));

                int maxValueColumnIndex = globalSummaryTable.Columns.Count;
                globalSummaryTable.Columns.Add(GlobalNames.SUMMARY_TABLE_MAX_VALUE_COLUMN_NAME, typeof(Double));

                int unitColumnIndex = globalSummaryTable.Columns.Count;
                globalSummaryTable.Columns.Add(GlobalNames.SUMMARY_TABLE_UNIT_COLUMN_NAME, typeof(String));
                #endregion

                List<SummaryKPI> kpis = getGlobalSummaryKpis(istTable, queueExitOccupationTable, collectorExitOccupationTable);
                int kpiId = 1;
                foreach (SummaryKPI kpi in kpis)
                {
                    DataRow row = globalSummaryTable.NewRow();
                    row[kpiIdColumnIndex] = kpiId;
                    row[kpiNameColumnIndex] = kpi.name;
                    if (kpi.value != -1)
                    {
                        row[totalValueColumnIndex] = kpi.value;
                        row[totalValueUnitColumnIndex] = kpi.valueUnitName;
                    }
                    if (kpi.minValue != -1 && kpi.avgValue != -1 && kpi.maxValue != -1)
                    {
                        row[minValueColumnIndex] = kpi.minValue;
                        row[avgValueColumnIndex] = kpi.avgValue;
                        row[maxValueColumnIndex] = kpi.maxValue;
                        row[unitColumnIndex] = kpi.unitName;
                    }
                    globalSummaryTable.Rows.Add(row);
                    kpiId++;
                }
                htResults.Add(globalSummaryTable.TableName, globalSummaryTable);
            }

            private static List<SummaryKPI> getGlobalSummaryKpis(DataTable istTable, DataTable queueExitOccupationTable, DataTable collectorExitOccupationTable)
            {
                List<SummaryKPI> kpis = new List<SummaryKPI>();
                if (istTable != null && istTable.Columns.IndexOf("Stopped") != -1)
                {
                    int stoppedColumnIndex = istTable.Columns.IndexOf("Stopped");
                    int nbTotalBags = 0;
                    int nbStoppedBags = 0;
                    foreach (DataRow row in istTable.Rows)
                    {
                        nbTotalBags++;
                        bool isStopped = false;
                        if (row[stoppedColumnIndex] != null && bool.TryParse(row[stoppedColumnIndex].ToString(), out isStopped)
                            && isStopped)
                        {
                            nbStoppedBags++;
                        }
                    }
                    SummaryKPI nbTotalBagsKpi = new SummaryKPI();
                    nbTotalBagsKpi.name = GlobalNames.BHS_KPI_NAME_NB_BAGS;
                    nbTotalBagsKpi.value = nbTotalBags;
                    nbTotalBagsKpi.valueUnitName = "Bag(s)";
                    kpis.Add(nbTotalBagsKpi);

                    SummaryKPI nbStoppedBagsKpi = new SummaryKPI();
                    nbStoppedBagsKpi.name = GlobalNames.BHS_KPI_NAME_NB_STOPPED_BAGS;
                    nbStoppedBagsKpi.value = nbStoppedBags;
                    nbStoppedBagsKpi.valueUnitName = "Bag(s)";
                    kpis.Add(nbStoppedBagsKpi);
                }
                if (queueExitOccupationTable != null)
                {
                    List<SummaryKPI> queueExitKpis = getOccupationKPIs(queueExitOccupationTable, GlobalNames.QUEUE_EXIT_OCCUPATION_KPI_NAMES_MAP);
                    kpis.AddRange(queueExitKpis.ToArray());
                }
                if (collectorExitOccupationTable != null)
                {
                    List<SummaryKPI> collectorExitKpis = getOccupationKPIs(collectorExitOccupationTable, GlobalNames.COLLECTOR_EXIT_OCCUPATION_KPI_NAMES_MAP);
                    kpis.AddRange(collectorExitKpis.ToArray());
                }
                return kpis;
            }

            private static List<SummaryKPI> getOccupationKPIs(DataTable occupationTable, Dictionary<String, String> occupationKpiNamesMap)
            {
                List<SummaryKPI> kpis = new List<SummaryKPI>();

                int minOccColumnIndex = occupationTable.Columns.IndexOf(GlobalNames.BHS_OCCUPATION_TABLE_MIN_OCC_COLUMN_NAME);
                int avgOccColumnIndex = occupationTable.Columns.IndexOf(GlobalNames.BHS_OCCUPATION_TABLE_AVG_OCC_COLUMN_NAME);
                int maxOccColumnIndex = occupationTable.Columns.IndexOf(GlobalNames.BHS_OCCUPATION_TABLE_MAX_OCC_COLUMN_NAME);

                int nbInColumnIndex = occupationTable.Columns.IndexOf(GlobalNames.BHS_OCCUPATION_TABLE_NB_BAGS_IN_COLUMN_NAME);
                int nbOutColumnIndex = occupationTable.Columns.IndexOf(GlobalNames.BHS_OCCUPATION_TABLE_NB_BAGS_OUT_COLUMN_NAME);

                int throughputInColumnIndex = occupationTable.Columns.IndexOf(GlobalNames.BHS_OCCUPATION_TABLE_THROUGHPUT_IN_COLUMN_NAME);
                int instantThroughputInColumnIndex = occupationTable.Columns.IndexOf(GlobalNames.OCCUPATION_TABLE_THROUGHPUT_INSTANT_IN_COLUMN_NAME);

                int throughputOutColumnIndex = occupationTable.Columns.IndexOf(GlobalNames.BHS_OCCUPATION_TABLE_THROUGHPUT_OUT_COLUMN_NAME);
                int instantThroughputOutColumnIndex = occupationTable.Columns.IndexOf(GlobalNames.OCCUPATION_TABLE_THROUGHPUT_INSTANT_OUT_COLUMN_NAME);

                if (minOccColumnIndex != -1 && avgOccColumnIndex != -1 && maxOccColumnIndex != -1)
                {
                    double[] minOccColStats = OverallTools.DataFunctions.GetStatColumn(occupationTable, minOccColumnIndex);
                    double[] avgOccColStats = OverallTools.DataFunctions.GetStatColumn(occupationTable, avgOccColumnIndex);
                    double[] maxOccColStats = OverallTools.DataFunctions.GetStatColumn(occupationTable, maxOccColumnIndex);

                    SummaryKPI occupationKpi = new SummaryKPI();
                    occupationKpi.name = occupationKpiNamesMap[GlobalNames.BHS_KPI_NAME_OCCUPATION];
                    occupationKpi.minValue = Math.Round(minOccColStats[0], 2);
                    occupationKpi.avgValue = Math.Round(avgOccColStats[2], 2);
                    occupationKpi.maxValue = Math.Round(maxOccColStats[1], 2);
                    occupationKpi.unitName = "Bag(s)";
                    kpis.Add(occupationKpi);
                }
                if (nbInColumnIndex != -1)
                {
                    double[] nbInColStats = OverallTools.DataFunctions.GetStatColumn(occupationTable, nbInColumnIndex);
                    double totalNbIn = OverallTools.DataFunctions.SumColumn(occupationTable, GlobalNames.BHS_OCCUPATION_TABLE_NB_BAGS_IN_COLUMN_NAME);
                    SummaryKPI nbInKpi = new SummaryKPI();
                    nbInKpi.name = occupationKpiNamesMap[GlobalNames.BHS_KPI_NAME_INPUT_BAGS];
                    nbInKpi.value = Math.Round(totalNbIn, 2);
                    nbInKpi.valueUnitName = "Bag(s)";
                    nbInKpi.minValue = Math.Round(nbInColStats[0], 2);
                    nbInKpi.avgValue = Math.Round(nbInColStats[2], 2);
                    nbInKpi.maxValue = Math.Round(nbInColStats[1], 2);
                    nbInKpi.unitName = "Bag(s)";
                    kpis.Add(nbInKpi);
                }
                if (nbOutColumnIndex != -1)
                {
                    double[] nbOutColStats = OverallTools.DataFunctions.GetStatColumn(occupationTable, nbOutColumnIndex);
                    double totalNbOut = OverallTools.DataFunctions.SumColumn(occupationTable, GlobalNames.BHS_OCCUPATION_TABLE_NB_BAGS_OUT_COLUMN_NAME);
                    SummaryKPI nbOutKpi = new SummaryKPI();
                    nbOutKpi.name = occupationKpiNamesMap[GlobalNames.BHS_KPI_NAME_OUTPUT_BAGS];
                    nbOutKpi.value = Math.Round(totalNbOut, 2);
                    nbOutKpi.valueUnitName = "Bag(s)";
                    nbOutKpi.minValue = Math.Round(nbOutColStats[0], 2);
                    nbOutKpi.avgValue = Math.Round(nbOutColStats[2], 2);
                    nbOutKpi.maxValue = Math.Round(nbOutColStats[1], 2);
                    nbOutKpi.unitName = "Bag(s)";
                    kpis.Add(nbOutKpi);
                }
                if (throughputInColumnIndex != -1)
                {
                    double[] throughputInColStats = OverallTools.DataFunctions.GetStatColumn(occupationTable, throughputInColumnIndex);
                    SummaryKPI throughputInKpi = new SummaryKPI();
                    throughputInKpi.name = occupationKpiNamesMap[GlobalNames.BHS_KPI_NAME_THROUGHPUT_INPUT];
                    throughputInKpi.minValue = Math.Round(throughputInColStats[0], 2);
                    throughputInKpi.avgValue = Math.Round(throughputInColStats[2], 2);
                    throughputInKpi.maxValue = Math.Round(throughputInColStats[1], 2);
                    throughputInKpi.unitName = "Bag(s)";
                    kpis.Add(throughputInKpi);
                }
                if (instantThroughputInColumnIndex != -1)
                {
                    double[] instantThroughputInColStats = OverallTools.DataFunctions.GetStatColumn(occupationTable, instantThroughputInColumnIndex);
                    SummaryKPI instantThroughputInKpi = new SummaryKPI();
                    instantThroughputInKpi.name = occupationKpiNamesMap[GlobalNames.BHS_KPI_NAME_THROUGHPUT_INSTANT_INPUT];
                    instantThroughputInKpi.minValue = Math.Round(instantThroughputInColStats[0], 2);
                    instantThroughputInKpi.avgValue = Math.Round(instantThroughputInColStats[2], 2);
                    instantThroughputInKpi.maxValue = Math.Round(instantThroughputInColStats[1], 2);
                    instantThroughputInKpi.unitName = "Bag(s)";
                    kpis.Add(instantThroughputInKpi);
                }
                if (throughputOutColumnIndex != -1)
                {
                    double[] throughputOutColStats = OverallTools.DataFunctions.GetStatColumn(occupationTable, throughputOutColumnIndex);
                    SummaryKPI throughputOutKpi = new SummaryKPI();
                    throughputOutKpi.name = occupationKpiNamesMap[GlobalNames.BHS_KPI_NAME_THROUGHPUT_OUTPUT];
                    throughputOutKpi.minValue = Math.Round(throughputOutColStats[0], 2);
                    throughputOutKpi.avgValue = Math.Round(throughputOutColStats[2], 2);
                    throughputOutKpi.maxValue = Math.Round(throughputOutColStats[1], 2);
                    throughputOutKpi.unitName = "Bag(s)";
                    kpis.Add(throughputOutKpi);
                }
                if (instantThroughputOutColumnIndex != -1)
                {
                    double[] instantThroughputOutColStats = OverallTools.DataFunctions.GetStatColumn(occupationTable, instantThroughputOutColumnIndex);
                    SummaryKPI instantThroughputOutKpi = new SummaryKPI();
                    instantThroughputOutKpi.name = occupationKpiNamesMap[GlobalNames.BHS_KPI_NAME_THROUGHPUT_INSTANT_OUTPUT];
                    instantThroughputOutKpi.minValue = Math.Round(instantThroughputOutColStats[0], 2);
                    instantThroughputOutKpi.avgValue = Math.Round(instantThroughputOutColStats[2], 2);
                    instantThroughputOutKpi.maxValue = Math.Round(instantThroughputOutColStats[1], 2);
                    instantThroughputOutKpi.unitName = "Bag(s)";
                    kpis.Add(instantThroughputOutKpi);
                }
                return kpis;
            }
            // << Task #17222 PAX2SIM - FromTo Times statistics - global summaries

            #region FROM-TO Constants
            public static List<string> ROUTE_STATION_TIME_TYPES_LIST
                = new List<string>(new string[] { AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING, AnalysisResultFilter.STATION_TIME_TYPE_LEAVING });

            public static List<string> ROUTE_FROM_STATION_CODE_LIST = new List<string>(new string[] { FROMTO_ENTRY_STATION_CODE,FROMTO_EXIT_STATION_CODE,
                FROMTO_QUEUE_STATION_CODE, FROMTO_COLLECTOR_STATION_CODE, FROMTO_CI_QUEUE_STATION_CODE, FROMTO_CI_COLLECTOR_STATION_CODE, FROMTO_CHECKIN_STATION_CODE,
                FROMTO_TRANSF_QUEUE_STATION_CODE, FROMTO_TRANSF_INFEED_STATION_CODE, FROMTO_TRANSF_COLLECTOR_STATION_CODE, FROMTO_PRESORTATION_STATION_CODE,
                FROMTO_DEP_READER_STATION_CODE, FROMTO_EBS_STATION_CODE, FROMTO_LAST_CHUTE_STATION_CODE, FROMTO_MAKEUP_STATION_CODE});

            public static List<string> ROUTE_TO_STATION_CODE_LIST = new List<string>(new string[] { FROMTO_COLLECTOR_STATION_CODE, FROMTO_EXIT_STATION_CODE,
                FROMTO_CI_COLLECTOR_STATION_CODE, FROMTO_CHECKIN_STATION_CODE, FROMTO_TRANSF_COLLECTOR_STATION_CODE, FROMTO_TRANSF_INFEED_STATION_CODE,
                FROMTO_PRESORTATION_STATION_CODE, FROMTO_DEP_READER_STATION_CODE, FROMTO_EBS_STATION_CODE, FROMTO_LAST_CHUTE_STATION_CODE, FROMTO_MAKEUP_STATION_CODE });

            public static List<string> ROUTE_STATION_CODE_LIST = new List<string>(new string[] { FROMTO_ENTRY_STATION_CODE,FROMTO_EXIT_STATION_CODE,
                FROMTO_QUEUE_STATION_CODE, FROMTO_COLLECTOR_STATION_CODE, FROMTO_CI_QUEUE_STATION_CODE, FROMTO_CI_COLLECTOR_STATION_CODE, FROMTO_CHECKIN_STATION_CODE,
                FROMTO_TRANSF_QUEUE_STATION_CODE, FROMTO_TRANSF_COLLECTOR_STATION_CODE, FROMTO_TRANSF_INFEED_STATION_CODE, FROMTO_PRESORTATION_STATION_CODE,
                FROMTO_DEP_READER_STATION_CODE, FROMTO_EBS_STATION_CODE, FROMTO_LAST_CHUTE_STATION_CODE, FROMTO_MAKEUP_STATION_CODE});

            internal const string FROMTO_MULTIPLE_STATION_CODE_PREFIX = "^";
            internal const string FROMTO_ENTRY_STATION_CODE = "Entry" + FROMTO_MULTIPLE_STATION_CODE_PREFIX;
            internal const string FROMTO_QUEUE_STATION_CODE = "Q" + FROMTO_MULTIPLE_STATION_CODE_PREFIX;
            internal const string FROMTO_COLLECTOR_STATION_CODE = "Coll" + FROMTO_MULTIPLE_STATION_CODE_PREFIX;
            internal const string FROMTO_EXIT_STATION_CODE = "Exit" + FROMTO_MULTIPLE_STATION_CODE_PREFIX;

            internal const string FROMTO_CI_QUEUE_STATION_CODE = "CIQ";
            internal const string FROMTO_TRANSF_QUEUE_STATION_CODE = "TrQ";

            internal const string FROMTO_CI_COLLECTOR_STATION_CODE = "CIColl";
            internal const string FROMTO_TRANSF_COLLECTOR_STATION_CODE = "TrColl";

            internal const string FROMTO_CHECKIN_STATION_CODE = "CI";
            internal const string FROMTO_TRANSF_INFEED_STATION_CODE = "TrIF";
            internal const string FROMTO_DEP_READER_STATION_CODE = "Reader";
            internal const string FROMTO_EBS_STATION_CODE = "EBS";
            internal const string FROMTO_LAST_CHUTE_STATION_CODE = "LChute";
            internal const string FROMTO_MAKEUP_STATION_CODE = "MU";
            internal const string FROMTO_PRESORTATION_STATION_CODE = "Presort";

            internal const string ANALYSIS_NAME_STATION_TYPES_SEPARATOR = "#";
            #endregion

            public static bool stationCodeBelongsToFlowTypeVisualName(string stationCode, string flowType)
            {
                if (flowType == AnalysisResultFilter.DEPARTING_FLOW_TYPE_VISUAL_NAME
                    && (AnalysisResultFilter.ORIGINATING_STATION_CODE_LIST.Contains(stationCode) || AnalysisResultFilter.TRANSFERRING_STATION_CODE_LIST.Contains(stationCode)))
                {
                    return true;
                }
                else if (flowType == AnalysisResultFilter.ORIGINATING_FLOW_TYPE_VISUAL_NAME && AnalysisResultFilter.ORIGINATING_STATION_CODE_LIST.Contains(stationCode))
                {
                    return true;
                }
                else if (flowType == AnalysisResultFilter.TRANSFERRING_FLOW_TYPE_VISUAL_NAME && AnalysisResultFilter.TRANSFERRING_STATION_CODE_LIST.Contains(stationCode))
                {
                    return true;
                }
                return false;
            }

            private static void addFromToDepartingStatisticTables(string fromStationCode, string toStationCode,
                Dictionary<Int32, BaggageResult> htData, string sName, string sRemainingName,
                double[] Levels, double dDistributionStep, double scenarioStep, double dWarmUp, bool bHasEBS, int iNbClasses, string mupSegregation,
                DateTime dtBegin, DateTime dtEnd, Hashtable htResults, XmlNode airportStructure, AnalysisResultFilter resultFilter)
            {
                int maxNbRecirc = -1;
                List<int> segregationLineNumbers = new List<int>();

                string pbcSpecificatorSuffix = "";
                string suffix = ANALYSIS_NAME_STATION_TYPES_SEPARATOR + fromStationCode + toStationCode;
                string nameTag = sName + suffix;

                //sName += suffix;                                
                if (mupSegregation != MUP_SEGREGATION_ALL)
                    nameTag = nameTag + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + mupSegregation;

                DataTable globalStats = null;
                generateFromToDepartingStatistics(fromStationCode, toStationCode, htData, nameTag, sRemainingName,
                    pbcSpecificatorSuffix, Levels, dDistributionStep, scenarioStep, dWarmUp, bHasEBS, iNbClasses, mupSegregation, dtBegin, dtEnd,
                    htResults, null, "", resultFilter, out globalStats);

                if (resultFilter.withRecirculation)
                {
                    addRecirculationStatistics(fromStationCode, toStationCode, nameTag, sRemainingName, pbcSpecificatorSuffix, htData,
                        dtBegin, dtEnd, Levels, dDistributionStep, scenarioStep, dWarmUp, bHasEBS, iNbClasses, mupSegregation, htResults, globalStats, resultFilter, out maxNbRecirc);
                }
                if (resultFilter.withFromSegregation || resultFilter.withToSegregation)
                {
                    addSegregationByLineStatistics(fromStationCode, toStationCode, nameTag, sRemainingName, htData,
                        dtBegin, dtEnd, Levels, dDistributionStep, scenarioStep, dWarmUp, bHasEBS, iNbClasses, mupSegregation, htResults, globalStats,
                        airportStructure, resultFilter, out segregationLineNumbers);
                }
                if (resultFilter.displayParameter == null)
                    resultFilter.displayParameter = new AnalysisResultsDisplayParameters(maxNbRecirc, segregationLineNumbers);
                else
                    resultFilter.displayParameter.update(maxNbRecirc, segregationLineNumbers);
            }

            private static AnalysisResultFilter getResultFilterByRoute(string fromStationCode, string toStationCode,
                List<AnalysisResultFilter> resultsFilters)
            {
                if (resultsFilters == null)
                    return null;
                foreach (AnalysisResultFilter resFil in resultsFilters)
                    if (resFil.fromStationCode == fromStationCode && resFil.toStationCode == toStationCode)
                        return resFil;
                return null;
            }

            internal const string RECIRCULATION_PREFFIX_PART = "Rec";
            private static void addRecirculationStatistics(string fromStationCode, string toStationCode,
                string sName, string sRemainingName, string pbcSpecificatorSuffix, Dictionary<Int32, BaggageResult> htData,
                DateTime dtBegin, DateTime dtEnd, double[] Levels, double dDistributionStep, double scenarioStep, double dWarmUp, bool bHasEBS, int iNbClasses, string mupSegregation,
                Hashtable htResults, DataTable globalStats, AnalysisResultFilter resultFilter, out int maxNbRecirculations)
            {
                maxNbRecirculations = getMaxNbRecirculations(fromStationCode, toStationCode, resultFilter.fromStationTimeType, resultFilter.toStationTimeType,
                    htData, dtBegin, dtEnd, mupSegregation, dWarmUp);
                for (int i = 0; i <= maxNbRecirculations; i++)
                {
                    string recircNamePrefix = sName + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + RECIRCULATION_PREFFIX_PART + i;
                    string recircRemainingPrefix = sRemainingName + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + RECIRCULATION_PREFFIX_PART + i;

                    Dictionary<int, BaggageResult> recircData = new Dictionary<int, BaggageResult>();
                    DataTable stats = null;
                    string recirculationLineSeparator = "";
                    if (i == 0)
                    {
                        pbcSpecificatorSuffix = " onlyPBC ";
                        recirculationLineSeparator = i + " Recirculation(s) " + pbcSpecificatorSuffix;
                        recircData = filterBagsByRecirculationNb(i, true, htData, dtBegin, dtEnd, mupSegregation, dWarmUp);
                        generateFromToDepartingStatistics(fromStationCode, toStationCode, recircData, recircNamePrefix, recircRemainingPrefix,
                            pbcSpecificatorSuffix, Levels, dDistributionStep, scenarioStep, dWarmUp, bHasEBS, iNbClasses, mupSegregation, dtBegin, dtEnd, htResults, globalStats,
                            recirculationLineSeparator, resultFilter, out stats);
                        pbcSpecificatorSuffix = " noPBC ";
                        recirculationLineSeparator = i + " Recirculation(s) " + pbcSpecificatorSuffix;
                        recircData = filterBagsByRecirculationNb(i, false, htData, dtBegin, dtEnd, mupSegregation, dWarmUp);
                        generateFromToDepartingStatistics(fromStationCode, toStationCode, recircData, recircNamePrefix, recircRemainingPrefix,
                            pbcSpecificatorSuffix, Levels, dDistributionStep, scenarioStep, dWarmUp, bHasEBS, iNbClasses, mupSegregation, dtBegin, dtEnd, htResults, globalStats,
                            recirculationLineSeparator, resultFilter, out stats);
                    }
                    else
                    {
                        pbcSpecificatorSuffix = "";
                        recirculationLineSeparator = i + " Recirculation(s) ";
                        recircData = filterBagsByRecirculationNb(i, false, htData, dtBegin, dtEnd, mupSegregation, dWarmUp);
                        generateFromToDepartingStatistics(fromStationCode, toStationCode, recircData, recircNamePrefix, recircRemainingPrefix,
                            pbcSpecificatorSuffix, Levels, dDistributionStep, scenarioStep, dWarmUp, bHasEBS, iNbClasses, mupSegregation, dtBegin, dtEnd, htResults, globalStats,
                            recirculationLineSeparator, resultFilter, out stats);
                    }
                }
            }

            internal const string LINE_SEGR_PREFFIX_PART = "Segr";
            private static void addSegregationByLineStatistics(string fromStationCode, string toStationCode,
                string sName, string sRemainingName, Dictionary<Int32, BaggageResult> htData,
                DateTime dtBegin, DateTime dtEnd, double[] Levels, double dDistributionStep, double scenarioStep, double dWarmUp, bool bHasEBS, int iNbClasses, string mupSegregation,
                Hashtable htResults, DataTable globalStats, XmlNode airportStructure, AnalysisResultFilter resultFilter, out List<int> segregationLineNumbers)
            {
                List<string> fromStationCodes = new List<string>();
                if (fromStationCode == FROMTO_QUEUE_STATION_CODE)
                {
                    fromStationCodes.Add(FROMTO_CI_QUEUE_STATION_CODE);
                    fromStationCodes.Add(FROMTO_TRANSF_QUEUE_STATION_CODE);
                }
                else if (fromStationCode == FROMTO_COLLECTOR_STATION_CODE)
                {
                    fromStationCodes.Add(FROMTO_CI_COLLECTOR_STATION_CODE);
                    if (foundTransferCollectorInTrace)
                        fromStationCodes.Add(FROMTO_TRANSF_COLLECTOR_STATION_CODE);
                    else if (foundTransferInfeedInTrace)
                        fromStationCodes.Add(FROMTO_TRANSF_INFEED_STATION_CODE);
                }
                else
                    fromStationCodes.Add(fromStationCode);

                List<string> toStationCodes = new List<string>();
                if (toStationCode == FROMTO_QUEUE_STATION_CODE)
                {
                    toStationCodes.Add(FROMTO_CI_QUEUE_STATION_CODE);
                    toStationCodes.Add(FROMTO_TRANSF_QUEUE_STATION_CODE);
                }
                else if (toStationCode == FROMTO_COLLECTOR_STATION_CODE)
                {
                    toStationCodes.Add(FROMTO_CI_COLLECTOR_STATION_CODE);
                    if (foundTransferCollectorInTrace)
                        toStationCodes.Add(FROMTO_TRANSF_COLLECTOR_STATION_CODE);
                    else if (foundTransferInfeedInTrace)
                        toStationCodes.Add(FROMTO_TRANSF_INFEED_STATION_CODE);
                }
                else
                    toStationCodes.Add(toStationCode);


                segregationLineNumbers = new List<int>();
                if (resultFilter.withFromSegregation && resultFilter.withToSegregation)
                {

                    List<int> fromStationSegregationLines = getSegregationLineNumbers(fromStationCodes, airportStructure);
                    List<int> toStationSegregationLines = getSegregationLineNumbers(toStationCodes, airportStructure);
                    segregationLineNumbers.AddRange(fromStationSegregationLines);
                    foreach (int i in toStationSegregationLines)
                    {
                        if (!segregationLineNumbers.Contains(i))
                            segregationLineNumbers.Add(i);
                    }
                }
                else if (resultFilter.withFromSegregation)
                    segregationLineNumbers.AddRange(getSegregationLineNumbers(fromStationCodes, airportStructure));
                else if (resultFilter.withToSegregation)
                    segregationLineNumbers.AddRange(getSegregationLineNumbers(toStationCodes, airportStructure));

                if (segregationLineNumbers.Count == 0)
                    return;
                List<int> emptySegregationLines = new List<int>();
                foreach (int i in segregationLineNumbers)
                {
                    string lineSegrNamePreffix = sName + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + LINE_SEGR_PREFFIX_PART + i;
                    string lineSegrRemainingNamePreffix = sRemainingName + ANALYSIS_NAME_STATION_TYPES_SEPARATOR + LINE_SEGR_PREFFIX_PART + i;

                    DataTable stats = null;
                    string lineSegregationLineSeparator = i + " Segregation(s) ";
                    Dictionary<int, BaggageResult> lineSegrData = filterBagsByLineSegregation(i, fromStationCode, toStationCode, resultFilter.fromStationTimeType, resultFilter.toStationTimeType,
                        resultFilter.withFromSegregation, resultFilter.withToSegregation, htData, dtBegin, dtEnd, mupSegregation, dWarmUp);
                    if (lineSegrData.Count > 0)
                    {
                        generateFromToDepartingStatistics(fromStationCode, toStationCode, lineSegrData, lineSegrNamePreffix, lineSegrRemainingNamePreffix,
                            "", Levels, dDistributionStep, scenarioStep, dWarmUp, bHasEBS, iNbClasses, mupSegregation, dtBegin, dtEnd, htResults, globalStats,
                            lineSegregationLineSeparator, resultFilter, out stats);
                    }
                    else
                    {
                        emptySegregationLines.Add(i);
                    }
                }
                foreach (int emptyLine in emptySegregationLines)
                {
                    if (emptySegregationLines.Contains(emptyLine))
                        segregationLineNumbers.Remove(emptyLine);
                }
            }

            // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation            
            /*public static List<int> getSegregationLineNumbers_old(List<string> referenceStationCodesList, XmlNode airportStructure)
            {
                List<int> segregationLineNumbers = new List<int>();
                int maxDeskIndexFromAirportStructure = getMaxDeskIndexFromAirportStrucutreByStationCode(referenceStationCodesList, airportStructure);
                
                List<int> deskIndexesFromTrace = new List<int>();                
                foreach (string referenceStationCode in referenceStationCodesList)
                {                    
                    string stationTraceKeyword = getStationTraceKeywordByStationCode(referenceStationCode);

                    int maxDeskIndexFromTrace = -1;
                    if (deskIndexesByStationTypeDictionary.ContainsKey(stationTraceKeyword))
                    {
                        deskIndexesFromTrace = deskIndexesByStationTypeDictionary[stationTraceKeyword];
                        if (deskIndexesFromTrace.Count > 0)
                        {
                            deskIndexesFromTrace.Sort();
                            maxDeskIndexFromTrace = deskIndexesFromTrace[deskIndexesFromTrace.Count - 1];
                        }
                    }

                    if (maxDeskIndexFromAirportStructure > 0 && maxDeskIndexFromTrace > 0)
                    {
                        foreach (int deskIndexTrace in deskIndexesFromTrace)
                        {
                            if (deskIndexTrace <= maxDeskIndexFromAirportStructure && !segregationLineNumbers.Contains(deskIndexTrace))
                                segregationLineNumbers.Add(deskIndexTrace);
                        }
                    }
                    else if (maxDeskIndexFromTrace > 0)
                    {
                        foreach (int deskIndexTrace in deskIndexesFromTrace)
                        {
                            if (!segregationLineNumbers.Contains(deskIndexTrace))
                                segregationLineNumbers.Add(deskIndexTrace);
                        }                        
                    }
                }

                segregationLineNumbers.Sort();
                return segregationLineNumbers;
            }*/

            public static List<int> getSegregationLineNumbers(List<string> referenceStationCodesList, XmlNode airportStructure)
            {
                List<int> segregationLineNumbers = new List<int>();
                int maxDeskIndexFromAirportStructure = getMaxDeskIndexFromAirportStrucutreByStationCode(referenceStationCodesList, airportStructure);

                List<int> deskIndexesFromTrace = new List<int>();
                foreach (string referenceStationCode in referenceStationCodesList)
                {
                    List<string> stationTraceKeywords = getStationTraceKeywordsListByStationCode(referenceStationCode);
                    foreach (string stationTraceKeyword in stationTraceKeywords)
                    {
                        int maxDeskIndexFromTrace = -1;
                        if (deskIndexesByStationTypeDictionary.ContainsKey(stationTraceKeyword))
                        {
                            deskIndexesFromTrace = deskIndexesByStationTypeDictionary[stationTraceKeyword];
                            if (deskIndexesFromTrace.Count > 0)
                            {
                                deskIndexesFromTrace.Sort();
                                maxDeskIndexFromTrace = deskIndexesFromTrace[deskIndexesFromTrace.Count - 1];
                            }
                        }

                        if (maxDeskIndexFromAirportStructure > 0 && maxDeskIndexFromTrace > 0)
                        {
                            foreach (int deskIndexTrace in deskIndexesFromTrace)
                            {
                                if (deskIndexTrace <= maxDeskIndexFromAirportStructure && !segregationLineNumbers.Contains(deskIndexTrace))
                                    segregationLineNumbers.Add(deskIndexTrace);
                            }
                        }
                        else if (maxDeskIndexFromTrace > 0)
                        {
                            foreach (int deskIndexTrace in deskIndexesFromTrace)
                            {
                                if (!segregationLineNumbers.Contains(deskIndexTrace))
                                    segregationLineNumbers.Add(deskIndexTrace);
                            }
                        }
                    }
                }

                segregationLineNumbers.Sort();
                return segregationLineNumbers;
            }
            // << Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation

            /// <summary>
            /// If using an abstract station code (ex:Queue contains CIQ and TrQ) 
            /// it will return the max index out of all station codes represented by the abstract station code (max(CIQ, TrQ)).
            /// </summary>
            /// <param name="referenceStationCodesList"></param>
            /// <param name="airportStructure"></param>
            /// <returns></returns>
            private static int getMaxDeskIndexFromAirportStrucutreByStationCode(List<string> referenceStationCodesList, XmlNode airportStructure)
            {
                int maxDeskIndex = -1;
                foreach (string stationCode in referenceStationCodesList)
                {
                    string airportStructureCode = getAirportStructureCodeByStationCode(stationCode);
                    if (airportStructureCode == "")
                        return -1;

                    XmlNode[] groups = null;
                    for (int i = 1; i <= GestionDonneesHUB2SIM.NbTerminaux; i++)
                    {
                        groups = GestionDonneesHUB2SIM.getGroup(airportStructure, i, airportStructureCode);
                        if (groups == null)
                            continue;
                        foreach (XmlNode group in groups)
                        {
                            if (group.ChildNodes == null)
                                continue;
                            foreach (XmlNode desk in group.ChildNodes)
                            {
                                int deskIndex = -1;
                                if (GestionDonneesHUB2SIM.tryGetResourceIndex(desk, out deskIndex))
                                {
                                    if (maxDeskIndex < deskIndex)
                                        maxDeskIndex = deskIndex;
                                }
                            }
                        }
                    }
                }
                return maxDeskIndex;
            }

            private static Dictionary<Int32, BaggageResult> filterBagsByLineSegregation(int lineSegrNb, string fromStationCode,
                string toStationCode, string fromStationTimeType, string toStationTimeType, bool useFromStationAsReference, bool useToStationAsReference,
                Dictionary<Int32, BaggageResult> htData,
                DateTime dtBegin, DateTime dtEnd, string mupSegregation, double dWarmUp)
            {
                Dictionary<Int32, BaggageResult> filteredData = new Dictionary<int, BaggageResult>();
                foreach (int iResult in htData.Keys)
                {
                    DepartingResult drTmp = (DepartingResult)htData[iResult];
                    if (mupSegregation != MUP_SEGREGATION_ALL)
                    {
                        int mupIndex = drTmp.MakeUpIndex;
                        if (makeUpSGroupsDictionary.ContainsKey(mupSegregation))
                        {
                            List<int> s3MupIndexes = makeUpSGroupsDictionary[mupSegregation];
                            if (!s3MupIndexes.Contains(mupIndex))
                                continue;
                        }
                    }
                    if (drTmp.Stopped || drTmp.LeavingSystemTime < dWarmUp)
                        continue;
                    int fromStationDeskIndex = -1;
                    int toStationDeskIndex = -1;
                    if (useFromStationAsReference)
                    {
                        fromStationDeskIndex = getStationDeskIndex(fromStationCode, fromStationCode, toStationCode, fromStationTimeType, toStationTimeType, drTmp);
                        if (fromStationDeskIndex == -1)
                            continue;
                    }
                    if (useToStationAsReference)
                    {
                        toStationDeskIndex = getStationDeskIndex(toStationCode, fromStationCode, toStationCode, fromStationTimeType, toStationTimeType, drTmp);
                        if (toStationDeskIndex == -1)
                            continue;
                    }

                    if (useFromStationAsReference && useToStationAsReference)
                    {
                        if (fromStationDeskIndex == lineSegrNb && toStationDeskIndex == lineSegrNb)
                            filteredData.Add(iResult, drTmp);
                    }
                    else if (useFromStationAsReference && fromStationDeskIndex == lineSegrNb)
                        filteredData.Add(iResult, drTmp);
                    else if (useToStationAsReference && toStationDeskIndex == lineSegrNb)
                        filteredData.Add(iResult, drTmp);
                }
                return filteredData;
            }

            private static void addTimelineStatistics(string fromStationCode, string toStationCode,
                Hashtable htResults, string sName, string pbcSpecificator, DateTime dtBegin, DateTime dtEnd, double scenarioStep, double dWarmUp, Double[] Levels,
                Dictionary<Int32, BaggageResult> htData,
                string mupSegregation, Dictionary<string, List<int>> makeUpSGroupsDictionary, AnalysisResultFilter resultFilter)
            {
                ArrayList bagTimesInfo = new ArrayList();
                foreach (int iResult in htData.Keys)
                {
                    DepartingResult drTmp = (DepartingResult)htData[iResult];
                    int mupIndex = drTmp.MakeUpIndex;
                    if (mupSegregation != MUP_SEGREGATION_ALL)
                    {
                        if (makeUpSGroupsDictionary.ContainsKey(mupSegregation))
                        {
                            List<int> s3MupIndexes = makeUpSGroupsDictionary[mupSegregation];
                            if (!s3MupIndexes.Contains(mupIndex))
                                continue;
                        }
                    }
                    if (drTmp.Stopped || drTmp.LeavingSystemTime < dWarmUp || drTmp.isContainer)
                        continue;

                    double fromStationMinute = -1;
                    double toStationMinute = -1;
                    double ebsStorageMinutes = -1;
                    double travelMinutes = getFromToMinutesDifference(fromStationCode, toStationCode, resultFilter.fromStationTimeType, resultFilter.toStationTimeType,
                                            drTmp, resultFilter.excludeEBSStorageTime, out fromStationMinute, out toStationMinute, out ebsStorageMinutes);
                    DateTime fromStationArrivingTime = dtBegin.AddMinutes(fromStationMinute);

                    if (fromStationMinute == -1 || toStationMinute == -1 || travelMinutes < 0)
                        continue;
                    BagInfo bagInfo = new BagInfo(drTmp.IDBag, fromStationArrivingTime, Math.Round(travelMinutes, 2));
                    bagTimesInfo.Add(bagInfo);
                }
                if (bagTimesInfo.Count > 0)
                    createTimelineTable(htResults, sName, pbcSpecificator, bagTimesInfo, dtBegin, dtEnd, scenarioStep, Levels);
            }

            // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation            
            /*
            private static int getStationDeskIndex_old(string searchedStationCode,
                string fromStationCode, string toStationCode, string fromStationTimeType, 
                string toStationTimeType, DepartingResult drTmp)
            {
                if (searchedStationCode == FROMTO_CI_QUEUE_STATION_CODE)
                    return drTmp.checkInQueueDeskIndex;
                else if (searchedStationCode == FROMTO_TRANSF_QUEUE_STATION_CODE)
                    return drTmp.transferringQueueDeskIndex;
                else if (searchedStationCode == FROMTO_QUEUE_STATION_CODE)
                {
                    if (drTmp.checkInQueueDeskIndex != -1)
                        return drTmp.checkInQueueDeskIndex;
                    else if (drTmp.transferringQueueDeskIndex != -1)
                        return drTmp.transferringQueueDeskIndex;
                }
                else if (searchedStationCode == FROMTO_COLLECTOR_STATION_CODE)
                {
                    if (drTmp.firstCheckInCollectorDeskIndex != -1)
                        return drTmp.firstCheckInCollectorDeskIndex;
                    else if (drTmp.transferringInfeedDeskIndex != -1)
                        return drTmp.transferringInfeedDeskIndex;
                    else if (drTmp.transferringCollectorDeskIndex != -1)
                        return drTmp.transferringCollectorDeskIndex;
                }
                else if (searchedStationCode == FROMTO_CI_COLLECTOR_STATION_CODE)
                    return drTmp.firstCheckInCollectorDeskIndex;
                else if (searchedStationCode == FROMTO_TRANSF_INFEED_STATION_CODE)
                    return drTmp.transferringInfeedDeskIndex;
                else if (searchedStationCode == FROMTO_TRANSF_COLLECTOR_STATION_CODE)
                {
                    if (drTmp.transferringCollectorDeskIndex != -1)
                        return drTmp.transferringCollectorDeskIndex;
                    else if (drTmp.transferringInfeedDeskIndex != -1)
                        return drTmp.transferringInfeedDeskIndex;
                }
                else if (searchedStationCode == FROMTO_CHECKIN_STATION_CODE)
                    return drTmp.CheckInIndex;
                else if (searchedStationCode == FROMTO_DEP_READER_STATION_CODE)
                    return drTmp.DepReaderTimestampDeskIndex;
                else if (searchedStationCode == FROMTO_EBS_STATION_CODE
                    && fromStationCode == FROMTO_EBS_STATION_CODE)
                {
                    string stationCode = toStationCode;
                    if (toStationCode == FROMTO_QUEUE_STATION_CODE)
                        stationCode = getSingleStationCodeFromAbstractStationCode(FROMTO_QUEUE_STATION_CODE, drTmp);
                    else if (toStationCode == FROMTO_COLLECTOR_STATION_CODE)
                        stationCode = getSingleStationCodeFromAbstractStationCode(FROMTO_COLLECTOR_STATION_CODE, drTmp);

                    string toStationKeyword = getStationTraceKeywordByStationCode(stationCode);
                    if (fromStationTimeType == AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING)
                        return drTmp.getFurthestEBSDeskIndexBeforeStationKeyword(toStationKeyword); //furthest ebs from the 'To', before the 'To'
                    else if (fromStationTimeType == AnalysisResultFilter.STATION_TIME_TYPE_LEAVING)
                        return drTmp.getFirstEBSDeskIndexBeforeStationKeyword(toStationKeyword); //closest ebs to the 'To' before the 'To'
                }
                else if (searchedStationCode == FROMTO_EBS_STATION_CODE
                    && toStationCode == FROMTO_EBS_STATION_CODE)
                {
                    string stationCode = toStationCode;
                    if (fromStationCode == FROMTO_QUEUE_STATION_CODE)
                        stationCode = getSingleStationCodeFromAbstractStationCode(FROMTO_QUEUE_STATION_CODE, drTmp);
                    else if (fromStationCode == FROMTO_COLLECTOR_STATION_CODE)
                        stationCode = getSingleStationCodeFromAbstractStationCode(FROMTO_COLLECTOR_STATION_CODE, drTmp);

                    string fromStationKeyword = getStationTraceKeywordByStationCode(stationCode);
                    if (toStationTimeType == AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING)
                        return drTmp.getFirstEBSDeskIndexAfterStationKeyword(fromStationKeyword); //closest ebs to the From, after the From
                    else if (toStationTimeType == AnalysisResultFilter.STATION_TIME_TYPE_LEAVING)
                        return drTmp.getFurthestEBSDeskIndexAfterStationKeyword(fromStationKeyword);//futhest ebs from the From, after the From                                        
                }
                else if (searchedStationCode == FROMTO_LAST_CHUTE_STATION_CODE)
                    return drTmp.LastChuteDeskIndex;
                else if (searchedStationCode == FROMTO_MAKEUP_STATION_CODE)
                    return drTmp.MakeUpIndex;
                else if (searchedStationCode == FROMTO_PRESORTATION_STATION_CODE)
                    return drTmp.firstPresortationDeskIndex;    //depVSUInputDn1_4DeskIndex;   // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation
                return -1;
            }
            */

            private static int getStationDeskIndex(string searchedStationCode,
                string fromStationCode, string toStationCode, string fromStationTimeType,
                string toStationTimeType, DepartingResult drTmp)
            {
                if (searchedStationCode == FROMTO_CI_QUEUE_STATION_CODE)
                    return drTmp.checkInQueueDeskIndex;
                else if (searchedStationCode == FROMTO_TRANSF_QUEUE_STATION_CODE)
                    return drTmp.transferringQueueDeskIndex;
                else if (searchedStationCode == FROMTO_QUEUE_STATION_CODE)
                {
                    if (drTmp.checkInQueueDeskIndex != -1)
                        return drTmp.checkInQueueDeskIndex;
                    else if (drTmp.transferringQueueDeskIndex != -1)
                        return drTmp.transferringQueueDeskIndex;
                }
                else if (searchedStationCode == FROMTO_COLLECTOR_STATION_CODE)
                {
                    if (drTmp.firstCheckInCollectorDeskIndex != -1)
                        return drTmp.firstCheckInCollectorDeskIndex;
                    else if (drTmp.transferringInfeedDeskIndex != -1)
                        return drTmp.transferringInfeedDeskIndex;
                    else if (drTmp.transferringCollectorDeskIndex != -1)
                        return drTmp.transferringCollectorDeskIndex;
                }
                else if (searchedStationCode == FROMTO_CI_COLLECTOR_STATION_CODE)
                    return drTmp.firstCheckInCollectorDeskIndex;
                else if (searchedStationCode == FROMTO_TRANSF_INFEED_STATION_CODE)
                    return drTmp.transferringInfeedDeskIndex;
                else if (searchedStationCode == FROMTO_TRANSF_COLLECTOR_STATION_CODE)
                {
                    if (drTmp.transferringCollectorDeskIndex != -1)
                        return drTmp.transferringCollectorDeskIndex;
                    else if (drTmp.transferringInfeedDeskIndex != -1)
                        return drTmp.transferringInfeedDeskIndex;
                }
                else if (searchedStationCode == FROMTO_CHECKIN_STATION_CODE)
                    return drTmp.CheckInIndex;
                else if (searchedStationCode == FROMTO_DEP_READER_STATION_CODE)
                    return drTmp.DepReaderTimestampDeskIndex;
                else if (searchedStationCode == FROMTO_EBS_STATION_CODE
                    && fromStationCode == FROMTO_EBS_STATION_CODE)
                {
                    string stationCode = toStationCode;
                    if (toStationCode == FROMTO_QUEUE_STATION_CODE)
                        stationCode = getSingleStationCodeFromAbstractStationCode(FROMTO_QUEUE_STATION_CODE, drTmp);
                    else if (toStationCode == FROMTO_COLLECTOR_STATION_CODE)
                        stationCode = getSingleStationCodeFromAbstractStationCode(FROMTO_COLLECTOR_STATION_CODE, drTmp);

                    //string toStationKeyword = getStationTraceKeywordByStationCode(stationCode);
                    List<string> toStationKeywords = getStationTraceKeywordsListByStationCode(stationCode);
                    if (fromStationTimeType == AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING)
                    {
                        return drTmp.getFurthestEBSDeskIndexBeforeFirstOccurenceOfAnyOfGivenStationKeywords(toStationKeywords);
                        //   return drTmp.getFurthestEBSDeskIndexBeforeStationKeyword(toStationKeyword); //furthest ebs from the 'To', before the 'To'
                    }
                    else if (fromStationTimeType == AnalysisResultFilter.STATION_TIME_TYPE_LEAVING)
                    {
                        return drTmp.getFirstEBSDeskIndexBeforeFirstOccurenceOfAnyOfGivenStationKeywords(toStationKeywords);
                        //return drTmp.getFirstEBSDeskIndexBeforeStationKeyword(toStationKeyword); //closest ebs to the 'To' before the 'To'
                    }
                }
                else if (searchedStationCode == FROMTO_EBS_STATION_CODE
                    && toStationCode == FROMTO_EBS_STATION_CODE)
                {
                    string stationCode = toStationCode;
                    if (fromStationCode == FROMTO_QUEUE_STATION_CODE)
                        stationCode = getSingleStationCodeFromAbstractStationCode(FROMTO_QUEUE_STATION_CODE, drTmp);
                    else if (fromStationCode == FROMTO_COLLECTOR_STATION_CODE)
                        stationCode = getSingleStationCodeFromAbstractStationCode(FROMTO_COLLECTOR_STATION_CODE, drTmp);

                    //string fromStationKeyword = getStationTraceKeywordByStationCode(stationCode);
                    List<string> fromStationKeywords = getStationTraceKeywordsListByStationCode(stationCode);
                    if (toStationTimeType == AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING)
                    {
                        return drTmp.getFirstEBSDeskIndexAfterFirstOccurenceOfAnyOfGivenStationKeywords(fromStationKeywords);
                        //return drTmp.getFirstEBSDeskIndexAfterStationKeyword(fromStationKeyword); //closest ebs to the From, after the From
                    }
                    else if (toStationTimeType == AnalysisResultFilter.STATION_TIME_TYPE_LEAVING)
                    {
                        return drTmp.getFurthestEBSDeskIndexAfterFirstOccurenceOfAnyOfGivenStationKeywords(fromStationKeywords);
                        //return drTmp.getFurthestEBSDeskIndexAfterStationKeyword(fromStationKeyword);//futhest ebs from the From, after the From
                    }
                }
                else if (searchedStationCode == FROMTO_LAST_CHUTE_STATION_CODE)
                    return drTmp.LastChuteDeskIndex;
                else if (searchedStationCode == FROMTO_MAKEUP_STATION_CODE)
                    return drTmp.MakeUpIndex;
                else if (searchedStationCode == FROMTO_PRESORTATION_STATION_CODE)
                    return drTmp.firstPresortationDeskIndex;    //depVSUInputDn1_4DeskIndex;   // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation
                return -1;
            }
            // << Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation

            private static string getSingleStationCodeFromAbstractStationCode(string abstractStationCode,
                DepartingResult drTmp)
            {
                if (abstractStationCode == FROMTO_QUEUE_STATION_CODE)
                {
                    if (drTmp.checkInQueueDeskIndex != -1)
                        return FROMTO_CI_QUEUE_STATION_CODE;
                    else if (drTmp.transferringQueueDeskIndex != -1)
                        return FROMTO_TRANSF_QUEUE_STATION_CODE;
                }
                else if (abstractStationCode == FROMTO_COLLECTOR_STATION_CODE)
                {
                    if (drTmp.firstCheckInCollectorDeskIndex != -1)
                        return FROMTO_CI_COLLECTOR_STATION_CODE;
                    else if (drTmp.transferringInfeedDeskIndex != -1)
                        return FROMTO_TRANSF_INFEED_STATION_CODE;
                    else if (drTmp.transferringCollectorDeskIndex != -1)
                        return FROMTO_TRANSF_COLLECTOR_STATION_CODE;
                }
                return "";
            }

            private static string getStationTraceKeywordByStationCode(string stationCode)
            {
                string stationKeyword = stationCode;
                if (stationCode == FROMTO_CI_QUEUE_STATION_CODE)
                    stationKeyword = OriginatingQueue;
                else if (stationCode == FROMTO_TRANSF_QUEUE_STATION_CODE)
                    stationKeyword = TransferringQueue;
                else if (stationCode == FROMTO_CI_COLLECTOR_STATION_CODE)
                    stationKeyword = OriginatingCollector;
                else if (stationCode == FROMTO_TRANSF_INFEED_STATION_CODE)
                    stationKeyword = TransferringInfeed;
                else if (stationCode == FROMTO_TRANSF_COLLECTOR_STATION_CODE)
                    stationKeyword = TransferringCollector;
                else if (stationCode == FROMTO_CHECKIN_STATION_CODE)
                    stationKeyword = Originating;
                else if (stationCode == FROMTO_DEP_READER_STATION_CODE)
                    stationKeyword = sDepReaderTimeStamp;
                else if (stationCode == FROMTO_EBS_STATION_CODE)
                    stationKeyword = OriginatingTransferEBS;
                else if (stationCode == FROMTO_LAST_CHUTE_STATION_CODE)
                    stationKeyword = OriginatingTransferChute;
                else if (stationCode == FROMTO_EXIT_STATION_CODE || stationCode == FROMTO_MAKEUP_STATION_CODE)
                    stationKeyword = OriginatingTransferMU;
                else if (stationCode == FROMTO_PRESORTATION_STATION_CODE)
                    stationKeyword = sDepVSUInputDn;
                return stationKeyword;
            }
            // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation
            private static List<string> getStationTraceKeywordsListByStationCode(string stationCode)
            {
                List<string> stationKeywords = new List<string>();
                if (stationCode == FROMTO_CI_QUEUE_STATION_CODE)
                {
                    stationKeywords.Add(OriginatingQueue);
                }
                else if (stationCode == FROMTO_TRANSF_QUEUE_STATION_CODE)
                {
                    stationKeywords.Add(TransferringQueue);
                }
                else if (stationCode == FROMTO_CI_COLLECTOR_STATION_CODE)
                {
                    stationKeywords.Add(OriginatingCollector);
                }
                else if (stationCode == FROMTO_TRANSF_INFEED_STATION_CODE)
                {
                    stationKeywords.Add(TransferringInfeed);
                }
                else if (stationCode == FROMTO_TRANSF_COLLECTOR_STATION_CODE)
                {
                    stationKeywords.Add(TransferringCollector);
                }
                else if (stationCode == FROMTO_CHECKIN_STATION_CODE)
                {
                    stationKeywords.Add(Originating);
                }
                else if (stationCode == FROMTO_DEP_READER_STATION_CODE)
                {
                    stationKeywords.Add(sDepReaderTimeStamp);
                }
                else if (stationCode == FROMTO_EBS_STATION_CODE)
                {
                    stationKeywords.Add(OriginatingTransferEBS);
                }
                else if (stationCode == FROMTO_LAST_CHUTE_STATION_CODE)
                    stationKeywords.Add(OriginatingTransferChute);
                else if (stationCode == FROMTO_EXIT_STATION_CODE || stationCode == FROMTO_MAKEUP_STATION_CODE)
                {
                    stationKeywords.Add(OriginatingTransferMU);
                }
                else if (stationCode == FROMTO_PRESORTATION_STATION_CODE)
                {
                    stationKeywords.Add(BHS_TRACE_KEYWORD_DEP_PRESORT);
                    stationKeywords.Add(BHS_TRACE_KEYWORD_ORIG_PRESORT);
                    stationKeywords.Add(BHS_TRACE_KEYWORD_TRANSF_PRESORT);
                }
                else
                {
                    stationKeywords.Add(stationCode);
                }
                return stationKeywords;
            }
            // << Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation

            private static string getStationCodeByStationTraceKeyword(string stationKeyword)
            {
                string stationCode = stationKeyword;
                if (stationKeyword == OriginatingQueue)
                    stationCode = FROMTO_CI_QUEUE_STATION_CODE;
                else if (stationKeyword == TransferringQueue)
                    stationCode = FROMTO_TRANSF_QUEUE_STATION_CODE;
                else if (stationKeyword == OriginatingCollector)
                    stationCode = FROMTO_CI_COLLECTOR_STATION_CODE;
                else if (stationKeyword == TransferringInfeed)
                    stationCode = FROMTO_TRANSF_INFEED_STATION_CODE;
                else if (stationKeyword == TransferringCollector)
                    stationCode = FROMTO_TRANSF_COLLECTOR_STATION_CODE;
                else if (stationKeyword == Originating)
                    stationCode = FROMTO_CHECKIN_STATION_CODE;
                else if (stationKeyword == sDepReaderTimeStamp)
                    stationCode = FROMTO_DEP_READER_STATION_CODE;
                else if (stationKeyword == OriginatingTransferEBS)
                    stationCode = FROMTO_EBS_STATION_CODE;
                else if (stationKeyword == OriginatingTransferChute)
                    stationCode = FROMTO_LAST_CHUTE_STATION_CODE;
                else if (stationKeyword == OriginatingTransferMU)
                    stationCode = FROMTO_MAKEUP_STATION_CODE;
                else if (stationKeyword == BHS_TRACE_KEYWORD_DEP_PRESORT || stationKeyword == BHS_TRACE_KEYWORD_ORIG_PRESORT
                    || stationKeyword == BHS_TRACE_KEYWORD_TRANSF_PRESORT) //sDepVSUInputDn)    // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation
                {
                    stationCode = FROMTO_PRESORTATION_STATION_CODE;
                }
                return stationCode;
            }

            private static string getAirportStructureCodeByStationCode(string stationCode)
            {
                //if (stationCode == FROMTO_QUEUE_STATION_CODE ||
                if (stationCode == FROMTO_CI_QUEUE_STATION_CODE || stationCode == FROMTO_TRANSF_QUEUE_STATION_CODE)
                    return "";
                else if (stationCode == FROMTO_CI_COLLECTOR_STATION_CODE)
                    return PAX2SIM.sCheckInCollectorGroup;
                else if (stationCode == FROMTO_TRANSF_COLLECTOR_STATION_CODE || stationCode == FROMTO_TRANSF_INFEED_STATION_CODE)
                    return GestionDonneesHUB2SIM.BHS_String_TransferInfeedGroup;
                else if (stationCode == FROMTO_CHECKIN_STATION_CODE)
                    return PAX2SIM.sCheckInGroup;
                else if (stationCode == FROMTO_DEP_READER_STATION_CODE)
                    return "";
                else if (stationCode == FROMTO_EBS_STATION_CODE)
                    return PAX2SIM.sEBSGroup;
                else if (stationCode == FROMTO_LAST_CHUTE_STATION_CODE)
                    return "";
                else if (stationCode == FROMTO_EXIT_STATION_CODE || stationCode == FROMTO_MAKEUP_STATION_CODE)
                    return PAX2SIM.sMakeUpGroup;
                else if (stationCode == FROMTO_PRESORTATION_STATION_CODE)
                    return "";
                return "";
            }

            private static int getMaxNbRecirculations(string fromStationCode, string toStationCode,
                string fromStationTimeType, string toStationTimeType,
                Dictionary<Int32, BaggageResult> htData,
                DateTime dtBegin, DateTime dtEnd, string mupSegregation, double dWarmUp)
            {
                int maxNbRecirculations = 0;
                foreach (int iResult in htData.Keys)
                {
                    DepartingResult drTmp = (DepartingResult)htData[iResult];
                    DateTime timeAtSystemEntrance = drTmp.GetTimeAtQueue(dtBegin);
                    if (timeAtSystemEntrance != null && timeAtSystemEntrance > dtEnd)
                    {
                        OverallTools.ExternFunctions.PrintLogFile("Bag trace analysis: The baggage with the Id " + drTmp.IDBag
                            + " enters the system at " + timeAtSystemEntrance + "."
                            + " Because the simulation ends at " + dtEnd + " the bag is not considered.");
                        continue;
                    }
                    if (mupSegregation != MUP_SEGREGATION_ALL)
                    {
                        if (makeUpSGroupsDictionary.ContainsKey(mupSegregation))
                        {
                            List<int> s3MupIndexes = makeUpSGroupsDictionary[mupSegregation];
                            if (!s3MupIndexes.Contains(drTmp.MakeUpIndex))
                                continue;
                        }
                    }
                    if ((drTmp.Stopped) || (drTmp.LeavingSystemTime < dWarmUp))
                        continue;
                    if (drTmp.isContainer)
                        continue;
                    if (fromStationCode != FROMTO_ENTRY_STATION_CODE)
                    {
                        int fromStationDeskIndex = getStationDeskIndex(fromStationCode, fromStationCode, toStationCode, fromStationTimeType, toStationTimeType, drTmp);
                        if (fromStationDeskIndex == -1)
                            continue;
                    }
                    if (toStationCode != FROMTO_EXIT_STATION_CODE)
                    {
                        int toStationDeskIndex = getStationDeskIndex(toStationCode, toStationCode, fromStationCode, fromStationTimeType, toStationTimeType, drTmp);
                        if (toStationDeskIndex == -1)
                            continue;
                    }
                    if (drTmp.Recirculation > maxNbRecirculations)
                        maxNbRecirculations = drTmp.Recirculation;
                }
                return maxNbRecirculations;
            }

            private static Dictionary<Int32, BaggageResult> filterBagsByRecirculationNb(int recirculationNb, bool onlyPBC, Dictionary<Int32, BaggageResult> htData,
                DateTime dtBegin, DateTime dtEnd, string mupSegregation, double dWarmUp)
            {
                Dictionary<Int32, BaggageResult> filteredData = new Dictionary<int, BaggageResult>();
                foreach (int iResult in htData.Keys)
                {
                    DepartingResult drTmp = (DepartingResult)htData[iResult];
                    if (mupSegregation != MUP_SEGREGATION_ALL)
                    {
                        int mupIndex = drTmp.MakeUpIndex;
                        if (makeUpSGroupsDictionary.ContainsKey(mupSegregation))
                        {
                            List<int> s3MupIndexes = makeUpSGroupsDictionary[mupSegregation];
                            if (!s3MupIndexes.Contains(mupIndex))
                                continue;
                        }
                    }
                    if (recirculationNb == 0)
                    {
                        if (onlyPBC && drTmp.pbcType == -1)
                            continue;
                        if (!onlyPBC && drTmp.pbcType != -1)
                            continue;
                    }
                    if (drTmp.Stopped || drTmp.LeavingSystemTime < dWarmUp)
                        continue;

                    if (drTmp.Recirculation == recirculationNb)
                        filteredData.Add(iResult, drTmp);
                }
                return filteredData;
            }

            private static void generateFromToDepartingStatistics(string fromStationCode, string toStationCode,
                Dictionary<Int32, BaggageResult> htData, string sName, string sRemainingName,
                string pbcSpecificatorSuffix, double[] Levels, double distributionStep, double scenarioStep, double dWarmUp, bool bHasEBS, int iNbClasses, string mupSegregation,
                DateTime dtBegin, DateTime dtEnd, Hashtable htResults, DataTable globalStats, string recirculationLineSeparator,
                AnalysisResultFilter resultFilter, out DataTable dtStatistics)
            {
                dtStatistics = new DataTable(sName + "__Statistics");
                if (pbcSpecificatorSuffix != "")
                    dtStatistics.TableName += " (" + pbcSpecificatorSuffix + ")";

                dtStatistics.Columns.Add("Type", typeof(String));
                dtStatistics.Columns.Add("Nb Bags", typeof(Int32));
                dtStatistics.Columns.Add(GlobalNames.BHS_STATISTICS_TABLE_PERCENT_OF_GLOBAL_COLUMN_NAME, typeof(Double));
                dtStatistics.Columns.Add("Min", typeof(Double));
                dtStatistics.Columns.Add("Average", typeof(Double));
                dtStatistics.Columns.Add("Max", typeof(Double));
                dtStatistics.Columns.Add(Levels[0].ToString() + " %", typeof(Double));
                dtStatistics.Columns.Add(Levels[1].ToString() + " %", typeof(Double));
                dtStatistics.Columns.Add(Levels[2].ToString() + " %", typeof(Double));

                ArrayList htGlobal = new ArrayList();
                ArrayList htStandardBags = new ArrayList();
                ArrayList htStandardBagsIncludingMES = new ArrayList();
                ArrayList htContainer = new ArrayList();

                ArrayList htNoHBS = new ArrayList();
                ArrayList htNoHBS_MES = new ArrayList();
                ArrayList htNoHBS_NoMES = new ArrayList();
                ArrayList htNoHBS_IntLink = new ArrayList();

                ArrayList htClearAtHBS1 = new ArrayList();
                ArrayList htClearAtHBS1_MES = new ArrayList();
                ArrayList htClearAtHBS1_NoMES = new ArrayList();
                ArrayList htClearAtHBS1_IntLink = new ArrayList();

                ArrayList htClearAtHBS2 = new ArrayList();
                ArrayList htClearAtHBS2_MES = new ArrayList();
                ArrayList htClearAtHBS2_NoMES = new ArrayList();
                ArrayList htClearAtHBS2_IntLink = new ArrayList();

                ArrayList htClearAtHBS3 = new ArrayList();
                ArrayList htClearAtHBS3_MES = new ArrayList();
                ArrayList htClearAtHBS3_WithoutMES = new ArrayList();
                ArrayList htClearAtHBS3_IntLink = new ArrayList();

                ArrayList htClearAtHBS4 = new ArrayList();
                ArrayList htClearAtHBS4_MES = new ArrayList();
                ArrayList htClearAtHBS4_NoMES = new ArrayList();
                ArrayList htClearAtHBS4_IntLink = new ArrayList();

                ArrayList htClearAtHBS5 = new ArrayList();
                ArrayList htClearAtHBS5_MES = new ArrayList();
                ArrayList htClearAtHBS5_NoMES = new ArrayList();
                ArrayList htClearAtHBS5_IntLink = new ArrayList();

                ArrayList htMES = new ArrayList();
                ArrayList htWithoutMES = new ArrayList();
                ArrayList htInterLink = new ArrayList();
                ArrayList htEBS = new ArrayList();

                ArrayList htRemaining = new ArrayList();

                foreach (int iResult in htData.Keys)
                {
                    DepartingResult drTmp = (DepartingResult)htData[iResult];
                    DateTime timeAtSystemEntrance = drTmp.GetTimeAtQueue(dtBegin);
                    if (timeAtSystemEntrance != null && timeAtSystemEntrance > dtEnd)
                    {
                        OverallTools.ExternFunctions.PrintLogFile("Bag trace analysis: The baggage with the Id " + drTmp.IDBag
                            + " enters the system at " + timeAtSystemEntrance + "."
                            + " Because the simulation ends at " + dtEnd + " the bag is not considered.");
                        continue;
                    }

                    if (mupSegregation != MUP_SEGREGATION_ALL)
                    {
                        if (makeUpSGroupsDictionary.ContainsKey(mupSegregation))
                        {
                            List<int> s3MupIndexes = makeUpSGroupsDictionary[mupSegregation];
                            if (!s3MupIndexes.Contains(drTmp.MakeUpIndex))
                                continue;
                        }
                    }
                    if ((drTmp.Stopped) || (drTmp.LeavingSystemTime < dWarmUp))
                        continue;

                    double fromStationMinute = -1;
                    double toStationMinute = -1;
                    double ebsStorageMinutes = -1;
                    double dValue = getFromToMinutesDifference(fromStationCode, toStationCode, resultFilter.fromStationTimeType, resultFilter.toStationTimeType,
                        drTmp, resultFilter.excludeEBSStorageTime, out fromStationMinute, out toStationMinute, out ebsStorageMinutes);
                    if (dValue == -1)
                        continue;

                    if (drTmp.isContainer)
                    {
                        htContainer.Add(dValue);
                        continue;
                    }
                    if (drTmp.STD != -1)
                        htRemaining.Add(drTmp.RemainingTime + dDecallage);

                    htGlobal.Add(dValue);

                    if (!drTmp.HasHBS3 && !drTmp.HasHBS4 && !drTmp.HasHBS5
                        && !drTmp.HasMES && !drTmp.HasInterLink && !drTmp.HasEBS)
                    {
                        if (drTmp.Recirculation != 0 || drTmp.pbcType == -1)
                            htStandardBags.Add(dValue);
                    }

                    if (!drTmp.HasHBS3 && !drTmp.HasHBS4 && !drTmp.HasHBS5
                         && !drTmp.HasInterLink && !drTmp.HasEBS)
                    {
                        if (drTmp.Recirculation != 0 || drTmp.pbcType == -1)
                            htStandardBagsIncludingMES.Add(dValue);
                    }

                    if (!drTmp.HasHBS1 && !drTmp.HasHBS2 && !drTmp.HasHBS3
                        && !drTmp.HasHBS4 && !drTmp.HasHBS5)
                    {
                        htNoHBS.Add(dValue);
                        if (drTmp.HasMES)
                            htNoHBS_MES.Add(dValue);
                        else
                            htNoHBS_NoMES.Add(dValue);
                        if (drTmp.HasInterLink)
                            htNoHBS_IntLink.Add(dValue);
                    }

                    if (drTmp.HasHBS1
                        && !drTmp.HasHBS2 && !drTmp.HasHBS3 && !drTmp.HasHBS4 && !drTmp.HasHBS5)
                    {
                        htClearAtHBS1.Add(dValue);
                        if (drTmp.HasMES)
                            htClearAtHBS1_MES.Add(dValue);
                        else
                            htClearAtHBS1_NoMES.Add(dValue);
                        if (drTmp.HasInterLink)
                            htClearAtHBS1_IntLink.Add(dValue);
                    }

                    if (drTmp.HasHBS2
                        && !drTmp.HasHBS3 && !drTmp.HasHBS4 && !drTmp.HasHBS5)
                    {
                        htClearAtHBS2.Add(dValue);
                        if (drTmp.HasMES)
                            htClearAtHBS2_MES.Add(dValue);
                        else
                            htClearAtHBS2_NoMES.Add(dValue);
                        if (drTmp.HasInterLink)
                            htClearAtHBS2_IntLink.Add(dValue);
                    }

                    if (drTmp.HasHBS3
                        && !drTmp.HasHBS4 && !drTmp.HasHBS5)
                    {
                        htClearAtHBS3.Add(dValue);
                        if (drTmp.HasMES)
                            htClearAtHBS3_MES.Add(dValue);
                        else
                            htClearAtHBS3_WithoutMES.Add(dValue);
                        if (drTmp.HasInterLink)
                            htClearAtHBS3_IntLink.Add(dValue);
                    }

                    if (drTmp.HasHBS4
                        && !drTmp.HasHBS5)
                    {
                        htClearAtHBS4.Add(dValue);
                        if (drTmp.HasMES)
                            htClearAtHBS4_MES.Add(dValue);
                        else
                            htClearAtHBS4_NoMES.Add(dValue);
                        if (drTmp.HasInterLink)
                            htClearAtHBS4_IntLink.Add(dValue);
                    }

                    if (drTmp.HasHBS5)
                    {
                        htClearAtHBS5.Add(dValue);
                        if (drTmp.HasMES)
                            htClearAtHBS5_MES.Add(dValue);
                        else
                            htClearAtHBS5_NoMES.Add(dValue);
                        if (drTmp.HasInterLink)
                            htClearAtHBS5_IntLink.Add(dValue);
                    }

                    if (drTmp.HasMES)
                        htMES.Add(dValue);
                    else
                        htWithoutMES.Add(dValue);

                    if (drTmp.HasInterLink)
                        htInterLink.Add(dValue);
                    if (drTmp.HasEBS)
                    {
                        if (drTmp.Recirculation != 0 || drTmp.pbcType == -1)
                            htEBS.Add(dValue);
                    }
                }

                if (globalStats != null)
                    globalStats.Rows.Add(new Object[] { recirculationLineSeparator });

                if (globalStats != null)
                    ResultFunctions.GenerateDistribution(sName + "_Global" + pbcSpecificatorSuffix, htGlobal, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                DataTable distributionTable = ResultFunctions.GenerateDistribution(sName + "_Global" + pbcSpecificatorSuffix, htGlobal, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                if (htGlobal.Count > 0)
                    htResults.Add(distributionTable.TableName, distributionTable);

                // >> _Times statistics - standard including MES
                //if (globalStats != null)
                //    ResultFunctions.GenerateDistribution(sName + "_MES" + pbcSpecificatorSuffix, htMES, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                //distributionTable = ResultFunctions.GenerateDistribution(sName + "_MES" + pbcSpecificatorSuffix, htMES, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                if (globalStats != null)
                    ResultFunctions.GenerateDistribution(sName + "_Global_MES" + pbcSpecificatorSuffix, htMES, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                distributionTable = ResultFunctions.GenerateDistribution(sName + "_Global_MES" + pbcSpecificatorSuffix, htMES, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                if (htMES.Count > 0)
                    htResults.Add(distributionTable.TableName, distributionTable);

                //if (globalStats != null)
                //    ResultFunctions.GenerateDistribution(sName + "_WithoutMES" + pbcSpecificatorSuffix, htWithoutMES, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                //distributionTable = ResultFunctions.GenerateDistribution(sName + "_WithoutMES" + pbcSpecificatorSuffix, htWithoutMES, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                if (globalStats != null)
                    ResultFunctions.GenerateDistribution(sName + "_Global_WithoutMES" + pbcSpecificatorSuffix, htWithoutMES, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                distributionTable = ResultFunctions.GenerateDistribution(sName + "_Global_WithoutMES" + pbcSpecificatorSuffix, htWithoutMES, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                if (htWithoutMES.Count > 0)
                    htResults.Add(distributionTable.TableName, distributionTable);

                //if (globalStats != null)
                //    ResultFunctions.GenerateDistribution(sName + "_Interlink" + pbcSpecificatorSuffix, htInterLink, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                //distributionTable = ResultFunctions.GenerateDistribution(sName + "_Interlink" + pbcSpecificatorSuffix, htInterLink, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                if (globalStats != null)
                    ResultFunctions.GenerateDistribution(sName + "_Global_Interlink" + pbcSpecificatorSuffix, htInterLink, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                distributionTable = ResultFunctions.GenerateDistribution(sName + "_Global_Interlink" + pbcSpecificatorSuffix, htInterLink, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                if (htInterLink.Count > 0)
                    htResults.Add(distributionTable.TableName, distributionTable);


                //if (globalStats != null)
                //    ResultFunctions.GenerateDistribution(sName + "_Standard_Bags" + pbcSpecificatorSuffix, htStandardBags, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                //distributionTable = ResultFunctions.GenerateDistribution(sName + "_Standard_Bags" + pbcSpecificatorSuffix, htStandardBags, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                if (globalStats != null)
                    ResultFunctions.GenerateDistribution(sName + "_Standard_Bags_WithoutMES" + pbcSpecificatorSuffix, htStandardBags, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                distributionTable = ResultFunctions.GenerateDistribution(sName + "_Standard_Bags_WithoutMES" + pbcSpecificatorSuffix, htStandardBags, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                if (htStandardBags.Count > 0)
                    htResults.Add(distributionTable.TableName, distributionTable);

                if (globalStats != null)
                    ResultFunctions.GenerateDistribution(sName + "_Standard_Bags_InclMES" + pbcSpecificatorSuffix, htStandardBagsIncludingMES, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                distributionTable = ResultFunctions.GenerateDistribution(sName + "_Standard_Bags_InclMES" + pbcSpecificatorSuffix, htStandardBagsIncludingMES, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                if (htStandardBagsIncludingMES.Count > 0)
                    htResults.Add(distributionTable.TableName, distributionTable);


                if (globalStats != null)
                    ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS1" + pbcSpecificatorSuffix, htClearAtHBS1, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                distributionTable = ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS1" + pbcSpecificatorSuffix, htClearAtHBS1, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                if (htClearAtHBS1.Count > 0)
                    htResults.Add(distributionTable.TableName, distributionTable);

                if (globalStats != null)
                    ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS1_MES" + pbcSpecificatorSuffix, htClearAtHBS1_MES, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                distributionTable = ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS1_MES" + pbcSpecificatorSuffix, htClearAtHBS1_MES, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                if (htClearAtHBS1_MES.Count > 0)
                    htResults.Add(distributionTable.TableName, distributionTable);

                if (globalStats != null)
                    ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS1_WithoutMES" + pbcSpecificatorSuffix, htClearAtHBS1_NoMES, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                distributionTable = ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS1_WithoutMES" + pbcSpecificatorSuffix, htClearAtHBS1_NoMES, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                if (htClearAtHBS1_NoMES.Count > 0)
                    htResults.Add(distributionTable.TableName, distributionTable);

                if (globalStats != null)
                    ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS1_InterLink" + pbcSpecificatorSuffix, htClearAtHBS1_IntLink, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                distributionTable = ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS1_InterLink" + pbcSpecificatorSuffix, htClearAtHBS1_IntLink, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                if (htClearAtHBS1_IntLink.Count > 0)
                    htResults.Add(distributionTable.TableName, distributionTable);

                if (globalStats != null)
                    ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS2" + pbcSpecificatorSuffix, htClearAtHBS2, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                distributionTable = ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS2" + pbcSpecificatorSuffix, htClearAtHBS2, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                if (htClearAtHBS2.Count > 0)
                    htResults.Add(distributionTable.TableName, distributionTable);

                if (globalStats != null)
                    ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS2_MES" + pbcSpecificatorSuffix, htClearAtHBS2_MES, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                distributionTable = ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS2_MES" + pbcSpecificatorSuffix, htClearAtHBS2_MES, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                if (htClearAtHBS2_MES.Count > 0)
                    htResults.Add(distributionTable.TableName, distributionTable);

                if (globalStats != null)
                    ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS2_WithoutMES" + pbcSpecificatorSuffix, htClearAtHBS2_NoMES, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                distributionTable = ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS2_WithoutMES" + pbcSpecificatorSuffix, htClearAtHBS2_NoMES, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                if (htClearAtHBS2_NoMES.Count > 0)
                    htResults.Add(distributionTable.TableName, distributionTable);

                if (globalStats != null)
                    ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS2_InterLink" + pbcSpecificatorSuffix, htClearAtHBS2_IntLink, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                distributionTable = ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS2_InterLink" + pbcSpecificatorSuffix, htClearAtHBS2_IntLink, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                if (htClearAtHBS2_IntLink.Count > 0)
                    htResults.Add(distributionTable.TableName, distributionTable);

                if (globalStats != null)
                    ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS3" + pbcSpecificatorSuffix, htClearAtHBS3, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                distributionTable = ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS3" + pbcSpecificatorSuffix, htClearAtHBS3, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                if (htClearAtHBS3.Count > 0)
                    htResults.Add(distributionTable.TableName, distributionTable);

                if (globalStats != null)
                    ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS3_MES" + pbcSpecificatorSuffix, htClearAtHBS3_MES, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                distributionTable = ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS3_MES" + pbcSpecificatorSuffix, htClearAtHBS3_MES, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                if (htClearAtHBS3_MES.Count > 0)
                    htResults.Add(distributionTable.TableName, distributionTable);

                if (globalStats != null)
                    ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS3_WithoutMES" + pbcSpecificatorSuffix, htClearAtHBS3_WithoutMES, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                distributionTable = ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS3_WithoutMES" + pbcSpecificatorSuffix, htClearAtHBS3_WithoutMES, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                if (htClearAtHBS3_WithoutMES.Count > 0)
                    htResults.Add(distributionTable.TableName, distributionTable);

                if (globalStats != null)
                    distributionTable = ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS3_InterLink" + pbcSpecificatorSuffix, htClearAtHBS3_IntLink, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                distributionTable = ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS3_InterLink" + pbcSpecificatorSuffix, htClearAtHBS3_IntLink, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                if (htClearAtHBS3_IntLink.Count > 0)
                    htResults.Add(distributionTable.TableName, distributionTable);

                if (!bDelhi)
                {
                    if (globalStats != null)
                        ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS4" + pbcSpecificatorSuffix, htClearAtHBS4, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                    distributionTable = ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS4" + pbcSpecificatorSuffix, htClearAtHBS4, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                    if (htClearAtHBS4.Count > 0)
                        htResults.Add(distributionTable.TableName, distributionTable);

                    if (globalStats != null)
                        ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS4_MES" + pbcSpecificatorSuffix, htClearAtHBS4_MES, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                    distributionTable = ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS4_MES" + pbcSpecificatorSuffix, htClearAtHBS4_MES, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                    if (htClearAtHBS4_MES.Count > 0)
                        htResults.Add(distributionTable.TableName, distributionTable);

                    if (globalStats != null)
                        ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS4_WithoutMES" + pbcSpecificatorSuffix, htClearAtHBS4_NoMES, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                    distributionTable = ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS4_WithoutMES" + pbcSpecificatorSuffix, htClearAtHBS4_NoMES, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                    if (htClearAtHBS4_NoMES.Count > 0)
                        htResults.Add(distributionTable.TableName, distributionTable);

                    if (globalStats != null)
                        ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS4_InterLink" + pbcSpecificatorSuffix, htClearAtHBS4_IntLink, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                    distributionTable = ResultFunctions.GenerateDistribution(sName + "_ClearAtHBS4_InterLink" + pbcSpecificatorSuffix, htClearAtHBS4_IntLink, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                    if (htClearAtHBS4_IntLink.Count > 0)
                        htResults.Add(distributionTable.TableName, distributionTable);
                }

                String sHBS5 = "ClearAtHBS5";
                String sHBS5_MES = "ClearAtHBS5_MES";
                String sHBS5_NoMES = "ClearAtHBS5_WithoutMES";
                String sHBS5_InterLink = "ClearAtHBS5_InterLink";
                if (bDelhi)
                {
                    sHBS5 = "ClearAtHBS4";
                    sHBS5_MES = "ClearAtHBS4_MES";
                    sHBS5_NoMES = "ClearAtHBS4_WithoutMES";
                    sHBS5_InterLink = "ClearAtHBS4_InterLink";
                }
                if (globalStats != null)
                    ResultFunctions.GenerateDistribution(sName + "_" + sHBS5 + pbcSpecificatorSuffix, htClearAtHBS5, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                distributionTable = ResultFunctions.GenerateDistribution(sName + "_" + sHBS5 + pbcSpecificatorSuffix, htClearAtHBS5, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                if (htClearAtHBS5.Count > 0)
                    htResults.Add(distributionTable.TableName, distributionTable);

                if (globalStats != null)
                    ResultFunctions.GenerateDistribution(sName + "_" + sHBS5_MES + pbcSpecificatorSuffix, htClearAtHBS5_MES, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                distributionTable = ResultFunctions.GenerateDistribution(sName + "_" + sHBS5_MES + pbcSpecificatorSuffix, htClearAtHBS5_MES, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                if (htClearAtHBS5_MES.Count > 0)
                    htResults.Add(distributionTable.TableName, distributionTable);

                if (globalStats != null)
                    ResultFunctions.GenerateDistribution(sName + "_" + sHBS5_NoMES + pbcSpecificatorSuffix, htClearAtHBS5_NoMES, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                distributionTable = ResultFunctions.GenerateDistribution(sName + "_" + sHBS5_NoMES + pbcSpecificatorSuffix, htClearAtHBS5_NoMES, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                if (htClearAtHBS5_NoMES.Count > 0)
                    htResults.Add(distributionTable.TableName, distributionTable);

                if (globalStats != null)
                    ResultFunctions.GenerateDistribution(sName + "_" + sHBS5_InterLink + pbcSpecificatorSuffix, htClearAtHBS5_IntLink, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                distributionTable = ResultFunctions.GenerateDistribution(sName + "_" + sHBS5_InterLink + pbcSpecificatorSuffix, htClearAtHBS5_IntLink, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                if (htClearAtHBS5_IntLink.Count > 0)
                    htResults.Add(distributionTable.TableName, distributionTable);

                if (bHasEBS)
                {
                    if (globalStats != null)
                        ResultFunctions.GenerateDistribution(sName + "_EBS" + pbcSpecificatorSuffix, htEBS, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, globalStats);
                    distributionTable = ResultFunctions.GenerateDistribution(sName + "_EBS" + pbcSpecificatorSuffix, htEBS, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Bags" }, Levels, dtStatistics);
                    if (htEBS.Count > 0)
                        htResults.Add(distributionTable.TableName, distributionTable);
                }

                if (globalStats != null)
                    ResultFunctions.GenerateDistribution(sName + "_ULD" + pbcSpecificatorSuffix, htContainer, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Containers" }, Levels, globalStats);
                distributionTable = ResultFunctions.GenerateDistribution(sName + "_ULD" + pbcSpecificatorSuffix, htContainer, distributionStep, iNbClasses, 0, "Minutes", new String[] { "Nb Containers" }, Levels, dtStatistics);
                if (htContainer.Count > 0)
                    htResults.Add(distributionTable.TableName, distributionTable);


                addTimelineStatistics(fromStationCode, toStationCode, htResults, sName, pbcSpecificatorSuffix, dtBegin, dtEnd, scenarioStep, dWarmUp, Levels, htData,
                     mupSegregation, makeUpSGroupsDictionary, resultFilter);

                htResults.Add(dtStatistics.TableName, dtStatistics);
            }

            private static double getFromToMinutesDifference(string fromStationCode, string toStationCode,
                string fromStationTimeType, string toStationTimeType,
                DepartingResult departingResult, bool excludeEBSStorageTime, out double fromStationMinute,
                out double toStationMinute, out double ebsStorageTime)
            {
                fromStationMinute = -1;
                toStationMinute = -1;
                ebsStorageTime = -1;

                if (fromStationTimeType == AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING)
                {
                    if (fromStationCode == FROMTO_ENTRY_STATION_CODE)
                    {
                        fromStationMinute = departingResult.arrivingMinuteAtFirstStation;
                    }
                    else if (fromStationCode == FROMTO_QUEUE_STATION_CODE)
                    {
                        if (departingResult.checkInQueueArrivingMinute != -1)
                            fromStationMinute = departingResult.checkInQueueArrivingMinute;
                        else if (departingResult.transferQueueArrivingMinute != -1)
                            fromStationMinute = departingResult.transferQueueArrivingMinute;
                    }
                    else if (fromStationCode == FROMTO_CI_QUEUE_STATION_CODE)
                        fromStationMinute = departingResult.checkInQueueArrivingMinute;
                    else if (fromStationCode == FROMTO_TRANSF_QUEUE_STATION_CODE)
                        fromStationMinute = departingResult.transferQueueArrivingMinute;
                    else if (fromStationCode == FROMTO_COLLECTOR_STATION_CODE)
                    {
                        if (departingResult.checkInCollectorArrivingMinute != -1)
                            fromStationMinute = departingResult.checkInCollectorArrivingMinute;
                        else if (departingResult.transferCollectorArrivingMinute != -1)
                            fromStationMinute = departingResult.transferCollectorArrivingMinute;
                        else if (departingResult.transferInfeedArrivingMinute != -1)
                            fromStationMinute = departingResult.transferInfeedArrivingMinute;
                    }
                    else if (fromStationCode == FROMTO_CI_COLLECTOR_STATION_CODE)
                        fromStationMinute = departingResult.checkInCollectorArrivingMinute;
                    else if (fromStationCode == FROMTO_TRANSF_INFEED_STATION_CODE)
                        fromStationMinute = departingResult.transferInfeedArrivingMinute;
                    else if (fromStationCode == FROMTO_TRANSF_COLLECTOR_STATION_CODE)
                    {
                        if (departingResult.transferCollectorArrivingMinute != -1)
                            fromStationMinute = departingResult.transferCollectorArrivingMinute;
                        else if (departingResult.transferInfeedArrivingMinute != -1)
                            fromStationMinute = departingResult.transferInfeedArrivingMinute;
                    }
                    else if (fromStationCode == FROMTO_CHECKIN_STATION_CODE)
                        fromStationMinute = departingResult.CI_Arriving_Minute;
                    else if (fromStationCode == FROMTO_DEP_READER_STATION_CODE)
                        fromStationMinute = departingResult.getArrivingMinuteAtDepReaderTimeStamp();
                    //else if (fromStationCode == FROMTO_PRESORTATION_STATION_CODE)
                    //fromStationMinute = departingResult.firstPresortationArrivingMinute;  // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation
                    else if (fromStationCode == FROMTO_LAST_CHUTE_STATION_CODE)
                        fromStationMinute = departingResult.LastChuteArrivingMinute;
                }
                else if (fromStationTimeType == AnalysisResultFilter.STATION_TIME_TYPE_LEAVING)
                {
                    if (fromStationCode == FROMTO_ENTRY_STATION_CODE)
                    {
                        fromStationMinute = departingResult.leavingMinuteFromFirstStation;
                    }
                    else if (fromStationCode == FROMTO_QUEUE_STATION_CODE)
                    {
                        if (departingResult.checkInQueueLeavingMinute != -1)
                            fromStationMinute = departingResult.checkInQueueLeavingMinute;
                        else if (departingResult.transferQueueLeavingMinute != -1)
                            fromStationMinute = departingResult.transferQueueLeavingMinute;
                    }
                    else if (fromStationCode == FROMTO_CI_QUEUE_STATION_CODE)
                        fromStationMinute = departingResult.checkInQueueLeavingMinute;
                    else if (fromStationCode == FROMTO_TRANSF_QUEUE_STATION_CODE)
                        fromStationMinute = departingResult.transferQueueLeavingMinute;
                    else if (fromStationCode == FROMTO_COLLECTOR_STATION_CODE)
                    {
                        if (departingResult.checkInCollectorLeavingMinute != -1)
                            fromStationMinute = departingResult.checkInCollectorLeavingMinute;
                        else if (departingResult.transferCollectorLeavingMinute != -1)
                            fromStationMinute = departingResult.transferCollectorLeavingMinute;
                        else if (departingResult.transferInfeedLeavingMinute != -1)
                            fromStationMinute = departingResult.transferInfeedLeavingMinute;
                    }
                    else if (fromStationCode == FROMTO_CI_COLLECTOR_STATION_CODE)
                        fromStationMinute = departingResult.checkInCollectorLeavingMinute;
                    else if (fromStationCode == FROMTO_TRANSF_INFEED_STATION_CODE)
                        fromStationMinute = departingResult.transferInfeedLeavingMinute;
                    else if (fromStationCode == FROMTO_TRANSF_COLLECTOR_STATION_CODE)
                    {
                        if (departingResult.transferCollectorLeavingMinute != -1)
                            fromStationMinute = departingResult.transferCollectorLeavingMinute;
                        else if (departingResult.transferInfeedLeavingMinute != -1)
                            fromStationMinute = departingResult.transferInfeedLeavingMinute;
                    }
                    else if (fromStationCode == FROMTO_CHECKIN_STATION_CODE)
                        fromStationMinute = departingResult.CI_Leaving_Minute;
                    else if (fromStationCode == FROMTO_DEP_READER_STATION_CODE)
                        fromStationMinute = departingResult.getLeavingMinuteFromDepReaderTimeStamp();
                    //else if (fromStationCode == FROMTO_PRESORTATION_STATION_CODE)
                    //fromStationMinute = departingResult.firstPresortationLeavingMinute;  // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation
                    else if (fromStationCode == FROMTO_LAST_CHUTE_STATION_CODE)
                        fromStationMinute = departingResult.LastChuteLeavingMinute;
                }

                if (toStationTimeType == AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING)
                {
                    if (toStationCode == FROMTO_EXIT_STATION_CODE)
                    {
                        toStationMinute = departingResult.arrivingMinuteAtLastStation;
                    }
                    else if (toStationCode == FROMTO_CHECKIN_STATION_CODE)
                        toStationMinute = departingResult.CI_Arriving_Minute;
                    else if (toStationCode == FROMTO_COLLECTOR_STATION_CODE)
                    {
                        if (departingResult.checkInCollectorArrivingMinute != -1)
                            toStationMinute = departingResult.checkInCollectorArrivingMinute;
                        else if (departingResult.transferCollectorArrivingMinute != -1)
                            toStationMinute = departingResult.transferCollectorArrivingMinute;
                        else if (departingResult.transferInfeedArrivingMinute != -1)
                            toStationMinute = departingResult.transferInfeedArrivingMinute;
                    }
                    else if (toStationCode == FROMTO_CI_COLLECTOR_STATION_CODE)
                        toStationMinute = departingResult.checkInCollectorArrivingMinute;
                    else if (toStationCode == FROMTO_TRANSF_INFEED_STATION_CODE)
                        toStationMinute = departingResult.transferInfeedArrivingMinute;
                    else if (toStationCode == FROMTO_TRANSF_COLLECTOR_STATION_CODE)
                    {
                        if (departingResult.transferCollectorArrivingMinute != -1)
                            toStationMinute = departingResult.transferCollectorArrivingMinute;
                        else if (departingResult.transferInfeedArrivingMinute != -1)
                            toStationMinute = departingResult.transferInfeedArrivingMinute;
                    }
                    else if (toStationCode == FROMTO_DEP_READER_STATION_CODE)
                        toStationMinute = departingResult.getArrivingMinuteAtDepReaderTimeStamp();
                    //else if (toStationCode == FROMTO_PRESORTATION_STATION_CODE)
                    //toStationMinute = departingResult.firstPresortationArrivingMinute;  //PresortationDepVSUInputDn1_4ArrivingTime;   // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation
                    else if (toStationCode == FROMTO_LAST_CHUTE_STATION_CODE)
                        toStationMinute = departingResult.LastChuteArrivingMinute;
                    else if (toStationCode == FROMTO_MAKEUP_STATION_CODE)
                        toStationMinute = departingResult.getArrivingMinuteAtMup();
                    else if (toStationCode == FROMTO_EXIT_STATION_CODE)
                        toStationMinute = departingResult.arrivingMinuteAtLastStation;
                }
                else if (toStationTimeType == AnalysisResultFilter.STATION_TIME_TYPE_LEAVING)
                {
                    if (toStationCode == FROMTO_EXIT_STATION_CODE)
                    {
                        toStationMinute = departingResult.leavingMinuteFromLastStation;
                    }
                    else if (toStationCode == FROMTO_CHECKIN_STATION_CODE)
                        toStationMinute = departingResult.CI_Leaving_Minute;
                    else if (toStationCode == FROMTO_COLLECTOR_STATION_CODE)
                    {
                        if (departingResult.checkInCollectorLeavingMinute != -1)
                            toStationMinute = departingResult.checkInCollectorLeavingMinute;
                        else if (departingResult.transferCollectorLeavingMinute != -1)
                            toStationMinute = departingResult.transferCollectorLeavingMinute;
                        else if (departingResult.transferInfeedLeavingMinute != -1)
                            toStationMinute = departingResult.transferInfeedLeavingMinute;
                    }
                    else if (toStationCode == FROMTO_CI_COLLECTOR_STATION_CODE)
                        toStationMinute = departingResult.checkInCollectorLeavingMinute;
                    else if (toStationCode == FROMTO_TRANSF_INFEED_STATION_CODE)
                        toStationMinute = departingResult.transferInfeedLeavingMinute;
                    else if (toStationCode == FROMTO_TRANSF_COLLECTOR_STATION_CODE)
                    {
                        if (departingResult.transferCollectorLeavingMinute != -1)
                            toStationMinute = departingResult.transferCollectorLeavingMinute;
                        else if (departingResult.transferInfeedLeavingMinute != -1)
                            toStationMinute = departingResult.transferInfeedLeavingMinute;
                    }
                    else if (toStationCode == FROMTO_DEP_READER_STATION_CODE)
                        toStationMinute = departingResult.getLeavingMinuteFromDepReaderTimeStamp();
                    //else if (toStationCode == FROMTO_PRESORTATION_STATION_CODE)
                    //toStationMinute = departingResult.firstPresortationLeavingMinute; //PresortationDepVSUInputDn1_4LeavingMinute;  // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation
                    else if (toStationCode == FROMTO_LAST_CHUTE_STATION_CODE)
                        toStationMinute = departingResult.LastChuteLeavingMinute;
                    else if (toStationCode == FROMTO_MAKEUP_STATION_CODE)
                        toStationMinute = departingResult.getLeavingMinuteFromMup();
                    else if (toStationCode == FROMTO_EXIT_STATION_CODE)
                        toStationMinute = departingResult.LeavingSystemTime;
                }
                if (fromStationCode == FROMTO_EBS_STATION_CODE)
                {
                    if (fromStationTimeType == AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING)
                        fromStationMinute = departingResult.getArrivingMinuteAtFurthestEBSBeforeGivenMinute(toStationMinute); //furthest ebs from the 'To', before the 'To' //getArrivingMinuteAtFirstEBSBeforeGivenMinute(toStationMinute);
                    else if (fromStationTimeType == AnalysisResultFilter.STATION_TIME_TYPE_LEAVING)
                        fromStationMinute = departingResult.getLeavingMinuteFromFirstEBSBeforeGivenMinute(toStationMinute); //closest ebs to the 'To' before the 'To'
                }
                if (toStationCode == FROMTO_EBS_STATION_CODE)
                {
                    if (toStationTimeType == AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING)
                        toStationMinute = departingResult.getArrivingMinuteAtFirstEBSAfterGivenMinute(fromStationMinute); //closest ebs to the From, after the From
                    else if (toStationTimeType == AnalysisResultFilter.STATION_TIME_TYPE_LEAVING)
                        toStationMinute = departingResult.getLeavingMinuteFromFurthestEBSAfterGivenMinute(fromStationMinute);//futhest ebs from the From, after the From//getLeavingMinuteFromFirstEBSAfterGivenMinute(fromStationMinute);
                }
                // >> Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation
                if (fromStationCode == FROMTO_PRESORTATION_STATION_CODE)
                {
                    if (fromStationTimeType == AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING)
                    {
                        fromStationMinute = departingResult
                            .getArrivingMinuteAtAnyOfGivenStationTypeBeforeAndFurthestFromGivenMinute(BHS_KEYWORDS_LIST_PRESORTATION, toStationMinute); //furthest ebs from the 'To', before the 'To'
                    }
                    else if (fromStationTimeType == AnalysisResultFilter.STATION_TIME_TYPE_LEAVING)
                    {
                        fromStationMinute = departingResult
                            .getLeavingMinuteFromAnyOfGivenStationTypeBeforeAndClosestToGivenMinute(BHS_KEYWORDS_LIST_PRESORTATION, toStationMinute); //closest ebs to the 'To' before the 'To'
                    }
                }
                if (toStationCode == FROMTO_PRESORTATION_STATION_CODE)
                {
                    if (toStationTimeType == AnalysisResultFilter.STATION_TIME_TYPE_ARRIVING)
                    {
                        toStationMinute = departingResult
                            .getArrivingMinuteAtAnyOfGivenStationTypeAfterAndClosestToGivenMinute(BHS_KEYWORDS_LIST_PRESORTATION, fromStationMinute); //closest ebs to the From, after the From
                    }
                    else if (toStationTimeType == AnalysisResultFilter.STATION_TIME_TYPE_LEAVING)
                    {
                        toStationMinute = departingResult
                            .getLeavingMinuteFromAnyOfGivenStationTypeAfterAndFurthestFromGivenMinute(BHS_KEYWORDS_LIST_PRESORTATION, fromStationMinute);//futhest ebs from the From, after the From//getLeavingMinuteFromFirstEBSAfterGivenMinute(fromStationMinute);
                    }
                }
                // << Task #10316 Pax2Sim - BHS - Presortation keyword C#2 Presortation

                ebsStorageTime = departingResult.getEBSStorageMinutesBetweenGivenMinutes(fromStationMinute, toStationMinute);

                if (fromStationMinute == -1 || toStationMinute == -1)
                    return -1;
                if (excludeEBSStorageTime)
                    return toStationMinute - fromStationMinute - ebsStorageTime;
                return toStationMinute - fromStationMinute;
            }

            // << Task #15088 Pax2Sim - BHS Analysis - Times and Indexes

            // >> Task #8223 Pax2Sim - BHS mode - baggs IST statistic change

            // >> Task #13659 IST MakeUp segregation
            /// <summary>
            /// Dictionary: k = make up group code (ex.: MUP_GROUP_S3, MUP_GROUP_S4) 
            /// Dictionary: v = list of indexes for the make-up stations that belong to the group
            /// </summary>
            /// <returns></returns>
            private static Dictionary<string, List<int>> getMakeUpSegregationDictionary(XmlNode airportStructure)
            {
                Dictionary<string, List<int>> makeUpSGroupsDictionary = new Dictionary<string, List<int>>();
                XmlNode[] makeUpGroups = null;
                for (int i = 1; i <= GestionDonneesHUB2SIM.NbTerminaux; i++)
                {
                    makeUpGroups = GestionDonneesHUB2SIM.getGroup(airportStructure, i, PAX2SIM.sMakeUpGroup);
                    if (makeUpGroups != null)
                        break;
                }
                if (makeUpGroups == null)
                {
                    OverallTools.ExternFunctions.PrintLogFile("Error while retrieving the Make-up Segregation data."
                        + " Could not find any Make-up Group in the Airport structure.");
                    return makeUpSGroupsDictionary;
                }
                foreach (XmlNode makeUpGroup in makeUpGroups)
                {
                    if (makeUpGroup.ChildNodes == null)
                        continue;
                    int makeUpGroupIndex = -1;
                    string makeUpGroupDescription = "";
                    if (GestionDonneesHUB2SIM.tryGetResourceIndex(makeUpGroup, out makeUpGroupIndex)
                        && GestionDonneesHUB2SIM.tryGetResourceDescription(makeUpGroup, out makeUpGroupDescription))
                    {
                        string key = MAKE_UP_GROUP_DIRECTORY_PREFIX_NAME + makeUpGroupIndex;//makeUpGroupIndex + "(" + makeUpGroupDescription + ")";
                        if (key.Contains("_"))
                            key = key.Replace("_", "");
                        List<int> mupStationIndexes = new List<int>();
                        foreach (XmlNode makeUpStation in makeUpGroup.ChildNodes)
                        {
                            int makeUpStationIndex = -1;
                            if (GestionDonneesHUB2SIM.tryGetResourceIndex(makeUpStation, out makeUpStationIndex))
                            {
                                mupStationIndexes.Add(makeUpStationIndex);
                                if (maxMakeUpStationIndex < makeUpStationIndex)
                                    maxMakeUpStationIndex = makeUpStationIndex;
                            }
                        }
                        if (!makeUpSGroupsDictionary.ContainsKey(key)
                            && mupStationIndexes.Count > 0)
                        {
                            makeUpSGroupsDictionary.Add(key, mupStationIndexes);
                        }
                        if (!makeUpGroupWithDescriptionDictionary.ContainsKey(key))
                            makeUpGroupWithDescriptionDictionary.Add(key, makeUpGroupDescription);
                    }
                }
                return makeUpSGroupsDictionary;
            }

            private static void addMakeUpStationToDictionary(int makeUpStationIndex,
                string makeUpStationSGroupType, Dictionary<string, List<int>> makeUpSGroupsDictionary)
            {
                if (makeUpSGroupsDictionary.ContainsKey(makeUpStationSGroupType))
                {
                    List<int> mupIndexes = makeUpSGroupsDictionary[makeUpStationSGroupType];
                    if (!mupIndexes.Contains(makeUpStationIndex))
                        mupIndexes.Add(makeUpStationIndex);
                }
                else
                {
                    List<int> mupIndexes = new List<int>();
                    mupIndexes.Add(makeUpStationIndex);
                    makeUpSGroupsDictionary.Add(makeUpStationSGroupType, mupIndexes);
                }
            }
            // << Task #13659 IST MakeUp segregation

            // >> Task #13659 IST MakeUp segregation            
            internal static List<int> mupGroupS3Indexes = new List<int>();
            internal static List<int> mupGroupS4Indexes = new List<int>();

            //internal List<int> MUP_GROUP_S3_INDEXES = new List<int>(new int[] { });
            internal const string MUP_SEGREGATION_ALL = "All";
            internal const string MUP_GROUP_S3 = "MUPS3";
            internal const string MUP_GROUP_S4 = "MUPS4";
            internal const string AIRPORT_STRUCTURE_MUP_GROUP_S3 = "_S3";
            internal const string AIRPORT_STRUCTURE_MUP_GROUP_S4 = "_S4";

            private static int getMakeUpGroupIndexByMakeUpStationIndex(int makeUpStationIndex,
                Dictionary<string, List<int>> makeUpSGroupsDictionary)
            {
                int makeUpGroupIndex = -1;
                foreach (KeyValuePair<string, List<int>> pair in makeUpSGroupsDictionary)
                {
                    List<int> makeUpStationIndexes = pair.Value;
                    if (makeUpStationIndexes.Contains(makeUpStationIndex))
                    {
                        string groupIndexAndDescription = pair.Key;
                        if (groupIndexAndDescription.Contains("("))
                        {
                            string groupNbAsString = groupIndexAndDescription.Substring(0, groupIndexAndDescription.IndexOf("("));
                            Int32.TryParse(groupNbAsString, out makeUpGroupIndex);
                        }
                    }
                }
                return makeUpGroupIndex;
            }
            // << Task #13659 IST MakeUp segregation

            public class BagInfo
            {
                private int _bagId;
                private DateTime _arrivalTime;
                private Double _travelTime;

                public int bagId { get { return _bagId; } set { _bagId = value; } }

                public DateTime arrivalTime { get { return _arrivalTime; } set { _arrivalTime = value; } }

                public Double travelTime { get { return _travelTime; } set { _travelTime = value; } }

                public BagInfo(int bagId, DateTime arrivalTime, Double travelTime)
                {
                    this.bagId = bagId;
                    this.arrivalTime = arrivalTime;
                    this.travelTime = travelTime;
                }
            }

            public static void createTimelineTable(Hashtable htResults, String sName, string pbcSpecificator,
                ArrayList bagTimesInfo, DateTime dtBegin, DateTime dtEnd, Double scenarioStep,
                Double[] Levels)   // >> Bug #14922 Pax2Sim - BHS trace - Time chute to Exit Segregation per line problem
            {
                String timelineTableName = sName + "_Timeline" + pbcSpecificator;

                DataTable timelineTable = new DataTable(timelineTableName);
                timelineTable.Columns.Add("Time", typeof(DateTime));

                int minTravelTimeColumnIndex = timelineTable.Columns.Count;
                timelineTable.Columns.Add("Min Travel Time", typeof(Double));
                int avgTravelTimeColumnIndex = timelineTable.Columns.Count;
                timelineTable.Columns.Add("Average Travel Time", typeof(Double));
                int maxTravelTimeColumnIndex = timelineTable.Columns.Count;
                timelineTable.Columns.Add("Max Travel Time", typeof(Double));
                int nbBagsColumnIndex = timelineTable.Columns.Count;
                timelineTable.Columns.Add("Nb Bags", typeof(Int32));

                int firstLevelColumnIndex = timelineTable.Columns.Count;
                timelineTable.Columns.Add(Levels[0].ToString() + " %", typeof(Double));
                int secondLevelColumnIndex = timelineTable.Columns.Count;
                timelineTable.Columns.Add(Levels[1].ToString() + " %", typeof(Double));
                int thirdLevelColumnIndex = timelineTable.Columns.Count;
                timelineTable.Columns.Add(Levels[2].ToString() + " %", typeof(Double));

                OverallTools.DataFunctions.initialiserLignes(timelineTable, dtBegin, dtEnd, scenarioStep);
                foreach (DataRow row in timelineTable.Rows)
                {
                    row[minTravelTimeColumnIndex] = 0.0d;
                    row[avgTravelTimeColumnIndex] = 0.0d;
                    row[maxTravelTimeColumnIndex] = 0.0d;
                    row[nbBagsColumnIndex] = 0;
                    row[firstLevelColumnIndex] = 0;
                    row[secondLevelColumnIndex] = 0;
                    row[thirdLevelColumnIndex] = 0;
                }
                int rowIndex = 0;
                foreach (DataRow row in timelineTable.Rows)
                {
                    DateTime referenceBeginTime = (DateTime)row[0];
                    DateTime referenceEndTime = DateTime.MinValue;
                    if (rowIndex + 1 < timelineTable.Rows.Count)
                        referenceEndTime = (DateTime)timelineTable.Rows[rowIndex + 1][0];
                    else
                    {
                        DateTime finalTime = (DateTime)row[0];
                        referenceEndTime = finalTime.AddMinutes(scenarioStep);
                    }

                    rowIndex = rowIndex + 1;
                    if (referenceBeginTime != null && referenceEndTime != DateTime.MinValue)
                    {
                        double min = double.MaxValue;
                        double max = double.MinValue;
                        int nbBags = 0;
                        double total = 0;

                        ArrayList bagsOnTimeSlot = new ArrayList();
                        foreach (BagInfo bagInfo in bagTimesInfo)
                        {
                            if (bagInfo.arrivalTime >= referenceBeginTime && bagInfo.arrivalTime < referenceEndTime)
                            {
                                if (bagInfo.travelTime < min)
                                    min = bagInfo.travelTime;
                                if (bagInfo.travelTime > max)
                                    max = bagInfo.travelTime;
                                total += bagInfo.travelTime;
                                nbBags = nbBags + 1;
                                bagsOnTimeSlot.Add(bagInfo.travelTime);
                            }
                        }
                        if (min != double.MaxValue && max != double.MinValue)
                        {
                            row[minTravelTimeColumnIndex] = Math.Round(min, 2);
                            row[avgTravelTimeColumnIndex] = Math.Round((double)total / (double)nbBags, 2);
                            row[maxTravelTimeColumnIndex] = Math.Round(max, 2);
                            row[nbBagsColumnIndex] = nbBags;
                        }
                        if (bagsOnTimeSlot.Count > 0)
                        {
                            bagsOnTimeSlot.Sort();
                            double firstLevelValue = ResultFunctions.getLevelValue(bagsOnTimeSlot, Levels[0]);
                            double secondLevelValue = ResultFunctions.getLevelValue(bagsOnTimeSlot, Levels[1]);
                            double thirdLevelValue = ResultFunctions.getLevelValue(bagsOnTimeSlot, Levels[2]);

                            row[firstLevelColumnIndex] = Math.Round(firstLevelValue, 2);
                            row[secondLevelColumnIndex] = Math.Round(secondLevelValue, 2);
                            row[thirdLevelColumnIndex] = Math.Round(thirdLevelValue, 2);
                        }
                    }
                }
                timelineTable.AcceptChanges();
                htResults.Add(timelineTable.TableName, timelineTable);
            }


            /*  Task #7527 Summaries correction
             *  Modifications:  
             *      - _IST tables - added the Time At Exit, BagId, PaxId and Recirculation nb
             *      - statistics - excluded from the standard bags the containers
             *      - distribution tables for ULD(containers)
             */
            private static void AnalyseTerminating(Hashtable htResults,
                                                  String sName,
                                                  Dictionary<Int32, BaggageResult> htData,
                                                  DateTime dtBegin,
                                                  Double dStep,
                                                  int iNbClasses,
                                                  Double dWarmUp,
                                                  Double[] Levels,
                                                  bool bCollector,
                                                  bool bHasABS,
                                                  DateTime dtEnd)   // >> Task #10926 Pax2Sim - BHS analysis - Filter period problem
            {
                DataTable dtGlobalIST = null;
                // << Task #7527 Summaries correction                
                int iIndexTimeAtQueue = -1;
                int iIndexTimeAtInfeed = -1;
                int iIndexTimeAtCollector = -1;
                int iIndexTimeAtExit = -1;   // << Task #7527 Summaries correction
                int iIndexTimeFromQueue = -1;
                int iIndexTimeFromInfeed = -1;
                int iIndexFlightID = -1;
                int iIndexBagId = -1;    // >> Task #7527 Summaries correction
                int iIndexPaxId = -1;    // >> Task #7527 Summaries correction                              
                int iIndexInfeed = -1;
                int iIndexCollector = -1;
                int iIndexReclaim = -1;
                int iIndexHBS = -1;
                int iIndexABS = -1;
                int iIndexCustom = -1;
                int iIndexStopped = -1;
                int iIndexBeforeWarmUp = -1;
                int iIndexNbRecirculation = -1; // >> Task #7527 Summaries correction
                                                // >> Task #7527 Summaries correction

                // >> Task #10877 Pax2Sim - BHS analysis - local IST tables for all the objects
                #region Terminating BHS stations indexes
                /*
                int termQueuesColumnIndex = -1;        
                int termHBSColumnIndex = -1;
                int termCustomColumnIndex = -1;
                int termABSColumnIndex = -1;
                
                int termPersonalQueueColumnIndex = -1;
                int termStorageColumnIndex = -1;
                int termStorage1ColumnIndex = -1;
                int termStorage2ColumnIndex = -1;
                int termULDMUInUseColumnIndex = -1;
                int termULDEmptyColumnIndex = -1;
                int termULDFullColumnIndex = -1;

                int termSlugsColumnIndex = -1;
                int termWindowColumnIndex = -1;
                int termFlowColumnIndex = -1;
                int termVSUInputDnColumnIndex = -1;
                int termVSUInputUpColumnIndex = -1;
                int termVSUOutputDnColumnIndex = -1;
                int termVSUOutputUpColumnIndex = -1;

                int termPersonalTimestampColumnIndex = -1;
                int termPersonalConvColumnIndex = -1;
                int termPersonalVehColumnIndex = -1;
                int termPersonalWorkCenterColumnIndex = -1;

                int termPersonalSecuColumnIndex = -1;
                int termPersonalPassColumnIndex = -1;
                int termPersonalGateColumnIndex = -1;
                 */
                #endregion
                // << Task #10877 Pax2Sim - BHS analysis - local IST tables for all the objects

                if (bCollector)
                    sName += "Coll";
                else
                {
                    dtGlobalIST = new DataTable("Terminating_IST");

                    iIndexTimeAtQueue = dtGlobalIST.Columns.Count;
                    dtGlobalIST.Columns.Add("Time At Queue", typeof(DateTime));

                    iIndexTimeAtInfeed = dtGlobalIST.Columns.Count;
                    dtGlobalIST.Columns.Add("Time At Infeed", typeof(DateTime));

                    iIndexTimeAtCollector = dtGlobalIST.Columns.Count;
                    dtGlobalIST.Columns.Add("Time At Collector", typeof(DateTime));

                    // << Task #7527 Summaries correction
                    iIndexTimeAtExit = dtGlobalIST.Columns.Count;
                    dtGlobalIST.Columns.Add("Time At Exit", typeof(DateTime));
                    // >> Task #7527 Summaries correction

                    iIndexTimeFromQueue = dtGlobalIST.Columns.Count;
                    dtGlobalIST.Columns.Add("Total time From Queue", typeof(Double));
                    iIndexTimeFromInfeed = dtGlobalIST.Columns.Count;
                    dtGlobalIST.Columns.Add("Total time From Infeed", typeof(Double));

                    iIndexFlightID = dtGlobalIST.Columns.Count;
                    dtGlobalIST.Columns.Add("Flight ID", typeof(Int32));
                    // << Task #7527 Summaries correction
                    iIndexBagId = dtGlobalIST.Columns.Count;
                    dtGlobalIST.Columns.Add(GlobalNames.BAG_ID_IST_TABLE_COLUMN_NAME, typeof(int)); // >> Task #10926 Pax2Sim - BHS analysis - Filter period problem
                    iIndexPaxId = dtGlobalIST.Columns.Count;
                    dtGlobalIST.Columns.Add("PAX ID", typeof(int));
                    // >> Task #7527 Summaries correction

                    iIndexCollector = dtGlobalIST.Columns.Count;
                    dtGlobalIST.Columns.Add("Collector", typeof(Int32));
                    iIndexInfeed = dtGlobalIST.Columns.Count;
                    dtGlobalIST.Columns.Add("Infeed", typeof(Int32));
                    iIndexReclaim = dtGlobalIST.Columns.Count;
                    dtGlobalIST.Columns.Add("Reclaim", typeof(Int32));
                    iIndexHBS = dtGlobalIST.Columns.Count;
                    dtGlobalIST.Columns.Add("HBS", typeof(Int32));    // >> Task #10877 Pax2Sim - BHS analysis - local IST tables for all the objects
                    if (bHasABS)
                    {
                        iIndexABS = dtGlobalIST.Columns.Count;
                        dtGlobalIST.Columns.Add("ABS", typeof(Int32));    // >> Task #10877 Pax2Sim - BHS analysis - local IST tables for all the objects
                    }
                    iIndexCustom = dtGlobalIST.Columns.Count;
                    dtGlobalIST.Columns.Add("Custom", typeof(Int32)); // >> Task #10877 Pax2Sim - BHS analysis - local IST tables for all the objects
                    iIndexStopped = dtGlobalIST.Columns.Count;
                    dtGlobalIST.Columns.Add("Stopped", typeof(Boolean));
                    iIndexBeforeWarmUp = dtGlobalIST.Columns.Count;
                    dtGlobalIST.Columns.Add("Before WarmUp", typeof(Boolean));
                    // << Task #7527 Summaries correction
                    iIndexNbRecirculation = dtGlobalIST.Columns.Count;
                    dtGlobalIST.Columns.Add("Recirculation", typeof(int));
                    // >> Task #7527 Summaries correction

                    // >> Task #10877 Pax2Sim - BHS analysis - local IST tables for all the objects                    
                    // << Task #10877 Pax2Sim - BHS analysis - local IST tables for all the objects
                }

                DataTable dtStatistics = new DataTable(sName + "__Statistics");
                dtStatistics.Columns.Add("Type", typeof(String));
                dtStatistics.Columns.Add("Nb Bags", typeof(Int32));
                dtStatistics.Columns.Add("Min", typeof(Double));
                dtStatistics.Columns.Add("Average", typeof(Double));
                dtStatistics.Columns.Add("Max", typeof(Double));
                dtStatistics.Columns.Add(Levels[0].ToString() + " %", typeof(Double));
                dtStatistics.Columns.Add(Levels[1].ToString() + " %", typeof(Double));
                dtStatistics.Columns.Add(Levels[2].ToString() + " %", typeof(Double));
                ArrayList alGlobal = new ArrayList();
                ArrayList alWithoutHBS = new ArrayList();
                ArrayList alHBS = new ArrayList();
                ArrayList alABS = new ArrayList();
                ArrayList alWithoutABS = new ArrayList();
                ArrayList alCustom = new ArrayList();
                // << Task #7527 Summaries correction
                ArrayList htContainer = new ArrayList();
                // >> Task #7527 Summaries correction
                // << Task #7530 Analyze Bag Trace module - Recirculation statistics
                int maxNbRecirculations = 0;
                // >> Task #7530 Analyze Bag Trace module - Recirculation statistics

                //SDE_Débugg 22/01/2010
                //ArrayList alTooLong = new ArrayList();
                foreach (int iResult in htData.Keys)
                {
                    TerminatingResult drTmp = (TerminatingResult)htData[iResult];

                    DataRow drNewRow = null;
                    if (!bCollector)
                    {
                        // >> Task #10926 Pax2Sim - BHS analysis - Filter period problem
                        DateTime timeAtSystemEntrance = drTmp.GetTimeAtQueue(dtBegin);
                        if (timeAtSystemEntrance != null && timeAtSystemEntrance > dtEnd)
                        {
                            OverallTools.ExternFunctions.PrintLogFile("Bag trace analysis: The baggage with the Id " + drTmp.IDBag
                                + " enters the system at " + timeAtSystemEntrance + "."
                                + " Because the simulation ends at " + dtEnd + " the bag is not considered.");
                            continue;
                        }
                        // << Task #10926 Pax2Sim - BHS analysis - Filter period problem

                        drNewRow = dtGlobalIST.NewRow();
                        if (iIndexTimeAtQueue != -1)
                            drNewRow[iIndexTimeAtQueue] = drTmp.GetTimeAtQueue(dtBegin);
                        if (iIndexTimeAtInfeed != -1)
                            drNewRow[iIndexTimeAtInfeed] = drTmp.GetTimeAtInfeed(dtBegin);
                        if (iIndexTimeAtCollector != -1)
                            drNewRow[iIndexTimeAtCollector] = drTmp.getArrivingDateAtArrivingCollector(dtBegin);
                        // << Task #7527 Summaries correction
                        if (iIndexTimeAtExit != -1)
                            drNewRow[iIndexTimeAtExit] = drTmp.GetTimeAtInfeed(dtBegin).AddMinutes(Math.Round(drTmp.TotalSimulationTime, 2));
                        // >> Task #7527 Summaries correction
                        if (iIndexTimeFromQueue != -1)
                            drNewRow[iIndexTimeFromQueue] = Math.Round(drTmp.TotalTime, 2);
                        if (iIndexTimeFromInfeed != -1)
                            drNewRow[iIndexTimeFromInfeed] = Math.Round(drTmp.TotalSimulationTime, 2);
                        if (iIndexFlightID != -1)
                            drNewRow[iIndexFlightID] = drTmp.FlightID;
                        // << Task #7527 Summaries correction
                        if (iIndexBagId != -1)
                            drNewRow[iIndexBagId] = drTmp.IDBag;
                        if (iIndexPaxId != -1)
                            drNewRow[iIndexPaxId] = drTmp.IDPax;
                        // >> Task #7527 Summaries correction
                        if (iIndexInfeed != -1)
                            drNewRow[iIndexInfeed] = drTmp.InfeedIndex;
                        if (iIndexCollector != -1)
                            drNewRow[iIndexCollector] = drTmp.arrivingCollectorDeskIndex;
                        if (iIndexReclaim != -1)
                            drNewRow[iIndexReclaim] = drTmp.ReclaimIndex;
                        if (iIndexHBS != -1)
                            drNewRow[iIndexHBS] = drTmp.terminatingHBSDeskIndex;    //false;  // >> Task #10877 Pax2Sim - BHS analysis - local IST tables for all the objects
                        if (iIndexABS != -1)
                            drNewRow[iIndexABS] = drTmp.terminatingABSDeskIndex; //false;  // >> Task #10877 Pax2Sim - BHS analysis - local IST tables for all the objects
                        if (iIndexCustom != -1)
                            drNewRow[iIndexCustom] = drTmp.terminatingCustomDeskIndex; //false; // >> Task #10877 Pax2Sim - BHS analysis - local IST tables for all the objects
                        // << Task #7527 Summaries correction
                        if (iIndexNbRecirculation != -1)
                            drNewRow[iIndexNbRecirculation] = drTmp.nbRecirculation;
                        // >> Task #7527 Summaries correction

                        // >> Task #10877 Pax2Sim - BHS analysis - local IST tables for all the objects
                        #region Terminating
                        /*
                        if (termQueuesColumnIndex != -1)
                        {
                            drNewRow[termQueuesColumnIndex] = drTmp.terminatingQueueDeskIndex;
                        }
                        if (termHBSColumnIndex != -1)
                        {
                            drNewRow[termHBSColumnIndex] = drTmp.terminatingHBSDeskIndex;
                        }
                        if (termCustomColumnIndex != -1)
                        {
                            drNewRow[termCustomColumnIndex] = drTmp.terminatingCustomDeskIndex;
                        }
                        if (termABSColumnIndex != -1)
                        {
                            drNewRow[termABSColumnIndex] = drTmp.terminatingABSDeskIndex;
                        }
                        if (termPersonalQueueColumnIndex != -1)
                        {
                            drNewRow[termPersonalQueueColumnIndex] = drTmp.personalTermQueueDeskIndex;
                        }
                        if (termStorageColumnIndex != -1)
                        {
                            drNewRow[termStorageColumnIndex] = drTmp.termStorageDeskIndex;
                        }
                        if (termStorage1ColumnIndex != -1)
                        {
                            drNewRow[termStorage1ColumnIndex] = drTmp.termStorage1DeskIndex;
                        }
                        if (termStorage2ColumnIndex != -1)
                        {
                            drNewRow[termStorage2ColumnIndex] = drTmp.termStorage2DeskIndex;
                        }
                        if (termULDMUInUseColumnIndex != -1)
                        {
                            drNewRow[termULDMUInUseColumnIndex] = drTmp.termULDMUInUsedDeskIndex;
                        }
                        if (termULDEmptyColumnIndex != -1)
                        {
                            drNewRow[termULDEmptyColumnIndex] = drTmp.termULDEmptyStorageDeskIndex;
                        }
                        if (termULDFullColumnIndex != -1)
                        {
                            drNewRow[termULDFullColumnIndex] = drTmp.termULDFullStorageDeskIndex;
                        }
                        if (termSlugsColumnIndex != -1)
                        {
                            drNewRow[termSlugsColumnIndex] = drTmp.termSlugsDeskIndex;
                        }
                        if (termWindowColumnIndex != -1)
                        {
                            drNewRow[termWindowColumnIndex] = drTmp.termWindowDeskIndex;
                        }
                        if (termFlowColumnIndex != -1)
                        {
                            drNewRow[termFlowColumnIndex] = drTmp.termFlowDeskIndex;
                        }
                        if (termVSUInputDnColumnIndex != -1)
                        {
                            drNewRow[termVSUInputDnColumnIndex] = drTmp.termVSUInputDnDeskIndex;
                        }
                        if (termVSUInputUpColumnIndex != -1)
                        {
                            drNewRow[termVSUInputUpColumnIndex] = drTmp.termVSUInputUpDeskIndex;
                        }
                        if (termVSUOutputDnColumnIndex != -1)
                        {
                            drNewRow[termVSUOutputDnColumnIndex] = drTmp.termVSUOutputDnDeskIndex;
                        }
                        if (termVSUOutputUpColumnIndex != -1)
                        {
                            drNewRow[termVSUOutputUpColumnIndex] = drTmp.termVSUOutputUpDeskIndex;
                        }
                        if (termPersonalTimestampColumnIndex != -1)
                        {
                            drNewRow[termPersonalTimestampColumnIndex] = drTmp.personalTermTimeStampDeskIndex;
                        }
                        if (termPersonalConvColumnIndex != -1)
                        {
                            drNewRow[termPersonalConvColumnIndex] = drTmp.personalTermConvDeskIndex;
                        }
                        if (termPersonalVehColumnIndex != -1)
                        {
                            drNewRow[termPersonalVehColumnIndex] = drTmp.personalTermVehDeskIndex;
                        }
                        if (termPersonalWorkCenterColumnIndex != -1)
                        {
                            drNewRow[termPersonalWorkCenterColumnIndex] = drTmp.personalTermWorkCenterDeskIndex;
                        }
                        if (termPersonalSecuColumnIndex != -1)
                        {
                            drNewRow[termPersonalSecuColumnIndex] = drTmp.personalTermSecuDeskIndex;
                        }
                        if (termPersonalPassColumnIndex != -1)
                        {
                            drNewRow[termPersonalPassColumnIndex] = drTmp.personalTermPassDeskIndex;
                        }
                        if (termPersonalGateColumnIndex != -1)
                        {
                            drNewRow[termPersonalGateColumnIndex] = drTmp.personalTermGateDeskIndex;
                        }
                         */
                        #endregion
                        // << Task #10877 Pax2Sim - BHS analysis - local IST tables for all the objects
                    }
                    if ((drTmp.Stopped) || (drTmp.LeavingSystemTime < dWarmUp))
                    {
                        if (drNewRow != null)
                        {
                            if (iIndexHBS != -1)
                                drNewRow[iIndexHBS] = drTmp.terminatingHBSDeskIndex;    //drTmp.HasHBS;   // >> Task #10877 Pax2Sim - BHS analysis - local IST tables for all the objects
                            if (iIndexABS != -1)
                                drNewRow[iIndexABS] = drTmp.terminatingABSDeskIndex;//drTmp.HasABS;   // >> Task #10877 Pax2Sim - BHS analysis - local IST tables for all the objects
                            if (iIndexCustom != -1)
                                drNewRow[iIndexCustom] = drTmp.terminatingCustomDeskIndex;  //drTmp.HasCustom;   // >> Task #10877 Pax2Sim - BHS analysis - local IST tables for all the objects
                            if (iIndexStopped != -1)
                                drNewRow[iIndexStopped] = drTmp.Stopped;
                            if (iIndexBeforeWarmUp != -1)
                                drNewRow[iIndexBeforeWarmUp] = (drTmp.LeavingSystemTime < dWarmUp);
                            dtGlobalIST.Rows.Add(drNewRow);
                        }
                        continue;
                    }

                    //SDE_Débugg 22/01/2010
                    //if (drTmp.TotalSimulationTime > 60)
                    //    alTooLong.Add(drTmp.OldLine);

                    // << Task #7527 Summaries correction
                    if (drTmp.isContainer)
                    {
                        Double containerTime = 0;
                        if (bCollector)
                        {
                            containerTime = drTmp.TotalSimulationTime;
                        }
                        else
                        {
                            containerTime = drTmp.TotalTime;
                        }
                        htContainer.Add(containerTime);
                        continue;
                    }
                    // >> Task #7527 Summaries correction
                    Double dValue;
                    if (bCollector)
                    {
                        dValue = drTmp.TotalSimulationTime;
                    }
                    else
                    {
                        dValue = drTmp.TotalTime;
                    }
                    alGlobal.Add(dValue);

                    if (drTmp.HasHBS)
                    {
                        if (drNewRow != null && iIndexHBS != -1)
                            drNewRow[iIndexHBS] = drTmp.terminatingHBSDeskIndex; //true;   // >> Task #10877 Pax2Sim - BHS analysis - local IST tables for all the objects
                        alHBS.Add(dValue);
                    }
                    else
                        alWithoutHBS.Add(dValue);

                    if (drTmp.HasABS)
                    {
                        if (drNewRow != null && iIndexABS != -1)
                            drNewRow[iIndexABS] = drTmp.terminatingABSDeskIndex; //true;   // >> Task #10877 Pax2Sim - BHS analysis - local IST tables for all the objects
                        alABS.Add(dValue);
                    }
                    else
                        alWithoutABS.Add(dValue);
                    if (drTmp.HasCustom)
                    {
                        if (drNewRow != null && iIndexCustom != -1)
                            drNewRow[iIndexCustom] = drTmp.terminatingCustomDeskIndex;  //true;  // >> Task #10877 Pax2Sim - BHS analysis - local IST tables for all the objects
                        alCustom.Add(dValue);
                    }

                    if (drNewRow != null)
                        dtGlobalIST.Rows.Add(drNewRow);
                    // << Task #7530 Analyze Bag Trace module - Recirculation statistics
                    if (drTmp.Recirculation > maxNbRecirculations)
                        maxNbRecirculations = drTmp.Recirculation;
                    // >> Task #7530 Analyze Bag Trace module - Recirculation statistics                                        
                }
                //SDE_Débugg 22/01/2010
                /*System.IO.StreamWriter swWriter = new StreamWriter("c:\\Terminating_" + sName + ".txt");
                foreach (String sLine in alTooLong)
                    swWriter.WriteLine(sLine);
                swWriter.Close();*/
                ///SDE_Débugg
                if (dtGlobalIST != null)
                {
                    dtGlobalIST.AcceptChanges();
                    htResults.Add(dtGlobalIST.TableName, dtGlobalIST);
                }

                DataTable dtTerminatingDistribution = ResultFunctions.GenerateDistribution(sName + "_Global", alGlobal, dStep, iNbClasses, 0, "Minutes", new string[] { "Nb Bags" }, Levels, dtStatistics);
                htResults.Add(dtTerminatingDistribution.TableName, dtTerminatingDistribution);

                dtTerminatingDistribution = ResultFunctions.GenerateDistribution(sName + "_WithoutHBS", alWithoutHBS, dStep, iNbClasses, 0, "Minutes", new string[] { "Nb Bags" }, Levels, dtStatistics);
                htResults.Add(dtTerminatingDistribution.TableName, dtTerminatingDistribution);

                dtTerminatingDistribution = ResultFunctions.GenerateDistribution(sName + "_HBS", alHBS, dStep, iNbClasses, 0, "Minutes", new string[] { "Nb Bags" }, Levels, dtStatistics);
                htResults.Add(dtTerminatingDistribution.TableName, dtTerminatingDistribution);
                if (bHasABS)
                {
                    dtTerminatingDistribution = ResultFunctions.GenerateDistribution(sName + "_ABS", alABS, dStep, iNbClasses, 0, "Minutes", new string[] { "Nb Bags" }, Levels, dtStatistics);
                    htResults.Add(dtTerminatingDistribution.TableName, dtTerminatingDistribution);
                }

                dtTerminatingDistribution = ResultFunctions.GenerateDistribution(sName + "_WithoutABS", alWithoutABS, dStep, iNbClasses, 0, "Minutes", new string[] { "Nb Bags" }, Levels, dtStatistics);
                htResults.Add(dtTerminatingDistribution.TableName, dtTerminatingDistribution);

                dtTerminatingDistribution = ResultFunctions.GenerateDistribution(sName + "_Custom", alCustom, dStep, iNbClasses, 0, "Minutes", new string[] { "Nb Bags" }, Levels, dtStatistics);
                htResults.Add(dtTerminatingDistribution.TableName, dtTerminatingDistribution);

                // << Task #7527 Summaries correction
                dtTerminatingDistribution = ResultFunctions.GenerateDistribution(sName + "_ULD", htContainer, dStep, iNbClasses, 0, "Minutes", new String[] { "Nb Containers" }, Levels, dtStatistics);
                htResults.Add(dtTerminatingDistribution.TableName, dtTerminatingDistribution);
                // >> Task #7527 Summaries correction

                // << Task #7530 Analyze Bag Trace module - Recirculation statistics                
                createRecirculationResultsFromTerminatingAnalysis(maxNbRecirculations, htResults, sName, dtBegin,
                    htData, dStep, iNbClasses, Levels, bCollector, bHasABS, dtStatistics);
                // >> Task #7530 Analyze Bag Trace module - Recirculation statistics

                htResults.Add(dtStatistics.TableName, dtStatistics);
            }

            // << Task #7530 Analyze Bag Trace module - Recirculation statistics
            private static void createRecirculationResultsFromTerminatingAnalysis(int maxNbRecirculations, Hashtable htResults,
                            String sName, DateTime dtBegin, Dictionary<Int32, BaggageResult> htData, Double dStep, int iNbClasses,
                            Double[] Levels, bool bCollector, bool bHasABS, DataTable dtGlobalStatistics)
            {
                for (int i = 0; i <= maxNbRecirculations; i++)
                {
                    DataTable dtStatistics = new DataTable(sName + "Rec" + i + "__Statistics");
                    dtStatistics.Columns.Add("Type", typeof(String));
                    dtStatistics.Columns.Add("Nb Bags", typeof(Int32));
                    dtStatistics.Columns.Add("Min", typeof(Double));
                    dtStatistics.Columns.Add("Average", typeof(Double));
                    dtStatistics.Columns.Add("Max", typeof(Double));
                    dtStatistics.Columns.Add(Levels[0].ToString() + " %", typeof(Double));
                    dtStatistics.Columns.Add(Levels[1].ToString() + " %", typeof(Double));
                    dtStatistics.Columns.Add(Levels[2].ToString() + " %", typeof(Double));
                    ArrayList alGlobal = new ArrayList();
                    ArrayList alWithoutHBS = new ArrayList();
                    ArrayList alHBS = new ArrayList();
                    ArrayList alABS = new ArrayList();
                    ArrayList alWithoutABS = new ArrayList();
                    ArrayList alCustom = new ArrayList();
                    // << Task #7527 Summaries correction
                    ArrayList htContainer = new ArrayList();
                    // >> Task #7527 Summaries correction

                    foreach (int iResult in htData.Keys)
                    {
                        TerminatingResult drTmp = (TerminatingResult)htData[iResult];
                        if (drTmp.Recirculation == i)
                        {
                            // << Task #7527 Summaries correction
                            if (drTmp.isContainer)
                            {
                                Double containerTime = 0;
                                if (bCollector)
                                {
                                    containerTime = drTmp.TotalSimulationTime;
                                }
                                else
                                {
                                    containerTime = drTmp.TotalTime;
                                }
                                htContainer.Add(containerTime);
                                continue;
                            }
                            // >> Task #7527 Summaries correction
                            Double dValue;
                            if (bCollector)
                                dValue = drTmp.TotalSimulationTime;
                            else
                                dValue = drTmp.TotalTime;

                            alGlobal.Add(dValue);

                            if (drTmp.HasHBS)
                                alHBS.Add(dValue);
                            else
                                alWithoutHBS.Add(dValue);

                            if (drTmp.HasABS)
                                alABS.Add(dValue);
                            else
                                alWithoutABS.Add(dValue);
                            if (drTmp.HasCustom)
                                alCustom.Add(dValue);
                        }
                    }

                    dtGlobalStatistics.Rows.Add(new Object[] { i + " Recirculation(s)" });

                    DataTable dtTerminatingDistribution = ResultFunctions.GenerateDistribution(sName + "Rec" + i + "_Global", alGlobal, dStep, iNbClasses, 0, "Minutes", new string[] { "Nb Bags" }, Levels, dtGlobalStatistics);
                    dtTerminatingDistribution = ResultFunctions.GenerateDistribution(sName + "Rec" + i + "_Global", alGlobal, dStep, iNbClasses, 0, "Minutes", new string[] { "Nb Bags" }, Levels, dtStatistics);
                    htResults.Add(dtTerminatingDistribution.TableName, dtTerminatingDistribution);

                    dtTerminatingDistribution = ResultFunctions.GenerateDistribution(sName + "Rec" + i + "_WithoutHBS", alWithoutHBS, dStep, iNbClasses, 0, "Minutes", new string[] { "Nb Bags" }, Levels, dtGlobalStatistics);
                    dtTerminatingDistribution = ResultFunctions.GenerateDistribution(sName + "Rec" + i + "_WithoutHBS", alWithoutHBS, dStep, iNbClasses, 0, "Minutes", new string[] { "Nb Bags" }, Levels, dtStatistics);
                    htResults.Add(dtTerminatingDistribution.TableName, dtTerminatingDistribution);

                    dtTerminatingDistribution = ResultFunctions.GenerateDistribution(sName + "Rec" + i + "_HBS", alHBS, dStep, iNbClasses, 0, "Minutes", new string[] { "Nb Bags" }, Levels, dtGlobalStatistics);
                    dtTerminatingDistribution = ResultFunctions.GenerateDistribution(sName + "Rec" + i + "_HBS", alHBS, dStep, iNbClasses, 0, "Minutes", new string[] { "Nb Bags" }, Levels, dtStatistics);
                    htResults.Add(dtTerminatingDistribution.TableName, dtTerminatingDistribution);
                    if (bHasABS)
                    {
                        dtTerminatingDistribution = ResultFunctions.GenerateDistribution(sName + "Rec" + i + "_ABS", alABS, dStep, iNbClasses, 0, "Minutes", new string[] { "Nb Bags" }, Levels, dtGlobalStatistics);
                        dtTerminatingDistribution = ResultFunctions.GenerateDistribution(sName + "Rec" + i + "_ABS", alABS, dStep, iNbClasses, 0, "Minutes", new string[] { "Nb Bags" }, Levels, dtStatistics);
                        htResults.Add(dtTerminatingDistribution.TableName, dtTerminatingDistribution);
                    }

                    dtTerminatingDistribution = ResultFunctions.GenerateDistribution(sName + "Rec" + i + "_WithoutABS", alWithoutABS, dStep, iNbClasses, 0, "Minutes", new string[] { "Nb Bags" }, Levels, dtGlobalStatistics);
                    dtTerminatingDistribution = ResultFunctions.GenerateDistribution(sName + "Rec" + i + "_WithoutABS", alWithoutABS, dStep, iNbClasses, 0, "Minutes", new string[] { "Nb Bags" }, Levels, dtStatistics);
                    htResults.Add(dtTerminatingDistribution.TableName, dtTerminatingDistribution);

                    dtTerminatingDistribution = ResultFunctions.GenerateDistribution(sName + "Rec" + i + "_Custom", alCustom, dStep, iNbClasses, 0, "Minutes", new string[] { "Nb Bags" }, Levels, dtGlobalStatistics);
                    dtTerminatingDistribution = ResultFunctions.GenerateDistribution(sName + "Rec" + i + "_Custom", alCustom, dStep, iNbClasses, 0, "Minutes", new string[] { "Nb Bags" }, Levels, dtStatistics);
                    htResults.Add(dtTerminatingDistribution.TableName, dtTerminatingDistribution);

                    // << Task #7527 Summaries correction
                    dtTerminatingDistribution = ResultFunctions.GenerateDistribution(sName + "Rec" + i + "_ULD", htContainer, dStep, iNbClasses, 0, "Minutes", new String[] { "Nb Containers" }, Levels, dtGlobalStatistics);
                    dtTerminatingDistribution = ResultFunctions.GenerateDistribution(sName + "Rec" + i + "_ULD", htContainer, dStep, iNbClasses, 0, "Minutes", new String[] { "Nb Containers" }, Levels, dtStatistics);
                    htResults.Add(dtTerminatingDistribution.TableName, dtTerminatingDistribution);
                    // >> Task #7527 Summaries correction

                    htResults.Add(dtStatistics.TableName, dtStatistics);
                }
            }
            // >> Task #7530 Analyze Bag Trace module - Recirculation statistics

            // >> Task #15088 Pax2Sim - BHS Analysis - Times and Indexes            
            private static void AnalyseTerminating_new(String sName, Dictionary<Int32, BaggageResult> htData, Hashtable htResults,
                DateTime dtBegin, DateTime dtEnd, Double dStep, Double dWarmUp, Double[] Levels, int iNbClasses, bool bHasABS,
                List<AnalysisResultFilter> resultsFilters)
            {
                addGlobalTerminatingISTTable(htData, htResults, dtBegin, dtEnd, dWarmUp, bHasABS);
                generateTerminating();
            }

            private static void addGlobalTerminatingISTTable(Dictionary<Int32, BaggageResult> htData, Hashtable htResults,
                DateTime dtBegin, DateTime dtEnd, Double dWarmUp, bool bHasABS)
            {
                DataTable dtGlobalIST = new DataTable("Terminating_IST");

                #region column indexes
                int iIndexTimeAtQueue = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Time At Queue", typeof(DateTime));
                int iIndexTimeAtInfeed = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Time At Infeed", typeof(DateTime));
                int iIndexTimeAtExit = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Time At Exit", typeof(DateTime));

                int iIndexTimeFromQueue = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Total time From Queue", typeof(Double));
                int iIndexTimeFromInfeed = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Total time From Infeed", typeof(Double));

                int iIndexFlightID = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Flight ID", typeof(Int32));
                int iIndexBagId = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add(GlobalNames.BAG_ID_IST_TABLE_COLUMN_NAME, typeof(int));
                int iIndexPaxId = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("PAX ID", typeof(int));

                int iIndexInfeed = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Infeed", typeof(Int32));
                int iIndexReclaim = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Reclaim", typeof(Int32));
                int iIndexHBS = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("HBS", typeof(Int32));
                int iIndexABS = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("ABS", typeof(Int32));
                int iIndexCustom = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Custom", typeof(Int32));

                int iIndexStopped = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Stopped", typeof(Boolean));
                int iIndexBeforeWarmUp = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Before WarmUp", typeof(Boolean));
                int iIndexNbRecirculation = dtGlobalIST.Columns.Count;
                dtGlobalIST.Columns.Add("Recirculation", typeof(int));
                #endregion

                foreach (int iResult in htData.Keys)
                {
                    TerminatingResult drTmp = (TerminatingResult)htData[iResult];

                    DataRow drNewRow = dtGlobalIST.NewRow();
                    DateTime timeAtSystemEntrance = drTmp.GetTimeAtQueue(dtBegin);
                    if (timeAtSystemEntrance != null && timeAtSystemEntrance > dtEnd)
                    {
                        OverallTools.ExternFunctions.PrintLogFile("Bag trace analysis: The baggage with the Id " + drTmp.IDBag
                            + " enters the system at " + timeAtSystemEntrance + "."
                            + " Because the simulation ends at " + dtEnd + " the bag is not considered.");
                        continue;
                    }

                    drNewRow[iIndexTimeAtQueue] = drTmp.GetTimeAtQueue(dtBegin);
                    drNewRow[iIndexTimeAtInfeed] = drTmp.GetTimeAtInfeed(dtBegin);
                    drNewRow[iIndexTimeAtExit] = drTmp.GetTimeAtInfeed(dtBegin).AddMinutes(Math.Round(drTmp.TotalSimulationTime, 2));

                    drNewRow[iIndexTimeFromQueue] = Math.Round(drTmp.TotalTime, 2);
                    drNewRow[iIndexTimeFromInfeed] = Math.Round(drTmp.TotalSimulationTime, 2);

                    drNewRow[iIndexFlightID] = drTmp.FlightID;
                    drNewRow[iIndexBagId] = drTmp.IDBag;
                    drNewRow[iIndexPaxId] = drTmp.IDPax;

                    drNewRow[iIndexInfeed] = drTmp.InfeedIndex;
                    drNewRow[iIndexReclaim] = drTmp.ReclaimIndex;
                    if (drTmp.HasHBS)
                        drNewRow[iIndexHBS] = drTmp.terminatingHBSDeskIndex;
                    if (bHasABS)
                        drNewRow[iIndexABS] = drTmp.terminatingABSDeskIndex;
                    if (drTmp.HasCustom)
                        drNewRow[iIndexCustom] = drTmp.terminatingCustomDeskIndex;

                    drNewRow[iIndexStopped] = drTmp.Stopped;
                    drNewRow[iIndexBeforeWarmUp] = (drTmp.LeavingSystemTime < dWarmUp);
                    drNewRow[iIndexNbRecirculation] = drTmp.nbRecirculation;
                    dtGlobalIST.Rows.Add(drNewRow);
                }
                dtGlobalIST.AcceptChanges();
                htResults.Add(dtGlobalIST.TableName, dtGlobalIST);
            }

            private static void generateTerminating()
            {

            }
            // << Task #15088 Pax2Sim - BHS Analysis - Times and Indexes

            #endregion
        }
        #endregion

        #region Fonction pour traiter les résultats d'analyse Automod.
        public class AutomodFiles
        {
            /// <summary>
            /// Function which permits to open an automod business graph.
            /// </summary>
            /// <param name="sPath">The location of the  business graphe.</param>
            /// <param name="dtStartDate">The starting date of the business graph</param>
            /// <param name="alErrors">An error list which is filled with the errors that had occureed during the importantion.</param>
            /// <returns>The datatable associated to the business graph. Or null if a problem appears</returns>
            public static DataTable openAutomodGraphic(String sPath, DateTime dtStartDate, ArrayList alErrors)
            {
                if (!System.IO.File.Exists(sPath))
                {
                    alErrors.Add("Err00600 : Graphic path does not exist : \"" + sPath + "\".");
                    return null;
                }
                System.IO.StreamReader srFile = null;
                try
                {
                    srFile = new StreamReader(sPath);
                    if (srFile == null)
                    {
                        alErrors.Add("Err00602 : Unable to open graphic :\"" + sPath + "\".");
                    }
                }
                catch (Exception e)
                {
                    alErrors.Add("Err00601 : Unable to open graphic :\"" + sPath + "\". " + e.Message);
                    OverallTools.ExternFunctions.PrintLogFile("Err00601: openAutomodGraphic throw an exception: " + e.Message);
                    return null;
                }
                int iLine = 1;
                String sLine = srFile.ReadLine();
                Hashtable htParameters = new Hashtable();
                Hashtable htColumns = new Hashtable();
                String[] tsLines;
                bool bXInHours = false;
                bool bXInMinutes = false;
                DataTable dtResult = new DataTable("Graph1");
                try
                {
                    while ((sLine.Length > 0) && (srFile.Peek() != -1))
                    {
                        tsLines = sLine.Split('=');
                        if (tsLines.Length != 2)
                        {
                            alErrors.Add("Warn00603 : Line " + iLine.ToString() + "in the file \"" + sPath + "\". Cannot recognize the line.");
                        }
                        else
                        {
                            String sKey = tsLines[0].Trim();
                            if (sKey == "Graph name")
                                dtResult.TableName = tsLines[1].Trim();
                            else if (sKey == "xlabel")
                            {
                                tsLines = (tsLines[1].Trim()).Split(new String[] { "in" }, StringSplitOptions.RemoveEmptyEntries);
                                if (tsLines.Length != 2)
                                {
                                    alErrors.Add("Warn00604 : Value for xlabel invalid. Unable to find the description for the label column.");
                                    continue;
                                }
                                bXInHours = (tsLines[1].Trim() == "Hours");
                                bXInMinutes = (tsLines[1].Trim() == "Minutes");
                                if (bXInHours || bXInMinutes)
                                {
                                    dtResult.Columns.Add(tsLines[0].Trim(), typeof(DateTime));
                                }
                                else
                                {
                                    dtResult.Columns.Add(tsLines[0].Trim(), typeof(String));
                                }
                            }
                            else if (sKey.StartsWith("column"))
                            {
                                dtResult.Columns.Add(tsLines[1].Trim(), typeof(Double));
                            }

                        }
                        iLine++;
                        sLine = srFile.ReadLine();
                    }
                }
                catch (Exception exc)
                {
                    alErrors.Add("Err00605 : Invalid names for the columns. Two columns have the same name.");
                    OverallTools.ExternFunctions.PrintLogFile("Err00605: openAutomodGraphic throw an exception: " + exc.Message);
                    srFile.Close();
                    return null;
                }
                iLine++;
                sLine = srFile.ReadLine();
                if (sLine == null)
                {
                    alErrors.Add("Err00612 : The file does not have a good format for an Automod graphic. Line " + iLine.ToString() + " does not have a valid format.");
                    srFile.Close();
                    return null;
                }
                tsLines = sLine.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
                if (tsLines.Length != dtResult.Columns.Count)
                {
                    alErrors.Add("Err00606 : The number of columns does not match the defined columns.");
                    srFile.Close();
                    return null;
                }

                if (srFile.Peek() == -1)
                {
                    alErrors.Add("Err00608 : The file does not contain a valid graphic.");
                    srFile.Close();
                    return null;
                }
                iLine++;
                sLine = srFile.ReadLine();
                if (!sLine.StartsWith("-"))
                {
                    alErrors.Add("Err00607 : Unable to locate the line with size information for the columns.");
                    srFile.Close();
                    return null;
                }
                tsLines = sLine.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);

                if (tsLines.Length != dtResult.Columns.Count)
                {
                    alErrors.Add("Err00609 : The number of columns does not match the defined columns.");
                    srFile.Close();
                    return null;
                }
                int i;
                DateTime dtTmp;
                while (srFile.Peek() != -1)
                {
                    iLine++;
                    sLine = srFile.ReadLine();
                    tsLines = sLine.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
                    if (tsLines.Length != dtResult.Columns.Count)
                    {
                        alErrors.Add("Warn00610 : Line \"" + iLine.ToString() + "\" ignored. The number of columns does not match the defined columns.");
                        continue;
                    }
                    Double[] dValues = new double[tsLines.Length];
                    i = 0;
                    if ((!bXInHours) && (!bXInMinutes))
                        i = 1;
                    for (; i < dValues.Length; i++)
                    {
                        if (!Double.TryParse(tsLines[i], out dValues[i]))
                        {
                            alErrors.Add("Warn00611 : Line \"" + iLine.ToString() + "\" ignored. Unable to recognize numerical value at column \"" + i.ToString() + "\".");
                            break;
                        }
                    }
                    if (i != dValues.Length)
                        continue;
                    DataRow drNewRow = dtResult.NewRow();
                    if ((bXInHours) || (bXInMinutes))
                    {
                        if (bXInHours)
                            dtTmp = dtStartDate.AddHours(dValues[0]);
                        else
                            dtTmp = dtStartDate.AddMinutes(dValues[i]);
                        if (dtTmp.Millisecond > 500)
                            dtTmp = dtTmp.AddMilliseconds(1000 - dtTmp.Millisecond);
                        drNewRow[0] = dtTmp;
                    }
                    else
                    {
                        drNewRow[0] = dValues[0];
                    }
                    for (i = 1; i < dValues.Length; i++)
                    {
                        drNewRow[i] = dValues[i];
                    }
                    dtResult.Rows.Add(drNewRow);
                }


                dtResult.AcceptChanges();

                srFile.Close();
                return dtResult;
            }

            public static void GenerateMFF(String sPath, int iSeed)
            {
                try
                {
                    if (!ExternFunctions.CheckCreateDirectory(Directory.GetDirectoryRoot(sPath)))
                        return;
                    System.IO.StreamWriter swFile = new StreamWriter(sPath);
                    swFile.WriteLine("*** Modification File");
                    swFile.WriteLine("Version 5.0");
                    //swFile.WriteLine("Run control init");
                    swFile.WriteLine("RNSet " + iSeed.ToString());
                    swFile.WriteLine();
                    swFile.Close();
                }
                catch (Exception exc)
                {
                    OverallTools.ExternFunctions.PrintLogFile("Except02025: GenerateMFF throw an exception: " + exc.Message);
                }
            }
            public static void GenerateMFF(String pathWithFileName, string dirPath, int iSeed)
            {
                try
                {
                    if (!ExternFunctions.CheckCreateDirectory(dirPath))
                        return;
                    System.IO.StreamWriter swFile = new StreamWriter(pathWithFileName);
                    swFile.WriteLine("*** Modification File");
                    swFile.WriteLine("Version 5.0");
                    //swFile.WriteLine("Run control init");
                    swFile.WriteLine("RNSet " + iSeed.ToString());
                    swFile.WriteLine();
                    swFile.Close();
                }
                catch (Exception exc)
                {
                    OverallTools.ExternFunctions.PrintLogFile("Except02025: GenerateMFF throw an exception: " + exc.Message);
                }
            }
        }
        #endregion

        #region Elements et classes utilisées pour l'analyse 
        internal class TraceTools
        {
            internal class TraceContent
            {
                internal String sDisplayedName;
                internal String sTraceName;
                internal bool bIndexed;
                internal bool bWorkingPoint;
                internal bool bQueue;
                internal TraceContent(String sDisplayedName_,
                            String sTraceName_,
                            bool bIndexed_,
                            bool bWorkingPoint_,
                            bool bQueue_)
                {
                    sDisplayedName = sDisplayedName_;
                    sTraceName = sTraceName_;
                    bIndexed = bIndexed_;
                    bWorkingPoint = bWorkingPoint_;
                    bQueue = bQueue_;
                }
                internal TraceContent(System.Xml.XmlNode xnTraceContent)
                {
                    sTraceName = "";
                    if (OverallTools.FonctionUtiles.hasNamedAttribute(xnTraceContent, "TraceName"))
                        sTraceName = xnTraceContent.Attributes["TraceName"].Value;
                    sDisplayedName = "";
                    if (OverallTools.FonctionUtiles.hasNamedAttribute(xnTraceContent, "DisplayedName"))
                        sDisplayedName = xnTraceContent.Attributes["DisplayedName"].Value;

                    bIndexed = OverallTools.FonctionUtiles.hasNamedAttribute(xnTraceContent, "Indexed");
                    bQueue = OverallTools.FonctionUtiles.hasNamedAttribute(xnTraceContent, "Queue");
                    bWorkingPoint = OverallTools.FonctionUtiles.hasNamedAttribute(xnTraceContent, "WorkingPoint");
                }
                internal System.Xml.XmlNode ToXml(System.Xml.XmlDocument xnDocument)
                {
                    if (xnDocument == null)
                        return null;
                    System.Xml.XmlElement result = xnDocument.CreateElement("TraceContent");
                    result.SetAttribute("TraceName", sTraceName);
                    result.SetAttribute("DisplayedName", sDisplayedName);
                    if (bIndexed)
                        result.SetAttribute("Indexed", true.ToString());
                    if (bQueue)
                        result.SetAttribute("Queue", true.ToString());
                    if (bWorkingPoint)
                        result.SetAttribute("WorkingPoint", true.ToString());
                    return result;
                }
                public override string ToString()
                {
                    return sDisplayedName;
                }

                internal void Dispose()
                {

                }
            }
        }
        #endregion

        #region Accesseurs d'attribut de l'assembly

        internal class AssemblyActions
        {
            public static string AssemblyTitle
            {
                get
                {
                    // Obtenir tous les attributs Title de cet assembly
                    object[] attributes = Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(AssemblyTitleAttribute), false);
                    // Si au moins un attribut Title existe
                    if (attributes.Length > 0)
                    {
                        // Sélectionnez le premier
                        AssemblyTitleAttribute titleAttribute = (AssemblyTitleAttribute)attributes[0];
                        // Si ce n'est pas une chaîne vide, le retourner
                        if (titleAttribute.Title != "")
                            return titleAttribute.Title;
                    }
                    // Si aucun attribut Title n'existe ou si l'attribut Title était la chaîne vide, retourner le nom .exe
                    return System.IO.Path.GetFileNameWithoutExtension(Assembly.GetExecutingAssembly().CodeBase);
                }
            }

            public static string AssemblyVersion
            {
                get
                {
                    String sVersion = Assembly.GetExecutingAssembly().GetName().Version.ToString();
                    if (PAX2SIM.bDelhi)
                        sVersion += ".D";
                    if (PAX2SIM.bAircraftMovementPerFlight)
                        sVersion += ".J";
                    if (PAX2SIM.bJNK)
                        sVersion += ".JNK";
                    if (PAX2SIM.bMultiScenario)
                        sVersion += ".Multi";
                    if (PAX2SIM.bTrialVersion)
                        sVersion += ".Trial";
                    if (PAX2SIM.bAIA)
                        sVersion += ".AIA";
                    if (PAX2SIM.liegeMode)      // >> Task #12808 Pax2Sim - allocation Liege
                        sVersion += ".Liege";
                    if (PAX2SIM.dubaiMode)      // >> Task #14727 Dubai allocation
                        sVersion += ".Dubai";
                    if (PAX2SIM.cdgMode)
                        sVersion += ".CDG";
                    if (PAX2SIM.usaMode)
                        sVersion += ".USA";
                    if (PAX2SIM.isNetworkVersion)    // >> Task #12391 Pax2Sim - Network use - Singapore University
                        sVersion += GlobalNames.NETWORK_VERSION_SUFFIX;
                    if (PAX2SIM.generalAllocationMode)  // >> Task #12790 Allocation app
                        sVersion += ".GeneralAllocationMode";
                    if (PAX2SIM.bDebug)
                        sVersion += ".Debug";
                    return sVersion;
                }
            }

            public static string AssemblyDescription
            {
                get
                {
                    // Obtenir tous les attributs Description de cet assembly
                    object[] attributes = Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(AssemblyDescriptionAttribute), false);
                    // Si aucun attribut Description n'existe, retourner une chaîne vide
                    if (attributes.Length == 0)
                        return "";
                    // Si un attribut Description existe, retourner sa valeur
                    return ((AssemblyDescriptionAttribute)attributes[0]).Description;
                }
            }

            public static string AssemblyProduct
            {
                get
                {
                    // Obtenir tous les attributs Product de cet assembly
                    object[] attributes = Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(AssemblyProductAttribute), false);
                    // Si aucun attribut Product n'existe, retourner une chaîne vide
                    if (attributes.Length == 0)
                        return "";
                    // Si un attribut Product existe, retourner sa valeur
                    return ((AssemblyProductAttribute)attributes[0]).Product;
                }
            }

            public static string AssemblyCopyright
            {
                get
                {
                    // Obtenir tous les attributs Copyright de cet assembly
                    object[] attributes = Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(AssemblyCopyrightAttribute), false);
                    // Si aucun attribut Copyright n'existe, retourner une chaîne vide
                    if (attributes.Length == 0)
                        return "";
                    // Si un attribut Copyright existe, retourner sa valeur
                    return ((AssemblyCopyrightAttribute)attributes[0]).Copyright;
                }
            }

            public static string AssemblyCompany
            {
                get
                {
                    // Obtenir tous les attributs Company de cet assembly
                    object[] attributes = Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(AssemblyCompanyAttribute), false);
                    // Si aucun attribut Company n'existe, retourner une chaîne vide
                    if (attributes.Length == 0)
                        return "";
                    // Si un attribut Company existe, retourner sa valeur
                    return ((AssemblyCompanyAttribute)attributes[0]).Company;
                }
            }

            internal static int getHandle
            {
                get
                {
                    return Process.GetCurrentProcess().Handle.ToInt32();
                }
            }
            internal static int getId
            {
                get
                {
                    return Process.GetCurrentProcess().Id;
                }
            }

            [DllImport("dwmapi.dll", PreserveSig = false)]
            public static extern bool DwmIsCompositionEnabled();

            //TaskbarListClass 
            /*[ComImport(), InterfaceType((short)1), Guid("56FDF342-FD6D-11D0-958A-006097C9A090")]
            public interface ITaskbarList
            {
                void HrInit();

                void AddTab(int hwnd);
                void DeleteTab(int hwnd);
                void ActivateTab(int hwnd);
                void SetActivateAlt(int hwnd);
            }

            /*[ComImport(), Guid("56FDF344-FD6D-11D0-958A-006097C9A090"), ClassInterface(CShort(0)), TypeLibType(CShort(2))]
            public class TaskbarListClass :Itas;*/

            internal static void test()
            {
                if (Environment.OSVersion.Version.Major < 7)
                    return;
                if (!DwmIsCompositionEnabled())
                    return;
                /* TaskbarListClass tt;
                 tt.*/
            }
        }

        #endregion

    }
}


